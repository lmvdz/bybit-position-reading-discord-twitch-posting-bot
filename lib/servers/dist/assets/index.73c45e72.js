(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const n of i)if(n.type==="childList")for(const r of n.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&s(r)}).observe(document,{childList:!0,subtree:!0});function t(i){const n={};return i.integrity&&(n.integrity=i.integrity),i.referrerpolicy&&(n.referrerPolicy=i.referrerpolicy),i.crossorigin==="use-credentials"?n.credentials="include":i.crossorigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function s(i){if(i.ep)return;i.ep=!0;const n=t(i);fetch(i.href,n)}})();var jh=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function My(f){var e=f.default;if(typeof e=="function"){var t=function(){return e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(f).forEach(function(s){var i=Object.getOwnPropertyDescriptor(f,s);Object.defineProperty(t,s,i.get?i:{enumerable:!0,get:function(){return f[s]}})}),t}var ul={},fl={};fl.byteLength=Q2;fl.toByteArray=J2;fl.fromByteArray=sM;var Wn=[],sn=[],X2=typeof Uint8Array<"u"?Uint8Array:Array,pp="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(var bo=0,Y2=pp.length;bo<Y2;++bo)Wn[bo]=pp[bo],sn[pp.charCodeAt(bo)]=bo;sn["-".charCodeAt(0)]=62;sn["_".charCodeAt(0)]=63;function JO(f){var e=f.length;if(e%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var t=f.indexOf("=");t===-1&&(t=e);var s=t===e?0:4-t%4;return[t,s]}function Q2(f){var e=JO(f),t=e[0],s=e[1];return(t+s)*3/4-s}function Z2(f,e,t){return(e+t)*3/4-t}function J2(f){var e,t=JO(f),s=t[0],i=t[1],n=new X2(Z2(f,s,i)),r=0,a=i>0?s-4:s,o;for(o=0;o<a;o+=4)e=sn[f.charCodeAt(o)]<<18|sn[f.charCodeAt(o+1)]<<12|sn[f.charCodeAt(o+2)]<<6|sn[f.charCodeAt(o+3)],n[r++]=e>>16&255,n[r++]=e>>8&255,n[r++]=e&255;return i===2&&(e=sn[f.charCodeAt(o)]<<2|sn[f.charCodeAt(o+1)]>>4,n[r++]=e&255),i===1&&(e=sn[f.charCodeAt(o)]<<10|sn[f.charCodeAt(o+1)]<<4|sn[f.charCodeAt(o+2)]>>2,n[r++]=e>>8&255,n[r++]=e&255),n}function eM(f){return Wn[f>>18&63]+Wn[f>>12&63]+Wn[f>>6&63]+Wn[f&63]}function tM(f,e,t){for(var s,i=[],n=e;n<t;n+=3)s=(f[n]<<16&16711680)+(f[n+1]<<8&65280)+(f[n+2]&255),i.push(eM(s));return i.join("")}function sM(f){for(var e,t=f.length,s=t%3,i=[],n=16383,r=0,a=t-s;r<a;r+=n)i.push(tM(f,r,r+n>a?a:r+n));return s===1?(e=f[t-1],i.push(Wn[e>>2]+Wn[e<<4&63]+"==")):s===2&&(e=(f[t-2]<<8)+f[t-1],i.push(Wn[e>>10]+Wn[e>>4&63]+Wn[e<<2&63]+"=")),i.join("")}var Py={};/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */Py.read=function(f,e,t,s,i){var n,r,a=i*8-s-1,o=(1<<a)-1,d=o>>1,c=-7,u=t?i-1:0,h=t?-1:1,l=f[e+u];for(u+=h,n=l&(1<<-c)-1,l>>=-c,c+=a;c>0;n=n*256+f[e+u],u+=h,c-=8);for(r=n&(1<<-c)-1,n>>=-c,c+=s;c>0;r=r*256+f[e+u],u+=h,c-=8);if(n===0)n=1-d;else{if(n===o)return r?NaN:(l?-1:1)*(1/0);r=r+Math.pow(2,s),n=n-d}return(l?-1:1)*r*Math.pow(2,n-s)};Py.write=function(f,e,t,s,i,n){var r,a,o,d=n*8-i-1,c=(1<<d)-1,u=c>>1,h=i===23?Math.pow(2,-24)-Math.pow(2,-77):0,l=s?0:n-1,p=s?1:-1,m=e<0||e===0&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(a=isNaN(e)?1:0,r=c):(r=Math.floor(Math.log(e)/Math.LN2),e*(o=Math.pow(2,-r))<1&&(r--,o*=2),r+u>=1?e+=h/o:e+=h*Math.pow(2,1-u),e*o>=2&&(r++,o/=2),r+u>=c?(a=0,r=c):r+u>=1?(a=(e*o-1)*Math.pow(2,i),r=r+u):(a=e*Math.pow(2,u-1)*Math.pow(2,i),r=0));i>=8;f[t+l]=a&255,l+=p,a/=256,i-=8);for(r=r<<i|a,d+=i;d>0;f[t+l]=r&255,l+=p,r/=256,d-=8);f[t+l-p]|=m*128};/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */(function(f){const e=fl,t=Py,s=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;f.Buffer=a,f.SlowBuffer=b,f.INSPECT_MAX_BYTES=50;const i=2147483647;f.kMaxLength=i,a.TYPED_ARRAY_SUPPORT=n(),!a.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function n(){try{const L=new Uint8Array(1),C={foo:function(){return 42}};return Object.setPrototypeOf(C,Uint8Array.prototype),Object.setPrototypeOf(L,C),L.foo()===42}catch{return!1}}Object.defineProperty(a.prototype,"parent",{enumerable:!0,get:function(){if(!!a.isBuffer(this))return this.buffer}}),Object.defineProperty(a.prototype,"offset",{enumerable:!0,get:function(){if(!!a.isBuffer(this))return this.byteOffset}});function r(L){if(L>i)throw new RangeError('The value "'+L+'" is invalid for option "size"');const C=new Uint8Array(L);return Object.setPrototypeOf(C,a.prototype),C}function a(L,C,B){if(typeof L=="number"){if(typeof C=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return u(L)}return o(L,C,B)}a.poolSize=8192;function o(L,C,B){if(typeof L=="string")return h(L,C);if(ArrayBuffer.isView(L))return p(L);if(L==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof L);if(de(L,ArrayBuffer)||L&&de(L.buffer,ArrayBuffer)||typeof SharedArrayBuffer<"u"&&(de(L,SharedArrayBuffer)||L&&de(L.buffer,SharedArrayBuffer)))return m(L,C,B);if(typeof L=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const z=L.valueOf&&L.valueOf();if(z!=null&&z!==L)return a.from(z,C,B);const Y=g(L);if(Y)return Y;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof L[Symbol.toPrimitive]=="function")return a.from(L[Symbol.toPrimitive]("string"),C,B);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof L)}a.from=function(L,C,B){return o(L,C,B)},Object.setPrototypeOf(a.prototype,Uint8Array.prototype),Object.setPrototypeOf(a,Uint8Array);function d(L){if(typeof L!="number")throw new TypeError('"size" argument must be of type number');if(L<0)throw new RangeError('The value "'+L+'" is invalid for option "size"')}function c(L,C,B){return d(L),L<=0?r(L):C!==void 0?typeof B=="string"?r(L).fill(C,B):r(L).fill(C):r(L)}a.alloc=function(L,C,B){return c(L,C,B)};function u(L){return d(L),r(L<0?0:y(L)|0)}a.allocUnsafe=function(L){return u(L)},a.allocUnsafeSlow=function(L){return u(L)};function h(L,C){if((typeof C!="string"||C==="")&&(C="utf8"),!a.isEncoding(C))throw new TypeError("Unknown encoding: "+C);const B=w(L,C)|0;let z=r(B);const Y=z.write(L,C);return Y!==B&&(z=z.slice(0,Y)),z}function l(L){const C=L.length<0?0:y(L.length)|0,B=r(C);for(let z=0;z<C;z+=1)B[z]=L[z]&255;return B}function p(L){if(de(L,Uint8Array)){const C=new Uint8Array(L);return m(C.buffer,C.byteOffset,C.byteLength)}return l(L)}function m(L,C,B){if(C<0||L.byteLength<C)throw new RangeError('"offset" is outside of buffer bounds');if(L.byteLength<C+(B||0))throw new RangeError('"length" is outside of buffer bounds');let z;return C===void 0&&B===void 0?z=new Uint8Array(L):B===void 0?z=new Uint8Array(L,C):z=new Uint8Array(L,C,B),Object.setPrototypeOf(z,a.prototype),z}function g(L){if(a.isBuffer(L)){const C=y(L.length)|0,B=r(C);return B.length===0||L.copy(B,0,0,C),B}if(L.length!==void 0)return typeof L.length!="number"||we(L.length)?r(0):l(L);if(L.type==="Buffer"&&Array.isArray(L.data))return l(L.data)}function y(L){if(L>=i)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+i.toString(16)+" bytes");return L|0}function b(L){return+L!=L&&(L=0),a.alloc(+L)}a.isBuffer=function(C){return C!=null&&C._isBuffer===!0&&C!==a.prototype},a.compare=function(C,B){if(de(C,Uint8Array)&&(C=a.from(C,C.offset,C.byteLength)),de(B,Uint8Array)&&(B=a.from(B,B.offset,B.byteLength)),!a.isBuffer(C)||!a.isBuffer(B))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(C===B)return 0;let z=C.length,Y=B.length;for(let se=0,re=Math.min(z,Y);se<re;++se)if(C[se]!==B[se]){z=C[se],Y=B[se];break}return z<Y?-1:Y<z?1:0},a.isEncoding=function(C){switch(String(C).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},a.concat=function(C,B){if(!Array.isArray(C))throw new TypeError('"list" argument must be an Array of Buffers');if(C.length===0)return a.alloc(0);let z;if(B===void 0)for(B=0,z=0;z<C.length;++z)B+=C[z].length;const Y=a.allocUnsafe(B);let se=0;for(z=0;z<C.length;++z){let re=C[z];if(de(re,Uint8Array))se+re.length>Y.length?(a.isBuffer(re)||(re=a.from(re)),re.copy(Y,se)):Uint8Array.prototype.set.call(Y,re,se);else if(a.isBuffer(re))re.copy(Y,se);else throw new TypeError('"list" argument must be an Array of Buffers');se+=re.length}return Y};function w(L,C){if(a.isBuffer(L))return L.length;if(ArrayBuffer.isView(L)||de(L,ArrayBuffer))return L.byteLength;if(typeof L!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof L);const B=L.length,z=arguments.length>2&&arguments[2]===!0;if(!z&&B===0)return 0;let Y=!1;for(;;)switch(C){case"ascii":case"latin1":case"binary":return B;case"utf8":case"utf-8":return J(L).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return B*2;case"hex":return B>>>1;case"base64":return ce(L).length;default:if(Y)return z?-1:J(L).length;C=(""+C).toLowerCase(),Y=!0}}a.byteLength=w;function S(L,C,B){let z=!1;if((C===void 0||C<0)&&(C=0),C>this.length||((B===void 0||B>this.length)&&(B=this.length),B<=0)||(B>>>=0,C>>>=0,B<=C))return"";for(L||(L="utf8");;)switch(L){case"hex":return F(this,C,B);case"utf8":case"utf-8":return A(this,C,B);case"ascii":return R(this,C,B);case"latin1":case"binary":return H(this,C,B);case"base64":return O(this,C,B);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return P(this,C,B);default:if(z)throw new TypeError("Unknown encoding: "+L);L=(L+"").toLowerCase(),z=!0}}a.prototype._isBuffer=!0;function k(L,C,B){const z=L[C];L[C]=L[B],L[B]=z}a.prototype.swap16=function(){const C=this.length;if(C%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let B=0;B<C;B+=2)k(this,B,B+1);return this},a.prototype.swap32=function(){const C=this.length;if(C%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let B=0;B<C;B+=4)k(this,B,B+3),k(this,B+1,B+2);return this},a.prototype.swap64=function(){const C=this.length;if(C%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let B=0;B<C;B+=8)k(this,B,B+7),k(this,B+1,B+6),k(this,B+2,B+5),k(this,B+3,B+4);return this},a.prototype.toString=function(){const C=this.length;return C===0?"":arguments.length===0?A(this,0,C):S.apply(this,arguments)},a.prototype.toLocaleString=a.prototype.toString,a.prototype.equals=function(C){if(!a.isBuffer(C))throw new TypeError("Argument must be a Buffer");return this===C?!0:a.compare(this,C)===0},a.prototype.inspect=function(){let C="";const B=f.INSPECT_MAX_BYTES;return C=this.toString("hex",0,B).replace(/(.{2})/g,"$1 ").trim(),this.length>B&&(C+=" ... "),"<Buffer "+C+">"},s&&(a.prototype[s]=a.prototype.inspect),a.prototype.compare=function(C,B,z,Y,se){if(de(C,Uint8Array)&&(C=a.from(C,C.offset,C.byteLength)),!a.isBuffer(C))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof C);if(B===void 0&&(B=0),z===void 0&&(z=C?C.length:0),Y===void 0&&(Y=0),se===void 0&&(se=this.length),B<0||z>C.length||Y<0||se>this.length)throw new RangeError("out of range index");if(Y>=se&&B>=z)return 0;if(Y>=se)return-1;if(B>=z)return 1;if(B>>>=0,z>>>=0,Y>>>=0,se>>>=0,this===C)return 0;let re=se-Y,Be=z-B;const $e=Math.min(re,Be),Ne=this.slice(Y,se),Fe=C.slice(B,z);for(let rt=0;rt<$e;++rt)if(Ne[rt]!==Fe[rt]){re=Ne[rt],Be=Fe[rt];break}return re<Be?-1:Be<re?1:0};function T(L,C,B,z,Y){if(L.length===0)return-1;if(typeof B=="string"?(z=B,B=0):B>2147483647?B=2147483647:B<-2147483648&&(B=-2147483648),B=+B,we(B)&&(B=Y?0:L.length-1),B<0&&(B=L.length+B),B>=L.length){if(Y)return-1;B=L.length-1}else if(B<0)if(Y)B=0;else return-1;if(typeof C=="string"&&(C=a.from(C,z)),a.isBuffer(C))return C.length===0?-1:I(L,C,B,z,Y);if(typeof C=="number")return C=C&255,typeof Uint8Array.prototype.indexOf=="function"?Y?Uint8Array.prototype.indexOf.call(L,C,B):Uint8Array.prototype.lastIndexOf.call(L,C,B):I(L,[C],B,z,Y);throw new TypeError("val must be string, number or Buffer")}function I(L,C,B,z,Y){let se=1,re=L.length,Be=C.length;if(z!==void 0&&(z=String(z).toLowerCase(),z==="ucs2"||z==="ucs-2"||z==="utf16le"||z==="utf-16le")){if(L.length<2||C.length<2)return-1;se=2,re/=2,Be/=2,B/=2}function $e(Fe,rt){return se===1?Fe[rt]:Fe.readUInt16BE(rt*se)}let Ne;if(Y){let Fe=-1;for(Ne=B;Ne<re;Ne++)if($e(L,Ne)===$e(C,Fe===-1?0:Ne-Fe)){if(Fe===-1&&(Fe=Ne),Ne-Fe+1===Be)return Fe*se}else Fe!==-1&&(Ne-=Ne-Fe),Fe=-1}else for(B+Be>re&&(B=re-Be),Ne=B;Ne>=0;Ne--){let Fe=!0;for(let rt=0;rt<Be;rt++)if($e(L,Ne+rt)!==$e(C,rt)){Fe=!1;break}if(Fe)return Ne}return-1}a.prototype.includes=function(C,B,z){return this.indexOf(C,B,z)!==-1},a.prototype.indexOf=function(C,B,z){return T(this,C,B,z,!0)},a.prototype.lastIndexOf=function(C,B,z){return T(this,C,B,z,!1)};function _(L,C,B,z){B=Number(B)||0;const Y=L.length-B;z?(z=Number(z),z>Y&&(z=Y)):z=Y;const se=C.length;z>se/2&&(z=se/2);let re;for(re=0;re<z;++re){const Be=parseInt(C.substr(re*2,2),16);if(we(Be))return re;L[B+re]=Be}return re}function N(L,C,B,z){return ie(J(C,L.length-B),L,B,z)}function M(L,C,B,z){return ie(ee(C),L,B,z)}function x(L,C,B,z){return ie(ce(C),L,B,z)}function v(L,C,B,z){return ie(ne(C,L.length-B),L,B,z)}a.prototype.write=function(C,B,z,Y){if(B===void 0)Y="utf8",z=this.length,B=0;else if(z===void 0&&typeof B=="string")Y=B,z=this.length,B=0;else if(isFinite(B))B=B>>>0,isFinite(z)?(z=z>>>0,Y===void 0&&(Y="utf8")):(Y=z,z=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const se=this.length-B;if((z===void 0||z>se)&&(z=se),C.length>0&&(z<0||B<0)||B>this.length)throw new RangeError("Attempt to write outside buffer bounds");Y||(Y="utf8");let re=!1;for(;;)switch(Y){case"hex":return _(this,C,B,z);case"utf8":case"utf-8":return N(this,C,B,z);case"ascii":case"latin1":case"binary":return M(this,C,B,z);case"base64":return x(this,C,B,z);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return v(this,C,B,z);default:if(re)throw new TypeError("Unknown encoding: "+Y);Y=(""+Y).toLowerCase(),re=!0}},a.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function O(L,C,B){return C===0&&B===L.length?e.fromByteArray(L):e.fromByteArray(L.slice(C,B))}function A(L,C,B){B=Math.min(L.length,B);const z=[];let Y=C;for(;Y<B;){const se=L[Y];let re=null,Be=se>239?4:se>223?3:se>191?2:1;if(Y+Be<=B){let $e,Ne,Fe,rt;switch(Be){case 1:se<128&&(re=se);break;case 2:$e=L[Y+1],($e&192)===128&&(rt=(se&31)<<6|$e&63,rt>127&&(re=rt));break;case 3:$e=L[Y+1],Ne=L[Y+2],($e&192)===128&&(Ne&192)===128&&(rt=(se&15)<<12|($e&63)<<6|Ne&63,rt>2047&&(rt<55296||rt>57343)&&(re=rt));break;case 4:$e=L[Y+1],Ne=L[Y+2],Fe=L[Y+3],($e&192)===128&&(Ne&192)===128&&(Fe&192)===128&&(rt=(se&15)<<18|($e&63)<<12|(Ne&63)<<6|Fe&63,rt>65535&&rt<1114112&&(re=rt))}}re===null?(re=65533,Be=1):re>65535&&(re-=65536,z.push(re>>>10&1023|55296),re=56320|re&1023),z.push(re),Y+=Be}return q(z)}const V=4096;function q(L){const C=L.length;if(C<=V)return String.fromCharCode.apply(String,L);let B="",z=0;for(;z<C;)B+=String.fromCharCode.apply(String,L.slice(z,z+=V));return B}function R(L,C,B){let z="";B=Math.min(L.length,B);for(let Y=C;Y<B;++Y)z+=String.fromCharCode(L[Y]&127);return z}function H(L,C,B){let z="";B=Math.min(L.length,B);for(let Y=C;Y<B;++Y)z+=String.fromCharCode(L[Y]);return z}function F(L,C,B){const z=L.length;(!C||C<0)&&(C=0),(!B||B<0||B>z)&&(B=z);let Y="";for(let se=C;se<B;++se)Y+=ue[L[se]];return Y}function P(L,C,B){const z=L.slice(C,B);let Y="";for(let se=0;se<z.length-1;se+=2)Y+=String.fromCharCode(z[se]+z[se+1]*256);return Y}a.prototype.slice=function(C,B){const z=this.length;C=~~C,B=B===void 0?z:~~B,C<0?(C+=z,C<0&&(C=0)):C>z&&(C=z),B<0?(B+=z,B<0&&(B=0)):B>z&&(B=z),B<C&&(B=C);const Y=this.subarray(C,B);return Object.setPrototypeOf(Y,a.prototype),Y};function E(L,C,B){if(L%1!==0||L<0)throw new RangeError("offset is not uint");if(L+C>B)throw new RangeError("Trying to access beyond buffer length")}a.prototype.readUintLE=a.prototype.readUIntLE=function(C,B,z){C=C>>>0,B=B>>>0,z||E(C,B,this.length);let Y=this[C],se=1,re=0;for(;++re<B&&(se*=256);)Y+=this[C+re]*se;return Y},a.prototype.readUintBE=a.prototype.readUIntBE=function(C,B,z){C=C>>>0,B=B>>>0,z||E(C,B,this.length);let Y=this[C+--B],se=1;for(;B>0&&(se*=256);)Y+=this[C+--B]*se;return Y},a.prototype.readUint8=a.prototype.readUInt8=function(C,B){return C=C>>>0,B||E(C,1,this.length),this[C]},a.prototype.readUint16LE=a.prototype.readUInt16LE=function(C,B){return C=C>>>0,B||E(C,2,this.length),this[C]|this[C+1]<<8},a.prototype.readUint16BE=a.prototype.readUInt16BE=function(C,B){return C=C>>>0,B||E(C,2,this.length),this[C]<<8|this[C+1]},a.prototype.readUint32LE=a.prototype.readUInt32LE=function(C,B){return C=C>>>0,B||E(C,4,this.length),(this[C]|this[C+1]<<8|this[C+2]<<16)+this[C+3]*16777216},a.prototype.readUint32BE=a.prototype.readUInt32BE=function(C,B){return C=C>>>0,B||E(C,4,this.length),this[C]*16777216+(this[C+1]<<16|this[C+2]<<8|this[C+3])},a.prototype.readBigUInt64LE=Oe(function(C){C=C>>>0,$(C,"offset");const B=this[C],z=this[C+7];(B===void 0||z===void 0)&&G(C,this.length-8);const Y=B+this[++C]*2**8+this[++C]*2**16+this[++C]*2**24,se=this[++C]+this[++C]*2**8+this[++C]*2**16+z*2**24;return BigInt(Y)+(BigInt(se)<<BigInt(32))}),a.prototype.readBigUInt64BE=Oe(function(C){C=C>>>0,$(C,"offset");const B=this[C],z=this[C+7];(B===void 0||z===void 0)&&G(C,this.length-8);const Y=B*2**24+this[++C]*2**16+this[++C]*2**8+this[++C],se=this[++C]*2**24+this[++C]*2**16+this[++C]*2**8+z;return(BigInt(Y)<<BigInt(32))+BigInt(se)}),a.prototype.readIntLE=function(C,B,z){C=C>>>0,B=B>>>0,z||E(C,B,this.length);let Y=this[C],se=1,re=0;for(;++re<B&&(se*=256);)Y+=this[C+re]*se;return se*=128,Y>=se&&(Y-=Math.pow(2,8*B)),Y},a.prototype.readIntBE=function(C,B,z){C=C>>>0,B=B>>>0,z||E(C,B,this.length);let Y=B,se=1,re=this[C+--Y];for(;Y>0&&(se*=256);)re+=this[C+--Y]*se;return se*=128,re>=se&&(re-=Math.pow(2,8*B)),re},a.prototype.readInt8=function(C,B){return C=C>>>0,B||E(C,1,this.length),this[C]&128?(255-this[C]+1)*-1:this[C]},a.prototype.readInt16LE=function(C,B){C=C>>>0,B||E(C,2,this.length);const z=this[C]|this[C+1]<<8;return z&32768?z|4294901760:z},a.prototype.readInt16BE=function(C,B){C=C>>>0,B||E(C,2,this.length);const z=this[C+1]|this[C]<<8;return z&32768?z|4294901760:z},a.prototype.readInt32LE=function(C,B){return C=C>>>0,B||E(C,4,this.length),this[C]|this[C+1]<<8|this[C+2]<<16|this[C+3]<<24},a.prototype.readInt32BE=function(C,B){return C=C>>>0,B||E(C,4,this.length),this[C]<<24|this[C+1]<<16|this[C+2]<<8|this[C+3]},a.prototype.readBigInt64LE=Oe(function(C){C=C>>>0,$(C,"offset");const B=this[C],z=this[C+7];(B===void 0||z===void 0)&&G(C,this.length-8);const Y=this[C+4]+this[C+5]*2**8+this[C+6]*2**16+(z<<24);return(BigInt(Y)<<BigInt(32))+BigInt(B+this[++C]*2**8+this[++C]*2**16+this[++C]*2**24)}),a.prototype.readBigInt64BE=Oe(function(C){C=C>>>0,$(C,"offset");const B=this[C],z=this[C+7];(B===void 0||z===void 0)&&G(C,this.length-8);const Y=(B<<24)+this[++C]*2**16+this[++C]*2**8+this[++C];return(BigInt(Y)<<BigInt(32))+BigInt(this[++C]*2**24+this[++C]*2**16+this[++C]*2**8+z)}),a.prototype.readFloatLE=function(C,B){return C=C>>>0,B||E(C,4,this.length),t.read(this,C,!0,23,4)},a.prototype.readFloatBE=function(C,B){return C=C>>>0,B||E(C,4,this.length),t.read(this,C,!1,23,4)},a.prototype.readDoubleLE=function(C,B){return C=C>>>0,B||E(C,8,this.length),t.read(this,C,!0,52,8)},a.prototype.readDoubleBE=function(C,B){return C=C>>>0,B||E(C,8,this.length),t.read(this,C,!1,52,8)};function j(L,C,B,z,Y,se){if(!a.isBuffer(L))throw new TypeError('"buffer" argument must be a Buffer instance');if(C>Y||C<se)throw new RangeError('"value" argument is out of bounds');if(B+z>L.length)throw new RangeError("Index out of range")}a.prototype.writeUintLE=a.prototype.writeUIntLE=function(C,B,z,Y){if(C=+C,B=B>>>0,z=z>>>0,!Y){const Be=Math.pow(2,8*z)-1;j(this,C,B,z,Be,0)}let se=1,re=0;for(this[B]=C&255;++re<z&&(se*=256);)this[B+re]=C/se&255;return B+z},a.prototype.writeUintBE=a.prototype.writeUIntBE=function(C,B,z,Y){if(C=+C,B=B>>>0,z=z>>>0,!Y){const Be=Math.pow(2,8*z)-1;j(this,C,B,z,Be,0)}let se=z-1,re=1;for(this[B+se]=C&255;--se>=0&&(re*=256);)this[B+se]=C/re&255;return B+z},a.prototype.writeUint8=a.prototype.writeUInt8=function(C,B,z){return C=+C,B=B>>>0,z||j(this,C,B,1,255,0),this[B]=C&255,B+1},a.prototype.writeUint16LE=a.prototype.writeUInt16LE=function(C,B,z){return C=+C,B=B>>>0,z||j(this,C,B,2,65535,0),this[B]=C&255,this[B+1]=C>>>8,B+2},a.prototype.writeUint16BE=a.prototype.writeUInt16BE=function(C,B,z){return C=+C,B=B>>>0,z||j(this,C,B,2,65535,0),this[B]=C>>>8,this[B+1]=C&255,B+2},a.prototype.writeUint32LE=a.prototype.writeUInt32LE=function(C,B,z){return C=+C,B=B>>>0,z||j(this,C,B,4,4294967295,0),this[B+3]=C>>>24,this[B+2]=C>>>16,this[B+1]=C>>>8,this[B]=C&255,B+4},a.prototype.writeUint32BE=a.prototype.writeUInt32BE=function(C,B,z){return C=+C,B=B>>>0,z||j(this,C,B,4,4294967295,0),this[B]=C>>>24,this[B+1]=C>>>16,this[B+2]=C>>>8,this[B+3]=C&255,B+4};function X(L,C,B,z,Y){D(C,z,Y,L,B,7);let se=Number(C&BigInt(4294967295));L[B++]=se,se=se>>8,L[B++]=se,se=se>>8,L[B++]=se,se=se>>8,L[B++]=se;let re=Number(C>>BigInt(32)&BigInt(4294967295));return L[B++]=re,re=re>>8,L[B++]=re,re=re>>8,L[B++]=re,re=re>>8,L[B++]=re,B}function Q(L,C,B,z,Y){D(C,z,Y,L,B,7);let se=Number(C&BigInt(4294967295));L[B+7]=se,se=se>>8,L[B+6]=se,se=se>>8,L[B+5]=se,se=se>>8,L[B+4]=se;let re=Number(C>>BigInt(32)&BigInt(4294967295));return L[B+3]=re,re=re>>8,L[B+2]=re,re=re>>8,L[B+1]=re,re=re>>8,L[B]=re,B+8}a.prototype.writeBigUInt64LE=Oe(function(C,B=0){return X(this,C,B,BigInt(0),BigInt("0xffffffffffffffff"))}),a.prototype.writeBigUInt64BE=Oe(function(C,B=0){return Q(this,C,B,BigInt(0),BigInt("0xffffffffffffffff"))}),a.prototype.writeIntLE=function(C,B,z,Y){if(C=+C,B=B>>>0,!Y){const $e=Math.pow(2,8*z-1);j(this,C,B,z,$e-1,-$e)}let se=0,re=1,Be=0;for(this[B]=C&255;++se<z&&(re*=256);)C<0&&Be===0&&this[B+se-1]!==0&&(Be=1),this[B+se]=(C/re>>0)-Be&255;return B+z},a.prototype.writeIntBE=function(C,B,z,Y){if(C=+C,B=B>>>0,!Y){const $e=Math.pow(2,8*z-1);j(this,C,B,z,$e-1,-$e)}let se=z-1,re=1,Be=0;for(this[B+se]=C&255;--se>=0&&(re*=256);)C<0&&Be===0&&this[B+se+1]!==0&&(Be=1),this[B+se]=(C/re>>0)-Be&255;return B+z},a.prototype.writeInt8=function(C,B,z){return C=+C,B=B>>>0,z||j(this,C,B,1,127,-128),C<0&&(C=255+C+1),this[B]=C&255,B+1},a.prototype.writeInt16LE=function(C,B,z){return C=+C,B=B>>>0,z||j(this,C,B,2,32767,-32768),this[B]=C&255,this[B+1]=C>>>8,B+2},a.prototype.writeInt16BE=function(C,B,z){return C=+C,B=B>>>0,z||j(this,C,B,2,32767,-32768),this[B]=C>>>8,this[B+1]=C&255,B+2},a.prototype.writeInt32LE=function(C,B,z){return C=+C,B=B>>>0,z||j(this,C,B,4,2147483647,-2147483648),this[B]=C&255,this[B+1]=C>>>8,this[B+2]=C>>>16,this[B+3]=C>>>24,B+4},a.prototype.writeInt32BE=function(C,B,z){return C=+C,B=B>>>0,z||j(this,C,B,4,2147483647,-2147483648),C<0&&(C=4294967295+C+1),this[B]=C>>>24,this[B+1]=C>>>16,this[B+2]=C>>>8,this[B+3]=C&255,B+4},a.prototype.writeBigInt64LE=Oe(function(C,B=0){return X(this,C,B,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),a.prototype.writeBigInt64BE=Oe(function(C,B=0){return Q(this,C,B,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function Se(L,C,B,z,Y,se){if(B+z>L.length)throw new RangeError("Index out of range");if(B<0)throw new RangeError("Index out of range")}function he(L,C,B,z,Y){return C=+C,B=B>>>0,Y||Se(L,C,B,4),t.write(L,C,B,z,23,4),B+4}a.prototype.writeFloatLE=function(C,B,z){return he(this,C,B,!0,z)},a.prototype.writeFloatBE=function(C,B,z){return he(this,C,B,!1,z)};function xe(L,C,B,z,Y){return C=+C,B=B>>>0,Y||Se(L,C,B,8),t.write(L,C,B,z,52,8),B+8}a.prototype.writeDoubleLE=function(C,B,z){return xe(this,C,B,!0,z)},a.prototype.writeDoubleBE=function(C,B,z){return xe(this,C,B,!1,z)},a.prototype.copy=function(C,B,z,Y){if(!a.isBuffer(C))throw new TypeError("argument should be a Buffer");if(z||(z=0),!Y&&Y!==0&&(Y=this.length),B>=C.length&&(B=C.length),B||(B=0),Y>0&&Y<z&&(Y=z),Y===z||C.length===0||this.length===0)return 0;if(B<0)throw new RangeError("targetStart out of bounds");if(z<0||z>=this.length)throw new RangeError("Index out of range");if(Y<0)throw new RangeError("sourceEnd out of bounds");Y>this.length&&(Y=this.length),C.length-B<Y-z&&(Y=C.length-B+z);const se=Y-z;return this===C&&typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin(B,z,Y):Uint8Array.prototype.set.call(C,this.subarray(z,Y),B),se},a.prototype.fill=function(C,B,z,Y){if(typeof C=="string"){if(typeof B=="string"?(Y=B,B=0,z=this.length):typeof z=="string"&&(Y=z,z=this.length),Y!==void 0&&typeof Y!="string")throw new TypeError("encoding must be a string");if(typeof Y=="string"&&!a.isEncoding(Y))throw new TypeError("Unknown encoding: "+Y);if(C.length===1){const re=C.charCodeAt(0);(Y==="utf8"&&re<128||Y==="latin1")&&(C=re)}}else typeof C=="number"?C=C&255:typeof C=="boolean"&&(C=Number(C));if(B<0||this.length<B||this.length<z)throw new RangeError("Out of range index");if(z<=B)return this;B=B>>>0,z=z===void 0?this.length:z>>>0,C||(C=0);let se;if(typeof C=="number")for(se=B;se<z;++se)this[se]=C;else{const re=a.isBuffer(C)?C:a.from(C,Y),Be=re.length;if(Be===0)throw new TypeError('The value "'+C+'" is invalid for argument "value"');for(se=0;se<z-B;++se)this[se+B]=re[se%Be]}return this};const Ae={};function Re(L,C,B){Ae[L]=class extends B{constructor(){super(),Object.defineProperty(this,"message",{value:C.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${L}]`,this.stack,delete this.name}get code(){return L}set code(Y){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:Y,writable:!0})}toString(){return`${this.name} [${L}]: ${this.message}`}}}Re("ERR_BUFFER_OUT_OF_BOUNDS",function(L){return L?`${L} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),Re("ERR_INVALID_ARG_TYPE",function(L,C){return`The "${L}" argument must be of type number. Received type ${typeof C}`},TypeError),Re("ERR_OUT_OF_RANGE",function(L,C,B){let z=`The value of "${L}" is out of range.`,Y=B;return Number.isInteger(B)&&Math.abs(B)>2**32?Y=He(String(B)):typeof B=="bigint"&&(Y=String(B),(B>BigInt(2)**BigInt(32)||B<-(BigInt(2)**BigInt(32)))&&(Y=He(Y)),Y+="n"),z+=` It must be ${C}. Received ${Y}`,z},RangeError);function He(L){let C="",B=L.length;const z=L[0]==="-"?1:0;for(;B>=z+4;B-=3)C=`_${L.slice(B-3,B)}${C}`;return`${L.slice(0,B)}${C}`}function qt(L,C,B){$(C,"offset"),(L[C]===void 0||L[C+B]===void 0)&&G(C,L.length-(B+1))}function D(L,C,B,z,Y,se){if(L>B||L<C){const re=typeof C=="bigint"?"n":"";let Be;throw se>3?C===0||C===BigInt(0)?Be=`>= 0${re} and < 2${re} ** ${(se+1)*8}${re}`:Be=`>= -(2${re} ** ${(se+1)*8-1}${re}) and < 2 ** ${(se+1)*8-1}${re}`:Be=`>= ${C}${re} and <= ${B}${re}`,new Ae.ERR_OUT_OF_RANGE("value",Be,L)}qt(z,Y,se)}function $(L,C){if(typeof L!="number")throw new Ae.ERR_INVALID_ARG_TYPE(C,"number",L)}function G(L,C,B){throw Math.floor(L)!==L?($(L,B),new Ae.ERR_OUT_OF_RANGE(B||"offset","an integer",L)):C<0?new Ae.ERR_BUFFER_OUT_OF_BOUNDS:new Ae.ERR_OUT_OF_RANGE(B||"offset",`>= ${B?1:0} and <= ${C}`,L)}const U=/[^+/0-9A-Za-z-_]/g;function W(L){if(L=L.split("=")[0],L=L.trim().replace(U,""),L.length<2)return"";for(;L.length%4!==0;)L=L+"=";return L}function J(L,C){C=C||1/0;let B;const z=L.length;let Y=null;const se=[];for(let re=0;re<z;++re){if(B=L.charCodeAt(re),B>55295&&B<57344){if(!Y){if(B>56319){(C-=3)>-1&&se.push(239,191,189);continue}else if(re+1===z){(C-=3)>-1&&se.push(239,191,189);continue}Y=B;continue}if(B<56320){(C-=3)>-1&&se.push(239,191,189),Y=B;continue}B=(Y-55296<<10|B-56320)+65536}else Y&&(C-=3)>-1&&se.push(239,191,189);if(Y=null,B<128){if((C-=1)<0)break;se.push(B)}else if(B<2048){if((C-=2)<0)break;se.push(B>>6|192,B&63|128)}else if(B<65536){if((C-=3)<0)break;se.push(B>>12|224,B>>6&63|128,B&63|128)}else if(B<1114112){if((C-=4)<0)break;se.push(B>>18|240,B>>12&63|128,B>>6&63|128,B&63|128)}else throw new Error("Invalid code point")}return se}function ee(L){const C=[];for(let B=0;B<L.length;++B)C.push(L.charCodeAt(B)&255);return C}function ne(L,C){let B,z,Y;const se=[];for(let re=0;re<L.length&&!((C-=2)<0);++re)B=L.charCodeAt(re),z=B>>8,Y=B%256,se.push(Y),se.push(z);return se}function ce(L){return e.toByteArray(W(L))}function ie(L,C,B,z){let Y;for(Y=0;Y<z&&!(Y+B>=C.length||Y>=L.length);++Y)C[Y+B]=L[Y];return Y}function de(L,C){return L instanceof C||L!=null&&L.constructor!=null&&L.constructor.name!=null&&L.constructor.name===C.name}function we(L){return L!==L}const ue=function(){const L="0123456789abcdef",C=new Array(256);for(let B=0;B<16;++B){const z=B*16;for(let Y=0;Y<16;++Y)C[z+Y]=L[B]+L[Y]}return C}();function Oe(L){return typeof BigInt>"u"?Me:L}function Me(){throw new Error("BigInt not supported")}})(ul);window.Buffer=ul.Buffer;function Ay(f,e){const t=Object.create(null),s=f.split(",");for(let i=0;i<s.length;i++)t[s[i]]=!0;return e?i=>!!t[i.toLowerCase()]:i=>!!t[i]}function By(f){if(Ue(f)){const e={};for(let t=0;t<f.length;t++){const s=f[t],i=ms(s)?aM(s):By(s);if(i)for(const n in i)e[n]=i[n]}return e}else{if(ms(f))return f;if(At(f))return f}}const iM=/;(?![^(]*\))/g,nM=/:([^]+)/,rM=/\/\*.*?\*\//gs;function aM(f){const e={};return f.replace(rM,"").split(iM).forEach(t=>{if(t){const s=t.split(nM);s.length>1&&(e[s[0].trim()]=s[1].trim())}}),e}function Ny(f){let e="";if(ms(f))e=f;else if(Ue(f))for(let t=0;t<f.length;t++){const s=Ny(f[t]);s&&(e+=s+" ")}else if(At(f))for(const t in f)f[t]&&(e+=t+" ");return e.trim()}const oM="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",dM=Ay(oM);function eI(f){return!!f||f===""}const mp=f=>ms(f)?f:f==null?"":Ue(f)||At(f)&&(f.toString===nI||!ze(f.toString))?JSON.stringify(f,tI,2):String(f),tI=(f,e)=>e&&e.__v_isRef?tI(f,e.value):od(e)?{[`Map(${e.size})`]:[...e.entries()].reduce((t,[s,i])=>(t[`${s} =>`]=i,t),{})}:sI(e)?{[`Set(${e.size})`]:[...e.values()]}:At(e)&&!Ue(e)&&!rI(e)?String(e):e,Pt={},ad=[],Mn=()=>{},cM=()=>!1,uM=/^on[^a-z]/,hl=f=>uM.test(f),Ey=f=>f.startsWith("onUpdate:"),Es=Object.assign,Vy=(f,e)=>{const t=f.indexOf(e);t>-1&&f.splice(t,1)},fM=Object.prototype.hasOwnProperty,dt=(f,e)=>fM.call(f,e),Ue=Array.isArray,od=f=>ll(f)==="[object Map]",sI=f=>ll(f)==="[object Set]",ze=f=>typeof f=="function",ms=f=>typeof f=="string",qy=f=>typeof f=="symbol",At=f=>f!==null&&typeof f=="object",iI=f=>At(f)&&ze(f.then)&&ze(f.catch),nI=Object.prototype.toString,ll=f=>nI.call(f),hM=f=>ll(f).slice(8,-1),rI=f=>ll(f)==="[object Object]",Ly=f=>ms(f)&&f!=="NaN"&&f[0]!=="-"&&""+parseInt(f,10)===f,qh=Ay(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),pl=f=>{const e=Object.create(null);return t=>e[t]||(e[t]=f(t))},lM=/-(\w)/g,fn=pl(f=>f.replace(lM,(e,t)=>t?t.toUpperCase():"")),pM=/\B([A-Z])/g,Sd=pl(f=>f.replace(pM,"-$1").toLowerCase()),br=pl(f=>f.charAt(0).toUpperCase()+f.slice(1)),Lh=pl(f=>f?`on${br(f)}`:""),uu=(f,e)=>!Object.is(f,e),gp=(f,e)=>{for(let t=0;t<f.length;t++)f[t](e)},Wh=(f,e,t)=>{Object.defineProperty(f,e,{configurable:!0,enumerable:!1,value:t})},Ry=f=>{const e=parseFloat(f);return isNaN(e)?f:e};let Zb;const mM=()=>Zb||(Zb=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});let nn;class aI{constructor(e=!1){this.detached=e,this.active=!0,this.effects=[],this.cleanups=[],this.parent=nn,!e&&nn&&(this.index=(nn.scopes||(nn.scopes=[])).push(this)-1)}run(e){if(this.active){const t=nn;try{return nn=this,e()}finally{nn=t}}}on(){nn=this}off(){nn=this.parent}stop(e){if(this.active){let t,s;for(t=0,s=this.effects.length;t<s;t++)this.effects[t].stop();for(t=0,s=this.cleanups.length;t<s;t++)this.cleanups[t]();if(this.scopes)for(t=0,s=this.scopes.length;t<s;t++)this.scopes[t].stop(!0);if(!this.detached&&this.parent&&!e){const i=this.parent.scopes.pop();i&&i!==this&&(this.parent.scopes[this.index]=i,i.index=this.index)}this.parent=void 0,this.active=!1}}}function ml(f){return new aI(f)}function gM(f,e=nn){e&&e.active&&e.effects.push(f)}function Zn(f){nn&&nn.cleanups.push(f)}const Fy=f=>{const e=new Set(f);return e.w=0,e.n=0,e},oI=f=>(f.w&oa)>0,dI=f=>(f.n&oa)>0,yM=({deps:f})=>{if(f.length)for(let e=0;e<f.length;e++)f[e].w|=oa},bM=f=>{const{deps:e}=f;if(e.length){let t=0;for(let s=0;s<e.length;s++){const i=e[s];oI(i)&&!dI(i)?i.delete(f):e[t++]=i,i.w&=~oa,i.n&=~oa}e.length=t}},Ug=new WeakMap;let Zc=0,oa=1;const $g=30;let _n;const ro=Symbol(""),jg=Symbol("");class Dy{constructor(e,t=null,s){this.fn=e,this.scheduler=t,this.active=!0,this.deps=[],this.parent=void 0,gM(this,s)}run(){if(!this.active)return this.fn();let e=_n,t=ra;for(;e;){if(e===this)return;e=e.parent}try{return this.parent=_n,_n=this,ra=!0,oa=1<<++Zc,Zc<=$g?yM(this):Jb(this),this.fn()}finally{Zc<=$g&&bM(this),oa=1<<--Zc,_n=this.parent,ra=t,this.parent=void 0,this.deferStop&&this.stop()}}stop(){_n===this?this.deferStop=!0:this.active&&(Jb(this),this.onStop&&this.onStop(),this.active=!1)}}function Jb(f){const{deps:e}=f;if(e.length){for(let t=0;t<e.length;t++)e[t].delete(f);e.length=0}}let ra=!0;const cI=[];function kd(){cI.push(ra),ra=!1}function vd(){const f=cI.pop();ra=f===void 0?!0:f}function Li(f,e,t){if(ra&&_n){let s=Ug.get(f);s||Ug.set(f,s=new Map);let i=s.get(t);i||s.set(t,i=Fy()),uI(i)}}function uI(f,e){let t=!1;Zc<=$g?dI(f)||(f.n|=oa,t=!oI(f)):t=!f.has(_n),t&&(f.add(_n),_n.deps.push(f))}function mr(f,e,t,s,i,n){const r=Ug.get(f);if(!r)return;let a=[];if(e==="clear")a=[...r.values()];else if(t==="length"&&Ue(f)){const o=Ry(s);r.forEach((d,c)=>{(c==="length"||c>=o)&&a.push(d)})}else switch(t!==void 0&&a.push(r.get(t)),e){case"add":Ue(f)?Ly(t)&&a.push(r.get("length")):(a.push(r.get(ro)),od(f)&&a.push(r.get(jg)));break;case"delete":Ue(f)||(a.push(r.get(ro)),od(f)&&a.push(r.get(jg)));break;case"set":od(f)&&a.push(r.get(ro));break}if(a.length===1)a[0]&&Wg(a[0]);else{const o=[];for(const d of a)d&&o.push(...d);Wg(Fy(o))}}function Wg(f,e){const t=Ue(f)?f:[...f];for(const s of t)s.computed&&ew(s);for(const s of t)s.computed||ew(s)}function ew(f,e){(f!==_n||f.allowRecurse)&&(f.scheduler?f.scheduler():f.run())}const wM=Ay("__proto__,__v_isRef,__isVue"),fI=new Set(Object.getOwnPropertyNames(Symbol).filter(f=>f!=="arguments"&&f!=="caller").map(f=>Symbol[f]).filter(qy)),SM=Hy(),kM=Hy(!1,!0),vM=Hy(!0),tw=TM();function TM(){const f={};return["includes","indexOf","lastIndexOf"].forEach(e=>{f[e]=function(...t){const s=ut(this);for(let n=0,r=this.length;n<r;n++)Li(s,"get",n+"");const i=s[e](...t);return i===-1||i===!1?s[e](...t.map(ut)):i}}),["push","pop","shift","unshift","splice"].forEach(e=>{f[e]=function(...t){kd();const s=ut(this)[e].apply(this,t);return vd(),s}}),f}function Hy(f=!1,e=!1){return function(s,i,n){if(i==="__v_isReactive")return!f;if(i==="__v_isReadonly")return f;if(i==="__v_isShallow")return e;if(i==="__v_raw"&&n===(f?e?FM:gI:e?mI:pI).get(s))return s;const r=Ue(s);if(!f&&r&&dt(tw,i))return Reflect.get(tw,i,n);const a=Reflect.get(s,i,n);return(qy(i)?fI.has(i):wM(i))||(f||Li(s,"get",i),e)?a:Xt(a)?r&&Ly(i)?a:a.value:At(a)?f?Iu(a):Js(a):a}}const OM=hI(),IM=hI(!0);function hI(f=!1){return function(t,s,i,n){let r=t[s];if(ld(r)&&Xt(r)&&!Xt(i))return!1;if(!f&&(!zh(i)&&!ld(i)&&(r=ut(r),i=ut(i)),!Ue(t)&&Xt(r)&&!Xt(i)))return r.value=i,!0;const a=Ue(t)&&Ly(s)?Number(s)<t.length:dt(t,s),o=Reflect.set(t,s,i,n);return t===ut(n)&&(a?uu(i,r)&&mr(t,"set",s,i):mr(t,"add",s,i)),o}}function xM(f,e){const t=dt(f,e);f[e];const s=Reflect.deleteProperty(f,e);return s&&t&&mr(f,"delete",e,void 0),s}function _M(f,e){const t=Reflect.has(f,e);return(!qy(e)||!fI.has(e))&&Li(f,"has",e),t}function CM(f){return Li(f,"iterate",Ue(f)?"length":ro),Reflect.ownKeys(f)}const lI={get:SM,set:OM,deleteProperty:xM,has:_M,ownKeys:CM},MM={get:vM,set(f,e){return!0},deleteProperty(f,e){return!0}},PM=Es({},lI,{get:kM,set:IM}),Gy=f=>f,gl=f=>Reflect.getPrototypeOf(f);function zu(f,e,t=!1,s=!1){f=f.__v_raw;const i=ut(f),n=ut(e);t||(e!==n&&Li(i,"get",e),Li(i,"get",n));const{has:r}=gl(i),a=s?Gy:t?jy:fu;if(r.call(i,e))return a(f.get(e));if(r.call(i,n))return a(f.get(n));f!==i&&f.get(e)}function Ku(f,e=!1){const t=this.__v_raw,s=ut(t),i=ut(f);return e||(f!==i&&Li(s,"has",f),Li(s,"has",i)),f===i?t.has(f):t.has(f)||t.has(i)}function Xu(f,e=!1){return f=f.__v_raw,!e&&Li(ut(f),"iterate",ro),Reflect.get(f,"size",f)}function sw(f){f=ut(f);const e=ut(this);return gl(e).has.call(e,f)||(e.add(f),mr(e,"add",f,f)),this}function iw(f,e){e=ut(e);const t=ut(this),{has:s,get:i}=gl(t);let n=s.call(t,f);n||(f=ut(f),n=s.call(t,f));const r=i.call(t,f);return t.set(f,e),n?uu(e,r)&&mr(t,"set",f,e):mr(t,"add",f,e),this}function nw(f){const e=ut(this),{has:t,get:s}=gl(e);let i=t.call(e,f);i||(f=ut(f),i=t.call(e,f)),s&&s.call(e,f);const n=e.delete(f);return i&&mr(e,"delete",f,void 0),n}function rw(){const f=ut(this),e=f.size!==0,t=f.clear();return e&&mr(f,"clear",void 0,void 0),t}function Yu(f,e){return function(s,i){const n=this,r=n.__v_raw,a=ut(r),o=e?Gy:f?jy:fu;return!f&&Li(a,"iterate",ro),r.forEach((d,c)=>s.call(i,o(d),o(c),n))}}function Qu(f,e,t){return function(...s){const i=this.__v_raw,n=ut(i),r=od(n),a=f==="entries"||f===Symbol.iterator&&r,o=f==="keys"&&r,d=i[f](...s),c=t?Gy:e?jy:fu;return!e&&Li(n,"iterate",o?jg:ro),{next(){const{value:u,done:h}=d.next();return h?{value:u,done:h}:{value:a?[c(u[0]),c(u[1])]:c(u),done:h}},[Symbol.iterator](){return this}}}}function _r(f){return function(...e){return f==="delete"?!1:this}}function AM(){const f={get(n){return zu(this,n)},get size(){return Xu(this)},has:Ku,add:sw,set:iw,delete:nw,clear:rw,forEach:Yu(!1,!1)},e={get(n){return zu(this,n,!1,!0)},get size(){return Xu(this)},has:Ku,add:sw,set:iw,delete:nw,clear:rw,forEach:Yu(!1,!0)},t={get(n){return zu(this,n,!0)},get size(){return Xu(this,!0)},has(n){return Ku.call(this,n,!0)},add:_r("add"),set:_r("set"),delete:_r("delete"),clear:_r("clear"),forEach:Yu(!0,!1)},s={get(n){return zu(this,n,!0,!0)},get size(){return Xu(this,!0)},has(n){return Ku.call(this,n,!0)},add:_r("add"),set:_r("set"),delete:_r("delete"),clear:_r("clear"),forEach:Yu(!0,!0)};return["keys","values","entries",Symbol.iterator].forEach(n=>{f[n]=Qu(n,!1,!1),t[n]=Qu(n,!0,!1),e[n]=Qu(n,!1,!0),s[n]=Qu(n,!0,!0)}),[f,t,e,s]}const[BM,NM,EM,VM]=AM();function Uy(f,e){const t=e?f?VM:EM:f?NM:BM;return(s,i,n)=>i==="__v_isReactive"?!f:i==="__v_isReadonly"?f:i==="__v_raw"?s:Reflect.get(dt(t,i)&&i in s?t:s,i,n)}const qM={get:Uy(!1,!1)},LM={get:Uy(!1,!0)},RM={get:Uy(!0,!1)},pI=new WeakMap,mI=new WeakMap,gI=new WeakMap,FM=new WeakMap;function DM(f){switch(f){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function HM(f){return f.__v_skip||!Object.isExtensible(f)?0:DM(hM(f))}function Js(f){return ld(f)?f:$y(f,!1,lI,qM,pI)}function yI(f){return $y(f,!1,PM,LM,mI)}function Iu(f){return $y(f,!0,MM,RM,gI)}function $y(f,e,t,s,i){if(!At(f)||f.__v_raw&&!(e&&f.__v_isReactive))return f;const n=i.get(f);if(n)return n;const r=HM(f);if(r===0)return f;const a=new Proxy(f,r===2?s:t);return i.set(f,a),a}function dd(f){return ld(f)?dd(f.__v_raw):!!(f&&f.__v_isReactive)}function ld(f){return!!(f&&f.__v_isReadonly)}function zh(f){return!!(f&&f.__v_isShallow)}function bI(f){return dd(f)||ld(f)}function ut(f){const e=f&&f.__v_raw;return e?ut(e):f}function wI(f){return Wh(f,"__v_skip",!0),f}const fu=f=>At(f)?Js(f):f,jy=f=>At(f)?Iu(f):f;function SI(f){ra&&_n&&(f=ut(f),uI(f.dep||(f.dep=Fy())))}function kI(f,e){f=ut(f),f.dep&&Wg(f.dep)}function Xt(f){return!!(f&&f.__v_isRef===!0)}function be(f){return vI(f,!1)}function GM(f){return vI(f,!0)}function vI(f,e){return Xt(f)?f:new UM(f,e)}class UM{constructor(e,t){this.__v_isShallow=t,this.dep=void 0,this.__v_isRef=!0,this._rawValue=t?e:ut(e),this._value=t?e:fu(e)}get value(){return SI(this),this._value}set value(e){const t=this.__v_isShallow||zh(e)||ld(e);e=t?e:ut(e),uu(e,this._rawValue)&&(this._rawValue=e,this._value=t?e:fu(e),kI(this))}}function rn(f){return Xt(f)?f.value:f}const $M={get:(f,e,t)=>rn(Reflect.get(f,e,t)),set:(f,e,t,s)=>{const i=f[e];return Xt(i)&&!Xt(t)?(i.value=t,!0):Reflect.set(f,e,t,s)}};function TI(f){return dd(f)?f:new Proxy(f,$M)}function Wy(f){const e=Ue(f)?new Array(f.length):{};for(const t in f)e[t]=Xe(f,t);return e}class jM{constructor(e,t,s){this._object=e,this._key=t,this._defaultValue=s,this.__v_isRef=!0}get value(){const e=this._object[this._key];return e===void 0?this._defaultValue:e}set value(e){this._object[this._key]=e}}function Xe(f,e,t){const s=f[e];return Xt(s)?s:new jM(f,e,t)}var OI;class WM{constructor(e,t,s,i){this._setter=t,this.dep=void 0,this.__v_isRef=!0,this[OI]=!1,this._dirty=!0,this.effect=new Dy(e,()=>{this._dirty||(this._dirty=!0,kI(this))}),this.effect.computed=this,this.effect.active=this._cacheable=!i,this.__v_isReadonly=s}get value(){const e=ut(this);return SI(e),(e._dirty||!e._cacheable)&&(e._dirty=!1,e._value=e.effect.run()),e._value}set value(e){this._setter(e)}}OI="__v_isReadonly";function II(f,e,t=!1){let s,i;const n=ze(f);return n?(s=f,i=Mn):(s=f.get,i=f.set),new WM(s,i,n||!i,t)}function aa(f,e,t,s){let i;try{i=s?f(...s):f()}catch(n){yl(n,e,t)}return i}function cn(f,e,t,s){if(ze(f)){const n=aa(f,e,t,s);return n&&iI(n)&&n.catch(r=>{yl(r,e,t)}),n}const i=[];for(let n=0;n<f.length;n++)i.push(cn(f[n],e,t,s));return i}function yl(f,e,t,s=!0){const i=e?e.vnode:null;if(e){let n=e.parent;const r=e.proxy,a=t;for(;n;){const d=n.ec;if(d){for(let c=0;c<d.length;c++)if(d[c](f,r,a)===!1)return}n=n.parent}const o=e.appContext.config.errorHandler;if(o){aa(o,null,10,[f,r,a]);return}}zM(f,t,i,s)}function zM(f,e,t,s=!0){console.error(f)}let hu=!1,zg=!1;const ei=[];let zn=0;const cd=[];let fr=null,Ja=0;const xI=Promise.resolve();let zy=null;function _i(f){const e=zy||xI;return f?e.then(this?f.bind(this):f):e}function KM(f){let e=zn+1,t=ei.length;for(;e<t;){const s=e+t>>>1;lu(ei[s])<f?e=s+1:t=s}return e}function Ky(f){(!ei.length||!ei.includes(f,hu&&f.allowRecurse?zn+1:zn))&&(f.id==null?ei.push(f):ei.splice(KM(f.id),0,f),_I())}function _I(){!hu&&!zg&&(zg=!0,zy=xI.then(MI))}function XM(f){const e=ei.indexOf(f);e>zn&&ei.splice(e,1)}function YM(f){Ue(f)?cd.push(...f):(!fr||!fr.includes(f,f.allowRecurse?Ja+1:Ja))&&cd.push(f),_I()}function aw(f,e=hu?zn+1:0){for(;e<ei.length;e++){const t=ei[e];t&&t.pre&&(ei.splice(e,1),e--,t())}}function CI(f){if(cd.length){const e=[...new Set(cd)];if(cd.length=0,fr){fr.push(...e);return}for(fr=e,fr.sort((t,s)=>lu(t)-lu(s)),Ja=0;Ja<fr.length;Ja++)fr[Ja]();fr=null,Ja=0}}const lu=f=>f.id==null?1/0:f.id,QM=(f,e)=>{const t=lu(f)-lu(e);if(t===0){if(f.pre&&!e.pre)return-1;if(e.pre&&!f.pre)return 1}return t};function MI(f){zg=!1,hu=!0,ei.sort(QM);const e=Mn;try{for(zn=0;zn<ei.length;zn++){const t=ei[zn];t&&t.active!==!1&&aa(t,null,14)}}finally{zn=0,ei.length=0,CI(),hu=!1,zy=null,(ei.length||cd.length)&&MI()}}function ZM(f,e,...t){if(f.isUnmounted)return;const s=f.vnode.props||Pt;let i=t;const n=e.startsWith("update:"),r=n&&e.slice(7);if(r&&r in s){const c=`${r==="modelValue"?"model":r}Modifiers`,{number:u,trim:h}=s[c]||Pt;h&&(i=t.map(l=>ms(l)?l.trim():l)),u&&(i=t.map(Ry))}let a,o=s[a=Lh(e)]||s[a=Lh(fn(e))];!o&&n&&(o=s[a=Lh(Sd(e))]),o&&cn(o,f,6,i);const d=s[a+"Once"];if(d){if(!f.emitted)f.emitted={};else if(f.emitted[a])return;f.emitted[a]=!0,cn(d,f,6,i)}}function PI(f,e,t=!1){const s=e.emitsCache,i=s.get(f);if(i!==void 0)return i;const n=f.emits;let r={},a=!1;if(!ze(f)){const o=d=>{const c=PI(d,e,!0);c&&(a=!0,Es(r,c))};!t&&e.mixins.length&&e.mixins.forEach(o),f.extends&&o(f.extends),f.mixins&&f.mixins.forEach(o)}return!n&&!a?(At(f)&&s.set(f,null),null):(Ue(n)?n.forEach(o=>r[o]=null):Es(r,n),At(f)&&s.set(f,r),r)}function bl(f,e){return!f||!hl(e)?!1:(e=e.slice(2).replace(/Once$/,""),dt(f,e[0].toLowerCase()+e.slice(1))||dt(f,Sd(e))||dt(f,e))}let qi=null,AI=null;function Kh(f){const e=qi;return qi=f,AI=f&&f.type.__scopeId||null,e}function qe(f,e=qi,t){if(!e||f._n)return f;const s=(...i)=>{s._d&&yw(-1);const n=Kh(e);let r;try{r=f(...i)}finally{Kh(n),s._d&&yw(1)}return r};return s._n=!0,s._c=!0,s._d=!0,s}function yp(f){const{type:e,vnode:t,proxy:s,withProxy:i,props:n,propsOptions:[r],slots:a,attrs:o,emit:d,render:c,renderCache:u,data:h,setupState:l,ctx:p,inheritAttrs:m}=f;let g,y;const b=Kh(f);try{if(t.shapeFlag&4){const S=i||s;g=jn(c.call(S,S,u,n,l,h,p)),y=o}else{const S=e;g=jn(S.length>1?S(n,{attrs:o,slots:a,emit:d}):S(n,null)),y=e.props?o:JM(o)}}catch(S){au.length=0,yl(S,f,1),g=K(Pn)}let w=g;if(y&&m!==!1){const S=Object.keys(y),{shapeFlag:k}=w;S.length&&k&7&&(r&&S.some(Ey)&&(y=eP(y,r)),w=gr(w,y))}return t.dirs&&(w=gr(w),w.dirs=w.dirs?w.dirs.concat(t.dirs):t.dirs),t.transition&&(w.transition=t.transition),g=w,Kh(b),g}const JM=f=>{let e;for(const t in f)(t==="class"||t==="style"||hl(t))&&((e||(e={}))[t]=f[t]);return e},eP=(f,e)=>{const t={};for(const s in f)(!Ey(s)||!(s.slice(9)in e))&&(t[s]=f[s]);return t};function tP(f,e,t){const{props:s,children:i,component:n}=f,{props:r,children:a,patchFlag:o}=e,d=n.emitsOptions;if(e.dirs||e.transition)return!0;if(t&&o>=0){if(o&1024)return!0;if(o&16)return s?ow(s,r,d):!!r;if(o&8){const c=e.dynamicProps;for(let u=0;u<c.length;u++){const h=c[u];if(r[h]!==s[h]&&!bl(d,h))return!0}}}else return(i||a)&&(!a||!a.$stable)?!0:s===r?!1:s?r?ow(s,r,d):!0:!!r;return!1}function ow(f,e,t){const s=Object.keys(e);if(s.length!==Object.keys(f).length)return!0;for(let i=0;i<s.length;i++){const n=s[i];if(e[n]!==f[n]&&!bl(t,n))return!0}return!1}function sP({vnode:f,parent:e},t){for(;e&&e.subTree===f;)(f=e.vnode).el=t,e=e.parent}const iP=f=>f.__isSuspense;function nP(f,e){e&&e.pendingBranch?Ue(f)?e.effects.push(...f):e.effects.push(f):YM(f)}function Mi(f,e){if(Ns){let t=Ns.provides;const s=Ns.parent&&Ns.parent.provides;s===t&&(t=Ns.provides=Object.create(s)),t[f]=e}}function Yt(f,e,t=!1){const s=Ns||qi;if(s){const i=s.parent==null?s.vnode.appContext&&s.vnode.appContext.provides:s.parent.provides;if(i&&f in i)return i[f];if(arguments.length>1)return t&&ze(e)?e.call(s.proxy):e}}function wr(f,e){return Xy(f,null,e)}const Zu={};function Je(f,e,t){return Xy(f,e,t)}function Xy(f,e,{immediate:t,deep:s,flush:i,onTrack:n,onTrigger:r}=Pt){const a=Ns;let o,d=!1,c=!1;if(Xt(f)?(o=()=>f.value,d=zh(f)):dd(f)?(o=()=>f,s=!0):Ue(f)?(c=!0,d=f.some(w=>dd(w)||zh(w)),o=()=>f.map(w=>{if(Xt(w))return w.value;if(dd(w))return io(w);if(ze(w))return aa(w,a,2)})):ze(f)?e?o=()=>aa(f,a,2):o=()=>{if(!(a&&a.isUnmounted))return u&&u(),cn(f,a,3,[h])}:o=Mn,e&&s){const w=o;o=()=>io(w())}let u,h=w=>{u=y.onStop=()=>{aa(w,a,4)}},l;if(yu)if(h=Mn,e?t&&cn(e,a,3,[o(),c?[]:void 0,h]):o(),i==="sync"){const w=XP();l=w.__watcherHandles||(w.__watcherHandles=[])}else return Mn;let p=c?new Array(f.length).fill(Zu):Zu;const m=()=>{if(!!y.active)if(e){const w=y.run();(s||d||(c?w.some((S,k)=>uu(S,p[k])):uu(w,p)))&&(u&&u(),cn(e,a,3,[w,p===Zu?void 0:c&&p[0]===Zu?[]:p,h]),p=w)}else y.run()};m.allowRecurse=!!e;let g;i==="sync"?g=m:i==="post"?g=()=>xi(m,a&&a.suspense):(m.pre=!0,a&&(m.id=a.uid),g=()=>Ky(m));const y=new Dy(o,g);e?t?m():p=y.run():i==="post"?xi(y.run.bind(y),a&&a.suspense):y.run();const b=()=>{y.stop(),a&&a.scope&&Vy(a.scope.effects,y)};return l&&l.push(b),b}function rP(f,e,t){const s=this.proxy,i=ms(f)?f.includes(".")?BI(s,f):()=>s[f]:f.bind(s,s);let n;ze(e)?n=e:(n=e.handler,t=e);const r=Ns;pd(this);const a=Xy(i,n.bind(s),t);return r?pd(r):ao(),a}function BI(f,e){const t=e.split(".");return()=>{let s=f;for(let i=0;i<t.length&&s;i++)s=s[t[i]];return s}}function io(f,e){if(!At(f)||f.__v_skip||(e=e||new Set,e.has(f)))return f;if(e.add(f),Xt(f))io(f.value,e);else if(Ue(f))for(let t=0;t<f.length;t++)io(f[t],e);else if(sI(f)||od(f))f.forEach(t=>{io(t,e)});else if(rI(f))for(const t in f)io(f[t],e);return f}function NI(){const f={isMounted:!1,isLeaving:!1,isUnmounting:!1,leavingVNodes:new Map};return Jn(()=>{f.isMounted=!0}),hn(()=>{f.isUnmounting=!0}),f}const Hi=[Function,Array],aP={name:"BaseTransition",props:{mode:String,appear:Boolean,persisted:Boolean,onBeforeEnter:Hi,onEnter:Hi,onAfterEnter:Hi,onEnterCancelled:Hi,onBeforeLeave:Hi,onLeave:Hi,onAfterLeave:Hi,onLeaveCancelled:Hi,onBeforeAppear:Hi,onAppear:Hi,onAfterAppear:Hi,onAppearCancelled:Hi},setup(f,{slots:e}){const t=Ol(),s=NI();let i;return()=>{const n=e.default&&Yy(e.default(),!0);if(!n||!n.length)return;let r=n[0];if(n.length>1){for(const m of n)if(m.type!==Pn){r=m;break}}const a=ut(f),{mode:o}=a;if(s.isLeaving)return bp(r);const d=dw(r);if(!d)return bp(r);const c=pu(d,a,s,t);mu(d,c);const u=t.subTree,h=u&&dw(u);let l=!1;const{getTransitionKey:p}=d.type;if(p){const m=p();i===void 0?i=m:m!==i&&(i=m,l=!0)}if(h&&h.type!==Pn&&(!eo(d,h)||l)){const m=pu(h,a,s,t);if(mu(h,m),o==="out-in")return s.isLeaving=!0,m.afterLeave=()=>{s.isLeaving=!1,t.update.active!==!1&&t.update()},bp(r);o==="in-out"&&d.type!==Pn&&(m.delayLeave=(g,y,b)=>{const w=VI(s,h);w[String(h.key)]=h,g._leaveCb=()=>{y(),g._leaveCb=void 0,delete c.delayedLeave},c.delayedLeave=b})}return r}}},EI=aP;function VI(f,e){const{leavingVNodes:t}=f;let s=t.get(e.type);return s||(s=Object.create(null),t.set(e.type,s)),s}function pu(f,e,t,s){const{appear:i,mode:n,persisted:r=!1,onBeforeEnter:a,onEnter:o,onAfterEnter:d,onEnterCancelled:c,onBeforeLeave:u,onLeave:h,onAfterLeave:l,onLeaveCancelled:p,onBeforeAppear:m,onAppear:g,onAfterAppear:y,onAppearCancelled:b}=e,w=String(f.key),S=VI(t,f),k=(_,N)=>{_&&cn(_,s,9,N)},T=(_,N)=>{const M=N[1];k(_,N),Ue(_)?_.every(x=>x.length<=1)&&M():_.length<=1&&M()},I={mode:n,persisted:r,beforeEnter(_){let N=a;if(!t.isMounted)if(i)N=m||a;else return;_._leaveCb&&_._leaveCb(!0);const M=S[w];M&&eo(f,M)&&M.el._leaveCb&&M.el._leaveCb(),k(N,[_])},enter(_){let N=o,M=d,x=c;if(!t.isMounted)if(i)N=g||o,M=y||d,x=b||c;else return;let v=!1;const O=_._enterCb=A=>{v||(v=!0,A?k(x,[_]):k(M,[_]),I.delayedLeave&&I.delayedLeave(),_._enterCb=void 0)};N?T(N,[_,O]):O()},leave(_,N){const M=String(f.key);if(_._enterCb&&_._enterCb(!0),t.isUnmounting)return N();k(u,[_]);let x=!1;const v=_._leaveCb=O=>{x||(x=!0,N(),O?k(p,[_]):k(l,[_]),_._leaveCb=void 0,S[M]===f&&delete S[M])};S[M]=f,h?T(h,[_,v]):v()},clone(_){return pu(_,e,t,s)}};return I}function bp(f){if(wl(f))return f=gr(f),f.children=null,f}function dw(f){return wl(f)?f.children?f.children[0]:void 0:f}function mu(f,e){f.shapeFlag&6&&f.component?mu(f.component.subTree,e):f.shapeFlag&128?(f.ssContent.transition=e.clone(f.ssContent),f.ssFallback.transition=e.clone(f.ssFallback)):f.transition=e}function Yy(f,e=!1,t){let s=[],i=0;for(let n=0;n<f.length;n++){let r=f[n];const a=t==null?r.key:String(t)+String(r.key!=null?r.key:n);r.type===Vt?(r.patchFlag&128&&i++,s=s.concat(Yy(r.children,e,a))):(e||r.type!==Pn)&&s.push(a!=null?gr(r,{key:a}):r)}if(i>1)for(let n=0;n<s.length;n++)s[n].patchFlag=-2;return s}function Qy(f){return ze(f)?{setup:f,name:f.name}:f}const Rh=f=>!!f.type.__asyncLoader,wl=f=>f.type.__isKeepAlive;function qI(f,e){RI(f,"a",e)}function LI(f,e){RI(f,"da",e)}function RI(f,e,t=Ns){const s=f.__wdc||(f.__wdc=()=>{let i=t;for(;i;){if(i.isDeactivated)return;i=i.parent}return f()});if(Sl(e,s,t),t){let i=t.parent;for(;i&&i.parent;)wl(i.parent.vnode)&&oP(s,e,t,i),i=i.parent}}function oP(f,e,t,s){const i=Sl(e,f,s,!0);DI(()=>{Vy(s[e],i)},t)}function Sl(f,e,t=Ns,s=!1){if(t){const i=t[f]||(t[f]=[]),n=e.__weh||(e.__weh=(...r)=>{if(t.isUnmounted)return;kd(),pd(t);const a=cn(e,t,f,r);return ao(),vd(),a});return s?i.unshift(n):i.push(n),n}}const Sr=f=>(e,t=Ns)=>(!yu||f==="sp")&&Sl(f,(...s)=>e(...s),t),kl=Sr("bm"),Jn=Sr("m"),dP=Sr("bu"),FI=Sr("u"),hn=Sr("bum"),DI=Sr("um"),cP=Sr("sp"),uP=Sr("rtg"),fP=Sr("rtc");function hP(f,e=Ns){Sl("ec",f,e)}function Ri(f,e){const t=qi;if(t===null)return f;const s=Il(t)||t.proxy,i=f.dirs||(f.dirs=[]);for(let n=0;n<e.length;n++){let[r,a,o,d=Pt]=e[n];r&&(ze(r)&&(r={mounted:r,updated:r}),r.deep&&io(a),i.push({dir:r,instance:s,value:a,oldValue:void 0,arg:o,modifiers:d}))}return f}function ma(f,e,t,s){const i=f.dirs,n=e&&e.dirs;for(let r=0;r<i.length;r++){const a=i[r];n&&(a.oldValue=n[r].value);let o=a.dir[s];o&&(kd(),cn(o,t,8,[f.el,a,f,e]),vd())}}const HI="components",lP="directives",GI=Symbol();function pP(f){return ms(f)?UI(HI,f,!1)||f:f||GI}function fa(f){return UI(lP,f)}function UI(f,e,t=!0,s=!1){const i=qi||Ns;if(i){const n=i.type;if(f===HI){const a=WP(n,!1);if(a&&(a===e||a===fn(e)||a===br(fn(e))))return n}const r=cw(i[f]||n[f],e)||cw(i.appContext[f],e);return!r&&s?n:r}}function cw(f,e){return f&&(f[e]||f[fn(e)]||f[br(fn(e))])}function mP(f,e,t,s){let i;const n=t&&t[s];if(Ue(f)||ms(f)){i=new Array(f.length);for(let r=0,a=f.length;r<a;r++)i[r]=e(f[r],r,void 0,n&&n[r])}else if(typeof f=="number"){i=new Array(f);for(let r=0;r<f;r++)i[r]=e(r+1,r,void 0,n&&n[r])}else if(At(f))if(f[Symbol.iterator])i=Array.from(f,(r,a)=>e(r,a,void 0,n&&n[a]));else{const r=Object.keys(f);i=new Array(r.length);for(let a=0,o=r.length;a<o;a++){const d=r[a];i[a]=e(f[d],d,a,n&&n[a])}}else i=[];return t&&(t[s]=i),i}function wp(f,e){const t={};for(const s in f)t[e&&/[A-Z]/.test(s)?`on:${s}`:Lh(s)]=f[s];return t}const Kg=f=>f?ex(f)?Il(f)||f.proxy:Kg(f.parent):null,nu=Es(Object.create(null),{$:f=>f,$el:f=>f.vnode.el,$data:f=>f.data,$props:f=>f.props,$attrs:f=>f.attrs,$slots:f=>f.slots,$refs:f=>f.refs,$parent:f=>Kg(f.parent),$root:f=>Kg(f.root),$emit:f=>f.emit,$options:f=>Zy(f),$forceUpdate:f=>f.f||(f.f=()=>Ky(f.update)),$nextTick:f=>f.n||(f.n=_i.bind(f.proxy)),$watch:f=>rP.bind(f)}),Sp=(f,e)=>f!==Pt&&!f.__isScriptSetup&&dt(f,e),gP={get({_:f},e){const{ctx:t,setupState:s,data:i,props:n,accessCache:r,type:a,appContext:o}=f;let d;if(e[0]!=="$"){const l=r[e];if(l!==void 0)switch(l){case 1:return s[e];case 2:return i[e];case 4:return t[e];case 3:return n[e]}else{if(Sp(s,e))return r[e]=1,s[e];if(i!==Pt&&dt(i,e))return r[e]=2,i[e];if((d=f.propsOptions[0])&&dt(d,e))return r[e]=3,n[e];if(t!==Pt&&dt(t,e))return r[e]=4,t[e];Xg&&(r[e]=0)}}const c=nu[e];let u,h;if(c)return e==="$attrs"&&Li(f,"get",e),c(f);if((u=a.__cssModules)&&(u=u[e]))return u;if(t!==Pt&&dt(t,e))return r[e]=4,t[e];if(h=o.config.globalProperties,dt(h,e))return h[e]},set({_:f},e,t){const{data:s,setupState:i,ctx:n}=f;return Sp(i,e)?(i[e]=t,!0):s!==Pt&&dt(s,e)?(s[e]=t,!0):dt(f.props,e)||e[0]==="$"&&e.slice(1)in f?!1:(n[e]=t,!0)},has({_:{data:f,setupState:e,accessCache:t,ctx:s,appContext:i,propsOptions:n}},r){let a;return!!t[r]||f!==Pt&&dt(f,r)||Sp(e,r)||(a=n[0])&&dt(a,r)||dt(s,r)||dt(nu,r)||dt(i.config.globalProperties,r)},defineProperty(f,e,t){return t.get!=null?f._.accessCache[e]=0:dt(t,"value")&&this.set(f,e,t.value,null),Reflect.defineProperty(f,e,t)}};let Xg=!0;function yP(f){const e=Zy(f),t=f.proxy,s=f.ctx;Xg=!1,e.beforeCreate&&uw(e.beforeCreate,f,"bc");const{data:i,computed:n,methods:r,watch:a,provide:o,inject:d,created:c,beforeMount:u,mounted:h,beforeUpdate:l,updated:p,activated:m,deactivated:g,beforeDestroy:y,beforeUnmount:b,destroyed:w,unmounted:S,render:k,renderTracked:T,renderTriggered:I,errorCaptured:_,serverPrefetch:N,expose:M,inheritAttrs:x,components:v,directives:O,filters:A}=e;if(d&&bP(d,s,null,f.appContext.config.unwrapInjectedRef),r)for(const R in r){const H=r[R];ze(H)&&(s[R]=H.bind(t))}if(i){const R=i.call(t,t);At(R)&&(f.data=Js(R))}if(Xg=!0,n)for(const R in n){const H=n[R],F=ze(H)?H.bind(t,t):ze(H.get)?H.get.bind(t,t):Mn,P=!ze(H)&&ze(H.set)?H.set.bind(t):Mn,E=te({get:F,set:P});Object.defineProperty(s,R,{enumerable:!0,configurable:!0,get:()=>E.value,set:j=>E.value=j})}if(a)for(const R in a)$I(a[R],s,t,R);if(o){const R=ze(o)?o.call(t):o;Reflect.ownKeys(R).forEach(H=>{Mi(H,R[H])})}c&&uw(c,f,"c");function q(R,H){Ue(H)?H.forEach(F=>R(F.bind(t))):H&&R(H.bind(t))}if(q(kl,u),q(Jn,h),q(dP,l),q(FI,p),q(qI,m),q(LI,g),q(hP,_),q(fP,T),q(uP,I),q(hn,b),q(DI,S),q(cP,N),Ue(M))if(M.length){const R=f.exposed||(f.exposed={});M.forEach(H=>{Object.defineProperty(R,H,{get:()=>t[H],set:F=>t[H]=F})})}else f.exposed||(f.exposed={});k&&f.render===Mn&&(f.render=k),x!=null&&(f.inheritAttrs=x),v&&(f.components=v),O&&(f.directives=O)}function bP(f,e,t=Mn,s=!1){Ue(f)&&(f=Yg(f));for(const i in f){const n=f[i];let r;At(n)?"default"in n?r=Yt(n.from||i,n.default,!0):r=Yt(n.from||i):r=Yt(n),Xt(r)&&s?Object.defineProperty(e,i,{enumerable:!0,configurable:!0,get:()=>r.value,set:a=>r.value=a}):e[i]=r}}function uw(f,e,t){cn(Ue(f)?f.map(s=>s.bind(e.proxy)):f.bind(e.proxy),e,t)}function $I(f,e,t,s){const i=s.includes(".")?BI(t,s):()=>t[s];if(ms(f)){const n=e[f];ze(n)&&Je(i,n)}else if(ze(f))Je(i,f.bind(t));else if(At(f))if(Ue(f))f.forEach(n=>$I(n,e,t,s));else{const n=ze(f.handler)?f.handler.bind(t):e[f.handler];ze(n)&&Je(i,n,f)}}function Zy(f){const e=f.type,{mixins:t,extends:s}=e,{mixins:i,optionsCache:n,config:{optionMergeStrategies:r}}=f.appContext,a=n.get(e);let o;return a?o=a:!i.length&&!t&&!s?o=e:(o={},i.length&&i.forEach(d=>Xh(o,d,r,!0)),Xh(o,e,r)),At(e)&&n.set(e,o),o}function Xh(f,e,t,s=!1){const{mixins:i,extends:n}=e;n&&Xh(f,n,t,!0),i&&i.forEach(r=>Xh(f,r,t,!0));for(const r in e)if(!(s&&r==="expose")){const a=wP[r]||t&&t[r];f[r]=a?a(f[r],e[r]):e[r]}return f}const wP={data:fw,props:Za,emits:Za,methods:Za,computed:Za,beforeCreate:hi,created:hi,beforeMount:hi,mounted:hi,beforeUpdate:hi,updated:hi,beforeDestroy:hi,beforeUnmount:hi,destroyed:hi,unmounted:hi,activated:hi,deactivated:hi,errorCaptured:hi,serverPrefetch:hi,components:Za,directives:Za,watch:kP,provide:fw,inject:SP};function fw(f,e){return e?f?function(){return Es(ze(f)?f.call(this,this):f,ze(e)?e.call(this,this):e)}:e:f}function SP(f,e){return Za(Yg(f),Yg(e))}function Yg(f){if(Ue(f)){const e={};for(let t=0;t<f.length;t++)e[f[t]]=f[t];return e}return f}function hi(f,e){return f?[...new Set([].concat(f,e))]:e}function Za(f,e){return f?Es(Es(Object.create(null),f),e):e}function kP(f,e){if(!f)return e;if(!e)return f;const t=Es(Object.create(null),f);for(const s in e)t[s]=hi(f[s],e[s]);return t}function vP(f,e,t,s=!1){const i={},n={};Wh(n,Tl,1),f.propsDefaults=Object.create(null),jI(f,e,i,n);for(const r in f.propsOptions[0])r in i||(i[r]=void 0);t?f.props=s?i:yI(i):f.type.props?f.props=i:f.props=n,f.attrs=n}function TP(f,e,t,s){const{props:i,attrs:n,vnode:{patchFlag:r}}=f,a=ut(i),[o]=f.propsOptions;let d=!1;if((s||r>0)&&!(r&16)){if(r&8){const c=f.vnode.dynamicProps;for(let u=0;u<c.length;u++){let h=c[u];if(bl(f.emitsOptions,h))continue;const l=e[h];if(o)if(dt(n,h))l!==n[h]&&(n[h]=l,d=!0);else{const p=fn(h);i[p]=Qg(o,a,p,l,f,!1)}else l!==n[h]&&(n[h]=l,d=!0)}}}else{jI(f,e,i,n)&&(d=!0);let c;for(const u in a)(!e||!dt(e,u)&&((c=Sd(u))===u||!dt(e,c)))&&(o?t&&(t[u]!==void 0||t[c]!==void 0)&&(i[u]=Qg(o,a,u,void 0,f,!0)):delete i[u]);if(n!==a)for(const u in n)(!e||!dt(e,u)&&!0)&&(delete n[u],d=!0)}d&&mr(f,"set","$attrs")}function jI(f,e,t,s){const[i,n]=f.propsOptions;let r=!1,a;if(e)for(let o in e){if(qh(o))continue;const d=e[o];let c;i&&dt(i,c=fn(o))?!n||!n.includes(c)?t[c]=d:(a||(a={}))[c]=d:bl(f.emitsOptions,o)||(!(o in s)||d!==s[o])&&(s[o]=d,r=!0)}if(n){const o=ut(t),d=a||Pt;for(let c=0;c<n.length;c++){const u=n[c];t[u]=Qg(i,o,u,d[u],f,!dt(d,u))}}return r}function Qg(f,e,t,s,i,n){const r=f[t];if(r!=null){const a=dt(r,"default");if(a&&s===void 0){const o=r.default;if(r.type!==Function&&ze(o)){const{propsDefaults:d}=i;t in d?s=d[t]:(pd(i),s=d[t]=o.call(null,e),ao())}else s=o}r[0]&&(n&&!a?s=!1:r[1]&&(s===""||s===Sd(t))&&(s=!0))}return s}function WI(f,e,t=!1){const s=e.propsCache,i=s.get(f);if(i)return i;const n=f.props,r={},a=[];let o=!1;if(!ze(f)){const c=u=>{o=!0;const[h,l]=WI(u,e,!0);Es(r,h),l&&a.push(...l)};!t&&e.mixins.length&&e.mixins.forEach(c),f.extends&&c(f.extends),f.mixins&&f.mixins.forEach(c)}if(!n&&!o)return At(f)&&s.set(f,ad),ad;if(Ue(n))for(let c=0;c<n.length;c++){const u=fn(n[c]);hw(u)&&(r[u]=Pt)}else if(n)for(const c in n){const u=fn(c);if(hw(u)){const h=n[c],l=r[u]=Ue(h)||ze(h)?{type:h}:Object.assign({},h);if(l){const p=mw(Boolean,l.type),m=mw(String,l.type);l[0]=p>-1,l[1]=m<0||p<m,(p>-1||dt(l,"default"))&&a.push(u)}}}const d=[r,a];return At(f)&&s.set(f,d),d}function hw(f){return f[0]!=="$"}function lw(f){const e=f&&f.toString().match(/^\s*function (\w+)/);return e?e[1]:f===null?"null":""}function pw(f,e){return lw(f)===lw(e)}function mw(f,e){return Ue(e)?e.findIndex(t=>pw(t,f)):ze(e)&&pw(e,f)?0:-1}const zI=f=>f[0]==="_"||f==="$stable",Jy=f=>Ue(f)?f.map(jn):[jn(f)],OP=(f,e,t)=>{if(e._n)return e;const s=qe((...i)=>Jy(e(...i)),t);return s._c=!1,s},KI=(f,e,t)=>{const s=f._ctx;for(const i in f){if(zI(i))continue;const n=f[i];if(ze(n))e[i]=OP(i,n,s);else if(n!=null){const r=Jy(n);e[i]=()=>r}}},XI=(f,e)=>{const t=Jy(e);f.slots.default=()=>t},IP=(f,e)=>{if(f.vnode.shapeFlag&32){const t=e._;t?(f.slots=ut(e),Wh(e,"_",t)):KI(e,f.slots={})}else f.slots={},e&&XI(f,e);Wh(f.slots,Tl,1)},xP=(f,e,t)=>{const{vnode:s,slots:i}=f;let n=!0,r=Pt;if(s.shapeFlag&32){const a=e._;a?t&&a===1?n=!1:(Es(i,e),!t&&a===1&&delete i._):(n=!e.$stable,KI(e,i)),r=e}else e&&(XI(f,e),r={default:1});if(n)for(const a in i)!zI(a)&&!(a in r)&&delete i[a]};function YI(){return{app:null,config:{isNativeTag:cM,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let _P=0;function CP(f,e){return function(s,i=null){ze(s)||(s=Object.assign({},s)),i!=null&&!At(i)&&(i=null);const n=YI(),r=new Set;let a=!1;const o=n.app={_uid:_P++,_component:s,_props:i,_container:null,_context:n,_instance:null,version:YP,get config(){return n.config},set config(d){},use(d,...c){return r.has(d)||(d&&ze(d.install)?(r.add(d),d.install(o,...c)):ze(d)&&(r.add(d),d(o,...c))),o},mixin(d){return n.mixins.includes(d)||n.mixins.push(d),o},component(d,c){return c?(n.components[d]=c,o):n.components[d]},directive(d,c){return c?(n.directives[d]=c,o):n.directives[d]},mount(d,c,u){if(!a){const h=K(s,i);return h.appContext=n,c&&e?e(h,d):f(h,d,u),a=!0,o._container=d,d.__vue_app__=o,Il(h.component)||h.component.proxy}},unmount(){a&&(f(null,o._container),delete o._container.__vue_app__)},provide(d,c){return n.provides[d]=c,o}};return o}}function Zg(f,e,t,s,i=!1){if(Ue(f)){f.forEach((h,l)=>Zg(h,e&&(Ue(e)?e[l]:e),t,s,i));return}if(Rh(s)&&!i)return;const n=s.shapeFlag&4?Il(s.component)||s.component.proxy:s.el,r=i?null:n,{i:a,r:o}=f,d=e&&e.r,c=a.refs===Pt?a.refs={}:a.refs,u=a.setupState;if(d!=null&&d!==o&&(ms(d)?(c[d]=null,dt(u,d)&&(u[d]=null)):Xt(d)&&(d.value=null)),ze(o))aa(o,a,12,[r,c]);else{const h=ms(o),l=Xt(o);if(h||l){const p=()=>{if(f.f){const m=h?dt(u,o)?u[o]:c[o]:o.value;i?Ue(m)&&Vy(m,n):Ue(m)?m.includes(n)||m.push(n):h?(c[o]=[n],dt(u,o)&&(u[o]=c[o])):(o.value=[n],f.k&&(c[f.k]=o.value))}else h?(c[o]=r,dt(u,o)&&(u[o]=r)):l&&(o.value=r,f.k&&(c[f.k]=r))};r?(p.id=-1,xi(p,t)):p()}}}const xi=nP;function MP(f){return PP(f)}function PP(f,e){const t=mM();t.__VUE__=!0;const{insert:s,remove:i,patchProp:n,createElement:r,createText:a,createComment:o,setText:d,setElementText:c,parentNode:u,nextSibling:h,setScopeId:l=Mn,insertStaticContent:p}=f,m=(D,$,G,U=null,W=null,J=null,ee=!1,ne=null,ce=!!$.dynamicChildren)=>{if(D===$)return;D&&!eo(D,$)&&(U=xe(D),j(D,W,J,!0),D=null),$.patchFlag===-2&&(ce=!1,$.dynamicChildren=null);const{type:ie,ref:de,shapeFlag:we}=$;switch(ie){case vl:g(D,$,G,U);break;case Pn:y(D,$,G,U);break;case kp:D==null&&b($,G,U,ee);break;case Vt:v(D,$,G,U,W,J,ee,ne,ce);break;default:we&1?k(D,$,G,U,W,J,ee,ne,ce):we&6?O(D,$,G,U,W,J,ee,ne,ce):(we&64||we&128)&&ie.process(D,$,G,U,W,J,ee,ne,ce,Re)}de!=null&&W&&Zg(de,D&&D.ref,J,$||D,!$)},g=(D,$,G,U)=>{if(D==null)s($.el=a($.children),G,U);else{const W=$.el=D.el;$.children!==D.children&&d(W,$.children)}},y=(D,$,G,U)=>{D==null?s($.el=o($.children||""),G,U):$.el=D.el},b=(D,$,G,U)=>{[D.el,D.anchor]=p(D.children,$,G,U,D.el,D.anchor)},w=({el:D,anchor:$},G,U)=>{let W;for(;D&&D!==$;)W=h(D),s(D,G,U),D=W;s($,G,U)},S=({el:D,anchor:$})=>{let G;for(;D&&D!==$;)G=h(D),i(D),D=G;i($)},k=(D,$,G,U,W,J,ee,ne,ce)=>{ee=ee||$.type==="svg",D==null?T($,G,U,W,J,ee,ne,ce):N(D,$,W,J,ee,ne,ce)},T=(D,$,G,U,W,J,ee,ne)=>{let ce,ie;const{type:de,props:we,shapeFlag:ue,transition:Oe,dirs:Me}=D;if(ce=D.el=r(D.type,J,we&&we.is,we),ue&8?c(ce,D.children):ue&16&&_(D.children,ce,null,U,W,J&&de!=="foreignObject",ee,ne),Me&&ma(D,null,U,"created"),we){for(const C in we)C!=="value"&&!qh(C)&&n(ce,C,null,we[C],J,D.children,U,W,he);"value"in we&&n(ce,"value",null,we.value),(ie=we.onVnodeBeforeMount)&&An(ie,U,D)}I(ce,D,D.scopeId,ee,U),Me&&ma(D,null,U,"beforeMount");const L=(!W||W&&!W.pendingBranch)&&Oe&&!Oe.persisted;L&&Oe.beforeEnter(ce),s(ce,$,G),((ie=we&&we.onVnodeMounted)||L||Me)&&xi(()=>{ie&&An(ie,U,D),L&&Oe.enter(ce),Me&&ma(D,null,U,"mounted")},W)},I=(D,$,G,U,W)=>{if(G&&l(D,G),U)for(let J=0;J<U.length;J++)l(D,U[J]);if(W){let J=W.subTree;if($===J){const ee=W.vnode;I(D,ee,ee.scopeId,ee.slotScopeIds,W.parent)}}},_=(D,$,G,U,W,J,ee,ne,ce=0)=>{for(let ie=ce;ie<D.length;ie++){const de=D[ie]=ne?ia(D[ie]):jn(D[ie]);m(null,de,$,G,U,W,J,ee,ne)}},N=(D,$,G,U,W,J,ee)=>{const ne=$.el=D.el;let{patchFlag:ce,dynamicChildren:ie,dirs:de}=$;ce|=D.patchFlag&16;const we=D.props||Pt,ue=$.props||Pt;let Oe;G&&ga(G,!1),(Oe=ue.onVnodeBeforeUpdate)&&An(Oe,G,$,D),de&&ma($,D,G,"beforeUpdate"),G&&ga(G,!0);const Me=W&&$.type!=="foreignObject";if(ie?M(D.dynamicChildren,ie,ne,G,U,Me,J):ee||H(D,$,ne,null,G,U,Me,J,!1),ce>0){if(ce&16)x(ne,$,we,ue,G,U,W);else if(ce&2&&we.class!==ue.class&&n(ne,"class",null,ue.class,W),ce&4&&n(ne,"style",we.style,ue.style,W),ce&8){const L=$.dynamicProps;for(let C=0;C<L.length;C++){const B=L[C],z=we[B],Y=ue[B];(Y!==z||B==="value")&&n(ne,B,z,Y,W,D.children,G,U,he)}}ce&1&&D.children!==$.children&&c(ne,$.children)}else!ee&&ie==null&&x(ne,$,we,ue,G,U,W);((Oe=ue.onVnodeUpdated)||de)&&xi(()=>{Oe&&An(Oe,G,$,D),de&&ma($,D,G,"updated")},U)},M=(D,$,G,U,W,J,ee)=>{for(let ne=0;ne<$.length;ne++){const ce=D[ne],ie=$[ne],de=ce.el&&(ce.type===Vt||!eo(ce,ie)||ce.shapeFlag&70)?u(ce.el):G;m(ce,ie,de,null,U,W,J,ee,!0)}},x=(D,$,G,U,W,J,ee)=>{if(G!==U){if(G!==Pt)for(const ne in G)!qh(ne)&&!(ne in U)&&n(D,ne,G[ne],null,ee,$.children,W,J,he);for(const ne in U){if(qh(ne))continue;const ce=U[ne],ie=G[ne];ce!==ie&&ne!=="value"&&n(D,ne,ie,ce,ee,$.children,W,J,he)}"value"in U&&n(D,"value",G.value,U.value)}},v=(D,$,G,U,W,J,ee,ne,ce)=>{const ie=$.el=D?D.el:a(""),de=$.anchor=D?D.anchor:a("");let{patchFlag:we,dynamicChildren:ue,slotScopeIds:Oe}=$;Oe&&(ne=ne?ne.concat(Oe):Oe),D==null?(s(ie,G,U),s(de,G,U),_($.children,G,de,W,J,ee,ne,ce)):we>0&&we&64&&ue&&D.dynamicChildren?(M(D.dynamicChildren,ue,G,W,J,ee,ne),($.key!=null||W&&$===W.subTree)&&eb(D,$,!0)):H(D,$,G,de,W,J,ee,ne,ce)},O=(D,$,G,U,W,J,ee,ne,ce)=>{$.slotScopeIds=ne,D==null?$.shapeFlag&512?W.ctx.activate($,G,U,ee,ce):A($,G,U,W,J,ee,ce):V(D,$,ce)},A=(D,$,G,U,W,J,ee)=>{const ne=D.component=HP(D,U,W);if(wl(D)&&(ne.ctx.renderer=Re),GP(ne),ne.asyncDep){if(W&&W.registerDep(ne,q),!D.el){const ce=ne.subTree=K(Pn);y(null,ce,$,G)}return}q(ne,D,$,G,W,J,ee)},V=(D,$,G)=>{const U=$.component=D.component;if(tP(D,$,G))if(U.asyncDep&&!U.asyncResolved){R(U,$,G);return}else U.next=$,XM(U.update),U.update();else $.el=D.el,U.vnode=$},q=(D,$,G,U,W,J,ee)=>{const ne=()=>{if(D.isMounted){let{next:de,bu:we,u:ue,parent:Oe,vnode:Me}=D,L=de,C;ga(D,!1),de?(de.el=Me.el,R(D,de,ee)):de=Me,we&&gp(we),(C=de.props&&de.props.onVnodeBeforeUpdate)&&An(C,Oe,de,Me),ga(D,!0);const B=yp(D),z=D.subTree;D.subTree=B,m(z,B,u(z.el),xe(z),D,W,J),de.el=B.el,L===null&&sP(D,B.el),ue&&xi(ue,W),(C=de.props&&de.props.onVnodeUpdated)&&xi(()=>An(C,Oe,de,Me),W)}else{let de;const{el:we,props:ue}=$,{bm:Oe,m:Me,parent:L}=D,C=Rh($);if(ga(D,!1),Oe&&gp(Oe),!C&&(de=ue&&ue.onVnodeBeforeMount)&&An(de,L,$),ga(D,!0),we&&qt){const B=()=>{D.subTree=yp(D),qt(we,D.subTree,D,W,null)};C?$.type.__asyncLoader().then(()=>!D.isUnmounted&&B()):B()}else{const B=D.subTree=yp(D);m(null,B,G,U,D,W,J),$.el=B.el}if(Me&&xi(Me,W),!C&&(de=ue&&ue.onVnodeMounted)){const B=$;xi(()=>An(de,L,B),W)}($.shapeFlag&256||L&&Rh(L.vnode)&&L.vnode.shapeFlag&256)&&D.a&&xi(D.a,W),D.isMounted=!0,$=G=U=null}},ce=D.effect=new Dy(ne,()=>Ky(ie),D.scope),ie=D.update=()=>ce.run();ie.id=D.uid,ga(D,!0),ie()},R=(D,$,G)=>{$.component=D;const U=D.vnode.props;D.vnode=$,D.next=null,TP(D,$.props,U,G),xP(D,$.children,G),kd(),aw(),vd()},H=(D,$,G,U,W,J,ee,ne,ce=!1)=>{const ie=D&&D.children,de=D?D.shapeFlag:0,we=$.children,{patchFlag:ue,shapeFlag:Oe}=$;if(ue>0){if(ue&128){P(ie,we,G,U,W,J,ee,ne,ce);return}else if(ue&256){F(ie,we,G,U,W,J,ee,ne,ce);return}}Oe&8?(de&16&&he(ie,W,J),we!==ie&&c(G,we)):de&16?Oe&16?P(ie,we,G,U,W,J,ee,ne,ce):he(ie,W,J,!0):(de&8&&c(G,""),Oe&16&&_(we,G,U,W,J,ee,ne,ce))},F=(D,$,G,U,W,J,ee,ne,ce)=>{D=D||ad,$=$||ad;const ie=D.length,de=$.length,we=Math.min(ie,de);let ue;for(ue=0;ue<we;ue++){const Oe=$[ue]=ce?ia($[ue]):jn($[ue]);m(D[ue],Oe,G,null,W,J,ee,ne,ce)}ie>de?he(D,W,J,!0,!1,we):_($,G,U,W,J,ee,ne,ce,we)},P=(D,$,G,U,W,J,ee,ne,ce)=>{let ie=0;const de=$.length;let we=D.length-1,ue=de-1;for(;ie<=we&&ie<=ue;){const Oe=D[ie],Me=$[ie]=ce?ia($[ie]):jn($[ie]);if(eo(Oe,Me))m(Oe,Me,G,null,W,J,ee,ne,ce);else break;ie++}for(;ie<=we&&ie<=ue;){const Oe=D[we],Me=$[ue]=ce?ia($[ue]):jn($[ue]);if(eo(Oe,Me))m(Oe,Me,G,null,W,J,ee,ne,ce);else break;we--,ue--}if(ie>we){if(ie<=ue){const Oe=ue+1,Me=Oe<de?$[Oe].el:U;for(;ie<=ue;)m(null,$[ie]=ce?ia($[ie]):jn($[ie]),G,Me,W,J,ee,ne,ce),ie++}}else if(ie>ue)for(;ie<=we;)j(D[ie],W,J,!0),ie++;else{const Oe=ie,Me=ie,L=new Map;for(ie=Me;ie<=ue;ie++){const $e=$[ie]=ce?ia($[ie]):jn($[ie]);$e.key!=null&&L.set($e.key,ie)}let C,B=0;const z=ue-Me+1;let Y=!1,se=0;const re=new Array(z);for(ie=0;ie<z;ie++)re[ie]=0;for(ie=Oe;ie<=we;ie++){const $e=D[ie];if(B>=z){j($e,W,J,!0);continue}let Ne;if($e.key!=null)Ne=L.get($e.key);else for(C=Me;C<=ue;C++)if(re[C-Me]===0&&eo($e,$[C])){Ne=C;break}Ne===void 0?j($e,W,J,!0):(re[Ne-Me]=ie+1,Ne>=se?se=Ne:Y=!0,m($e,$[Ne],G,null,W,J,ee,ne,ce),B++)}const Be=Y?AP(re):ad;for(C=Be.length-1,ie=z-1;ie>=0;ie--){const $e=Me+ie,Ne=$[$e],Fe=$e+1<de?$[$e+1].el:U;re[ie]===0?m(null,Ne,G,Fe,W,J,ee,ne,ce):Y&&(C<0||ie!==Be[C]?E(Ne,G,Fe,2):C--)}}},E=(D,$,G,U,W=null)=>{const{el:J,type:ee,transition:ne,children:ce,shapeFlag:ie}=D;if(ie&6){E(D.component.subTree,$,G,U);return}if(ie&128){D.suspense.move($,G,U);return}if(ie&64){ee.move(D,$,G,Re);return}if(ee===Vt){s(J,$,G);for(let we=0;we<ce.length;we++)E(ce[we],$,G,U);s(D.anchor,$,G);return}if(ee===kp){w(D,$,G);return}if(U!==2&&ie&1&&ne)if(U===0)ne.beforeEnter(J),s(J,$,G),xi(()=>ne.enter(J),W);else{const{leave:we,delayLeave:ue,afterLeave:Oe}=ne,Me=()=>s(J,$,G),L=()=>{we(J,()=>{Me(),Oe&&Oe()})};ue?ue(J,Me,L):L()}else s(J,$,G)},j=(D,$,G,U=!1,W=!1)=>{const{type:J,props:ee,ref:ne,children:ce,dynamicChildren:ie,shapeFlag:de,patchFlag:we,dirs:ue}=D;if(ne!=null&&Zg(ne,null,G,D,!0),de&256){$.ctx.deactivate(D);return}const Oe=de&1&&ue,Me=!Rh(D);let L;if(Me&&(L=ee&&ee.onVnodeBeforeUnmount)&&An(L,$,D),de&6)Se(D.component,G,U);else{if(de&128){D.suspense.unmount(G,U);return}Oe&&ma(D,null,$,"beforeUnmount"),de&64?D.type.remove(D,$,G,W,Re,U):ie&&(J!==Vt||we>0&&we&64)?he(ie,$,G,!1,!0):(J===Vt&&we&384||!W&&de&16)&&he(ce,$,G),U&&X(D)}(Me&&(L=ee&&ee.onVnodeUnmounted)||Oe)&&xi(()=>{L&&An(L,$,D),Oe&&ma(D,null,$,"unmounted")},G)},X=D=>{const{type:$,el:G,anchor:U,transition:W}=D;if($===Vt){Q(G,U);return}if($===kp){S(D);return}const J=()=>{i(G),W&&!W.persisted&&W.afterLeave&&W.afterLeave()};if(D.shapeFlag&1&&W&&!W.persisted){const{leave:ee,delayLeave:ne}=W,ce=()=>ee(G,J);ne?ne(D.el,J,ce):ce()}else J()},Q=(D,$)=>{let G;for(;D!==$;)G=h(D),i(D),D=G;i($)},Se=(D,$,G)=>{const{bum:U,scope:W,update:J,subTree:ee,um:ne}=D;U&&gp(U),W.stop(),J&&(J.active=!1,j(ee,D,$,G)),ne&&xi(ne,$),xi(()=>{D.isUnmounted=!0},$),$&&$.pendingBranch&&!$.isUnmounted&&D.asyncDep&&!D.asyncResolved&&D.suspenseId===$.pendingId&&($.deps--,$.deps===0&&$.resolve())},he=(D,$,G,U=!1,W=!1,J=0)=>{for(let ee=J;ee<D.length;ee++)j(D[ee],$,G,U,W)},xe=D=>D.shapeFlag&6?xe(D.component.subTree):D.shapeFlag&128?D.suspense.next():h(D.anchor||D.el),Ae=(D,$,G)=>{D==null?$._vnode&&j($._vnode,null,null,!0):m($._vnode||null,D,$,null,null,null,G),aw(),CI(),$._vnode=D},Re={p:m,um:j,m:E,r:X,mt:A,mc:_,pc:H,pbc:M,n:xe,o:f};let He,qt;return e&&([He,qt]=e(Re)),{render:Ae,hydrate:He,createApp:CP(Ae,He)}}function ga({effect:f,update:e},t){f.allowRecurse=e.allowRecurse=t}function eb(f,e,t=!1){const s=f.children,i=e.children;if(Ue(s)&&Ue(i))for(let n=0;n<s.length;n++){const r=s[n];let a=i[n];a.shapeFlag&1&&!a.dynamicChildren&&((a.patchFlag<=0||a.patchFlag===32)&&(a=i[n]=ia(i[n]),a.el=r.el),t||eb(r,a)),a.type===vl&&(a.el=r.el)}}function AP(f){const e=f.slice(),t=[0];let s,i,n,r,a;const o=f.length;for(s=0;s<o;s++){const d=f[s];if(d!==0){if(i=t[t.length-1],f[i]<d){e[s]=i,t.push(s);continue}for(n=0,r=t.length-1;n<r;)a=n+r>>1,f[t[a]]<d?n=a+1:r=a;d<f[t[n]]&&(n>0&&(e[s]=t[n-1]),t[n]=s)}}for(n=t.length,r=t[n-1];n-- >0;)t[n]=r,r=e[r];return t}const BP=f=>f.__isTeleport,ru=f=>f&&(f.disabled||f.disabled===""),gw=f=>typeof SVGElement<"u"&&f instanceof SVGElement,Jg=(f,e)=>{const t=f&&f.to;return ms(t)?e?e(t):null:t},NP={__isTeleport:!0,process(f,e,t,s,i,n,r,a,o,d){const{mc:c,pc:u,pbc:h,o:{insert:l,querySelector:p,createText:m,createComment:g}}=d,y=ru(e.props);let{shapeFlag:b,children:w,dynamicChildren:S}=e;if(f==null){const k=e.el=m(""),T=e.anchor=m("");l(k,t,s),l(T,t,s);const I=e.target=Jg(e.props,p),_=e.targetAnchor=m("");I&&(l(_,I),r=r||gw(I));const N=(M,x)=>{b&16&&c(w,M,x,i,n,r,a,o)};y?N(t,T):I&&N(I,_)}else{e.el=f.el;const k=e.anchor=f.anchor,T=e.target=f.target,I=e.targetAnchor=f.targetAnchor,_=ru(f.props),N=_?t:T,M=_?k:I;if(r=r||gw(T),S?(h(f.dynamicChildren,S,N,i,n,r,a),eb(f,e,!0)):o||u(f,e,N,M,i,n,r,a,!1),y)_||Ju(e,t,k,d,1);else if((e.props&&e.props.to)!==(f.props&&f.props.to)){const x=e.target=Jg(e.props,p);x&&Ju(e,x,null,d,0)}else _&&Ju(e,T,I,d,1)}QI(e)},remove(f,e,t,s,{um:i,o:{remove:n}},r){const{shapeFlag:a,children:o,anchor:d,targetAnchor:c,target:u,props:h}=f;if(u&&n(c),(r||!ru(h))&&(n(d),a&16))for(let l=0;l<o.length;l++){const p=o[l];i(p,e,t,!0,!!p.dynamicChildren)}},move:Ju,hydrate:EP};function Ju(f,e,t,{o:{insert:s},m:i},n=2){n===0&&s(f.targetAnchor,e,t);const{el:r,anchor:a,shapeFlag:o,children:d,props:c}=f,u=n===2;if(u&&s(r,e,t),(!u||ru(c))&&o&16)for(let h=0;h<d.length;h++)i(d[h],e,t,2);u&&s(a,e,t)}function EP(f,e,t,s,i,n,{o:{nextSibling:r,parentNode:a,querySelector:o}},d){const c=e.target=Jg(e.props,o);if(c){const u=c._lpa||c.firstChild;if(e.shapeFlag&16)if(ru(e.props))e.anchor=d(r(f),e,a(f),t,s,i,n),e.targetAnchor=u;else{e.anchor=r(f);let h=u;for(;h;)if(h=r(h),h&&h.nodeType===8&&h.data==="teleport anchor"){e.targetAnchor=h,c._lpa=e.targetAnchor&&r(e.targetAnchor);break}d(u,e,c,t,s,i,n)}QI(e)}return e.anchor&&r(e.anchor)}const VP=NP;function QI(f){const e=f.ctx;if(e&&e.ut){let t=f.children[0].el;for(;t!==f.targetAnchor;)t.nodeType===1&&t.setAttribute("data-v-owner",e.uid),t=t.nextSibling;e.ut()}}const Vt=Symbol(void 0),vl=Symbol(void 0),Pn=Symbol(void 0),kp=Symbol(void 0),au=[];let Cn=null;function St(f=!1){au.push(Cn=f?null:[])}function qP(){au.pop(),Cn=au[au.length-1]||null}let gu=1;function yw(f){gu+=f}function ZI(f){return f.dynamicChildren=gu>0?Cn||ad:null,qP(),gu>0&&Cn&&Cn.push(f),f}function ya(f,e,t,s,i,n){return ZI($s(f,e,t,s,i,n,!0))}function Kt(f,e,t,s,i){return ZI(K(f,e,t,s,i,!0))}function ey(f){return f?f.__v_isVNode===!0:!1}function eo(f,e){return f.type===e.type&&f.key===e.key}const Tl="__vInternal",JI=({key:f})=>f!=null?f:null,Fh=({ref:f,ref_key:e,ref_for:t})=>f!=null?ms(f)||Xt(f)||ze(f)?{i:qi,r:f,k:e,f:!!t}:f:null;function $s(f,e=null,t=null,s=0,i=null,n=f===Vt?0:1,r=!1,a=!1){const o={__v_isVNode:!0,__v_skip:!0,type:f,props:e,key:e&&JI(e),ref:e&&Fh(e),scopeId:AI,slotScopeIds:null,children:t,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetAnchor:null,staticCount:0,shapeFlag:n,patchFlag:s,dynamicProps:i,dynamicChildren:null,appContext:null,ctx:qi};return a?(tb(o,t),n&128&&f.normalize(o)):t&&(o.shapeFlag|=ms(t)?8:16),gu>0&&!r&&Cn&&(o.patchFlag>0||n&6)&&o.patchFlag!==32&&Cn.push(o),o}const K=LP;function LP(f,e=null,t=null,s=0,i=null,n=!1){if((!f||f===GI)&&(f=Pn),ey(f)){const a=gr(f,e,!0);return t&&tb(a,t),gu>0&&!n&&Cn&&(a.shapeFlag&6?Cn[Cn.indexOf(f)]=a:Cn.push(a)),a.patchFlag|=-2,a}if(zP(f)&&(f=f.__vccOpts),e){e=RP(e);let{class:a,style:o}=e;a&&!ms(a)&&(e.class=Ny(a)),At(o)&&(bI(o)&&!Ue(o)&&(o=Es({},o)),e.style=By(o))}const r=ms(f)?1:iP(f)?128:BP(f)?64:At(f)?4:ze(f)?2:0;return $s(f,e,t,s,i,r,n,!0)}function RP(f){return f?bI(f)||Tl in f?Es({},f):f:null}function gr(f,e,t=!1){const{props:s,ref:i,patchFlag:n,children:r}=f,a=e?ct(s||{},e):s;return{__v_isVNode:!0,__v_skip:!0,type:f.type,props:a,key:a&&JI(a),ref:e&&e.ref?t&&i?Ue(i)?i.concat(Fh(e)):[i,Fh(e)]:Fh(e):i,scopeId:f.scopeId,slotScopeIds:f.slotScopeIds,children:r,target:f.target,targetAnchor:f.targetAnchor,staticCount:f.staticCount,shapeFlag:f.shapeFlag,patchFlag:e&&f.type!==Vt?n===-1?16:n|16:n,dynamicProps:f.dynamicProps,dynamicChildren:f.dynamicChildren,appContext:f.appContext,dirs:f.dirs,transition:f.transition,component:f.component,suspense:f.suspense,ssContent:f.ssContent&&gr(f.ssContent),ssFallback:f.ssFallback&&gr(f.ssFallback),el:f.el,anchor:f.anchor,ctx:f.ctx}}function ht(f=" ",e=0){return K(vl,null,f,e)}function Bt(f="",e=!1){return e?(St(),Kt(Pn,null,f)):K(Pn,null,f)}function jn(f){return f==null||typeof f=="boolean"?K(Pn):Ue(f)?K(Vt,null,f.slice()):typeof f=="object"?ia(f):K(vl,null,String(f))}function ia(f){return f.el===null&&f.patchFlag!==-1||f.memo?f:gr(f)}function tb(f,e){let t=0;const{shapeFlag:s}=f;if(e==null)e=null;else if(Ue(e))t=16;else if(typeof e=="object")if(s&65){const i=e.default;i&&(i._c&&(i._d=!1),tb(f,i()),i._c&&(i._d=!0));return}else{t=32;const i=e._;!i&&!(Tl in e)?e._ctx=qi:i===3&&qi&&(qi.slots._===1?e._=1:(e._=2,f.patchFlag|=1024))}else ze(e)?(e={default:e,_ctx:qi},t=32):(e=String(e),s&64?(t=16,e=[ht(e)]):t=8);f.children=e,f.shapeFlag|=t}function ct(...f){const e={};for(let t=0;t<f.length;t++){const s=f[t];for(const i in s)if(i==="class")e.class!==s.class&&(e.class=Ny([e.class,s.class]));else if(i==="style")e.style=By([e.style,s.style]);else if(hl(i)){const n=e[i],r=s[i];r&&n!==r&&!(Ue(n)&&n.includes(r))&&(e[i]=n?[].concat(n,r):r)}else i!==""&&(e[i]=s[i])}return e}function An(f,e,t,s=null){cn(f,e,7,[t,s])}const FP=YI();let DP=0;function HP(f,e,t){const s=f.type,i=(e?e.appContext:f.appContext)||FP,n={uid:DP++,vnode:f,type:s,parent:e,appContext:i,root:null,next:null,subTree:null,effect:null,update:null,scope:new aI(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:e?e.provides:Object.create(i.provides),accessCache:null,renderCache:[],components:null,directives:null,propsOptions:WI(s,i),emitsOptions:PI(s,i),emit:null,emitted:null,propsDefaults:Pt,inheritAttrs:s.inheritAttrs,ctx:Pt,data:Pt,props:Pt,attrs:Pt,slots:Pt,refs:Pt,setupState:Pt,setupContext:null,suspense:t,suspenseId:t?t.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return n.ctx={_:n},n.root=e?e.root:n,n.emit=ZM.bind(null,n),f.ce&&f.ce(n),n}let Ns=null;const Ol=()=>Ns||qi,pd=f=>{Ns=f,f.scope.on()},ao=()=>{Ns&&Ns.scope.off(),Ns=null};function ex(f){return f.vnode.shapeFlag&4}let yu=!1;function GP(f,e=!1){yu=e;const{props:t,children:s}=f.vnode,i=ex(f);vP(f,t,i,e),IP(f,s);const n=i?UP(f,e):void 0;return yu=!1,n}function UP(f,e){const t=f.type;f.accessCache=Object.create(null),f.proxy=wI(new Proxy(f.ctx,gP));const{setup:s}=t;if(s){const i=f.setupContext=s.length>1?jP(f):null;pd(f),kd();const n=aa(s,f,0,[f.props,i]);if(vd(),ao(),iI(n)){if(n.then(ao,ao),e)return n.then(r=>{bw(f,r,e)}).catch(r=>{yl(r,f,0)});f.asyncDep=n}else bw(f,n,e)}else tx(f,e)}function bw(f,e,t){ze(e)?f.type.__ssrInlineRender?f.ssrRender=e:f.render=e:At(e)&&(f.setupState=TI(e)),tx(f,t)}let ww;function tx(f,e,t){const s=f.type;if(!f.render){if(!e&&ww&&!s.render){const i=s.template||Zy(f).template;if(i){const{isCustomElement:n,compilerOptions:r}=f.appContext.config,{delimiters:a,compilerOptions:o}=s,d=Es(Es({isCustomElement:n,delimiters:a},r),o);s.render=ww(i,d)}}f.render=s.render||Mn}pd(f),kd(),yP(f),vd(),ao()}function $P(f){return new Proxy(f.attrs,{get(e,t){return Li(f,"get","$attrs"),e[t]}})}function jP(f){const e=s=>{f.exposed=s||{}};let t;return{get attrs(){return t||(t=$P(f))},slots:f.slots,emit:f.emit,expose:e}}function Il(f){if(f.exposed)return f.exposeProxy||(f.exposeProxy=new Proxy(TI(wI(f.exposed)),{get(e,t){if(t in e)return e[t];if(t in nu)return nu[t](f)},has(e,t){return t in e||t in nu}}))}function WP(f,e=!0){return ze(f)?f.displayName||f.name:f.name||e&&f.__name}function zP(f){return ze(f)&&"__vccOpts"in f}const te=(f,e)=>II(f,e,yu);function ha(f,e,t){const s=arguments.length;return s===2?At(e)&&!Ue(e)?ey(e)?K(f,null,[e]):K(f,e):K(f,null,e):(s>3?t=Array.prototype.slice.call(arguments,2):s===3&&ey(t)&&(t=[t]),K(f,e,t))}const KP=Symbol(""),XP=()=>Yt(KP),YP="3.2.45",QP="http://www.w3.org/2000/svg",to=typeof document<"u"?document:null,Sw=to&&to.createElement("template"),ZP={insert:(f,e,t)=>{e.insertBefore(f,t||null)},remove:f=>{const e=f.parentNode;e&&e.removeChild(f)},createElement:(f,e,t,s)=>{const i=e?to.createElementNS(QP,f):to.createElement(f,t?{is:t}:void 0);return f==="select"&&s&&s.multiple!=null&&i.setAttribute("multiple",s.multiple),i},createText:f=>to.createTextNode(f),createComment:f=>to.createComment(f),setText:(f,e)=>{f.nodeValue=e},setElementText:(f,e)=>{f.textContent=e},parentNode:f=>f.parentNode,nextSibling:f=>f.nextSibling,querySelector:f=>to.querySelector(f),setScopeId(f,e){f.setAttribute(e,"")},insertStaticContent(f,e,t,s,i,n){const r=t?t.previousSibling:e.lastChild;if(i&&(i===n||i.nextSibling))for(;e.insertBefore(i.cloneNode(!0),t),!(i===n||!(i=i.nextSibling)););else{Sw.innerHTML=s?`<svg>${f}</svg>`:f;const a=Sw.content;if(s){const o=a.firstChild;for(;o.firstChild;)a.appendChild(o.firstChild);a.removeChild(o)}e.insertBefore(a,t)}return[r?r.nextSibling:e.firstChild,t?t.previousSibling:e.lastChild]}};function JP(f,e,t){const s=f._vtc;s&&(e=(e?[e,...s]:[...s]).join(" ")),e==null?f.removeAttribute("class"):t?f.setAttribute("class",e):f.className=e}function eA(f,e,t){const s=f.style,i=ms(t);if(t&&!i){for(const n in t)ty(s,n,t[n]);if(e&&!ms(e))for(const n in e)t[n]==null&&ty(s,n,"")}else{const n=s.display;i?e!==t&&(s.cssText=t):e&&f.removeAttribute("style"),"_vod"in f&&(s.display=n)}}const kw=/\s*!important$/;function ty(f,e,t){if(Ue(t))t.forEach(s=>ty(f,e,s));else if(t==null&&(t=""),e.startsWith("--"))f.setProperty(e,t);else{const s=tA(f,e);kw.test(t)?f.setProperty(Sd(s),t.replace(kw,""),"important"):f[s]=t}}const vw=["Webkit","Moz","ms"],vp={};function tA(f,e){const t=vp[e];if(t)return t;let s=fn(e);if(s!=="filter"&&s in f)return vp[e]=s;s=br(s);for(let i=0;i<vw.length;i++){const n=vw[i]+s;if(n in f)return vp[e]=n}return e}const Tw="http://www.w3.org/1999/xlink";function sA(f,e,t,s,i){if(s&&e.startsWith("xlink:"))t==null?f.removeAttributeNS(Tw,e.slice(6,e.length)):f.setAttributeNS(Tw,e,t);else{const n=dM(e);t==null||n&&!eI(t)?f.removeAttribute(e):f.setAttribute(e,n?"":t)}}function iA(f,e,t,s,i,n,r){if(e==="innerHTML"||e==="textContent"){s&&r(s,i,n),f[e]=t==null?"":t;return}if(e==="value"&&f.tagName!=="PROGRESS"&&!f.tagName.includes("-")){f._value=t;const o=t==null?"":t;(f.value!==o||f.tagName==="OPTION")&&(f.value=o),t==null&&f.removeAttribute(e);return}let a=!1;if(t===""||t==null){const o=typeof f[e];o==="boolean"?t=eI(t):t==null&&o==="string"?(t="",a=!0):o==="number"&&(t=0,a=!0)}try{f[e]=t}catch{}a&&f.removeAttribute(e)}function nA(f,e,t,s){f.addEventListener(e,t,s)}function rA(f,e,t,s){f.removeEventListener(e,t,s)}function aA(f,e,t,s,i=null){const n=f._vei||(f._vei={}),r=n[e];if(s&&r)r.value=s;else{const[a,o]=oA(e);if(s){const d=n[e]=uA(s,i);nA(f,a,d,o)}else r&&(rA(f,a,r,o),n[e]=void 0)}}const Ow=/(?:Once|Passive|Capture)$/;function oA(f){let e;if(Ow.test(f)){e={};let s;for(;s=f.match(Ow);)f=f.slice(0,f.length-s[0].length),e[s[0].toLowerCase()]=!0}return[f[2]===":"?f.slice(3):Sd(f.slice(2)),e]}let Tp=0;const dA=Promise.resolve(),cA=()=>Tp||(dA.then(()=>Tp=0),Tp=Date.now());function uA(f,e){const t=s=>{if(!s._vts)s._vts=Date.now();else if(s._vts<=t.attached)return;cn(fA(s,t.value),e,5,[s])};return t.value=f,t.attached=cA(),t}function fA(f,e){if(Ue(e)){const t=f.stopImmediatePropagation;return f.stopImmediatePropagation=()=>{t.call(f),f._stopped=!0},e.map(s=>i=>!i._stopped&&s&&s(i))}else return e}const Iw=/^on[a-z]/,hA=(f,e,t,s,i=!1,n,r,a,o)=>{e==="class"?JP(f,s,i):e==="style"?eA(f,t,s):hl(e)?Ey(e)||aA(f,e,t,s,r):(e[0]==="."?(e=e.slice(1),!0):e[0]==="^"?(e=e.slice(1),!1):lA(f,e,s,i))?iA(f,e,s,n,r,a,o):(e==="true-value"?f._trueValue=s:e==="false-value"&&(f._falseValue=s),sA(f,e,s,i))};function lA(f,e,t,s){return s?!!(e==="innerHTML"||e==="textContent"||e in f&&Iw.test(e)&&ze(t)):e==="spellcheck"||e==="draggable"||e==="translate"||e==="form"||e==="list"&&f.tagName==="INPUT"||e==="type"&&f.tagName==="TEXTAREA"||Iw.test(e)&&ms(t)?!1:e in f}const Cr="transition",Ld="animation",Yn=(f,{slots:e})=>ha(EI,ix(f),e);Yn.displayName="Transition";const sx={name:String,type:String,css:{type:Boolean,default:!0},duration:[String,Number,Object],enterFromClass:String,enterActiveClass:String,enterToClass:String,appearFromClass:String,appearActiveClass:String,appearToClass:String,leaveFromClass:String,leaveActiveClass:String,leaveToClass:String},pA=Yn.props=Es({},EI.props,sx),ba=(f,e=[])=>{Ue(f)?f.forEach(t=>t(...e)):f&&f(...e)},xw=f=>f?Ue(f)?f.some(e=>e.length>1):f.length>1:!1;function ix(f){const e={};for(const v in f)v in sx||(e[v]=f[v]);if(f.css===!1)return e;const{name:t="v",type:s,duration:i,enterFromClass:n=`${t}-enter-from`,enterActiveClass:r=`${t}-enter-active`,enterToClass:a=`${t}-enter-to`,appearFromClass:o=n,appearActiveClass:d=r,appearToClass:c=a,leaveFromClass:u=`${t}-leave-from`,leaveActiveClass:h=`${t}-leave-active`,leaveToClass:l=`${t}-leave-to`}=f,p=mA(i),m=p&&p[0],g=p&&p[1],{onBeforeEnter:y,onEnter:b,onEnterCancelled:w,onLeave:S,onLeaveCancelled:k,onBeforeAppear:T=y,onAppear:I=b,onAppearCancelled:_=w}=e,N=(v,O,A)=>{sa(v,O?c:a),sa(v,O?d:r),A&&A()},M=(v,O)=>{v._isLeaving=!1,sa(v,u),sa(v,l),sa(v,h),O&&O()},x=v=>(O,A)=>{const V=v?I:b,q=()=>N(O,v,A);ba(V,[O,q]),_w(()=>{sa(O,v?o:n),ur(O,v?c:a),xw(V)||Cw(O,s,m,q)})};return Es(e,{onBeforeEnter(v){ba(y,[v]),ur(v,n),ur(v,r)},onBeforeAppear(v){ba(T,[v]),ur(v,o),ur(v,d)},onEnter:x(!1),onAppear:x(!0),onLeave(v,O){v._isLeaving=!0;const A=()=>M(v,O);ur(v,u),rx(),ur(v,h),_w(()=>{!v._isLeaving||(sa(v,u),ur(v,l),xw(S)||Cw(v,s,g,A))}),ba(S,[v,A])},onEnterCancelled(v){N(v,!1),ba(w,[v])},onAppearCancelled(v){N(v,!0),ba(_,[v])},onLeaveCancelled(v){M(v),ba(k,[v])}})}function mA(f){if(f==null)return null;if(At(f))return[Op(f.enter),Op(f.leave)];{const e=Op(f);return[e,e]}}function Op(f){return Ry(f)}function ur(f,e){e.split(/\s+/).forEach(t=>t&&f.classList.add(t)),(f._vtc||(f._vtc=new Set)).add(e)}function sa(f,e){e.split(/\s+/).forEach(s=>s&&f.classList.remove(s));const{_vtc:t}=f;t&&(t.delete(e),t.size||(f._vtc=void 0))}function _w(f){requestAnimationFrame(()=>{requestAnimationFrame(f)})}let gA=0;function Cw(f,e,t,s){const i=f._endId=++gA,n=()=>{i===f._endId&&s()};if(t)return setTimeout(n,t);const{type:r,timeout:a,propCount:o}=nx(f,e);if(!r)return s();const d=r+"end";let c=0;const u=()=>{f.removeEventListener(d,h),n()},h=l=>{l.target===f&&++c>=o&&u()};setTimeout(()=>{c<o&&u()},a+1),f.addEventListener(d,h)}function nx(f,e){const t=window.getComputedStyle(f),s=p=>(t[p]||"").split(", "),i=s(`${Cr}Delay`),n=s(`${Cr}Duration`),r=Mw(i,n),a=s(`${Ld}Delay`),o=s(`${Ld}Duration`),d=Mw(a,o);let c=null,u=0,h=0;e===Cr?r>0&&(c=Cr,u=r,h=n.length):e===Ld?d>0&&(c=Ld,u=d,h=o.length):(u=Math.max(r,d),c=u>0?r>d?Cr:Ld:null,h=c?c===Cr?n.length:o.length:0);const l=c===Cr&&/\b(transform|all)(,|$)/.test(s(`${Cr}Property`).toString());return{type:c,timeout:u,propCount:h,hasTransform:l}}function Mw(f,e){for(;f.length<e.length;)f=f.concat(f);return Math.max(...e.map((t,s)=>Pw(t)+Pw(f[s])))}function Pw(f){return Number(f.slice(0,-1).replace(",","."))*1e3}function rx(){return document.body.offsetHeight}const ax=new WeakMap,ox=new WeakMap,yA={name:"TransitionGroup",props:Es({},pA,{tag:String,moveClass:String}),setup(f,{slots:e}){const t=Ol(),s=NI();let i,n;return FI(()=>{if(!i.length)return;const r=f.moveClass||`${f.name||"v"}-move`;if(!vA(i[0].el,t.vnode.el,r))return;i.forEach(wA),i.forEach(SA);const a=i.filter(kA);rx(),a.forEach(o=>{const d=o.el,c=d.style;ur(d,r),c.transform=c.webkitTransform=c.transitionDuration="";const u=d._moveCb=h=>{h&&h.target!==d||(!h||/transform$/.test(h.propertyName))&&(d.removeEventListener("transitionend",u),d._moveCb=null,sa(d,r))};d.addEventListener("transitionend",u)})}),()=>{const r=ut(f),a=ix(r);let o=r.tag||Vt;i=n,n=e.default?Yy(e.default()):[];for(let d=0;d<n.length;d++){const c=n[d];c.key!=null&&mu(c,pu(c,a,s,t))}if(i)for(let d=0;d<i.length;d++){const c=i[d];mu(c,pu(c,a,s,t)),ax.set(c,c.el.getBoundingClientRect())}return K(o,null,n)}}},bA=yA;function wA(f){const e=f.el;e._moveCb&&e._moveCb(),e._enterCb&&e._enterCb()}function SA(f){ox.set(f,f.el.getBoundingClientRect())}function kA(f){const e=ax.get(f),t=ox.get(f),s=e.left-t.left,i=e.top-t.top;if(s||i){const n=f.el.style;return n.transform=n.webkitTransform=`translate(${s}px,${i}px)`,n.transitionDuration="0s",f}}function vA(f,e,t){const s=f.cloneNode();f._vtc&&f._vtc.forEach(r=>{r.split(/\s+/).forEach(a=>a&&s.classList.remove(a))}),t.split(/\s+/).forEach(r=>r&&s.classList.add(r)),s.style.display="none";const i=e.nodeType===1?e:e.parentNode;i.appendChild(s);const{hasTransform:n}=nx(s);return i.removeChild(s),n}const Td={beforeMount(f,{value:e},{transition:t}){f._vod=f.style.display==="none"?"":f.style.display,t&&e?t.beforeEnter(f):Rd(f,e)},mounted(f,{value:e},{transition:t}){t&&e&&t.enter(f)},updated(f,{value:e,oldValue:t},{transition:s}){!e!=!t&&(s?e?(s.beforeEnter(f),Rd(f,!0),s.enter(f)):s.leave(f,()=>{Rd(f,!1)}):Rd(f,e))},beforeUnmount(f,{value:e}){Rd(f,e)}};function Rd(f,e){f.style.display=e?f._vod:"none"}const TA=Es({patchProp:hA},ZP);let Aw;function OA(){return Aw||(Aw=MP(TA))}const IA=(...f)=>{const e=OA().createApp(...f),{mount:t}=e;return e.mount=s=>{const i=xA(s);if(!i)return;const n=e._component;!ze(n)&&!n.render&&!n.template&&(n.template=i.innerHTML),i.innerHTML="";const r=t(i,!1,i instanceof SVGElement);return i instanceof Element&&(i.removeAttribute("v-cloak"),i.setAttribute("data-v-app","")),r},e};function xA(f){return ms(f)?document.querySelector(f):f}function dx(f,e){return function(){return f.apply(e,arguments)}}const{toString:cx}=Object.prototype,{getPrototypeOf:sb}=Object,ib=(f=>e=>{const t=cx.call(e);return f[t]||(f[t]=t.slice(8,-1).toLowerCase())})(Object.create(null)),kr=f=>(f=f.toLowerCase(),e=>ib(e)===f),xl=f=>e=>typeof e===f,{isArray:xu}=Array,sy=xl("undefined");function _A(f){return f!==null&&!sy(f)&&f.constructor!==null&&!sy(f.constructor)&&Od(f.constructor.isBuffer)&&f.constructor.isBuffer(f)}const ux=kr("ArrayBuffer");function CA(f){let e;return typeof ArrayBuffer<"u"&&ArrayBuffer.isView?e=ArrayBuffer.isView(f):e=f&&f.buffer&&ux(f.buffer),e}const MA=xl("string"),Od=xl("function"),fx=xl("number"),hx=f=>f!==null&&typeof f=="object",PA=f=>f===!0||f===!1,Dh=f=>{if(ib(f)!=="object")return!1;const e=sb(f);return(e===null||e===Object.prototype||Object.getPrototypeOf(e)===null)&&!(Symbol.toStringTag in f)&&!(Symbol.iterator in f)},AA=kr("Date"),BA=kr("File"),NA=kr("Blob"),EA=kr("FileList"),VA=f=>hx(f)&&Od(f.pipe),qA=f=>{const e="[object FormData]";return f&&(typeof FormData=="function"&&f instanceof FormData||cx.call(f)===e||Od(f.toString)&&f.toString()===e)},LA=kr("URLSearchParams"),RA=f=>f.trim?f.trim():f.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"");function _l(f,e,{allOwnKeys:t=!1}={}){if(f===null||typeof f>"u")return;let s,i;if(typeof f!="object"&&(f=[f]),xu(f))for(s=0,i=f.length;s<i;s++)e.call(null,f[s],s,f);else{const n=t?Object.getOwnPropertyNames(f):Object.keys(f),r=n.length;let a;for(s=0;s<r;s++)a=n[s],e.call(null,f[a],a,f)}}function iy(){const f={},e=(t,s)=>{Dh(f[s])&&Dh(t)?f[s]=iy(f[s],t):Dh(t)?f[s]=iy({},t):xu(t)?f[s]=t.slice():f[s]=t};for(let t=0,s=arguments.length;t<s;t++)arguments[t]&&_l(arguments[t],e);return f}const FA=(f,e,t,{allOwnKeys:s}={})=>(_l(e,(i,n)=>{t&&Od(i)?f[n]=dx(i,t):f[n]=i},{allOwnKeys:s}),f),DA=f=>(f.charCodeAt(0)===65279&&(f=f.slice(1)),f),HA=(f,e,t,s)=>{f.prototype=Object.create(e.prototype,s),f.prototype.constructor=f,Object.defineProperty(f,"super",{value:e.prototype}),t&&Object.assign(f.prototype,t)},GA=(f,e,t,s)=>{let i,n,r;const a={};if(e=e||{},f==null)return e;do{for(i=Object.getOwnPropertyNames(f),n=i.length;n-- >0;)r=i[n],(!s||s(r,f,e))&&!a[r]&&(e[r]=f[r],a[r]=!0);f=t!==!1&&sb(f)}while(f&&(!t||t(f,e))&&f!==Object.prototype);return e},UA=(f,e,t)=>{f=String(f),(t===void 0||t>f.length)&&(t=f.length),t-=e.length;const s=f.indexOf(e,t);return s!==-1&&s===t},$A=f=>{if(!f)return null;if(xu(f))return f;let e=f.length;if(!fx(e))return null;const t=new Array(e);for(;e-- >0;)t[e]=f[e];return t},jA=(f=>e=>f&&e instanceof f)(typeof Uint8Array<"u"&&sb(Uint8Array)),WA=(f,e)=>{const s=(f&&f[Symbol.iterator]).call(f);let i;for(;(i=s.next())&&!i.done;){const n=i.value;e.call(f,n[0],n[1])}},zA=(f,e)=>{let t;const s=[];for(;(t=f.exec(e))!==null;)s.push(t);return s},KA=kr("HTMLFormElement"),XA=f=>f.toLowerCase().replace(/[_-\s]([a-z\d])(\w*)/g,function(t,s,i){return s.toUpperCase()+i}),Bw=(({hasOwnProperty:f})=>(e,t)=>f.call(e,t))(Object.prototype),YA=kr("RegExp"),lx=(f,e)=>{const t=Object.getOwnPropertyDescriptors(f),s={};_l(t,(i,n)=>{e(i,n,f)!==!1&&(s[n]=i)}),Object.defineProperties(f,s)},QA=f=>{lx(f,(e,t)=>{const s=f[t];if(!!Od(s)){if(e.enumerable=!1,"writable"in e){e.writable=!1;return}e.set||(e.set=()=>{throw Error("Can not read-only method '"+t+"'")})}})},ZA=(f,e)=>{const t={},s=i=>{i.forEach(n=>{t[n]=!0})};return xu(f)?s(f):s(String(f).split(e)),t},JA=()=>{},eB=(f,e)=>(f=+f,Number.isFinite(f)?f:e),fe={isArray:xu,isArrayBuffer:ux,isBuffer:_A,isFormData:qA,isArrayBufferView:CA,isString:MA,isNumber:fx,isBoolean:PA,isObject:hx,isPlainObject:Dh,isUndefined:sy,isDate:AA,isFile:BA,isBlob:NA,isRegExp:YA,isFunction:Od,isStream:VA,isURLSearchParams:LA,isTypedArray:jA,isFileList:EA,forEach:_l,merge:iy,extend:FA,trim:RA,stripBOM:DA,inherits:HA,toFlatObject:GA,kindOf:ib,kindOfTest:kr,endsWith:UA,toArray:$A,forEachEntry:WA,matchAll:zA,isHTMLForm:KA,hasOwnProperty:Bw,hasOwnProp:Bw,reduceDescriptors:lx,freezeMethods:QA,toObjectSet:ZA,toCamelCase:XA,noop:JA,toFiniteNumber:eB};function lt(f,e,t,s,i){Error.call(this),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=new Error().stack,this.message=f,this.name="AxiosError",e&&(this.code=e),t&&(this.config=t),s&&(this.request=s),i&&(this.response=i)}fe.inherits(lt,Error,{toJSON:function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:this.config,code:this.code,status:this.response&&this.response.status?this.response.status:null}}});const px=lt.prototype,mx={};["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED","ERR_NOT_SUPPORT","ERR_INVALID_URL"].forEach(f=>{mx[f]={value:f}});Object.defineProperties(lt,mx);Object.defineProperty(px,"isAxiosError",{value:!0});lt.from=(f,e,t,s,i,n)=>{const r=Object.create(px);return fe.toFlatObject(f,r,function(o){return o!==Error.prototype},a=>a!=="isAxiosError"),lt.call(r,f.message,e,t,s,i),r.cause=f,r.name=f.name,n&&Object.assign(r,n),r};var tB=typeof self=="object"?self.FormData:window.FormData;function ny(f){return fe.isPlainObject(f)||fe.isArray(f)}function gx(f){return fe.endsWith(f,"[]")?f.slice(0,-2):f}function Nw(f,e,t){return f?f.concat(e).map(function(i,n){return i=gx(i),!t&&n?"["+i+"]":i}).join(t?".":""):e}function sB(f){return fe.isArray(f)&&!f.some(ny)}const iB=fe.toFlatObject(fe,{},null,function(e){return/^is[A-Z]/.test(e)});function nB(f){return f&&fe.isFunction(f.append)&&f[Symbol.toStringTag]==="FormData"&&f[Symbol.iterator]}function Cl(f,e,t){if(!fe.isObject(f))throw new TypeError("target must be an object");e=e||new(tB||FormData),t=fe.toFlatObject(t,{metaTokens:!0,dots:!1,indexes:!1},!1,function(m,g){return!fe.isUndefined(g[m])});const s=t.metaTokens,i=t.visitor||c,n=t.dots,r=t.indexes,o=(t.Blob||typeof Blob<"u"&&Blob)&&nB(e);if(!fe.isFunction(i))throw new TypeError("visitor must be a function");function d(p){if(p===null)return"";if(fe.isDate(p))return p.toISOString();if(!o&&fe.isBlob(p))throw new lt("Blob is not supported. Use a Buffer instead.");return fe.isArrayBuffer(p)||fe.isTypedArray(p)?o&&typeof Blob=="function"?new Blob([p]):Buffer.from(p):p}function c(p,m,g){let y=p;if(p&&!g&&typeof p=="object"){if(fe.endsWith(m,"{}"))m=s?m:m.slice(0,-2),p=JSON.stringify(p);else if(fe.isArray(p)&&sB(p)||fe.isFileList(p)||fe.endsWith(m,"[]")&&(y=fe.toArray(p)))return m=gx(m),y.forEach(function(w,S){!(fe.isUndefined(w)||w===null)&&e.append(r===!0?Nw([m],S,n):r===null?m:m+"[]",d(w))}),!1}return ny(p)?!0:(e.append(Nw(g,m,n),d(p)),!1)}const u=[],h=Object.assign(iB,{defaultVisitor:c,convertValue:d,isVisitable:ny});function l(p,m){if(!fe.isUndefined(p)){if(u.indexOf(p)!==-1)throw Error("Circular reference detected in "+m.join("."));u.push(p),fe.forEach(p,function(y,b){(!(fe.isUndefined(y)||y===null)&&i.call(e,y,fe.isString(b)?b.trim():b,m,h))===!0&&l(y,m?m.concat(b):[b])}),u.pop()}}if(!fe.isObject(f))throw new TypeError("data must be an object");return l(f),e}function Ew(f){const e={"!":"%21","'":"%27","(":"%28",")":"%29","~":"%7E","%20":"+","%00":"\0"};return encodeURIComponent(f).replace(/[!'()~]|%20|%00/g,function(s){return e[s]})}function nb(f,e){this._pairs=[],f&&Cl(f,this,e)}const yx=nb.prototype;yx.append=function(e,t){this._pairs.push([e,t])};yx.toString=function(e){const t=e?function(s){return e.call(this,s,Ew)}:Ew;return this._pairs.map(function(i){return t(i[0])+"="+t(i[1])},"").join("&")};function rB(f){return encodeURIComponent(f).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}function bx(f,e,t){if(!e)return f;const s=t&&t.encode||rB,i=t&&t.serialize;let n;if(i?n=i(e,t):n=fe.isURLSearchParams(e)?e.toString():new nb(e,t).toString(s),n){const r=f.indexOf("#");r!==-1&&(f=f.slice(0,r)),f+=(f.indexOf("?")===-1?"?":"&")+n}return f}class Vw{constructor(){this.handlers=[]}use(e,t,s){return this.handlers.push({fulfilled:e,rejected:t,synchronous:s?s.synchronous:!1,runWhen:s?s.runWhen:null}),this.handlers.length-1}eject(e){this.handlers[e]&&(this.handlers[e]=null)}clear(){this.handlers&&(this.handlers=[])}forEach(e){fe.forEach(this.handlers,function(s){s!==null&&e(s)})}}const wx={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1},aB=typeof URLSearchParams<"u"?URLSearchParams:nb,oB=FormData,dB=(()=>{let f;return typeof navigator<"u"&&((f=navigator.product)==="ReactNative"||f==="NativeScript"||f==="NS")?!1:typeof window<"u"&&typeof document<"u"})(),pr={isBrowser:!0,classes:{URLSearchParams:aB,FormData:oB,Blob},isStandardBrowserEnv:dB,protocols:["http","https","file","blob","url","data"]};function cB(f,e){return Cl(f,new pr.classes.URLSearchParams,Object.assign({visitor:function(t,s,i,n){return pr.isNode&&fe.isBuffer(t)?(this.append(s,t.toString("base64")),!1):n.defaultVisitor.apply(this,arguments)}},e))}function uB(f){return fe.matchAll(/\w+|\[(\w*)]/g,f).map(e=>e[0]==="[]"?"":e[1]||e[0])}function fB(f){const e={},t=Object.keys(f);let s;const i=t.length;let n;for(s=0;s<i;s++)n=t[s],e[n]=f[n];return e}function Sx(f){function e(t,s,i,n){let r=t[n++];const a=Number.isFinite(+r),o=n>=t.length;return r=!r&&fe.isArray(i)?i.length:r,o?(fe.hasOwnProp(i,r)?i[r]=[i[r],s]:i[r]=s,!a):((!i[r]||!fe.isObject(i[r]))&&(i[r]=[]),e(t,s,i[r],n)&&fe.isArray(i[r])&&(i[r]=fB(i[r])),!a)}if(fe.isFormData(f)&&fe.isFunction(f.entries)){const t={};return fe.forEachEntry(f,(s,i)=>{e(uB(s),i,t,0)}),t}return null}function hB(f,e,t){const s=t.config.validateStatus;!t.status||!s||s(t.status)?f(t):e(new lt("Request failed with status code "+t.status,[lt.ERR_BAD_REQUEST,lt.ERR_BAD_RESPONSE][Math.floor(t.status/100)-4],t.config,t.request,t))}const lB=pr.isStandardBrowserEnv?function(){return{write:function(t,s,i,n,r,a){const o=[];o.push(t+"="+encodeURIComponent(s)),fe.isNumber(i)&&o.push("expires="+new Date(i).toGMTString()),fe.isString(n)&&o.push("path="+n),fe.isString(r)&&o.push("domain="+r),a===!0&&o.push("secure"),document.cookie=o.join("; ")},read:function(t){const s=document.cookie.match(new RegExp("(^|;\\s*)("+t+")=([^;]*)"));return s?decodeURIComponent(s[3]):null},remove:function(t){this.write(t,"",Date.now()-864e5)}}}():function(){return{write:function(){},read:function(){return null},remove:function(){}}}();function pB(f){return/^([a-z][a-z\d+\-.]*:)?\/\//i.test(f)}function mB(f,e){return e?f.replace(/\/+$/,"")+"/"+e.replace(/^\/+/,""):f}function kx(f,e){return f&&!pB(e)?mB(f,e):e}const gB=pr.isStandardBrowserEnv?function(){const e=/(msie|trident)/i.test(navigator.userAgent),t=document.createElement("a");let s;function i(n){let r=n;return e&&(t.setAttribute("href",r),r=t.href),t.setAttribute("href",r),{href:t.href,protocol:t.protocol?t.protocol.replace(/:$/,""):"",host:t.host,search:t.search?t.search.replace(/^\?/,""):"",hash:t.hash?t.hash.replace(/^#/,""):"",hostname:t.hostname,port:t.port,pathname:t.pathname.charAt(0)==="/"?t.pathname:"/"+t.pathname}}return s=i(window.location.href),function(r){const a=fe.isString(r)?i(r):r;return a.protocol===s.protocol&&a.host===s.host}}():function(){return function(){return!0}}();function _u(f,e,t){lt.call(this,f==null?"canceled":f,lt.ERR_CANCELED,e,t),this.name="CanceledError"}fe.inherits(_u,lt,{__CANCEL__:!0});function yB(f){const e=/^([-+\w]{1,25})(:?\/\/|:)/.exec(f);return e&&e[1]||""}const bB=fe.toObjectSet(["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"]),wB=f=>{const e={};let t,s,i;return f&&f.split(`
`).forEach(function(r){i=r.indexOf(":"),t=r.substring(0,i).trim().toLowerCase(),s=r.substring(i+1).trim(),!(!t||e[t]&&bB[t])&&(t==="set-cookie"?e[t]?e[t].push(s):e[t]=[s]:e[t]=e[t]?e[t]+", "+s:s)}),e},qw=Symbol("internals"),vx=Symbol("defaults");function Jc(f){return f&&String(f).trim().toLowerCase()}function Hh(f){return f===!1||f==null?f:fe.isArray(f)?f.map(Hh):String(f)}function SB(f){const e=Object.create(null),t=/([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;let s;for(;s=t.exec(f);)e[s[1]]=s[2];return e}function Lw(f,e,t,s){if(fe.isFunction(s))return s.call(this,e,t);if(!!fe.isString(e)){if(fe.isString(s))return e.indexOf(s)!==-1;if(fe.isRegExp(s))return s.test(e)}}function kB(f){return f.trim().toLowerCase().replace(/([a-z\d])(\w*)/g,(e,t,s)=>t.toUpperCase()+s)}function vB(f,e){const t=fe.toCamelCase(" "+e);["get","set","has"].forEach(s=>{Object.defineProperty(f,s+t,{value:function(i,n,r){return this[s].call(this,e,i,n,r)},configurable:!0})})}function Fd(f,e){e=e.toLowerCase();const t=Object.keys(f);let s=t.length,i;for(;s-- >0;)if(i=t[s],e===i.toLowerCase())return i;return null}function un(f,e){f&&this.set(f),this[vx]=e||null}Object.assign(un.prototype,{set:function(f,e,t){const s=this;function i(n,r,a){const o=Jc(r);if(!o)throw new Error("header name must be a non-empty string");const d=Fd(s,o);d&&a!==!0&&(s[d]===!1||a===!1)||(s[d||r]=Hh(n))}return fe.isPlainObject(f)?fe.forEach(f,(n,r)=>{i(n,r,e)}):i(e,f,t),this},get:function(f,e){if(f=Jc(f),!f)return;const t=Fd(this,f);if(t){const s=this[t];if(!e)return s;if(e===!0)return SB(s);if(fe.isFunction(e))return e.call(this,s,t);if(fe.isRegExp(e))return e.exec(s);throw new TypeError("parser must be boolean|regexp|function")}},has:function(f,e){if(f=Jc(f),f){const t=Fd(this,f);return!!(t&&(!e||Lw(this,this[t],t,e)))}return!1},delete:function(f,e){const t=this;let s=!1;function i(n){if(n=Jc(n),n){const r=Fd(t,n);r&&(!e||Lw(t,t[r],r,e))&&(delete t[r],s=!0)}}return fe.isArray(f)?f.forEach(i):i(f),s},clear:function(){return Object.keys(this).forEach(this.delete.bind(this))},normalize:function(f){const e=this,t={};return fe.forEach(this,(s,i)=>{const n=Fd(t,i);if(n){e[n]=Hh(s),delete e[i];return}const r=f?kB(i):String(i).trim();r!==i&&delete e[i],e[r]=Hh(s),t[r]=!0}),this},toJSON:function(f){const e=Object.create(null);return fe.forEach(Object.assign({},this[vx]||null,this),(t,s)=>{t==null||t===!1||(e[s]=f&&fe.isArray(t)?t.join(", "):t)}),e}});Object.assign(un,{from:function(f){return fe.isString(f)?new this(wB(f)):f instanceof this?f:new this(f)},accessor:function(f){const t=(this[qw]=this[qw]={accessors:{}}).accessors,s=this.prototype;function i(n){const r=Jc(n);t[r]||(vB(s,n),t[r]=!0)}return fe.isArray(f)?f.forEach(i):i(f),this}});un.accessor(["Content-Type","Content-Length","Accept","Accept-Encoding","User-Agent"]);fe.freezeMethods(un.prototype);fe.freezeMethods(un);function TB(f,e){f=f||10;const t=new Array(f),s=new Array(f);let i=0,n=0,r;return e=e!==void 0?e:1e3,function(o){const d=Date.now(),c=s[n];r||(r=d),t[i]=o,s[i]=d;let u=n,h=0;for(;u!==i;)h+=t[u++],u=u%f;if(i=(i+1)%f,i===n&&(n=(n+1)%f),d-r<e)return;const l=c&&d-c;return l?Math.round(h*1e3/l):void 0}}function Rw(f,e){let t=0;const s=TB(50,250);return i=>{const n=i.loaded,r=i.lengthComputable?i.total:void 0,a=n-t,o=s(a),d=n<=r;t=n;const c={loaded:n,total:r,progress:r?n/r:void 0,bytes:a,rate:o||void 0,estimated:o&&r&&d?(r-n)/o:void 0};c[e?"download":"upload"]=!0,f(c)}}function Fw(f){return new Promise(function(t,s){let i=f.data;const n=un.from(f.headers).normalize(),r=f.responseType;let a;function o(){f.cancelToken&&f.cancelToken.unsubscribe(a),f.signal&&f.signal.removeEventListener("abort",a)}fe.isFormData(i)&&pr.isStandardBrowserEnv&&n.setContentType(!1);let d=new XMLHttpRequest;if(f.auth){const l=f.auth.username||"",p=f.auth.password?unescape(encodeURIComponent(f.auth.password)):"";n.set("Authorization","Basic "+btoa(l+":"+p))}const c=kx(f.baseURL,f.url);d.open(f.method.toUpperCase(),bx(c,f.params,f.paramsSerializer),!0),d.timeout=f.timeout;function u(){if(!d)return;const l=un.from("getAllResponseHeaders"in d&&d.getAllResponseHeaders()),m={data:!r||r==="text"||r==="json"?d.responseText:d.response,status:d.status,statusText:d.statusText,headers:l,config:f,request:d};hB(function(y){t(y),o()},function(y){s(y),o()},m),d=null}if("onloadend"in d?d.onloadend=u:d.onreadystatechange=function(){!d||d.readyState!==4||d.status===0&&!(d.responseURL&&d.responseURL.indexOf("file:")===0)||setTimeout(u)},d.onabort=function(){!d||(s(new lt("Request aborted",lt.ECONNABORTED,f,d)),d=null)},d.onerror=function(){s(new lt("Network Error",lt.ERR_NETWORK,f,d)),d=null},d.ontimeout=function(){let p=f.timeout?"timeout of "+f.timeout+"ms exceeded":"timeout exceeded";const m=f.transitional||wx;f.timeoutErrorMessage&&(p=f.timeoutErrorMessage),s(new lt(p,m.clarifyTimeoutError?lt.ETIMEDOUT:lt.ECONNABORTED,f,d)),d=null},pr.isStandardBrowserEnv){const l=(f.withCredentials||gB(c))&&f.xsrfCookieName&&lB.read(f.xsrfCookieName);l&&n.set(f.xsrfHeaderName,l)}i===void 0&&n.setContentType(null),"setRequestHeader"in d&&fe.forEach(n.toJSON(),function(p,m){d.setRequestHeader(m,p)}),fe.isUndefined(f.withCredentials)||(d.withCredentials=!!f.withCredentials),r&&r!=="json"&&(d.responseType=f.responseType),typeof f.onDownloadProgress=="function"&&d.addEventListener("progress",Rw(f.onDownloadProgress,!0)),typeof f.onUploadProgress=="function"&&d.upload&&d.upload.addEventListener("progress",Rw(f.onUploadProgress)),(f.cancelToken||f.signal)&&(a=l=>{!d||(s(!l||l.type?new _u(null,f,d):l),d.abort(),d=null)},f.cancelToken&&f.cancelToken.subscribe(a),f.signal&&(f.signal.aborted?a():f.signal.addEventListener("abort",a)));const h=yB(c);if(h&&pr.protocols.indexOf(h)===-1){s(new lt("Unsupported protocol "+h+":",lt.ERR_BAD_REQUEST,f));return}d.send(i||null)})}const Dw={http:Fw,xhr:Fw},Hw={getAdapter:f=>{if(fe.isString(f)){const e=Dw[f];if(!f)throw Error(fe.hasOwnProp(f)?`Adapter '${f}' is not available in the build`:`Can not resolve adapter '${f}'`);return e}if(!fe.isFunction(f))throw new TypeError("adapter is not a function");return f},adapters:Dw},OB={"Content-Type":"application/x-www-form-urlencoded"};function IB(){let f;return typeof XMLHttpRequest<"u"?f=Hw.getAdapter("xhr"):typeof process<"u"&&fe.kindOf(process)==="process"&&(f=Hw.getAdapter("http")),f}function xB(f,e,t){if(fe.isString(f))try{return(e||JSON.parse)(f),fe.trim(f)}catch(s){if(s.name!=="SyntaxError")throw s}return(t||JSON.stringify)(f)}const Id={transitional:wx,adapter:IB(),transformRequest:[function(e,t){const s=t.getContentType()||"",i=s.indexOf("application/json")>-1,n=fe.isObject(e);if(n&&fe.isHTMLForm(e)&&(e=new FormData(e)),fe.isFormData(e))return i&&i?JSON.stringify(Sx(e)):e;if(fe.isArrayBuffer(e)||fe.isBuffer(e)||fe.isStream(e)||fe.isFile(e)||fe.isBlob(e))return e;if(fe.isArrayBufferView(e))return e.buffer;if(fe.isURLSearchParams(e))return t.setContentType("application/x-www-form-urlencoded;charset=utf-8",!1),e.toString();let a;if(n){if(s.indexOf("application/x-www-form-urlencoded")>-1)return cB(e,this.formSerializer).toString();if((a=fe.isFileList(e))||s.indexOf("multipart/form-data")>-1){const o=this.env&&this.env.FormData;return Cl(a?{"files[]":e}:e,o&&new o,this.formSerializer)}}return n||i?(t.setContentType("application/json",!1),xB(e)):e}],transformResponse:[function(e){const t=this.transitional||Id.transitional,s=t&&t.forcedJSONParsing,i=this.responseType==="json";if(e&&fe.isString(e)&&(s&&!this.responseType||i)){const r=!(t&&t.silentJSONParsing)&&i;try{return JSON.parse(e)}catch(a){if(r)throw a.name==="SyntaxError"?lt.from(a,lt.ERR_BAD_RESPONSE,this,null,this.response):a}}return e}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:pr.classes.FormData,Blob:pr.classes.Blob},validateStatus:function(e){return e>=200&&e<300},headers:{common:{Accept:"application/json, text/plain, */*"}}};fe.forEach(["delete","get","head"],function(e){Id.headers[e]={}});fe.forEach(["post","put","patch"],function(e){Id.headers[e]=fe.merge(OB)});function Ip(f,e){const t=this||Id,s=e||t,i=un.from(s.headers);let n=s.data;return fe.forEach(f,function(a){n=a.call(t,n,i.normalize(),e?e.status:void 0)}),i.normalize(),n}function Tx(f){return!!(f&&f.__CANCEL__)}function xp(f){if(f.cancelToken&&f.cancelToken.throwIfRequested(),f.signal&&f.signal.aborted)throw new _u}function Gw(f){return xp(f),f.headers=un.from(f.headers),f.data=Ip.call(f,f.transformRequest),(f.adapter||Id.adapter)(f).then(function(s){return xp(f),s.data=Ip.call(f,f.transformResponse,s),s.headers=un.from(s.headers),s},function(s){return Tx(s)||(xp(f),s&&s.response&&(s.response.data=Ip.call(f,f.transformResponse,s.response),s.response.headers=un.from(s.response.headers))),Promise.reject(s)})}function bu(f,e){e=e||{};const t={};function s(d,c){return fe.isPlainObject(d)&&fe.isPlainObject(c)?fe.merge(d,c):fe.isPlainObject(c)?fe.merge({},c):fe.isArray(c)?c.slice():c}function i(d){if(fe.isUndefined(e[d])){if(!fe.isUndefined(f[d]))return s(void 0,f[d])}else return s(f[d],e[d])}function n(d){if(!fe.isUndefined(e[d]))return s(void 0,e[d])}function r(d){if(fe.isUndefined(e[d])){if(!fe.isUndefined(f[d]))return s(void 0,f[d])}else return s(void 0,e[d])}function a(d){if(d in e)return s(f[d],e[d]);if(d in f)return s(void 0,f[d])}const o={url:n,method:n,data:n,baseURL:r,transformRequest:r,transformResponse:r,paramsSerializer:r,timeout:r,timeoutMessage:r,withCredentials:r,adapter:r,responseType:r,xsrfCookieName:r,xsrfHeaderName:r,onUploadProgress:r,onDownloadProgress:r,decompress:r,maxContentLength:r,maxBodyLength:r,beforeRedirect:r,transport:r,httpAgent:r,httpsAgent:r,cancelToken:r,socketPath:r,responseEncoding:r,validateStatus:a};return fe.forEach(Object.keys(f).concat(Object.keys(e)),function(c){const u=o[c]||i,h=u(c);fe.isUndefined(h)&&u!==a||(t[c]=h)}),t}const Ox="1.1.3",rb={};["object","boolean","number","function","string","symbol"].forEach((f,e)=>{rb[f]=function(s){return typeof s===f||"a"+(e<1?"n ":" ")+f}});const Uw={};rb.transitional=function(e,t,s){function i(n,r){return"[Axios v"+Ox+"] Transitional option '"+n+"'"+r+(s?". "+s:"")}return(n,r,a)=>{if(e===!1)throw new lt(i(r," has been removed"+(t?" in "+t:"")),lt.ERR_DEPRECATED);return t&&!Uw[r]&&(Uw[r]=!0,console.warn(i(r," has been deprecated since v"+t+" and will be removed in the near future"))),e?e(n,r,a):!0}};function _B(f,e,t){if(typeof f!="object")throw new lt("options must be an object",lt.ERR_BAD_OPTION_VALUE);const s=Object.keys(f);let i=s.length;for(;i-- >0;){const n=s[i],r=e[n];if(r){const a=f[n],o=a===void 0||r(a,n,f);if(o!==!0)throw new lt("option "+n+" must be "+o,lt.ERR_BAD_OPTION_VALUE);continue}if(t!==!0)throw new lt("Unknown option "+n,lt.ERR_BAD_OPTION)}}const ry={assertOptions:_B,validators:rb},Mr=ry.validators;class oo{constructor(e){this.defaults=e,this.interceptors={request:new Vw,response:new Vw}}request(e,t){typeof e=="string"?(t=t||{},t.url=e):t=e||{},t=bu(this.defaults,t);const{transitional:s,paramsSerializer:i}=t;s!==void 0&&ry.assertOptions(s,{silentJSONParsing:Mr.transitional(Mr.boolean),forcedJSONParsing:Mr.transitional(Mr.boolean),clarifyTimeoutError:Mr.transitional(Mr.boolean)},!1),i!==void 0&&ry.assertOptions(i,{encode:Mr.function,serialize:Mr.function},!0),t.method=(t.method||this.defaults.method||"get").toLowerCase();const n=t.headers&&fe.merge(t.headers.common,t.headers[t.method]);n&&fe.forEach(["delete","get","head","post","put","patch","common"],function(p){delete t.headers[p]}),t.headers=new un(t.headers,n);const r=[];let a=!0;this.interceptors.request.forEach(function(p){typeof p.runWhen=="function"&&p.runWhen(t)===!1||(a=a&&p.synchronous,r.unshift(p.fulfilled,p.rejected))});const o=[];this.interceptors.response.forEach(function(p){o.push(p.fulfilled,p.rejected)});let d,c=0,u;if(!a){const l=[Gw.bind(this),void 0];for(l.unshift.apply(l,r),l.push.apply(l,o),u=l.length,d=Promise.resolve(t);c<u;)d=d.then(l[c++],l[c++]);return d}u=r.length;let h=t;for(c=0;c<u;){const l=r[c++],p=r[c++];try{h=l(h)}catch(m){p.call(this,m);break}}try{d=Gw.call(this,h)}catch(l){return Promise.reject(l)}for(c=0,u=o.length;c<u;)d=d.then(o[c++],o[c++]);return d}getUri(e){e=bu(this.defaults,e);const t=kx(e.baseURL,e.url);return bx(t,e.params,e.paramsSerializer)}}fe.forEach(["delete","get","head","options"],function(e){oo.prototype[e]=function(t,s){return this.request(bu(s||{},{method:e,url:t,data:(s||{}).data}))}});fe.forEach(["post","put","patch"],function(e){function t(s){return function(n,r,a){return this.request(bu(a||{},{method:e,headers:s?{"Content-Type":"multipart/form-data"}:{},url:n,data:r}))}}oo.prototype[e]=t(),oo.prototype[e+"Form"]=t(!0)});class ab{constructor(e){if(typeof e!="function")throw new TypeError("executor must be a function.");let t;this.promise=new Promise(function(n){t=n});const s=this;this.promise.then(i=>{if(!s._listeners)return;let n=s._listeners.length;for(;n-- >0;)s._listeners[n](i);s._listeners=null}),this.promise.then=i=>{let n;const r=new Promise(a=>{s.subscribe(a),n=a}).then(i);return r.cancel=function(){s.unsubscribe(n)},r},e(function(n,r,a){s.reason||(s.reason=new _u(n,r,a),t(s.reason))})}throwIfRequested(){if(this.reason)throw this.reason}subscribe(e){if(this.reason){e(this.reason);return}this._listeners?this._listeners.push(e):this._listeners=[e]}unsubscribe(e){if(!this._listeners)return;const t=this._listeners.indexOf(e);t!==-1&&this._listeners.splice(t,1)}static source(){let e;return{token:new ab(function(i){e=i}),cancel:e}}}function CB(f){return function(t){return f.apply(null,t)}}function MB(f){return fe.isObject(f)&&f.isAxiosError===!0}function Ix(f){const e=new oo(f),t=dx(oo.prototype.request,e);return fe.extend(t,oo.prototype,e,{allOwnKeys:!0}),fe.extend(t,e,null,{allOwnKeys:!0}),t.create=function(i){return Ix(bu(f,i))},t}const as=Ix(Id);as.Axios=oo;as.CanceledError=_u;as.CancelToken=ab;as.isCancel=Tx;as.VERSION=Ox;as.toFormData=Cl;as.AxiosError=lt;as.Cancel=as.CanceledError;as.all=function(e){return Promise.all(e)};as.spread=CB;as.isAxiosError=MB;as.formToJSON=f=>Sx(fe.isHTMLForm(f)?new FormData(f):f);let ef;const PB=new Uint8Array(16);function AB(){if(!ef&&(ef=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!ef))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return ef(PB)}const Gs=[];for(let f=0;f<256;++f)Gs.push((f+256).toString(16).slice(1));function BB(f,e=0){return(Gs[f[e+0]]+Gs[f[e+1]]+Gs[f[e+2]]+Gs[f[e+3]]+"-"+Gs[f[e+4]]+Gs[f[e+5]]+"-"+Gs[f[e+6]]+Gs[f[e+7]]+"-"+Gs[f[e+8]]+Gs[f[e+9]]+"-"+Gs[f[e+10]]+Gs[f[e+11]]+Gs[f[e+12]]+Gs[f[e+13]]+Gs[f[e+14]]+Gs[f[e+15]]).toLowerCase()}const NB=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto),$w={randomUUID:NB};function EB(f,e,t){if($w.randomUUID&&!e&&!f)return $w.randomUUID();f=f||{};const s=f.random||(f.rng||AB)();if(s[6]=s[6]&15|64,s[8]=s[8]&63|128,e){t=t||0;for(let i=0;i<16;++i)e[t+i]=s[i];return e}return BB(s)}const xx=f=>f?(f^Math.random()*16>>f/4).toString(16):([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,xx),_x=f=>f?(f^Math.random()*16>>f/4).toString(16):([1e5]+100+400+8e3).replace(/[018]/g,_x),Cx=f=>f?(f^Math.random()*16>>f/4).toString(16):([1e7]+1e3+4e3+8e5).replace(/[018]/g,Cx);var ob={uuid:xx,uuid16:_x,uuid22:Cx,unCamelCase:f=>f.match(/[A-Z]/)?f.replace(/[a-z0-9][A-Z]/g,e=>e[0]+"_"+e[1]).replace(/[A-Z0-9][A-Z0-9][a-z][^$]/g,e=>e[0]+"_"+e[1]+e[2]+e[3]).replace(/[a-z][0-9]$/g,e=>e[0]+"_"+e[1]).toLowerCase():f,capitalize:f=>f.length?f.charAt(0).toUpperCase()+f.slice(1):f,strip:f=>f.replace(/^\s+|\s+$/g,"")},tf={exports:{}};const VB={},qB=Object.freeze(Object.defineProperty({__proto__:null,default:VB},Symbol.toStringTag,{value:"Module"})),Mt=My(qB);var jw;function LB(){return jw||(jw=1,function(f,e){Object.defineProperty(e,"__esModule",{value:!0});const t=Symbol("buffer"),s=Symbol("type");class i{constructor(){this[s]="";const U=arguments[0],W=arguments[1],J=[];if(U){const ne=U,ce=Number(ne.length);for(let ie=0;ie<ce;ie++){const de=ne[ie];let we;de instanceof Buffer?we=de:ArrayBuffer.isView(de)?we=Buffer.from(de.buffer,de.byteOffset,de.byteLength):de instanceof ArrayBuffer?we=Buffer.from(de):de instanceof i?we=de[t]:we=Buffer.from(typeof de=="string"?de:String(de)),J.push(we)}}this[t]=Buffer.concat(J);let ee=W&&W.type!==void 0&&String(W.type).toLowerCase();ee&&!/[^\u0020-\u007E]/.test(ee)&&(this[s]=ee)}get size(){return this[t].length}get type(){return this[s]}slice(){const U=this.size,W=arguments[0],J=arguments[1];let ee,ne;W===void 0?ee=0:W<0?ee=Math.max(U+W,0):ee=Math.min(W,U),J===void 0?ne=U:J<0?ne=Math.max(U+J,0):ne=Math.min(J,U);const ce=Math.max(ne-ee,0),de=this[t].slice(ee,ee+ce),we=new i([],{type:arguments[2]});return we[t]=de,we}}Object.defineProperties(i.prototype,{size:{enumerable:!0},type:{enumerable:!0},slice:{enumerable:!0}}),Object.defineProperty(i.prototype,Symbol.toStringTag,{value:"Blob",writable:!1,enumerable:!1,configurable:!0});function n(G,U,W){Error.call(this,G),this.message=G,this.type=U,W&&(this.code=this.errno=W.code),Error.captureStackTrace(this,this.constructor)}n.prototype=Object.create(Error.prototype),n.prototype.constructor=n,n.prototype.name="FetchError";const r=Mt;var a=Mt;const o=a.PassThrough,d=Symbol("Body internals");function c(G){var U=this,W=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},J=W.size;let ee=J===void 0?0:J;var ne=W.timeout;let ce=ne===void 0?0:ne;G==null?G=null:typeof G=="string"||l(G)||G instanceof i||Buffer.isBuffer(G)||Object.prototype.toString.call(G)==="[object ArrayBuffer]"||G instanceof r||(G=String(G)),this[d]={body:G,disturbed:!1,error:null},this.size=ee,this.timeout=ce,G instanceof r&&G.on("error",function(ie){U[d].error=new n(`Invalid response body while trying to fetch ${U.url}: ${ie.message}`,"system",ie)})}c.prototype={get body(){return this[d].body},get bodyUsed(){return this[d].disturbed},arrayBuffer(){return u.call(this).then(function(G){return G.buffer.slice(G.byteOffset,G.byteOffset+G.byteLength)})},blob(){let G=this.headers&&this.headers.get("content-type")||"";return u.call(this).then(function(U){return Object.assign(new i([],{type:G.toLowerCase()}),{[t]:U})})},json(){var G=this;return u.call(this).then(function(U){try{return JSON.parse(U.toString())}catch(W){return c.Promise.reject(new n(`invalid json response body at ${G.url} reason: ${W.message}`,"invalid-json"))}})},text(){return u.call(this).then(function(G){return G.toString()})},buffer(){return u.call(this)},textConverted(){var G=this;return u.call(this).then(function(U){return h(U,G.headers)})}},Object.defineProperties(c.prototype,{body:{enumerable:!0},bodyUsed:{enumerable:!0},arrayBuffer:{enumerable:!0},blob:{enumerable:!0},json:{enumerable:!0},text:{enumerable:!0}}),c.mixIn=function(G){for(const U of Object.getOwnPropertyNames(c.prototype))if(!(U in G)){const W=Object.getOwnPropertyDescriptor(c.prototype,U);Object.defineProperty(G,U,W)}};function u(){var G=this;if(this[d].disturbed)return c.Promise.reject(new TypeError(`body used already for: ${this.url}`));if(this[d].disturbed=!0,this[d].error)return c.Promise.reject(this[d].error);if(this.body===null)return c.Promise.resolve(Buffer.alloc(0));if(typeof this.body=="string")return c.Promise.resolve(Buffer.from(this.body));if(this.body instanceof i)return c.Promise.resolve(this.body[t]);if(Buffer.isBuffer(this.body))return c.Promise.resolve(this.body);if(Object.prototype.toString.call(this.body)==="[object ArrayBuffer]")return c.Promise.resolve(Buffer.from(this.body));if(!(this.body instanceof r))return c.Promise.resolve(Buffer.alloc(0));let U=[],W=0,J=!1;return new c.Promise(function(ee,ne){let ce;G.timeout&&(ce=setTimeout(function(){J=!0,ne(new n(`Response timeout while trying to fetch ${G.url} (over ${G.timeout}ms)`,"body-timeout"))},G.timeout)),G.body.on("error",function(ie){ne(new n(`Invalid response body while trying to fetch ${G.url}: ${ie.message}`,"system",ie))}),G.body.on("data",function(ie){if(!(J||ie===null)){if(G.size&&W+ie.length>G.size){J=!0,ne(new n(`content size at ${G.url} over limit: ${G.size}`,"max-size"));return}W+=ie.length,U.push(ie)}}),G.body.on("end",function(){if(!J){clearTimeout(ce);try{ee(Buffer.concat(U))}catch(ie){ne(new n(`Could not create Buffer from response body for ${G.url}: ${ie.message}`,"system",ie))}}})})}function h(G,U){if(typeof convert!="function")throw new Error("The package `encoding` must be installed to use the textConverted() function");const W=U.get("content-type");let J="utf-8",ee,ne;return W&&(ee=/charset=([^;]*)/i.exec(W)),ne=G.slice(0,1024).toString(),!ee&&ne&&(ee=/<meta.+?charset=(['"])(.+?)\1/i.exec(ne)),!ee&&ne&&(ee=/<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(ne),ee&&(ee=/charset=(.*)/i.exec(ee.pop()))),!ee&&ne&&(ee=/<\?xml.+?encoding=(['"])(.+?)\1/i.exec(ne)),ee&&(J=ee.pop(),(J==="gb2312"||J==="gbk")&&(J="gb18030")),convert(G,"UTF-8",J).toString()}function l(G){return typeof G!="object"||typeof G.append!="function"||typeof G.delete!="function"||typeof G.get!="function"||typeof G.getAll!="function"||typeof G.has!="function"||typeof G.set!="function"?!1:G.constructor.name==="URLSearchParams"||Object.prototype.toString.call(G)==="[object URLSearchParams]"||typeof G.sort=="function"}function p(G){let U,W,J=G.body;if(G.bodyUsed)throw new Error("cannot clone body after it is used");return J instanceof r&&typeof J.getBoundary!="function"&&(U=new o,W=new o,J.pipe(U),J.pipe(W),G[d].body=U,J=W),J}function m(G){const U=G.body;return U===null?null:typeof U=="string"?"text/plain;charset=UTF-8":l(U)?"application/x-www-form-urlencoded;charset=UTF-8":U instanceof i?U.type||null:Buffer.isBuffer(U)||Object.prototype.toString.call(U)==="[object ArrayBuffer]"?null:typeof U.getBoundary=="function"?`multipart/form-data;boundary=${U.getBoundary()}`:null}function g(G){const U=G.body;return U===null?0:typeof U=="string"?Buffer.byteLength(U):l(U)?Buffer.byteLength(String(U)):U instanceof i?U.size:Buffer.isBuffer(U)?U.length:Object.prototype.toString.call(U)==="[object ArrayBuffer]"?U.byteLength:U&&typeof U.getLengthSync=="function"&&(U._lengthRetrievers&&U._lengthRetrievers.length==0||U.hasKnownLength&&U.hasKnownLength())?U.getLengthSync():null}function y(G,U){const W=U.body;W===null?G.end():typeof W=="string"?(G.write(W),G.end()):l(W)?(G.write(Buffer.from(String(W))),G.end()):W instanceof i?(G.write(W[t]),G.end()):Buffer.isBuffer(W)?(G.write(W),G.end()):Object.prototype.toString.call(W)==="[object ArrayBuffer]"?(G.write(Buffer.from(W)),G.end()):W.pipe(G)}c.Promise=jh.Promise;const b=/[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/,w=/[^\t\x20-\x7e\x80-\xff]/;function S(G){if(G=`${G}`,b.test(G))throw new TypeError(`${G} is not a legal HTTP header name`)}function k(G){if(G=`${G}`,w.test(G))throw new TypeError(`${G} is not a legal HTTP header value`)}function T(G,U){U=U.toLowerCase();for(const W in G)if(W.toLowerCase()===U)return W}const I=Symbol("map");class _{constructor(){let U=arguments.length>0&&arguments[0]!==void 0?arguments[0]:void 0;if(this[I]=Object.create(null),U instanceof _){const W=U.raw(),J=Object.keys(W);for(const ee of J)for(const ne of W[ee])this.append(ee,ne);return}if(U!=null)if(typeof U=="object"){const W=U[Symbol.iterator];if(W!=null){if(typeof W!="function")throw new TypeError("Header pairs must be iterable");const J=[];for(const ee of U){if(typeof ee!="object"||typeof ee[Symbol.iterator]!="function")throw new TypeError("Each header pair must be iterable");J.push(Array.from(ee))}for(const ee of J){if(ee.length!==2)throw new TypeError("Each header pair must be a name/value tuple");this.append(ee[0],ee[1])}}else for(const J of Object.keys(U)){const ee=U[J];this.append(J,ee)}}else throw new TypeError("Provided initializer must be an object")}get(U){U=`${U}`,S(U);const W=T(this[I],U);return W===void 0?null:this[I][W].join(", ")}forEach(U){let W=arguments.length>1&&arguments[1]!==void 0?arguments[1]:void 0,J=N(this),ee=0;for(;ee<J.length;){var ne=J[ee];const ce=ne[0],ie=ne[1];U.call(W,ie,ce,this),J=N(this),ee++}}set(U,W){U=`${U}`,W=`${W}`,S(U),k(W);const J=T(this[I],U);this[I][J!==void 0?J:U]=[W]}append(U,W){U=`${U}`,W=`${W}`,S(U),k(W);const J=T(this[I],U);J!==void 0?this[I][J].push(W):this[I][U]=[W]}has(U){return U=`${U}`,S(U),T(this[I],U)!==void 0}delete(U){U=`${U}`,S(U);const W=T(this[I],U);W!==void 0&&delete this[I][W]}raw(){return this[I]}keys(){return x(this,"key")}values(){return x(this,"value")}[Symbol.iterator](){return x(this,"key+value")}}_.prototype.entries=_.prototype[Symbol.iterator],Object.defineProperty(_.prototype,Symbol.toStringTag,{value:"Headers",writable:!1,enumerable:!1,configurable:!0}),Object.defineProperties(_.prototype,{get:{enumerable:!0},forEach:{enumerable:!0},set:{enumerable:!0},append:{enumerable:!0},has:{enumerable:!0},delete:{enumerable:!0},keys:{enumerable:!0},values:{enumerable:!0},entries:{enumerable:!0}});function N(G){let U=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"key+value";return Object.keys(G[I]).sort().map(U==="key"?function(J){return J.toLowerCase()}:U==="value"?function(J){return G[I][J].join(", ")}:function(J){return[J.toLowerCase(),G[I][J].join(", ")]})}const M=Symbol("internal");function x(G,U){const W=Object.create(v);return W[M]={target:G,kind:U,index:0},W}const v=Object.setPrototypeOf({next(){if(!this||Object.getPrototypeOf(this)!==v)throw new TypeError("Value of `this` is not a HeadersIterator");var G=this[M];const U=G.target,W=G.kind,J=G.index,ee=N(U,W),ne=ee.length;return J>=ne?{value:void 0,done:!0}:(this[M].index=J+1,{value:ee[J],done:!1})}},Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));Object.defineProperty(v,Symbol.toStringTag,{value:"HeadersIterator",writable:!1,enumerable:!1,configurable:!0});function O(G){const U=Object.assign({__proto__:null},G[I]),W=T(G[I],"Host");return W!==void 0&&(U[W]=U[W][0]),U}function A(G){const U=new _;for(const W of Object.keys(G))if(!b.test(W))if(Array.isArray(G[W]))for(const J of G[W])w.test(J)||(U[I][W]===void 0?U[I][W]=[J]:U[I][W].push(J));else w.test(G[W])||(U[I][W]=[G[W]]);return U}var V=Mt;const q=V.STATUS_CODES,R=Symbol("Response internals");class H{constructor(){let U=arguments.length>0&&arguments[0]!==void 0?arguments[0]:null,W=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};c.call(this,U,W);const J=W.status||200;this[R]={url:W.url,status:J,statusText:W.statusText||q[J],headers:new _(W.headers)}}get url(){return this[R].url}get status(){return this[R].status}get ok(){return this[R].status>=200&&this[R].status<300}get statusText(){return this[R].statusText}get headers(){return this[R].headers}clone(){return new H(p(this),{url:this.url,status:this.status,statusText:this.statusText,headers:this.headers,ok:this.ok})}}c.mixIn(H.prototype),Object.defineProperties(H.prototype,{url:{enumerable:!0},status:{enumerable:!0},ok:{enumerable:!0},statusText:{enumerable:!0},headers:{enumerable:!0},clone:{enumerable:!0}}),Object.defineProperty(H.prototype,Symbol.toStringTag,{value:"Response",writable:!1,enumerable:!1,configurable:!0});var F=Mt;const P=F.format,E=F.parse,j=Symbol("Request internals");function X(G){return typeof G=="object"&&typeof G[j]=="object"}class Q{constructor(U){let W=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},J;X(U)?J=E(U.url):(U&&U.href?J=E(U.href):J=E(`${U}`),U={});let ee=W.method||U.method||"GET";if(ee=ee.toUpperCase(),(W.body!=null||X(U)&&U.body!==null)&&(ee==="GET"||ee==="HEAD"))throw new TypeError("Request with GET/HEAD method cannot have body");let ne=W.body!=null?W.body:X(U)&&U.body!==null?p(U):null;c.call(this,ne,{timeout:W.timeout||U.timeout||0,size:W.size||U.size||0});const ce=new _(W.headers||U.headers||{});if(W.body!=null){const ie=m(this);ie!==null&&!ce.has("Content-Type")&&ce.append("Content-Type",ie)}this[j]={method:ee,redirect:W.redirect||U.redirect||"follow",headers:ce,parsedURL:J},this.follow=W.follow!==void 0?W.follow:U.follow!==void 0?U.follow:20,this.compress=W.compress!==void 0?W.compress:U.compress!==void 0?U.compress:!0,this.counter=W.counter||U.counter||0,this.agent=W.agent||U.agent}get method(){return this[j].method}get url(){return P(this[j].parsedURL)}get headers(){return this[j].headers}get redirect(){return this[j].redirect}clone(){return new Q(this)}}c.mixIn(Q.prototype),Object.defineProperty(Q.prototype,Symbol.toStringTag,{value:"Request",writable:!1,enumerable:!1,configurable:!0}),Object.defineProperties(Q.prototype,{method:{enumerable:!0},url:{enumerable:!0},headers:{enumerable:!0},redirect:{enumerable:!0},clone:{enumerable:!0}});function Se(G){const U=G[j].parsedURL,W=new _(G[j].headers);if(W.has("Accept")||W.set("Accept","*/*"),!U.protocol||!U.hostname)throw new TypeError("Only absolute URLs are supported");if(!/^https?:$/.test(U.protocol))throw new TypeError("Only HTTP(S) protocols are supported");let J=null;if(G.body==null&&/^(POST|PUT)$/i.test(G.method)&&(J="0"),G.body!=null){const ee=g(G);typeof ee=="number"&&(J=String(ee))}return J&&W.set("Content-Length",J),W.has("User-Agent")||W.set("User-Agent","node-fetch/1.0 (+https://github.com/bitinn/node-fetch)"),G.compress&&W.set("Accept-Encoding","gzip,deflate"),!W.has("Connection")&&!G.agent&&W.set("Connection","close"),Object.assign({},U,{method:G.method,headers:O(W),agent:G.agent})}const he=Mt,xe=Mt;var Ae=Mt;const Re=Ae.PassThrough;var He=Mt;const qt=He.resolve,D=Mt;function $(G,U){if(!$.Promise)throw new Error("native promise missing, set fetch.Promise to your favorite alternative");return c.Promise=$.Promise,new $.Promise(function(W,J){const ee=new Q(G,U),ne=Se(ee),ce=(ne.protocol==="https:"?xe:he).request,ie=ce(ne);let de;function we(){ie.abort(),clearTimeout(de)}ee.timeout&&ie.once("socket",function(ue){de=setTimeout(function(){J(new n(`network timeout at: ${ee.url}`,"request-timeout")),we()},ee.timeout)}),ie.on("error",function(ue){J(new n(`request to ${ee.url} failed, reason: ${ue.message}`,"system",ue)),we()}),ie.on("response",function(ue){clearTimeout(de);const Oe=A(ue.headers);if($.isRedirect(ue.statusCode)){const z=Oe.get("Location"),Y=z===null?null:qt(ee.url,z);switch(ee.redirect){case"error":J(new n(`redirect mode is set to error: ${ee.url}`,"no-redirect")),we();return;case"manual":Y!==null&&Oe.set("Location",Y);break;case"follow":if(Y===null)break;if(ee.counter>=ee.follow){J(new n(`maximum redirect reached at: ${ee.url}`,"max-redirect")),we();return}const se={headers:new _(ee.headers),follow:ee.follow,counter:ee.counter+1,agent:ee.agent,compress:ee.compress,method:ee.method,body:ee.body};if(ue.statusCode!==303&&ee.body&&g(ee)===null){J(new n("Cannot follow redirect with body being a readable stream","unsupported-redirect")),we();return}(ue.statusCode===303||(ue.statusCode===301||ue.statusCode===302)&&ee.method==="POST")&&(se.method="GET",se.body=void 0,se.headers.delete("content-length")),W($(new Q(Y,se))),we();return}}let Me=ue.pipe(new Re);const L={url:ee.url,status:ue.statusCode,statusText:ue.statusMessage,headers:Oe,size:ee.size,timeout:ee.timeout},C=Oe.get("Content-Encoding");if(!ee.compress||ee.method==="HEAD"||C===null||ue.statusCode===204||ue.statusCode===304){W(new H(Me,L));return}const B={flush:D.Z_SYNC_FLUSH,finishFlush:D.Z_SYNC_FLUSH};if(C=="gzip"||C=="x-gzip"){Me=Me.pipe(D.createGunzip(B)),W(new H(Me,L));return}if(C=="deflate"||C=="x-deflate"){ue.pipe(new Re).once("data",function(Y){(Y[0]&15)===8?Me=Me.pipe(D.createInflate()):Me=Me.pipe(D.createInflateRaw()),W(new H(Me,L))});return}W(new H(Me,L))}),y(ie,ee)})}$.isRedirect=function(G){return G===301||G===302||G===303||G===307||G===308},$.default=$,$.Promise=jh.Promise,$.http=he,$.https=xe,f.exports=e=$,e.Headers=_,e.Request=Q,e.Response=H,e.FetchError=n}(tf,tf.exports)),tf.exports}var _p,Ww;function RB(){if(Ww)return _p;Ww=1;var f=LB();function e(t){const s=function(i,n){return typeof i=="string"&&i.slice(0,2)==="//"?t("https:"+i,n):t(i,n)};return s.http=t.http,s.https=t.https,s}return _p=function(t){return t&&t.Promise&&(f.Promise=t.Promise),{fetch:e(f),Headers:f.Headers,Request:f.Request,Response:f.Response}},_p}const Mx=typeof window<"u",FB=typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.electron<"u",Px=typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope,DB=typeof process<"u"&&process.platform==="win32",HB=!(Mx||Px),GB=typeof fetch>"u"?RB()().fetch:fetch;var UB={isBrowser:Mx,isElectron:FB,isWebWorker:Px,isNode:HB,isWindows:DB,defaultFetch:GB};const Qs=Number.isFinite,$B=Number.isInteger,Ax=Array.isArray,eu=f=>f!=null,db=f=>typeof f=="string",Ml=f=>f!==null&&typeof f=="object",jB=f=>f instanceof RegExp,WB=f=>Ml(f)&&Object.getPrototypeOf(f)===Object.prototype&&!Ax(f)&&!jB(f),Bn=f=>eu(f)&&f.toString||Qs(f),$n=(f,e)=>Ml(f)&&f[e]!==""&&f[e]!==null?f[e]:void 0,Pr=(f,e,t)=>Ml(f)?f[e]!==void 0&&f[e]!==""&&f[e]!==null?f[e]:f[t]!==""&&f[t]!==null?f[t]:void 0:void 0,Ar=(f,e)=>f[e.find(t=>$n(f,t)!==void 0)],wa=f=>Qs(f)||db(f)&&f.length!==0?parseFloat(f):NaN,Sa=f=>Qs(f)||db(f)&&f.length!==0?Math.trunc(Number(f)):NaN;var Bx={isNumber:Qs,isInteger:$B,isArray:Ax,isObject:Ml,isString:db,isStringCoercible:Bn,isDictionary:WB,hasProps:eu,prop:$n,asFloat:wa,asInteger:Sa,safeFloat:(f,e,t,s=wa($n(f,e)))=>Qs(s)?s:t,safeInteger:(f,e,t,s=Sa($n(f,e)))=>Qs(s)?s:t,safeIntegerProduct:(f,e,t,s,i=Sa($n(f,e)))=>Qs(i)?parseInt(i*t):s,safeTimestamp:(f,e,t,s=wa($n(f,e)))=>Qs(s)?parseInt(s*1e3):t,safeValue:(f,e,t,s=$n(f,e))=>eu(s)?s:t,safeString:(f,e,t,s=$n(f,e))=>Bn(s)?String(s):t,safeStringLower:(f,e,t,s=$n(f,e))=>Bn(s)?String(s).toLowerCase():t,safeStringUpper:(f,e,t,s=$n(f,e))=>Bn(s)?String(s).toUpperCase():t,safeFloat2:(f,e,t,s,i=wa(Pr(f,e,t)))=>Qs(i)?i:s,safeInteger2:(f,e,t,s,i=Sa(Pr(f,e,t)))=>Qs(i)?i:s,safeIntegerProduct2:(f,e,t,s,i,n=Sa(Pr(f,e,t)))=>Qs(n)?parseInt(n*s):i,safeTimestamp2:(f,e,t,s,i=wa(Pr(f,e,t)))=>Qs(i)?parseInt(i*1e3):s,safeValue2:(f,e,t,s,i=Pr(f,e,t))=>eu(i)?i:s,safeString2:(f,e,t,s,i=Pr(f,e,t))=>Bn(i)?String(i):s,safeStringLower2:(f,e,t,s,i=Pr(f,e,t))=>Bn(i)?String(i).toLowerCase():s,safeStringUpper2:(f,e,t,s,i=Pr(f,e,t))=>Bn(i)?String(i).toUpperCase():s,safeFloatN:(f,e,t,s=wa(Ar(f,e)))=>Qs(s)?s:t,safeIntegerN:(f,e,t,s=Sa(Ar(f,e)))=>Qs(s)?s:t,safeIntegerProductN:(f,e,t,s,i=Sa(Ar(f,e)))=>Qs(i)?parseInt(i*t):s,safeTimestampN:(f,e,t,s=wa(Ar(f,e)))=>Qs(s)?parseInt(s*1e3):t,safeValueN:(f,e,t,s=Ar(f,e))=>eu(s)?s:t,safeStringN:(f,e,t,s=Ar(f,e))=>Bn(s)?String(s):t,safeStringLowerN:(f,e,t,s=Ar(f,e))=>Bn(s)?String(s).toLowerCase():t,safeStringUpperN:(f,e,t,s=Ar(f,e))=>Bn(s)?String(s).toUpperCase():t};const{isNumber:zB,isDictionary:zw,isArray:Yh}=Bx,Kw=Object.keys,ed=f=>Yh(f)?f:Object.values(f),Xw=f=>new Set(ed(f)),Nx=(...f)=>Object.assign({},...f),Yw=f=>Yh(f)?Array.from(f):Nx(f);var Ex={keys:Kw,values:ed,extend:Nx,clone:Yw,index:Xw,ordered:f=>f,unique:f=>Array.from(Xw(f)),arrayConcat:(f,e)=>f.concat(e),inArray(f,e){return e.includes(f)},toArray(f){return Object.values(f)},isEmpty(f){return f?(Array.isArray(f)?f:Object.keys(f)).length<1:!0},keysort(f,e={}){for(const t of Kw(f).sort())e[t]=f[t];return e},indexBy(f,e,t={}){for(const s of ed(f))e in s&&(t[s[e]]=s);return t},groupBy(f,e,t={}){for(const s of ed(f))if(e in s){const i=s[e];t[i]=t[i]||[],t[i].push(s)}return t},filterBy(f,e,t=void 0,s=[]){for(const i of ed(f))i[e]===t&&s.push(i);return s},sortBy:(f,e,t=!1,s=t?-1:1)=>f.sort((i,n)=>i[e]<n[e]?-s:i[e]>n[e]?s:0),sortBy2:(f,e,t,s=!1,i=s?-1:1)=>f.sort((n,r)=>n[e]<r[e]?-i:n[e]>r[e]?i:n[t]<r[t]?-i:n[t]>r[t]?i:0),flatten:function f(e,t=[]){for(const s of e)Yh(s)?f(s,t):t.push(s);return t},pluck:(f,e)=>ed(f).filter(t=>e in t).map(t=>t[e]),omit(f,...e){if(!Array.isArray(f)){const t=Yw(f);for(const s of e)if(Yh(s))for(const i of s)delete t[i];else delete t[s];return t}return f},sum(...f){const e=f.filter(zB);return e.length>0?e.reduce((t,s)=>t+s,0):void 0},deepExtend:function f(...e){let t;for(const s of e)if(zw(s)){zw(t)||(t={});for(const i in s)t[i]=f(t[i],s[i])}else t=s;return t}};const hr=0,Qh=1,Vx=2,qx=3,na=0,cb=1,Zh=2,so=0,Lx=1,KB={ROUND:hr,TRUNCATE:Qh,ROUND_UP:Vx,ROUND_DOWN:qx,DECIMAL_PLACES:na,SIGNIFICANT_DIGITS:cb,TICK_SIZE:Zh,NO_PADDING:so,PAD_WITH_ZERO:Lx};function ub(f){if(f===void 0)return;if(typeof f!="number")return f.toString();const e=f.toString();if(Math.abs(f)<1){const t=e.split("e-"),s=t[0].replace(".",""),i=parseInt(t[1]),n=e[0]==="-";if(i)return f=(n?"-":"")+"0."+new Array(i).join("0")+s.substring(n),f}else{const t=e.split("e");if(t[1]){let s=parseInt(t[1]);const i=t[0].split(".");let n="";return i[1]&&(s-=i[1].length,n=i[1]),i[0]+n+new Array(s+1).join("0")}}return e}const Qw=[],Rx=(f,e=0)=>{if(f=ub(f),e>0){const t=Qw[e]||(Qw[e]=new RegExp("([-]*\\d+\\.\\d{"+e+"})(\\d)")),[,s]=f.toString().match(t)||[null,f];return s.toString()}return parseInt(f).toString()},XB=(f,e=0)=>parseFloat(Rx(f,e));function ay(f){const e=f.replace(/0+$/g,"").split(".");return e.length>1?e[1].length:0}const td=(f,e,t,s=na,i=so)=>{if(s===Zh&&t<=0)throw new Error("TICK_SIZE cant be used with negative or zero numPrecisionDigits");if(t<0){const X=Math.pow(10,-t);if(e===hr)return(X*td(f/X,e,0,s,i)).toString();if(e===Qh)return(f-f%X).toString()}if(s===Zh){const X=td(t,hr,22,na,so),Q=ay(X);let Se=f%t;Se=Number(td(Se,hr,8,na,so));const he=td(Se/t,hr,Math.max(Q,8),na,so);return ay(he)!==0&&(e===hr?f>0?Se>=t/2?f=f-Se+t:f=f-Se:Se>=t/2?f=Number(f)-Se:f=Number(f)-Se-t:e===Qh&&(f=f-Se)),td(f,hr,Q,na,i)}const n=ub(f),r=n[0]==="-",a=r?1:0,o=n.length;for(var d=0;d<o&&n[d]!==".";d++);const c=d<n.length,u=45,h=46,l=48,p=l+1,m=l+5,g=l+9,y=new Uint8Array(o-a+(c?0:1));y[0]=l;let b=y.length,w=-1,S=-1;for(var k=1,T=a;T<o;T++,k++){const X=n.charCodeAt(T);if(X===h)b=k--;else{if(X<l||X>g)throw new Error(`${n}: invalid number (contains an illegal character '${n[k-1]}')`);y[k]=X,X!==l&&w<0&&(w=k)}}w<0&&(w=1);let I=s===na?b:w,_=I+t;S=-1;let N=!0,M=r;for(let X=y.length-1,Q=0;X>=0;X--){let Se=y[X];X!==0?(Se+=Q,X>=I+t&&(Se=e===hr&&Se>=m&&!(Se===m&&Q)?g+1:l),Se>g?(Se=l,Q=1):Q=0):Q&&(Se=p),y[X]=Se,Se!==l&&(N=!1,w=X,S=S<0?X+1:S)}s===cb&&(I=w,_=I+t),N&&(M=!1);const x=w>=b||N?b-1:w,v=S<b?b:S,O=M?1:0,A=O+(b-x),V=Math.max(v-b,0),q=v-x,R=i===so?q:_-x,H=Math.max(R-q,0),F=A+1+V,P=F+H,E=V+H===0,j=new Uint8Array(A+(E?0:1)+V+H);for(M&&(j[0]=u),k=O,T=x;k<A;k++,T++)j[k]=y[T];for(E||(j[A]=h),k=A+1,T=b;k<F;k++,T++)j[k]=y[T];for(k=F;k<P;k++)j[k]=l;return String.fromCharCode(...j)};function YB(f){if(!(f===void 0||f==="")&&parseFloat(f)!==0)return f}var pe={numberToString:ub,precisionFromString:ay,decimalToPrecision:td,truncate_to_string:Rx,truncate:XB,omitZero:YB,precisionConstants:KB,ROUND:hr,TRUNCATE:Qh,ROUND_UP:Vx,ROUND_DOWN:qx,DECIMAL_PLACES:na,SIGNIFICANT_DIGITS:cb,TICK_SIZE:Zh,NO_PADDING:so,PAD_WITH_ZERO:Lx},xd={exports:{}},_d={exports:{}};(function(f,e){(function(t,s){f.exports=s()})(jh,function(){var t=t||function(s,i){var n=Object.create||function(){function g(){}return function(y){var b;return g.prototype=y,b=new g,g.prototype=null,b}}(),r={},a=r.lib={},o=a.Base=function(){return{extend:function(g){var y=n(this);return g&&y.mixIn(g),(!y.hasOwnProperty("init")||this.init===y.init)&&(y.init=function(){y.$super.init.apply(this,arguments)}),y.init.prototype=y,y.$super=this,y},create:function(){var g=this.extend();return g.init.apply(g,arguments),g},init:function(){},mixIn:function(g){for(var y in g)g.hasOwnProperty(y)&&(this[y]=g[y]);g.hasOwnProperty("toString")&&(this.toString=g.toString)},clone:function(){return this.init.prototype.extend(this)}}}(),d=a.WordArray=o.extend({init:function(g,y){g=this.words=g||[],y!=i?this.sigBytes=y:this.sigBytes=g.length*4},toString:function(g){return(g||u).stringify(this)},concat:function(g){var y=this.words,b=g.words,w=this.sigBytes,S=g.sigBytes;if(this.clamp(),w%4)for(var k=0;k<S;k++){var T=b[k>>>2]>>>24-k%4*8&255;y[w+k>>>2]|=T<<24-(w+k)%4*8}else for(var k=0;k<S;k+=4)y[w+k>>>2]=b[k>>>2];return this.sigBytes+=S,this},clamp:function(){var g=this.words,y=this.sigBytes;g[y>>>2]&=4294967295<<32-y%4*8,g.length=s.ceil(y/4)},clone:function(){var g=o.clone.call(this);return g.words=this.words.slice(0),g},random:function(g){for(var y=[],b=function(I){var I=I,_=987654321,N=4294967295;return function(){_=36969*(_&65535)+(_>>16)&N,I=18e3*(I&65535)+(I>>16)&N;var M=(_<<16)+I&N;return M/=4294967296,M+=.5,M*(s.random()>.5?1:-1)}},w=0,S;w<g;w+=4){var k=b((S||s.random())*4294967296);S=k()*987654071,y.push(k()*4294967296|0)}return new d.init(y,g)}}),c=r.enc={},u=c.Hex={stringify:function(g){for(var y=g.words,b=g.sigBytes,w=[],S=0;S<b;S++){var k=y[S>>>2]>>>24-S%4*8&255;w.push((k>>>4).toString(16)),w.push((k&15).toString(16))}return w.join("")},parse:function(g){for(var y=g.length,b=[],w=0;w<y;w+=2)b[w>>>3]|=parseInt(g.substr(w,2),16)<<24-w%8*4;return new d.init(b,y/2)}},h=c.Latin1={stringify:function(g){for(var y=g.words,b=g.sigBytes,w=[],S=0;S<b;S++){var k=y[S>>>2]>>>24-S%4*8&255;w.push(String.fromCharCode(k))}return w.join("")},parse:function(g){for(var y=g.length,b=[],w=0;w<y;w++)b[w>>>2]|=(g.charCodeAt(w)&255)<<24-w%4*8;return new d.init(b,y)}},l=c.Utf8={stringify:function(g){try{return decodeURIComponent(escape(h.stringify(g)))}catch{throw new Error("Malformed UTF-8 data")}},parse:function(g){return h.parse(unescape(encodeURIComponent(g)))}},p=a.BufferedBlockAlgorithm=o.extend({reset:function(){this._data=new d.init,this._nDataBytes=0},_append:function(g){typeof g=="string"&&(g=l.parse(g)),this._data.concat(g),this._nDataBytes+=g.sigBytes},_process:function(g){var y=this._data,b=y.words,w=y.sigBytes,S=this.blockSize,k=S*4,T=w/k;g?T=s.ceil(T):T=s.max((T|0)-this._minBufferSize,0);var I=T*S,_=s.min(I*4,w);if(I){for(var N=0;N<I;N+=S)this._doProcessBlock(b,N);var M=b.splice(0,I);y.sigBytes-=_}return new d.init(M,_)},clone:function(){var g=o.clone.call(this);return g._data=this._data.clone(),g},_minBufferSize:0});a.Hasher=p.extend({cfg:o.extend(),init:function(g){this.cfg=this.cfg.extend(g),this.reset()},reset:function(){p.reset.call(this),this._doReset()},update:function(g){return this._append(g),this._process(),this},finalize:function(g){g&&this._append(g);var y=this._doFinalize();return y},blockSize:16,_createHelper:function(g){return function(y,b){return new g.init(b).finalize(y)}},_createHmacHelper:function(g){return function(y,b){return new m.HMAC.init(g,b).finalize(y)}}});var m=r.algo={};return r}(Math);(function(){var s=t,i=s.lib,n=i.WordArray,r=s.enc;r.Base64={stringify:function(o){var d=o.words,c=o.sigBytes,u=this._map;o.clamp();for(var h=[],l=0;l<c;l+=3)for(var p=d[l>>>2]>>>24-l%4*8&255,m=d[l+1>>>2]>>>24-(l+1)%4*8&255,g=d[l+2>>>2]>>>24-(l+2)%4*8&255,y=p<<16|m<<8|g,b=0;b<4&&l+b*.75<c;b++)h.push(u.charAt(y>>>6*(3-b)&63));var w=u.charAt(64);if(w)for(;h.length%4;)h.push(w);return h.join("")},parse:function(o){var d=o.length,c=this._map,u=this._reverseMap;if(!u){u=this._reverseMap=[];for(var h=0;h<c.length;h++)u[c.charCodeAt(h)]=h}var l=c.charAt(64);if(l){var p=o.indexOf(l);p!==-1&&(d=p)}return a(o,d,u)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="};function a(o,d,c){for(var u=[],h=0,l=0;l<d;l++)if(l%4){var p=c[o.charCodeAt(l-1)]<<l%4*2,m=c[o.charCodeAt(l)]>>>6-l%4*2;u[h>>>2]|=(p|m)<<24-h%4*8,h++}return n.create(u,h)}})(),function(s){var i=t,n=i.lib,r=n.WordArray,a=n.Hasher,o=i.algo,d=[];(function(){for(var m=0;m<64;m++)d[m]=s.abs(s.sin(m+1))*4294967296|0})();var c=o.MD5=a.extend({_doReset:function(){this._hash=new r.init([1732584193,4023233417,2562383102,271733878])},_doProcessBlock:function(m,g){for(var y=0;y<16;y++){var b=g+y,w=m[b];m[b]=(w<<8|w>>>24)&16711935|(w<<24|w>>>8)&4278255360}var S=this._hash.words,k=m[g+0],T=m[g+1],I=m[g+2],_=m[g+3],N=m[g+4],M=m[g+5],x=m[g+6],v=m[g+7],O=m[g+8],A=m[g+9],V=m[g+10],q=m[g+11],R=m[g+12],H=m[g+13],F=m[g+14],P=m[g+15],E=S[0],j=S[1],X=S[2],Q=S[3];E=u(E,j,X,Q,k,7,d[0]),Q=u(Q,E,j,X,T,12,d[1]),X=u(X,Q,E,j,I,17,d[2]),j=u(j,X,Q,E,_,22,d[3]),E=u(E,j,X,Q,N,7,d[4]),Q=u(Q,E,j,X,M,12,d[5]),X=u(X,Q,E,j,x,17,d[6]),j=u(j,X,Q,E,v,22,d[7]),E=u(E,j,X,Q,O,7,d[8]),Q=u(Q,E,j,X,A,12,d[9]),X=u(X,Q,E,j,V,17,d[10]),j=u(j,X,Q,E,q,22,d[11]),E=u(E,j,X,Q,R,7,d[12]),Q=u(Q,E,j,X,H,12,d[13]),X=u(X,Q,E,j,F,17,d[14]),j=u(j,X,Q,E,P,22,d[15]),E=h(E,j,X,Q,T,5,d[16]),Q=h(Q,E,j,X,x,9,d[17]),X=h(X,Q,E,j,q,14,d[18]),j=h(j,X,Q,E,k,20,d[19]),E=h(E,j,X,Q,M,5,d[20]),Q=h(Q,E,j,X,V,9,d[21]),X=h(X,Q,E,j,P,14,d[22]),j=h(j,X,Q,E,N,20,d[23]),E=h(E,j,X,Q,A,5,d[24]),Q=h(Q,E,j,X,F,9,d[25]),X=h(X,Q,E,j,_,14,d[26]),j=h(j,X,Q,E,O,20,d[27]),E=h(E,j,X,Q,H,5,d[28]),Q=h(Q,E,j,X,I,9,d[29]),X=h(X,Q,E,j,v,14,d[30]),j=h(j,X,Q,E,R,20,d[31]),E=l(E,j,X,Q,M,4,d[32]),Q=l(Q,E,j,X,O,11,d[33]),X=l(X,Q,E,j,q,16,d[34]),j=l(j,X,Q,E,F,23,d[35]),E=l(E,j,X,Q,T,4,d[36]),Q=l(Q,E,j,X,N,11,d[37]),X=l(X,Q,E,j,v,16,d[38]),j=l(j,X,Q,E,V,23,d[39]),E=l(E,j,X,Q,H,4,d[40]),Q=l(Q,E,j,X,k,11,d[41]),X=l(X,Q,E,j,_,16,d[42]),j=l(j,X,Q,E,x,23,d[43]),E=l(E,j,X,Q,A,4,d[44]),Q=l(Q,E,j,X,R,11,d[45]),X=l(X,Q,E,j,P,16,d[46]),j=l(j,X,Q,E,I,23,d[47]),E=p(E,j,X,Q,k,6,d[48]),Q=p(Q,E,j,X,v,10,d[49]),X=p(X,Q,E,j,F,15,d[50]),j=p(j,X,Q,E,M,21,d[51]),E=p(E,j,X,Q,R,6,d[52]),Q=p(Q,E,j,X,_,10,d[53]),X=p(X,Q,E,j,V,15,d[54]),j=p(j,X,Q,E,T,21,d[55]),E=p(E,j,X,Q,O,6,d[56]),Q=p(Q,E,j,X,P,10,d[57]),X=p(X,Q,E,j,x,15,d[58]),j=p(j,X,Q,E,H,21,d[59]),E=p(E,j,X,Q,N,6,d[60]),Q=p(Q,E,j,X,q,10,d[61]),X=p(X,Q,E,j,I,15,d[62]),j=p(j,X,Q,E,A,21,d[63]),S[0]=S[0]+E|0,S[1]=S[1]+j|0,S[2]=S[2]+X|0,S[3]=S[3]+Q|0},_doFinalize:function(){var m=this._data,g=m.words,y=this._nDataBytes*8,b=m.sigBytes*8;g[b>>>5]|=128<<24-b%32;var w=s.floor(y/4294967296),S=y;g[(b+64>>>9<<4)+15]=(w<<8|w>>>24)&16711935|(w<<24|w>>>8)&4278255360,g[(b+64>>>9<<4)+14]=(S<<8|S>>>24)&16711935|(S<<24|S>>>8)&4278255360,m.sigBytes=(g.length+1)*4,this._process();for(var k=this._hash,T=k.words,I=0;I<4;I++){var _=T[I];T[I]=(_<<8|_>>>24)&16711935|(_<<24|_>>>8)&4278255360}return k},clone:function(){var m=a.clone.call(this);return m._hash=this._hash.clone(),m}});function u(m,g,y,b,w,S,k){var T=m+(g&y|~g&b)+w+k;return(T<<S|T>>>32-S)+g}function h(m,g,y,b,w,S,k){var T=m+(g&b|y&~b)+w+k;return(T<<S|T>>>32-S)+g}function l(m,g,y,b,w,S,k){var T=m+(g^y^b)+w+k;return(T<<S|T>>>32-S)+g}function p(m,g,y,b,w,S,k){var T=m+(y^(g|~b))+w+k;return(T<<S|T>>>32-S)+g}i.MD5=a._createHelper(c),i.HmacMD5=a._createHmacHelper(c)}(Math),function(){var s=t,i=s.lib,n=i.WordArray,r=i.Hasher,a=s.algo,o=[],d=a.SHA1=r.extend({_doReset:function(){this._hash=new n.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(c,u){for(var h=this._hash.words,l=h[0],p=h[1],m=h[2],g=h[3],y=h[4],b=0;b<80;b++){if(b<16)o[b]=c[u+b]|0;else{var w=o[b-3]^o[b-8]^o[b-14]^o[b-16];o[b]=w<<1|w>>>31}var S=(l<<5|l>>>27)+y+o[b];b<20?S+=(p&m|~p&g)+1518500249:b<40?S+=(p^m^g)+1859775393:b<60?S+=(p&m|p&g|m&g)-1894007588:S+=(p^m^g)-899497514,y=g,g=m,m=p<<30|p>>>2,p=l,l=S}h[0]=h[0]+l|0,h[1]=h[1]+p|0,h[2]=h[2]+m|0,h[3]=h[3]+g|0,h[4]=h[4]+y|0},_doFinalize:function(){var c=this._data,u=c.words,h=this._nDataBytes*8,l=c.sigBytes*8;return u[l>>>5]|=128<<24-l%32,u[(l+64>>>9<<4)+14]=Math.floor(h/4294967296),u[(l+64>>>9<<4)+15]=h,c.sigBytes=u.length*4,this._process(),this._hash},clone:function(){var c=r.clone.call(this);return c._hash=this._hash.clone(),c}});s.SHA1=r._createHelper(d),s.HmacSHA1=r._createHmacHelper(d)}(),function(s){var i=t,n=i.lib,r=n.WordArray,a=n.Hasher,o=i.algo,d=[],c=[];(function(){function l(y){for(var b=s.sqrt(y),w=2;w<=b;w++)if(!(y%w))return!1;return!0}function p(y){return(y-(y|0))*4294967296|0}for(var m=2,g=0;g<64;)l(m)&&(g<8&&(d[g]=p(s.pow(m,1/2))),c[g]=p(s.pow(m,1/3)),g++),m++})();var u=[],h=o.SHA256=a.extend({_doReset:function(){this._hash=new r.init(d.slice(0))},_doProcessBlock:function(l,p){for(var m=this._hash.words,g=m[0],y=m[1],b=m[2],w=m[3],S=m[4],k=m[5],T=m[6],I=m[7],_=0;_<64;_++){if(_<16)u[_]=l[p+_]|0;else{var N=u[_-15],M=(N<<25|N>>>7)^(N<<14|N>>>18)^N>>>3,x=u[_-2],v=(x<<15|x>>>17)^(x<<13|x>>>19)^x>>>10;u[_]=M+u[_-7]+v+u[_-16]}var O=S&k^~S&T,A=g&y^g&b^y&b,V=(g<<30|g>>>2)^(g<<19|g>>>13)^(g<<10|g>>>22),q=(S<<26|S>>>6)^(S<<21|S>>>11)^(S<<7|S>>>25),R=I+q+O+c[_]+u[_],H=V+A;I=T,T=k,k=S,S=w+R|0,w=b,b=y,y=g,g=R+H|0}m[0]=m[0]+g|0,m[1]=m[1]+y|0,m[2]=m[2]+b|0,m[3]=m[3]+w|0,m[4]=m[4]+S|0,m[5]=m[5]+k|0,m[6]=m[6]+T|0,m[7]=m[7]+I|0},_doFinalize:function(){var l=this._data,p=l.words,m=this._nDataBytes*8,g=l.sigBytes*8;return p[g>>>5]|=128<<24-g%32,p[(g+64>>>9<<4)+14]=s.floor(m/4294967296),p[(g+64>>>9<<4)+15]=m,l.sigBytes=p.length*4,this._process(),this._hash},clone:function(){var l=a.clone.call(this);return l._hash=this._hash.clone(),l}});i.SHA256=a._createHelper(h),i.HmacSHA256=a._createHmacHelper(h)}(Math),function(){var s=t,i=s.lib,n=i.WordArray,r=s.enc;r.Utf16=r.Utf16BE={stringify:function(o){for(var d=o.words,c=o.sigBytes,u=[],h=0;h<c;h+=2){var l=d[h>>>2]>>>16-h%4*8&65535;u.push(String.fromCharCode(l))}return u.join("")},parse:function(o){for(var d=o.length,c=[],u=0;u<d;u++)c[u>>>1]|=o.charCodeAt(u)<<16-u%2*16;return n.create(c,d*2)}},r.Utf16LE={stringify:function(o){for(var d=o.words,c=o.sigBytes,u=[],h=0;h<c;h+=2){var l=a(d[h>>>2]>>>16-h%4*8&65535);u.push(String.fromCharCode(l))}return u.join("")},parse:function(o){for(var d=o.length,c=[],u=0;u<d;u++)c[u>>>1]|=a(o.charCodeAt(u)<<16-u%2*16);return n.create(c,d*2)}};function a(o){return o<<8&4278255360|o>>>8&16711935}}(),function(){if(typeof ArrayBuffer=="function"){var s=t,i=s.lib,n=i.WordArray,r=n.init,a=n.init=function(o){if(o instanceof ArrayBuffer&&(o=new Uint8Array(o)),(o instanceof Int8Array||typeof Uint8ClampedArray<"u"&&o instanceof Uint8ClampedArray||o instanceof Int16Array||o instanceof Uint16Array||o instanceof Int32Array||o instanceof Uint32Array||o instanceof Float32Array||o instanceof Float64Array)&&(o=new Uint8Array(o.buffer,o.byteOffset,o.byteLength)),o instanceof Uint8Array){for(var d=o.byteLength,c=[],u=0;u<d;u++)c[u>>>2]|=o[u]<<24-u%4*8;r.call(this,c,d)}else r.apply(this,arguments)};a.prototype=n}}();/** @preserve
		(c) 2012 by Cédric Mesnil. All rights reserved.

		Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

		    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
		    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

		THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		*/(function(s){var i=t,n=i.lib,r=n.WordArray,a=n.Hasher,o=i.algo,d=r.create([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13]),c=r.create([5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11]),u=r.create([11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6]),h=r.create([8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]),l=r.create([0,1518500249,1859775393,2400959708,2840853838]),p=r.create([1352829926,1548603684,1836072691,2053994217,0]),m=o.RIPEMD160=a.extend({_doReset:function(){this._hash=r.create([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(T,I){for(var _=0;_<16;_++){var N=I+_,M=T[N];T[N]=(M<<8|M>>>24)&16711935|(M<<24|M>>>8)&4278255360}var x=this._hash.words,v=l.words,O=p.words,A=d.words,V=c.words,q=u.words,R=h.words,H,F,P,E,j,X,Q,Se,he,xe;X=H=x[0],Q=F=x[1],Se=P=x[2],he=E=x[3],xe=j=x[4];for(var Ae,_=0;_<80;_+=1)Ae=H+T[I+A[_]]|0,_<16?Ae+=g(F,P,E)+v[0]:_<32?Ae+=y(F,P,E)+v[1]:_<48?Ae+=b(F,P,E)+v[2]:_<64?Ae+=w(F,P,E)+v[3]:Ae+=S(F,P,E)+v[4],Ae=Ae|0,Ae=k(Ae,q[_]),Ae=Ae+j|0,H=j,j=E,E=k(P,10),P=F,F=Ae,Ae=X+T[I+V[_]]|0,_<16?Ae+=S(Q,Se,he)+O[0]:_<32?Ae+=w(Q,Se,he)+O[1]:_<48?Ae+=b(Q,Se,he)+O[2]:_<64?Ae+=y(Q,Se,he)+O[3]:Ae+=g(Q,Se,he)+O[4],Ae=Ae|0,Ae=k(Ae,R[_]),Ae=Ae+xe|0,X=xe,xe=he,he=k(Se,10),Se=Q,Q=Ae;Ae=x[1]+P+he|0,x[1]=x[2]+E+xe|0,x[2]=x[3]+j+X|0,x[3]=x[4]+H+Q|0,x[4]=x[0]+F+Se|0,x[0]=Ae},_doFinalize:function(){var T=this._data,I=T.words,_=this._nDataBytes*8,N=T.sigBytes*8;I[N>>>5]|=128<<24-N%32,I[(N+64>>>9<<4)+14]=(_<<8|_>>>24)&16711935|(_<<24|_>>>8)&4278255360,T.sigBytes=(I.length+1)*4,this._process();for(var M=this._hash,x=M.words,v=0;v<5;v++){var O=x[v];x[v]=(O<<8|O>>>24)&16711935|(O<<24|O>>>8)&4278255360}return M},clone:function(){var T=a.clone.call(this);return T._hash=this._hash.clone(),T}});function g(T,I,_){return T^I^_}function y(T,I,_){return T&I|~T&_}function b(T,I,_){return(T|~I)^_}function w(T,I,_){return T&_|I&~_}function S(T,I,_){return T^(I|~_)}function k(T,I){return T<<I|T>>>32-I}i.RIPEMD160=a._createHelper(m),i.HmacRIPEMD160=a._createHmacHelper(m)})(),function(){var s=t,i=s.lib,n=i.Base,r=s.enc,a=r.Utf8,o=s.algo;o.HMAC=n.extend({init:function(d,c){d=this._hasher=new d.init,typeof c=="string"&&(c=a.parse(c));var u=d.blockSize,h=u*4;c.sigBytes>h&&(c=d.finalize(c)),c.clamp();for(var l=this._oKey=c.clone(),p=this._iKey=c.clone(),m=l.words,g=p.words,y=0;y<u;y++)m[y]^=1549556828,g[y]^=909522486;l.sigBytes=p.sigBytes=h,this.reset()},reset:function(){var d=this._hasher;d.reset(),d.update(this._iKey)},update:function(d){return this._hasher.update(d),this},finalize:function(d){var c=this._hasher,u=c.finalize(d);c.reset();var h=c.finalize(this._oKey.clone().concat(u));return h}})}(),function(){var s=t,i=s.lib,n=i.Base,r=i.WordArray,a=s.algo,o=a.SHA1,d=a.HMAC,c=a.PBKDF2=n.extend({cfg:n.extend({keySize:128/32,hasher:o,iterations:1}),init:function(u){this.cfg=this.cfg.extend(u)},compute:function(u,h){for(var l=this.cfg,p=d.create(l.hasher,u),m=r.create(),g=r.create([1]),y=m.words,b=g.words,w=l.keySize,S=l.iterations;y.length<w;){var k=p.update(h).finalize(g);p.reset();for(var T=k.words,I=T.length,_=k,N=1;N<S;N++){_=p.finalize(_),p.reset();for(var M=_.words,x=0;x<I;x++)T[x]^=M[x]}m.concat(k),b[0]++}return m.sigBytes=w*4,m}});s.PBKDF2=function(u,h,l){return c.create(l).compute(u,h)}}(),function(){var s=t,i=s.lib,n=i.Base,r=i.WordArray,a=s.algo,o=a.MD5,d=a.EvpKDF=n.extend({cfg:n.extend({keySize:128/32,hasher:o,iterations:1}),init:function(c){this.cfg=this.cfg.extend(c)},compute:function(c,u){for(var h=this.cfg,l=h.hasher.create(),p=r.create(),m=p.words,g=h.keySize,y=h.iterations;m.length<g;){b&&l.update(b);var b=l.update(c).finalize(u);l.reset();for(var w=1;w<y;w++)b=l.finalize(b),l.reset();p.concat(b)}return p.sigBytes=g*4,p}});s.EvpKDF=function(c,u,h){return d.create(h).compute(c,u)}}(),function(){var s=t,i=s.lib,n=i.WordArray,r=s.algo,a=r.SHA256,o=r.SHA224=a.extend({_doReset:function(){this._hash=new n.init([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428])},_doFinalize:function(){var d=a._doFinalize.call(this);return d.sigBytes-=4,d}});s.SHA224=a._createHelper(o),s.HmacSHA224=a._createHmacHelper(o)}(),function(s){var i=t,n=i.lib,r=n.Base,a=n.WordArray,o=i.x64={};o.Word=r.extend({init:function(d,c){this.high=d,this.low=c}}),o.WordArray=r.extend({init:function(d,c){d=this.words=d||[],c!=s?this.sigBytes=c:this.sigBytes=d.length*8},toX32:function(){for(var d=this.words,c=d.length,u=[],h=0;h<c;h++){var l=d[h];u.push(l.high),u.push(l.low)}return a.create(u,this.sigBytes)},clone:function(){for(var d=r.clone.call(this),c=d.words=this.words.slice(0),u=c.length,h=0;h<u;h++)c[h]=c[h].clone();return d}})}(),function(s){var i=t,n=i.lib,r=n.WordArray,a=n.Hasher,o=i.x64,d=o.Word,c=i.algo,u=[],h=[],l=[];(function(){for(var g=1,y=0,b=0;b<24;b++){u[g+5*y]=(b+1)*(b+2)/2%64;var w=y%5,S=(2*g+3*y)%5;g=w,y=S}for(var g=0;g<5;g++)for(var y=0;y<5;y++)h[g+5*y]=y+(2*g+3*y)%5*5;for(var k=1,T=0;T<24;T++){for(var I=0,_=0,N=0;N<7;N++){if(k&1){var M=(1<<N)-1;M<32?_^=1<<M:I^=1<<M-32}k&128?k=k<<1^113:k<<=1}l[T]=d.create(I,_)}})();var p=[];(function(){for(var g=0;g<25;g++)p[g]=d.create()})();var m=c.SHA3=a.extend({cfg:a.cfg.extend({outputLength:512}),_doReset:function(){for(var g=this._state=[],y=0;y<25;y++)g[y]=new d.init;this.blockSize=(1600-2*this.cfg.outputLength)/32},_doProcessBlock:function(g,y){for(var b=this._state,w=this.blockSize/2,S=0;S<w;S++){var k=g[y+2*S],T=g[y+2*S+1];k=(k<<8|k>>>24)&16711935|(k<<24|k>>>8)&4278255360,T=(T<<8|T>>>24)&16711935|(T<<24|T>>>8)&4278255360;var I=b[S];I.high^=T,I.low^=k}for(var _=0;_<24;_++){for(var N=0;N<5;N++){for(var M=0,x=0,v=0;v<5;v++){var I=b[N+5*v];M^=I.high,x^=I.low}var O=p[N];O.high=M,O.low=x}for(var N=0;N<5;N++)for(var A=p[(N+4)%5],V=p[(N+1)%5],q=V.high,R=V.low,M=A.high^(q<<1|R>>>31),x=A.low^(R<<1|q>>>31),v=0;v<5;v++){var I=b[N+5*v];I.high^=M,I.low^=x}for(var H=1;H<25;H++){var I=b[H],F=I.high,P=I.low,E=u[H];if(E<32)var M=F<<E|P>>>32-E,x=P<<E|F>>>32-E;else var M=P<<E-32|F>>>64-E,x=F<<E-32|P>>>64-E;var j=p[h[H]];j.high=M,j.low=x}var X=p[0],Q=b[0];X.high=Q.high,X.low=Q.low;for(var N=0;N<5;N++)for(var v=0;v<5;v++){var H=N+5*v,I=b[H],Se=p[H],he=p[(N+1)%5+5*v],xe=p[(N+2)%5+5*v];I.high=Se.high^~he.high&xe.high,I.low=Se.low^~he.low&xe.low}var I=b[0],Ae=l[_];I.high^=Ae.high,I.low^=Ae.low}},_doFinalize:function(){var g=this._data,y=g.words;this._nDataBytes*8;var b=g.sigBytes*8,w=this.blockSize*32;y[b>>>5]|=1<<24-b%32,y[(s.ceil((b+1)/w)*w>>>5)-1]|=128,g.sigBytes=y.length*4,this._process();for(var S=this._state,k=this.cfg.outputLength/8,T=k/8,I=[],_=0;_<T;_++){var N=S[_],M=N.high,x=N.low;M=(M<<8|M>>>24)&16711935|(M<<24|M>>>8)&4278255360,x=(x<<8|x>>>24)&16711935|(x<<24|x>>>8)&4278255360,I.push(x),I.push(M)}return new r.init(I,k)},clone:function(){for(var g=a.clone.call(this),y=g._state=this._state.slice(0),b=0;b<25;b++)y[b]=y[b].clone();return g}});i.SHA3=a._createHelper(m),i.HmacSHA3=a._createHmacHelper(m)}(Math),function(){var s=t,i=s.lib,n=i.Hasher,r=s.x64,a=r.Word,o=r.WordArray,d=s.algo;function c(){return a.create.apply(a,arguments)}var u=[c(1116352408,3609767458),c(1899447441,602891725),c(3049323471,3964484399),c(3921009573,2173295548),c(961987163,4081628472),c(1508970993,3053834265),c(2453635748,2937671579),c(2870763221,3664609560),c(3624381080,2734883394),c(310598401,1164996542),c(607225278,1323610764),c(1426881987,3590304994),c(1925078388,4068182383),c(2162078206,991336113),c(2614888103,633803317),c(3248222580,3479774868),c(3835390401,2666613458),c(4022224774,944711139),c(264347078,2341262773),c(604807628,2007800933),c(770255983,1495990901),c(1249150122,1856431235),c(1555081692,3175218132),c(1996064986,2198950837),c(2554220882,3999719339),c(2821834349,766784016),c(2952996808,2566594879),c(3210313671,3203337956),c(3336571891,1034457026),c(3584528711,2466948901),c(113926993,3758326383),c(338241895,168717936),c(666307205,1188179964),c(773529912,1546045734),c(1294757372,1522805485),c(1396182291,2643833823),c(1695183700,2343527390),c(1986661051,1014477480),c(2177026350,1206759142),c(2456956037,344077627),c(2730485921,1290863460),c(2820302411,3158454273),c(3259730800,3505952657),c(3345764771,106217008),c(3516065817,3606008344),c(3600352804,1432725776),c(4094571909,1467031594),c(275423344,851169720),c(430227734,3100823752),c(506948616,1363258195),c(659060556,3750685593),c(883997877,3785050280),c(958139571,3318307427),c(1322822218,3812723403),c(1537002063,2003034995),c(1747873779,3602036899),c(1955562222,1575990012),c(2024104815,1125592928),c(2227730452,2716904306),c(2361852424,442776044),c(2428436474,593698344),c(2756734187,3733110249),c(3204031479,2999351573),c(3329325298,3815920427),c(3391569614,3928383900),c(3515267271,566280711),c(3940187606,3454069534),c(4118630271,4000239992),c(116418474,1914138554),c(174292421,2731055270),c(289380356,3203993006),c(460393269,320620315),c(685471733,587496836),c(852142971,1086792851),c(1017036298,365543100),c(1126000580,2618297676),c(1288033470,3409855158),c(1501505948,4234509866),c(1607167915,987167468),c(1816402316,1246189591)],h=[];(function(){for(var p=0;p<80;p++)h[p]=c()})();var l=d.SHA512=n.extend({_doReset:function(){this._hash=new o.init([new a.init(1779033703,4089235720),new a.init(3144134277,2227873595),new a.init(1013904242,4271175723),new a.init(2773480762,1595750129),new a.init(1359893119,2917565137),new a.init(2600822924,725511199),new a.init(528734635,4215389547),new a.init(1541459225,327033209)])},_doProcessBlock:function(p,m){for(var g=this._hash.words,y=g[0],b=g[1],w=g[2],S=g[3],k=g[4],T=g[5],I=g[6],_=g[7],N=y.high,M=y.low,x=b.high,v=b.low,O=w.high,A=w.low,V=S.high,q=S.low,R=k.high,H=k.low,F=T.high,P=T.low,E=I.high,j=I.low,X=_.high,Q=_.low,Se=N,he=M,xe=x,Ae=v,Re=O,He=A,qt=V,D=q,$=R,G=H,U=F,W=P,J=E,ee=j,ne=X,ce=Q,ie=0;ie<80;ie++){var de=h[ie];if(ie<16)var we=de.high=p[m+ie*2]|0,ue=de.low=p[m+ie*2+1]|0;else{var Oe=h[ie-15],Me=Oe.high,L=Oe.low,C=(Me>>>1|L<<31)^(Me>>>8|L<<24)^Me>>>7,B=(L>>>1|Me<<31)^(L>>>8|Me<<24)^(L>>>7|Me<<25),z=h[ie-2],Y=z.high,se=z.low,re=(Y>>>19|se<<13)^(Y<<3|se>>>29)^Y>>>6,Be=(se>>>19|Y<<13)^(se<<3|Y>>>29)^(se>>>6|Y<<26),$e=h[ie-7],Ne=$e.high,Fe=$e.low,rt=h[ie-16],Qt=rt.high,Lt=rt.low,ue=B+Fe,we=C+Ne+(ue>>>0<B>>>0?1:0),ue=ue+Be,we=we+re+(ue>>>0<Be>>>0?1:0),ue=ue+Lt,we=we+Qt+(ue>>>0<Lt>>>0?1:0);de.high=we,de.low=ue}var Uu=$&U^~$&J,Rt=G&W^~G&ee,Zt=Se&xe^Se&Re^xe&Re,$u=he&Ae^he&He^Ae&He,Jt=(Se>>>28|he<<4)^(Se<<30|he>>>2)^(Se<<25|he>>>7),Ft=(he>>>28|Se<<4)^(he<<30|Se>>>2)^(he<<25|Se>>>7),ju=($>>>14|G<<18)^($>>>18|G<<14)^($<<23|G>>>9),es=(G>>>14|$<<18)^(G>>>18|$<<14)^(G<<23|$>>>9),Dt=u[ie],Wu=Dt.high,Ht=Dt.low,it=ce+es,pn=ne+ju+(it>>>0<ce>>>0?1:0),it=it+Rt,pn=pn+Uu+(it>>>0<Rt>>>0?1:0),it=it+Ht,pn=pn+Wu+(it>>>0<Ht>>>0?1:0),it=it+ue,pn=pn+we+(it>>>0<ue>>>0?1:0),Gt=Ft+$u,ts=Jt+Zt+(Gt>>>0<Ft>>>0?1:0);ne=J,ce=ee,J=U,ee=W,U=$,W=G,G=D+it|0,$=qt+pn+(G>>>0<D>>>0?1:0)|0,qt=Re,D=He,Re=xe,He=Ae,xe=Se,Ae=he,he=it+Gt|0,Se=pn+ts+(he>>>0<it>>>0?1:0)|0}M=y.low=M+he,y.high=N+Se+(M>>>0<he>>>0?1:0),v=b.low=v+Ae,b.high=x+xe+(v>>>0<Ae>>>0?1:0),A=w.low=A+He,w.high=O+Re+(A>>>0<He>>>0?1:0),q=S.low=q+D,S.high=V+qt+(q>>>0<D>>>0?1:0),H=k.low=H+G,k.high=R+$+(H>>>0<G>>>0?1:0),P=T.low=P+W,T.high=F+U+(P>>>0<W>>>0?1:0),j=I.low=j+ee,I.high=E+J+(j>>>0<ee>>>0?1:0),Q=_.low=Q+ce,_.high=X+ne+(Q>>>0<ce>>>0?1:0)},_doFinalize:function(){var p=this._data,m=p.words,g=this._nDataBytes*8,y=p.sigBytes*8;m[y>>>5]|=128<<24-y%32,m[(y+128>>>10<<5)+30]=Math.floor(g/4294967296),m[(y+128>>>10<<5)+31]=g,p.sigBytes=m.length*4,this._process();var b=this._hash.toX32();return b},clone:function(){var p=n.clone.call(this);return p._hash=this._hash.clone(),p},blockSize:1024/32});s.SHA512=n._createHelper(l),s.HmacSHA512=n._createHmacHelper(l)}(),function(){var s=t,i=s.x64,n=i.Word,r=i.WordArray,a=s.algo,o=a.SHA512,d=a.SHA384=o.extend({_doReset:function(){this._hash=new r.init([new n.init(3418070365,3238371032),new n.init(1654270250,914150663),new n.init(2438529370,812702999),new n.init(355462360,4144912697),new n.init(1731405415,4290775857),new n.init(2394180231,1750603025),new n.init(3675008525,1694076839),new n.init(1203062813,3204075428)])},_doFinalize:function(){var c=o._doFinalize.call(this);return c.sigBytes-=16,c}});s.SHA384=o._createHelper(d),s.HmacSHA384=o._createHmacHelper(d)}(),t.lib.Cipher||function(s){var i=t,n=i.lib,r=n.Base,a=n.WordArray,o=n.BufferedBlockAlgorithm,d=i.enc;d.Utf8;var c=d.Base64,u=i.algo,h=u.EvpKDF,l=n.Cipher=o.extend({cfg:r.extend(),createEncryptor:function(M,x){return this.create(this._ENC_XFORM_MODE,M,x)},createDecryptor:function(M,x){return this.create(this._DEC_XFORM_MODE,M,x)},init:function(M,x,v){this.cfg=this.cfg.extend(v),this._xformMode=M,this._key=x,this.reset()},reset:function(){o.reset.call(this),this._doReset()},process:function(M){return this._append(M),this._process()},finalize:function(M){M&&this._append(M);var x=this._doFinalize();return x},keySize:128/32,ivSize:128/32,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(){function M(x){return typeof x=="string"?N:T}return function(x){return{encrypt:function(v,O,A){return M(O).encrypt(x,v,O,A)},decrypt:function(v,O,A){return M(O).decrypt(x,v,O,A)}}}}()});n.StreamCipher=l.extend({_doFinalize:function(){var M=this._process(!0);return M},blockSize:1});var p=i.mode={},m=n.BlockCipherMode=r.extend({createEncryptor:function(M,x){return this.Encryptor.create(M,x)},createDecryptor:function(M,x){return this.Decryptor.create(M,x)},init:function(M,x){this._cipher=M,this._iv=x}}),g=p.CBC=function(){var M=m.extend();M.Encryptor=M.extend({processBlock:function(v,O){var A=this._cipher,V=A.blockSize;x.call(this,v,O,V),A.encryptBlock(v,O),this._prevBlock=v.slice(O,O+V)}}),M.Decryptor=M.extend({processBlock:function(v,O){var A=this._cipher,V=A.blockSize,q=v.slice(O,O+V);A.decryptBlock(v,O),x.call(this,v,O,V),this._prevBlock=q}});function x(v,O,A){var V=this._iv;if(V){var q=V;this._iv=s}else var q=this._prevBlock;for(var R=0;R<A;R++)v[O+R]^=q[R]}return M}(),y=i.pad={},b=y.Pkcs7={pad:function(M,x){for(var v=x*4,O=v-M.sigBytes%v,A=O<<24|O<<16|O<<8|O,V=[],q=0;q<O;q+=4)V.push(A);var R=a.create(V,O);M.concat(R)},unpad:function(M){var x=M.words[M.sigBytes-1>>>2]&255;M.sigBytes-=x}};n.BlockCipher=l.extend({cfg:l.cfg.extend({mode:g,padding:b}),reset:function(){l.reset.call(this);var M=this.cfg,x=M.iv,v=M.mode;if(this._xformMode==this._ENC_XFORM_MODE)var O=v.createEncryptor;else{var O=v.createDecryptor;this._minBufferSize=1}this._mode&&this._mode.__creator==O?this._mode.init(this,x&&x.words):(this._mode=O.call(v,this,x&&x.words),this._mode.__creator=O)},_doProcessBlock:function(M,x){this._mode.processBlock(M,x)},_doFinalize:function(){var M=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){M.pad(this._data,this.blockSize);var x=this._process(!0)}else{var x=this._process(!0);M.unpad(x)}return x},blockSize:128/32});var w=n.CipherParams=r.extend({init:function(M){this.mixIn(M)},toString:function(M){return(M||this.formatter).stringify(this)}}),S=i.format={},k=S.OpenSSL={stringify:function(M){var x=M.ciphertext,v=M.salt;if(v)var O=a.create([1398893684,1701076831]).concat(v).concat(x);else var O=x;return O.toString(c)},parse:function(M){var x=c.parse(M),v=x.words;if(v[0]==1398893684&&v[1]==1701076831){var O=a.create(v.slice(2,4));v.splice(0,4),x.sigBytes-=16}return w.create({ciphertext:x,salt:O})}},T=n.SerializableCipher=r.extend({cfg:r.extend({format:k}),encrypt:function(M,x,v,O){O=this.cfg.extend(O);var A=M.createEncryptor(v,O),V=A.finalize(x),q=A.cfg;return w.create({ciphertext:V,key:v,iv:q.iv,algorithm:M,mode:q.mode,padding:q.padding,blockSize:M.blockSize,formatter:O.format})},decrypt:function(M,x,v,O){O=this.cfg.extend(O),x=this._parse(x,O.format);var A=M.createDecryptor(v,O).finalize(x.ciphertext);return A},_parse:function(M,x){return typeof M=="string"?x.parse(M,this):M}}),I=i.kdf={},_=I.OpenSSL={execute:function(M,x,v,O){O||(O=a.random(64/8));var A=h.create({keySize:x+v}).compute(M,O),V=a.create(A.words.slice(x),v*4);return A.sigBytes=x*4,w.create({key:A,iv:V,salt:O})}},N=n.PasswordBasedCipher=T.extend({cfg:T.cfg.extend({kdf:_}),encrypt:function(M,x,v,O){O=this.cfg.extend(O);var A=O.kdf.execute(v,M.keySize,M.ivSize);O.iv=A.iv;var V=T.encrypt.call(this,M,x,A.key,O);return V.mixIn(A),V},decrypt:function(M,x,v,O){O=this.cfg.extend(O),x=this._parse(x,O.format);var A=O.kdf.execute(v,M.keySize,M.ivSize,x.salt);O.iv=A.iv;var V=T.decrypt.call(this,M,x,A.key,O);return V}})}(),t.mode.CFB=function(){var s=t.lib.BlockCipherMode.extend();s.Encryptor=s.extend({processBlock:function(n,r){var a=this._cipher,o=a.blockSize;i.call(this,n,r,o,a),this._prevBlock=n.slice(r,r+o)}}),s.Decryptor=s.extend({processBlock:function(n,r){var a=this._cipher,o=a.blockSize,d=n.slice(r,r+o);i.call(this,n,r,o,a),this._prevBlock=d}});function i(n,r,a,o){var d=this._iv;if(d){var c=d.slice(0);this._iv=void 0}else var c=this._prevBlock;o.encryptBlock(c,0);for(var u=0;u<a;u++)n[r+u]^=c[u]}return s}(),t.mode.ECB=function(){var s=t.lib.BlockCipherMode.extend();return s.Encryptor=s.extend({processBlock:function(i,n){this._cipher.encryptBlock(i,n)}}),s.Decryptor=s.extend({processBlock:function(i,n){this._cipher.decryptBlock(i,n)}}),s}(),t.pad.AnsiX923={pad:function(s,i){var n=s.sigBytes,r=i*4,a=r-n%r,o=n+a-1;s.clamp(),s.words[o>>>2]|=a<<24-o%4*8,s.sigBytes+=a},unpad:function(s){var i=s.words[s.sigBytes-1>>>2]&255;s.sigBytes-=i}},t.pad.Iso10126={pad:function(s,i){var n=i*4,r=n-s.sigBytes%n;s.concat(t.lib.WordArray.random(r-1)).concat(t.lib.WordArray.create([r<<24],1))},unpad:function(s){var i=s.words[s.sigBytes-1>>>2]&255;s.sigBytes-=i}},t.pad.Iso97971={pad:function(s,i){s.concat(t.lib.WordArray.create([2147483648],1)),t.pad.ZeroPadding.pad(s,i)},unpad:function(s){t.pad.ZeroPadding.unpad(s),s.sigBytes--}},t.mode.OFB=function(){var s=t.lib.BlockCipherMode.extend(),i=s.Encryptor=s.extend({processBlock:function(n,r){var a=this._cipher,o=a.blockSize,d=this._iv,c=this._keystream;d&&(c=this._keystream=d.slice(0),this._iv=void 0),a.encryptBlock(c,0);for(var u=0;u<o;u++)n[r+u]^=c[u]}});return s.Decryptor=i,s}(),t.pad.NoPadding={pad:function(){},unpad:function(){}},function(s){var i=t,n=i.lib,r=n.CipherParams,a=i.enc,o=a.Hex,d=i.format;d.Hex={stringify:function(c){return c.ciphertext.toString(o)},parse:function(c){var u=o.parse(c);return r.create({ciphertext:u})}}}(),function(){var s=t,i=s.lib,n=i.BlockCipher,r=s.algo,a=[],o=[],d=[],c=[],u=[],h=[],l=[],p=[],m=[],g=[];(function(){for(var w=[],S=0;S<256;S++)S<128?w[S]=S<<1:w[S]=S<<1^283;for(var k=0,T=0,S=0;S<256;S++){var I=T^T<<1^T<<2^T<<3^T<<4;I=I>>>8^I&255^99,a[k]=I,o[I]=k;var _=w[k],N=w[_],M=w[N],x=w[I]*257^I*16843008;d[k]=x<<24|x>>>8,c[k]=x<<16|x>>>16,u[k]=x<<8|x>>>24,h[k]=x;var x=M*16843009^N*65537^_*257^k*16843008;l[I]=x<<24|x>>>8,p[I]=x<<16|x>>>16,m[I]=x<<8|x>>>24,g[I]=x,k?(k=_^w[w[w[M^_]]],T^=w[w[T]]):k=T=1}})();var y=[0,1,2,4,8,16,32,64,128,27,54],b=r.AES=n.extend({_doReset:function(){if(!(this._nRounds&&this._keyPriorReset===this._key)){for(var w=this._keyPriorReset=this._key,S=w.words,k=w.sigBytes/4,T=this._nRounds=k+6,I=(T+1)*4,_=this._keySchedule=[],N=0;N<I;N++)if(N<k)_[N]=S[N];else{var M=_[N-1];N%k?k>6&&N%k==4&&(M=a[M>>>24]<<24|a[M>>>16&255]<<16|a[M>>>8&255]<<8|a[M&255]):(M=M<<8|M>>>24,M=a[M>>>24]<<24|a[M>>>16&255]<<16|a[M>>>8&255]<<8|a[M&255],M^=y[N/k|0]<<24),_[N]=_[N-k]^M}for(var x=this._invKeySchedule=[],v=0;v<I;v++){var N=I-v;if(v%4)var M=_[N];else var M=_[N-4];v<4||N<=4?x[v]=M:x[v]=l[a[M>>>24]]^p[a[M>>>16&255]]^m[a[M>>>8&255]]^g[a[M&255]]}}},encryptBlock:function(w,S){this._doCryptBlock(w,S,this._keySchedule,d,c,u,h,a)},decryptBlock:function(w,S){var k=w[S+1];w[S+1]=w[S+3],w[S+3]=k,this._doCryptBlock(w,S,this._invKeySchedule,l,p,m,g,o);var k=w[S+1];w[S+1]=w[S+3],w[S+3]=k},_doCryptBlock:function(w,S,k,T,I,_,N,M){for(var x=this._nRounds,v=w[S]^k[0],O=w[S+1]^k[1],A=w[S+2]^k[2],V=w[S+3]^k[3],q=4,R=1;R<x;R++){var H=T[v>>>24]^I[O>>>16&255]^_[A>>>8&255]^N[V&255]^k[q++],F=T[O>>>24]^I[A>>>16&255]^_[V>>>8&255]^N[v&255]^k[q++],P=T[A>>>24]^I[V>>>16&255]^_[v>>>8&255]^N[O&255]^k[q++],E=T[V>>>24]^I[v>>>16&255]^_[O>>>8&255]^N[A&255]^k[q++];v=H,O=F,A=P,V=E}var H=(M[v>>>24]<<24|M[O>>>16&255]<<16|M[A>>>8&255]<<8|M[V&255])^k[q++],F=(M[O>>>24]<<24|M[A>>>16&255]<<16|M[V>>>8&255]<<8|M[v&255])^k[q++],P=(M[A>>>24]<<24|M[V>>>16&255]<<16|M[v>>>8&255]<<8|M[O&255])^k[q++],E=(M[V>>>24]<<24|M[v>>>16&255]<<16|M[O>>>8&255]<<8|M[A&255])^k[q++];w[S]=H,w[S+1]=F,w[S+2]=P,w[S+3]=E},keySize:256/32});s.AES=n._createHelper(b)}(),function(){var s=t,i=s.lib,n=i.WordArray,r=i.BlockCipher,a=s.algo,o=[57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4],d=[14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32],c=[1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28],u=[{0:8421888,268435456:32768,536870912:8421378,805306368:2,1073741824:512,1342177280:8421890,1610612736:8389122,1879048192:8388608,2147483648:514,2415919104:8389120,2684354560:33280,2952790016:8421376,3221225472:32770,3489660928:8388610,3758096384:0,4026531840:33282,134217728:0,402653184:8421890,671088640:33282,939524096:32768,1207959552:8421888,1476395008:512,1744830464:8421378,2013265920:2,2281701376:8389120,2550136832:33280,2818572288:8421376,3087007744:8389122,3355443200:8388610,3623878656:32770,3892314112:514,4160749568:8388608,1:32768,268435457:2,536870913:8421888,805306369:8388608,1073741825:8421378,1342177281:33280,1610612737:512,1879048193:8389122,2147483649:8421890,2415919105:8421376,2684354561:8388610,2952790017:33282,3221225473:514,3489660929:8389120,3758096385:32770,4026531841:0,134217729:8421890,402653185:8421376,671088641:8388608,939524097:512,1207959553:32768,1476395009:8388610,1744830465:2,2013265921:33282,2281701377:32770,2550136833:8389122,2818572289:514,3087007745:8421888,3355443201:8389120,3623878657:0,3892314113:33280,4160749569:8421378},{0:1074282512,16777216:16384,33554432:524288,50331648:1074266128,67108864:1073741840,83886080:1074282496,100663296:1073758208,117440512:16,134217728:540672,150994944:1073758224,167772160:1073741824,184549376:540688,201326592:524304,218103808:0,234881024:16400,251658240:1074266112,8388608:1073758208,25165824:540688,41943040:16,58720256:1073758224,75497472:1074282512,92274688:1073741824,109051904:524288,125829120:1074266128,142606336:524304,159383552:0,176160768:16384,192937984:1074266112,209715200:1073741840,226492416:540672,243269632:1074282496,260046848:16400,268435456:0,285212672:1074266128,301989888:1073758224,318767104:1074282496,335544320:1074266112,352321536:16,369098752:540688,385875968:16384,402653184:16400,419430400:524288,436207616:524304,452984832:1073741840,469762048:540672,486539264:1073758208,503316480:1073741824,520093696:1074282512,276824064:540688,293601280:524288,310378496:1074266112,327155712:16384,343932928:1073758208,360710144:1074282512,377487360:16,394264576:1073741824,411041792:1074282496,427819008:1073741840,444596224:1073758224,461373440:524304,478150656:0,494927872:16400,511705088:1074266128,528482304:540672},{0:260,1048576:0,2097152:67109120,3145728:65796,4194304:65540,5242880:67108868,6291456:67174660,7340032:67174400,8388608:67108864,9437184:67174656,10485760:65792,11534336:67174404,12582912:67109124,13631488:65536,14680064:4,15728640:256,524288:67174656,1572864:67174404,2621440:0,3670016:67109120,4718592:67108868,5767168:65536,6815744:65540,7864320:260,8912896:4,9961472:256,11010048:67174400,12058624:65796,13107200:65792,14155776:67109124,15204352:67174660,16252928:67108864,16777216:67174656,17825792:65540,18874368:65536,19922944:67109120,20971520:256,22020096:67174660,23068672:67108868,24117248:0,25165824:67109124,26214400:67108864,27262976:4,28311552:65792,29360128:67174400,30408704:260,31457280:65796,32505856:67174404,17301504:67108864,18350080:260,19398656:67174656,20447232:0,21495808:65540,22544384:67109120,23592960:256,24641536:67174404,25690112:65536,26738688:67174660,27787264:65796,28835840:67108868,29884416:67109124,30932992:67174400,31981568:4,33030144:65792},{0:2151682048,65536:2147487808,131072:4198464,196608:2151677952,262144:0,327680:4198400,393216:2147483712,458752:4194368,524288:2147483648,589824:4194304,655360:64,720896:2147487744,786432:2151678016,851968:4160,917504:4096,983040:2151682112,32768:2147487808,98304:64,163840:2151678016,229376:2147487744,294912:4198400,360448:2151682112,425984:0,491520:2151677952,557056:4096,622592:2151682048,688128:4194304,753664:4160,819200:2147483648,884736:4194368,950272:4198464,1015808:2147483712,1048576:4194368,1114112:4198400,1179648:2147483712,1245184:0,1310720:4160,1376256:2151678016,1441792:2151682048,1507328:2147487808,1572864:2151682112,1638400:2147483648,1703936:2151677952,1769472:4198464,1835008:2147487744,1900544:4194304,1966080:64,2031616:4096,1081344:2151677952,1146880:2151682112,1212416:0,1277952:4198400,1343488:4194368,1409024:2147483648,1474560:2147487808,1540096:64,1605632:2147483712,1671168:4096,1736704:2147487744,1802240:2151678016,1867776:4160,1933312:2151682048,1998848:4194304,2064384:4198464},{0:128,4096:17039360,8192:262144,12288:536870912,16384:537133184,20480:16777344,24576:553648256,28672:262272,32768:16777216,36864:537133056,40960:536871040,45056:553910400,49152:553910272,53248:0,57344:17039488,61440:553648128,2048:17039488,6144:553648256,10240:128,14336:17039360,18432:262144,22528:537133184,26624:553910272,30720:536870912,34816:537133056,38912:0,43008:553910400,47104:16777344,51200:536871040,55296:553648128,59392:16777216,63488:262272,65536:262144,69632:128,73728:536870912,77824:553648256,81920:16777344,86016:553910272,90112:537133184,94208:16777216,98304:553910400,102400:553648128,106496:17039360,110592:537133056,114688:262272,118784:536871040,122880:0,126976:17039488,67584:553648256,71680:16777216,75776:17039360,79872:537133184,83968:536870912,88064:17039488,92160:128,96256:553910272,100352:262272,104448:553910400,108544:0,112640:553648128,116736:16777344,120832:262144,124928:537133056,129024:536871040},{0:268435464,256:8192,512:270532608,768:270540808,1024:268443648,1280:2097152,1536:2097160,1792:268435456,2048:0,2304:268443656,2560:2105344,2816:8,3072:270532616,3328:2105352,3584:8200,3840:270540800,128:270532608,384:270540808,640:8,896:2097152,1152:2105352,1408:268435464,1664:268443648,1920:8200,2176:2097160,2432:8192,2688:268443656,2944:270532616,3200:0,3456:270540800,3712:2105344,3968:268435456,4096:268443648,4352:270532616,4608:270540808,4864:8200,5120:2097152,5376:268435456,5632:268435464,5888:2105344,6144:2105352,6400:0,6656:8,6912:270532608,7168:8192,7424:268443656,7680:270540800,7936:2097160,4224:8,4480:2105344,4736:2097152,4992:268435464,5248:268443648,5504:8200,5760:270540808,6016:270532608,6272:270540800,6528:270532616,6784:8192,7040:2105352,7296:2097160,7552:0,7808:268435456,8064:268443656},{0:1048576,16:33555457,32:1024,48:1049601,64:34604033,80:0,96:1,112:34603009,128:33555456,144:1048577,160:33554433,176:34604032,192:34603008,208:1025,224:1049600,240:33554432,8:34603009,24:0,40:33555457,56:34604032,72:1048576,88:33554433,104:33554432,120:1025,136:1049601,152:33555456,168:34603008,184:1048577,200:1024,216:34604033,232:1,248:1049600,256:33554432,272:1048576,288:33555457,304:34603009,320:1048577,336:33555456,352:34604032,368:1049601,384:1025,400:34604033,416:1049600,432:1,448:0,464:34603008,480:33554433,496:1024,264:1049600,280:33555457,296:34603009,312:1,328:33554432,344:1048576,360:1025,376:34604032,392:33554433,408:34603008,424:0,440:34604033,456:1049601,472:1024,488:33555456,504:1048577},{0:134219808,1:131072,2:134217728,3:32,4:131104,5:134350880,6:134350848,7:2048,8:134348800,9:134219776,10:133120,11:134348832,12:2080,13:0,14:134217760,15:133152,2147483648:2048,2147483649:134350880,2147483650:134219808,2147483651:134217728,2147483652:134348800,2147483653:133120,2147483654:133152,2147483655:32,2147483656:134217760,2147483657:2080,2147483658:131104,2147483659:134350848,2147483660:0,2147483661:134348832,2147483662:134219776,2147483663:131072,16:133152,17:134350848,18:32,19:2048,20:134219776,21:134217760,22:134348832,23:131072,24:0,25:131104,26:134348800,27:134219808,28:134350880,29:133120,30:2080,31:134217728,2147483664:131072,2147483665:2048,2147483666:134348832,2147483667:133152,2147483668:32,2147483669:134348800,2147483670:134217728,2147483671:134219808,2147483672:134350880,2147483673:134217760,2147483674:134219776,2147483675:0,2147483676:133120,2147483677:2080,2147483678:131104,2147483679:134350848}],h=[4160749569,528482304,33030144,2064384,129024,8064,504,2147483679],l=a.DES=r.extend({_doReset:function(){for(var y=this._key,b=y.words,w=[],S=0;S<56;S++){var k=o[S]-1;w[S]=b[k>>>5]>>>31-k%32&1}for(var T=this._subKeys=[],I=0;I<16;I++){for(var _=T[I]=[],N=c[I],S=0;S<24;S++)_[S/6|0]|=w[(d[S]-1+N)%28]<<31-S%6,_[4+(S/6|0)]|=w[28+(d[S+24]-1+N)%28]<<31-S%6;_[0]=_[0]<<1|_[0]>>>31;for(var S=1;S<7;S++)_[S]=_[S]>>>(S-1)*4+3;_[7]=_[7]<<5|_[7]>>>27}for(var M=this._invSubKeys=[],S=0;S<16;S++)M[S]=T[15-S]},encryptBlock:function(y,b){this._doCryptBlock(y,b,this._subKeys)},decryptBlock:function(y,b){this._doCryptBlock(y,b,this._invSubKeys)},_doCryptBlock:function(y,b,w){this._lBlock=y[b],this._rBlock=y[b+1],p.call(this,4,252645135),p.call(this,16,65535),m.call(this,2,858993459),m.call(this,8,16711935),p.call(this,1,1431655765);for(var S=0;S<16;S++){for(var k=w[S],T=this._lBlock,I=this._rBlock,_=0,N=0;N<8;N++)_|=u[N][((I^k[N])&h[N])>>>0];this._lBlock=I,this._rBlock=T^_}var M=this._lBlock;this._lBlock=this._rBlock,this._rBlock=M,p.call(this,1,1431655765),m.call(this,8,16711935),m.call(this,2,858993459),p.call(this,16,65535),p.call(this,4,252645135),y[b]=this._lBlock,y[b+1]=this._rBlock},keySize:64/32,ivSize:64/32,blockSize:64/32});function p(y,b){var w=(this._lBlock>>>y^this._rBlock)&b;this._rBlock^=w,this._lBlock^=w<<y}function m(y,b){var w=(this._rBlock>>>y^this._lBlock)&b;this._lBlock^=w,this._rBlock^=w<<y}s.DES=r._createHelper(l);var g=a.TripleDES=r.extend({_doReset:function(){var y=this._key,b=y.words;this._des1=l.createEncryptor(n.create(b.slice(0,2))),this._des2=l.createEncryptor(n.create(b.slice(2,4))),this._des3=l.createEncryptor(n.create(b.slice(4,6)))},encryptBlock:function(y,b){this._des1.encryptBlock(y,b),this._des2.decryptBlock(y,b),this._des3.encryptBlock(y,b)},decryptBlock:function(y,b){this._des3.decryptBlock(y,b),this._des2.encryptBlock(y,b),this._des1.decryptBlock(y,b)},keySize:192/32,ivSize:64/32,blockSize:64/32});s.TripleDES=r._createHelper(g)}(),function(){var s=t,i=s.lib,n=i.StreamCipher,r=s.algo,a=r.RC4=n.extend({_doReset:function(){for(var c=this._key,u=c.words,h=c.sigBytes,l=this._S=[],p=0;p<256;p++)l[p]=p;for(var p=0,m=0;p<256;p++){var g=p%h,y=u[g>>>2]>>>24-g%4*8&255;m=(m+l[p]+y)%256;var b=l[p];l[p]=l[m],l[m]=b}this._i=this._j=0},_doProcessBlock:function(c,u){c[u]^=o.call(this)},keySize:256/32,ivSize:0});function o(){for(var c=this._S,u=this._i,h=this._j,l=0,p=0;p<4;p++){u=(u+1)%256,h=(h+c[u])%256;var m=c[u];c[u]=c[h],c[h]=m,l|=c[(c[u]+c[h])%256]<<24-p*8}return this._i=u,this._j=h,l}s.RC4=n._createHelper(a);var d=r.RC4Drop=a.extend({cfg:a.cfg.extend({drop:192}),_doReset:function(){a._doReset.call(this);for(var c=this.cfg.drop;c>0;c--)o.call(this)}});s.RC4Drop=n._createHelper(d)}();/** @preserve
 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
 * derived from CryptoJS.mode.CTR
 * Jan Hruby jhruby.web@gmail.com
 */return t.mode.CTRGladman=function(){var s=t.lib.BlockCipherMode.extend();function i(a){if((a>>24&255)===255){var o=a>>16&255,d=a>>8&255,c=a&255;o===255?(o=0,d===255?(d=0,c===255?c=0:++c):++d):++o,a=0,a+=o<<16,a+=d<<8,a+=c}else a+=1<<24;return a}function n(a){return(a[0]=i(a[0]))===0&&(a[1]=i(a[1])),a}var r=s.Encryptor=s.extend({processBlock:function(a,o){var d=this._cipher,c=d.blockSize,u=this._iv,h=this._counter;u&&(h=this._counter=u.slice(0),this._iv=void 0),n(h);var l=h.slice(0);d.encryptBlock(l,0);for(var p=0;p<c;p++)a[o+p]^=l[p]}});return s.Decryptor=r,s}(),function(){var s=t,i=s.lib,n=i.StreamCipher,r=s.algo,a=[],o=[],d=[],c=r.Rabbit=n.extend({_doReset:function(){for(var h=this._key.words,l=this.cfg.iv,p=0;p<4;p++)h[p]=(h[p]<<8|h[p]>>>24)&16711935|(h[p]<<24|h[p]>>>8)&4278255360;var m=this._X=[h[0],h[3]<<16|h[2]>>>16,h[1],h[0]<<16|h[3]>>>16,h[2],h[1]<<16|h[0]>>>16,h[3],h[2]<<16|h[1]>>>16],g=this._C=[h[2]<<16|h[2]>>>16,h[0]&4294901760|h[1]&65535,h[3]<<16|h[3]>>>16,h[1]&4294901760|h[2]&65535,h[0]<<16|h[0]>>>16,h[2]&4294901760|h[3]&65535,h[1]<<16|h[1]>>>16,h[3]&4294901760|h[0]&65535];this._b=0;for(var p=0;p<4;p++)u.call(this);for(var p=0;p<8;p++)g[p]^=m[p+4&7];if(l){var y=l.words,b=y[0],w=y[1],S=(b<<8|b>>>24)&16711935|(b<<24|b>>>8)&4278255360,k=(w<<8|w>>>24)&16711935|(w<<24|w>>>8)&4278255360,T=S>>>16|k&4294901760,I=k<<16|S&65535;g[0]^=S,g[1]^=T,g[2]^=k,g[3]^=I,g[4]^=S,g[5]^=T,g[6]^=k,g[7]^=I;for(var p=0;p<4;p++)u.call(this)}},_doProcessBlock:function(h,l){var p=this._X;u.call(this),a[0]=p[0]^p[5]>>>16^p[3]<<16,a[1]=p[2]^p[7]>>>16^p[5]<<16,a[2]=p[4]^p[1]>>>16^p[7]<<16,a[3]=p[6]^p[3]>>>16^p[1]<<16;for(var m=0;m<4;m++)a[m]=(a[m]<<8|a[m]>>>24)&16711935|(a[m]<<24|a[m]>>>8)&4278255360,h[l+m]^=a[m]},blockSize:128/32,ivSize:64/32});function u(){for(var h=this._X,l=this._C,p=0;p<8;p++)o[p]=l[p];l[0]=l[0]+1295307597+this._b|0,l[1]=l[1]+3545052371+(l[0]>>>0<o[0]>>>0?1:0)|0,l[2]=l[2]+886263092+(l[1]>>>0<o[1]>>>0?1:0)|0,l[3]=l[3]+1295307597+(l[2]>>>0<o[2]>>>0?1:0)|0,l[4]=l[4]+3545052371+(l[3]>>>0<o[3]>>>0?1:0)|0,l[5]=l[5]+886263092+(l[4]>>>0<o[4]>>>0?1:0)|0,l[6]=l[6]+1295307597+(l[5]>>>0<o[5]>>>0?1:0)|0,l[7]=l[7]+3545052371+(l[6]>>>0<o[6]>>>0?1:0)|0,this._b=l[7]>>>0<o[7]>>>0?1:0;for(var p=0;p<8;p++){var m=h[p]+l[p],g=m&65535,y=m>>>16,b=((g*g>>>17)+g*y>>>15)+y*y,w=((m&4294901760)*m|0)+((m&65535)*m|0);d[p]=b^w}h[0]=d[0]+(d[7]<<16|d[7]>>>16)+(d[6]<<16|d[6]>>>16)|0,h[1]=d[1]+(d[0]<<8|d[0]>>>24)+d[7]|0,h[2]=d[2]+(d[1]<<16|d[1]>>>16)+(d[0]<<16|d[0]>>>16)|0,h[3]=d[3]+(d[2]<<8|d[2]>>>24)+d[1]|0,h[4]=d[4]+(d[3]<<16|d[3]>>>16)+(d[2]<<16|d[2]>>>16)|0,h[5]=d[5]+(d[4]<<8|d[4]>>>24)+d[3]|0,h[6]=d[6]+(d[5]<<16|d[5]>>>16)+(d[4]<<16|d[4]>>>16)|0,h[7]=d[7]+(d[6]<<8|d[6]>>>24)+d[5]|0}s.Rabbit=n._createHelper(c)}(),t.mode.CTR=function(){var s=t.lib.BlockCipherMode.extend(),i=s.Encryptor=s.extend({processBlock:function(n,r){var a=this._cipher,o=a.blockSize,d=this._iv,c=this._counter;d&&(c=this._counter=d.slice(0),this._iv=void 0);var u=c.slice(0);a.encryptBlock(u,0),c[o-1]=c[o-1]+1|0;for(var h=0;h<o;h++)n[r+h]^=u[h]}});return s.Decryptor=i,s}(),function(){var s=t,i=s.lib,n=i.StreamCipher,r=s.algo,a=[],o=[],d=[],c=r.RabbitLegacy=n.extend({_doReset:function(){var h=this._key.words,l=this.cfg.iv,p=this._X=[h[0],h[3]<<16|h[2]>>>16,h[1],h[0]<<16|h[3]>>>16,h[2],h[1]<<16|h[0]>>>16,h[3],h[2]<<16|h[1]>>>16],m=this._C=[h[2]<<16|h[2]>>>16,h[0]&4294901760|h[1]&65535,h[3]<<16|h[3]>>>16,h[1]&4294901760|h[2]&65535,h[0]<<16|h[0]>>>16,h[2]&4294901760|h[3]&65535,h[1]<<16|h[1]>>>16,h[3]&4294901760|h[0]&65535];this._b=0;for(var g=0;g<4;g++)u.call(this);for(var g=0;g<8;g++)m[g]^=p[g+4&7];if(l){var y=l.words,b=y[0],w=y[1],S=(b<<8|b>>>24)&16711935|(b<<24|b>>>8)&4278255360,k=(w<<8|w>>>24)&16711935|(w<<24|w>>>8)&4278255360,T=S>>>16|k&4294901760,I=k<<16|S&65535;m[0]^=S,m[1]^=T,m[2]^=k,m[3]^=I,m[4]^=S,m[5]^=T,m[6]^=k,m[7]^=I;for(var g=0;g<4;g++)u.call(this)}},_doProcessBlock:function(h,l){var p=this._X;u.call(this),a[0]=p[0]^p[5]>>>16^p[3]<<16,a[1]=p[2]^p[7]>>>16^p[5]<<16,a[2]=p[4]^p[1]>>>16^p[7]<<16,a[3]=p[6]^p[3]>>>16^p[1]<<16;for(var m=0;m<4;m++)a[m]=(a[m]<<8|a[m]>>>24)&16711935|(a[m]<<24|a[m]>>>8)&4278255360,h[l+m]^=a[m]},blockSize:128/32,ivSize:64/32});function u(){for(var h=this._X,l=this._C,p=0;p<8;p++)o[p]=l[p];l[0]=l[0]+1295307597+this._b|0,l[1]=l[1]+3545052371+(l[0]>>>0<o[0]>>>0?1:0)|0,l[2]=l[2]+886263092+(l[1]>>>0<o[1]>>>0?1:0)|0,l[3]=l[3]+1295307597+(l[2]>>>0<o[2]>>>0?1:0)|0,l[4]=l[4]+3545052371+(l[3]>>>0<o[3]>>>0?1:0)|0,l[5]=l[5]+886263092+(l[4]>>>0<o[4]>>>0?1:0)|0,l[6]=l[6]+1295307597+(l[5]>>>0<o[5]>>>0?1:0)|0,l[7]=l[7]+3545052371+(l[6]>>>0<o[6]>>>0?1:0)|0,this._b=l[7]>>>0<o[7]>>>0?1:0;for(var p=0;p<8;p++){var m=h[p]+l[p],g=m&65535,y=m>>>16,b=((g*g>>>17)+g*y>>>15)+y*y,w=((m&4294901760)*m|0)+((m&65535)*m|0);d[p]=b^w}h[0]=d[0]+(d[7]<<16|d[7]>>>16)+(d[6]<<16|d[6]>>>16)|0,h[1]=d[1]+(d[0]<<8|d[0]>>>24)+d[7]|0,h[2]=d[2]+(d[1]<<16|d[1]>>>16)+(d[0]<<16|d[0]>>>16)|0,h[3]=d[3]+(d[2]<<8|d[2]>>>24)+d[1]|0,h[4]=d[4]+(d[3]<<16|d[3]>>>16)+(d[2]<<16|d[2]>>>16)|0,h[5]=d[5]+(d[4]<<8|d[4]>>>24)+d[3]|0,h[6]=d[6]+(d[5]<<16|d[5]>>>16)+(d[4]<<16|d[4]>>>16)|0,h[7]=d[7]+(d[6]<<8|d[6]>>>24)+d[5]|0}s.RabbitLegacy=n._createHelper(c)}(),t.pad.ZeroPadding={pad:function(s,i){var n=i*4;s.clamp(),s.sigBytes+=n-(s.sigBytes%n||n)},unpad:function(s){for(var i=s.words,n=s.sigBytes-1;!(i[n>>>2]>>>24-n%4*8&255);)n--;s.sigBytes=n+1}},t})})(_d);var Cp=Object.prototype.hasOwnProperty,sd=Array.isArray,Nn=function(){for(var f=[],e=0;e<256;++e)f.push("%"+((e<16?"0":"")+e.toString(16)).toUpperCase());return f}(),QB=function(e){for(;e.length>1;){var t=e.pop(),s=t.obj[t.prop];if(sd(s)){for(var i=[],n=0;n<s.length;++n)typeof s[n]<"u"&&i.push(s[n]);t.obj[t.prop]=i}}},Fx=function(e,t){for(var s=t&&t.plainObjects?Object.create(null):{},i=0;i<e.length;++i)typeof e[i]<"u"&&(s[i]=e[i]);return s},ZB=function f(e,t,s){if(!t)return e;if(typeof t!="object"){if(sd(e))e.push(t);else if(e&&typeof e=="object")(s&&(s.plainObjects||s.allowPrototypes)||!Cp.call(Object.prototype,t))&&(e[t]=!0);else return[e,t];return e}if(!e||typeof e!="object")return[e].concat(t);var i=e;return sd(e)&&!sd(t)&&(i=Fx(e,s)),sd(e)&&sd(t)?(t.forEach(function(n,r){if(Cp.call(e,r)){var a=e[r];a&&typeof a=="object"&&n&&typeof n=="object"?e[r]=f(a,n,s):e.push(n)}else e[r]=n}),e):Object.keys(t).reduce(function(n,r){var a=t[r];return Cp.call(n,r)?n[r]=f(n[r],a,s):n[r]=a,n},i)},JB=function(e,t){return Object.keys(t).reduce(function(s,i){return s[i]=t[i],s},e)},eN=function(f,e,t){var s=f.replace(/\+/g," ");if(t==="iso-8859-1")return s.replace(/%[0-9a-f]{2}/gi,unescape);try{return decodeURIComponent(s)}catch{return s}},tN=function(e,t,s){if(e.length===0)return e;var i=typeof e=="string"?e:String(e);if(s==="iso-8859-1")return escape(i).replace(/%u[0-9a-f]{4}/gi,function(o){return"%26%23"+parseInt(o.slice(2),16)+"%3B"});for(var n="",r=0;r<i.length;++r){var a=i.charCodeAt(r);if(a===45||a===46||a===95||a===126||a>=48&&a<=57||a>=65&&a<=90||a>=97&&a<=122){n+=i.charAt(r);continue}if(a<128){n=n+Nn[a];continue}if(a<2048){n=n+(Nn[192|a>>6]+Nn[128|a&63]);continue}if(a<55296||a>=57344){n=n+(Nn[224|a>>12]+Nn[128|a>>6&63]+Nn[128|a&63]);continue}r+=1,a=65536+((a&1023)<<10|i.charCodeAt(r)&1023),n+=Nn[240|a>>18]+Nn[128|a>>12&63]+Nn[128|a>>6&63]+Nn[128|a&63]}return n},sN=function(e){for(var t=[{obj:{o:e},prop:"o"}],s=[],i=0;i<t.length;++i)for(var n=t[i],r=n.obj[n.prop],a=Object.keys(r),o=0;o<a.length;++o){var d=a[o],c=r[d];typeof c=="object"&&c!==null&&s.indexOf(c)===-1&&(t.push({obj:r,prop:d}),s.push(c))}return QB(t),e},iN=function(e){return Object.prototype.toString.call(e)==="[object RegExp]"},nN=function(e){return!e||typeof e!="object"?!1:!!(e.constructor&&e.constructor.isBuffer&&e.constructor.isBuffer(e))},rN=function(e,t){return[].concat(e,t)},Dx={arrayToObject:Fx,assign:JB,combine:rN,compact:sN,decode:eN,encode:tN,isBuffer:nN,isRegExp:iN,merge:ZB},aN=String.prototype.replace,oN=/%20/g,Hx={default:"RFC3986",formatters:{RFC1738:function(f){return aN.call(f,oN,"+")},RFC3986:function(f){return f}},RFC1738:"RFC1738",RFC3986:"RFC3986"},Gx=Dx,ou=Hx,dN=Object.prototype.hasOwnProperty,Zw={brackets:function(e){return e+"[]"},comma:"comma",indices:function(e,t){return e+"["+t+"]"},repeat:function(e){return e}},ud=Array.isArray,cN=Array.prototype.push,oy=function(f,e){cN.apply(f,ud(e)?e:[e])},uN=Date.prototype.toISOString,Zs={addQueryPrefix:!1,allowDots:!1,charset:"utf-8",charsetSentinel:!1,delimiter:"&",encode:!0,encoder:Gx.encode,encodeValuesOnly:!1,formatter:ou.formatters[ou.default],indices:!1,serializeDate:function(e){return uN.call(e)},skipNulls:!1,strictNullHandling:!1},fN=function f(e,t,s,i,n,r,a,o,d,c,u,h,l){var p=e;if(typeof a=="function"?p=a(t,p):p instanceof Date?p=c(p):s==="comma"&&ud(p)&&(p=p.join(",")),p===null){if(i)return r&&!h?r(t,Zs.encoder,l):t;p=""}if(typeof p=="string"||typeof p=="number"||typeof p=="boolean"||Gx.isBuffer(p)){if(r){var m=h?t:r(t,Zs.encoder,l);return[u(m)+"="+u(r(p,Zs.encoder,l))]}return[u(t)+"="+u(String(p))]}var g=[];if(typeof p>"u")return g;var y;if(ud(a))y=a;else{var b=Object.keys(p);y=o?b.sort(o):b}for(var w=0;w<y.length;++w){var S=y[w];n&&p[S]===null||(ud(p)?oy(g,f(p[S],typeof s=="function"?s(t,S):t,s,i,n,r,a,o,d,c,u,h,l)):oy(g,f(p[S],t+(d?"."+S:"["+S+"]"),s,i,n,r,a,o,d,c,u,h,l)))}return g},hN=function(e){if(!e)return Zs;if(e.encoder!==null&&e.encoder!==void 0&&typeof e.encoder!="function")throw new TypeError("Encoder has to be a function.");var t=e.charset||Zs.charset;if(typeof e.charset<"u"&&e.charset!=="utf-8"&&e.charset!=="iso-8859-1")throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");var s=ou.default;if(typeof e.format<"u"){if(!dN.call(ou.formatters,e.format))throw new TypeError("Unknown format option provided.");s=e.format}var i=ou.formatters[s],n=Zs.filter;return(typeof e.filter=="function"||ud(e.filter))&&(n=e.filter),{addQueryPrefix:typeof e.addQueryPrefix=="boolean"?e.addQueryPrefix:Zs.addQueryPrefix,allowDots:typeof e.allowDots>"u"?Zs.allowDots:!!e.allowDots,charset:t,charsetSentinel:typeof e.charsetSentinel=="boolean"?e.charsetSentinel:Zs.charsetSentinel,delimiter:typeof e.delimiter>"u"?Zs.delimiter:e.delimiter,encode:typeof e.encode=="boolean"?e.encode:Zs.encode,encoder:typeof e.encoder=="function"?e.encoder:Zs.encoder,encodeValuesOnly:typeof e.encodeValuesOnly=="boolean"?e.encodeValuesOnly:Zs.encodeValuesOnly,filter:n,formatter:i,serializeDate:typeof e.serializeDate=="function"?e.serializeDate:Zs.serializeDate,skipNulls:typeof e.skipNulls=="boolean"?e.skipNulls:Zs.skipNulls,sort:typeof e.sort=="function"?e.sort:null,strictNullHandling:typeof e.strictNullHandling=="boolean"?e.strictNullHandling:Zs.strictNullHandling}},lN=function(f,e){var t=f,s=hN(e),i,n;typeof s.filter=="function"?(n=s.filter,t=n("",t)):ud(s.filter)&&(n=s.filter,i=n);var r=[];if(typeof t!="object"||t===null)return"";var a;e&&e.arrayFormat in Zw?a=e.arrayFormat:e&&"indices"in e?a=e.indices?"indices":"repeat":a="indices";var o=Zw[a];i||(i=Object.keys(t)),s.sort&&i.sort(s.sort);for(var d=0;d<i.length;++d){var c=i[d];s.skipNulls&&t[c]===null||oy(r,fN(t[c],c,o,s.strictNullHandling,s.skipNulls,s.encode?s.encoder:null,s.filter,s.sort,s.allowDots,s.serializeDate,s.formatter,s.encodeValuesOnly,s.charset))}var u=r.join(s.delimiter),h=s.addQueryPrefix===!0?"?":"";return s.charsetSentinel&&(s.charset==="iso-8859-1"?h+="utf8=%26%2310003%3B&":h+="utf8=%E2%9C%93&"),u.length>0?h+u:""},wu=Dx,dy=Object.prototype.hasOwnProperty,Us={allowDots:!1,allowPrototypes:!1,arrayLimit:20,charset:"utf-8",charsetSentinel:!1,comma:!1,decoder:wu.decode,delimiter:"&",depth:5,ignoreQueryPrefix:!1,interpretNumericEntities:!1,parameterLimit:1e3,parseArrays:!0,plainObjects:!1,strictNullHandling:!1},pN=function(f){return f.replace(/&#(\d+);/g,function(e,t){return String.fromCharCode(parseInt(t,10))})},mN="utf8=%26%2310003%3B",gN="utf8=%E2%9C%93",yN=function(e,t){var s={},i=t.ignoreQueryPrefix?e.replace(/^\?/,""):e,n=t.parameterLimit===1/0?void 0:t.parameterLimit,r=i.split(t.delimiter,n),a=-1,o,d=t.charset;if(t.charsetSentinel)for(o=0;o<r.length;++o)r[o].indexOf("utf8=")===0&&(r[o]===gN?d="utf-8":r[o]===mN&&(d="iso-8859-1"),a=o,o=r.length);for(o=0;o<r.length;++o)if(o!==a){var c=r[o],u=c.indexOf("]="),h=u===-1?c.indexOf("="):u+1,l,p;h===-1?(l=t.decoder(c,Us.decoder,d),p=t.strictNullHandling?null:""):(l=t.decoder(c.slice(0,h),Us.decoder,d),p=t.decoder(c.slice(h+1),Us.decoder,d)),p&&t.interpretNumericEntities&&d==="iso-8859-1"&&(p=pN(p)),p&&t.comma&&p.indexOf(",")>-1&&(p=p.split(",")),dy.call(s,l)?s[l]=wu.combine(s[l],p):s[l]=p}return s},bN=function(f,e,t){for(var s=e,i=f.length-1;i>=0;--i){var n,r=f[i];if(r==="[]"&&t.parseArrays)n=[].concat(s);else{n=t.plainObjects?Object.create(null):{};var a=r.charAt(0)==="["&&r.charAt(r.length-1)==="]"?r.slice(1,-1):r,o=parseInt(a,10);!t.parseArrays&&a===""?n={0:s}:!isNaN(o)&&r!==a&&String(o)===a&&o>=0&&t.parseArrays&&o<=t.arrayLimit?(n=[],n[o]=s):n[a]=s}s=n}return s},wN=function(e,t,s){if(!!e){var i=s.allowDots?e.replace(/\.([^.[]+)/g,"[$1]"):e,n=/(\[[^[\]]*])/,r=/(\[[^[\]]*])/g,a=n.exec(i),o=a?i.slice(0,a.index):i,d=[];if(o){if(!s.plainObjects&&dy.call(Object.prototype,o)&&!s.allowPrototypes)return;d.push(o)}for(var c=0;(a=r.exec(i))!==null&&c<s.depth;){if(c+=1,!s.plainObjects&&dy.call(Object.prototype,a[1].slice(1,-1))&&!s.allowPrototypes)return;d.push(a[1])}return a&&d.push("["+i.slice(a.index)+"]"),bN(d,t,s)}},SN=function(e){if(!e)return Us;if(e.decoder!==null&&e.decoder!==void 0&&typeof e.decoder!="function")throw new TypeError("Decoder has to be a function.");if(typeof e.charset<"u"&&e.charset!=="utf-8"&&e.charset!=="iso-8859-1")throw new Error("The charset option must be either utf-8, iso-8859-1, or undefined");var t=typeof e.charset>"u"?Us.charset:e.charset;return{allowDots:typeof e.allowDots>"u"?Us.allowDots:!!e.allowDots,allowPrototypes:typeof e.allowPrototypes=="boolean"?e.allowPrototypes:Us.allowPrototypes,arrayLimit:typeof e.arrayLimit=="number"?e.arrayLimit:Us.arrayLimit,charset:t,charsetSentinel:typeof e.charsetSentinel=="boolean"?e.charsetSentinel:Us.charsetSentinel,comma:typeof e.comma=="boolean"?e.comma:Us.comma,decoder:typeof e.decoder=="function"?e.decoder:Us.decoder,delimiter:typeof e.delimiter=="string"||wu.isRegExp(e.delimiter)?e.delimiter:Us.delimiter,depth:typeof e.depth=="number"?e.depth:Us.depth,ignoreQueryPrefix:e.ignoreQueryPrefix===!0,interpretNumericEntities:typeof e.interpretNumericEntities=="boolean"?e.interpretNumericEntities:Us.interpretNumericEntities,parameterLimit:typeof e.parameterLimit=="number"?e.parameterLimit:Us.parameterLimit,parseArrays:e.parseArrays!==!1,plainObjects:typeof e.plainObjects=="boolean"?e.plainObjects:Us.plainObjects,strictNullHandling:typeof e.strictNullHandling=="boolean"?e.strictNullHandling:Us.strictNullHandling}},kN=function(f,e){var t=SN(e);if(f===""||f===null||typeof f>"u")return t.plainObjects?Object.create(null):{};for(var s=typeof f=="string"?yN(f,t):f,i=t.plainObjects?Object.create(null):{},n=Object.keys(s),r=0;r<n.length;++r){var a=n[r],o=wN(a,s[a],t);i=wu.merge(i,o,t)}return wu.compact(i)},vN=lN,TN=kN,ON=Hx,IN={formats:ON,parse:TN,stringify:vN},Fi={exports:{}};(function(f){(function(e,t){function s(x,v){if(!x)throw new Error(v||"Assertion failed")}function i(x,v){x.super_=v;var O=function(){};O.prototype=v.prototype,x.prototype=new O,x.prototype.constructor=x}function n(x,v,O){if(n.isBN(x))return x;this.negative=0,this.words=null,this.length=0,this.red=null,x!==null&&((v==="le"||v==="be")&&(O=v,v=10),this._init(x||0,v||10,O||"be"))}typeof e=="object"?e.exports=n:t.BN=n,n.BN=n,n.wordSize=26;var r;try{r=ul.Buffer}catch{}n.isBN=function(v){return v instanceof n?!0:v!==null&&typeof v=="object"&&v.constructor.wordSize===n.wordSize&&Array.isArray(v.words)},n.max=function(v,O){return v.cmp(O)>0?v:O},n.min=function(v,O){return v.cmp(O)<0?v:O},n.prototype._init=function(v,O,A){if(typeof v=="number")return this._initNumber(v,O,A);if(typeof v=="object")return this._initArray(v,O,A);O==="hex"&&(O=16),s(O===(O|0)&&O>=2&&O<=36),v=v.toString().replace(/\s+/g,"");var V=0;v[0]==="-"&&V++,O===16?this._parseHex(v,V):this._parseBase(v,O,V),v[0]==="-"&&(this.negative=1),this._strip(),A==="le"&&this._initArray(this.toArray(),O,A)},n.prototype._initNumber=function(v,O,A){v<0&&(this.negative=1,v=-v),v<67108864?(this.words=[v&67108863],this.length=1):v<4503599627370496?(this.words=[v&67108863,v/67108864&67108863],this.length=2):(s(v<9007199254740992),this.words=[v&67108863,v/67108864&67108863,1],this.length=3),A==="le"&&this._initArray(this.toArray(),O,A)},n.prototype._initArray=function(v,O,A){if(s(typeof v.length=="number"),v.length<=0)return this.words=[0],this.length=1,this;this.length=Math.ceil(v.length/3),this.words=new Array(this.length);for(var V=0;V<this.length;V++)this.words[V]=0;var q,R,H=0;if(A==="be")for(V=v.length-1,q=0;V>=0;V-=3)R=v[V]|v[V-1]<<8|v[V-2]<<16,this.words[q]|=R<<H&67108863,this.words[q+1]=R>>>26-H&67108863,H+=24,H>=26&&(H-=26,q++);else if(A==="le")for(V=0,q=0;V<v.length;V+=3)R=v[V]|v[V+1]<<8|v[V+2]<<16,this.words[q]|=R<<H&67108863,this.words[q+1]=R>>>26-H&67108863,H+=24,H>=26&&(H-=26,q++);return this._strip()};function a(x,v,O){for(var A=0,V=Math.min(x.length,O),q=0,R=v;R<V;R++){var H=x.charCodeAt(R)-48;A<<=4;var F;H>=49&&H<=54?F=H-49+10:H>=17&&H<=22?F=H-17+10:F=H,A|=F,q|=F}return s(!(q&240),"Invalid character in "+x),A}n.prototype._parseHex=function(v,O){this.length=Math.ceil((v.length-O)/6),this.words=new Array(this.length);for(var A=0;A<this.length;A++)this.words[A]=0;var V,q,R=0;for(A=v.length-6,V=0;A>=O;A-=6)q=a(v,A,A+6),this.words[V]|=q<<R&67108863,this.words[V+1]|=q>>>26-R&4194303,R+=24,R>=26&&(R-=26,V++);A+6!==O&&(q=a(v,O,A+6),this.words[V]|=q<<R&67108863,this.words[V+1]|=q>>>26-R&4194303),this._strip()};function o(x,v,O,A){for(var V=0,q=0,R=Math.min(x.length,O),H=v;H<R;H++){var F=x.charCodeAt(H)-48;V*=A,F>=49?q=F-49+10:F>=17?q=F-17+10:q=F,s(F>=0&&q<A,"Invalid character"),V+=q}return V}n.prototype._parseBase=function(v,O,A){this.words=[0],this.length=1;for(var V=0,q=1;q<=67108863;q*=O)V++;V--,q=q/O|0;for(var R=v.length-A,H=R%V,F=Math.min(R,R-H)+A,P=0,E=A;E<F;E+=V)P=o(v,E,E+V,O),this.imuln(q),this.words[0]+P<67108864?this.words[0]+=P:this._iaddn(P);if(H!==0){var j=1;for(P=o(v,E,v.length,O),E=0;E<H;E++)j*=O;this.imuln(j),this.words[0]+P<67108864?this.words[0]+=P:this._iaddn(P)}},n.prototype.copy=function(v){v.words=new Array(this.length);for(var O=0;O<this.length;O++)v.words[O]=this.words[O];v.length=this.length,v.negative=this.negative,v.red=this.red},n.prototype._move=function(v){v.words=this.words,v.length=this.length,v.negative=this.negative,v.red=this.red},n.prototype.clone=function(){var v=new n(null);return this.copy(v),v},n.prototype._expand=function(v){for(;this.length<v;)this.words[this.length++]=0;return this},n.prototype._strip=function(){for(;this.length>1&&this.words[this.length-1]===0;)this.length--;return this._normSign()},n.prototype._normSign=function(){return this.length===1&&this.words[0]===0&&(this.negative=0),this},typeof Symbol<"u"&&typeof Symbol.for=="function"?n.prototype[Symbol.for("nodejs.util.inspect.custom")]=d:n.prototype.inspect=d;function d(){return(this.red?"<BN-R: ":"<BN: ")+this.toString(16)+">"}var c=["","0","00","000","0000","00000","000000","0000000","00000000","000000000","0000000000","00000000000","000000000000","0000000000000","00000000000000","000000000000000","0000000000000000","00000000000000000","000000000000000000","0000000000000000000","00000000000000000000","000000000000000000000","0000000000000000000000","00000000000000000000000","000000000000000000000000","0000000000000000000000000"],u=[0,0,25,16,12,11,10,9,8,8,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],h=[0,0,33554432,43046721,16777216,48828125,60466176,40353607,16777216,43046721,1e7,19487171,35831808,62748517,7529536,11390625,16777216,24137569,34012224,47045881,64e6,4084101,5153632,6436343,7962624,9765625,11881376,14348907,17210368,20511149,243e5,28629151,33554432,39135393,45435424,52521875,60466176];n.prototype.toString=function(v,O){v=v||10,O=O|0||1;var A;if(v===16||v==="hex"){A="";for(var V=0,q=0,R=0;R<this.length;R++){var H=this.words[R],F=((H<<V|q)&16777215).toString(16);q=H>>>24-V&16777215,q!==0||R!==this.length-1?A=c[6-F.length]+F+A:A=F+A,V+=2,V>=26&&(V-=26,R--)}for(q!==0&&(A=q.toString(16)+A);A.length%O!==0;)A="0"+A;return this.negative!==0&&(A="-"+A),A}if(v===(v|0)&&v>=2&&v<=36){var P=u[v],E=h[v];A="";var j=this.clone();for(j.negative=0;!j.isZero();){var X=j.modrn(E).toString(v);j=j.idivn(E),j.isZero()?A=X+A:A=c[P-X.length]+X+A}for(this.isZero()&&(A="0"+A);A.length%O!==0;)A="0"+A;return this.negative!==0&&(A="-"+A),A}s(!1,"Base should be between 2 and 36")},n.prototype.toNumber=function(){var v=this.words[0];return this.length===2?v+=this.words[1]*67108864:this.length===3&&this.words[2]===1?v+=4503599627370496+this.words[1]*67108864:this.length>2&&s(!1,"Number can only safely store up to 53 bits"),this.negative!==0?-v:v},n.prototype.toJSON=function(){return this.toString(16,2)},r&&(n.prototype.toBuffer=function(v,O){return this.toArrayLike(r,v,O)}),n.prototype.toArray=function(v,O){return this.toArrayLike(Array,v,O)};var l=function(v,O){return v.allocUnsafe?v.allocUnsafe(O):new v(O)};n.prototype.toArrayLike=function(v,O,A){this._strip();var V=this.byteLength(),q=A||Math.max(1,V);s(V<=q,"byte array longer than desired length"),s(q>0,"Requested array length <= 0");var R=l(v,q),H=O==="le"?"LE":"BE";return this["_toArrayLike"+H](R,V),R},n.prototype._toArrayLikeLE=function(v,O){for(var A=0,V=0,q=0,R=0;q<this.length;q++){var H=this.words[q]<<R|V;v[A++]=H&255,A<v.length&&(v[A++]=H>>8&255),A<v.length&&(v[A++]=H>>16&255),R===6?(A<v.length&&(v[A++]=H>>24&255),V=0,R=0):(V=H>>>24,R+=2)}if(A<v.length)for(v[A++]=V;A<v.length;)v[A++]=0},n.prototype._toArrayLikeBE=function(v,O){for(var A=v.length-1,V=0,q=0,R=0;q<this.length;q++){var H=this.words[q]<<R|V;v[A--]=H&255,A>=0&&(v[A--]=H>>8&255),A>=0&&(v[A--]=H>>16&255),R===6?(A>=0&&(v[A--]=H>>24&255),V=0,R=0):(V=H>>>24,R+=2)}if(A>=0)for(v[A--]=V;A>=0;)v[A--]=0},Math.clz32?n.prototype._countBits=function(v){return 32-Math.clz32(v)}:n.prototype._countBits=function(v){var O=v,A=0;return O>=4096&&(A+=13,O>>>=13),O>=64&&(A+=7,O>>>=7),O>=8&&(A+=4,O>>>=4),O>=2&&(A+=2,O>>>=2),A+O},n.prototype._zeroBits=function(v){if(v===0)return 26;var O=v,A=0;return(O&8191)===0&&(A+=13,O>>>=13),(O&127)===0&&(A+=7,O>>>=7),(O&15)===0&&(A+=4,O>>>=4),(O&3)===0&&(A+=2,O>>>=2),(O&1)===0&&A++,A},n.prototype.bitLength=function(){var v=this.words[this.length-1],O=this._countBits(v);return(this.length-1)*26+O};function p(x){for(var v=new Array(x.bitLength()),O=0;O<v.length;O++){var A=O/26|0,V=O%26;v[O]=x.words[A]>>>V&1}return v}n.prototype.zeroBits=function(){if(this.isZero())return 0;for(var v=0,O=0;O<this.length;O++){var A=this._zeroBits(this.words[O]);if(v+=A,A!==26)break}return v},n.prototype.byteLength=function(){return Math.ceil(this.bitLength()/8)},n.prototype.toTwos=function(v){return this.negative!==0?this.abs().inotn(v).iaddn(1):this.clone()},n.prototype.fromTwos=function(v){return this.testn(v-1)?this.notn(v).iaddn(1).ineg():this.clone()},n.prototype.isNeg=function(){return this.negative!==0},n.prototype.neg=function(){return this.clone().ineg()},n.prototype.ineg=function(){return this.isZero()||(this.negative^=1),this},n.prototype.iuor=function(v){for(;this.length<v.length;)this.words[this.length++]=0;for(var O=0;O<v.length;O++)this.words[O]=this.words[O]|v.words[O];return this._strip()},n.prototype.ior=function(v){return s((this.negative|v.negative)===0),this.iuor(v)},n.prototype.or=function(v){return this.length>v.length?this.clone().ior(v):v.clone().ior(this)},n.prototype.uor=function(v){return this.length>v.length?this.clone().iuor(v):v.clone().iuor(this)},n.prototype.iuand=function(v){var O;this.length>v.length?O=v:O=this;for(var A=0;A<O.length;A++)this.words[A]=this.words[A]&v.words[A];return this.length=O.length,this._strip()},n.prototype.iand=function(v){return s((this.negative|v.negative)===0),this.iuand(v)},n.prototype.and=function(v){return this.length>v.length?this.clone().iand(v):v.clone().iand(this)},n.prototype.uand=function(v){return this.length>v.length?this.clone().iuand(v):v.clone().iuand(this)},n.prototype.iuxor=function(v){var O,A;this.length>v.length?(O=this,A=v):(O=v,A=this);for(var V=0;V<A.length;V++)this.words[V]=O.words[V]^A.words[V];if(this!==O)for(;V<O.length;V++)this.words[V]=O.words[V];return this.length=O.length,this._strip()},n.prototype.ixor=function(v){return s((this.negative|v.negative)===0),this.iuxor(v)},n.prototype.xor=function(v){return this.length>v.length?this.clone().ixor(v):v.clone().ixor(this)},n.prototype.uxor=function(v){return this.length>v.length?this.clone().iuxor(v):v.clone().iuxor(this)},n.prototype.inotn=function(v){s(typeof v=="number"&&v>=0);var O=Math.ceil(v/26)|0,A=v%26;this._expand(O),A>0&&O--;for(var V=0;V<O;V++)this.words[V]=~this.words[V]&67108863;return A>0&&(this.words[V]=~this.words[V]&67108863>>26-A),this._strip()},n.prototype.notn=function(v){return this.clone().inotn(v)},n.prototype.setn=function(v,O){s(typeof v=="number"&&v>=0);var A=v/26|0,V=v%26;return this._expand(A+1),O?this.words[A]=this.words[A]|1<<V:this.words[A]=this.words[A]&~(1<<V),this._strip()},n.prototype.iadd=function(v){var O;if(this.negative!==0&&v.negative===0)return this.negative=0,O=this.isub(v),this.negative^=1,this._normSign();if(this.negative===0&&v.negative!==0)return v.negative=0,O=this.isub(v),v.negative=1,O._normSign();var A,V;this.length>v.length?(A=this,V=v):(A=v,V=this);for(var q=0,R=0;R<V.length;R++)O=(A.words[R]|0)+(V.words[R]|0)+q,this.words[R]=O&67108863,q=O>>>26;for(;q!==0&&R<A.length;R++)O=(A.words[R]|0)+q,this.words[R]=O&67108863,q=O>>>26;if(this.length=A.length,q!==0)this.words[this.length]=q,this.length++;else if(A!==this)for(;R<A.length;R++)this.words[R]=A.words[R];return this},n.prototype.add=function(v){var O;return v.negative!==0&&this.negative===0?(v.negative=0,O=this.sub(v),v.negative^=1,O):v.negative===0&&this.negative!==0?(this.negative=0,O=v.sub(this),this.negative=1,O):this.length>v.length?this.clone().iadd(v):v.clone().iadd(this)},n.prototype.isub=function(v){if(v.negative!==0){v.negative=0;var O=this.iadd(v);return v.negative=1,O._normSign()}else if(this.negative!==0)return this.negative=0,this.iadd(v),this.negative=1,this._normSign();var A=this.cmp(v);if(A===0)return this.negative=0,this.length=1,this.words[0]=0,this;var V,q;A>0?(V=this,q=v):(V=v,q=this);for(var R=0,H=0;H<q.length;H++)O=(V.words[H]|0)-(q.words[H]|0)+R,R=O>>26,this.words[H]=O&67108863;for(;R!==0&&H<V.length;H++)O=(V.words[H]|0)+R,R=O>>26,this.words[H]=O&67108863;if(R===0&&H<V.length&&V!==this)for(;H<V.length;H++)this.words[H]=V.words[H];return this.length=Math.max(this.length,H),V!==this&&(this.negative=1),this._strip()},n.prototype.sub=function(v){return this.clone().isub(v)};function m(x,v,O){O.negative=v.negative^x.negative;var A=x.length+v.length|0;O.length=A,A=A-1|0;var V=x.words[0]|0,q=v.words[0]|0,R=V*q,H=R&67108863,F=R/67108864|0;O.words[0]=H;for(var P=1;P<A;P++){for(var E=F>>>26,j=F&67108863,X=Math.min(P,v.length-1),Q=Math.max(0,P-x.length+1);Q<=X;Q++){var Se=P-Q|0;V=x.words[Se]|0,q=v.words[Q]|0,R=V*q+j,E+=R/67108864|0,j=R&67108863}O.words[P]=j|0,F=E|0}return F!==0?O.words[P]=F|0:O.length--,O._strip()}var g=function(v,O,A){var V=v.words,q=O.words,R=A.words,H=0,F,P,E,j=V[0]|0,X=j&8191,Q=j>>>13,Se=V[1]|0,he=Se&8191,xe=Se>>>13,Ae=V[2]|0,Re=Ae&8191,He=Ae>>>13,qt=V[3]|0,D=qt&8191,$=qt>>>13,G=V[4]|0,U=G&8191,W=G>>>13,J=V[5]|0,ee=J&8191,ne=J>>>13,ce=V[6]|0,ie=ce&8191,de=ce>>>13,we=V[7]|0,ue=we&8191,Oe=we>>>13,Me=V[8]|0,L=Me&8191,C=Me>>>13,B=V[9]|0,z=B&8191,Y=B>>>13,se=q[0]|0,re=se&8191,Be=se>>>13,$e=q[1]|0,Ne=$e&8191,Fe=$e>>>13,rt=q[2]|0,Qt=rt&8191,Lt=rt>>>13,Uu=q[3]|0,Rt=Uu&8191,Zt=Uu>>>13,$u=q[4]|0,Jt=$u&8191,Ft=$u>>>13,ju=q[5]|0,es=ju&8191,Dt=ju>>>13,Wu=q[6]|0,Ht=Wu&8191,it=Wu>>>13,pn=q[7]|0,Gt=pn&8191,ts=pn>>>13,Yb=q[8]|0,gs=Yb&8191,ys=Yb>>>13,Qb=q[9]|0,bs=Qb&8191,ws=Qb>>>13;A.negative=v.negative^O.negative,A.length=19,F=Math.imul(X,re),P=Math.imul(X,Be),P=P+Math.imul(Q,re)|0,E=Math.imul(Q,Be);var Xl=(H+F|0)+((P&8191)<<13)|0;H=(E+(P>>>13)|0)+(Xl>>>26)|0,Xl&=67108863,F=Math.imul(he,re),P=Math.imul(he,Be),P=P+Math.imul(xe,re)|0,E=Math.imul(xe,Be),F=F+Math.imul(X,Ne)|0,P=P+Math.imul(X,Fe)|0,P=P+Math.imul(Q,Ne)|0,E=E+Math.imul(Q,Fe)|0;var Yl=(H+F|0)+((P&8191)<<13)|0;H=(E+(P>>>13)|0)+(Yl>>>26)|0,Yl&=67108863,F=Math.imul(Re,re),P=Math.imul(Re,Be),P=P+Math.imul(He,re)|0,E=Math.imul(He,Be),F=F+Math.imul(he,Ne)|0,P=P+Math.imul(he,Fe)|0,P=P+Math.imul(xe,Ne)|0,E=E+Math.imul(xe,Fe)|0,F=F+Math.imul(X,Qt)|0,P=P+Math.imul(X,Lt)|0,P=P+Math.imul(Q,Qt)|0,E=E+Math.imul(Q,Lt)|0;var Ql=(H+F|0)+((P&8191)<<13)|0;H=(E+(P>>>13)|0)+(Ql>>>26)|0,Ql&=67108863,F=Math.imul(D,re),P=Math.imul(D,Be),P=P+Math.imul($,re)|0,E=Math.imul($,Be),F=F+Math.imul(Re,Ne)|0,P=P+Math.imul(Re,Fe)|0,P=P+Math.imul(He,Ne)|0,E=E+Math.imul(He,Fe)|0,F=F+Math.imul(he,Qt)|0,P=P+Math.imul(he,Lt)|0,P=P+Math.imul(xe,Qt)|0,E=E+Math.imul(xe,Lt)|0,F=F+Math.imul(X,Rt)|0,P=P+Math.imul(X,Zt)|0,P=P+Math.imul(Q,Rt)|0,E=E+Math.imul(Q,Zt)|0;var Zl=(H+F|0)+((P&8191)<<13)|0;H=(E+(P>>>13)|0)+(Zl>>>26)|0,Zl&=67108863,F=Math.imul(U,re),P=Math.imul(U,Be),P=P+Math.imul(W,re)|0,E=Math.imul(W,Be),F=F+Math.imul(D,Ne)|0,P=P+Math.imul(D,Fe)|0,P=P+Math.imul($,Ne)|0,E=E+Math.imul($,Fe)|0,F=F+Math.imul(Re,Qt)|0,P=P+Math.imul(Re,Lt)|0,P=P+Math.imul(He,Qt)|0,E=E+Math.imul(He,Lt)|0,F=F+Math.imul(he,Rt)|0,P=P+Math.imul(he,Zt)|0,P=P+Math.imul(xe,Rt)|0,E=E+Math.imul(xe,Zt)|0,F=F+Math.imul(X,Jt)|0,P=P+Math.imul(X,Ft)|0,P=P+Math.imul(Q,Jt)|0,E=E+Math.imul(Q,Ft)|0;var Jl=(H+F|0)+((P&8191)<<13)|0;H=(E+(P>>>13)|0)+(Jl>>>26)|0,Jl&=67108863,F=Math.imul(ee,re),P=Math.imul(ee,Be),P=P+Math.imul(ne,re)|0,E=Math.imul(ne,Be),F=F+Math.imul(U,Ne)|0,P=P+Math.imul(U,Fe)|0,P=P+Math.imul(W,Ne)|0,E=E+Math.imul(W,Fe)|0,F=F+Math.imul(D,Qt)|0,P=P+Math.imul(D,Lt)|0,P=P+Math.imul($,Qt)|0,E=E+Math.imul($,Lt)|0,F=F+Math.imul(Re,Rt)|0,P=P+Math.imul(Re,Zt)|0,P=P+Math.imul(He,Rt)|0,E=E+Math.imul(He,Zt)|0,F=F+Math.imul(he,Jt)|0,P=P+Math.imul(he,Ft)|0,P=P+Math.imul(xe,Jt)|0,E=E+Math.imul(xe,Ft)|0,F=F+Math.imul(X,es)|0,P=P+Math.imul(X,Dt)|0,P=P+Math.imul(Q,es)|0,E=E+Math.imul(Q,Dt)|0;var ep=(H+F|0)+((P&8191)<<13)|0;H=(E+(P>>>13)|0)+(ep>>>26)|0,ep&=67108863,F=Math.imul(ie,re),P=Math.imul(ie,Be),P=P+Math.imul(de,re)|0,E=Math.imul(de,Be),F=F+Math.imul(ee,Ne)|0,P=P+Math.imul(ee,Fe)|0,P=P+Math.imul(ne,Ne)|0,E=E+Math.imul(ne,Fe)|0,F=F+Math.imul(U,Qt)|0,P=P+Math.imul(U,Lt)|0,P=P+Math.imul(W,Qt)|0,E=E+Math.imul(W,Lt)|0,F=F+Math.imul(D,Rt)|0,P=P+Math.imul(D,Zt)|0,P=P+Math.imul($,Rt)|0,E=E+Math.imul($,Zt)|0,F=F+Math.imul(Re,Jt)|0,P=P+Math.imul(Re,Ft)|0,P=P+Math.imul(He,Jt)|0,E=E+Math.imul(He,Ft)|0,F=F+Math.imul(he,es)|0,P=P+Math.imul(he,Dt)|0,P=P+Math.imul(xe,es)|0,E=E+Math.imul(xe,Dt)|0,F=F+Math.imul(X,Ht)|0,P=P+Math.imul(X,it)|0,P=P+Math.imul(Q,Ht)|0,E=E+Math.imul(Q,it)|0;var tp=(H+F|0)+((P&8191)<<13)|0;H=(E+(P>>>13)|0)+(tp>>>26)|0,tp&=67108863,F=Math.imul(ue,re),P=Math.imul(ue,Be),P=P+Math.imul(Oe,re)|0,E=Math.imul(Oe,Be),F=F+Math.imul(ie,Ne)|0,P=P+Math.imul(ie,Fe)|0,P=P+Math.imul(de,Ne)|0,E=E+Math.imul(de,Fe)|0,F=F+Math.imul(ee,Qt)|0,P=P+Math.imul(ee,Lt)|0,P=P+Math.imul(ne,Qt)|0,E=E+Math.imul(ne,Lt)|0,F=F+Math.imul(U,Rt)|0,P=P+Math.imul(U,Zt)|0,P=P+Math.imul(W,Rt)|0,E=E+Math.imul(W,Zt)|0,F=F+Math.imul(D,Jt)|0,P=P+Math.imul(D,Ft)|0,P=P+Math.imul($,Jt)|0,E=E+Math.imul($,Ft)|0,F=F+Math.imul(Re,es)|0,P=P+Math.imul(Re,Dt)|0,P=P+Math.imul(He,es)|0,E=E+Math.imul(He,Dt)|0,F=F+Math.imul(he,Ht)|0,P=P+Math.imul(he,it)|0,P=P+Math.imul(xe,Ht)|0,E=E+Math.imul(xe,it)|0,F=F+Math.imul(X,Gt)|0,P=P+Math.imul(X,ts)|0,P=P+Math.imul(Q,Gt)|0,E=E+Math.imul(Q,ts)|0;var sp=(H+F|0)+((P&8191)<<13)|0;H=(E+(P>>>13)|0)+(sp>>>26)|0,sp&=67108863,F=Math.imul(L,re),P=Math.imul(L,Be),P=P+Math.imul(C,re)|0,E=Math.imul(C,Be),F=F+Math.imul(ue,Ne)|0,P=P+Math.imul(ue,Fe)|0,P=P+Math.imul(Oe,Ne)|0,E=E+Math.imul(Oe,Fe)|0,F=F+Math.imul(ie,Qt)|0,P=P+Math.imul(ie,Lt)|0,P=P+Math.imul(de,Qt)|0,E=E+Math.imul(de,Lt)|0,F=F+Math.imul(ee,Rt)|0,P=P+Math.imul(ee,Zt)|0,P=P+Math.imul(ne,Rt)|0,E=E+Math.imul(ne,Zt)|0,F=F+Math.imul(U,Jt)|0,P=P+Math.imul(U,Ft)|0,P=P+Math.imul(W,Jt)|0,E=E+Math.imul(W,Ft)|0,F=F+Math.imul(D,es)|0,P=P+Math.imul(D,Dt)|0,P=P+Math.imul($,es)|0,E=E+Math.imul($,Dt)|0,F=F+Math.imul(Re,Ht)|0,P=P+Math.imul(Re,it)|0,P=P+Math.imul(He,Ht)|0,E=E+Math.imul(He,it)|0,F=F+Math.imul(he,Gt)|0,P=P+Math.imul(he,ts)|0,P=P+Math.imul(xe,Gt)|0,E=E+Math.imul(xe,ts)|0,F=F+Math.imul(X,gs)|0,P=P+Math.imul(X,ys)|0,P=P+Math.imul(Q,gs)|0,E=E+Math.imul(Q,ys)|0;var ip=(H+F|0)+((P&8191)<<13)|0;H=(E+(P>>>13)|0)+(ip>>>26)|0,ip&=67108863,F=Math.imul(z,re),P=Math.imul(z,Be),P=P+Math.imul(Y,re)|0,E=Math.imul(Y,Be),F=F+Math.imul(L,Ne)|0,P=P+Math.imul(L,Fe)|0,P=P+Math.imul(C,Ne)|0,E=E+Math.imul(C,Fe)|0,F=F+Math.imul(ue,Qt)|0,P=P+Math.imul(ue,Lt)|0,P=P+Math.imul(Oe,Qt)|0,E=E+Math.imul(Oe,Lt)|0,F=F+Math.imul(ie,Rt)|0,P=P+Math.imul(ie,Zt)|0,P=P+Math.imul(de,Rt)|0,E=E+Math.imul(de,Zt)|0,F=F+Math.imul(ee,Jt)|0,P=P+Math.imul(ee,Ft)|0,P=P+Math.imul(ne,Jt)|0,E=E+Math.imul(ne,Ft)|0,F=F+Math.imul(U,es)|0,P=P+Math.imul(U,Dt)|0,P=P+Math.imul(W,es)|0,E=E+Math.imul(W,Dt)|0,F=F+Math.imul(D,Ht)|0,P=P+Math.imul(D,it)|0,P=P+Math.imul($,Ht)|0,E=E+Math.imul($,it)|0,F=F+Math.imul(Re,Gt)|0,P=P+Math.imul(Re,ts)|0,P=P+Math.imul(He,Gt)|0,E=E+Math.imul(He,ts)|0,F=F+Math.imul(he,gs)|0,P=P+Math.imul(he,ys)|0,P=P+Math.imul(xe,gs)|0,E=E+Math.imul(xe,ys)|0,F=F+Math.imul(X,bs)|0,P=P+Math.imul(X,ws)|0,P=P+Math.imul(Q,bs)|0,E=E+Math.imul(Q,ws)|0;var np=(H+F|0)+((P&8191)<<13)|0;H=(E+(P>>>13)|0)+(np>>>26)|0,np&=67108863,F=Math.imul(z,Ne),P=Math.imul(z,Fe),P=P+Math.imul(Y,Ne)|0,E=Math.imul(Y,Fe),F=F+Math.imul(L,Qt)|0,P=P+Math.imul(L,Lt)|0,P=P+Math.imul(C,Qt)|0,E=E+Math.imul(C,Lt)|0,F=F+Math.imul(ue,Rt)|0,P=P+Math.imul(ue,Zt)|0,P=P+Math.imul(Oe,Rt)|0,E=E+Math.imul(Oe,Zt)|0,F=F+Math.imul(ie,Jt)|0,P=P+Math.imul(ie,Ft)|0,P=P+Math.imul(de,Jt)|0,E=E+Math.imul(de,Ft)|0,F=F+Math.imul(ee,es)|0,P=P+Math.imul(ee,Dt)|0,P=P+Math.imul(ne,es)|0,E=E+Math.imul(ne,Dt)|0,F=F+Math.imul(U,Ht)|0,P=P+Math.imul(U,it)|0,P=P+Math.imul(W,Ht)|0,E=E+Math.imul(W,it)|0,F=F+Math.imul(D,Gt)|0,P=P+Math.imul(D,ts)|0,P=P+Math.imul($,Gt)|0,E=E+Math.imul($,ts)|0,F=F+Math.imul(Re,gs)|0,P=P+Math.imul(Re,ys)|0,P=P+Math.imul(He,gs)|0,E=E+Math.imul(He,ys)|0,F=F+Math.imul(he,bs)|0,P=P+Math.imul(he,ws)|0,P=P+Math.imul(xe,bs)|0,E=E+Math.imul(xe,ws)|0;var rp=(H+F|0)+((P&8191)<<13)|0;H=(E+(P>>>13)|0)+(rp>>>26)|0,rp&=67108863,F=Math.imul(z,Qt),P=Math.imul(z,Lt),P=P+Math.imul(Y,Qt)|0,E=Math.imul(Y,Lt),F=F+Math.imul(L,Rt)|0,P=P+Math.imul(L,Zt)|0,P=P+Math.imul(C,Rt)|0,E=E+Math.imul(C,Zt)|0,F=F+Math.imul(ue,Jt)|0,P=P+Math.imul(ue,Ft)|0,P=P+Math.imul(Oe,Jt)|0,E=E+Math.imul(Oe,Ft)|0,F=F+Math.imul(ie,es)|0,P=P+Math.imul(ie,Dt)|0,P=P+Math.imul(de,es)|0,E=E+Math.imul(de,Dt)|0,F=F+Math.imul(ee,Ht)|0,P=P+Math.imul(ee,it)|0,P=P+Math.imul(ne,Ht)|0,E=E+Math.imul(ne,it)|0,F=F+Math.imul(U,Gt)|0,P=P+Math.imul(U,ts)|0,P=P+Math.imul(W,Gt)|0,E=E+Math.imul(W,ts)|0,F=F+Math.imul(D,gs)|0,P=P+Math.imul(D,ys)|0,P=P+Math.imul($,gs)|0,E=E+Math.imul($,ys)|0,F=F+Math.imul(Re,bs)|0,P=P+Math.imul(Re,ws)|0,P=P+Math.imul(He,bs)|0,E=E+Math.imul(He,ws)|0;var ap=(H+F|0)+((P&8191)<<13)|0;H=(E+(P>>>13)|0)+(ap>>>26)|0,ap&=67108863,F=Math.imul(z,Rt),P=Math.imul(z,Zt),P=P+Math.imul(Y,Rt)|0,E=Math.imul(Y,Zt),F=F+Math.imul(L,Jt)|0,P=P+Math.imul(L,Ft)|0,P=P+Math.imul(C,Jt)|0,E=E+Math.imul(C,Ft)|0,F=F+Math.imul(ue,es)|0,P=P+Math.imul(ue,Dt)|0,P=P+Math.imul(Oe,es)|0,E=E+Math.imul(Oe,Dt)|0,F=F+Math.imul(ie,Ht)|0,P=P+Math.imul(ie,it)|0,P=P+Math.imul(de,Ht)|0,E=E+Math.imul(de,it)|0,F=F+Math.imul(ee,Gt)|0,P=P+Math.imul(ee,ts)|0,P=P+Math.imul(ne,Gt)|0,E=E+Math.imul(ne,ts)|0,F=F+Math.imul(U,gs)|0,P=P+Math.imul(U,ys)|0,P=P+Math.imul(W,gs)|0,E=E+Math.imul(W,ys)|0,F=F+Math.imul(D,bs)|0,P=P+Math.imul(D,ws)|0,P=P+Math.imul($,bs)|0,E=E+Math.imul($,ws)|0;var op=(H+F|0)+((P&8191)<<13)|0;H=(E+(P>>>13)|0)+(op>>>26)|0,op&=67108863,F=Math.imul(z,Jt),P=Math.imul(z,Ft),P=P+Math.imul(Y,Jt)|0,E=Math.imul(Y,Ft),F=F+Math.imul(L,es)|0,P=P+Math.imul(L,Dt)|0,P=P+Math.imul(C,es)|0,E=E+Math.imul(C,Dt)|0,F=F+Math.imul(ue,Ht)|0,P=P+Math.imul(ue,it)|0,P=P+Math.imul(Oe,Ht)|0,E=E+Math.imul(Oe,it)|0,F=F+Math.imul(ie,Gt)|0,P=P+Math.imul(ie,ts)|0,P=P+Math.imul(de,Gt)|0,E=E+Math.imul(de,ts)|0,F=F+Math.imul(ee,gs)|0,P=P+Math.imul(ee,ys)|0,P=P+Math.imul(ne,gs)|0,E=E+Math.imul(ne,ys)|0,F=F+Math.imul(U,bs)|0,P=P+Math.imul(U,ws)|0,P=P+Math.imul(W,bs)|0,E=E+Math.imul(W,ws)|0;var dp=(H+F|0)+((P&8191)<<13)|0;H=(E+(P>>>13)|0)+(dp>>>26)|0,dp&=67108863,F=Math.imul(z,es),P=Math.imul(z,Dt),P=P+Math.imul(Y,es)|0,E=Math.imul(Y,Dt),F=F+Math.imul(L,Ht)|0,P=P+Math.imul(L,it)|0,P=P+Math.imul(C,Ht)|0,E=E+Math.imul(C,it)|0,F=F+Math.imul(ue,Gt)|0,P=P+Math.imul(ue,ts)|0,P=P+Math.imul(Oe,Gt)|0,E=E+Math.imul(Oe,ts)|0,F=F+Math.imul(ie,gs)|0,P=P+Math.imul(ie,ys)|0,P=P+Math.imul(de,gs)|0,E=E+Math.imul(de,ys)|0,F=F+Math.imul(ee,bs)|0,P=P+Math.imul(ee,ws)|0,P=P+Math.imul(ne,bs)|0,E=E+Math.imul(ne,ws)|0;var cp=(H+F|0)+((P&8191)<<13)|0;H=(E+(P>>>13)|0)+(cp>>>26)|0,cp&=67108863,F=Math.imul(z,Ht),P=Math.imul(z,it),P=P+Math.imul(Y,Ht)|0,E=Math.imul(Y,it),F=F+Math.imul(L,Gt)|0,P=P+Math.imul(L,ts)|0,P=P+Math.imul(C,Gt)|0,E=E+Math.imul(C,ts)|0,F=F+Math.imul(ue,gs)|0,P=P+Math.imul(ue,ys)|0,P=P+Math.imul(Oe,gs)|0,E=E+Math.imul(Oe,ys)|0,F=F+Math.imul(ie,bs)|0,P=P+Math.imul(ie,ws)|0,P=P+Math.imul(de,bs)|0,E=E+Math.imul(de,ws)|0;var up=(H+F|0)+((P&8191)<<13)|0;H=(E+(P>>>13)|0)+(up>>>26)|0,up&=67108863,F=Math.imul(z,Gt),P=Math.imul(z,ts),P=P+Math.imul(Y,Gt)|0,E=Math.imul(Y,ts),F=F+Math.imul(L,gs)|0,P=P+Math.imul(L,ys)|0,P=P+Math.imul(C,gs)|0,E=E+Math.imul(C,ys)|0,F=F+Math.imul(ue,bs)|0,P=P+Math.imul(ue,ws)|0,P=P+Math.imul(Oe,bs)|0,E=E+Math.imul(Oe,ws)|0;var fp=(H+F|0)+((P&8191)<<13)|0;H=(E+(P>>>13)|0)+(fp>>>26)|0,fp&=67108863,F=Math.imul(z,gs),P=Math.imul(z,ys),P=P+Math.imul(Y,gs)|0,E=Math.imul(Y,ys),F=F+Math.imul(L,bs)|0,P=P+Math.imul(L,ws)|0,P=P+Math.imul(C,bs)|0,E=E+Math.imul(C,ws)|0;var hp=(H+F|0)+((P&8191)<<13)|0;H=(E+(P>>>13)|0)+(hp>>>26)|0,hp&=67108863,F=Math.imul(z,bs),P=Math.imul(z,ws),P=P+Math.imul(Y,bs)|0,E=Math.imul(Y,ws);var lp=(H+F|0)+((P&8191)<<13)|0;return H=(E+(P>>>13)|0)+(lp>>>26)|0,lp&=67108863,R[0]=Xl,R[1]=Yl,R[2]=Ql,R[3]=Zl,R[4]=Jl,R[5]=ep,R[6]=tp,R[7]=sp,R[8]=ip,R[9]=np,R[10]=rp,R[11]=ap,R[12]=op,R[13]=dp,R[14]=cp,R[15]=up,R[16]=fp,R[17]=hp,R[18]=lp,H!==0&&(R[19]=H,A.length++),A};Math.imul||(g=m);function y(x,v,O){O.negative=v.negative^x.negative,O.length=x.length+v.length;for(var A=0,V=0,q=0;q<O.length-1;q++){var R=V;V=0;for(var H=A&67108863,F=Math.min(q,v.length-1),P=Math.max(0,q-x.length+1);P<=F;P++){var E=q-P,j=x.words[E]|0,X=v.words[P]|0,Q=j*X,Se=Q&67108863;R=R+(Q/67108864|0)|0,Se=Se+H|0,H=Se&67108863,R=R+(Se>>>26)|0,V+=R>>>26,R&=67108863}O.words[q]=H,A=R,R=V}return A!==0?O.words[q]=A:O.length--,O._strip()}function b(x,v,O){return y(x,v,O)}n.prototype.mulTo=function(v,O){var A,V=this.length+v.length;return this.length===10&&v.length===10?A=g(this,v,O):V<63?A=m(this,v,O):V<1024?A=y(this,v,O):A=b(this,v,O),A},n.prototype.mul=function(v){var O=new n(null);return O.words=new Array(this.length+v.length),this.mulTo(v,O)},n.prototype.mulf=function(v){var O=new n(null);return O.words=new Array(this.length+v.length),b(this,v,O)},n.prototype.imul=function(v){return this.clone().mulTo(v,this)},n.prototype.imuln=function(v){var O=v<0;O&&(v=-v),s(typeof v=="number"),s(v<67108864);for(var A=0,V=0;V<this.length;V++){var q=(this.words[V]|0)*v,R=(q&67108863)+(A&67108863);A>>=26,A+=q/67108864|0,A+=R>>>26,this.words[V]=R&67108863}return A!==0&&(this.words[V]=A,this.length++),O?this.ineg():this},n.prototype.muln=function(v){return this.clone().imuln(v)},n.prototype.sqr=function(){return this.mul(this)},n.prototype.isqr=function(){return this.imul(this.clone())},n.prototype.pow=function(v){var O=p(v);if(O.length===0)return new n(1);for(var A=this,V=0;V<O.length&&O[V]===0;V++,A=A.sqr());if(++V<O.length)for(var q=A.sqr();V<O.length;V++,q=q.sqr())O[V]!==0&&(A=A.mul(q));return A},n.prototype.iushln=function(v){s(typeof v=="number"&&v>=0);var O=v%26,A=(v-O)/26,V=67108863>>>26-O<<26-O,q;if(O!==0){var R=0;for(q=0;q<this.length;q++){var H=this.words[q]&V,F=(this.words[q]|0)-H<<O;this.words[q]=F|R,R=H>>>26-O}R&&(this.words[q]=R,this.length++)}if(A!==0){for(q=this.length-1;q>=0;q--)this.words[q+A]=this.words[q];for(q=0;q<A;q++)this.words[q]=0;this.length+=A}return this._strip()},n.prototype.ishln=function(v){return s(this.negative===0),this.iushln(v)},n.prototype.iushrn=function(v,O,A){s(typeof v=="number"&&v>=0);var V;O?V=(O-O%26)/26:V=0;var q=v%26,R=Math.min((v-q)/26,this.length),H=67108863^67108863>>>q<<q,F=A;if(V-=R,V=Math.max(0,V),F){for(var P=0;P<R;P++)F.words[P]=this.words[P];F.length=R}if(R!==0)if(this.length>R)for(this.length-=R,P=0;P<this.length;P++)this.words[P]=this.words[P+R];else this.words[0]=0,this.length=1;var E=0;for(P=this.length-1;P>=0&&(E!==0||P>=V);P--){var j=this.words[P]|0;this.words[P]=E<<26-q|j>>>q,E=j&H}return F&&E!==0&&(F.words[F.length++]=E),this.length===0&&(this.words[0]=0,this.length=1),this._strip()},n.prototype.ishrn=function(v,O,A){return s(this.negative===0),this.iushrn(v,O,A)},n.prototype.shln=function(v){return this.clone().ishln(v)},n.prototype.ushln=function(v){return this.clone().iushln(v)},n.prototype.shrn=function(v){return this.clone().ishrn(v)},n.prototype.ushrn=function(v){return this.clone().iushrn(v)},n.prototype.testn=function(v){s(typeof v=="number"&&v>=0);var O=v%26,A=(v-O)/26,V=1<<O;if(this.length<=A)return!1;var q=this.words[A];return!!(q&V)},n.prototype.imaskn=function(v){s(typeof v=="number"&&v>=0);var O=v%26,A=(v-O)/26;if(s(this.negative===0,"imaskn works only with positive numbers"),this.length<=A)return this;if(O!==0&&A++,this.length=Math.min(A,this.length),O!==0){var V=67108863^67108863>>>O<<O;this.words[this.length-1]&=V}return this._strip()},n.prototype.maskn=function(v){return this.clone().imaskn(v)},n.prototype.iaddn=function(v){return s(typeof v=="number"),s(v<67108864),v<0?this.isubn(-v):this.negative!==0?this.length===1&&(this.words[0]|0)<=v?(this.words[0]=v-(this.words[0]|0),this.negative=0,this):(this.negative=0,this.isubn(v),this.negative=1,this):this._iaddn(v)},n.prototype._iaddn=function(v){this.words[0]+=v;for(var O=0;O<this.length&&this.words[O]>=67108864;O++)this.words[O]-=67108864,O===this.length-1?this.words[O+1]=1:this.words[O+1]++;return this.length=Math.max(this.length,O+1),this},n.prototype.isubn=function(v){if(s(typeof v=="number"),s(v<67108864),v<0)return this.iaddn(-v);if(this.negative!==0)return this.negative=0,this.iaddn(v),this.negative=1,this;if(this.words[0]-=v,this.length===1&&this.words[0]<0)this.words[0]=-this.words[0],this.negative=1;else for(var O=0;O<this.length&&this.words[O]<0;O++)this.words[O]+=67108864,this.words[O+1]-=1;return this._strip()},n.prototype.addn=function(v){return this.clone().iaddn(v)},n.prototype.subn=function(v){return this.clone().isubn(v)},n.prototype.iabs=function(){return this.negative=0,this},n.prototype.abs=function(){return this.clone().iabs()},n.prototype._ishlnsubmul=function(v,O,A){var V=v.length+A,q;this._expand(V);var R,H=0;for(q=0;q<v.length;q++){R=(this.words[q+A]|0)+H;var F=(v.words[q]|0)*O;R-=F&67108863,H=(R>>26)-(F/67108864|0),this.words[q+A]=R&67108863}for(;q<this.length-A;q++)R=(this.words[q+A]|0)+H,H=R>>26,this.words[q+A]=R&67108863;if(H===0)return this._strip();for(s(H===-1),H=0,q=0;q<this.length;q++)R=-(this.words[q]|0)+H,H=R>>26,this.words[q]=R&67108863;return this.negative=1,this._strip()},n.prototype._wordDiv=function(v,O){var A=this.length-v.length,V=this.clone(),q=v,R=q.words[q.length-1]|0,H=this._countBits(R);A=26-H,A!==0&&(q=q.ushln(A),V.iushln(A),R=q.words[q.length-1]|0);var F=V.length-q.length,P;if(O!=="mod"){P=new n(null),P.length=F+1,P.words=new Array(P.length);for(var E=0;E<P.length;E++)P.words[E]=0}var j=V.clone()._ishlnsubmul(q,1,F);j.negative===0&&(V=j,P&&(P.words[F]=1));for(var X=F-1;X>=0;X--){var Q=(V.words[q.length+X]|0)*67108864+(V.words[q.length+X-1]|0);for(Q=Math.min(Q/R|0,67108863),V._ishlnsubmul(q,Q,X);V.negative!==0;)Q--,V.negative=0,V._ishlnsubmul(q,1,X),V.isZero()||(V.negative^=1);P&&(P.words[X]=Q)}return P&&P._strip(),V._strip(),O!=="div"&&A!==0&&V.iushrn(A),{div:P||null,mod:V}},n.prototype.divmod=function(v,O,A){if(s(!v.isZero()),this.isZero())return{div:new n(0),mod:new n(0)};var V,q,R;return this.negative!==0&&v.negative===0?(R=this.neg().divmod(v,O),O!=="mod"&&(V=R.div.neg()),O!=="div"&&(q=R.mod.neg(),A&&q.negative!==0&&q.iadd(v)),{div:V,mod:q}):this.negative===0&&v.negative!==0?(R=this.divmod(v.neg(),O),O!=="mod"&&(V=R.div.neg()),{div:V,mod:R.mod}):(this.negative&v.negative)!==0?(R=this.neg().divmod(v.neg(),O),O!=="div"&&(q=R.mod.neg(),A&&q.negative!==0&&q.isub(v)),{div:R.div,mod:q}):v.length>this.length||this.cmp(v)<0?{div:new n(0),mod:this}:v.length===1?O==="div"?{div:this.divn(v.words[0]),mod:null}:O==="mod"?{div:null,mod:new n(this.modrn(v.words[0]))}:{div:this.divn(v.words[0]),mod:new n(this.modrn(v.words[0]))}:this._wordDiv(v,O)},n.prototype.div=function(v){return this.divmod(v,"div",!1).div},n.prototype.mod=function(v){return this.divmod(v,"mod",!1).mod},n.prototype.umod=function(v){return this.divmod(v,"mod",!0).mod},n.prototype.divRound=function(v){var O=this.divmod(v);if(O.mod.isZero())return O.div;var A=O.div.negative!==0?O.mod.isub(v):O.mod,V=v.ushrn(1),q=v.andln(1),R=A.cmp(V);return R<0||q===1&&R===0?O.div:O.div.negative!==0?O.div.isubn(1):O.div.iaddn(1)},n.prototype.modrn=function(v){var O=v<0;O&&(v=-v),s(v<=67108863);for(var A=(1<<26)%v,V=0,q=this.length-1;q>=0;q--)V=(A*V+(this.words[q]|0))%v;return O?-V:V},n.prototype.modn=function(v){return this.modrn(v)},n.prototype.idivn=function(v){var O=v<0;O&&(v=-v),s(v<=67108863);for(var A=0,V=this.length-1;V>=0;V--){var q=(this.words[V]|0)+A*67108864;this.words[V]=q/v|0,A=q%v}return this._strip(),O?this.ineg():this},n.prototype.divn=function(v){return this.clone().idivn(v)},n.prototype.egcd=function(v){s(v.negative===0),s(!v.isZero());var O=this,A=v.clone();O.negative!==0?O=O.umod(v):O=O.clone();for(var V=new n(1),q=new n(0),R=new n(0),H=new n(1),F=0;O.isEven()&&A.isEven();)O.iushrn(1),A.iushrn(1),++F;for(var P=A.clone(),E=O.clone();!O.isZero();){for(var j=0,X=1;(O.words[0]&X)===0&&j<26;++j,X<<=1);if(j>0)for(O.iushrn(j);j-- >0;)(V.isOdd()||q.isOdd())&&(V.iadd(P),q.isub(E)),V.iushrn(1),q.iushrn(1);for(var Q=0,Se=1;(A.words[0]&Se)===0&&Q<26;++Q,Se<<=1);if(Q>0)for(A.iushrn(Q);Q-- >0;)(R.isOdd()||H.isOdd())&&(R.iadd(P),H.isub(E)),R.iushrn(1),H.iushrn(1);O.cmp(A)>=0?(O.isub(A),V.isub(R),q.isub(H)):(A.isub(O),R.isub(V),H.isub(q))}return{a:R,b:H,gcd:A.iushln(F)}},n.prototype._invmp=function(v){s(v.negative===0),s(!v.isZero());var O=this,A=v.clone();O.negative!==0?O=O.umod(v):O=O.clone();for(var V=new n(1),q=new n(0),R=A.clone();O.cmpn(1)>0&&A.cmpn(1)>0;){for(var H=0,F=1;(O.words[0]&F)===0&&H<26;++H,F<<=1);if(H>0)for(O.iushrn(H);H-- >0;)V.isOdd()&&V.iadd(R),V.iushrn(1);for(var P=0,E=1;(A.words[0]&E)===0&&P<26;++P,E<<=1);if(P>0)for(A.iushrn(P);P-- >0;)q.isOdd()&&q.iadd(R),q.iushrn(1);O.cmp(A)>=0?(O.isub(A),V.isub(q)):(A.isub(O),q.isub(V))}var j;return O.cmpn(1)===0?j=V:j=q,j.cmpn(0)<0&&j.iadd(v),j},n.prototype.gcd=function(v){if(this.isZero())return v.abs();if(v.isZero())return this.abs();var O=this.clone(),A=v.clone();O.negative=0,A.negative=0;for(var V=0;O.isEven()&&A.isEven();V++)O.iushrn(1),A.iushrn(1);do{for(;O.isEven();)O.iushrn(1);for(;A.isEven();)A.iushrn(1);var q=O.cmp(A);if(q<0){var R=O;O=A,A=R}else if(q===0||A.cmpn(1)===0)break;O.isub(A)}while(!0);return A.iushln(V)},n.prototype.invm=function(v){return this.egcd(v).a.umod(v)},n.prototype.isEven=function(){return(this.words[0]&1)===0},n.prototype.isOdd=function(){return(this.words[0]&1)===1},n.prototype.andln=function(v){return this.words[0]&v},n.prototype.bincn=function(v){s(typeof v=="number");var O=v%26,A=(v-O)/26,V=1<<O;if(this.length<=A)return this._expand(A+1),this.words[A]|=V,this;for(var q=V,R=A;q!==0&&R<this.length;R++){var H=this.words[R]|0;H+=q,q=H>>>26,H&=67108863,this.words[R]=H}return q!==0&&(this.words[R]=q,this.length++),this},n.prototype.isZero=function(){return this.length===1&&this.words[0]===0},n.prototype.cmpn=function(v){var O=v<0;if(this.negative!==0&&!O)return-1;if(this.negative===0&&O)return 1;this._strip();var A;if(this.length>1)A=1;else{O&&(v=-v),s(v<=67108863,"Number is too big");var V=this.words[0]|0;A=V===v?0:V<v?-1:1}return this.negative!==0?-A|0:A},n.prototype.cmp=function(v){if(this.negative!==0&&v.negative===0)return-1;if(this.negative===0&&v.negative!==0)return 1;var O=this.ucmp(v);return this.negative!==0?-O|0:O},n.prototype.ucmp=function(v){if(this.length>v.length)return 1;if(this.length<v.length)return-1;for(var O=0,A=this.length-1;A>=0;A--){var V=this.words[A]|0,q=v.words[A]|0;if(V!==q){V<q?O=-1:V>q&&(O=1);break}}return O},n.prototype.gtn=function(v){return this.cmpn(v)===1},n.prototype.gt=function(v){return this.cmp(v)===1},n.prototype.gten=function(v){return this.cmpn(v)>=0},n.prototype.gte=function(v){return this.cmp(v)>=0},n.prototype.ltn=function(v){return this.cmpn(v)===-1},n.prototype.lt=function(v){return this.cmp(v)===-1},n.prototype.lten=function(v){return this.cmpn(v)<=0},n.prototype.lte=function(v){return this.cmp(v)<=0},n.prototype.eqn=function(v){return this.cmpn(v)===0},n.prototype.eq=function(v){return this.cmp(v)===0},n.red=function(v){return new N(v)},n.prototype.toRed=function(v){return s(!this.red,"Already a number in reduction context"),s(this.negative===0,"red works only with positives"),v.convertTo(this)._forceRed(v)},n.prototype.fromRed=function(){return s(this.red,"fromRed works only with numbers in reduction context"),this.red.convertFrom(this)},n.prototype._forceRed=function(v){return this.red=v,this},n.prototype.forceRed=function(v){return s(!this.red,"Already a number in reduction context"),this._forceRed(v)},n.prototype.redAdd=function(v){return s(this.red,"redAdd works only with red numbers"),this.red.add(this,v)},n.prototype.redIAdd=function(v){return s(this.red,"redIAdd works only with red numbers"),this.red.iadd(this,v)},n.prototype.redSub=function(v){return s(this.red,"redSub works only with red numbers"),this.red.sub(this,v)},n.prototype.redISub=function(v){return s(this.red,"redISub works only with red numbers"),this.red.isub(this,v)},n.prototype.redShl=function(v){return s(this.red,"redShl works only with red numbers"),this.red.shl(this,v)},n.prototype.redMul=function(v){return s(this.red,"redMul works only with red numbers"),this.red._verify2(this,v),this.red.mul(this,v)},n.prototype.redIMul=function(v){return s(this.red,"redMul works only with red numbers"),this.red._verify2(this,v),this.red.imul(this,v)},n.prototype.redSqr=function(){return s(this.red,"redSqr works only with red numbers"),this.red._verify1(this),this.red.sqr(this)},n.prototype.redISqr=function(){return s(this.red,"redISqr works only with red numbers"),this.red._verify1(this),this.red.isqr(this)},n.prototype.redSqrt=function(){return s(this.red,"redSqrt works only with red numbers"),this.red._verify1(this),this.red.sqrt(this)},n.prototype.redInvm=function(){return s(this.red,"redInvm works only with red numbers"),this.red._verify1(this),this.red.invm(this)},n.prototype.redNeg=function(){return s(this.red,"redNeg works only with red numbers"),this.red._verify1(this),this.red.neg(this)},n.prototype.redPow=function(v){return s(this.red&&!v.red,"redPow(normalNum)"),this.red._verify1(this),this.red.pow(this,v)};var w={k256:null,p224:null,p192:null,p25519:null};function S(x,v){this.name=x,this.p=new n(v,16),this.n=this.p.bitLength(),this.k=new n(1).iushln(this.n).isub(this.p),this.tmp=this._tmp()}S.prototype._tmp=function(){var v=new n(null);return v.words=new Array(Math.ceil(this.n/13)),v},S.prototype.ireduce=function(v){var O=v,A;do this.split(O,this.tmp),O=this.imulK(O),O=O.iadd(this.tmp),A=O.bitLength();while(A>this.n);var V=A<this.n?-1:O.ucmp(this.p);return V===0?(O.words[0]=0,O.length=1):V>0?O.isub(this.p):O._strip(),O},S.prototype.split=function(v,O){v.iushrn(this.n,0,O)},S.prototype.imulK=function(v){return v.imul(this.k)};function k(){S.call(this,"k256","ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")}i(k,S),k.prototype.split=function(v,O){for(var A=4194303,V=Math.min(v.length,9),q=0;q<V;q++)O.words[q]=v.words[q];if(O.length=V,v.length<=9){v.words[0]=0,v.length=1;return}var R=v.words[9];for(O.words[O.length++]=R&A,q=10;q<v.length;q++){var H=v.words[q]|0;v.words[q-10]=(H&A)<<4|R>>>22,R=H}R>>>=22,v.words[q-10]=R,R===0&&v.length>10?v.length-=10:v.length-=9},k.prototype.imulK=function(v){v.words[v.length]=0,v.words[v.length+1]=0,v.length+=2;for(var O=0,A=0;A<v.length;A++){var V=v.words[A]|0;O+=V*977,v.words[A]=O&67108863,O=V*64+(O/67108864|0)}return v.words[v.length-1]===0&&(v.length--,v.words[v.length-1]===0&&v.length--),v};function T(){S.call(this,"p224","ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")}i(T,S);function I(){S.call(this,"p192","ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")}i(I,S);function _(){S.call(this,"25519","7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")}i(_,S),_.prototype.imulK=function(v){for(var O=0,A=0;A<v.length;A++){var V=(v.words[A]|0)*19+O,q=V&67108863;V>>>=26,v.words[A]=q,O=V}return O!==0&&(v.words[v.length++]=O),v},n._prime=function(v){if(w[v])return w[v];var O;if(v==="k256")O=new k;else if(v==="p224")O=new T;else if(v==="p192")O=new I;else if(v==="p25519")O=new _;else throw new Error("Unknown prime "+v);return w[v]=O,O};function N(x){if(typeof x=="string"){var v=n._prime(x);this.m=v.p,this.prime=v}else s(x.gtn(1),"modulus must be greater than 1"),this.m=x,this.prime=null}N.prototype._verify1=function(v){s(v.negative===0,"red works only with positives"),s(v.red,"red works only with red numbers")},N.prototype._verify2=function(v,O){s((v.negative|O.negative)===0,"red works only with positives"),s(v.red&&v.red===O.red,"red works only with red numbers")},N.prototype.imod=function(v){return this.prime?this.prime.ireduce(v)._forceRed(this):(v.umod(this.m)._forceRed(this)._move(v),v)},N.prototype.neg=function(v){return v.isZero()?v.clone():this.m.sub(v)._forceRed(this)},N.prototype.add=function(v,O){this._verify2(v,O);var A=v.add(O);return A.cmp(this.m)>=0&&A.isub(this.m),A._forceRed(this)},N.prototype.iadd=function(v,O){this._verify2(v,O);var A=v.iadd(O);return A.cmp(this.m)>=0&&A.isub(this.m),A},N.prototype.sub=function(v,O){this._verify2(v,O);var A=v.sub(O);return A.cmpn(0)<0&&A.iadd(this.m),A._forceRed(this)},N.prototype.isub=function(v,O){this._verify2(v,O);var A=v.isub(O);return A.cmpn(0)<0&&A.iadd(this.m),A},N.prototype.shl=function(v,O){return this._verify1(v),this.imod(v.ushln(O))},N.prototype.imul=function(v,O){return this._verify2(v,O),this.imod(v.imul(O))},N.prototype.mul=function(v,O){return this._verify2(v,O),this.imod(v.mul(O))},N.prototype.isqr=function(v){return this.imul(v,v.clone())},N.prototype.sqr=function(v){return this.mul(v,v)},N.prototype.sqrt=function(v){if(v.isZero())return v.clone();var O=this.m.andln(3);if(s(O%2===1),O===3){var A=this.m.add(new n(1)).iushrn(2);return this.pow(v,A)}for(var V=this.m.subn(1),q=0;!V.isZero()&&V.andln(1)===0;)q++,V.iushrn(1);s(!V.isZero());var R=new n(1).toRed(this),H=R.redNeg(),F=this.m.subn(1).iushrn(1),P=this.m.bitLength();for(P=new n(2*P*P).toRed(this);this.pow(P,F).cmp(H)!==0;)P.redIAdd(H);for(var E=this.pow(P,V),j=this.pow(v,V.addn(1).iushrn(1)),X=this.pow(v,V),Q=q;X.cmp(R)!==0;){for(var Se=X,he=0;Se.cmp(R)!==0;he++)Se=Se.redSqr();s(he<Q);var xe=this.pow(E,new n(1).iushln(Q-he-1));j=j.redMul(xe),E=xe.redSqr(),X=X.redMul(E),Q=he}return j},N.prototype.invm=function(v){var O=v._invmp(this.m);return O.negative!==0?(O.negative=0,this.imod(O).redNeg()):this.imod(O)},N.prototype.pow=function(v,O){if(O.isZero())return new n(1).toRed(this);if(O.cmpn(1)===0)return v.clone();var A=4,V=new Array(1<<A);V[0]=new n(1).toRed(this),V[1]=v;for(var q=2;q<V.length;q++)V[q]=this.mul(V[q-1],v);var R=V[0],H=0,F=0,P=O.bitLength()%26;for(P===0&&(P=26),q=O.length-1;q>=0;q--){for(var E=O.words[q],j=P-1;j>=0;j--){var X=E>>j&1;if(R!==V[0]&&(R=this.sqr(R)),X===0&&H===0){F=0;continue}H<<=1,H|=X,F++,!(F!==A&&(q!==0||j!==0))&&(R=this.mul(R,V[H]),F=0,H=0)}P=26}return R},N.prototype.convertTo=function(v){var O=v.umod(this.m);return O===v?O.clone():O},N.prototype.convertFrom=function(v){var O=v.clone();return O.red=null,O},n.mont=function(v){return new M(v)};function M(x){N.call(this,x),this.shift=this.m.bitLength(),this.shift%26!==0&&(this.shift+=26-this.shift%26),this.r=new n(1).iushln(this.shift),this.r2=this.imod(this.r.sqr()),this.rinv=this.r._invmp(this.m),this.minv=this.rinv.mul(this.r).isubn(1).div(this.m),this.minv=this.minv.umod(this.r),this.minv=this.r.sub(this.minv)}i(M,N),M.prototype.convertTo=function(v){return this.imod(v.ushln(this.shift))},M.prototype.convertFrom=function(v){var O=this.imod(v.mul(this.rinv));return O.red=null,O},M.prototype.imul=function(v,O){if(v.isZero()||O.isZero())return v.words[0]=0,v.length=1,v;var A=v.imul(O),V=A.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),q=A.isub(V).iushrn(this.shift),R=q;return q.cmp(this.m)>=0?R=q.isub(this.m):q.cmpn(0)<0&&(R=q.iadd(this.m)),R._forceRed(this)},M.prototype.mul=function(v,O){if(v.isZero()||O.isZero())return new n(0)._forceRed(this);var A=v.mul(O),V=A.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),q=A.isub(V).iushrn(this.shift),R=q;return q.cmp(this.m)>=0?R=q.isub(this.m):q.cmpn(0)<0&&(R=q.iadd(this.m)),R._forceRed(this)},M.prototype.invm=function(v){var O=this.imod(v._invmp(this.m).mul(this.r2));return O._forceRed(this)}})(f,jh)})(Fi);(function(f){const e=_d.exports,t=IN,s=Fi.exports,i="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";let n=null,r=null;f.exports={json:(o,d=void 0)=>JSON.stringify(o),isJsonEncodedObject:o=>typeof o=="string"&&o.length>=2&&(o[0]==="{"||o[0]==="["),stringToBinary:o=>e.enc.Latin1.parse(o),stringToBase64:o=>e.enc.Latin1.parse(o).toString(e.enc.Base64),base64ToBinary:o=>e.enc.Base64.parse(o),base64ToString:o=>e.enc.Base64.parse(o).toString(e.enc.Utf8),binaryToBase64:o=>o.toString(e.enc.Base64),base16ToBinary:o=>e.enc.Hex.parse(o),binaryToBase16:o=>o.toString(e.enc.Hex),binaryConcat:(...o)=>o.reduce((d,c)=>d.concat(c)),binaryConcatArray:o=>o.reduce((d,c)=>d.concat(c)),urlencode:o=>t.stringify(o),urlencodeNested:o=>t.stringify(o),urlencodeWithArrayRepeat:o=>t.stringify(o,{arrayFormat:"repeat"}),rawencode:o=>t.stringify(o,{encode:!1}),encode:o=>o,decode:o=>o,urlencodeBase64:o=>o.replace(/[=]+$/,"").replace(/\+/g,"-").replace(/\//g,"_"),numberToLE:(o,d)=>{const c=new s(o).toArray("le",d);return a(c)},numberToBE:(o,d)=>{const c=new s(o).toArray("be",d);return a(c)},base58ToBinary:o=>{if(!n){n={},r={};for(let u=0;u<58;u++){const h=i[u],l=new s(u);n[h]=l,r[l]=h}}let d=new s(0);const c=new s(58);for(let u=0;u<o.length;u++){const h=o[u];d.imul(c),d.iadd(n[h])}return a(d.toArray("be"))},binaryToBase58:o=>{if(!r){n={},r={};for(let l=0;l<58;l++){const p=i[l],m=new s(l);n[p]=m,r[m]=p}}const d=new s(58),c=o.toString(e.enc.Hex);let u=new s(c,16),h=[];for(;!u.isZero();){const{div:l,mod:p}=u.divmod(d);u=l,h.push(r[p])}return h.reverse().join("")}};function a(o){const d=[];for(let c=0;c<o.length;c++)d[c/4|0]|=o[c]<<24-8*c;return e.lib.WordArray.create(d,o.length)}f.exports.byteArrayToWordArray=a})(xd);var Ux={},Ci={};Ci.linebrk=function(f,e){for(var t="",s=0;s+e<f.length;)t+=f.substring(s,s+e)+`
`,s+=e;return t+f.substring(s,f.length)};Ci.get32IntFromBuffer=function(f,e){e=e||0;var t=0;if((t=f.length-e)>0){if(t>=4)return f.readUInt32BE(e);for(var s=0,i=e+t,n=0;i>e;i--,n+=2)s+=f[i-1]*Math.pow(16,n);return s}else return NaN};Ci._={isObject:function(f){var e=typeof f;return!!f&&(e=="object"||e=="function")},isString:function(f){return typeof f=="string"||f instanceof String},isNumber:function(f){return typeof f=="number"||!isNaN(parseFloat(f))&&isFinite(f)},omit:function(f,e){var t={};for(var s in f)!f.hasOwnProperty(s)||s===e||(t[s]=f[s]);return t}};Ci.trimSurroundingText=function(f,e,t){var s=0,i=f.length,n=f.indexOf(e);n>=0&&(s=n+e.length);var r=f.indexOf(t,n);return r>=0&&(i=r),f.substring(s,i)};var xN=Ci._,Cd;function Pe(f,e){f!=null&&(typeof f=="number"?this.fromNumber(f,e):Buffer.isBuffer(f)?this.fromBuffer(f):e==null&&typeof f!="string"?this.fromByteArray(f):this.fromString(f,e))}function kt(){return new Pe(null)}function _N(f,e,t,s,i,n){for(var r=e&16383,a=e>>14;--n>=0;){var o=this[f]&16383,d=this[f++]>>14,c=a*o+d*r;o=r*o+((c&16383)<<14)+t[s]+i,i=(o>>28)+(c>>14)+a*d,t[s++]=o&268435455}return i}Pe.prototype.am=_N;Cd=28;Pe.prototype.DB=Cd;Pe.prototype.DM=(1<<Cd)-1;Pe.prototype.DV=1<<Cd;var fb=52;Pe.prototype.FV=Math.pow(2,fb);Pe.prototype.F1=fb-Cd;Pe.prototype.F2=2*Cd-fb;var CN="0123456789abcdefghijklmnopqrstuvwxyz",Pl=new Array,Md,an;Md="0".charCodeAt(0);for(an=0;an<=9;++an)Pl[Md++]=an;Md="a".charCodeAt(0);for(an=10;an<36;++an)Pl[Md++]=an;Md="A".charCodeAt(0);for(an=10;an<36;++an)Pl[Md++]=an;function cy(f){return CN.charAt(f)}function $x(f,e){var t=Pl[f.charCodeAt(e)];return t==null?-1:t}function MN(f){for(var e=this.t-1;e>=0;--e)f[e]=this[e];f.t=this.t,f.s=this.s}function PN(f){this.t=1,this.s=f<0?-1:0,f>0?this[0]=f:f<-1?this[0]=f+DV:this.t=0}function Al(f){var e=kt();return e.fromInt(f),e}function AN(f,e,t){var s;switch(e){case 2:s=1;break;case 4:s=2;break;case 8:s=3;break;case 16:s=4;break;case 32:s=5;break;case 256:s=8;break;default:this.fromRadix(f,e);return}this.t=0,this.s=0;for(var i=f.length,n=!1,r=0;--i>=0;){var a=s==8?f[i]&255:$x(f,i);if(a<0){f.charAt(i)=="-"&&(n=!0);continue}n=!1,r===0?this[this.t++]=a:r+s>this.DB?(this[this.t-1]|=(a&(1<<this.DB-r)-1)<<r,this[this.t++]=a>>this.DB-r):this[this.t-1]|=a<<r,r+=s,r>=this.DB&&(r-=this.DB)}!t&&s==8&&(f[0]&128)!=0&&(this.s=-1,r>0&&(this[this.t-1]|=(1<<this.DB-r)-1<<r)),this.clamp(),n&&Pe.ZERO.subTo(this,this)}function BN(f,e){this.fromString(f,256,e)}function NN(f){this.fromString(f,256,!0)}function EN(){for(var f=this.s&this.DM;this.t>0&&this[this.t-1]==f;)--this.t}function VN(f){if(this.s<0)return"-"+this.negate().toString(f);var e;if(f==16)e=4;else if(f==8)e=3;else if(f==2)e=1;else if(f==32)e=5;else if(f==4)e=2;else return this.toRadix(f);var t=(1<<e)-1,s,i=!1,n="",r=this.t,a=this.DB-r*this.DB%e;if(r-- >0)for(a<this.DB&&(s=this[r]>>a)>0&&(i=!0,n=cy(s));r>=0;)a<e?(s=(this[r]&(1<<a)-1)<<e-a,s|=this[--r]>>(a+=this.DB-e)):(s=this[r]>>(a-=e)&t,a<=0&&(a+=this.DB,--r)),s>0&&(i=!0),i&&(n+=cy(s));return i?n:"0"}function qN(){var f=kt();return Pe.ZERO.subTo(this,f),f}function LN(){return this.s<0?this.negate():this}function RN(f){var e=this.s-f.s;if(e!=0)return e;var t=this.t;if(e=t-f.t,e!=0)return this.s<0?-e:e;for(;--t>=0;)if((e=this[t]-f[t])!=0)return e;return 0}function Bl(f){var e=1,t;return(t=f>>>16)!=0&&(f=t,e+=16),(t=f>>8)!=0&&(f=t,e+=8),(t=f>>4)!=0&&(f=t,e+=4),(t=f>>2)!=0&&(f=t,e+=2),(t=f>>1)!=0&&(f=t,e+=1),e}function FN(){return this.t<=0?0:this.DB*(this.t-1)+Bl(this[this.t-1]^this.s&this.DM)}function DN(f,e){var t;for(t=this.t-1;t>=0;--t)e[t+f]=this[t];for(t=f-1;t>=0;--t)e[t]=0;e.t=this.t+f,e.s=this.s}function HN(f,e){for(var t=f;t<this.t;++t)e[t-f]=this[t];e.t=Math.max(this.t-f,0),e.s=this.s}function GN(f,e){var t=f%this.DB,s=this.DB-t,i=(1<<s)-1,n=Math.floor(f/this.DB),r=this.s<<t&this.DM,a;for(a=this.t-1;a>=0;--a)e[a+n+1]=this[a]>>s|r,r=(this[a]&i)<<t;for(a=n-1;a>=0;--a)e[a]=0;e[n]=r,e.t=this.t+n+1,e.s=this.s,e.clamp()}function UN(f,e){e.s=this.s;var t=Math.floor(f/this.DB);if(t>=this.t){e.t=0;return}var s=f%this.DB,i=this.DB-s,n=(1<<s)-1;e[0]=this[t]>>s;for(var r=t+1;r<this.t;++r)e[r-t-1]|=(this[r]&n)<<i,e[r-t]=this[r]>>s;s>0&&(e[this.t-t-1]|=(this.s&n)<<i),e.t=this.t-t,e.clamp()}function $N(f,e){for(var t=0,s=0,i=Math.min(f.t,this.t);t<i;)s+=this[t]-f[t],e[t++]=s&this.DM,s>>=this.DB;if(f.t<this.t){for(s-=f.s;t<this.t;)s+=this[t],e[t++]=s&this.DM,s>>=this.DB;s+=this.s}else{for(s+=this.s;t<f.t;)s-=f[t],e[t++]=s&this.DM,s>>=this.DB;s-=f.s}e.s=s<0?-1:0,s<-1?e[t++]=this.DV+s:s>0&&(e[t++]=s),e.t=t,e.clamp()}function jN(f,e){var t=this.abs(),s=f.abs(),i=t.t;for(e.t=i+s.t;--i>=0;)e[i]=0;for(i=0;i<s.t;++i)e[i+t.t]=t.am(0,s[i],e,i,0,t.t);e.s=0,e.clamp(),this.s!=f.s&&Pe.ZERO.subTo(e,e)}function WN(f){for(var e=this.abs(),t=f.t=2*e.t;--t>=0;)f[t]=0;for(t=0;t<e.t-1;++t){var s=e.am(t,e[t],f,2*t,0,1);(f[t+e.t]+=e.am(t+1,2*e[t],f,2*t+1,s,e.t-t-1))>=e.DV&&(f[t+e.t]-=e.DV,f[t+e.t+1]=1)}f.t>0&&(f[f.t-1]+=e.am(t,e[t],f,2*t,0,1)),f.s=0,f.clamp()}function zN(f,e,t){var s=f.abs();if(!(s.t<=0)){var i=this.abs();if(i.t<s.t){e!=null&&e.fromInt(0),t!=null&&this.copyTo(t);return}t==null&&(t=kt());var n=kt(),r=this.s,a=f.s,o=this.DB-Bl(s[s.t-1]);o>0?(s.lShiftTo(o,n),i.lShiftTo(o,t)):(s.copyTo(n),i.copyTo(t));var d=n.t,c=n[d-1];if(c!==0){var u=c*(1<<this.F1)+(d>1?n[d-2]>>this.F2:0),h=this.FV/u,l=(1<<this.F1)/u,p=1<<this.F2,m=t.t,g=m-d,y=e==null?kt():e;for(n.dlShiftTo(g,y),t.compareTo(y)>=0&&(t[t.t++]=1,t.subTo(y,t)),Pe.ONE.dlShiftTo(d,y),y.subTo(n,n);n.t<d;)n[n.t++]=0;for(;--g>=0;){var b=t[--m]==c?this.DM:Math.floor(t[m]*h+(t[m-1]+p)*l);if((t[m]+=n.am(0,b,t,g,0,d))<b)for(n.dlShiftTo(g,y),t.subTo(y,t);t[m]<--b;)t.subTo(y,t)}e!=null&&(t.drShiftTo(d,e),r!=a&&Pe.ZERO.subTo(e,e)),t.t=d,t.clamp(),o>0&&t.rShiftTo(o,t),r<0&&Pe.ZERO.subTo(t,t)}}}function KN(f){var e=kt();return this.abs().divRemTo(f,null,e),this.s<0&&e.compareTo(Pe.ZERO)>0&&f.subTo(e,e),e}function Pd(f){this.m=f}function XN(f){return f.s<0||f.compareTo(this.m)>=0?f.mod(this.m):f}function YN(f){return f}function QN(f){f.divRemTo(this.m,null,f)}function ZN(f,e,t){f.multiplyTo(e,t),this.reduce(t)}function JN(f,e){f.squareTo(e),this.reduce(e)}Pd.prototype.convert=XN;Pd.prototype.revert=YN;Pd.prototype.reduce=QN;Pd.prototype.mulTo=ZN;Pd.prototype.sqrTo=JN;function eE(){if(this.t<1)return 0;var f=this[0];if((f&1)===0)return 0;var e=f&3;return e=e*(2-(f&15)*e)&15,e=e*(2-(f&255)*e)&255,e=e*(2-((f&65535)*e&65535))&65535,e=e*(2-f*e%this.DV)%this.DV,e>0?this.DV-e:-e}function Ad(f){this.m=f,this.mp=f.invDigit(),this.mpl=this.mp&32767,this.mph=this.mp>>15,this.um=(1<<f.DB-15)-1,this.mt2=2*f.t}function tE(f){var e=kt();return f.abs().dlShiftTo(this.m.t,e),e.divRemTo(this.m,null,e),f.s<0&&e.compareTo(Pe.ZERO)>0&&this.m.subTo(e,e),e}function sE(f){var e=kt();return f.copyTo(e),this.reduce(e),e}function iE(f){for(;f.t<=this.mt2;)f[f.t++]=0;for(var e=0;e<this.m.t;++e){var t=f[e]&32767,s=t*this.mpl+((t*this.mph+(f[e]>>15)*this.mpl&this.um)<<15)&f.DM;for(t=e+this.m.t,f[t]+=this.m.am(0,s,f,e,0,this.m.t);f[t]>=f.DV;)f[t]-=f.DV,f[++t]++}f.clamp(),f.drShiftTo(this.m.t,f),f.compareTo(this.m)>=0&&f.subTo(this.m,f)}function nE(f,e){f.squareTo(e),this.reduce(e)}function rE(f,e,t){f.multiplyTo(e,t),this.reduce(t)}Ad.prototype.convert=tE;Ad.prototype.revert=sE;Ad.prototype.reduce=iE;Ad.prototype.mulTo=rE;Ad.prototype.sqrTo=nE;function aE(){return(this.t>0?this[0]&1:this.s)===0}function oE(f,e){if(f>4294967295||f<1)return Pe.ONE;var t=kt(),s=kt(),i=e.convert(this),n=Bl(f)-1;for(i.copyTo(t);--n>=0;)if(e.sqrTo(t,s),(f&1<<n)>0)e.mulTo(s,i,t);else{var r=t;t=s,s=r}return e.revert(t)}function dE(){var f=kt();return this.copyTo(f),f}function cE(){if(this.s<0){if(this.t==1)return this[0]-this.DV;if(this.t===0)return-1}else{if(this.t==1)return this[0];if(this.t===0)return 0}return(this[1]&(1<<32-this.DB)-1)<<this.DB|this[0]}function uE(f){return Math.floor(Math.LN2*this.DB/Math.log(f))}function fE(){return this.s<0?-1:this.t<=0||this.t==1&&this[0]<=0?0:1}function hE(f){if(f==null&&(f=10),this.signum()===0||f<2||f>36)return"0";var e=this.chunkSize(f),t=Math.pow(f,e),s=Al(t),i=kt(),n=kt(),r="";for(this.divRemTo(s,i,n);i.signum()>0;)r=(t+n.intValue()).toString(f).substr(1)+r,i.divRemTo(s,i,n);return n.intValue().toString(f)+r}function lE(f,e){this.fromInt(0),e==null&&(e=10);for(var t=this.chunkSize(e),s=Math.pow(e,t),i=!1,n=0,r=0,a=0;a<f.length;++a){var o=$x(f,a);if(o<0){f.charAt(a)=="-"&&this.signum()===0&&(i=!0);continue}r=e*r+o,++n>=t&&(this.dMultiply(s),this.dAddOffset(r,0),n=0,r=0)}n>0&&(this.dMultiply(Math.pow(e,n)),this.dAddOffset(r,0)),i&&Pe.ZERO.subTo(this,this)}function pE(){var f=this.t,e=new Array;e[0]=this.s;var t=this.DB-f*this.DB%8,s,i=0;if(f-- >0)for(t<this.DB&&(s=this[f]>>t)!=(this.s&this.DM)>>t&&(e[i++]=s|this.s<<this.DB-t);f>=0;)t<8?(s=(this[f]&(1<<t)-1)<<8-t,s|=this[--f]>>(t+=this.DB-8)):(s=this[f]>>(t-=8)&255,t<=0&&(t+=this.DB,--f)),(s&128)!=0&&(s|=-256),i===0&&(this.s&128)!=(s&128)&&++i,(i>0||s!=this.s)&&(e[i++]=s);return e}function mE(f){var e=Buffer.from(this.toByteArray());if(f===!0&&e[0]===0)e=e.slice(1);else if(xN.isNumber(f)){if(e.length>f){for(var t=0;t<e.length-f;t++)if(e[t]!==0)return null;return e.slice(e.length-f)}else if(e.length<f){var s=Buffer.alloc(f);return s.fill(0,0,f-e.length),e.copy(s,f-e.length),s}}return e}function gE(f){return this.compareTo(f)==0}function yE(f){return this.compareTo(f)<0?this:f}function bE(f){return this.compareTo(f)>0?this:f}function wE(f,e,t){var s,i,n=Math.min(f.t,this.t);for(s=0;s<n;++s)t[s]=e(this[s],f[s]);if(f.t<this.t){for(i=f.s&this.DM,s=n;s<this.t;++s)t[s]=e(this[s],i);t.t=this.t}else{for(i=this.s&this.DM,s=n;s<f.t;++s)t[s]=e(i,f[s]);t.t=f.t}t.s=e(this.s,f.s),t.clamp()}function SE(f,e){return f&e}function kE(f){var e=kt();return this.bitwiseTo(f,SE,e),e}function vE(f,e){return f|e}function TE(f){var e=kt();return this.bitwiseTo(f,vE,e),e}function OE(f,e){return f^e}function IE(f){var e=kt();return this.bitwiseTo(f,OE,e),e}function xE(){for(var f=kt(),e=0;e<this.t;++e)f[e]=this.DM&~this[e];return f.t=this.t,f.s=~this.s,f}function _E(f){if(f===0)return-1;var e=0;return(f&65535)===0&&(f>>=16,e+=16),(f&255)===0&&(f>>=8,e+=8),(f&15)===0&&(f>>=4,e+=4),(f&3)===0&&(f>>=2,e+=2),(f&1)===0&&++e,e}function CE(){for(var f=0;f<this.t;++f)if(this[f]!=0)return f*this.DB+_E(this[f]);return this.s<0?this.t*this.DB:-1}function ME(f,e){for(var t=0,s=0,i=Math.min(f.t,this.t);t<i;)s+=this[t]+f[t],e[t++]=s&this.DM,s>>=this.DB;if(f.t<this.t){for(s+=f.s;t<this.t;)s+=this[t],e[t++]=s&this.DM,s>>=this.DB;s+=this.s}else{for(s+=this.s;t<f.t;)s+=f[t],e[t++]=s&this.DM,s>>=this.DB;s+=f.s}e.s=s<0?-1:0,s>0?e[t++]=s:s<-1&&(e[t++]=this.DV+s),e.t=t,e.clamp()}function PE(f){var e=kt();return this.addTo(f,e),e}function AE(f){var e=kt();return this.subTo(f,e),e}function BE(f){var e=kt();return this.multiplyTo(f,e),e}function NE(){var f=kt();return this.squareTo(f),f}function EE(f){var e=kt();return this.divRemTo(f,e,null),e}function VE(f){var e=kt();return this.divRemTo(f,null,e),e}function qE(f){this[this.t]=this.am(0,f-1,this,0,0,this.t),++this.t,this.clamp()}function LE(f,e){if(f!==0){for(;this.t<=e;)this[this.t++]=0;for(this[e]+=f;this[e]>=this.DV;)this[e]-=this.DV,++e>=this.t&&(this[this.t++]=0),++this[e]}}function Cu(){}function jx(f){return f}function RE(f,e,t){f.multiplyTo(e,t)}function FE(f,e){f.squareTo(e)}Cu.prototype.convert=jx;Cu.prototype.revert=jx;Cu.prototype.mulTo=RE;Cu.prototype.sqrTo=FE;function DE(f){return this.exp(f,new Cu)}function HE(f,e,t){var s=Math.min(this.t+f.t,e);for(t.s=0,t.t=s;s>0;)t[--s]=0;var i;for(i=t.t-this.t;s<i;++s)t[s+this.t]=this.am(0,f[s],t,s,0,this.t);for(i=Math.min(f.t,e);s<i;++s)this.am(0,f[s],t,s,0,e-s);t.clamp()}function GE(f,e,t){--e;var s=t.t=this.t+f.t-e;for(t.s=0;--s>=0;)t[s]=0;for(s=Math.max(e-this.t,0);s<f.t;++s)t[this.t+s-e]=this.am(e-s,f[s],t,0,0,this.t+s-e);t.clamp(),t.drShiftTo(1,t)}function Bd(f){this.r2=kt(),this.q3=kt(),Pe.ONE.dlShiftTo(2*f.t,this.r2),this.mu=this.r2.divide(f),this.m=f}function UE(f){if(f.s<0||f.t>2*this.m.t)return f.mod(this.m);if(f.compareTo(this.m)<0)return f;var e=kt();return f.copyTo(e),this.reduce(e),e}function $E(f){return f}function jE(f){for(f.drShiftTo(this.m.t-1,this.r2),f.t>this.m.t+1&&(f.t=this.m.t+1,f.clamp()),this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3),this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);f.compareTo(this.r2)<0;)f.dAddOffset(1,this.m.t+1);for(f.subTo(this.r2,f);f.compareTo(this.m)>=0;)f.subTo(this.m,f)}function WE(f,e){f.squareTo(e),this.reduce(e)}function zE(f,e,t){f.multiplyTo(e,t),this.reduce(t)}Bd.prototype.convert=UE;Bd.prototype.revert=$E;Bd.prototype.reduce=jE;Bd.prototype.mulTo=zE;Bd.prototype.sqrTo=WE;function KE(f,e){var t=f.bitLength(),s,i=Al(1),n;if(t<=0)return i;t<18?s=1:t<48?s=3:t<144?s=4:t<768?s=5:s=6,t<8?n=new Pd(e):e.isEven()?n=new Bd(e):n=new Ad(e);var r=new Array,a=3,o=s-1,d=(1<<s)-1;if(r[1]=n.convert(this),s>1){var c=kt();for(n.sqrTo(r[1],c);a<=d;)r[a]=kt(),n.mulTo(c,r[a-2],r[a]),a+=2}var u=f.t-1,h,l=!0,p=kt(),m;for(t=Bl(f[u])-1;u>=0;){for(t>=o?h=f[u]>>t-o&d:(h=(f[u]&(1<<t+1)-1)<<o-t,u>0&&(h|=f[u-1]>>this.DB+t-o)),a=s;(h&1)===0;)h>>=1,--a;if((t-=a)<0&&(t+=this.DB,--u),l)r[h].copyTo(i),l=!1;else{for(;a>1;)n.sqrTo(i,p),n.sqrTo(p,i),a-=2;a>0?n.sqrTo(i,p):(m=i,i=p,p=m),n.mulTo(p,r[h],i)}for(;u>=0&&(f[u]&1<<t)===0;)n.sqrTo(i,p),m=i,i=p,p=m,--t<0&&(t=this.DB-1,--u)}return n.revert(i)}function XE(f){var e=this.s<0?this.negate():this.clone(),t=f.s<0?f.negate():f.clone();if(e.compareTo(t)<0){var s=e;e=t,t=s}var i=e.getLowestSetBit(),n=t.getLowestSetBit();if(n<0)return e;for(i<n&&(n=i),n>0&&(e.rShiftTo(n,e),t.rShiftTo(n,t));e.signum()>0;)(i=e.getLowestSetBit())>0&&e.rShiftTo(i,e),(i=t.getLowestSetBit())>0&&t.rShiftTo(i,t),e.compareTo(t)>=0?(e.subTo(t,e),e.rShiftTo(1,e)):(t.subTo(e,t),t.rShiftTo(1,t));return n>0&&t.lShiftTo(n,t),t}Pe.prototype.copyTo=MN;Pe.prototype.fromInt=PN;Pe.prototype.fromString=AN;Pe.prototype.fromByteArray=BN;Pe.prototype.fromBuffer=NN;Pe.prototype.clamp=EN;Pe.prototype.dlShiftTo=DN;Pe.prototype.drShiftTo=HN;Pe.prototype.lShiftTo=GN;Pe.prototype.rShiftTo=UN;Pe.prototype.subTo=$N;Pe.prototype.multiplyTo=jN;Pe.prototype.squareTo=WN;Pe.prototype.divRemTo=zN;Pe.prototype.invDigit=eE;Pe.prototype.isEven=aE;Pe.prototype.exp=oE;Pe.prototype.chunkSize=uE;Pe.prototype.toRadix=hE;Pe.prototype.fromRadix=lE;Pe.prototype.bitwiseTo=wE;Pe.prototype.addTo=ME;Pe.prototype.dMultiply=qE;Pe.prototype.dAddOffset=LE;Pe.prototype.multiplyLowerTo=HE;Pe.prototype.multiplyUpperTo=GE;Pe.prototype.toString=VN;Pe.prototype.negate=qN;Pe.prototype.abs=LN;Pe.prototype.compareTo=RN;Pe.prototype.bitLength=FN;Pe.prototype.mod=KN;Pe.prototype.clone=dE;Pe.prototype.intValue=cE;Pe.prototype.signum=fE;Pe.prototype.toByteArray=pE;Pe.prototype.toBuffer=mE;Pe.prototype.equals=gE;Pe.prototype.min=yE;Pe.prototype.max=bE;Pe.prototype.and=kE;Pe.prototype.or=TE;Pe.prototype.xor=IE;Pe.prototype.not=xE;Pe.prototype.getLowestSetBit=CE;Pe.prototype.add=PE;Pe.prototype.subtract=AE;Pe.prototype.multiply=BE;Pe.prototype.divide=EE;Pe.prototype.remainder=VE;Pe.prototype.modPow=KE;Pe.prototype.pow=DE;Pe.prototype.gcd=XE;Pe.int2char=cy;Pe.ZERO=Al(0);Pe.ONE=Al(1);Pe.prototype.square=NE;var Wx=Pe,hb={exports:{}},lb={exports:{}},YE=Wx,QE=_d.exports,Jw={RSA_NO_PADDING:3},ZE={md2:Buffer.from("3020300c06082a864886f70d020205000410","hex"),md5:Buffer.from("3020300c06082a864886f70d020505000410","hex"),sha1:Buffer.from("3021300906052b0e03021a05000414","hex"),sha224:Buffer.from("302d300d06096086480165030402040500041c","hex"),sha256:Buffer.from("3031300d060960864801650304020105000420","hex"),sha384:Buffer.from("3041300d060960864801650304020205000430","hex"),sha512:Buffer.from("3051300d060960864801650304020305000440","hex"),ripemd160:Buffer.from("3021300906052b2403020105000414","hex"),rmd160:Buffer.from("3021300906052b2403020105000414","hex")},JE={ripemd160:"rmd160"},e3="sha256";lb.exports={isEncryption:!0,isSignature:!0};lb.exports.makeScheme=function(f,e){function t(s,i){this.key=s,this.options=i}return t.prototype.maxMessageLength=function(){return this.options.encryptionSchemeOptions&&this.options.encryptionSchemeOptions.padding==Jw.RSA_NO_PADDING?this.key.encryptedDataLength:this.key.encryptedDataLength-11},t.prototype.encUnPad=function(s,i){i=i||{};var n=0;if(this.options.encryptionSchemeOptions&&this.options.encryptionSchemeOptions.padding==Jw.RSA_NO_PADDING){var r;return typeof s.lastIndexOf=="function"?r=s.slice(s.lastIndexOf("\0")+1,s.length):r=s.slice(String.prototype.lastIndexOf.call(s,"\0")+1,s.length),r}if(s.length<4)return null;if(i.type===1){if(s[0]!==0&&s[1]!==1)return null;for(n=3;s[n]!==0;)if(s[n]!=255||++n>=s.length)return null}else{if(s[0]!==0&&s[1]!==2)return null;for(n=3;s[n]!==0;)if(++n>=s.length)return null}return s.slice(n+1,s.length)},t.prototype.sign=function(s){var i=this.options.signingSchemeOptions.hash||e3;if(this.options.environment==="browser"){i=JE[i]||i;var n=QE[i.toUpperCase()](s.toString()),r=s3(n),a=this.pkcs1pad(r,i),o=this.key.$doPrivate(new YE(a)).toBuffer(this.key.encryptedDataLength);return o}else throw new Error("CCXT only supports browser mode :P")},t.prototype.pkcs1pad=function(s,i){var n=ZE[i];if(!n)throw Error("Unsupported hash algorithm");var r=Buffer.concat([n,s]);if(r.length+10>this.key.encryptedDataLength)throw Error("Key is too short for signing algorithm ("+i+")");var a=Buffer.alloc(this.key.encryptedDataLength-r.length-1);a.fill(255,0,a.length-1),a[0]=1,a[a.length-1]=0;var o=Buffer.concat([a,r]);return o},new t(f,e)};function t3(f,e){var t=[],s=255;return e>0&&t.push(f>>>24),e>1&&t.push(f>>>16&s),e>2&&t.push(f>>>8&s),e>3&&t.push(f&s),t}function s3(f){let e;if(f.hasOwnProperty("sigBytes")&&f.hasOwnProperty("words"))e=f.sigBytes,f=f.words;else throw Error("Argument not a wordArray");const t=[];let s=[],i=0;for(;e>0;)s=t3(f[i],Math.min(4,e)),e-=s.length,t.push(s),i++;return new Buffer.from([].concat.apply([],t),"hex")}(function(f){f.exports={pkcs1:lb.exports,isEncryption:function(e){return f.exports[e]&&f.exports[e].isEncryption},isSignature:function(e){return f.exports[e]&&f.exports[e].isSignature}}})(hb);var e1=Ci._,ka=Wx,i3=Ci,t1=hb.exports;Ux.Key=function(){function f(){this.n=null,this.e=0,this.d=null,this.p=null,this.q=null,this.dmp1=null,this.dmq1=null,this.coeff=null}return f.prototype.setOptions=function(e){var t=t1[e.signingScheme],s=t1[e.encryptionScheme];t===s?this.signingScheme=this.encryptionScheme=s.makeScheme(this,e):(this.encryptionScheme=s.makeScheme(this,e),this.signingScheme=t.makeScheme(this,e))},f.prototype.setPrivate=function(e,t,s,i,n,r,a,o){if(e&&t&&s&&e.length>0&&(e1.isNumber(t)||t.length>0)&&s.length>0)this.n=new ka(e),this.e=e1.isNumber(t)?t:i3.get32IntFromBuffer(t,0),this.d=new ka(s),i&&n&&r&&a&&o&&(this.p=new ka(i),this.q=new ka(n),this.dmp1=new ka(r),this.dmq1=new ka(a),this.coeff=new ka(o)),this.$$recalculateCache();else throw Error("Invalid RSA private key")},f.prototype.$doPrivate=function(e){if(this.p||this.q)return e.modPow(this.d,this.n);for(var t=e.mod(this.p).modPow(this.dmp1,this.p),s=e.mod(this.q).modPow(this.dmq1,this.q);t.compareTo(s)<0;)t=t.add(this.p);return t.subtract(s).multiply(this.coeff).mod(this.p).multiply(this.q).add(s)},f.prototype.sign=function(e){return this.signingScheme.sign.apply(this.signingScheme,arguments)},f.prototype.isPrivate=function(){return this.n&&this.e&&this.d||!1},Object.defineProperty(f.prototype,"keySize",{get:function(){return this.cache.keyBitLength}}),Object.defineProperty(f.prototype,"encryptedDataLength",{get:function(){return this.cache.keyByteLength}}),Object.defineProperty(f.prototype,"maxMessageLength",{get:function(){return this.encryptionScheme.maxMessageLength()}}),f.prototype.$$recalculateCache=function(){this.cache=this.cache||{},this.cache.keyBitLength=this.n.bitLength(),this.cache.keyByteLength=this.cache.keyBitLength+6>>3},f}();var zx={exports:{}},Kx={exports:{}},Xx={exports:{}},Yx={newInvalidAsn1Error:function(f){var e=new Error;return e.name="InvalidAsn1Error",e.message=f||"",e}},Qx={EOC:0,Boolean:1,Integer:2,BitString:3,OctetString:4,Null:5,OID:6,ObjectDescriptor:7,External:8,Real:9,Enumeration:10,PDV:11,Utf8String:12,RelativeOID:13,Sequence:16,Set:17,NumericString:18,PrintableString:19,T61String:20,VideotexString:21,IA5String:22,UTCTime:23,GeneralizedTime:24,GraphicString:25,VisibleString:26,GeneralString:28,UniversalString:29,CharacterString:30,BMPString:31,Constructor:32,Context:128},n3=Mt,Mu=Qx,r3=Yx,md=r3.newInvalidAsn1Error;function li(f){if(!f||!Buffer.isBuffer(f))throw new TypeError("data must be a node Buffer");this._buf=f,this._size=f.length,this._len=0,this._offset=0}Object.defineProperty(li.prototype,"length",{enumerable:!0,get:function(){return this._len}});Object.defineProperty(li.prototype,"offset",{enumerable:!0,get:function(){return this._offset}});Object.defineProperty(li.prototype,"remain",{get:function(){return this._size-this._offset}});Object.defineProperty(li.prototype,"buffer",{get:function(){return this._buf.slice(this._offset)}});li.prototype.readByte=function(f){if(this._size-this._offset<1)return null;var e=this._buf[this._offset]&255;return f||(this._offset+=1),e};li.prototype.peek=function(){return this.readByte(!0)};li.prototype.readLength=function(f){if(f===void 0&&(f=this._offset),f>=this._size)return null;var e=this._buf[f++]&255;if(e===null)return null;if((e&128)===128){if(e&=127,e===0)throw md("Indefinite length not supported");if(e>4)throw md("encoding too long");if(this._size-f<e)return null;this._len=0;for(var t=0;t<e;t++)this._len=(this._len<<8)+(this._buf[f++]&255)}else this._len=e;return f};li.prototype.readSequence=function(f){var e=this.peek();if(e===null)return null;if(f!==void 0&&f!==e)throw md("Expected 0x"+f.toString(16)+": got 0x"+e.toString(16));var t=this.readLength(this._offset+1);return t===null?null:(this._offset=t,e)};li.prototype.readInt=function(){return this._readTag(Mu.Integer)};li.prototype.readBoolean=function(){return this._readTag(Mu.Boolean)!==0};li.prototype.readEnumeration=function(){return this._readTag(Mu.Enumeration)};li.prototype.readString=function(f,e){f||(f=Mu.OctetString);var t=this.peek();if(t===null)return null;if(t!==f)throw md("Expected 0x"+f.toString(16)+": got 0x"+t.toString(16));var s=this.readLength(this._offset+1);if(s===null||this.length>this._size-s)return null;if(this._offset=s,this.length===0)return e?Buffer.alloc(0):"";var i=this._buf.slice(this._offset,this._offset+this.length);return this._offset+=this.length,e?i:i.toString("utf8")};li.prototype.readOID=function(f){f||(f=Mu.OID);var e=this.readString(f,!0);if(e===null)return null;for(var t=[],s=0,i=0;i<e.length;i++){var n=e[i]&255;s<<=7,s+=n&127,(n&128)===0&&(t.push(s),s=0)}return s=t.shift(),t.unshift(s%40),t.unshift(s/40>>0),t.join(".")};li.prototype._readTag=function(f){n3.ok(f!==void 0);var e=this.peek();if(e===null)return null;if(e!==f)throw md("Expected 0x"+f.toString(16)+": got 0x"+e.toString(16));var t=this.readLength(this._offset+1);if(t===null)return null;if(this.length>4)throw md("Integer too long: "+this.length);if(this.length>this._size-t)return null;this._offset=t;for(var s=this._buf[this._offset],i=0,n=0;n<this.length;n++)i<<=8,i|=this._buf[this._offset++]&255;return(s&128)===128&&n!==4&&(i-=1<<n*8),i>>0};var a3=li;(function(f){var e=Yx,t=Qx,s=a3;f.exports={Reader:s};for(var i in t)t.hasOwnProperty(i)&&(f.exports[i]=t[i]);for(var n in e)e.hasOwnProperty(n)&&(f.exports[n]=e[n])})(Xx);var s1=Xx.exports,Zx={Ber:s1,BerReader:s1.Reader};(function(f){var e=Zx.Ber,t=Ci._,s=Ci;const i="-----BEGIN RSA PRIVATE KEY-----",n="-----END RSA PRIVATE KEY-----",r="-----BEGIN RSA PUBLIC KEY-----",a="-----END RSA PUBLIC KEY-----";f.exports={privateExport:function(o,d){d=d||{};var c=o.n.toBuffer(),u=o.d.toBuffer(),h=o.p.toBuffer(),l=o.q.toBuffer(),p=o.dmp1.toBuffer(),m=o.dmq1.toBuffer(),g=o.coeff.toBuffer(),y=c.length+u.length+h.length+l.length+p.length+m.length+g.length+512,b=new e.Writer({size:y});return b.startSequence(),b.writeInt(0),b.writeBuffer(c,2),b.writeInt(o.e),b.writeBuffer(u,2),b.writeBuffer(h,2),b.writeBuffer(l,2),b.writeBuffer(p,2),b.writeBuffer(m,2),b.writeBuffer(g,2),b.endSequence(),d.type==="der"?b.buffer:i+`
`+s.linebrk(b.buffer.toString("base64"),64)+`
`+n},privateImport:function(o,d,c){c=c||{};var u;if(c.type!=="der")if(Buffer.isBuffer(d)&&(d=d.toString("utf8")),t.isString(d)){var h=s.trimSurroundingText(d,i,n).replace(/\s+|\n\r|\n|\r$/gm,"");u=Buffer.from(h,"base64")}else throw Error("Unsupported key format");else if(Buffer.isBuffer(d))u=d;else throw Error("Unsupported key format");var l=new e.Reader(u);l.readSequence(),l.readString(2,!0),o.setPrivate(l.readString(2,!0),l.readString(2,!0),l.readString(2,!0),l.readString(2,!0),l.readString(2,!0),l.readString(2,!0),l.readString(2,!0),l.readString(2,!0))},publicExport:function(o,d){d=d||{};var c=o.n.toBuffer(),u=c.length+512,h=new e.Writer({size:u});return h.startSequence(),h.writeBuffer(c,2),h.writeInt(o.e),h.endSequence(),d.type==="der"?h.buffer:r+`
`+s.linebrk(h.buffer.toString("base64"),64)+`
`+a},publicImport:function(o,d,c){c=c||{};var u;if(c.type!=="der"){if(Buffer.isBuffer(d)&&(d=d.toString("utf8")),t.isString(d)){var h=s.trimSurroundingText(d,r,a).replace(/\s+|\n\r|\n|\r$/gm,"");u=Buffer.from(h,"base64")}}else if(Buffer.isBuffer(d))u=d;else throw Error("Unsupported key format");var l=new e.Reader(u);l.readSequence(),o.setPublic(l.readString(2,!0),l.readString(2,!0))},autoImport:function(o,d){return/^[\S\s]*-----BEGIN RSA PRIVATE KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END RSA PRIVATE KEY-----[\S\s]*$/g.test(d)?(f.exports.privateImport(o,d),!0):/^[\S\s]*-----BEGIN RSA PUBLIC KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END RSA PUBLIC KEY-----[\S\s]*$/g.test(d)?(f.exports.publicImport(o,d),!0):!1}}})(Kx);var Jx={exports:{}};(function(f){var e=Zx.Ber,t=Ci._,s="1.2.840.113549.1.1.1",i=Ci;const n="-----BEGIN PRIVATE KEY-----",r="-----END PRIVATE KEY-----",a="-----BEGIN PUBLIC KEY-----",o="-----END PUBLIC KEY-----";f.exports={privateExport:function(d,c){c=c||{};var u=d.n.toBuffer(),h=d.d.toBuffer(),l=d.p.toBuffer(),p=d.q.toBuffer(),m=d.dmp1.toBuffer(),g=d.dmq1.toBuffer(),y=d.coeff.toBuffer(),b=u.length+h.length+l.length+p.length+m.length+g.length+y.length+512,w=new e.Writer({size:b});w.startSequence(),w.writeInt(0),w.writeBuffer(u,2),w.writeInt(d.e),w.writeBuffer(h,2),w.writeBuffer(l,2),w.writeBuffer(p,2),w.writeBuffer(m,2),w.writeBuffer(g,2),w.writeBuffer(y,2),w.endSequence();var S=new e.Writer({size:b});return S.startSequence(),S.writeInt(0),S.startSequence(),S.writeOID(s),S.writeNull(),S.endSequence(),S.writeBuffer(w.buffer,4),S.endSequence(),c.type==="der"?S.buffer:n+`
`+i.linebrk(S.buffer.toString("base64"),64)+`
`+r},privateImport:function(d,c,u){u=u||{};var h;if(u.type!=="der")if(Buffer.isBuffer(c)&&(c=c.toString("utf8")),t.isString(c)){var l=i.trimSurroundingText(c,n,r).replace("-----END PRIVATE KEY-----","").replace(/\s+|\n\r|\n|\r$/gm,"");h=Buffer.from(l,"base64")}else throw Error("Unsupported key format");else if(Buffer.isBuffer(c))h=c;else throw Error("Unsupported key format");var p=new e.Reader(h);p.readSequence(),p.readInt(0);var m=new e.Reader(p.readString(48,!0));if(m.readOID(6,!0)!==s)throw Error("Invalid Public key format");var g=new e.Reader(p.readString(4,!0));g.readSequence(),g.readString(2,!0),d.setPrivate(g.readString(2,!0),g.readString(2,!0),g.readString(2,!0),g.readString(2,!0),g.readString(2,!0),g.readString(2,!0),g.readString(2,!0),g.readString(2,!0))},publicExport:function(d,c){c=c||{};var u=d.n.toBuffer(),h=u.length+512,l=new e.Writer({size:h});l.writeByte(0),l.startSequence(),l.writeBuffer(u,2),l.writeInt(d.e),l.endSequence();var p=new e.Writer({size:h});return p.startSequence(),p.startSequence(),p.writeOID(s),p.writeNull(),p.endSequence(),p.writeBuffer(l.buffer,3),p.endSequence(),c.type==="der"?p.buffer:a+`
`+i.linebrk(p.buffer.toString("base64"),64)+`
`+o},publicImport:function(d,c,u){u=u||{};var h;if(u.type!=="der"){if(Buffer.isBuffer(c)&&(c=c.toString("utf8")),t.isString(c)){var l=i.trimSurroundingText(c,a,o).replace(/\s+|\n\r|\n|\r$/gm,"");h=Buffer.from(l,"base64")}}else if(Buffer.isBuffer(c))h=c;else throw Error("Unsupported key format");var p=new e.Reader(h);p.readSequence();var m=new e.Reader(p.readString(48,!0));if(m.readOID(6,!0)!==s)throw Error("Invalid Public key format");var g=new e.Reader(p.readString(3,!0));g.readByte(),g.readSequence(),d.setPublic(g.readString(2,!0),g.readString(2,!0))},autoImport:function(d,c){return/^[\S\s]*-----BEGIN PRIVATE KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END PRIVATE KEY-----[\S\s]*$/g.test(c)?(f.exports.privateImport(d,c),!0):/^[\S\s]*-----BEGIN PUBLIC KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END PUBLIC KEY-----[\S\s]*$/g.test(c)?(f.exports.publicImport(d,c),!0):!1}}})(Jx);var e_={exports:{}};(function(f){Ci._,f.exports={privateExport:function(e,t){return{n:e.n.toBuffer(),e:e.e,d:e.d.toBuffer(),p:e.p.toBuffer(),q:e.q.toBuffer(),dmp1:e.dmp1.toBuffer(),dmq1:e.dmq1.toBuffer(),coeff:e.coeff.toBuffer()}},privateImport:function(e,t,s){if(t.n&&t.e&&t.d&&t.p&&t.q&&t.dmp1&&t.dmq1&&t.coeff)e.setPrivate(t.n,t.e,t.d,t.p,t.q,t.dmp1,t.dmq1,t.coeff);else throw Error("Invalid key data")},publicExport:function(e,t){return{n:e.n.toBuffer(),e:e.e}},publicImport:function(e,t,s){if(t.n&&t.e)e.setPublic(t.n,t.e);else throw Error("Invalid key data")},autoImport:function(e,t){return t.n&&t.e?t.d&&t.p&&t.q&&t.dmp1&&t.dmq1&&t.coeff?(f.exports.privateImport(e,t),!0):(f.exports.publicImport(e,t),!0):!1}}})(e_);(function(f){Ci._,f.exports={pkcs1:Kx.exports,pkcs8:Jx.exports,components:e_.exports,detectAndImport:function(e,t,s){if(s===void 0){for(var i in f.exports)if(typeof f.exports[i].autoImport=="function"&&f.exports[i].autoImport(e,t))return!0}else if(s){var n=formatParse(s);if(f.exports[n.scheme])n.keyType==="private"?f.exports[n.scheme].privateImport(e,t,n.keyOpt):f.exports[n.scheme].publicImport(e,t,n.keyOpt);else throw Error("Unsupported key format")}return!1}}})(zx);/*!
 * RSA library for Node.js
 *
 * Author: rzcoder
 * License MIT
 */var o3=Ux,Gi=Ci._,i1=hb.exports,d3=zx.exports,c3=function(){var f={browser:["md5","ripemd160","sha1","sha256","sha512"]},e="pkcs1",t="pkcs1",s={private:"pkcs1-private-pem","private-der":"pkcs1-private-der",public:"pkcs8-public-pem","public-der":"pkcs8-public-der"};function i(n,r,a){if(!(this instanceof i))return new i(n,r,a);Gi.isObject(r)&&(a=r,r=void 0),this.$options={signingScheme:t,signingSchemeOptions:{hash:"sha256",saltLength:null},encryptionScheme:e,encryptionSchemeOptions:{hash:"sha1",label:null},environment:"browser",rsaUtils:this},this.keyPair=new o3.Key,this.$cache={},Buffer.isBuffer(n)||Gi.isString(n)?this.importKey(n,r):Gi.isObject(n)&&this.generateKeyPair(n.b,n.e),this.setOptions(a)}return i.prototype.setOptions=function(n){if(n=n||{},n.environment&&(this.$options.environment=n.environment),n.signingScheme){if(Gi.isString(n.signingScheme)){var r=n.signingScheme.toLowerCase().split("-");r.length==1?f.node.indexOf(r[0])>-1?(this.$options.signingSchemeOptions={hash:r[0]},this.$options.signingScheme=t):(this.$options.signingScheme=r[0],this.$options.signingSchemeOptions={hash:null}):(this.$options.signingSchemeOptions={hash:r[1]},this.$options.signingScheme=r[0])}else Gi.isObject(n.signingScheme)&&(this.$options.signingScheme=n.signingScheme.scheme||t,this.$options.signingSchemeOptions=Gi.omit(n.signingScheme,"scheme"));if(!i1.isSignature(this.$options.signingScheme))throw Error("Unsupported signing scheme");if(this.$options.signingSchemeOptions.hash&&f[this.$options.environment].indexOf(this.$options.signingSchemeOptions.hash)===-1)throw Error("Unsupported hashing algorithm for "+this.$options.environment+" environment")}if(n.encryptionScheme){if(Gi.isString(n.encryptionScheme)?(this.$options.encryptionScheme=n.encryptionScheme.toLowerCase(),this.$options.encryptionSchemeOptions={}):Gi.isObject(n.encryptionScheme)&&(this.$options.encryptionScheme=n.encryptionScheme.scheme||e,this.$options.encryptionSchemeOptions=Gi.omit(n.encryptionScheme,"scheme")),!i1.isEncryption(this.$options.encryptionScheme))throw Error("Unsupported encryption scheme");if(this.$options.encryptionSchemeOptions.hash&&f[this.$options.environment].indexOf(this.$options.encryptionSchemeOptions.hash)===-1)throw Error("Unsupported hashing algorithm for "+this.$options.environment+" environment")}this.keyPair.setOptions(this.$options)},i.prototype.importKey=function(n,r){if(!n)throw Error("Empty key given");if(r&&(r=s[r]||r),!d3.detectAndImport(this.keyPair,n,r)&&r===void 0)throw Error("Key format must be specified");return this.$cache={},this},i.prototype.isPrivate=function(){return this.keyPair.isPrivate()},i.prototype.isPublic=function(n){return this.keyPair.isPublic(n)},i.prototype.isEmpty=function(n){return!(this.keyPair.n||this.keyPair.e||this.keyPair.d)},i.prototype.sign=function(n,r,a){if(!this.isPrivate())throw Error("This is not private key");var o=this.keyPair.sign(this.$getDataForEncrypt(n,a));return r&&r!="buffer"&&(o=o.toString(r)),o},i.prototype.$getDataForEncrypt=function(n,r){if(Gi.isString(n)||Gi.isNumber(n))return Buffer.from(""+n,r||"utf8");if(Buffer.isBuffer(n))return n;if(Gi.isObject(n))return Buffer.from(JSON.stringify(n));throw Error("Unexpected data type")},i}(),Mp={},fo={};(function(f){var e=f,t=Fi.exports;e.assert=function(l,p){if(!l)throw new Error(p)};function s(l,p){for(var m=[],g=1<<p+1,y=l.clone();y.cmpn(1)>=0;){var b;if(y.isOdd()){var w=y.andln(g-1);w>(g>>1)-1?b=(g>>1)-w:b=w,y.isubn(b)}else b=0;m.push(b);for(var S=y.cmpn(0)!==0&&y.andln(g-1)===0?p+1:1,k=1;k<S;k++)m.push(0);y.iushrn(S)}return m}e.getNAF=s;function i(l,p){var m=[[],[]];l=l.clone(),p=p.clone();for(var g=0,y=0;l.cmpn(-g)>0||p.cmpn(-y)>0;){var b=l.andln(3)+g&3,w=p.andln(3)+y&3;b===3&&(b=-1),w===3&&(w=-1);var S;if((b&1)===0)S=0;else{var k=l.andln(7)+g&7;(k===3||k===5)&&w===2?S=-b:S=b}m[0].push(S);var T;if((w&1)===0)T=0;else{var k=p.andln(7)+y&7;(k===3||k===5)&&b===2?T=-w:T=w}m[1].push(T),2*g===S+1&&(g=1-g),2*y===T+1&&(y=1-y),l.iushrn(1),p.iushrn(1)}return m}e.getJSF=i;function n(l,p,m){var g="_"+p;l.prototype[p]=function(){return this[g]!==void 0?this[g]:this[g]=m.call(this)}}e.cachedProperty=n;function r(l){return typeof l=="string"?e.toArray(l,"hex"):l}e.parseBytes=r;function a(l){return new t(l,"hex","le")}e.intFromLE=a;function o(l,p){var m=[],g=255;return p>0&&m.push(l>>>24),p>1&&m.push(l>>>16&g),p>2&&m.push(l>>>8&g),p>3&&m.push(l&g),m}function d(l){let p;if(l.hasOwnProperty("sigBytes")&&l.hasOwnProperty("words"))p=l.sigBytes,l=l.words;else throw Error("Argument not a wordArray");const m=[];let g=[],y=0;for(;p>0;)g=o(l[y],Math.min(4,p)),p-=g.length,m.push(g),y++;return[].concat.apply([],m)}e.wordArrayToBuffer=d;function c(l,p){if(Array.isArray(l))return l.slice();if(!l)return[];var m=[];if(typeof l!="string"){for(var g=0;g<l.length;g++)m[g]=l[g]|0;return m}if(p==="hex"){l=l.replace(/[^a-z0-9]+/ig,""),l.length%2!==0&&(l="0"+l);for(var g=0;g<l.length;g+=2)m.push(parseInt(l[g]+l[g+1],16))}else for(var g=0;g<l.length;g++){var y=l.charCodeAt(g),b=y>>8,w=y&255;b?m.push(b,w):m.push(w)}return m}e.toArray=c;function u(l){return l.length===1?"0"+l:l}e.zero2=u;function h(l){for(var p="",m=0;m<l.length;m++)p+=u(l[m].toString(16));return p}e.toHex=h,e.encode=function(p,m){return m==="hex"?h(p):p}})(fo);var Pp={},Ap,n1;function u3(){if(n1)return Ap;n1=1;var f=Fi.exports,e=Qn(),t=e.utils,s=t.getNAF,i=t.getJSF,n=t.assert;function r(o,d){this.type=o,this.p=new f(d.p,16),this.red=d.prime?f.red(d.prime):f.mont(this.p),this.zero=new f(0).toRed(this.red),this.one=new f(1).toRed(this.red),this.two=new f(2).toRed(this.red),this.n=d.n&&new f(d.n,16),this.g=d.g&&this.pointFromJSON(d.g,d.gRed),this._wnafT1=new Array(4),this._wnafT2=new Array(4),this._wnafT3=new Array(4),this._wnafT4=new Array(4);var c=this.n&&this.p.div(this.n);!c||c.cmpn(100)>0?this.redN=null:(this._maxwellTrick=!0,this.redN=this.n.toRed(this.red))}Ap=r,r.prototype.point=function(){throw new Error("Not implemented")},r.prototype.validate=function(){throw new Error("Not implemented")},r.prototype._fixedNafMul=function(d,c){n(d.precomputed);var u=d._getDoubles(),h=s(c,1),l=(1<<u.step+1)-(u.step%2===0?2:1);l/=3;for(var p=[],m=0;m<h.length;m+=u.step){for(var g=0,c=m+u.step-1;c>=m;c--)g=(g<<1)+h[c];p.push(g)}for(var y=this.jpoint(null,null,null),b=this.jpoint(null,null,null),w=l;w>0;w--){for(var m=0;m<p.length;m++){var g=p[m];g===w?b=b.mixedAdd(u.points[m]):g===-w&&(b=b.mixedAdd(u.points[m].neg()))}y=y.add(b)}return y.toP()},r.prototype._wnafMul=function(d,c){var u=4,h=d._getNAFPoints(u);u=h.wnd;for(var l=h.points,p=s(c,u),m=this.jpoint(null,null,null),g=p.length-1;g>=0;g--){for(var c=0;g>=0&&p[g]===0;g--)c++;if(g>=0&&c++,m=m.dblp(c),g<0)break;var y=p[g];n(y!==0),d.type==="affine"?y>0?m=m.mixedAdd(l[y-1>>1]):m=m.mixedAdd(l[-y-1>>1].neg()):y>0?m=m.add(l[y-1>>1]):m=m.add(l[-y-1>>1].neg())}return d.type==="affine"?m.toP():m},r.prototype._wnafMulAdd=function(d,c,u,h,l){for(var p=this._wnafT1,m=this._wnafT2,g=this._wnafT3,y=0,b=0;b<h;b++){var w=c[b],S=w._getNAFPoints(d);p[b]=S.wnd,m[b]=S.points}for(var b=h-1;b>=1;b-=2){var k=b-1,T=b;if(p[k]!==1||p[T]!==1){g[k]=s(u[k],p[k]),g[T]=s(u[T],p[T]),y=Math.max(g[k].length,y),y=Math.max(g[T].length,y);continue}var I=[c[k],null,null,c[T]];c[k].y.cmp(c[T].y)===0?(I[1]=c[k].add(c[T]),I[2]=c[k].toJ().mixedAdd(c[T].neg())):c[k].y.cmp(c[T].y.redNeg())===0?(I[1]=c[k].toJ().mixedAdd(c[T]),I[2]=c[k].add(c[T].neg())):(I[1]=c[k].toJ().mixedAdd(c[T]),I[2]=c[k].toJ().mixedAdd(c[T].neg()));var _=[-3,-1,-5,-7,0,7,5,1,3],N=i(u[k],u[T]);y=Math.max(N[0].length,y),g[k]=new Array(y),g[T]=new Array(y);for(var M=0;M<y;M++){var x=N[0][M]|0,v=N[1][M]|0;g[k][M]=_[(x+1)*3+(v+1)],g[T][M]=0,m[k]=I}}for(var O=this.jpoint(null,null,null),A=this._wnafT4,b=y;b>=0;b--){for(var V=0;b>=0;){for(var q=!0,M=0;M<h;M++)A[M]=g[M][b]|0,A[M]!==0&&(q=!1);if(!q)break;V++,b--}if(b>=0&&V++,O=O.dblp(V),b<0)break;for(var M=0;M<h;M++){var R=A[M],w;R!==0&&(R>0?w=m[M][R-1>>1]:R<0&&(w=m[M][-R-1>>1].neg()),w.type==="affine"?O=O.mixedAdd(w):O=O.add(w))}}for(var b=0;b<h;b++)m[b]=null;return l?O:O.toP()};function a(o,d){this.curve=o,this.type=d,this.precomputed=null}return r.BasePoint=a,a.prototype.eq=function(){throw new Error("Not implemented")},a.prototype.validate=function(){return this.curve.validate(this)},r.prototype.decodePoint=function(d,c){d=t.toArray(d,c);var u=this.p.byteLength();if((d[0]===4||d[0]===6||d[0]===7)&&d.length-1===2*u){d[0]===6?n(d[d.length-1]%2===0):d[0]===7&&n(d[d.length-1]%2===1);var h=this.point(d.slice(1,1+u),d.slice(1+u,1+2*u));return h}else if((d[0]===2||d[0]===3)&&d.length-1===u)return this.pointFromX(d.slice(1,1+u),d[0]===3);throw new Error("Unknown point format")},a.prototype.encodeCompressed=function(d){return this.encode(d,!0)},a.prototype._encode=function(d){var c=this.curve.p.byteLength(),u=this.getX().toArray("be",c);return d?[this.getY().isEven()?2:3].concat(u):[4].concat(u,this.getY().toArray("be",c))},a.prototype.encode=function(d,c){return t.encode(this._encode(c),d)},a.prototype.precompute=function(d){if(this.precomputed)return this;var c={doubles:null,naf:null,beta:null};return c.naf=this._getNAFPoints(8),c.doubles=this._getDoubles(4,d),c.beta=this._getBeta(),this.precomputed=c,this},a.prototype._hasDoubles=function(d){if(!this.precomputed)return!1;var c=this.precomputed.doubles;return c?c.points.length>=Math.ceil((d.bitLength()+1)/c.step):!1},a.prototype._getDoubles=function(d,c){if(this.precomputed&&this.precomputed.doubles)return this.precomputed.doubles;for(var u=[this],h=this,l=0;l<c;l+=d){for(var p=0;p<d;p++)h=h.dbl();u.push(h)}return{step:d,points:u}},a.prototype._getNAFPoints=function(d){if(this.precomputed&&this.precomputed.naf)return this.precomputed.naf;for(var c=[this],u=(1<<d)-1,h=u===1?null:this.dbl(),l=1;l<u;l++)c[l]=c[l-1].add(h);return{wnd:d,points:c}},a.prototype._getBeta=function(){return null},a.prototype.dblp=function(d){for(var c=this,u=0;u<d;u++)c=c.dbl();return c},Ap}var Bp,r1;function f3(){if(r1)return Bp;r1=1;var f=Nl(),e=Qn(),t=Fi.exports,s=e.inherits,i=f.base,n=e.utils.assert;function r(d){i.call(this,"short",d),this.a=new t(d.a,16).toRed(this.red),this.b=new t(d.b,16).toRed(this.red),this.tinv=this.two.redInvm(),this.zeroA=this.a.fromRed().cmpn(0)===0,this.threeA=this.a.fromRed().sub(this.p).cmpn(-3)===0,this.endo=this._getEndomorphism(d),this._endoWnafT1=new Array(4),this._endoWnafT2=new Array(4)}s(r,i),Bp=r,r.prototype._getEndomorphism=function(c){if(!(!this.zeroA||!this.g||!this.n||this.p.modn(3)!==1)){var u,h;if(c.beta)u=new t(c.beta,16).toRed(this.red);else{var l=this._getEndoRoots(this.p);u=l[0].cmp(l[1])<0?l[0]:l[1],u=u.toRed(this.red)}if(c.lambda)h=new t(c.lambda,16);else{var p=this._getEndoRoots(this.n);this.g.mul(p[0]).x.cmp(this.g.x.redMul(u))===0?h=p[0]:(h=p[1],n(this.g.mul(h).x.cmp(this.g.x.redMul(u))===0))}var m;return c.basis?m=c.basis.map(function(g){return{a:new t(g.a,16),b:new t(g.b,16)}}):m=this._getEndoBasis(h),{beta:u,lambda:h,basis:m}}},r.prototype._getEndoRoots=function(c){var u=c===this.p?this.red:t.mont(c),h=new t(2).toRed(u).redInvm(),l=h.redNeg(),p=new t(3).toRed(u).redNeg().redSqrt().redMul(h),m=l.redAdd(p).fromRed(),g=l.redSub(p).fromRed();return[m,g]},r.prototype._getEndoBasis=function(c){for(var u=this.n.ushrn(Math.floor(this.n.bitLength()/2)),h=c,l=this.n.clone(),p=new t(1),m=new t(0),g=new t(0),y=new t(1),b,w,S,k,T,I,_,N=0,M,x;h.cmpn(0)!==0;){var v=l.div(h);M=l.sub(v.mul(h)),x=g.sub(v.mul(p));var O=y.sub(v.mul(m));if(!S&&M.cmp(u)<0)b=_.neg(),w=p,S=M.neg(),k=x;else if(S&&++N===2)break;_=M,l=h,h=M,g=p,p=x,y=m,m=O}T=M.neg(),I=x;var A=S.sqr().add(k.sqr()),V=T.sqr().add(I.sqr());return V.cmp(A)>=0&&(T=b,I=w),S.negative&&(S=S.neg(),k=k.neg()),T.negative&&(T=T.neg(),I=I.neg()),[{a:S,b:k},{a:T,b:I}]},r.prototype._endoSplit=function(c){var u=this.endo.basis,h=u[0],l=u[1],p=l.b.mul(c).divRound(this.n),m=h.b.neg().mul(c).divRound(this.n),g=p.mul(h.a),y=m.mul(l.a),b=p.mul(h.b),w=m.mul(l.b),S=c.sub(g).sub(y),k=b.add(w).neg();return{k1:S,k2:k}},r.prototype.pointFromX=function(c,u){c=new t(c,16),c.red||(c=c.toRed(this.red));var h=c.redSqr().redMul(c).redIAdd(c.redMul(this.a)).redIAdd(this.b),l=h.redSqrt();if(l.redSqr().redSub(h).cmp(this.zero)!==0)throw new Error("invalid point");var p=l.fromRed().isOdd();return(u&&!p||!u&&p)&&(l=l.redNeg()),this.point(c,l)},r.prototype.validate=function(c){if(c.inf)return!0;var u=c.x,h=c.y,l=this.a.redMul(u),p=u.redSqr().redMul(u).redIAdd(l).redIAdd(this.b);return h.redSqr().redISub(p).cmpn(0)===0},r.prototype._endoWnafMulAdd=function(c,u,h){for(var l=this._endoWnafT1,p=this._endoWnafT2,m=0;m<c.length;m++){var g=this._endoSplit(u[m]),y=c[m],b=y._getBeta();g.k1.negative&&(g.k1.ineg(),y=y.neg(!0)),g.k2.negative&&(g.k2.ineg(),b=b.neg(!0)),l[m*2]=y,l[m*2+1]=b,p[m*2]=g.k1,p[m*2+1]=g.k2}for(var w=this._wnafMulAdd(1,l,p,m*2,h),S=0;S<m*2;S++)l[S]=null,p[S]=null;return w};function a(d,c,u,h){i.BasePoint.call(this,d,"affine"),c===null&&u===null?(this.x=null,this.y=null,this.inf=!0):(this.x=new t(c,16),this.y=new t(u,16),h&&(this.x.forceRed(this.curve.red),this.y.forceRed(this.curve.red)),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.inf=!1)}s(a,i.BasePoint),r.prototype.point=function(c,u,h){return new a(this,c,u,h)},r.prototype.pointFromJSON=function(c,u){return a.fromJSON(this,c,u)},a.prototype._getBeta=function(){if(!!this.curve.endo){var c=this.precomputed;if(c&&c.beta)return c.beta;var u=this.curve.point(this.x.redMul(this.curve.endo.beta),this.y);if(c){var h=this.curve,l=function(p){return h.point(p.x.redMul(h.endo.beta),p.y)};c.beta=u,u.precomputed={beta:null,naf:c.naf&&{wnd:c.naf.wnd,points:c.naf.points.map(l)},doubles:c.doubles&&{step:c.doubles.step,points:c.doubles.points.map(l)}}}return u}},a.prototype.toJSON=function(){return this.precomputed?[this.x,this.y,this.precomputed&&{doubles:this.precomputed.doubles&&{step:this.precomputed.doubles.step,points:this.precomputed.doubles.points.slice(1)},naf:this.precomputed.naf&&{wnd:this.precomputed.naf.wnd,points:this.precomputed.naf.points.slice(1)}}]:[this.x,this.y]},a.fromJSON=function(c,u,h){typeof u=="string"&&(u=JSON.parse(u));var l=c.point(u[0],u[1],h);if(!u[2])return l;function p(g){return c.point(g[0],g[1],h)}var m=u[2];return l.precomputed={beta:null,doubles:m.doubles&&{step:m.doubles.step,points:[l].concat(m.doubles.points.map(p))},naf:m.naf&&{wnd:m.naf.wnd,points:[l].concat(m.naf.points.map(p))}},l},a.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" y: "+this.y.fromRed().toString(16,2)+">"},a.prototype.isInfinity=function(){return this.inf},a.prototype.add=function(c){if(this.inf)return c;if(c.inf)return this;if(this.eq(c))return this.dbl();if(this.neg().eq(c))return this.curve.point(null,null);if(this.x.cmp(c.x)===0)return this.curve.point(null,null);var u=this.y.redSub(c.y);u.cmpn(0)!==0&&(u=u.redMul(this.x.redSub(c.x).redInvm()));var h=u.redSqr().redISub(this.x).redISub(c.x),l=u.redMul(this.x.redSub(h)).redISub(this.y);return this.curve.point(h,l)},a.prototype.dbl=function(){if(this.inf)return this;var c=this.y.redAdd(this.y);if(c.cmpn(0)===0)return this.curve.point(null,null);var u=this.curve.a,h=this.x.redSqr(),l=c.redInvm(),p=h.redAdd(h).redIAdd(h).redIAdd(u).redMul(l),m=p.redSqr().redISub(this.x.redAdd(this.x)),g=p.redMul(this.x.redSub(m)).redISub(this.y);return this.curve.point(m,g)},a.prototype.getX=function(){return this.x.fromRed()},a.prototype.getY=function(){return this.y.fromRed()},a.prototype.mul=function(c){return c=new t(c,16),this._hasDoubles(c)?this.curve._fixedNafMul(this,c):this.curve.endo?this.curve._endoWnafMulAdd([this],[c]):this.curve._wnafMul(this,c)},a.prototype.mulAdd=function(c,u,h){var l=[this,u],p=[c,h];return this.curve.endo?this.curve._endoWnafMulAdd(l,p):this.curve._wnafMulAdd(1,l,p,2)},a.prototype.jmulAdd=function(c,u,h){var l=[this,u],p=[c,h];return this.curve.endo?this.curve._endoWnafMulAdd(l,p,!0):this.curve._wnafMulAdd(1,l,p,2,!0)},a.prototype.eq=function(c){return this===c||this.inf===c.inf&&(this.inf||this.x.cmp(c.x)===0&&this.y.cmp(c.y)===0)},a.prototype.neg=function(c){if(this.inf)return this;var u=this.curve.point(this.x,this.y.redNeg());if(c&&this.precomputed){var h=this.precomputed,l=function(p){return p.neg()};u.precomputed={naf:h.naf&&{wnd:h.naf.wnd,points:h.naf.points.map(l)},doubles:h.doubles&&{step:h.doubles.step,points:h.doubles.points.map(l)}}}return u},a.prototype.toJ=function(){if(this.inf)return this.curve.jpoint(null,null,null);var c=this.curve.jpoint(this.x,this.y,this.curve.one);return c};function o(d,c,u,h){i.BasePoint.call(this,d,"jacobian"),c===null&&u===null&&h===null?(this.x=this.curve.one,this.y=this.curve.one,this.z=new t(0)):(this.x=new t(c,16),this.y=new t(u,16),this.z=new t(h,16)),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)),this.zOne=this.z===this.curve.one}return s(o,i.BasePoint),r.prototype.jpoint=function(c,u,h){return new o(this,c,u,h)},o.prototype.toP=function(){if(this.isInfinity())return this.curve.point(null,null);var c=this.z.redInvm(),u=c.redSqr(),h=this.x.redMul(u),l=this.y.redMul(u).redMul(c);return this.curve.point(h,l)},o.prototype.neg=function(){return this.curve.jpoint(this.x,this.y.redNeg(),this.z)},o.prototype.add=function(c){if(this.isInfinity())return c;if(c.isInfinity())return this;var u=c.z.redSqr(),h=this.z.redSqr(),l=this.x.redMul(u),p=c.x.redMul(h),m=this.y.redMul(u.redMul(c.z)),g=c.y.redMul(h.redMul(this.z)),y=l.redSub(p),b=m.redSub(g);if(y.cmpn(0)===0)return b.cmpn(0)!==0?this.curve.jpoint(null,null,null):this.dbl();var w=y.redSqr(),S=w.redMul(y),k=l.redMul(w),T=b.redSqr().redIAdd(S).redISub(k).redISub(k),I=b.redMul(k.redISub(T)).redISub(m.redMul(S)),_=this.z.redMul(c.z).redMul(y);return this.curve.jpoint(T,I,_)},o.prototype.mixedAdd=function(c){if(this.isInfinity())return c.toJ();if(c.isInfinity())return this;var u=this.z.redSqr(),h=this.x,l=c.x.redMul(u),p=this.y,m=c.y.redMul(u).redMul(this.z),g=h.redSub(l),y=p.redSub(m);if(g.cmpn(0)===0)return y.cmpn(0)!==0?this.curve.jpoint(null,null,null):this.dbl();var b=g.redSqr(),w=b.redMul(g),S=h.redMul(b),k=y.redSqr().redIAdd(w).redISub(S).redISub(S),T=y.redMul(S.redISub(k)).redISub(p.redMul(w)),I=this.z.redMul(g);return this.curve.jpoint(k,T,I)},o.prototype.dblp=function(c){if(c===0)return this;if(this.isInfinity())return this;if(!c)return this.dbl();if(this.curve.zeroA||this.curve.threeA){for(var u=this,h=0;h<c;h++)u=u.dbl();return u}for(var l=this.curve.a,p=this.curve.tinv,m=this.x,g=this.y,y=this.z,b=y.redSqr().redSqr(),w=g.redAdd(g),h=0;h<c;h++){var S=m.redSqr(),k=w.redSqr(),T=k.redSqr(),I=S.redAdd(S).redIAdd(S).redIAdd(l.redMul(b)),_=m.redMul(k),N=I.redSqr().redISub(_.redAdd(_)),M=_.redISub(N),x=I.redMul(M);x=x.redIAdd(x).redISub(T);var v=w.redMul(y);h+1<c&&(b=b.redMul(T)),m=N,y=v,w=x}return this.curve.jpoint(m,w.redMul(p),y)},o.prototype.dbl=function(){return this.isInfinity()?this:this.curve.zeroA?this._zeroDbl():this.curve.threeA?this._threeDbl():this._dbl()},o.prototype._zeroDbl=function(){var c,u,h;if(this.zOne){var l=this.x.redSqr(),p=this.y.redSqr(),m=p.redSqr(),g=this.x.redAdd(p).redSqr().redISub(l).redISub(m);g=g.redIAdd(g);var y=l.redAdd(l).redIAdd(l),b=y.redSqr().redISub(g).redISub(g),w=m.redIAdd(m);w=w.redIAdd(w),w=w.redIAdd(w),c=b,u=y.redMul(g.redISub(b)).redISub(w),h=this.y.redAdd(this.y)}else{var S=this.x.redSqr(),k=this.y.redSqr(),T=k.redSqr(),I=this.x.redAdd(k).redSqr().redISub(S).redISub(T);I=I.redIAdd(I);var _=S.redAdd(S).redIAdd(S),N=_.redSqr(),M=T.redIAdd(T);M=M.redIAdd(M),M=M.redIAdd(M),c=N.redISub(I).redISub(I),u=_.redMul(I.redISub(c)).redISub(M),h=this.y.redMul(this.z),h=h.redIAdd(h)}return this.curve.jpoint(c,u,h)},o.prototype._threeDbl=function(){var c,u,h;if(this.zOne){var l=this.x.redSqr(),p=this.y.redSqr(),m=p.redSqr(),g=this.x.redAdd(p).redSqr().redISub(l).redISub(m);g=g.redIAdd(g);var y=l.redAdd(l).redIAdd(l).redIAdd(this.curve.a),b=y.redSqr().redISub(g).redISub(g);c=b;var w=m.redIAdd(m);w=w.redIAdd(w),w=w.redIAdd(w),u=y.redMul(g.redISub(b)).redISub(w),h=this.y.redAdd(this.y)}else{var S=this.z.redSqr(),k=this.y.redSqr(),T=this.x.redMul(k),I=this.x.redSub(S).redMul(this.x.redAdd(S));I=I.redAdd(I).redIAdd(I);var _=T.redIAdd(T);_=_.redIAdd(_);var N=_.redAdd(_);c=I.redSqr().redISub(N),h=this.y.redAdd(this.z).redSqr().redISub(k).redISub(S);var M=k.redSqr();M=M.redIAdd(M),M=M.redIAdd(M),M=M.redIAdd(M),u=I.redMul(_.redISub(c)).redISub(M)}return this.curve.jpoint(c,u,h)},o.prototype._dbl=function(){var c=this.curve.a,u=this.x,h=this.y,l=this.z,p=l.redSqr().redSqr(),m=u.redSqr(),g=h.redSqr(),y=m.redAdd(m).redIAdd(m).redIAdd(c.redMul(p)),b=u.redAdd(u);b=b.redIAdd(b);var w=b.redMul(g),S=y.redSqr().redISub(w.redAdd(w)),k=w.redISub(S),T=g.redSqr();T=T.redIAdd(T),T=T.redIAdd(T),T=T.redIAdd(T);var I=y.redMul(k).redISub(T),_=h.redAdd(h).redMul(l);return this.curve.jpoint(S,I,_)},o.prototype.trpl=function(){if(!this.curve.zeroA)return this.dbl().add(this);var c=this.x.redSqr(),u=this.y.redSqr(),h=this.z.redSqr(),l=u.redSqr(),p=c.redAdd(c).redIAdd(c),m=p.redSqr(),g=this.x.redAdd(u).redSqr().redISub(c).redISub(l);g=g.redIAdd(g),g=g.redAdd(g).redIAdd(g),g=g.redISub(m);var y=g.redSqr(),b=l.redIAdd(l);b=b.redIAdd(b),b=b.redIAdd(b),b=b.redIAdd(b);var w=p.redIAdd(g).redSqr().redISub(m).redISub(y).redISub(b),S=u.redMul(w);S=S.redIAdd(S),S=S.redIAdd(S);var k=this.x.redMul(y).redISub(S);k=k.redIAdd(k),k=k.redIAdd(k);var T=this.y.redMul(w.redMul(b.redISub(w)).redISub(g.redMul(y)));T=T.redIAdd(T),T=T.redIAdd(T),T=T.redIAdd(T);var I=this.z.redAdd(g).redSqr().redISub(h).redISub(y);return this.curve.jpoint(k,T,I)},o.prototype.mul=function(c,u){return c=new t(c,u),this.curve._wnafMul(this,c)},o.prototype.eq=function(c){if(c.type==="affine")return this.eq(c.toJ());if(this===c)return!0;var u=this.z.redSqr(),h=c.z.redSqr();if(this.x.redMul(h).redISub(c.x.redMul(u)).cmpn(0)!==0)return!1;var l=u.redMul(this.z),p=h.redMul(c.z);return this.y.redMul(p).redISub(c.y.redMul(l)).cmpn(0)===0},o.prototype.eqXToP=function(c){var u=this.z.redSqr(),h=c.toRed(this.curve.red).redMul(u);if(this.x.cmp(h)===0)return!0;for(var l=c.clone(),p=this.curve.redN.redMul(u);;){if(l.iadd(this.curve.n),l.cmp(this.curve.p)>=0)return!1;if(h.redIAdd(p),this.x.cmp(h)===0)return!0}return!1},o.prototype.inspect=function(){return this.isInfinity()?"<EC JPoint Infinity>":"<EC JPoint x: "+this.x.toString(16,2)+" y: "+this.y.toString(16,2)+" z: "+this.z.toString(16,2)+">"},o.prototype.isInfinity=function(){return this.z.cmpn(0)===0},Bp}var Np,a1;function h3(){if(a1)return Np;a1=1;var f=Nl(),e=Fi.exports,t=Qn().inherits,s=f.base,i=Qn(),n=i.utils;function r(o){s.call(this,"mont",o),this.a=new e(o.a,16).toRed(this.red),this.b=new e(o.b,16).toRed(this.red),this.i4=new e(4).toRed(this.red).redInvm(),this.two=new e(2).toRed(this.red),this.a24=this.i4.redMul(this.a.redAdd(this.two))}t(r,s),Np=r,r.prototype.validate=function(d){var c=d.normalize().x,u=c.redSqr(),h=u.redMul(c).redAdd(u.redMul(this.a)).redAdd(c),l=h.redSqrt();return l.redSqr().cmp(h)===0};function a(o,d,c){s.BasePoint.call(this,o,"projective"),d===null&&c===null?(this.x=this.curve.one,this.z=this.curve.zero):(this.x=new e(d,16),this.z=new e(c,16),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)))}return t(a,s.BasePoint),r.prototype.decodePoint=function(d,c){return this.point(n.toArray(d,c),1)},r.prototype.point=function(d,c){return new a(this,d,c)},r.prototype.pointFromJSON=function(d){return a.fromJSON(this,d)},a.prototype.precompute=function(){},a.prototype._encode=function(){return this.getX().toArray("be",this.curve.p.byteLength())},a.fromJSON=function(d,c){return new a(d,c[0],c[1]||d.one)},a.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" z: "+this.z.fromRed().toString(16,2)+">"},a.prototype.isInfinity=function(){return this.z.cmpn(0)===0},a.prototype.dbl=function(){var d=this.x.redAdd(this.z),c=d.redSqr(),u=this.x.redSub(this.z),h=u.redSqr(),l=c.redSub(h),p=c.redMul(h),m=l.redMul(h.redAdd(this.curve.a24.redMul(l)));return this.curve.point(p,m)},a.prototype.add=function(){throw new Error("Not supported on Montgomery curve")},a.prototype.diffAdd=function(d,c){var u=this.x.redAdd(this.z),h=this.x.redSub(this.z),l=d.x.redAdd(d.z),p=d.x.redSub(d.z),m=p.redMul(u),g=l.redMul(h),y=c.z.redMul(m.redAdd(g).redSqr()),b=c.x.redMul(m.redISub(g).redSqr());return this.curve.point(y,b)},a.prototype.mul=function(d){for(var c=d.clone(),u=this,h=this.curve.point(null,null),l=this,p=[];c.cmpn(0)!==0;c.iushrn(1))p.push(c.andln(1));for(var m=p.length-1;m>=0;m--)p[m]===0?(u=u.diffAdd(h,l),h=h.dbl()):(h=u.diffAdd(h,l),u=u.dbl());return h},a.prototype.mulAdd=function(){throw new Error("Not supported on Montgomery curve")},a.prototype.jumlAdd=function(){throw new Error("Not supported on Montgomery curve")},a.prototype.eq=function(d){return this.getX().cmp(d.getX())===0},a.prototype.normalize=function(){return this.x=this.x.redMul(this.z.redInvm()),this.z=this.curve.one,this},a.prototype.getX=function(){return this.normalize(),this.x.fromRed()},Np}var Ep,o1;function l3(){if(o1)return Ep;o1=1;var f=Nl(),e=Qn(),t=Fi.exports,s=e.inherits,i=f.base,n=e.utils.assert;function r(o){this.twisted=(o.a|0)!==1,this.mOneA=this.twisted&&(o.a|0)===-1,this.extended=this.mOneA,i.call(this,"edwards",o),this.a=new t(o.a,16).umod(this.red.m),this.a=this.a.toRed(this.red),this.c=new t(o.c,16).toRed(this.red),this.c2=this.c.redSqr(),this.d=new t(o.d,16).toRed(this.red),this.dd=this.d.redAdd(this.d),n(!this.twisted||this.c.fromRed().cmpn(1)===0),this.oneC=(o.c|0)===1}s(r,i),Ep=r,r.prototype._mulA=function(d){return this.mOneA?d.redNeg():this.a.redMul(d)},r.prototype._mulC=function(d){return this.oneC?d:this.c.redMul(d)},r.prototype.jpoint=function(d,c,u,h){return this.point(d,c,u,h)},r.prototype.pointFromX=function(d,c){d=new t(d,16),d.red||(d=d.toRed(this.red));var u=d.redSqr(),h=this.c2.redSub(this.a.redMul(u)),l=this.one.redSub(this.c2.redMul(this.d).redMul(u)),p=h.redMul(l.redInvm()),m=p.redSqrt();if(m.redSqr().redSub(p).cmp(this.zero)!==0)throw new Error("invalid point");var g=m.fromRed().isOdd();return(c&&!g||!c&&g)&&(m=m.redNeg()),this.point(d,m)},r.prototype.pointFromY=function(d,c){d=new t(d,16),d.red||(d=d.toRed(this.red));var u=d.redSqr(),h=u.redSub(this.one),l=u.redMul(this.d).redAdd(this.one),p=h.redMul(l.redInvm());if(p.cmp(this.zero)===0){if(c)throw new Error("invalid point");return this.point(this.zero,d)}var m=p.redSqrt();if(m.redSqr().redSub(p).cmp(this.zero)!==0)throw new Error("invalid point");return m.isOdd()!==c&&(m=m.redNeg()),this.point(m,d)},r.prototype.validate=function(d){if(d.isInfinity())return!0;d.normalize();var c=d.x.redSqr(),u=d.y.redSqr(),h=c.redMul(this.a).redAdd(u),l=this.c2.redMul(this.one.redAdd(this.d.redMul(c).redMul(u)));return h.cmp(l)===0};function a(o,d,c,u,h){i.BasePoint.call(this,o,"projective"),d===null&&c===null&&u===null?(this.x=this.curve.zero,this.y=this.curve.one,this.z=this.curve.one,this.t=this.curve.zero,this.zOne=!0):(this.x=new t(d,16),this.y=new t(c,16),this.z=u?new t(u,16):this.curve.one,this.t=h&&new t(h,16),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)),this.t&&!this.t.red&&(this.t=this.t.toRed(this.curve.red)),this.zOne=this.z===this.curve.one,this.curve.extended&&!this.t&&(this.t=this.x.redMul(this.y),this.zOne||(this.t=this.t.redMul(this.z.redInvm()))))}return s(a,i.BasePoint),r.prototype.pointFromJSON=function(d){return a.fromJSON(this,d)},r.prototype.point=function(d,c,u,h){return new a(this,d,c,u,h)},a.fromJSON=function(d,c){return new a(d,c[0],c[1],c[2])},a.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" y: "+this.y.fromRed().toString(16,2)+" z: "+this.z.fromRed().toString(16,2)+">"},a.prototype.isInfinity=function(){return this.x.cmpn(0)===0&&this.y.cmp(this.z)===0},a.prototype._extDbl=function(){var d=this.x.redSqr(),c=this.y.redSqr(),u=this.z.redSqr();u=u.redIAdd(u);var h=this.curve._mulA(d),l=this.x.redAdd(this.y).redSqr().redISub(d).redISub(c),p=h.redAdd(c),m=p.redSub(u),g=h.redSub(c),y=l.redMul(m),b=p.redMul(g),w=l.redMul(g),S=m.redMul(p);return this.curve.point(y,b,S,w)},a.prototype._projDbl=function(){var d=this.x.redAdd(this.y).redSqr(),c=this.x.redSqr(),u=this.y.redSqr(),h,l,p;if(this.curve.twisted){var m=this.curve._mulA(c),g=m.redAdd(u);if(this.zOne)h=d.redSub(c).redSub(u).redMul(g.redSub(this.curve.two)),l=g.redMul(m.redSub(u)),p=g.redSqr().redSub(g).redSub(g);else{var y=this.z.redSqr(),b=g.redSub(y).redISub(y);h=d.redSub(c).redISub(u).redMul(b),l=g.redMul(m.redSub(u)),p=g.redMul(b)}}else{var m=c.redAdd(u),y=this.curve._mulC(this.c.redMul(this.z)).redSqr(),b=m.redSub(y).redSub(y);h=this.curve._mulC(d.redISub(m)).redMul(b),l=this.curve._mulC(m).redMul(c.redISub(u)),p=m.redMul(b)}return this.curve.point(h,l,p)},a.prototype.dbl=function(){return this.isInfinity()?this:this.curve.extended?this._extDbl():this._projDbl()},a.prototype._extAdd=function(d){var c=this.y.redSub(this.x).redMul(d.y.redSub(d.x)),u=this.y.redAdd(this.x).redMul(d.y.redAdd(d.x)),h=this.t.redMul(this.curve.dd).redMul(d.t),l=this.z.redMul(d.z.redAdd(d.z)),p=u.redSub(c),m=l.redSub(h),g=l.redAdd(h),y=u.redAdd(c),b=p.redMul(m),w=g.redMul(y),S=p.redMul(y),k=m.redMul(g);return this.curve.point(b,w,k,S)},a.prototype._projAdd=function(d){var c=this.z.redMul(d.z),u=c.redSqr(),h=this.x.redMul(d.x),l=this.y.redMul(d.y),p=this.curve.d.redMul(h).redMul(l),m=u.redSub(p),g=u.redAdd(p),y=this.x.redAdd(this.y).redMul(d.x.redAdd(d.y)).redISub(h).redISub(l),b=c.redMul(m).redMul(y),w,S;return this.curve.twisted?(w=c.redMul(g).redMul(l.redSub(this.curve._mulA(h))),S=m.redMul(g)):(w=c.redMul(g).redMul(l.redSub(h)),S=this.curve._mulC(m).redMul(g)),this.curve.point(b,w,S)},a.prototype.add=function(d){return this.isInfinity()?d:d.isInfinity()?this:this.curve.extended?this._extAdd(d):this._projAdd(d)},a.prototype.mul=function(d){return this._hasDoubles(d)?this.curve._fixedNafMul(this,d):this.curve._wnafMul(this,d)},a.prototype.mulAdd=function(d,c,u){return this.curve._wnafMulAdd(1,[this,c],[d,u],2,!1)},a.prototype.jmulAdd=function(d,c,u){return this.curve._wnafMulAdd(1,[this,c],[d,u],2,!0)},a.prototype.normalize=function(){if(this.zOne)return this;var d=this.z.redInvm();return this.x=this.x.redMul(d),this.y=this.y.redMul(d),this.t&&(this.t=this.t.redMul(d)),this.z=this.curve.one,this.zOne=!0,this},a.prototype.neg=function(){return this.curve.point(this.x.redNeg(),this.y,this.z,this.t&&this.t.redNeg())},a.prototype.getX=function(){return this.normalize(),this.x.fromRed()},a.prototype.getY=function(){return this.normalize(),this.y.fromRed()},a.prototype.eq=function(d){return this===d||this.getX().cmp(d.getX())===0&&this.getY().cmp(d.getY())===0},a.prototype.eqXToP=function(d){var c=d.toRed(this.curve.red).redMul(this.z);if(this.x.cmp(c)===0)return!0;for(var u=d.clone(),h=this.curve.redN.redMul(this.z);;){if(u.iadd(this.curve.n),u.cmp(this.curve.p)>=0)return!1;if(c.redIAdd(h),this.x.cmp(c)===0)return!0}return!1},a.prototype.toP=a.prototype.normalize,a.prototype.mixedAdd=a.prototype.add,Ep}var d1;function Nl(){return d1||(d1=1,function(f){var e=f;e.base=u3(),e.short=f3(),e.mont=h3(),e.edwards=l3()}(Pp)),Pp}var Vp={},qp,c1;function p3(){return c1||(c1=1,qp={doubles:{step:4,points:[["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a","f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"],["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508","11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"],["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739","d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"],["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640","4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"],["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c","4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"],["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda","96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"],["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa","5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"],["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0","cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"],["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d","9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"],["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d","e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"],["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1","9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"],["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0","5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"],["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047","10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"],["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862","283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"],["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7","7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"],["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd","56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"],["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83","7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"],["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a","53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"],["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8","bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"],["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d","4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"],["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725","7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"],["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754","4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"],["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c","17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"],["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6","6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"],["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39","c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"],["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891","893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"],["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b","febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"],["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03","2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"],["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d","eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"],["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070","7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"],["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4","e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"],["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da","662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"],["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11","1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"],["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e","efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"],["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41","2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"],["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef","67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"],["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8","db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"],["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d","648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"],["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96","35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"],["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd","ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"],["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5","9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"],["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266","40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"],["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71","34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"],["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac","c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"],["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751","1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"],["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e","493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"],["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241","c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"],["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3","be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"],["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f","4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"],["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19","aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"],["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be","b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"],["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9","6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"],["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2","8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"],["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13","7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"],["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c","ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"],["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba","2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"],["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151","e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"],["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073","d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"],["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458","38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"],["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b","69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"],["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366","d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"],["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa","40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"],["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0","620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"],["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787","7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"],["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e","ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]]},naf:{wnd:7,points:[["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9","388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"],["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4","d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"],["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc","6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"],["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe","cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"],["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb","d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"],["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8","ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"],["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e","581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"],["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34","4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"],["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c","85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"],["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5","321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"],["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f","2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"],["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714","73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"],["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729","a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"],["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db","2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"],["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4","e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"],["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5","b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"],["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479","2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"],["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d","80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"],["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f","1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"],["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb","d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"],["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9","eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"],["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963","758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"],["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74","958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"],["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530","e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"],["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b","5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"],["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247","cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"],["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1","cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"],["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120","4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"],["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435","91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"],["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18","673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"],["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8","59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"],["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb","3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"],["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f","55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"],["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143","efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"],["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba","e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"],["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45","f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"],["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a","744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"],["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e","c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"],["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8","e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"],["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c","30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"],["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519","e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"],["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab","100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"],["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca","ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"],["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf","8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"],["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610","68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"],["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4","f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"],["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c","d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"],["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940","edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"],["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980","a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"],["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3","66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"],["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf","9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"],["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63","4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"],["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448","fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"],["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf","5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"],["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5","8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"],["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6","8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"],["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5","5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"],["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99","f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"],["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51","f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"],["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5","42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"],["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5","204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"],["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997","4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"],["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881","73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"],["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5","39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"],["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66","d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"],["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726","ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"],["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede","6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"],["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94","60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"],["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31","3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"],["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51","b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"],["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252","ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"],["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5","cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"],["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b","6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"],["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4","322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"],["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f","6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"],["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889","2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"],["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246","b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"],["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984","998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"],["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a","b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"],["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030","bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"],["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197","6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"],["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593","c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"],["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef","21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"],["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38","60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"],["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a","49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"],["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111","5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"],["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502","7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"],["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea","be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"],["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26","8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"],["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986","39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"],["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e","62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"],["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4","25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"],["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda","ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"],["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859","cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"],["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f","f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"],["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c","6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"],["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942","fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"],["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a","1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"],["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80","5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"],["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d","438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"],["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1","cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"],["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63","c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"],["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352","6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"],["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193","ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"],["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00","9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"],["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58","ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"],["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7","d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"],["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8","c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"],["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e","67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"],["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d","cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"],["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b","299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"],["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f","f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"],["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6","462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"],["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297","62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"],["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a","7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"],["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c","ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"],["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52","4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"],["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb","bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"],["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065","bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"],["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917","603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"],["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9","cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"],["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3","553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"],["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57","712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"],["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66","ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"],["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8","9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"],["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721","9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"],["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180","4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]]}}),qp}var u1;function t_(){return u1||(u1=1,function(f){var e=f,t=Qn(),s=t.utils.assert;function i(a){a.type==="short"?this.curve=new t.curve.short(a):a.type==="edwards"?this.curve=new t.curve.edwards(a):this.curve=new t.curve.mont(a),this.g=this.curve.g,this.n=this.curve.n,this.hash=a.hash,s(this.g.validate(),"Invalid curve"),s(this.g.mul(this.n).isInfinity(),"Invalid curve, G*N != O")}e.PresetCurve=i;function n(a,o){Object.defineProperty(e,a,{configurable:!0,enumerable:!0,get:function(){var d=new i(o);return Object.defineProperty(e,a,{configurable:!0,enumerable:!0,value:d}),d}})}n("p192",{type:"short",prime:"p192",p:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",a:"ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",b:"64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",n:"ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",hash:"SHA256",gRed:!1,g:["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012","07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]}),n("p224",{type:"short",prime:"p224",p:"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",a:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",b:"b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",n:"ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",hash:"SHA256",gRed:!1,g:["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21","bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]}),n("p256",{type:"short",prime:null,p:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",a:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",b:"5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",n:"ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",hash:"SHA256",gRed:!1,g:["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296","4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]}),n("p384",{type:"short",prime:null,p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",a:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",b:"b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",n:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",hash:"SHA384",gRed:!1,g:["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7","3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]}),n("p521",{type:"short",prime:null,p:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",a:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",b:"00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",n:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",hash:"SHA512",gRed:!1,g:["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66","00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]}),n("curve25519",{type:"mont",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"76d06",b:"1",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",hash:"SHA256",gRed:!1,g:["9"]}),n("ed25519",{type:"edwards",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"-1",c:"1",d:"52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",hash:"SHA256",gRed:!1,g:["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a","6666666666666666666666666666666666666666666666666666666666666658"]});var r;try{r=p3()}catch{r=void 0}n("secp256k1",{type:"short",prime:"k256",p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",a:"0",b:"7",n:"ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",h:"1",hash:"SHA256",beta:"7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",lambda:"5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",basis:[{a:"3086d221a7d46bcde86c90e49284eb15",b:"-e4437ed6010e88286f547fa90abfe4c3"},{a:"114ca50f7a8e2f3f657c1108d9d44cfd8",b:"3086d221a7d46bcde86c90e49284eb15"}],gRed:!1,g:["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798","483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",r]})}(Vp)),Vp}var on=_d.exports,s_=fo.assert,m3=fo,{byteArrayToWordArray:f1}=xd.exports;const g3=on.enc.Utf8.parse(""),y3=on.enc.Utf8.parse("\0");function da(f){if(!(this instanceof da))return new da(f);this.hash=f.hash,this.predResist=!!f.predResist,this.outLen=this.hash.slice(3,6),this.minEntropy=f.minEntropy||192,this._reseed=null,this.reseedInterval=null,this.K=null,this.V=null;var e=f.entropy,t=f.nonce,s=[];s_(e.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits"),this._init(e,t,s)}var b3=da;da.prototype._init=function(e,t,s){var i=e.concat(t).concat(s);this.K=new on.lib.WordArray.init,this.V=new on.lib.WordArray.init;const n=(1<<24)+(1<<16)+(1<<8)+1;this.V.words=Array(this.outLen/32).fill(n),this.V.sigBytes=32,this._update(i),this._reseed=1,this.reseedInterval=281474976710656};da.prototype._hmac=function(){return new on.lib.WordArray.init};da.prototype._update=function(e){var t=this._hmac();t.concat(this.V),t.concat(y3),e&&t.concat(f1(e)),this.K=on["Hmac"+this.hash](t,this.K),this.V=on["Hmac"+this.hash](this.V,this.K),e&&(t=this._hmac(),t.concat(this.V),t.concat(g3),t.concat(f1(e)),this.K=on["Hmac"+this.hash](t,this.K),this.V=on["Hmac"+this.hash](this.V,this.K))};da.prototype.reseed=function(e,t,s,i){typeof t!="string"&&(s=t,t=null),s_(e.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits"),this._update(e.concat(s||[])),this._reseed=1};da.prototype.generate=function(e,t,s,i){if(this._reseed>this.reseedInterval)throw new Error("Reseed is required");typeof t!="string"&&(s=t,t=null),s&&(s=on.enc.Utf8.parse(s),this._update(s));for(var n=new on.lib.WordArray.init;n.sigBytes<e;)this.V=on["Hmac"+this.hash](this.V,this.K),n.concat(this.V);return this._update(s),this._reseed++,m3.wordArrayToBuffer(n)};var Lp,h1;function w3(){if(h1)return Lp;h1=1;var f=Fi.exports,e=Qn(),t=e.utils,s=t.assert;function i(n,r){this.ec=n,this.priv=null,this.pub=null,r.priv&&this._importPrivate(r.priv,r.privEnc),r.pub&&this._importPublic(r.pub,r.pubEnc)}return Lp=i,i.fromPublic=function(r,a,o){return a instanceof i?a:new i(r,{pub:a,pubEnc:o})},i.fromPrivate=function(r,a,o){return a instanceof i?a:new i(r,{priv:a,privEnc:o})},i.prototype.validate=function(){var r=this.getPublic();return r.isInfinity()?{result:!1,reason:"Invalid public key"}:r.validate()?r.mul(this.ec.curve.n).isInfinity()?{result:!0,reason:null}:{result:!1,reason:"Public key * N != O"}:{result:!1,reason:"Public key is not a point"}},i.prototype.getPublic=function(r,a){return typeof r=="string"&&(a=r,r=null),this.pub||(this.pub=this.ec.g.mul(this.priv)),a?this.pub.encode(a,r):this.pub},i.prototype.getPrivate=function(r){return r==="hex"?this.priv.toString(16,2):this.priv},i.prototype._importPrivate=function(r,a){this.priv=new f(r,a||16),this.priv=this.priv.umod(this.ec.curve.n)},i.prototype._importPublic=function(r,a){if(r.x||r.y){this.ec.curve.type==="mont"?s(r.x,"Need x coordinate"):(this.ec.curve.type==="short"||this.ec.curve.type==="edwards")&&s(r.x&&r.y,"Need both x and y coordinate"),this.pub=this.ec.curve.point(r.x,r.y);return}this.pub=this.ec.curve.decodePoint(r,a)},i.prototype.derive=function(r){return r.mul(this.priv).getX()},i.prototype.sign=function(r,a,o){return this.ec.sign(r,this,a,o)},i.prototype.verify=function(r,a){return this.ec.verify(r,a,this)},i.prototype.inspect=function(){return"<Key priv: "+(this.priv&&this.priv.toString(16,2))+" pub: "+(this.pub&&this.pub.inspect())+" >"},Lp}var Rp,l1;function S3(){if(l1)return Rp;l1=1;var f=Fi.exports,e=Qn(),t=e.utils,s=t.assert;function i(n,r){if(n instanceof i)return n;s(n.r&&n.s,"Signature without r or s"),this.r=new f(n.r,16),this.s=new f(n.s,16),n.recoveryParam===void 0?this.recoveryParam=null:this.recoveryParam=n.recoveryParam}return Rp=i,Rp}var Fp,p1;function k3(){if(p1)return Fp;p1=1;var f=Fi.exports,e=b3,t=Qn(),s=t.utils,i=s.assert,n=w3(),r=S3();function a(o){if(!(this instanceof a))return new a(o);typeof o=="string"&&(i(t.curves.hasOwnProperty(o),"Unknown curve "+o),o=t.curves[o]),o instanceof t.curves.PresetCurve&&(o={curve:o}),this.curve=o.curve.curve,this.n=this.curve.n,this.nh=this.n.ushrn(1),this.g=this.curve.g,this.g=o.curve.g,this.g.precompute(o.curve.n.bitLength()+1),this.hash=o.hash||o.curve.hash}return Fp=a,a.prototype.keyPair=function(d){return new n(this,d)},a.prototype.keyFromPrivate=function(d,c){return n.fromPrivate(this,d,c)},a.prototype.keyFromPublic=function(d,c){return n.fromPublic(this,d,c)},a.prototype.genKeyPair=function(d){d||(d={});var c=new e({hash:this.hash,pers:d.pers,persEnc:d.persEnc||"utf8",entropy:d.entropy||null,entropyEnc:d.entropy&&d.entropyEnc||"utf8",nonce:this.n.toArray()}),u=this.n.byteLength(),h=this.n.sub(new f(2));do{var l=new f(c.generate(u));if(!(l.cmp(h)>0))return l.iaddn(1),this.keyFromPrivate(l)}while(!0)},a.prototype._truncateToN=function(d,c){var u=d.byteLength()*8-this.n.bitLength();return u>0&&(d=d.ushrn(u)),!c&&d.cmp(this.n)>=0?d.sub(this.n):d},a.prototype.sign=function(d,c,u,h){typeof u=="object"&&(h=u,u=null),h||(h={}),c=this.keyFromPrivate(c,u),d=this._truncateToN(new f(d,16));for(var l=this.n.byteLength(),p=c.getPrivate().toArray("be",l),m=d.toArray("be",l),g=new e({hash:this.hash,entropy:h.extraEntropy?p.concat(h.extraEntropy):p,nonce:m,pers:h.pers,persEnc:h.persEnc||"utf8"}),y=this.n.sub(new f(1)),b=0;;b++){var w=h.k?h.k(b):new f(g.generate(this.n.byteLength()));if(w=this._truncateToN(w,!0),!(w.cmpn(1)<=0||w.cmp(y)>=0)){var S=this.g.mul(w);if(!S.isInfinity()){var k=S.getX(),T=k.umod(this.n);if(T.cmpn(0)!==0){var I=w.invm(this.n).mul(T.mul(c.getPrivate()).iadd(d));if(I=I.umod(this.n),I.cmpn(0)!==0){var _=(S.getY().isOdd()?1:0)|(k.cmp(T)!==0?2:0);return h.canonical&&I.cmp(this.nh)>0&&(I=this.n.sub(I),_^=1),new r({r:T,s:I,recoveryParam:_})}}}}}},a.prototype.verify=function(d,c,u,h){d=this._truncateToN(new f(d,16)),u=this.keyFromPublic(u,h),c=new r(c,"hex");var l=c.r,p=c.s;if(l.cmpn(1)<0||l.cmp(this.n)>=0||p.cmpn(1)<0||p.cmp(this.n)>=0)return!1;var m=p.invm(this.n),g=m.mul(d).umod(this.n),y=m.mul(l).umod(this.n);if(!this.curve._maxwellTrick){var b=this.g.mulAdd(g,u.getPublic(),y);return b.isInfinity()?!1:b.getX().umod(this.n).cmp(l)===0}var b=this.g.jmulAdd(g,u.getPublic(),y);return b.isInfinity()?!1:b.eqXToP(l)},a.prototype.recoverPubKey=function(o,d,c,u){i((3&c)===c,"The recovery param is more than two bits"),d=new r(d,u);var h=this.n,l=new f(o),p=d.r,m=d.s,g=c&1,y=c>>1;if(p.cmp(this.curve.p.umod(this.curve.n))>=0&&y)throw new Error("Unable to find sencond key candinate");y?p=this.curve.pointFromX(p.add(this.curve.n),g):p=this.curve.pointFromX(p,g);var b=d.r.invm(h),w=h.sub(l).mul(b).umod(h),S=m.mul(b).umod(h);return this.g.mulAdd(w,p,S)},a.prototype.getKeyRecoveryParam=function(o,d,c,u){if(d=new r(d,u),d.recoveryParam!==null)return d.recoveryParam;for(var h=0;h<4;h++){var l;try{l=this.recoverPubKey(o,d,h)}catch{continue}if(l.eq(c))return h}throw new Error("Unable to find valid recovery factor")},Fp}var Pu=fo,pb=Pu.assert,m1=Pu.parseBytes,Nd=Pu.cachedProperty;function Cs(f,e){this.eddsa=f,this._secret=m1(e.secret),f.isPoint(e.pub)?this._pub=e.pub:this._pubBytes=m1(e.pub)}Cs.fromPublic=function(e,t){return t instanceof Cs?t:new Cs(e,{pub:t})};Cs.fromSecret=function(e,t){return t instanceof Cs?t:new Cs(e,{secret:t})};Cs.prototype.secret=function(){return this._secret};Nd(Cs,"pubBytes",function(){return this.eddsa.encodePoint(this.pub())});Nd(Cs,"pub",function(){return this._pubBytes?this.eddsa.decodePoint(this._pubBytes):this.eddsa.g.mul(this.priv())});Nd(Cs,"privBytes",function(){var e=this.eddsa,t=this.hash(),s=e.encodingLength-1,i=t.slice(0,e.encodingLength);return i[0]&=248,i[s]&=127,i[s]|=64,i});Nd(Cs,"priv",function(){return this.eddsa.decodeInt(this.privBytes())});Nd(Cs,"hash",function(){return this.eddsa.hash().update(this.secret()).digest()});Nd(Cs,"messagePrefix",function(){return this.hash().slice(this.eddsa.encodingLength)});Cs.prototype.sign=function(e){return pb(this._secret,"KeyPair can only verify"),this.eddsa.sign(e,this)};Cs.prototype.signModified=function(e){return pb(this._secret,"KeyPair can only verify"),this.eddsa.signModified(e,this)};Cs.prototype.verify=function(e,t){return this.eddsa.verify(e,t,this)};Cs.prototype.getSecret=function(e){return pb(this._secret,"KeyPair is public only"),Pu.encode(this.secret(),e)};Cs.prototype.getPublic=function(e){return Pu.encode(this.pubBytes(),e)};var v3=Cs,T3=Fi.exports,El=fo,O3=El.assert,Vl=El.cachedProperty,I3=El.parseBytes;function ho(f,e){this.eddsa=f,typeof e!="object"&&(e=I3(e)),Array.isArray(e)&&(e={R:e.slice(0,f.encodingLength),S:e.slice(f.encodingLength)}),O3(e.R&&e.S,"Signature without R or S"),f.isPoint(e.R)&&(this._R=e.R),e.S instanceof T3&&(this._S=e.S),this._Rencoded=Array.isArray(e.R)?e.R:e.Rencoded,this._Sencoded=Array.isArray(e.S)?e.S:e.Sencoded}Vl(ho,"S",function(){return this.eddsa.decodeInt(this.Sencoded())});Vl(ho,"R",function(){return this.eddsa.decodePoint(this.Rencoded())});Vl(ho,"Rencoded",function(){return this.eddsa.encodePoint(this.R())});Vl(ho,"Sencoded",function(){return this.eddsa.encodeInt(this.S())});ho.prototype.toBytes=function(){return this.Rencoded().concat(this.Sencoded())};ho.prototype.toHex=function(){return El.encode(this.toBytes(),"hex").toUpperCase()};var x3=ho,Dp,g1;function _3(){if(g1)return Dp;g1=1;var f=t_(),e=fo,t=e.assert,s=e.parseBytes,i=v3,n=x3;const r=Fi.exports,{byteArrayToWordArray:a}=xd.exports,o=_d.exports;function d(c){if(t(c==="ed25519","only tested with ed25519 so far"),!(this instanceof d))return new d(c);var u=f[c].curve;this.curve=u,this.g=u.g,this.g.precompute(u.n.bitLength()+1),this.pointClass=u.point().constructor,this.encodingLength=Math.ceil(u.n.bitLength()/8)}return Dp=d,d.prototype.sign=function(u,h){u=s(u);var l=this.keyFromSecret(h),p=this.hashInt(l.secret(),u),m=this.g.mul(p),g=this.encodePoint(m),y=this.hashInt(g,l.pubBytes(),u);y=y.mul(l.priv());var b=p.add(y).umod(this.curve.n);return this.makeSignature({R:m,S:b,Rencoded:g})},d.prototype.signModified=function(u,h){u=s(u);var l=this.keyFromSecret(h);const p=new r(l.secret(),16,"le"),m=this.encodePoint(this.g.mul(p)),g=m[31]&128;var y=this.hashInt(l.secret(),u),b=this.g.mul(y),w=this.encodePoint(b);let S=this.hashInt(w,m,u);S=S.mul(p);var k=y.add(S).umod(this.curve.n),T=k.toArray("le",32);return T[31]|=g,this.makeSignature({R:b,S:k,Rencoded:w,Sencoded:T})},d.prototype.verify=function(u,h,l){u=s(u),h=this.makeSignature(h);var p=this.keyFromPublic(l),m=this.hashInt(h.Rencoded(),p.pubBytes(),u),g=this.g.mul(h.S()),y=h.R().add(p.pub().mul(m));return y.eq(g)},d.prototype.hashInt=function(){let u=Array.from(arguments).reduce((l,p)=>l.concat(p));u=a(u);const h=o.SHA512(u).toString(o.enc.Hex);return e.intFromLE(h).umod(this.curve.n)},d.prototype.keyFromPublic=function(u){return i.fromPublic(this,u)},d.prototype.keyFromSecret=function(u){return i.fromSecret(this,u)},d.prototype.makeSignature=function(u){return u instanceof n?u:new n(this,u)},d.prototype.encodePoint=function(u){var h=u.getY().toArray("le",this.encodingLength);return h[this.encodingLength-1]|=u.getX().isOdd()?128:0,h},d.prototype.decodePoint=function(u){u=e.parseBytes(u);var h=u.length-1,l=u.slice(0,h).concat(u[h]&-129),p=(u[h]&128)!==0,m=e.intFromLE(l);return this.curve.pointFromY(m,p)},d.prototype.encodeInt=function(u){return u.toArray("le",this.encodingLength)},d.prototype.decodeInt=function(u){return e.intFromLE(u)},d.prototype.isPoint=function(u){return u instanceof this.pointClass},Dp}var y1;function Qn(){return y1||(y1=1,function(f){var e=f;function t(s,i){s.super_=i;var n=function(){};n.prototype=i.prototype,s.prototype=new n,s.prototype.constructor=s}e.inherits=t,e.version="6.5.0",e.utils=fo,e.curve=Nl(),e.curves=t_(),e.ec=k3(),e.eddsa=_3()}(Mp)),Mp}const C3={BaseError:{ExchangeError:{AuthenticationError:{PermissionDenied:{AccountNotEnabled:{}},AccountSuspended:{}},ArgumentsRequired:{},BadRequest:{BadSymbol:{},MarginModeAlreadySet:{}},BadResponse:{NullResponse:{}},InsufficientFunds:{},InvalidAddress:{AddressPending:{}},InvalidOrder:{OrderNotFound:{},OrderNotCached:{},CancelPending:{},OrderImmediatelyFillable:{},OrderNotFillable:{},DuplicateOrderId:{}},NotSupported:{}},NetworkError:{DDoSProtection:{RateLimitExceeded:{}},ExchangeNotAvailable:{OnMaintenance:{}},InvalidNonce:{},RequestTimeout:{}}}};var M3=C3;const P3=M3;function i_(f,e,t={}){for(const[s,i]of Object.entries(e)){const n=Object.assign(t,{[s]:class extends f{constructor(r){super(r),this.constructor=n,this.__proto__=n.prototype,this.name=s,this.message=r,Object.setPrototypeOf(this,n.prototype)}}})[s];i_(n,i,t)}return t}var oe=i_(Error,P3);const gd=_d.exports,{capitalize:uy}=ob,{stringToBase64:b1,urlencodeBase64:sf}=xd.exports,A3=c3,{binaryToBase58:B3,byteArrayToWordArray:N3}=xd.exports,n_=Qn(),E3=n_.ec,V3=n_.eddsa,nf=Fi.exports,r_=(f,e="md5",t="hex")=>{const s={};e==="keccak"&&(e="SHA3",s.outputLength=256);const i=gd[e.toUpperCase()](f,s);return t==="binary"?i:i.toString(gd.enc[uy(t)])},mb=(f,e,t="sha256",s="hex")=>{const i=gd["Hmac"+t.toUpperCase()](f,e);if(s){const n=s==="binary"?"Latin1":uy(s);return i.toString(gd.enc[uy(n)])}return i};function a_(f,e,t="RS256"){const s={RS256:"pkcs1-sha256",RS512:"pkcs1-sha512"};if(!(t in s))throw new ExchangeError(t+" is not a supported rsa signing algorithm.");const i=s[t];return new A3(e,{environment:"browser",signingScheme:i}).sign(f,"base64","binary")}function q3(f,e,t="HS256"){const s={HS256:"sha256",HS384:"sha384",HS512:"sha512"},i=sf(b1(JSON.stringify({alg:t,typ:"JWT"}))),n=sf(b1(JSON.stringify(f))),r=[i,n].join("."),a=t.slice(0,2),o=s[t];let d;return a==="HS"?d=sf(mb(r,e,o,"base64")):a==="RS"&&(d=sf(a_(r,e,t))),[r,d].join(".")}function L3(f,e,t="p256",s=void 0,i=!1){let n=f;s!==void 0&&(n=r_(f,s,"hex"));const r=new E3(t);let a=r.sign(n,e,"hex",{canonical:!0}),o=new nf("0");const d=new nf("1").shln(8*31).sub(new nf("1"));for(;i&&(a.r.gt(r.nh)||a.r.lte(d)||a.s.lte(d));)a=r.sign(n,e,"hex",{canonical:!0,extraEntropy:o.toArray("le",32)}),o=o.add(new nf("1"));return{r:a.r.toString(16).padStart(64,"0"),s:a.s.toString(16).padStart(64,"0"),v:a.recoveryParam}}function R3(f,e,t="ed25519"){const i=new V3(t).signModified(f,e);return B3(N3(i.toBytes()))}const F3=f=>{const e=r=>(r<15.5?"0":"")+Math.round(r).toString(16),t=r=>parseInt(r,16),s=(r,a)=>(a+r).slice(-a.length),i=r=>{let a="ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",o="",d="";for(let c=0;c<r.length;c++){let u=a.indexOf(r.charAt(c).toUpperCase());o+=s(u.toString(2),"00000")}for(let c=0;c+4<=o.length;c+=4){let u=o.substr(c,4);d=d+parseInt(u,2).toString(16)}return d};return(r=>{r=r.replace(" ","");let a=Math.round(new Date().getTime()/1e3),o=s(e(Math.floor(a/30)),"0000000000000000"),d=mb(gd.enc.Hex.parse(o),gd.enc.Hex.parse(i(r)),"sha1","hex"),c=t(d.substring(d.length-1)),u=(t(d.substr(c*2,8))&t("7fffffff"))+"";return u=u.substr(u.length-6,6),u})(f)};function Gh(f,e=!1){const t="00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D";Gh.table===void 0&&(Gh.table=t.split(" ").map(n=>parseInt(n,16)));let s=-1;for(let n=0;n<f.length;n++)s=s>>>8^Gh.table[(s^f.charCodeAt(n))&255];const i=(s^-1)>>>0;return e&&i>=2147483648?i-4294967296:i}var D3={hash:r_,hmac:mb,jwt:q3,totp:F3,rsa:a_,ecdsa:L3,eddsa:R3,crc32:Gh};const yd=Date.now,o_=()=>yd()*1e3,H3=yd,G3=()=>Math.floor(yd()/1e3),U3=()=>{const s=(o_()*10+122192928e9).toString(16),i=s.slice(7,15)+s.slice(3,7)+"1"+s.slice(0,3),n="9696",r="ff".repeat(6);return i+n+r},$3=setTimeout,Uh=(f,e,t=$3,s=yd()+e)=>{if(e>=2147483647)throw new Error("setTimeout() function was called with unrealistic value of "+e.toString());let i=()=>{},n=!0;const r=t(()=>{n=!0;const a=s-yd();a>0?i=Uh(f,a,t,s):f()},e);return function(){n&&(n=!1,clearTimeout(r)),i()}};class Su extends Error{constructor(){const e="timed out";super(e),this.constructor=Su,this.__proto__=Su.prototype,this.message=e}}const j3=f=>{let e;if(typeof f=="number"?e=Math.floor(f):e=parseInt(f,10),!(Number.isNaN(e)||e<0))try{return new Date(e).toISOString()}catch{return}},d_=f=>{if(!(typeof f!="string"||!f)&&!f.match(/^[0-9]+$/)&&!(f.indexOf("-")<0||f.indexOf(":")<0))try{const e=Date.parse(f.indexOf("+")>=0||f.slice(-1)==="Z"?f:(f+"Z").replace(/\s(\d\d):/,"T$1:"));return Number.isNaN(e)?void 0:e}catch{return}},W3=f=>{if(!(typeof f!="string"||!f)){if(f.indexOf("GMT")>=0)try{return Date.parse(f)}catch{return}return d_(f)}},z3=(f=void 0)=>new Date(f).toUTCString(),K3=(f,e="-")=>{e=e||"";const t=new Date(f),s=t.getUTCFullYear().toString();let i=t.getUTCMonth()+1,n=t.getUTCDate();return i=i<10?"0"+i:i.toString(),n=n<10?"0"+n:n.toString(),i+e+n+e+s},gb=(f,e,t=!0)=>{e=e||"";const s=new Date(f),i=s.getUTCFullYear(),r=(t?i:i-2e3).toString();let a=s.getUTCMonth()+1,o=s.getUTCDate();return a=a<10?"0"+a:a.toString(),o=o<10?"0"+o:o.toString(),r+e+a+e+o},X3=(f,e="")=>gb(f,e,!1),Y3=(f,e="-")=>gb(f,e,!0),Q3=(f,e=" ")=>{const t=new Date(f),s=t.getUTCFullYear();let i=t.getUTCMonth()+1,n=t.getUTCDate(),r=t.getUTCHours(),a=t.getUTCMinutes(),o=t.getUTCSeconds();return i=i<10?"0"+i:i,n=n<10?"0"+n:n,r=r<10?"0"+r:r,a=a<10?"0"+a:a,o=o<10?"0"+o:o,s+"-"+i+"-"+n+e+r+":"+a+":"+o};var yb={now:yd,microseconds:o_,milliseconds:H3,seconds:G3,iso8601:j3,parse8601:d_,rfc2616:z3,uuidv1:U3,parseDate:W3,mdy:K3,ymd:gb,yymmdd:X3,yyyymmdd:Y3,ymdhms:Q3,setTimeout_safe:Uh,sleep:f=>new Promise(e=>Uh(e,f)),TimedOut:Su,timeout:async(f,e)=>{let t=()=>{};const s=new Promise(i=>t=Uh(i,f));try{return await Promise.race([e,s.then(()=>{throw new Su})])}finally{t()}}};const{now:w1,sleep:Z3}=yb;class J3{constructor(e){this.config={refillRate:1,delay:.001,capacity:1,maxCapacity:2e3,tokens:0,cost:1},Object.assign(this.config,e),this.queue=[],this.running=!1}async loop(){let e=w1();for(;this.running;){const{resolver:t,cost:s}=this.queue[0];if(this.config.tokens>=0)this.config.tokens-=s,t(),this.queue.shift(),await Promise.resolve(),this.queue.length===0&&(this.running=!1);else{await Z3(this.config.delay*1e3);const i=w1(),n=i-e;e=i;const r=this.config.tokens+this.config.refillRate*n;this.config.tokens=Math.min(r,this.config.capacity)}}}}function eV(f){function e(i=void 0){let n;const r=new Promise((a,o)=>{n=a});if(this.queue.length>this.config.maxCapacity)throw new Error("throttle queue is over maxCapacity ("+this.config.maxCapacity.toString()+"), see https://github.com/ccxt/ccxt/issues/11645#issuecomment-1195695526");return i=i===void 0?this.config.cost:i,this.queue.push({resolver:n,cost:i}),this.running||(this.running=!0,this.loop()),r}const t=new J3(f),s=e.bind(t);return s.config=t.config,s.queue=t.queue,s}var tV={throttle:eV};const{ROUND_UP:c_,ROUND_DOWN:u_}=pe,{NotSupported:sV}=oe,bb=f=>{const e=f.slice(0,-1),t=f.slice(-1);let s;if(t==="y")s=60*60*24*365;else if(t==="M")s=60*60*24*30;else if(t==="w")s=60*60*24*7;else if(t==="d")s=60*60*24;else if(t==="h")s=60*60;else if(t==="m")s=60;else if(t==="s")s=1;else throw new sV("timeframe unit "+t+" is not supported");return e*s},iV=(f,e,t=u_)=>{const s=bb(f)*1e3,i=e%s;return e-i+(t===c_?s:0)},nV=(f,e="1m",t=-1/0,s=1/0)=>{const i=bb(e)*1e3,n=[],[r,,a,o,d,c,u]=[0,1,2,3,4,5,6],h=Math.min(f.length-1,s);for(let l=0;l<=h;l++){const p=f[l];if(p.timestamp<t)continue;const m=Math.floor(p.timestamp/i)*i,g=n.length-1;g===-1||m>=n[g][r]+i?n.push([m,p.price,p.price,p.price,p.price,p.amount,1]):(n[g][a]=Math.max(n[g][a],p.price),n[g][o]=Math.min(n[g][o],p.price),n[g][d]=p.price,n[g][c]+=p.amount,n[g][u]++)}return n},rV=f=>{const e=/{([\w-]+)}/g,t=[];let s=e.exec(f);for(;s;)t.push(s[1]),s=e.exec(f);return t},aV=(f,e)=>{if(!Array.isArray(e)){const t=Object.keys(e);for(let s=0;s<t.length;s++){const i=t[s];Array.isArray(e[i])||(f=f.replace("{"+i+"}",e[i]))}}return f};function oV(f,e){return f!==void 0&&e!==void 0&&f>0?e/f:void 0}var dV={aggregate(f){const e={};for(let t=0;t<f.length;t++){const[s,i]=f[t];i>0&&(e[s]=(e[s]||0)+i)}return Object.keys(e).map(t=>[parseFloat(t),parseFloat(e[t])])},parseTimeframe:bb,roundTimeframe:iV,buildOHLCVC:nV,ROUND_UP:c_,ROUND_DOWN:u_,implodeParams:aV,extractParams:rV,vwap:oV};const{unCamelCase:cV}=ob,uV=f=>{for(const e in f)f[cV(e)]=f[e];return f};var Au=uV(Object.assign({},UB,Ex,ob,Bx,pe,xd.exports,D3,yb,tV,dV));const fV=BigInt(0),hV=BigInt(-1),Dd=BigInt(10);class Ze{constructor(e,t=void 0){if(t===void 0){let s=0;e=e.toLowerCase(),e.indexOf("e")>-1&&([e,s]=e.split("e"),s=parseInt(s));const i=e.indexOf(".");this.decimals=i>-1?e.length-i-1:0;const n=e.replace(".","");this.integer=BigInt(n),this.decimals=this.decimals-s}else this.integer=e,this.decimals=t}mul(e){const t=this.integer*e.integer;return new Ze(t,this.decimals+e.decimals)}div(e,t=18){const s=t-this.decimals+e.decimals;let i;if(s===0)i=this.integer;else if(s<0){const r=Dd**BigInt(-s);i=this.integer/r}else{const r=Dd**BigInt(s);i=this.integer*r}const n=i/e.integer;return new Ze(n,t)}add(e){if(this.decimals===e.decimals){const t=this.integer+e.integer;return new Ze(t,this.decimals)}else{const[t,s]=this.decimals>e.decimals?[e,this]:[this,e],i=s.decimals-t.decimals,r=t.integer*Dd**BigInt(i)+s.integer;return new Ze(r,s.decimals)}}mod(e){const t=Math.max(-this.decimals+e.decimals,0),s=this.integer*Dd**BigInt(t),i=Math.max(-e.decimals+this.decimals,0),n=e.integer*Dd**BigInt(i),r=s%n;return new Ze(r,i+e.decimals)}sub(e){const t=new Ze(-e.integer,e.decimals);return this.add(t)}abs(){return new Ze(this.integer<0?this.integer*hV:this.integer,this.decimals)}neg(){return new Ze(-this.integer,this.decimals)}min(e){return this.lt(e)?this:e}max(e){return this.gt(e)?this:e}gt(e){return this.sub(e).integer>0}ge(e){return this.sub(e).integer>=0}lt(e){return e.gt(this)}le(e){return e.ge(this)}reduce(){const e=this.integer.toString(),t=e.length-1;if(t===0)return e==="0"&&(this.decimals=0),this;let s;for(s=t;s>=0&&e.charAt(s)==="0";s--);const i=t-s;if(i===0)return this;this.decimals-=i,this.integer=BigInt(e.slice(0,s+1))}equals(e){return this.reduce(),e.reduce(),this.decimals===e.decimals&&this.integer===e.integer}toString(){this.reduce();let e,t;this.integer<0?(e="-",t=-this.integer):(e="",t=this.integer);const s=Array.from(t.toString(this.base).padStart(this.decimals,"0")),i=s.length-this.decimals;let n;return i===0?n="0.":this.decimals<0?n="0".repeat(-this.decimals):this.decimals===0?n="":n=".",s.splice(i,0,n),e+s.join("")}static stringMul(e,t){if(!(e===void 0||t===void 0))return new Ze(e).mul(new Ze(t)).toString()}static stringDiv(e,t,s=18){if(e===void 0||t===void 0)return;const i=new Ze(t);if(i.integer!==fV)return new Ze(e).div(i,s).toString()}static stringAdd(e,t){if(!(e===void 0&&t===void 0))return e===void 0?t:t===void 0?e:new Ze(e).add(new Ze(t)).toString()}static stringSub(e,t){if(!(e===void 0||t===void 0))return new Ze(e).sub(new Ze(t)).toString()}static stringAbs(e){if(e!==void 0)return new Ze(e).abs().toString()}static stringNeg(e){if(e!==void 0)return new Ze(e).neg().toString()}static stringMod(e,t){if(!(e===void 0||t===void 0))return new Ze(e).mod(new Ze(t)).toString()}static stringEquals(e,t){if(!(e===void 0||t===void 0))return new Ze(e).equals(new Ze(t))}static stringEq(e,t){if(!(e===void 0||t===void 0))return new Ze(e).equals(new Ze(t))}static stringMin(e,t){if(!(e===void 0||t===void 0))return new Ze(e).min(new Ze(t)).toString()}static stringMax(e,t){if(!(e===void 0||t===void 0))return new Ze(e).max(new Ze(t)).toString()}static stringGt(e,t){if(!(e===void 0||t===void 0))return new Ze(e).gt(new Ze(t))}static stringGe(e,t){if(!(e===void 0||t===void 0))return new Ze(e).ge(new Ze(t))}static stringLt(e,t){if(!(e===void 0||t===void 0))return new Ze(e).lt(new Ze(t))}static stringLe(e,t){if(!(e===void 0||t===void 0))return new Ze(e).le(new Ze(t))}}var ke=Ze;const wb=Au,{isNode:wo,clone:Hp,unCamelCase:lV,throttle:pV,timeout:mV,TimedOut:gV,defaultFetch:Hd}=wb,{ExchangeError:Br,BadSymbol:Gp,NullResponse:S1,InvalidAddress:Up,InvalidOrder:k1,NotSupported:De,AuthenticationError:$p,DDoSProtection:yV,RequestTimeout:jp,ExchangeNotAvailable:qs,RateLimitExceeded:bV,ArgumentsRequired:va}=oe,{TRUNCATE:v1,ROUND:Wp,DECIMAL_PLACES:T1,NO_PADDING:wV,TICK_SIZE:SV}=wb.precisionConstants,Qe=ke;var me=class fy{describe(){return{id:void 0,name:void 0,countries:void 0,enableRateLimit:!0,rateLimit:2e3,certified:!1,pro:!1,alias:!1,has:{publicAPI:!0,privateAPI:!0,CORS:void 0,spot:void 0,margin:void 0,swap:void 0,future:void 0,option:void 0,addMargin:void 0,cancelAllOrders:void 0,cancelOrder:!0,cancelOrders:void 0,createDepositAddress:void 0,createLimitOrder:!0,createMarketOrder:!0,createOrder:!0,createPostOnlyOrder:void 0,createReduceOnlyOrder:void 0,createStopOrder:void 0,createStopLimitOrder:void 0,createStopMarketOrder:void 0,editOrder:"emulated",fetchAccounts:void 0,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowInterest:void 0,fetchBorrowRate:void 0,fetchBorrowRateHistory:void 0,fetchBorrowRatesPerSymbol:void 0,fetchBorrowRates:void 0,fetchCanceledOrders:void 0,fetchClosedOrder:void 0,fetchClosedOrders:void 0,fetchCurrencies:"emulated",fetchDeposit:void 0,fetchDepositAddress:void 0,fetchDepositAddresses:void 0,fetchDepositAddressesByNetwork:void 0,fetchDeposits:void 0,fetchTransactionFee:void 0,fetchTransactionFees:void 0,fetchFundingHistory:void 0,fetchFundingRate:void 0,fetchFundingRateHistory:void 0,fetchFundingRates:void 0,fetchIndexOHLCV:void 0,fetchL2OrderBook:!0,fetchLedger:void 0,fetchLedgerEntry:void 0,fetchLeverageTiers:void 0,fetchMarketLeverageTiers:void 0,fetchMarkets:!0,fetchMarkOHLCV:void 0,fetchMyTrades:void 0,fetchOHLCV:"emulated",fetchOpenOrder:void 0,fetchOpenOrders:void 0,fetchOrder:void 0,fetchOrderBook:!0,fetchOrderBooks:void 0,fetchOrders:void 0,fetchOrderTrades:void 0,fetchPermissions:void 0,fetchPosition:void 0,fetchPositions:void 0,fetchPositionsRisk:void 0,fetchPremiumIndexOHLCV:void 0,fetchStatus:"emulated",fetchTicker:!0,fetchTickers:void 0,fetchTime:void 0,fetchTrades:!0,fetchTradingFee:void 0,fetchTradingFees:void 0,fetchTradingLimits:void 0,fetchTransactions:void 0,fetchTransfers:void 0,fetchWithdrawal:void 0,fetchWithdrawals:void 0,reduceMargin:void 0,setLeverage:void 0,setMargin:void 0,setMarginMode:void 0,setPositionMode:void 0,signIn:void 0,transfer:void 0,withdraw:void 0},urls:{logo:void 0,api:void 0,www:void 0,doc:void 0,fees:void 0},api:void 0,requiredCredentials:{apiKey:!0,secret:!0,uid:!1,login:!1,password:!1,twofa:!1,privateKey:!1,walletAddress:!1,token:!1},markets:void 0,currencies:{},timeframes:void 0,fees:{trading:{tierBased:void 0,percentage:void 0,taker:void 0,maker:void 0},funding:{tierBased:void 0,percentage:void 0,withdraw:{},deposit:{}}},status:{status:"ok",updated:void 0,eta:void 0,url:void 0},exceptions:void 0,httpExceptions:{422:Br,418:yV,429:bV,404:qs,409:qs,410:qs,500:qs,501:qs,502:qs,520:qs,521:qs,522:qs,525:qs,526:qs,400:qs,403:qs,405:qs,503:qs,530:qs,408:jp,504:jp,401:$p,511:$p},commonCurrencies:{XBT:"BTC",BCC:"BCH",BCHABC:"BCH",BCHSV:"BSV"},precisionMode:T1,paddingMode:wV,limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}}}}constructor(e={}){Object.assign(this,wb),this.options={},this.fetchOptions={},this.userAgents={chrome:"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36",chrome39:"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36",chrome100:"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.75 Safari/537.36"},this.headers={},this.proxy="",this.origin="*",this.minFundingAddressLength=1,this.substituteCommonCurrencyCodes=!0,this.quoteJsonNumbers=!0,this.number=Number,this.handleContentTypeApplicationZip=!1,this.reduceFees=!0,this.fetchImplementation=Hd,this.validateServerSsl=!0,this.validateClientSsl=!1,this.timeout=1e4,this.verbose=!1,this.debug=!1,this.userAgent=void 0,this.twofa=void 0,this.apiKey=void 0,this.secret=void 0,this.uid=void 0,this.login=void 0,this.password=void 0,this.privateKey=void 0,this.walletAddress=void 0,this.token=void 0,this.balance={},this.orderbooks={},this.tickers={},this.orders=void 0,this.trades={},this.transactions={},this.ohlcvs={},this.myTrades=void 0,this.positions={},this.requiresWeb3=!1,this.requiresEddsa=!1,this.precision={},this.lastRestRequestTimestamp=0,this.enableLastJsonResponse=!0,this.enableLastHttpResponse=!0,this.enableLastResponseHeaders=!0,this.last_http_response=void 0,this.last_json_response=void 0,this.last_response_headers=void 0;const t=(r=this)=>{if(r!==null){const a=Object.getOwnPropertyNames(r);for(let o=0;o<a.length;o++){const d=a[o];this[lV(d)]=this[d]}t(Object.getPrototypeOf(r))}};t();const s=Object.entries(this.describe()).concat(Object.entries(e));for(let r=0;r<s.length;r++){const[a,o]=s[r];o&&Object.getPrototypeOf(o)===Object.prototype?this[a]=this.deepExtend(this[a],o):this[a]=o}const i={keepAlive:!0};this.validateServerSsl||(i.rejectUnauthorized=!1),!this.httpAgent&&Hd.http&&wo&&(this.httpAgent=new Hd.http.Agent(i)),!this.httpsAgent&&Hd.https&&wo&&(this.httpsAgent=new Hd.https.Agent(i));const n=Object.keys(this.has);for(let r=0;r<n.length;r++){const a=n[r];this["has"+this.capitalize(a)]=!!this.has[a]}this.api&&this.defineRestApi(this.api,"request"),this.initRestRateLimiter(),this.markets&&this.setMarkets(this.markets)}encodeURIComponent(...e){return encodeURIComponent(...e)}checkRequiredVersion(e,t=!0){let s=!0;const[i,n,r]=e.split("."),[a,o,d]=fy.ccxtVersion.split("."),c=parseInt(i),u=parseInt(n),h=parseInt(r),l=parseInt(a),p=parseInt(o),m=parseInt(d);if(c>l&&(s=!1),c===l&&(u>p||u===p&&h>m)&&(s=!1),!s){if(t)throw new De("Your current version of CCXT is "+fy.ccxtVersion+", a newer version "+e+" is required, please, upgrade your version of CCXT");return t}return s}checkAddress(e){if(e===void 0)throw new Up(this.id+" address is undefined");if(this.unique(e).length===1||e.length<this.minFundingAddressLength||e.includes(" "))throw new Up(this.id+" address is invalid or has less than "+this.minFundingAddressLength.toString()+' characters: "'+this.json(e)+'"');return e}initRestRateLimiter(){if(this.rateLimit===void 0)throw new Error(this.id+".rateLimit property is not configured");this.tokenBucket=this.extend({delay:.001,capacity:1,cost:1,maxCapacity:1e3,refillRate:this.rateLimit>0?1/this.rateLimit:Number.MAX_VALUE},this.tokenBucket),this.throttle=pV(this.tokenBucket),this.executeRestRequest=(e,t="GET",s=void 0,i=void 0)=>{const n=this.fetchImplementation,r={method:t,headers:s,body:i,timeout:this.timeout};this.agent?r.agent=this.agent:this.httpAgent&&e.indexOf("http://")===0?r.agent=this.httpAgent:this.httpsAgent&&e.indexOf("https://")===0&&(r.agent=this.httpsAgent);const a=n(e,this.extend(r,this.fetchOptions)).catch(o=>{throw wo?new qs([this.id,t,e,o.type,o.message].join(" ")):o}).then(o=>this.handleRestResponse(o,e,t,s,i));return mV(this.timeout,a).catch(o=>{throw o instanceof gV?new jp(this.id+" "+t+" "+e+" request timed out ("+this.timeout+" ms)"):o})}}setSandboxMode(e){if(e)if("test"in this.urls)typeof this.urls.api=="string"?(this.urls.apiBackup=this.urls.api,this.urls.api=this.urls.test):(this.urls.apiBackup=Hp(this.urls.api),this.urls.api=Hp(this.urls.test));else throw new De(this.id+" does not have a sandbox URL");else"apiBackup"in this.urls&&(typeof this.urls.api=="string"?this.urls.api=this.urls.apiBackup:this.urls.api=Hp(this.urls.apiBackup))}defineRestApiEndpoint(e,t,s,i,n,r,a={}){const o=n.split(/[^a-zA-Z0-9]/),d=o.map(this.capitalize).join(""),c=o.map(y=>y.trim().toLowerCase()).filter(y=>y.length>0).join("_"),u=[r[0]].concat(r.slice(1).map(this.capitalize)).join(""),h=[r[0]].concat(r.slice(1).map(y=>y.trim()).filter(y=>y.length>0)).join("_"),l=u+i+this.capitalize(d),p=h+"_"+s+"_"+c,m=r.length>1?r:r[0],g=async(y={},b={})=>this[e](n,m,t,y,void 0,void 0,a,b);this[l]=g,this[p]=g}defineRestApi(e,t,s=[]){const i=Object.keys(e);for(let n=0;n<i.length;n++){const r=i[n],a=e[r],o=r.toUpperCase(),d=r.toLowerCase(),c=this.capitalize(d);if(Array.isArray(a))for(let u=0;u<a.length;u++){const h=a[u].trim();this.defineRestApiEndpoint(t,o,d,c,h,s)}else if(r.match(/^(?:get|post|put|delete|head|patch)$/i)){const u=Object.keys(a);for(let h=0;h<u.length;h++){const l=u[h],p=l.trim(),m=a[l];if(typeof m=="object")this.defineRestApiEndpoint(t,o,d,c,p,s,m);else if(typeof m=="number")this.defineRestApiEndpoint(t,o,d,c,p,s,{cost:m});else throw new De(this.id+" defineRestApi() API format is not supported, API leafs must strings, objects or numbers")}}else this.defineRestApi(a,t,s.concat([r]))}}log(...e){console.log(...e)}fetch(e,t="GET",s=void 0,i=void 0){return wo&&this.userAgent&&(typeof this.userAgent=="string"?s=this.extend({"User-Agent":this.userAgent},s):typeof this.userAgent=="object"&&"User-Agent"in this.userAgent&&(s=this.extend(this.userAgent,s))),typeof this.proxy=="function"?(e=this.proxy(e),wo&&(s=this.extend({Origin:this.origin},s))):typeof this.proxy=="string"&&(this.proxy.length&&wo&&(s=this.extend({Origin:this.origin},s)),e=this.proxy+e),s=this.extend(this.headers,s),s=this.setHeaders(s),this.verbose&&this.log(`fetch Request:
`,this.id,t,e,`
RequestHeaders:
`,s,`
RequestBody:
`,i,`
`),this.executeRestRequest(e,t,s,i)}parseJson(e){try{if(this.isJsonEncodedObject(e))return JSON.parse(this.onJsonResponse(e))}catch{return}}getResponseHeaders(e){const t={};return e.headers.forEach((s,i)=>{i=i.split("-").map(n=>this.capitalize(n)).join("-"),t[i]=s}),t}handleRestResponse(e,t,s="GET",i=void 0,n=void 0){const r=this.getResponseHeaders(e);if(this.handleContentTypeApplicationZip&&r["Content-Type"]==="application/zip"){const a=e.buffer();return this.enableLastResponseHeaders&&(this.last_response_headers=r),this.enableLastHttpResponse&&(this.last_http_response=a),this.verbose&&this.log(`handleRestResponse:
`,this.id,s,t,e.status,e.statusText,`
ResponseHeaders:
`,r,"ZIP redacted",`
`),a}return e.text().then(a=>{const o=this.onRestResponse(e.status,e.statusText,t,s,r,a,i,n),d=this.parseJson(o);return this.enableLastResponseHeaders&&(this.last_response_headers=r),this.enableLastHttpResponse&&(this.last_http_response=a),this.enableLastJsonResponse&&(this.last_json_response=d),this.verbose&&this.log(`handleRestResponse:
`,this.id,s,t,e.status,e.statusText,`
ResponseHeaders:
`,r,`
ResponseBody:
`,a,`
`),this.handleErrors(e.status,e.statusText,t,s,r,a,d,i,n)||this.handleHttpStatusCode(e.status,e.statusText,t,s,a),d||a})}onRestResponse(e,t,s,i,n,r,a,o){return r.trim()}onJsonResponse(e){return this.quoteJsonNumbers?e.replace(/":([+.0-9eE-]+)([,}])/g,'":"$1"$2'):e}async loadMarketsHelper(e=!1,t={}){if(!e&&this.markets)return this.markets_by_id?this.markets:this.setMarkets(this.markets);let s;this.has.fetchCurrencies===!0&&(s=await this.fetchCurrencies());const i=await this.fetchMarkets(t);return this.setMarkets(i,s)}loadMarkets(e=!1,t={}){return(e&&!this.reloadingMarkets||!this.marketsLoading)&&(this.reloadingMarkets=!0,this.marketsLoading=this.loadMarketsHelper(e,t).then(s=>(this.reloadingMarkets=!1,s),s=>{throw this.reloadingMarkets=!1,s})),this.marketsLoading}fetchCurrencies(e={}){return new Promise((t,s)=>t(this.currencies))}fetchMarkets(e={}){return new Promise((t,s)=>t(Object.values(this.markets)))}filterBySinceLimit(e,t=void 0,s=void 0,i="timestamp",n=!1){return t!=null&&(e=e.filter(a=>a[i]>=t)),s!=null&&(e=n?e.slice(-s):e.slice(0,s)),e}filterByValueSinceLimit(e,t,s=void 0,i=void 0,n=void 0,r="timestamp",a=!1){const o=s!=null,d=i!=null;return(o||d)&&(e=e.filter(c=>(o?c[t]===s:!0)&&(d?c[r]>=i:!0))),n!=null&&(e=a?e.slice(-n):e.slice(0,n)),e}checkRequiredDependencies(){}remove0xPrefix(e){return e.slice(0,2)==="0x"?e.slice(2):e}hashMessage(e){const t=this.base16ToBinary(this.remove0xPrefix(e)),s=this.stringToBinary(`Ethereum Signed Message:
`+t.sigBytes);return"0x"+this.hash(this.binaryConcat(s,t),"keccak","hex")}signHash(e,t){const s=this.ecdsa(e.slice(-64),t.slice(-64),"secp256k1",void 0);return{r:"0x"+s.r,s:"0x"+s.s,v:27+s.v}}signMessage(e,t){return this.signHash(this.hashMessage(e),t.slice(-64))}signMessageString(e,t){const s=this.signMessage(e,t);return s.r+this.remove0xPrefix(s.s)+this.binaryToBase16(this.numberToBE(s.v))}parseNumber(e,t=void 0){if(e===void 0)return t;try{return this.number(e)}catch{return t}}checkOrderArguments(e,t,s,i,n,r){if(n===void 0&&t==="limit")throw new va(this.id+" createOrder() requires a price argument for a limit order");if(i<=0)throw new va(this.id+" createOrder() amount should be above 0")}handleHttpStatusCode(e,t,s,i,n){const r=e.toString();if(r in this.httpExceptions){const a=this.httpExceptions[r];throw new a(this.id+" "+i+" "+s+" "+r+" "+t+" "+n)}}safeLedgerEntry(e,t=void 0){t=this.safeCurrency(void 0,t);let s=this.safeString(e,"direction"),i=this.safeString(e,"before"),n=this.safeString(e,"after");const r=this.safeString(e,"amount");r!==void 0&&(i===void 0&&n!==void 0?i=Qe.stringSub(n,r):i!==void 0&&n===void 0&&(n=Qe.stringAdd(i,r))),i!==void 0&&n!==void 0&&s===void 0&&(Qe.stringGt(i,n)&&(s="out"),Qe.stringGt(n,i)&&(s="in"));const a=this.safeValue(e,"fee");a!==void 0&&(a.cost=this.safeNumber(a,"cost"));const o=this.safeInteger(e,"timestamp");return{id:this.safeString(e,"id"),timestamp:o,datetime:this.iso8601(o),direction:s,account:this.safeString(e,"account"),referenceId:this.safeString(e,"referenceId"),referenceAccount:this.safeString(e,"referenceAccount"),type:this.safeString(e,"type"),currency:t.code,amount:this.parseNumber(r),before:this.parseNumber(i),after:this.parseNumber(n),status:this.safeString(e,"status"),fee:a,info:e}}setMarkets(e,t=void 0){const s=[],i=this.toArray(e);for(let o=0;o<i.length;o++){const d=this.deepExtend(this.safeMarket(),{precision:this.precision,limits:this.limits},this.fees.trading,i[o]);s.push(d)}this.markets=this.indexBy(s,"symbol"),this.markets_by_id=this.indexBy(e,"id");const n=this.keysort(this.markets),r=this.keysort(this.markets_by_id);if(this.symbols=Object.keys(n),this.ids=Object.keys(r),t!==void 0)this.currencies=this.deepExtend(this.currencies,t);else{let o=[],d=[];for(let m=0;m<s.length;m++){const g=s[m],y=this.precisionMode===T1?8:this.parseNumber("0.00000001"),b=this.safeValue(g,"precision",{});if("base"in g){const w=this.safeValue2(b,"base","amount",y),S={id:this.safeString2(g,"baseId","base"),numericId:this.safeString(g,"baseNumericId"),code:this.safeString(g,"base"),precision:w};o.push(S)}if("quote"in g){const w=this.safeValue2(b,"quote","price",y),S={id:this.safeString2(g,"quoteId","quote"),numericId:this.safeString(g,"quoteNumericId"),code:this.safeString(g,"quote"),precision:w};d.push(S)}}o=this.sortBy(o,"code"),d=this.sortBy(d,"code"),this.baseCurrencies=this.indexBy(o,"code"),this.quoteCurrencies=this.indexBy(d,"code");const c=this.arrayConcat(o,d),u=this.groupBy(c,"code"),h=Object.keys(u),l=[];for(let m=0;m<h.length;m++){const g=h[m],y=this.safeValue(u,g,[]);let b=this.safeValue(y,0);for(let w=1;w<y.length;w++){const S=y[w];this.precisionMode===SV?b=S.precision<b.precision?S:b:b=S.precision>b.precision?S:b}l.push(b)}const p=this.sortBy(l,"code");this.currencies=this.deepExtend(this.currencies,this.indexBy(p,"code"))}this.currencies_by_id=this.indexBy(this.currencies,"id");const a=this.keysort(this.currencies);return this.codes=Object.keys(a),this.markets}safeBalance(e){const t=this.omit(e,["info","timestamp","datetime","free","used","total"]),s=Object.keys(t);e.free={},e.used={},e.total={};const i={};for(let a=0;a<s.length;a++){const o=s[a];let d=this.safeString(e[o],"total"),c=this.safeString(e[o],"free"),u=this.safeString(e[o],"used");const h=this.safeString(e[o],"debt");d===void 0&&c!==void 0&&u!==void 0&&(d=Qe.stringAdd(c,u)),c===void 0&&d!==void 0&&u!==void 0&&(c=Qe.stringSub(d,u)),u===void 0&&d!==void 0&&c!==void 0&&(u=Qe.stringSub(d,c)),e[o].free=this.parseNumber(c),e[o].used=this.parseNumber(u),e[o].total=this.parseNumber(d),e.free[o]=e[o].free,e.used[o]=e[o].used,e.total[o]=e[o].total,h!==void 0&&(e[o].debt=this.parseNumber(h),i[o]=e[o].debt)}return Object.keys(i).length&&(e.debt=i),e}safeOrder(e,t=void 0){let s=this.omitZero(this.safeString(e,"amount")),i=this.safeString(e,"remaining"),n=this.safeString(e,"filled"),r=this.safeString(e,"cost"),a=this.omitZero(this.safeString(e,"average")),o=this.omitZero(this.safeString(e,"price")),d=this.safeInteger(e,"lastTradeTimestamp");const c=n===void 0,u=r===void 0,h=d===void 0,l=this.safeValue(e,"fee"),p=l===void 0,m=this.safeValue(e,"fees")===void 0,g=p||m,y=this.safeValue(e,"fees",[]);let b=[];if(c||u||g){const I=this.safeValue(e,"trades",b),_=this.number;this.number=String,b=this.parseTrades(I,t,void 0,void 0,{symbol:e.symbol,side:e.side,type:e.type,order:e.id}),this.number=_;let N=0;const M=Array.isArray(b);if(M&&(N=b.length),M&&N>0){e.symbol===void 0&&(e.symbol=b[0].symbol),e.side===void 0&&(e.side=b[0].side),e.type===void 0&&(e.type=b[0].type),e.id===void 0&&(e.id=b[0].order),c&&(n="0"),u&&(r="0");for(let x=0;x<b.length;x++){const v=b[x],O=this.safeString(v,"amount");c&&O!==void 0&&(n=Qe.stringAdd(n,O));const A=this.safeString(v,"cost");u&&A!==void 0&&(r=Qe.stringAdd(r,A));const V=this.safeValue(v,"timestamp");if(h&&V!==void 0&&(d===void 0?d=V:d=Math.max(d,V)),g){const q=this.safeValue(v,"fees");if(q!==void 0)for(let R=0;R<q.length;R++){const H=q[R];y.push(this.extend({},H))}else{const R=this.safeValue(v,"fee");R!==void 0&&y.push(this.extend({},R))}}}}}if(g){const I=this.reduceFees?this.reduceFeesByCurrency(y):y,_=I.length;for(let N=0;N<_;N++)I[N].cost=this.safeNumber(I[N],"cost"),"rate"in I[N]&&(I[N].rate=this.safeNumber(I[N],"rate"));!p&&_===0&&(l.cost=this.safeNumber(l,"cost"),"rate"in l&&(l.rate=this.safeNumber(l,"rate")),I.push(l)),e.fees=I,p&&_===1&&(e.fee=I[0])}if(s===void 0&&(n!==void 0&&i!==void 0?s=Qe.stringAdd(n,i):this.safeString(e,"status")==="closed"&&(s=n)),n===void 0&&s!==void 0&&i!==void 0&&(n=Qe.stringSub(s,i)),i===void 0&&s!==void 0&&n!==void 0&&(i=Qe.stringSub(s,n)),a===void 0&&n!==void 0&&r!==void 0&&Qe.stringGt(n,"0")&&(a=Qe.stringDiv(r,n)),u&&n!==void 0&&(a!==void 0||o!==void 0)){let I;a===void 0?I=o:I=a;const _=this.safeString(t,"contractSize");_!==void 0&&(this.safeValue(t,"inverse",!1)&&(I=Qe.stringDiv("1",I)),I=Qe.stringMul(I,_)),r=Qe.stringMul(I,n)}const S=this.safeValue(e,"type");(o===void 0||Qe.stringEquals(o,"0"))&&S==="market"&&(o=a);for(let I=0;I<b.length;I++){const _=b[I];_.amount=this.safeNumber(_,"amount"),_.price=this.safeNumber(_,"price"),_.cost=this.safeNumber(_,"cost");const N=this.safeValue(_,"fee",{});N.cost=this.safeNumber(N,"cost"),"rate"in N&&(N.rate=this.safeNumber(N,"rate")),_.fee=N}let T=this.safeString(e,"timeInForce");return T===void 0&&(this.safeString(e,"type")==="market"&&(T="IOC"),this.safeValue(e,"postOnly",!1)&&(T="PO")),this.extend(e,{lastTradeTimestamp:d,price:this.parseNumber(o),amount:this.parseNumber(s),cost:this.parseNumber(r),average:this.parseNumber(a),filled:this.parseNumber(n),remaining:this.parseNumber(i),timeInForce:T,trades:b})}parseOrders(e,t=void 0,s=void 0,i=void 0,n={}){let r=[];if(Array.isArray(e))for(let d=0;d<e.length;d++){const c=this.extend(this.parseOrder(e[d],t),n);r.push(c)}else{const d=Object.keys(e);for(let c=0;c<d.length;c++){const u=d[c],h=this.extend(this.parseOrder(this.extend({id:u},e[u]),t),n);r.push(h)}}r=this.sortBy(r,"timestamp");const a=t!==void 0?t.symbol:void 0,o=s===void 0;return this.filterBySymbolSinceLimit(r,a,s,i,o)}calculateFee(e,t,s,i,n,r="taker",a={}){if(t==="market"&&r==="maker")throw new va(this.id+' calculateFee() - you have provided incompatible arguments - "market" type order can not be "maker". Change either the "type" or the "takerOrMaker" argument to calculate the fee.');const o=this.markets[e],d=this.safeString(o,"feeSide","quote");let c="quote",u;const h=this.numberToString(i),l=this.numberToString(n);d==="quote"?u=Qe.stringMul(h,l):d==="base"?u=h:d==="get"?(u=h,s==="sell"?u=Qe.stringMul(u,l):c="base"):d==="give"&&(u=h,s==="buy"?u=Qe.stringMul(u,l):c="base"),o.spot||(c="settle"),t==="market"&&(r="taker");const p=this.safeString(o,r);return u!==void 0&&(u=Qe.stringMul(u,p)),{type:r,currency:o[c],rate:this.parseNumber(p),cost:this.parseNumber(u)}}safeTrade(e,t=void 0){const s=this.safeString(e,"amount"),i=this.safeString(e,"price");let n=this.safeString(e,"cost");if(n===void 0){const u=this.safeString(t,"contractSize");let h=i;u!==void 0&&(this.safeValue(t,"inverse",!1)&&(h=Qe.stringDiv("1",i)),h=Qe.stringMul(h,u)),n=Qe.stringMul(h,s)}const r=this.safeValue(e,"fee")===void 0,a=this.safeValue(e,"fees")===void 0,o=r||a,d=[];if(o){const u=this.safeValue(e,"fees");if(u!==void 0)for(let h=0;h<u.length;h++){const l=u[h];d.push(this.extend({},l))}else{const h=this.safeValue(e,"fee");h!==void 0&&d.push(this.extend({},h))}}const c=this.safeValue(e,"fee");if(o){const u=this.reduceFees?this.reduceFeesByCurrency(d):d,h=u.length;for(let p=0;p<h;p++)u[p].cost=this.safeNumber(u[p],"cost"),"rate"in u[p]&&(u[p].rate=this.safeNumber(u[p],"rate"));!r&&h===0&&(c.cost=this.safeNumber(c,"cost"),"rate"in c&&(c.rate=this.safeNumber(c,"rate")),u.push(c)),a&&(e.fees=u),r&&h===1&&(e.fee=u[0]);const l=this.safeValue(e,"fee");l!==void 0&&(l.cost=this.safeNumber(l,"cost"),"rate"in l&&(l.rate=this.safeNumber(l,"rate")),e.fee=l)}return e.amount=this.parseNumber(s),e.price=this.parseNumber(i),e.cost=this.parseNumber(n),e}reduceFeesByCurrency(e){const t={};for(let n=0;n<e.length;n++){const r=e[n],a=this.safeString(r,"currency");if(a!==void 0){const o=this.safeString(r,"rate"),d=this.safeValue(r,"cost");if(Qe.stringEq(d,"0"))continue;a in t||(t[a]={});const c=o===void 0?"":o;c in t[a]?t[a][c].cost=Qe.stringAdd(t[a][c].cost,d):(t[a][c]={currency:a,cost:d},o!==void 0&&(t[a][c].rate=o))}}let s=[];const i=Object.values(t);for(let n=0;n<i.length;n++){const r=Object.values(i[n]);s=this.arrayConcat(s,r)}return s}safeTicker(e,t=void 0){let s=this.safeValue(e,"open"),i=this.safeValue(e,"close"),n=this.safeValue(e,"last"),r=this.safeValue(e,"change"),a=this.safeValue(e,"percentage"),o=this.safeValue(e,"average"),d=this.safeValue(e,"vwap");const c=this.safeValue(e,"baseVolume"),u=this.safeValue(e,"quoteVolume");return d===void 0&&(d=Qe.stringDiv(u,c)),n!==void 0&&i===void 0?i=n:n===void 0&&i!==void 0&&(n=i),n!==void 0&&s!==void 0&&(r===void 0&&(r=Qe.stringSub(n,s)),o===void 0&&(o=Qe.stringDiv(Qe.stringAdd(n,s),"2"))),a===void 0&&r!==void 0&&s!==void 0&&Qe.stringGt(s,"0")&&(a=Qe.stringMul(Qe.stringDiv(r,s),"100")),r===void 0&&a!==void 0&&s!==void 0&&(r=Qe.stringDiv(Qe.stringMul(a,s),"100")),s===void 0&&n!==void 0&&r!==void 0&&(s=Qe.stringSub(n,r)),this.extend(e,{bid:this.safeNumber(e,"bid"),bidVolume:this.safeNumber(e,"bidVolume"),ask:this.safeNumber(e,"ask"),askVolume:this.safeNumber(e,"askVolume"),high:this.safeNumber(e,"high"),low:this.safeNumber(e,"low"),open:this.parseNumber(s),close:this.parseNumber(i),last:this.parseNumber(n),change:this.parseNumber(r),percentage:this.parseNumber(a),average:this.parseNumber(o),vwap:this.parseNumber(d),baseVolume:this.parseNumber(c),quoteVolume:this.parseNumber(u),previousClose:this.safeNumber(e,"previousClose")})}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){if(!this.has.fetchTrades)throw new De(this.id+" fetchOHLCV() is not supported yet");await this.loadMarkets();const r=await this.fetchTrades(e,s,i,n),a=this.buildOHLCVC(r,t,s,i),o=[];for(let d=0;d<a.length;d++)o.push([this.safeInteger(a[d],0),this.safeNumber(a[d],1),this.safeNumber(a[d],2),this.safeNumber(a[d],3),this.safeNumber(a[d],4),this.safeNumber(a[d],5)]);return o}convertTradingViewToOHLCV(e,t="t",s="o",i="h",n="l",r="c",a="v",o=!1){const d=[],c=this.safeValue(e,t,[]),u=this.safeValue(e,s,[]),h=this.safeValue(e,i,[]),l=this.safeValue(e,n,[]),p=this.safeValue(e,r,[]),m=this.safeValue(e,a,[]);for(let g=0;g<c.length;g++)d.push([o?this.safeInteger(c,g):this.safeTimestamp(c,g),this.safeValue(u,g),this.safeValue(h,g),this.safeValue(l,g),this.safeValue(p,g),this.safeValue(m,g)]);return d}convertOHLCVToTradingView(e,t="t",s="o",i="h",n="l",r="c",a="v",o=!1){const d={};d[t]=[],d[s]=[],d[i]=[],d[n]=[],d[r]=[],d[a]=[];for(let c=0;c<e.length;c++){const u=o?e[c][0]:parseInt(e[c][0]/1e3);d[t].push(u),d[s].push(e[c][1]),d[i].push(e[c][2]),d[n].push(e[c][3]),d[r].push(e[c][4]),d[a].push(e[c][5])}return d}marketIds(e){const t=[];for(let s=0;s<e.length;s++)t.push(this.marketId(e[s]));return t}marketSymbols(e){if(e===void 0)return e;const t=[];for(let s=0;s<e.length;s++)t.push(this.symbol(e[s]));return t}marketCodes(e){if(e===void 0)return e;const t=[];for(let s=0;s<e.length;s++)t.push(this.commonCurrencyCode(e[s]));return t}parseBidsAsks(e,t=0,s=1){e=this.toArray(e);const i=[];for(let n=0;n<e.length;n++)i.push(this.parseBidAsk(e[n],t,s));return i}async fetchL2OrderBook(e,t=void 0,s={}){const i=await this.fetchOrderBook(e,t,s);return this.extend(i,{asks:this.sortBy(this.aggregate(i.asks),0),bids:this.sortBy(this.aggregate(i.bids),0,!0)})}filterBySymbol(e,t=void 0){if(t===void 0)return e;const s=[];for(let i=0;i<e.length;i++)this.safeString(e[i],"symbol")===t&&s.push(e[i]);return s}parseOHLCV(e,t=void 0){return Array.isArray(e)?[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]:e}getNetwork(e,t){e=e.toUpperCase();const s={ETHEREUM:"ETH",ETHER:"ETH",ERC20:"ETH",ETH:"ETH",TRC20:"TRX",TRON:"TRX",TRX:"TRX",BEP20:"BSC",BSC:"BSC",HRC20:"HT",HECO:"HT",SPL:"SOL",SOL:"SOL",TERRA:"LUNA",LUNA:"LUNA",POLYGON:"MATIC",MATIC:"MATIC",EOS:"EOS",WAVES:"WAVES",AVALANCHE:"AVAX",AVAX:"AVAX",QTUM:"QTUM",CHZ:"CHZ",NEO:"NEO",ONT:"ONT",RON:"RON"};if(e===t)return e;if(e in s)return s[e];throw new De(this.id+" network "+e+" is not yet supported")}networkCodeToId(e){const t=this.safeValue(this.options,"networks",{});return this.safeString(t,e,e)}networkIdToCode(e){const t=this.safeValue(this.options,"networksById",{});return this.safeString(t,e,e)}handleNetworkCodeAndParams(e){const t=this.safeString2(e,"networkCode","network");return t!==void 0&&(e=this.omit(e,["networkCode","network"])),[t,e]}defaultNetworkCode(e){let t;const s=this.safeValue(this.options,"defaultNetworks",{});if(e in s)t=s[e];else{const i=this.safeValue(this.options,"defaultNetwork");i!==void 0&&(t=i)}return t}selectNetworkIdFromAvailableNetworks(e,t,s){let i;const n=Object.keys(s),r=n.length;if(t!==void 0){const a=this.networkCodeToId(t);if(r===0)throw new De(this.id+" - "+t+" network did not return any result for "+e);if(a in s)i=a;else throw new De(this.id+" - "+a+" network was not found for "+e+", use one of "+n.join(", "))}else{if(r===0)throw new De(this.id+" - no networks were returned for"+e);{const a=this.defaultNetworkCode(e),o=this.networkCodeToId(a);i=o in s?o:n[0]}}return i}safeNumber2(e,t,s,i=void 0){const n=this.safeString2(e,t,s);return this.parseNumber(n,i)}parseOrderBook(e,t,s=void 0,i="bids",n="asks",r=0,a=1){const o=this.parseBidsAsks(this.safeValue(e,i,[]),r,a),d=this.parseBidsAsks(this.safeValue(e,n,[]),r,a);return{symbol:t,bids:this.sortBy(o,0,!0),asks:this.sortBy(d,0),timestamp:s,datetime:this.iso8601(s),nonce:void 0}}parseOHLCVs(e,t=void 0,s="1m",i=void 0,n=void 0){const r=[];for(let d=0;d<e.length;d++)r.push(this.parseOHLCV(e[d],t));const a=this.sortBy(r,0),o=i===void 0;return this.filterBySinceLimit(a,i,n,0,o)}parseLeverageTiers(e,t=void 0,s=void 0){t=this.marketSymbols(t);const i={};for(let n=0;n<e.length;n++){const r=e[n],a=this.safeString(r,s),o=this.safeMarket(a),d=o.symbol;this.safeValue(o,"contract",!1)&&(t===void 0||this.inArray(d,t))&&(i[d]=this.parseMarketLeverageTiers(r,o))}return i}async loadTradingLimits(e=void 0,t=!1,s={}){if(this.has.fetchTradingLimits&&(t||!("limitsLoaded"in this.options))){const i=await this.fetchTradingLimits(e);for(let n=0;n<e.length;n++){const r=e[n];this.markets[r]=this.deepExtend(this.markets[r],i[r])}this.options.limitsLoaded=this.milliseconds()}return this.markets}parsePositions(e,t=void 0,s={}){t=this.marketSymbols(t),e=this.toArray(e);const i=[];for(let n=0;n<e.length;n++){const r=this.extend(this.parsePosition(e[n],void 0),s);i.push(r)}return this.filterByArray(i,"symbol",t,!1)}parseAccounts(e,t={}){e=this.toArray(e);const s=[];for(let i=0;i<e.length;i++){const n=this.extend(this.parseAccount(e[i]),t);s.push(n)}return s}parseTrades(e,t=void 0,s=void 0,i=void 0,n={}){e=this.toArray(e);let r=[];for(let d=0;d<e.length;d++){const c=this.extend(this.parseTrade(e[d],t),n);r.push(c)}r=this.sortBy2(r,"timestamp","id");const a=t!==void 0?t.symbol:void 0,o=s===void 0;return this.filterBySymbolSinceLimit(r,a,s,i,o)}parseTransactions(e,t=void 0,s=void 0,i=void 0,n={}){e=this.toArray(e);let r=[];for(let d=0;d<e.length;d++){const c=this.extend(this.parseTransaction(e[d],t),n);r.push(c)}r=this.sortBy(r,"timestamp");const a=t!==void 0?t.code:void 0,o=s===void 0;return this.filterByCurrencySinceLimit(r,a,s,i,o)}parseTransfers(e,t=void 0,s=void 0,i=void 0,n={}){e=this.toArray(e);let r=[];for(let d=0;d<e.length;d++){const c=this.extend(this.parseTransfer(e[d],t),n);r.push(c)}r=this.sortBy(r,"timestamp");const a=t!==void 0?t.code:void 0,o=s===void 0;return this.filterByCurrencySinceLimit(r,a,s,i,o)}parseLedger(e,t=void 0,s=void 0,i=void 0,n={}){let r=[];const a=this.toArray(e);for(let c=0;c<a.length;c++){const u=this.parseLedgerEntry(a[c],t);if(Array.isArray(u))for(let h=0;h<u.length;h++)r.push(this.extend(u[h],n));else r.push(this.extend(u,n))}r=this.sortBy(r,"timestamp");const o=t!==void 0?t.code:void 0,d=s===void 0;return this.filterByCurrencySinceLimit(r,o,s,i,d)}nonce(){return this.seconds()}setHeaders(e){return e}marketId(e){const t=this.market(e);return t!==void 0?t.id:e}symbol(e){const t=this.market(e);return this.safeString(t,"symbol",e)}resolvePath(e,t){return[this.implodeParams(e,t),this.omit(t,this.extractParams(e))]}filterByArray(e,t,s=void 0,i=!0){if(e=this.toArray(e),s===void 0||!s)return i?this.indexBy(e,t):e;const n=[];for(let r=0;r<e.length;r++)this.inArray(e[r][t],s)&&n.push(e[r]);return i?this.indexBy(n,t):n}async fetch2(e,t="public",s="GET",i={},n=void 0,r=void 0,a={},o={}){if(this.enableRateLimit){const c=this.calculateRateLimiterCost(t,s,e,i,a,o);await this.throttle(c)}this.lastRestRequestTimestamp=this.milliseconds();const d=this.sign(e,t,s,i,n,r);return await this.fetch(d.url,d.method,d.headers,d.body)}async request(e,t="public",s="GET",i={},n=void 0,r=void 0,a={},o={}){return await this.fetch2(e,t,s,i,n,r,a,o)}async loadAccounts(e=!1,t={}){if(e)this.accounts=await this.fetchAccounts(t);else{if(this.accounts)return this.accounts;this.accounts=await this.fetchAccounts(t)}return this.accountsById=this.indexBy(this.accounts,"id"),this.accounts}async fetchTrades(e,t=void 0,s=void 0,i={}){throw new De(this.id+" fetchTrades() is not supported yet")}async fetchOHLCVC(e,t="1m",s=void 0,i=void 0,n={}){if(!this.has.fetchTrades)throw new De(this.id+" fetchOHLCV() is not supported yet");await this.loadMarkets();const r=await this.fetchTrades(e,s,i,n);return this.buildOHLCVC(r,t,s,i)}parseTradingViewOHLCV(e,t=void 0,s="1m",i=void 0,n=void 0){const r=this.convertTradingViewToOHLCV(e);return this.parseOHLCVs(r,t,s,i,n)}async editLimitBuyOrder(e,t,s,i=void 0,n={}){return await this.editLimitOrder(e,t,"buy",s,i,n)}async editLimitSellOrder(e,t,s,i=void 0,n={}){return await this.editLimitOrder(e,t,"sell",s,i,n)}async editLimitOrder(e,t,s,i,n=void 0,r={}){return await this.editOrder(e,t,"limit",s,i,n,r)}async editOrder(e,t,s,i,n,r=void 0,a={}){return await this.cancelOrder(e,t),await this.createOrder(t,s,i,n,r,a)}async fetchPermissions(e={}){throw new De(this.id+" fetchPermissions() is not supported yet")}async fetchPosition(e,t={}){throw new De(this.id+" fetchPosition() is not supported yet")}async fetchPositions(e=void 0,t={}){throw new De(this.id+" fetchPositions() is not supported yet")}async fetchPositionsRisk(e=void 0,t={}){throw new De(this.id+" fetchPositionsRisk() is not supported yet")}async fetchBidsAsks(e=void 0,t={}){throw new De(this.id+" fetchBidsAsks() is not supported yet")}parseBidAsk(e,t=0,s=1){const i=this.safeNumber(e,t),n=this.safeNumber(e,s);return[i,n]}safeCurrency(e,t=void 0){if(e===void 0&&t!==void 0)return t;if(this.currencies_by_id!==void 0&&e in this.currencies_by_id&&this.currencies_by_id[e]!==void 0)return this.currencies_by_id[e];let s=e;return e!==void 0&&(s=this.commonCurrencyCode(e.toUpperCase())),{id:e,code:s}}safeMarket(e=void 0,t=void 0,s=void 0){const i={id:e,symbol:e,base:void 0,quote:void 0,baseId:void 0,quoteId:void 0,active:void 0,type:void 0,linear:void 0,inverse:void 0,spot:!1,swap:!1,future:!1,option:!1,margin:!1,contract:!1,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,optionType:void 0,strike:void 0,settle:void 0,settleId:void 0,precision:{amount:void 0,price:void 0},limits:{amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:void 0};if(e!==void 0){if(this.markets_by_id!==void 0&&e in this.markets_by_id)t=this.markets_by_id[e];else if(s!==void 0){const n=e.split(s);return n.length===2&&(i.baseId=this.safeString(n,0),i.quoteId=this.safeString(n,1),i.base=this.safeCurrencyCode(i.baseId),i.quote=this.safeCurrencyCode(i.quoteId),i.symbol=i.base+"/"+i.quote),i}}return t!==void 0?t:i}checkRequiredCredentials(e=!0){const t=Object.keys(this.requiredCredentials);for(let s=0;s<t.length;s++){const i=t[s];if(this.requiredCredentials[i]&&!this[i]){if(e)throw new $p(this.id+' requires "'+i+'" credential');return e}}return!0}oath(){if(this.twofa!==void 0)return this.totp(this.twofa);throw new Br(this.id+" exchange.twofa has not been set for 2FA Two-Factor Authentication")}async fetchBalance(e={}){throw new De(this.id+" fetchBalance() is not supported yet")}async fetchPartialBalance(e,t={}){return(await this.fetchBalance(t))[e]}async fetchFreeBalance(e={}){return await this.fetchPartialBalance("free",e)}async fetchUsedBalance(e={}){return await this.fetchPartialBalance("used",e)}async fetchTotalBalance(e={}){return await this.fetchPartialBalance("total",e)}async fetchStatus(e={}){if(this.has.fetchTime){const t=await this.fetchTime(e);this.status=this.extend(this.status,{updated:t})}return this.status}async fetchFundingFee(e,t={}){if(this.safeValue(this.options,"warnOnFetchFundingFee",!0))throw new De(this.id+' fetchFundingFee() method is deprecated, it will be removed in July 2022, please, use fetchTransactionFee() or set exchange.options["warnOnFetchFundingFee"] = false to suppress this warning');return await this.fetchTransactionFee(e,t)}async fetchFundingFees(e=void 0,t={}){if(this.safeValue(this.options,"warnOnFetchFundingFees",!0))throw new De(this.id+' fetchFundingFees() method is deprecated, it will be removed in July 2022. Please, use fetchTransactionFees() or set exchange.options["warnOnFetchFundingFees"] = false to suppress this warning');return await this.fetchTransactionFees(e,t)}async fetchTransactionFee(e,t={}){if(!this.has.fetchTransactionFees)throw new De(this.id+" fetchTransactionFee() is not supported yet");return await this.fetchTransactionFees([e],t)}async fetchTransactionFees(e=void 0,t={}){throw new De(this.id+" fetchTransactionFees() is not supported yet")}async fetchDepositWithdrawFee(e,t={}){if(!this.has.fetchDepositWithdrawFees)throw new De(this.id+" fetchDepositWithdrawFee() is not supported yet");const s=await this.fetchDepositWithdrawFees([e],t);return this.safeValue(s,e)}getSupportedMapping(e,t={}){if(e in t)return t[e];throw new De(this.id+" "+e+" does not have a value in mapping")}async fetchBorrowRate(e,t={}){if(await this.loadMarkets(),!this.has.fetchBorrowRates)throw new De(this.id+" fetchBorrowRate() is not supported yet");const s=await this.fetchBorrowRates(t),i=this.safeValue(s,e);if(i===void 0)throw new Br(this.id+" fetchBorrowRate() could not find the borrow rate for currency code "+e);return i}handleOptionAndParams(e,t,s,i=void 0){const n="default"+this.capitalize(s);let r=this.safeString2(e,s,n);if(r!==void 0&&(e=this.omit(e,[s,n])),r===void 0){const a=this.safeValue(this.options,t);a!==void 0&&(r=this.safeString2(a,s,n))}return r===void 0&&(r=this.safeString2(this.options,s,n)),r=r!==void 0?r:i,[r,e]}handleMarketTypeAndParams(e,t=void 0,s={}){const i=this.safeString2(this.options,"defaultType","type","spot"),n=this.safeValue(this.options,e);let r=i;n!==void 0&&(typeof n=="string"?r=n:r=this.safeString2(n,"defaultType","type",r));const a=t===void 0?r:t.type,o=this.safeString2(s,"defaultType","type",a);return s=this.omit(s,["defaultType","type"]),[o,s]}handleSubTypeAndParams(e,t=void 0,s={},i="linear"){let n;const r=this.safeString2(s,"subType","defaultSubType");return r!==void 0?(n=r,s=this.omit(s,["subType","defaultSubType"])):(t!==void 0&&(t.linear?n="linear":t.inverse&&(n="inverse")),n===void 0&&(n=this.handleOptionAndParams(void 0,e,"subType",i)[0])),[n,s]}handleMarginModeAndParams(e,t={},s=void 0){return this.handleOptionAndParams(t,e,"marginMode",s)}throwExactlyMatchedException(e,t,s){if(t in e)throw new e[t](s)}throwBroadlyMatchedException(e,t,s){const i=this.findBroadlyMatchedKey(e,t);if(i!==void 0)throw new e[i](s)}findBroadlyMatchedKey(e,t){const s=Object.keys(e);for(let i=0;i<s.length;i++){const n=s[i];if(t!==void 0&&t.indexOf(n)>=0)return n}}handleErrors(e,t,s,i,n,r,a,o,d){}calculateRateLimiterCost(e,t,s,i,n={},r={}){return this.safeValue(n,"cost",1)}async fetchTicker(e,t={}){if(this.has.fetchTickers){const s=await this.fetchTickers([e],t),i=this.safeValue(s,e);if(i===void 0)throw new S1(this.id+" fetchTickers() could not find a ticker for "+e);return i}else throw new De(this.id+" fetchTicker() is not supported yet")}async fetchTickers(e=void 0,t={}){throw new De(this.id+" fetchTickers() is not supported yet")}async fetchOrder(e,t=void 0,s={}){throw new De(this.id+" fetchOrder() is not supported yet")}async fetchOrderStatus(e,t=void 0,s={}){return(await this.fetchOrder(e,t,s)).status}async fetchUnifiedOrder(e,t={}){return await this.fetchOrder(this.safeValue(e,"id"),this.safeValue(e,"symbol"),t)}async createOrder(e,t,s,i,n=void 0,r={}){throw new De(this.id+" createOrder() is not supported yet")}async cancelOrder(e,t=void 0,s={}){throw new De(this.id+" cancelOrder() is not supported yet")}async cancelUnifiedOrder(e,t={}){return this.cancelOrder(this.safeValue(e,"id"),this.safeValue(e,"symbol"),t)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){throw new De(this.id+" fetchOrders() is not supported yet")}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){throw new De(this.id+" fetchOpenOrders() is not supported yet")}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){throw new De(this.id+" fetchClosedOrders() is not supported yet")}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){throw new De(this.id+" fetchMyTrades() is not supported yet")}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){throw new De(this.id+" fetchTransactions() is not supported yet")}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){throw new De(this.id+" fetchDeposits() is not supported yet")}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){throw new De(this.id+" fetchWithdrawals() is not supported yet")}async fetchDepositAddress(e,t={}){if(this.has.fetchDepositAddresses){const s=await this.fetchDepositAddresses([e],t),i=this.safeValue(s,e);if(i===void 0)throw new Up(this.id+" fetchDepositAddress() could not find a deposit address for "+e+", make sure you have created a corresponding deposit address in your wallet on the exchange website");return i}else throw new De(this.id+" fetchDepositAddress() is not supported yet")}account(){return{free:void 0,used:void 0,total:void 0}}commonCurrencyCode(e){return this.substituteCommonCurrencyCodes?this.safeString(this.commonCurrencies,e,e):e}currency(e){if(this.currencies===void 0)throw new Br(this.id+" currencies not loaded");if(typeof e=="string"){if(e in this.currencies)return this.currencies[e];if(e in this.currencies_by_id)return this.currencies_by_id[e]}throw new Br(this.id+" does not have currency code "+e)}market(e){if(this.markets===void 0)throw new Br(this.id+" markets not loaded");if(this.markets_by_id===void 0)throw new Br(this.id+" markets not loaded");if(typeof e=="string"){if(e in this.markets)return this.markets[e];if(e in this.markets_by_id)return this.markets_by_id[e]}throw new Gp(this.id+" does not have market symbol "+e)}handleWithdrawTagAndParams(e,t){return typeof e=="object"&&(t=this.extend(e,t),e=void 0),e===void 0&&(e=this.safeString(t,"tag"),e!==void 0&&(t=this.omit(t,"tag"))),[e,t]}async createLimitOrder(e,t,s,i,n={}){return await this.createOrder(e,"limit",t,s,i,n)}async createMarketOrder(e,t,s,i=void 0,n={}){return await this.createOrder(e,"market",t,s,i,n)}async createLimitBuyOrder(e,t,s,i={}){return await this.createOrder(e,"limit","buy",t,s,i)}async createLimitSellOrder(e,t,s,i={}){return await this.createOrder(e,"limit","sell",t,s,i)}async createMarketBuyOrder(e,t,s={}){return await this.createOrder(e,"market","buy",t,void 0,s)}async createMarketSellOrder(e,t,s={}){return await this.createOrder(e,"market","sell",t,void 0,s)}costToPrecision(e,t){const s=this.market(e);return this.decimalToPrecision(t,v1,s.precision.price,this.precisionMode,this.paddingMode)}priceToPrecision(e,t){const s=this.market(e);return this.decimalToPrecision(t,Wp,s.precision.price,this.precisionMode,this.paddingMode)}amountToPrecision(e,t){const s=this.market(e);return this.decimalToPrecision(t,v1,s.precision.amount,this.precisionMode,this.paddingMode)}feeToPrecision(e,t){const s=this.market(e);return this.decimalToPrecision(t,Wp,s.precision.price,this.precisionMode,this.paddingMode)}currencyToPrecision(e,t,s=void 0){const i=this.currencies[e];let n=this.safeValue(i,"precision");if(s!==void 0){const r=this.safeValue(i,"networks",{}),a=this.safeValue(r,s,{});n=this.safeValue(a,"precision",n)}return n===void 0?t:this.decimalToPrecision(t,Wp,n,this.precisionMode,this.paddingMode)}safeNumber(e,t,s=void 0){const i=this.safeString(e,t);return this.parseNumber(i,s)}safeNumberN(e,t,s=void 0){const i=this.safeStringN(e,t);return this.parseNumber(i,s)}parsePrecision(e){if(e!==void 0)return"1e"+Qe.stringNeg(e)}async loadTimeDifference(e={}){const t=await this.fetchTime(e),s=this.milliseconds();return this.options.timeDifference=s-t,this.options.timeDifference}implodeHostname(e){return this.implodeParams(e,{hostname:this.hostname})}async fetchMarketLeverageTiers(e,t={}){if(this.has.fetchLeverageTiers){if(!(await this.market(e)).contract)throw new Gp(this.id+" fetchMarketLeverageTiers() supports contract markets only");const i=await this.fetchLeverageTiers([e]);return this.safeValue(i,e)}else throw new De(this.id+" fetchMarketLeverageTiers() is not supported yet")}async createPostOnlyOrder(e,t,s,i,n,r={}){if(!this.has.createPostOnlyOrder)throw new De(this.id+"createPostOnlyOrder() is not supported yet");const a=this.extend(r,{postOnly:!0});return await this.createOrder(e,t,s,i,n,a)}async createReduceOnlyOrder(e,t,s,i,n,r={}){if(!this.has.createReduceOnlyOrder)throw new De(this.id+"createReduceOnlyOrder() is not supported yet");const a=this.extend(r,{reduceOnly:!0});return await this.createOrder(e,t,s,i,n,a)}async createStopOrder(e,t,s,i,n=void 0,r=void 0,a={}){if(!this.has.createStopOrder)throw new De(this.id+" createStopOrder() is not supported yet");if(r===void 0)throw new va(this.id+" create_stop_order() requires a stopPrice argument");const o=this.extend(a,{stopPrice:r});return await this.createOrder(e,t,s,i,n,o)}async createStopLimitOrder(e,t,s,i,n,r={}){if(!this.has.createStopLimitOrder)throw new De(this.id+" createStopLimitOrder() is not supported yet");const a=this.extend(r,{stopPrice:n});return await this.createOrder(e,"limit",t,s,i,a)}async createStopMarketOrder(e,t,s,i,n={}){if(!this.has.createStopMarketOrder)throw new De(this.id+" createStopMarketOrder() is not supported yet");const r=this.extend(n,{stopPrice:i});return await this.createOrder(e,"market",t,s,void 0,r)}safeCurrencyCode(e,t=void 0){return t=this.safeCurrency(e,t),t.code}filterBySymbolSinceLimit(e,t=void 0,s=void 0,i=void 0,n=!1){return this.filterByValueSinceLimit(e,"symbol",t,s,i,"timestamp",n)}filterByCurrencySinceLimit(e,t=void 0,s=void 0,i=void 0,n=!1){return this.filterByValueSinceLimit(e,"currency",t,s,i,"timestamp",n)}parseTickers(e,t=void 0,s={}){const i=[];if(Array.isArray(e))for(let n=0;n<e.length;n++){const r=this.extend(this.parseTicker(e[n]),s);i.push(r)}else{const n=Object.keys(e);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeMarket(a),d=this.extend(this.parseTicker(e[a],o),s);i.push(d)}}return t=this.marketSymbols(t),this.filterByArray(i,"symbol",t)}parseDepositAddresses(e,t=void 0,s=!0,i={}){let n=[];for(let r=0;r<e.length;r++){const a=this.extend(this.parseDepositAddress(e[r]),i);n.push(a)}return t!==void 0&&(n=this.filterByArray(n,"currency",t,!1)),n=s?this.indexBy(n,"currency"):n,n}parseBorrowInterests(e,t=void 0){const s=[];for(let i=0;i<e.length;i++){const n=e[i];s.push(this.parseBorrowInterest(n,t))}return s}parseFundingRateHistories(e,t=void 0,s=void 0,i=void 0){const n=[];for(let o=0;o<e.length;o++){const d=e[o];n.push(this.parseFundingRateHistory(d,t))}const r=this.sortBy(n,"timestamp"),a=t===void 0?void 0:t.symbol;return this.filterBySymbolSinceLimit(r,a,s,i)}safeSymbol(e,t=void 0,s=void 0){return t=this.safeMarket(e,t,s),t.symbol}parseFundingRate(e,t=void 0){throw new De(this.id+" parseFundingRate() is not supported yet")}parseFundingRates(e,t=void 0){const s={};for(let i=0;i<e.length;i++){const n=this.parseFundingRate(e[i],t);s[n.symbol]=n}return s}isTriggerOrder(e){const t=this.safeValue2(e,"trigger","stop");return t&&(e=this.omit(e,["trigger","stop"])),[t,e]}isPostOnly(e,t,s={}){const i=this.safeStringUpper(s,"timeInForce");let n=this.safeValue2(s,"postOnly","post_only",!1);const r=i==="IOC",a=i==="FOK";if(n=n||i==="PO"||t,n){if(r||a)throw new k1(this.id+" postOnly orders cannot have timeInForce equal to "+i);if(e)throw new k1(this.id+" market orders cannot be postOnly");return!0}else return!1}async fetchTradingFees(e={}){throw new De(this.id+" fetchTradingFees() is not supported yet")}async fetchTradingFee(e,t={}){if(!this.has.fetchTradingFees)throw new De(this.id+" fetchTradingFee() is not supported yet");return await this.fetchTradingFees(t)}parseOpenInterest(e,t=void 0){throw new De(this.id+" parseOpenInterest () is not supported yet")}parseOpenInterests(e,t=void 0,s=void 0,i=void 0){const n=[];for(let o=0;o<e.length;o++){const d=e[o],c=this.parseOpenInterest(d,t);n.push(c)}const r=this.sortBy(n,"timestamp"),a=this.safeString(t,"symbol");return this.filterBySymbolSinceLimit(r,a,s,i)}async fetchFundingRate(e,t={}){if(this.has.fetchFundingRates){if(await this.loadMarkets(),!this.market(e).contract)throw new Gp(this.id+" fetchFundingRate() supports contract markets only");const i=await this.fetchFundingRates([e],t),n=this.safeValue(i,e);if(n===void 0)throw new S1(this.id+" fetchFundingRate () returned no data for "+e);return n}else throw new De(this.id+" fetchFundingRate () is not supported yet")}async fetchMarkOHLCV(e,t="1m",s=void 0,i=void 0,n={}){if(this.has.fetchMarkOHLCV){const r={price:"mark"};return await this.fetchOHLCV(e,t,s,i,this.extend(r,n))}else throw new De(this.id+" fetchMarkOHLCV () is not supported yet")}async fetchIndexOHLCV(e,t="1m",s=void 0,i=void 0,n={}){if(this.has.fetchIndexOHLCV){const r={price:"index"};return await this.fetchOHLCV(e,t,s,i,this.extend(r,n))}else throw new De(this.id+" fetchIndexOHLCV () is not supported yet")}async fetchPremiumIndexOHLCV(e,t="1m",s=void 0,i=void 0,n={}){if(this.has.fetchPremiumIndexOHLCV){const r={price:"premiumIndex"};return await this.fetchOHLCV(e,t,s,i,this.extend(r,n))}else throw new De(this.id+" fetchPremiumIndexOHLCV () is not supported yet")}handleTimeInForce(e={}){const t=this.safeStringUpper(e,"timeInForce");if(t!==void 0){const s=this.safeString(this.options.timeInForce,t);if(s===void 0)throw new Br(this.id+' does not support timeInForce "'+t+'"');return s}}convertTypeToAccount(e){const t=this.safeValue(this.options,"accountsByType",{}),s=e.toLowerCase();return s in t?t[s]:e in this.markets||e in this.markets_by_id?this.market(e).id:e}checkRequiredArgument(e,t,s,i=[]){if(t===void 0||i.length>0&&!this.inArray(t,i)){const n=i.join(", ");let r=this.id+" "+e+"() requires a "+s+" argument";throw n!==""&&(r+=", one of ("+n+")"),new va(r)}}checkRequiredMarginArgument(e,t,s){if(s==="isolated"&&t===void 0)throw new va(this.id+" "+e+"() requires a symbol argument for isolated margin");if(s==="cross"&&t!==void 0)throw new va(this.id+" "+e+"() cannot have a symbol argument for cross margin")}checkRequiredSymbol(e,t){this.checkRequiredArgument(e,t,"symbol")}parseDepositWithdrawFees(e,t=void 0,s=void 0){const i={};t=this.marketCodes(t);const n=Array.isArray(e);let r=e;n||(r=Object.keys(e));for(let a=0;a<r.length;a++){const o=r[a],d=n?o:e[o],c=n?this.safeString(d,s):o,u=this.safeValue(this.currencies_by_id,c),h=this.safeString(u,"code",c);(t===void 0||this.inArray(h,t))&&(i[h]=this.parseDepositWithdrawFee(d,u))}return i}depositWithdrawFee(e){return{info:e,withdraw:{fee:void 0,percentage:void 0},deposit:{fee:void 0,percentage:void 0},networks:{}}}};const{inflateRawSync:kV,gunzipSync:vV}=Mt;function f_(f){return kV(f).toString()}function TV(f){return f_(Buffer.from(f,"base64"))}function OV(f){return vV(f).toString()}var h_={inflate:f_,inflate64:TV,gunzip:OV},IV=function(){let e,t;const s=new Promise((i,n)=>{e=i,t=n});return s.resolve=function(){e.apply(this,arguments)},s.reject=function(){t.apply(this,arguments)},s};const xV=oe,_V=Au,{isNode:CV,isJsonEncodedObject:MV,deepExtend:PV,milliseconds:zp}=_V,{RequestTimeout:O1,NetworkError:I1,NotSupported:Kp,BaseError:AV}=xV,{inflate:BV,gunzip:NV}=h_,x1=IV;var EV=class{constructor(e,t,s,i,n,r={}){Object.assign(this,PV({url:e,onMessageCallback:t,onErrorCallback:s,onCloseCallback:i,onConnectedCallback:n,verbose:!1,protocols:void 0,options:void 0,futures:{},subscriptions:{},rejections:{},connected:void 0,error:void 0,connectionStarted:void 0,connectionEstablished:void 0,isConnected:!1,connectionTimer:void 0,connectionTimeout:1e4,pingInterval:void 0,ping:void 0,keepAlive:3e4,maxPingPongMisses:2,connection:void 0,startedConnecting:!1,gunzip:!1,inflate:!1},r)),this.connected=x1()}future(e){e in this.futures||(this.futures[e]=x1());const t=this.futures[e];return e in this.rejections&&(t.reject(this.rejections[e]),delete this.rejections[e]),t}resolve(e,t){return this.verbose&&t===void 0&&this.log(new Date,"resolve received undefined messageHash"),t in this.futures&&(this.futures[t].resolve(e),delete this.futures[t]),e}reject(e,t=void 0){if(t)t in this.futures?(this.futures[t].reject(e),delete this.futures[t]):this.rejections[t]=e;else{const s=Object.keys(this.futures);for(let i=0;i<s.length;i++)this.reject(e,s[i])}return e}log(...e){console.log(...e)}connect(e=0){throw new Kp("connect() not implemented yet")}isOpen(){throw new Kp("isOpen() not implemented yet")}reset(e){this.clearConnectionTimeout(),this.clearPingInterval(),this.reject(e)}onConnectionTimeout(){if(!this.isOpen()){const e=new O1("Connection to "+this.url+" failed due to a connection timeout");this.onError(e),this.connection.close(1006)}}setConnectionTimeout(){if(this.connectionTimeout){const e=this.onConnectionTimeout.bind(this);this.connectionTimer=setTimeout(e,this.connectionTimeout)}}clearConnectionTimeout(){this.connectionTimer&&(this.connectionTimer=clearTimeout(this.connectionTimer))}setPingInterval(){if(this.keepAlive){const e=this.onPingInterval.bind(this);this.pingInterval=setInterval(e,this.keepAlive)}}clearPingInterval(){this.pingInterval&&(this.pingInterval=clearInterval(this.pingInterval))}onPingInterval(){if(this.keepAlive&&this.isOpen()){const e=zp();this.lastPong=this.lastPong||e,this.lastPong+this.keepAlive*this.maxPingPongMisses<e?this.onError(new O1("Connection to "+this.url+" timed out due to a ping-pong keepalive missing on time")):this.ping?this.send(this.ping(this)):CV?this.connection.ping():this.lastPong=e}}onOpen(){this.verbose&&this.log(new Date,"onOpen"),this.connectionEstablished=zp(),this.isConnected=!0,this.connected.resolve(this.url),this.clearConnectionTimeout(),this.setPingInterval(),this.onConnectedCallback(this)}onPing(){this.verbose&&this.log(new Date,"onPing")}onPong(){this.lastPong=zp(),this.verbose&&this.log(new Date,"onPong")}onError(e){this.verbose&&this.log(new Date,"onError",e.message),e instanceof AV||(e=new I1(e.message)),this.error=e,this.reset(this.error),this.onErrorCallback(this,this.error)}onClose(e){this.verbose&&this.log(new Date,"onClose",e),this.error||this.reset(new I1("connection closed by remote server, closing code "+String(e.code))),this.onCloseCallback(this,e)}onUpgrade(e){this.verbose&&this.log(new Date,"onUpgrade")}send(e){this.verbose&&this.log(new Date,"sending",e),e=typeof e=="string"?e:JSON.stringify(e),this.connection.send(e)}close(){throw new Kp("close() not implemented yet")}onMessage(e){e=e.data,e.byteLength!==void 0&&(this.gunzip?e=NV(e):this.inflate&&(e=BV(e)));try{e instanceof Buffer&&(e=e.toString()),MV(e)&&(e=JSON.parse(e.replace(/:(\d{15,}),/g,':"$1",'))),this.verbose&&this.log(new Date,"onMessage",e)}catch(t){this.log(new Date,"onMessage JSON.parse",t)}this.onMessageCallback(this,e)}},Gd={exports:{}},Xp,_1;function lo(){return _1||(_1=1,Xp={BINARY_TYPES:["nodebuffer","arraybuffer","fragments"],EMPTY_BUFFER:Buffer.alloc(0),GUID:"258EAFA5-E914-47DA-95CA-C5AB0DC85B11",kForOnEventAttribute:Symbol("kIsForOnEventAttribute"),kListener:Symbol("kListener"),kStatusCode:Symbol("status-code"),kWebSocket:Symbol("websocket"),NOOP:()=>{}}),Xp}const VV={},qV=Object.freeze(Object.defineProperty({__proto__:null,default:VV},Symbol.toStringTag,{value:"Module"})),LV=My(qV);var C1;function ql(){if(C1)return Gd.exports;C1=1;const{EMPTY_BUFFER:f}=lo();function e(r,a){if(r.length===0)return f;if(r.length===1)return r[0];const o=Buffer.allocUnsafe(a);let d=0;for(let c=0;c<r.length;c++){const u=r[c];o.set(u,d),d+=u.length}return d<a?o.slice(0,d):o}function t(r,a,o,d,c){for(let u=0;u<c;u++)o[d+u]=r[u]^a[u&3]}function s(r,a){for(let o=0;o<r.length;o++)r[o]^=a[o&3]}function i(r){return r.byteLength===r.buffer.byteLength?r.buffer:r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}function n(r){if(n.readOnly=!0,Buffer.isBuffer(r))return r;let a;return r instanceof ArrayBuffer?a=Buffer.from(r):ArrayBuffer.isView(r)?a=Buffer.from(r.buffer,r.byteOffset,r.byteLength):(a=Buffer.from(r),n.readOnly=!1),a}if(Gd.exports={concat:e,mask:t,toArrayBuffer:i,toBuffer:n,unmask:s},!{}.WS_NO_BUFFER_UTIL)try{const r=LV;Gd.exports.mask=function(a,o,d,c,u){u<48?t(a,o,d,c,u):r.mask(a,o,d,c,u)},Gd.exports.unmask=function(a,o){a.length<32?s(a,o):r.unmask(a,o)}}catch{}return Gd.exports}var Yp,M1;function RV(){if(M1)return Yp;M1=1;const f=Symbol("kDone"),e=Symbol("kRun");class t{constructor(i){this[f]=()=>{this.pending--,this[e]()},this.concurrency=i||1/0,this.jobs=[],this.pending=0}add(i){this.jobs.push(i),this[e]()}[e](){if(this.pending!==this.concurrency&&this.jobs.length){const i=this.jobs.shift();this.pending++,i(this[f])}}}return Yp=t,Yp}var Qp,P1;function Ll(){if(P1)return Qp;P1=1;const f=Mt,e=ql(),t=RV(),{kStatusCode:s}=lo(),i=Buffer.from([0,0,255,255]),n=Symbol("permessage-deflate"),r=Symbol("total-length"),a=Symbol("callback"),o=Symbol("buffers"),d=Symbol("error");let c;class u{constructor(g,y,b){if(this._maxPayload=b|0,this._options=g||{},this._threshold=this._options.threshold!==void 0?this._options.threshold:1024,this._isServer=!!y,this._deflate=null,this._inflate=null,this.params=null,!c){const w=this._options.concurrencyLimit!==void 0?this._options.concurrencyLimit:10;c=new t(w)}}static get extensionName(){return"permessage-deflate"}offer(){const g={};return this._options.serverNoContextTakeover&&(g.server_no_context_takeover=!0),this._options.clientNoContextTakeover&&(g.client_no_context_takeover=!0),this._options.serverMaxWindowBits&&(g.server_max_window_bits=this._options.serverMaxWindowBits),this._options.clientMaxWindowBits?g.client_max_window_bits=this._options.clientMaxWindowBits:this._options.clientMaxWindowBits==null&&(g.client_max_window_bits=!0),g}accept(g){return g=this.normalizeParams(g),this.params=this._isServer?this.acceptAsServer(g):this.acceptAsClient(g),this.params}cleanup(){if(this._inflate&&(this._inflate.close(),this._inflate=null),this._deflate){const g=this._deflate[a];this._deflate.close(),this._deflate=null,g&&g(new Error("The deflate stream was closed while data was being processed"))}}acceptAsServer(g){const y=this._options,b=g.find(w=>!(y.serverNoContextTakeover===!1&&w.server_no_context_takeover||w.server_max_window_bits&&(y.serverMaxWindowBits===!1||typeof y.serverMaxWindowBits=="number"&&y.serverMaxWindowBits>w.server_max_window_bits)||typeof y.clientMaxWindowBits=="number"&&!w.client_max_window_bits));if(!b)throw new Error("None of the extension offers can be accepted");return y.serverNoContextTakeover&&(b.server_no_context_takeover=!0),y.clientNoContextTakeover&&(b.client_no_context_takeover=!0),typeof y.serverMaxWindowBits=="number"&&(b.server_max_window_bits=y.serverMaxWindowBits),typeof y.clientMaxWindowBits=="number"?b.client_max_window_bits=y.clientMaxWindowBits:(b.client_max_window_bits===!0||y.clientMaxWindowBits===!1)&&delete b.client_max_window_bits,b}acceptAsClient(g){const y=g[0];if(this._options.clientNoContextTakeover===!1&&y.client_no_context_takeover)throw new Error('Unexpected parameter "client_no_context_takeover"');if(!y.client_max_window_bits)typeof this._options.clientMaxWindowBits=="number"&&(y.client_max_window_bits=this._options.clientMaxWindowBits);else if(this._options.clientMaxWindowBits===!1||typeof this._options.clientMaxWindowBits=="number"&&y.client_max_window_bits>this._options.clientMaxWindowBits)throw new Error('Unexpected or invalid parameter "client_max_window_bits"');return y}normalizeParams(g){return g.forEach(y=>{Object.keys(y).forEach(b=>{let w=y[b];if(w.length>1)throw new Error(`Parameter "${b}" must have only a single value`);if(w=w[0],b==="client_max_window_bits"){if(w!==!0){const S=+w;if(!Number.isInteger(S)||S<8||S>15)throw new TypeError(`Invalid value for parameter "${b}": ${w}`);w=S}else if(!this._isServer)throw new TypeError(`Invalid value for parameter "${b}": ${w}`)}else if(b==="server_max_window_bits"){const S=+w;if(!Number.isInteger(S)||S<8||S>15)throw new TypeError(`Invalid value for parameter "${b}": ${w}`);w=S}else if(b==="client_no_context_takeover"||b==="server_no_context_takeover"){if(w!==!0)throw new TypeError(`Invalid value for parameter "${b}": ${w}`)}else throw new Error(`Unknown parameter "${b}"`);y[b]=w})}),g}decompress(g,y,b){c.add(w=>{this._decompress(g,y,(S,k)=>{w(),b(S,k)})})}compress(g,y,b){c.add(w=>{this._compress(g,y,(S,k)=>{w(),b(S,k)})})}_decompress(g,y,b){const w=this._isServer?"client":"server";if(!this._inflate){const S=`${w}_max_window_bits`,k=typeof this.params[S]!="number"?f.Z_DEFAULT_WINDOWBITS:this.params[S];this._inflate=f.createInflateRaw({...this._options.zlibInflateOptions,windowBits:k}),this._inflate[n]=this,this._inflate[r]=0,this._inflate[o]=[],this._inflate.on("error",p),this._inflate.on("data",l)}this._inflate[a]=b,this._inflate.write(g),y&&this._inflate.write(i),this._inflate.flush(()=>{const S=this._inflate[d];if(S){this._inflate.close(),this._inflate=null,b(S);return}const k=e.concat(this._inflate[o],this._inflate[r]);this._inflate._readableState.endEmitted?(this._inflate.close(),this._inflate=null):(this._inflate[r]=0,this._inflate[o]=[],y&&this.params[`${w}_no_context_takeover`]&&this._inflate.reset()),b(null,k)})}_compress(g,y,b){const w=this._isServer?"server":"client";if(!this._deflate){const S=`${w}_max_window_bits`,k=typeof this.params[S]!="number"?f.Z_DEFAULT_WINDOWBITS:this.params[S];this._deflate=f.createDeflateRaw({...this._options.zlibDeflateOptions,windowBits:k}),this._deflate[r]=0,this._deflate[o]=[],this._deflate.on("data",h)}this._deflate[a]=b,this._deflate.write(g),this._deflate.flush(f.Z_SYNC_FLUSH,()=>{if(!this._deflate)return;let S=e.concat(this._deflate[o],this._deflate[r]);y&&(S=S.slice(0,S.length-4)),this._deflate[a]=null,this._deflate[r]=0,this._deflate[o]=[],y&&this.params[`${w}_no_context_takeover`]&&this._deflate.reset(),b(null,S)})}}Qp=u;function h(m){this[o].push(m),this[r]+=m.length}function l(m){if(this[r]+=m.length,this[n]._maxPayload<1||this[r]<=this[n]._maxPayload){this[o].push(m);return}this[d]=new RangeError("Max payload size exceeded"),this[d].code="WS_ERR_UNSUPPORTED_MESSAGE_LENGTH",this[d][s]=1009,this.removeListener("data",l),this.reset()}function p(m){this[n]._inflate=null,m[s]=1007,this[a](m)}return Qp}var rf={exports:{}};const FV={},HV=Object.freeze(Object.defineProperty({__proto__:null,default:FV},Symbol.toStringTag,{value:"Module"})),GV=My(HV);var A1;function Rl(){if(A1)return rf.exports;A1=1;const f=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0];function e(s){return s>=1e3&&s<=1014&&s!==1004&&s!==1005&&s!==1006||s>=3e3&&s<=4999}function t(s){const i=s.length;let n=0;for(;n<i;)if((s[n]&128)===0)n++;else if((s[n]&224)===192){if(n+1===i||(s[n+1]&192)!==128||(s[n]&254)===192)return!1;n+=2}else if((s[n]&240)===224){if(n+2>=i||(s[n+1]&192)!==128||(s[n+2]&192)!==128||s[n]===224&&(s[n+1]&224)===128||s[n]===237&&(s[n+1]&224)===160)return!1;n+=3}else if((s[n]&248)===240){if(n+3>=i||(s[n+1]&192)!==128||(s[n+2]&192)!==128||(s[n+3]&192)!==128||s[n]===240&&(s[n+1]&240)===128||s[n]===244&&s[n+1]>143||s[n]>244)return!1;n+=4}else return!1;return!0}if(rf.exports={isValidStatusCode:e,isValidUTF8:t,tokenChars:f},!{}.WS_NO_UTF_8_VALIDATE)try{const s=GV;rf.exports.isValidUTF8=function(i){return i.length<150?t(i):s(i)}}catch{}return rf.exports}var Zp,B1;function l_(){if(B1)return Zp;B1=1;const{Writable:f}=Mt,e=Ll(),{BINARY_TYPES:t,EMPTY_BUFFER:s,kStatusCode:i,kWebSocket:n}=lo(),{concat:r,toArrayBuffer:a,unmask:o}=ql(),{isValidStatusCode:d,isValidUTF8:c}=Rl(),u=0,h=1,l=2,p=3,m=4,g=5;class y extends f{constructor(S={}){super(),this._binaryType=S.binaryType||t[0],this._extensions=S.extensions||{},this._isServer=!!S.isServer,this._maxPayload=S.maxPayload|0,this._skipUTF8Validation=!!S.skipUTF8Validation,this[n]=void 0,this._bufferedBytes=0,this._buffers=[],this._compressed=!1,this._payloadLength=0,this._mask=void 0,this._fragmented=0,this._masked=!1,this._fin=!1,this._opcode=0,this._totalPayloadLength=0,this._messageLength=0,this._fragments=[],this._state=u,this._loop=!1}_write(S,k,T){if(this._opcode===8&&this._state==u)return T();this._bufferedBytes+=S.length,this._buffers.push(S),this.startLoop(T)}consume(S){if(this._bufferedBytes-=S,S===this._buffers[0].length)return this._buffers.shift();if(S<this._buffers[0].length){const T=this._buffers[0];return this._buffers[0]=T.slice(S),T.slice(0,S)}const k=Buffer.allocUnsafe(S);do{const T=this._buffers[0],I=k.length-S;S>=T.length?k.set(this._buffers.shift(),I):(k.set(new Uint8Array(T.buffer,T.byteOffset,S),I),this._buffers[0]=T.slice(S)),S-=T.length}while(S>0);return k}startLoop(S){let k;this._loop=!0;do switch(this._state){case u:k=this.getInfo();break;case h:k=this.getPayloadLength16();break;case l:k=this.getPayloadLength64();break;case p:this.getMask();break;case m:k=this.getData(S);break;default:this._loop=!1;return}while(this._loop);S(k)}getInfo(){if(this._bufferedBytes<2){this._loop=!1;return}const S=this.consume(2);if((S[0]&48)!==0)return this._loop=!1,b(RangeError,"RSV2 and RSV3 must be clear",!0,1002,"WS_ERR_UNEXPECTED_RSV_2_3");const k=(S[0]&64)===64;if(k&&!this._extensions[e.extensionName])return this._loop=!1,b(RangeError,"RSV1 must be clear",!0,1002,"WS_ERR_UNEXPECTED_RSV_1");if(this._fin=(S[0]&128)===128,this._opcode=S[0]&15,this._payloadLength=S[1]&127,this._opcode===0){if(k)return this._loop=!1,b(RangeError,"RSV1 must be clear",!0,1002,"WS_ERR_UNEXPECTED_RSV_1");if(!this._fragmented)return this._loop=!1,b(RangeError,"invalid opcode 0",!0,1002,"WS_ERR_INVALID_OPCODE");this._opcode=this._fragmented}else if(this._opcode===1||this._opcode===2){if(this._fragmented)return this._loop=!1,b(RangeError,`invalid opcode ${this._opcode}`,!0,1002,"WS_ERR_INVALID_OPCODE");this._compressed=k}else if(this._opcode>7&&this._opcode<11){if(!this._fin)return this._loop=!1,b(RangeError,"FIN must be set",!0,1002,"WS_ERR_EXPECTED_FIN");if(k)return this._loop=!1,b(RangeError,"RSV1 must be clear",!0,1002,"WS_ERR_UNEXPECTED_RSV_1");if(this._payloadLength>125)return this._loop=!1,b(RangeError,`invalid payload length ${this._payloadLength}`,!0,1002,"WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH")}else return this._loop=!1,b(RangeError,`invalid opcode ${this._opcode}`,!0,1002,"WS_ERR_INVALID_OPCODE");if(!this._fin&&!this._fragmented&&(this._fragmented=this._opcode),this._masked=(S[1]&128)===128,this._isServer){if(!this._masked)return this._loop=!1,b(RangeError,"MASK must be set",!0,1002,"WS_ERR_EXPECTED_MASK")}else if(this._masked)return this._loop=!1,b(RangeError,"MASK must be clear",!0,1002,"WS_ERR_UNEXPECTED_MASK");if(this._payloadLength===126)this._state=h;else if(this._payloadLength===127)this._state=l;else return this.haveLength()}getPayloadLength16(){if(this._bufferedBytes<2){this._loop=!1;return}return this._payloadLength=this.consume(2).readUInt16BE(0),this.haveLength()}getPayloadLength64(){if(this._bufferedBytes<8){this._loop=!1;return}const S=this.consume(8),k=S.readUInt32BE(0);return k>Math.pow(2,53-32)-1?(this._loop=!1,b(RangeError,"Unsupported WebSocket frame: payload length > 2^53 - 1",!1,1009,"WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH")):(this._payloadLength=k*Math.pow(2,32)+S.readUInt32BE(4),this.haveLength())}haveLength(){if(this._payloadLength&&this._opcode<8&&(this._totalPayloadLength+=this._payloadLength,this._totalPayloadLength>this._maxPayload&&this._maxPayload>0))return this._loop=!1,b(RangeError,"Max payload size exceeded",!1,1009,"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");this._masked?this._state=p:this._state=m}getMask(){if(this._bufferedBytes<4){this._loop=!1;return}this._mask=this.consume(4),this._state=m}getData(S){let k=s;if(this._payloadLength){if(this._bufferedBytes<this._payloadLength){this._loop=!1;return}k=this.consume(this._payloadLength),this._masked&&(this._mask[0]|this._mask[1]|this._mask[2]|this._mask[3])!==0&&o(k,this._mask)}if(this._opcode>7)return this.controlMessage(k);if(this._compressed){this._state=g,this.decompress(k,S);return}return k.length&&(this._messageLength=this._totalPayloadLength,this._fragments.push(k)),this.dataMessage()}decompress(S,k){this._extensions[e.extensionName].decompress(S,this._fin,(I,_)=>{if(I)return k(I);if(_.length){if(this._messageLength+=_.length,this._messageLength>this._maxPayload&&this._maxPayload>0)return k(b(RangeError,"Max payload size exceeded",!1,1009,"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));this._fragments.push(_)}const N=this.dataMessage();if(N)return k(N);this.startLoop(k)})}dataMessage(){if(this._fin){const S=this._messageLength,k=this._fragments;if(this._totalPayloadLength=0,this._messageLength=0,this._fragmented=0,this._fragments=[],this._opcode===2){let T;this._binaryType==="nodebuffer"?T=r(k,S):this._binaryType==="arraybuffer"?T=a(r(k,S)):T=k,this.emit("message",T,!0)}else{const T=r(k,S);if(!this._skipUTF8Validation&&!c(T))return this._loop=!1,b(Error,"invalid UTF-8 sequence",!0,1007,"WS_ERR_INVALID_UTF8");this.emit("message",T,!1)}}this._state=u}controlMessage(S){if(this._opcode===8)if(this._loop=!1,S.length===0)this.emit("conclude",1005,s),this.end();else{if(S.length===1)return b(RangeError,"invalid payload length 1",!0,1002,"WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");{const k=S.readUInt16BE(0);if(!d(k))return b(RangeError,`invalid status code ${k}`,!0,1002,"WS_ERR_INVALID_CLOSE_CODE");const T=S.slice(2);if(!this._skipUTF8Validation&&!c(T))return b(Error,"invalid UTF-8 sequence",!0,1007,"WS_ERR_INVALID_UTF8");this.emit("conclude",k,T),this.end()}}else this._opcode===9?this.emit("ping",S):this.emit("pong",S);this._state=u}}Zp=y;function b(w,S,k,T,I){const _=new w(k?`Invalid WebSocket frame: ${S}`:S);return Error.captureStackTrace(_,b),_.code=I,_[i]=T,_}return Zp}var Jp,N1;function p_(){if(N1)return Jp;N1=1;const{randomFillSync:f}=Mt,e=Ll(),{EMPTY_BUFFER:t}=lo(),{isValidStatusCode:s}=Rl(),{mask:i,toBuffer:n}=ql(),r=Symbol("kByteLength"),a=Buffer.alloc(4);class o{constructor(c,u,h){this._extensions=u||{},h&&(this._generateMask=h,this._maskBuffer=Buffer.alloc(4)),this._socket=c,this._firstFragment=!0,this._compress=!1,this._bufferedBytes=0,this._deflating=!1,this._queue=[]}static frame(c,u){let h,l=!1,p=2,m=!1;u.mask&&(h=u.maskBuffer||a,u.generateMask?u.generateMask(h):f(h,0,4),m=(h[0]|h[1]|h[2]|h[3])===0,p=6);let g;typeof c=="string"?(!u.mask||m)&&u[r]!==void 0?g=u[r]:(c=Buffer.from(c),g=c.length):(g=c.length,l=u.mask&&u.readOnly&&!m);let y=g;g>=65536?(p+=8,y=127):g>125&&(p+=2,y=126);const b=Buffer.allocUnsafe(l?g+p:p);return b[0]=u.fin?u.opcode|128:u.opcode,u.rsv1&&(b[0]|=64),b[1]=y,y===126?b.writeUInt16BE(g,2):y===127&&(b[2]=b[3]=0,b.writeUIntBE(g,4,6)),u.mask?(b[1]|=128,b[p-4]=h[0],b[p-3]=h[1],b[p-2]=h[2],b[p-1]=h[3],m?[b,c]:l?(i(c,h,b,p,g),[b]):(i(c,h,c,0,g),[b,c])):[b,c]}close(c,u,h,l){let p;if(c===void 0)p=t;else{if(typeof c!="number"||!s(c))throw new TypeError("First argument must be a valid error code number");if(u===void 0||!u.length)p=Buffer.allocUnsafe(2),p.writeUInt16BE(c,0);else{const g=Buffer.byteLength(u);if(g>123)throw new RangeError("The message must not be greater than 123 bytes");p=Buffer.allocUnsafe(2+g),p.writeUInt16BE(c,0),typeof u=="string"?p.write(u,2):p.set(u,2)}}const m={[r]:p.length,fin:!0,generateMask:this._generateMask,mask:h,maskBuffer:this._maskBuffer,opcode:8,readOnly:!1,rsv1:!1};this._deflating?this.enqueue([this.dispatch,p,!1,m,l]):this.sendFrame(o.frame(p,m),l)}ping(c,u,h){let l,p;if(typeof c=="string"?(l=Buffer.byteLength(c),p=!1):(c=n(c),l=c.length,p=n.readOnly),l>125)throw new RangeError("The data size must not be greater than 125 bytes");const m={[r]:l,fin:!0,generateMask:this._generateMask,mask:u,maskBuffer:this._maskBuffer,opcode:9,readOnly:p,rsv1:!1};this._deflating?this.enqueue([this.dispatch,c,!1,m,h]):this.sendFrame(o.frame(c,m),h)}pong(c,u,h){let l,p;if(typeof c=="string"?(l=Buffer.byteLength(c),p=!1):(c=n(c),l=c.length,p=n.readOnly),l>125)throw new RangeError("The data size must not be greater than 125 bytes");const m={[r]:l,fin:!0,generateMask:this._generateMask,mask:u,maskBuffer:this._maskBuffer,opcode:10,readOnly:p,rsv1:!1};this._deflating?this.enqueue([this.dispatch,c,!1,m,h]):this.sendFrame(o.frame(c,m),h)}send(c,u,h){const l=this._extensions[e.extensionName];let p=u.binary?2:1,m=u.compress,g,y;if(typeof c=="string"?(g=Buffer.byteLength(c),y=!1):(c=n(c),g=c.length,y=n.readOnly),this._firstFragment?(this._firstFragment=!1,m&&l&&l.params[l._isServer?"server_no_context_takeover":"client_no_context_takeover"]&&(m=g>=l._threshold),this._compress=m):(m=!1,p=0),u.fin&&(this._firstFragment=!0),l){const b={[r]:g,fin:u.fin,generateMask:this._generateMask,mask:u.mask,maskBuffer:this._maskBuffer,opcode:p,readOnly:y,rsv1:m};this._deflating?this.enqueue([this.dispatch,c,this._compress,b,h]):this.dispatch(c,this._compress,b,h)}else this.sendFrame(o.frame(c,{[r]:g,fin:u.fin,generateMask:this._generateMask,mask:u.mask,maskBuffer:this._maskBuffer,opcode:p,readOnly:y,rsv1:!1}),h)}dispatch(c,u,h,l){if(!u){this.sendFrame(o.frame(c,h),l);return}const p=this._extensions[e.extensionName];this._bufferedBytes+=h[r],this._deflating=!0,p.compress(c,h.fin,(m,g)=>{if(this._socket.destroyed){const y=new Error("The socket was closed while data was being compressed");typeof l=="function"&&l(y);for(let b=0;b<this._queue.length;b++){const w=this._queue[b],S=w[w.length-1];typeof S=="function"&&S(y)}return}this._bufferedBytes-=h[r],this._deflating=!1,h.readOnly=!1,this.sendFrame(o.frame(g,h),l),this.dequeue()})}dequeue(){for(;!this._deflating&&this._queue.length;){const c=this._queue.shift();this._bufferedBytes-=c[3][r],Reflect.apply(c[0],this,c.slice(1))}}enqueue(c){this._bufferedBytes+=c[3][r],this._queue.push(c)}sendFrame(c,u){c.length===2?(this._socket.cork(),this._socket.write(c[0]),this._socket.write(c[1],u),this._socket.uncork()):this._socket.write(c[0],u)}}return Jp=o,Jp}var em,E1;function UV(){if(E1)return em;E1=1;const{kForOnEventAttribute:f,kListener:e}=lo(),t=Symbol("kCode"),s=Symbol("kData"),i=Symbol("kError"),n=Symbol("kMessage"),r=Symbol("kReason"),a=Symbol("kTarget"),o=Symbol("kType"),d=Symbol("kWasClean");class c{constructor(y){this[a]=null,this[o]=y}get target(){return this[a]}get type(){return this[o]}}Object.defineProperty(c.prototype,"target",{enumerable:!0}),Object.defineProperty(c.prototype,"type",{enumerable:!0});class u extends c{constructor(y,b={}){super(y),this[t]=b.code===void 0?0:b.code,this[r]=b.reason===void 0?"":b.reason,this[d]=b.wasClean===void 0?!1:b.wasClean}get code(){return this[t]}get reason(){return this[r]}get wasClean(){return this[d]}}Object.defineProperty(u.prototype,"code",{enumerable:!0}),Object.defineProperty(u.prototype,"reason",{enumerable:!0}),Object.defineProperty(u.prototype,"wasClean",{enumerable:!0});class h extends c{constructor(y,b={}){super(y),this[i]=b.error===void 0?null:b.error,this[n]=b.message===void 0?"":b.message}get error(){return this[i]}get message(){return this[n]}}Object.defineProperty(h.prototype,"error",{enumerable:!0}),Object.defineProperty(h.prototype,"message",{enumerable:!0});class l extends c{constructor(y,b={}){super(y),this[s]=b.data===void 0?null:b.data}get data(){return this[s]}}Object.defineProperty(l.prototype,"data",{enumerable:!0}),em={CloseEvent:u,ErrorEvent:h,Event:c,EventTarget:{addEventListener(g,y,b={}){for(const S of this.listeners(g))if(!b[f]&&S[e]===y&&!S[f])return;let w;if(g==="message")w=function(k,T){const I=new l("message",{data:T?k:k.toString()});I[a]=this,m(y,this,I)};else if(g==="close")w=function(k,T){const I=new u("close",{code:k,reason:T.toString(),wasClean:this._closeFrameReceived&&this._closeFrameSent});I[a]=this,m(y,this,I)};else if(g==="error")w=function(k){const T=new h("error",{error:k,message:k.message});T[a]=this,m(y,this,T)};else if(g==="open")w=function(){const k=new c("open");k[a]=this,m(y,this,k)};else return;w[f]=!!b[f],w[e]=y,b.once?this.once(g,w):this.on(g,w)},removeEventListener(g,y){for(const b of this.listeners(g))if(b[e]===y&&!b[f]){this.removeListener(g,b);break}}},MessageEvent:l};function m(g,y,b){typeof g=="object"&&g.handleEvent?g.handleEvent.call(g,b):g.call(y,b)}return em}var tm,V1;function m_(){if(V1)return tm;V1=1;const{tokenChars:f}=Rl();function e(i,n,r){i[n]===void 0?i[n]=[r]:i[n].push(r)}function t(i){const n=Object.create(null);let r=Object.create(null),a=!1,o=!1,d=!1,c,u,h=-1,l=-1,p=-1,m=0;for(;m<i.length;m++)if(l=i.charCodeAt(m),c===void 0)if(p===-1&&f[l]===1)h===-1&&(h=m);else if(m!==0&&(l===32||l===9))p===-1&&h!==-1&&(p=m);else if(l===59||l===44){if(h===-1)throw new SyntaxError(`Unexpected character at index ${m}`);p===-1&&(p=m);const y=i.slice(h,p);l===44?(e(n,y,r),r=Object.create(null)):c=y,h=p=-1}else throw new SyntaxError(`Unexpected character at index ${m}`);else if(u===void 0)if(p===-1&&f[l]===1)h===-1&&(h=m);else if(l===32||l===9)p===-1&&h!==-1&&(p=m);else if(l===59||l===44){if(h===-1)throw new SyntaxError(`Unexpected character at index ${m}`);p===-1&&(p=m),e(r,i.slice(h,p),!0),l===44&&(e(n,c,r),r=Object.create(null),c=void 0),h=p=-1}else if(l===61&&h!==-1&&p===-1)u=i.slice(h,m),h=p=-1;else throw new SyntaxError(`Unexpected character at index ${m}`);else if(o){if(f[l]!==1)throw new SyntaxError(`Unexpected character at index ${m}`);h===-1?h=m:a||(a=!0),o=!1}else if(d)if(f[l]===1)h===-1&&(h=m);else if(l===34&&h!==-1)d=!1,p=m;else if(l===92)o=!0;else throw new SyntaxError(`Unexpected character at index ${m}`);else if(l===34&&i.charCodeAt(m-1)===61)d=!0;else if(p===-1&&f[l]===1)h===-1&&(h=m);else if(h!==-1&&(l===32||l===9))p===-1&&(p=m);else if(l===59||l===44){if(h===-1)throw new SyntaxError(`Unexpected character at index ${m}`);p===-1&&(p=m);let y=i.slice(h,p);a&&(y=y.replace(/\\/g,""),a=!1),e(r,u,y),l===44&&(e(n,c,r),r=Object.create(null),c=void 0),u=void 0,h=p=-1}else throw new SyntaxError(`Unexpected character at index ${m}`);if(h===-1||d||l===32||l===9)throw new SyntaxError("Unexpected end of input");p===-1&&(p=m);const g=i.slice(h,p);return c===void 0?e(n,g,r):(u===void 0?e(r,g,!0):a?e(r,u,g.replace(/\\/g,"")):e(r,u,g),e(n,c,r)),n}function s(i){return Object.keys(i).map(n=>{let r=i[n];return Array.isArray(r)||(r=[r]),r.map(a=>[n].concat(Object.keys(a).map(o=>{let d=a[o];return Array.isArray(d)||(d=[d]),d.map(c=>c===!0?o:`${o}=${c}`).join("; ")})).join("; ")).join(", ")}).join(", ")}return tm={format:s,parse:t},tm}var sm,q1;function g_(){if(q1)return sm;q1=1;const f=Mt,e=Mt,t=Mt,s=Mt,i=Mt,{randomBytes:n,createHash:r}=Mt,{URL:a}=Mt,o=Ll(),d=l_(),c=p_(),{BINARY_TYPES:u,EMPTY_BUFFER:h,GUID:l,kForOnEventAttribute:p,kListener:m,kStatusCode:g,kWebSocket:y,NOOP:b}=lo(),{EventTarget:{addEventListener:w,removeEventListener:S}}=UV(),{format:k,parse:T}=m_(),{toBuffer:I}=ql(),_=30*1e3,N=Symbol("kAborted"),M=[8,13],x=["CONNECTING","OPEN","CLOSING","CLOSED"],v=/^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;class O extends f{constructor($,G,U){super(),this._binaryType=u[0],this._closeCode=1006,this._closeFrameReceived=!1,this._closeFrameSent=!1,this._closeMessage=h,this._closeTimer=null,this._extensions={},this._paused=!1,this._protocol="",this._readyState=O.CONNECTING,this._receiver=null,this._sender=null,this._socket=null,$!==null?(this._bufferedAmount=0,this._isServer=!1,this._redirects=0,G===void 0?G=[]:Array.isArray(G)||(typeof G=="object"&&G!==null?(U=G,G=[]):G=[G]),A(this,$,G,U)):this._isServer=!0}get binaryType(){return this._binaryType}set binaryType($){!u.includes($)||(this._binaryType=$,this._receiver&&(this._receiver._binaryType=$))}get bufferedAmount(){return this._socket?this._socket._writableState.length+this._sender._bufferedBytes:this._bufferedAmount}get extensions(){return Object.keys(this._extensions).join()}get isPaused(){return this._paused}get onclose(){return null}get onerror(){return null}get onopen(){return null}get onmessage(){return null}get protocol(){return this._protocol}get readyState(){return this._readyState}get url(){return this._url}setSocket($,G,U){const W=new d({binaryType:this.binaryType,extensions:this._extensions,isServer:this._isServer,maxPayload:U.maxPayload,skipUTF8Validation:U.skipUTF8Validation});this._sender=new c($,this._extensions,U.generateMask),this._receiver=W,this._socket=$,W[y]=this,$[y]=this,W.on("conclude",P),W.on("drain",E),W.on("error",j),W.on("message",Q),W.on("ping",Se),W.on("pong",he),$.setTimeout(0),$.setNoDelay(),G.length>0&&$.unshift(G),$.on("close",Ae),$.on("data",Re),$.on("end",He),$.on("error",qt),this._readyState=O.OPEN,this.emit("open")}emitClose(){if(!this._socket){this._readyState=O.CLOSED,this.emit("close",this._closeCode,this._closeMessage);return}this._extensions[o.extensionName]&&this._extensions[o.extensionName].cleanup(),this._receiver.removeAllListeners(),this._readyState=O.CLOSED,this.emit("close",this._closeCode,this._closeMessage)}close($,G){if(this.readyState!==O.CLOSED){if(this.readyState===O.CONNECTING){const U="WebSocket was closed before the connection was established";return H(this,this._req,U)}if(this.readyState===O.CLOSING){this._closeFrameSent&&(this._closeFrameReceived||this._receiver._writableState.errorEmitted)&&this._socket.end();return}this._readyState=O.CLOSING,this._sender.close($,G,!this._isServer,U=>{U||(this._closeFrameSent=!0,(this._closeFrameReceived||this._receiver._writableState.errorEmitted)&&this._socket.end())}),this._closeTimer=setTimeout(this._socket.destroy.bind(this._socket),_)}}pause(){this.readyState===O.CONNECTING||this.readyState===O.CLOSED||(this._paused=!0,this._socket.pause())}ping($,G,U){if(this.readyState===O.CONNECTING)throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");if(typeof $=="function"?(U=$,$=G=void 0):typeof G=="function"&&(U=G,G=void 0),typeof $=="number"&&($=$.toString()),this.readyState!==O.OPEN){F(this,$,U);return}G===void 0&&(G=!this._isServer),this._sender.ping($||h,G,U)}pong($,G,U){if(this.readyState===O.CONNECTING)throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");if(typeof $=="function"?(U=$,$=G=void 0):typeof G=="function"&&(U=G,G=void 0),typeof $=="number"&&($=$.toString()),this.readyState!==O.OPEN){F(this,$,U);return}G===void 0&&(G=!this._isServer),this._sender.pong($||h,G,U)}resume(){this.readyState===O.CONNECTING||this.readyState===O.CLOSED||(this._paused=!1,this._receiver._writableState.needDrain||this._socket.resume())}send($,G,U){if(this.readyState===O.CONNECTING)throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");if(typeof G=="function"&&(U=G,G={}),typeof $=="number"&&($=$.toString()),this.readyState!==O.OPEN){F(this,$,U);return}const W={binary:typeof $!="string",mask:!this._isServer,compress:!0,fin:!0,...G};this._extensions[o.extensionName]||(W.compress=!1),this._sender.send($||h,W,U)}terminate(){if(this.readyState!==O.CLOSED){if(this.readyState===O.CONNECTING){const $="WebSocket was closed before the connection was established";return H(this,this._req,$)}this._socket&&(this._readyState=O.CLOSING,this._socket.destroy())}}}Object.defineProperty(O,"CONNECTING",{enumerable:!0,value:x.indexOf("CONNECTING")}),Object.defineProperty(O.prototype,"CONNECTING",{enumerable:!0,value:x.indexOf("CONNECTING")}),Object.defineProperty(O,"OPEN",{enumerable:!0,value:x.indexOf("OPEN")}),Object.defineProperty(O.prototype,"OPEN",{enumerable:!0,value:x.indexOf("OPEN")}),Object.defineProperty(O,"CLOSING",{enumerable:!0,value:x.indexOf("CLOSING")}),Object.defineProperty(O.prototype,"CLOSING",{enumerable:!0,value:x.indexOf("CLOSING")}),Object.defineProperty(O,"CLOSED",{enumerable:!0,value:x.indexOf("CLOSED")}),Object.defineProperty(O.prototype,"CLOSED",{enumerable:!0,value:x.indexOf("CLOSED")}),["binaryType","bufferedAmount","extensions","isPaused","protocol","readyState","url"].forEach(D=>{Object.defineProperty(O.prototype,D,{enumerable:!0})}),["open","error","close","message"].forEach(D=>{Object.defineProperty(O.prototype,`on${D}`,{enumerable:!0,get(){for(const $ of this.listeners(D))if($[p])return $[m];return null},set($){for(const G of this.listeners(D))if(G[p]){this.removeListener(D,G);break}typeof $=="function"&&this.addEventListener(D,$,{[p]:!0})}})}),O.prototype.addEventListener=w,O.prototype.removeEventListener=S,sm=O;function A(D,$,G,U){const W={protocolVersion:M[1],maxPayload:104857600,skipUTF8Validation:!1,perMessageDeflate:!0,followRedirects:!1,maxRedirects:10,...U,createConnection:void 0,socketPath:void 0,hostname:void 0,protocol:void 0,timeout:void 0,method:"GET",host:void 0,path:void 0,port:void 0};if(!M.includes(W.protocolVersion))throw new RangeError(`Unsupported protocol version: ${W.protocolVersion} (supported versions: ${M.join(", ")})`);let J;if($ instanceof a)J=$,D._url=$.href;else{try{J=new a($)}catch{throw new SyntaxError(`Invalid URL: ${$}`)}D._url=$}const ee=J.protocol==="wss:",ne=J.protocol==="ws+unix:";let ce;if(J.protocol!=="ws:"&&!ee&&!ne?ce=`The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`:ne&&!J.pathname?ce="The URL's pathname is empty":J.hash&&(ce="The URL contains a fragment identifier"),ce){const L=new SyntaxError(ce);if(D._redirects===0)throw L;V(D,L);return}const ie=ee?443:80,de=n(16).toString("base64"),we=ee?e.request:t.request,ue=new Set;let Oe;if(W.createConnection=ee?R:q,W.defaultPort=W.defaultPort||ie,W.port=J.port||ie,W.host=J.hostname.startsWith("[")?J.hostname.slice(1,-1):J.hostname,W.headers={...W.headers,"Sec-WebSocket-Version":W.protocolVersion,"Sec-WebSocket-Key":de,Connection:"Upgrade",Upgrade:"websocket"},W.path=J.pathname+J.search,W.timeout=W.handshakeTimeout,W.perMessageDeflate&&(Oe=new o(W.perMessageDeflate!==!0?W.perMessageDeflate:{},!1,W.maxPayload),W.headers["Sec-WebSocket-Extensions"]=k({[o.extensionName]:Oe.offer()})),G.length){for(const L of G){if(typeof L!="string"||!v.test(L)||ue.has(L))throw new SyntaxError("An invalid or duplicated subprotocol was specified");ue.add(L)}W.headers["Sec-WebSocket-Protocol"]=G.join(",")}if(W.origin&&(W.protocolVersion<13?W.headers["Sec-WebSocket-Origin"]=W.origin:W.headers.Origin=W.origin),(J.username||J.password)&&(W.auth=`${J.username}:${J.password}`),ne){const L=W.path.split(":");W.socketPath=L[0],W.path=L[1]}let Me;if(W.followRedirects){if(D._redirects===0){D._originalIpc=ne,D._originalSecure=ee,D._originalHostOrSocketPath=ne?W.socketPath:J.host;const L=U&&U.headers;if(U={...U,headers:{}},L)for(const[C,B]of Object.entries(L))U.headers[C.toLowerCase()]=B}else if(D.listenerCount("redirect")===0){const L=ne?D._originalIpc?W.socketPath===D._originalHostOrSocketPath:!1:D._originalIpc?!1:J.host===D._originalHostOrSocketPath;(!L||D._originalSecure&&!ee)&&(delete W.headers.authorization,delete W.headers.cookie,L||delete W.headers.host,W.auth=void 0)}W.auth&&!U.headers.authorization&&(U.headers.authorization="Basic "+Buffer.from(W.auth).toString("base64")),Me=D._req=we(W),D._redirects&&D.emit("redirect",D.url,Me)}else Me=D._req=we(W);W.timeout&&Me.on("timeout",()=>{H(D,Me,"Opening handshake has timed out")}),Me.on("error",L=>{Me===null||Me[N]||(Me=D._req=null,V(D,L))}),Me.on("response",L=>{const C=L.headers.location,B=L.statusCode;if(C&&W.followRedirects&&B>=300&&B<400){if(++D._redirects>W.maxRedirects){H(D,Me,"Maximum redirects exceeded");return}Me.abort();let z;try{z=new a(C,$)}catch{const se=new SyntaxError(`Invalid URL: ${C}`);V(D,se);return}A(D,z,G,U)}else D.emit("unexpected-response",Me,L)||H(D,Me,`Unexpected server response: ${L.statusCode}`)}),Me.on("upgrade",(L,C,B)=>{if(D.emit("upgrade",L),D.readyState!==O.CONNECTING)return;if(Me=D._req=null,L.headers.upgrade.toLowerCase()!=="websocket"){H(D,C,"Invalid Upgrade header");return}const z=r("sha1").update(de+l).digest("base64");if(L.headers["sec-websocket-accept"]!==z){H(D,C,"Invalid Sec-WebSocket-Accept header");return}const Y=L.headers["sec-websocket-protocol"];let se;if(Y!==void 0?ue.size?ue.has(Y)||(se="Server sent an invalid subprotocol"):se="Server sent a subprotocol but none was requested":ue.size&&(se="Server sent no subprotocol"),se){H(D,C,se);return}Y&&(D._protocol=Y);const re=L.headers["sec-websocket-extensions"];if(re!==void 0){if(!Oe){H(D,C,"Server sent a Sec-WebSocket-Extensions header but no extension was requested");return}let Be;try{Be=T(re)}catch{H(D,C,"Invalid Sec-WebSocket-Extensions header");return}const $e=Object.keys(Be);if($e.length!==1||$e[0]!==o.extensionName){H(D,C,"Server indicated an extension that was not requested");return}try{Oe.accept(Be[o.extensionName])}catch{H(D,C,"Invalid Sec-WebSocket-Extensions header");return}D._extensions[o.extensionName]=Oe}D.setSocket(C,B,{generateMask:W.generateMask,maxPayload:W.maxPayload,skipUTF8Validation:W.skipUTF8Validation})}),Me.end()}function V(D,$){D._readyState=O.CLOSING,D.emit("error",$),D.emitClose()}function q(D){return D.path=D.socketPath,s.connect(D)}function R(D){return D.path=void 0,!D.servername&&D.servername!==""&&(D.servername=s.isIP(D.host)?"":D.host),i.connect(D)}function H(D,$,G){D._readyState=O.CLOSING;const U=new Error(G);Error.captureStackTrace(U,H),$.setHeader?($[N]=!0,$.abort(),$.socket&&!$.socket.destroyed&&$.socket.destroy(),process.nextTick(V,D,U)):($.destroy(U),$.once("error",D.emit.bind(D,"error")),$.once("close",D.emitClose.bind(D)))}function F(D,$,G){if($){const U=I($).length;D._socket?D._sender._bufferedBytes+=U:D._bufferedAmount+=U}if(G){const U=new Error(`WebSocket is not open: readyState ${D.readyState} (${x[D.readyState]})`);G(U)}}function P(D,$){const G=this[y];G._closeFrameReceived=!0,G._closeMessage=$,G._closeCode=D,G._socket[y]!==void 0&&(G._socket.removeListener("data",Re),process.nextTick(xe,G._socket),D===1005?G.close():G.close(D,$))}function E(){const D=this[y];D.isPaused||D._socket.resume()}function j(D){const $=this[y];$._socket[y]!==void 0&&($._socket.removeListener("data",Re),process.nextTick(xe,$._socket),$.close(D[g])),$.emit("error",D)}function X(){this[y].emitClose()}function Q(D,$){this[y].emit("message",D,$)}function Se(D){const $=this[y];$.pong(D,!$._isServer,b),$.emit("ping",D)}function he(D){this[y].emit("pong",D)}function xe(D){D.resume()}function Ae(){const D=this[y];this.removeListener("close",Ae),this.removeListener("data",Re),this.removeListener("end",He),D._readyState=O.CLOSING;let $;!this._readableState.endEmitted&&!D._closeFrameReceived&&!D._receiver._writableState.errorEmitted&&($=D._socket.read())!==null&&D._receiver.write($),D._receiver.end(),this[y]=void 0,clearTimeout(D._closeTimer),D._receiver._writableState.finished||D._receiver._writableState.errorEmitted?D.emitClose():(D._receiver.on("error",X),D._receiver.on("finish",X))}function Re(D){this[y]._receiver.write(D)||this.pause()}function He(){const D=this[y];D._readyState=O.CLOSING,D._receiver.end(),this.end()}function qt(){const D=this[y];this.removeListener("error",qt),this.on("error",b),D&&(D._readyState=O.CLOSING,this.destroy())}return sm}var im,L1;function $V(){if(L1)return im;L1=1;const{Duplex:f}=Mt;function e(n){n.emit("close")}function t(){!this.destroyed&&this._writableState.finished&&this.destroy()}function s(n){this.removeListener("error",s),this.destroy(),this.listenerCount("error")===0&&this.emit("error",n)}function i(n,r){let a=!0;const o=new f({...r,autoDestroy:!1,emitClose:!1,objectMode:!1,writableObjectMode:!1});return n.on("message",function(c,u){const h=!u&&o._readableState.objectMode?c.toString():c;o.push(h)||n.pause()}),n.once("error",function(c){o.destroyed||(a=!1,o.destroy(c))}),n.once("close",function(){o.destroyed||o.push(null)}),o._destroy=function(d,c){if(n.readyState===n.CLOSED){c(d),process.nextTick(e,o);return}let u=!1;n.once("error",function(l){u=!0,c(l)}),n.once("close",function(){u||c(d),process.nextTick(e,o)}),a&&n.terminate()},o._final=function(d){if(n.readyState===n.CONNECTING){n.once("open",function(){o._final(d)});return}n._socket!==null&&(n._socket._writableState.finished?(d(),o._readableState.endEmitted&&o.destroy()):(n._socket.once("finish",function(){d()}),n.close()))},o._read=function(){n.isPaused&&n.resume()},o._write=function(d,c,u){if(n.readyState===n.CONNECTING){n.once("open",function(){o._write(d,c,u)});return}n.send(d,u)},o.on("end",t),o.on("error",s),o}return im=i,im}var nm,R1;function jV(){if(R1)return nm;R1=1;const{tokenChars:f}=Rl();function e(t){const s=new Set;let i=-1,n=-1,r=0;for(r;r<t.length;r++){const o=t.charCodeAt(r);if(n===-1&&f[o]===1)i===-1&&(i=r);else if(r!==0&&(o===32||o===9))n===-1&&i!==-1&&(n=r);else if(o===44){if(i===-1)throw new SyntaxError(`Unexpected character at index ${r}`);n===-1&&(n=r);const d=t.slice(i,n);if(s.has(d))throw new SyntaxError(`The "${d}" subprotocol is duplicated`);s.add(d),i=n=-1}else throw new SyntaxError(`Unexpected character at index ${r}`)}if(i===-1||n!==-1)throw new SyntaxError("Unexpected end of input");const a=t.slice(i,r);if(s.has(a))throw new SyntaxError(`The "${a}" subprotocol is duplicated`);return s.add(a),s}return nm={parse:e},nm}var rm,F1;function WV(){if(F1)return rm;F1=1;const f=Mt,e=Mt,{createHash:t}=Mt,s=m_(),i=Ll(),n=jV(),r=g_(),{GUID:a,kWebSocket:o}=lo(),d=/^[+/0-9A-Za-z]{22}==$/,c=0,u=1,h=2;class l extends f{constructor(S,k){if(super(),S={maxPayload:100*1024*1024,skipUTF8Validation:!1,perMessageDeflate:!1,handleProtocols:null,clientTracking:!0,verifyClient:null,noServer:!1,backlog:null,server:null,host:null,path:null,port:null,WebSocket:r,...S},S.port==null&&!S.server&&!S.noServer||S.port!=null&&(S.server||S.noServer)||S.server&&S.noServer)throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified');if(S.port!=null?(this._server=e.createServer((T,I)=>{const _=e.STATUS_CODES[426];I.writeHead(426,{"Content-Length":_.length,"Content-Type":"text/plain"}),I.end(_)}),this._server.listen(S.port,S.host,S.backlog,k)):S.server&&(this._server=S.server),this._server){const T=this.emit.bind(this,"connection");this._removeListeners=p(this._server,{listening:this.emit.bind(this,"listening"),error:this.emit.bind(this,"error"),upgrade:(I,_,N)=>{this.handleUpgrade(I,_,N,T)}})}S.perMessageDeflate===!0&&(S.perMessageDeflate={}),S.clientTracking&&(this.clients=new Set,this._shouldEmitClose=!1),this.options=S,this._state=c}address(){if(this.options.noServer)throw new Error('The server is operating in "noServer" mode');return this._server?this._server.address():null}close(S){if(this._state===h){S&&this.once("close",()=>{S(new Error("The server is not running"))}),process.nextTick(m,this);return}if(S&&this.once("close",S),this._state!==u)if(this._state=u,this.options.noServer||this.options.server)this._server&&(this._removeListeners(),this._removeListeners=this._server=null),this.clients?this.clients.size?this._shouldEmitClose=!0:process.nextTick(m,this):process.nextTick(m,this);else{const k=this._server;this._removeListeners(),this._removeListeners=this._server=null,k.close(()=>{m(this)})}}shouldHandle(S){if(this.options.path){const k=S.url.indexOf("?");if((k!==-1?S.url.slice(0,k):S.url)!==this.options.path)return!1}return!0}handleUpgrade(S,k,T,I){k.on("error",g);const _=S.headers["sec-websocket-key"],N=+S.headers["sec-websocket-version"];if(S.method!=="GET"){b(this,S,k,405,"Invalid HTTP method");return}if(S.headers.upgrade.toLowerCase()!=="websocket"){b(this,S,k,400,"Invalid Upgrade header");return}if(!_||!d.test(_)){b(this,S,k,400,"Missing or invalid Sec-WebSocket-Key header");return}if(N!==8&&N!==13){b(this,S,k,400,"Missing or invalid Sec-WebSocket-Version header");return}if(!this.shouldHandle(S)){y(k,400);return}const M=S.headers["sec-websocket-protocol"];let x=new Set;if(M!==void 0)try{x=n.parse(M)}catch{b(this,S,k,400,"Invalid Sec-WebSocket-Protocol header");return}const v=S.headers["sec-websocket-extensions"],O={};if(this.options.perMessageDeflate&&v!==void 0){const A=new i(this.options.perMessageDeflate,!0,this.options.maxPayload);try{const V=s.parse(v);V[i.extensionName]&&(A.accept(V[i.extensionName]),O[i.extensionName]=A)}catch{b(this,S,k,400,"Invalid or unacceptable Sec-WebSocket-Extensions header");return}}if(this.options.verifyClient){const A={origin:S.headers[`${N===8?"sec-websocket-origin":"origin"}`],secure:!!(S.socket.authorized||S.socket.encrypted),req:S};if(this.options.verifyClient.length===2){this.options.verifyClient(A,(V,q,R,H)=>{if(!V)return y(k,q||401,R,H);this.completeUpgrade(O,_,x,S,k,T,I)});return}if(!this.options.verifyClient(A))return y(k,401)}this.completeUpgrade(O,_,x,S,k,T,I)}completeUpgrade(S,k,T,I,_,N,M){if(!_.readable||!_.writable)return _.destroy();if(_[o])throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");if(this._state>c)return y(_,503);const v=["HTTP/1.1 101 Switching Protocols","Upgrade: websocket","Connection: Upgrade",`Sec-WebSocket-Accept: ${t("sha1").update(k+a).digest("base64")}`],O=new this.options.WebSocket(null);if(T.size){const A=this.options.handleProtocols?this.options.handleProtocols(T,I):T.values().next().value;A&&(v.push(`Sec-WebSocket-Protocol: ${A}`),O._protocol=A)}if(S[i.extensionName]){const A=S[i.extensionName].params,V=s.format({[i.extensionName]:[A]});v.push(`Sec-WebSocket-Extensions: ${V}`),O._extensions=S}this.emit("headers",v,I),_.write(v.concat(`\r
`).join(`\r
`)),_.removeListener("error",g),O.setSocket(_,N,{maxPayload:this.options.maxPayload,skipUTF8Validation:this.options.skipUTF8Validation}),this.clients&&(this.clients.add(O),O.on("close",()=>{this.clients.delete(O),this._shouldEmitClose&&!this.clients.size&&process.nextTick(m,this)})),M(O,I)}}rm=l;function p(w,S){for(const k of Object.keys(S))w.on(k,S[k]);return function(){for(const T of Object.keys(S))w.removeListener(T,S[T])}}function m(w){w._state=h,w.emit("close")}function g(){this.destroy()}function y(w,S,k,T){k=k||e.STATUS_CODES[S],T={Connection:"close","Content-Type":"text/html","Content-Length":Buffer.byteLength(k),...T},w.once("finish",w.destroy),w.end(`HTTP/1.1 ${S} ${e.STATUS_CODES[S]}\r
`+Object.keys(T).map(I=>`${I}: ${T[I]}`).join(`\r
`)+`\r
\r
`+k)}function b(w,S,k,T,I){if(w.listenerCount("wsClientError")){const _=new Error(I);Error.captureStackTrace(_,b),w.emit("wsClientError",_,k,S)}else y(k,T,I)}return rm}var am,D1;function zV(){if(D1)return am;D1=1;const f=g_();return f.createWebSocketStream=$V(),f.Server=WV(),f.Receiver=l_(),f.Sender=p_(),f.WebSocket=f,f.WebSocketServer=f.Server,am=f,am}const KV=Au,{sleep:XV,isNode:y_,milliseconds:YV}=KV,QV=EV,om=y_?zV():self.WebSocket;var ZV=class extends QV{createConnection(){this.verbose&&this.log(new Date,"connecting to",this.url),this.connectionStarted=YV(),this.setConnectionTimeout(),this.connection=new om(this.url,this.protocols,this.options),this.connection.onopen=this.onOpen.bind(this),this.connection.onmessage=this.onMessage.bind(this),this.connection.onerror=this.onError.bind(this),this.connection.onclose=this.onClose.bind(this),y_&&this.connection.on("ping",this.onPing.bind(this)).on("pong",this.onPong.bind(this)).on("upgrade",this.onUpgrade.bind(this))}connect(e=0){return this.startedConnecting||(this.startedConnecting=!0,e?XV(e).then(this.createConnection.bind(this)):this.createConnection()),this.connected}isOpen(){return this.connection.readyState===om.OPEN}close(){if(this.connection instanceof om)return this.connection.close()}};function nd(f,e){let t=0,s=f.length-1;for(;t<=s;){const i=t+s>>>1;f[i]-e<0?t=i+1:s=i-1}return t}const JV=1024,b_=new Float64Array(new Array(JV).fill(Number.MAX_VALUE));class Fl extends Array{constructor(e=[],t=void 0){super(),Object.defineProperty(this,"index",{__proto__:null,value:new Float64Array(b_),writable:!0}),Object.defineProperty(this,"depth",{__proto__:null,value:t||Number.MAX_SAFE_INTEGER,writable:!0}),this.length=0;for(let s=0;s<e.length;s++)this.storeArray(e[s].slice())}storeArray(e){const t=e[0],s=e[1],i=this.side?-t:t,n=nd(this.index,i);if(s){if(this.index[n]===i)this[n][1]=s;else if(this.length++,this.index.copyWithin(n+1,n,this.index.length),this.index[n]=i,this.copyWithin(n+1,n,this.length),this[n]=e,this.length>this.index.length-1){const r=Array.from(this.index);r.length=this.length*2,r.fill(Number.MAX_VALUE,this.index.length),this.index=new Float64Array(r)}}else this.index[n]===i&&(this.index.copyWithin(n,n+1,this.index.length),this.index[this.length-1]=Number.MAX_VALUE,this.copyWithin(n,n+1,this.length),this.length--)}store(e,t){this.storeArray([e,t])}limit(){if(this.length>this.depth){for(let e=this.depth;e<this.length;e++)this.index[e]=Number.MAX_VALUE;this.length=this.depth}}}class Sb extends Fl{store(e,t,s){this.storeArray([e,t,s])}storeArray(e){const t=e[0],s=e[1],i=e[2],n=this.side?-t:t,r=nd(this.index,n);if(s&&i){if(this.index[r]===n){const a=this[r];a[1]=s,a[2]=i}else if(this.length++,this.index.copyWithin(r+1,r,this.index.length),this.index[r]=n,this.copyWithin(r+1,r,this.length),this[r]=e,this.length>this.index.length-1){const a=Array.from(this.index);a.length=this.length*2,a.fill(Number.MAX_VALUE,this.index.length),this.index=new Float64Array(a)}}else this.index[r]===n&&(this.index.copyWithin(r,r+1,this.index.length),this.index[this.length-1]=Number.MAX_VALUE,this.copyWithin(r,r+1,this.length),this.length--)}}class kb extends Array{constructor(e=[],t=Number.MAX_SAFE_INTEGER){super(e.length),Object.defineProperty(this,"hashmap",{__proto__:null,value:new Map,writable:!0}),Object.defineProperty(this,"index",{__proto__:null,value:new Float64Array(b_),writable:!0}),Object.defineProperty(this,"depth",{__proto__:null,value:t||Number.MAX_SAFE_INTEGER,writable:!0}),Object.defineProperty(this,"hidden",{__proto__:null,value:new Map,writable:!0});for(let s=0;s<e.length;s++)this.length=s,this.storeArray(e[s].slice())}store(e,t,s){this.storeArray([e,t,s])}storeArray(e){const t=e[0],s=e[1],i=e[2];let n;if(t!==void 0?n=this.side?-t:t:n=void 0,s){if(this.hashmap.has(i)){const a=this.hashmap.get(i);if(n=n||a,e[0]=Math.abs(n),n===a){const o=nd(this.index,n);this.index[o]=n,this[o]=e;return}else{const o=nd(this.index,a);this.index.copyWithin(o,o+1,this.index.length),this.index[this.length-1]=Number.MAX_VALUE,this.copyWithin(o,o+1,this.length),this.length--}}this.hashmap.set(i,n);const r=nd(this.index,n);if(this.length++,this.index.copyWithin(r+1,r,this.index.length),this.index[r]=n,this.copyWithin(r+1,r,this.length),this[r]=e,this.length>this.index.length-1){const a=Array.from(this.index);a.length=this.length*2,a.fill(Number.MAX_VALUE,this.index.length),this.index=new Float64Array(a)}}else if(this.hashmap.has(i)){const r=this.hashmap.get(i),a=nd(this.index,r);this.index.copyWithin(a,a+1,this.index.length),this.index[this.length-1]=Number.MAX_VALUE,this.copyWithin(a,a+1,this.length),this.length--,this.hashmap.delete(i)}}limit(){if(this.length>this.depth){for(let e=this.depth;e<this.length;e++)this.hashmap.delete(this.index[e]),this.index[e]=Number.MAX_VALUE;this.length=this.depth}}}class eq extends Fl{get side(){return!1}}class tq extends Fl{get side(){return!0}}class sq extends Sb{get side(){return!1}}class iq extends Sb{get side(){return!0}}class nq extends kb{get side(){return!1}}class rq extends kb{get side(){return!0}}var aq={Asks:eq,Bids:tq,OrderBookSide:Fl,CountedAsks:sq,CountedBids:iq,CountedOrderBookSide:Sb,IndexedAsks:nq,IndexedBids:rq,IndexedOrderBookSide:kb};const{iso8601:dm}=yb,{extend:Bu,deepExtend:rQ}=Ex,{Asks:oq,Bids:dq,CountedAsks:cq,CountedBids:uq,IndexedAsks:fq,IndexedBids:hq,IncrementalAsks:lq,IncrementalBids:pq,IncrementalIndexedAsks:mq,IncrementalIndexedBids:gq}=aq;class Nu{constructor(e={},t=void 0){Object.defineProperty(this,"cache",{__proto__:null,value:[],writable:!0}),t=t||Number.MAX_SAFE_INTEGER;const i=Object.entries(Bu({bids:[],asks:[],timestamp:void 0,datetime:void 0,nonce:void 0,symbol:void 0},e));for(let n=0;n<i.length;n++){const[r,a]=i[n];this[r]=a}this.asks.constructor.name==="Array"&&(this.asks=new oq(this.asks,t)),this.bids.constructor.name==="Array"&&(this.bids=new dq(this.bids,t)),this.timestamp&&(this.datetime=dm(this.timestamp))}limit(){return this.asks.limit(),this.bids.limit(),this}update(e){return e.nonce!==void 0&&this.nonce!==void 0&&e.nonce<=this.nonce?this:(this.nonce=e.nonce,this.timestamp=e.timestamp,this.datetime=dm(this.timestamp),this.reset(e))}reset(e={}){if(this.asks.index.fill(Number.MAX_VALUE),this.asks.length=0,e.asks)for(let t=0;t<e.asks.length;t++)this.asks.storeArray(e.asks[t]);if(this.bids.index.fill(Number.MAX_VALUE),this.bids.length=0,e.bids)for(let t=0;t<e.bids.length;t++)this.bids.storeArray(e.bids[t]);return this.nonce=e.nonce,this.timestamp=e.timestamp,this.datetime=dm(this.timestamp),this.symbol=e.symbol,this}}class yq extends Nu{constructor(e={},t=void 0){super(Bu(e,{asks:new cq(e.asks||[],t),bids:new uq(e.bids||[],t)}))}}class bq extends Nu{constructor(e={},t=void 0){super(Bu(e,{asks:new fq(e.asks||[],t),bids:new hq(e.bids||[],t)}))}}class wq extends Nu{constructor(e={},t=void 0){super(Bu(e,{asks:new lq(e.asks||[],t),bids:new pq(e.bids||[],t)}))}}class Sq extends Nu{constructor(e={},t=void 0){super(Bu(e,{asks:new mq(e.asks||[],t),bids:new gq(e.bids||[],t)}))}}var kq={OrderBook:Nu,CountedOrderBook:yq,IndexedOrderBook:bq,IncrementalOrderBook:wq,IncrementalIndexedOrderBook:Sq};const vq=me,Tq=Au.throttle,Oq=ZV,{OrderBook:Iq,IndexedOrderBook:xq,CountedOrderBook:_q}=kq,cm=h_;var Cq=class extends vq{constructor(e={}){super(e),this.newUpdates=e.newUpdates||!0}inflate(e){return cm.inflate(e)}inflate64(e){return cm.inflate64(e)}gunzip(e){return cm.gunzip(e)}orderBook(e={},t=Number.MAX_SAFE_INTEGER){return new Iq(e,t)}indexedOrderBook(e={},t=Number.MAX_SAFE_INTEGER){return new xq(e,t)}countedOrderBook(e={},t=Number.MAX_SAFE_INTEGER){return new _q(e,t)}client(e){if(this.clients=this.clients||{},!this.clients[e]){const t=this.handleMessage.bind(this),s=this.onError.bind(this),i=this.onClose.bind(this),n=this.onConnected.bind(this),r=this.safeValue(this.options,"ws",{}),a=this.extend(this.streaming,{log:this.log?this.log.bind(this):this.log,ping:this.ping?this.ping.bind(this):this.ping,verbose:this.verbose,throttle:Tq(this.tokenBucket)},r);this.clients[e]=new Oq(e,t,s,i,n,a)}return this.clients[e]}spawn(e,...t){e.apply(this,t).catch(s=>{})}delay(e,t,...s){setTimeout(()=>{this.spawn(t,...s)},e)}watch(e,t,s=void 0,i=void 0,n=void 0){const r=this.client(e),a=0,o=r.future(t);return r.connect(a).then(()=>{if(!r.subscriptions[i]){r.subscriptions[i]=n||!0;const c=this.safeValue(this.options,"ws"),u=this.safeValue(c,"cost",1);s&&(this.enableRateLimit&&r.throttle?r.throttle(u).then(()=>{r.send(s)}).catch(h=>{throw h}):r.send(s))}}),o}onConnected(e,t=void 0){}onError(e,t){e.url in this.clients&&this.clients[e.url].error&&delete this.clients[e.url]}onClose(e,t){e.error||this.clients[e.url]&&delete this.clients[e.url]}async close(){const e=Object.values(this.clients||{});for(let t=0;t<e.length;t++){const s=e[t];delete this.clients[s.url],await s.close()}}findTimeframe(e,t=void 0){t=t||this.timeframes;const s=Object.keys(t);for(let i=0;i<s.length;i++){const n=s[i];if(t[n]===e)return n}}formatScientificNotationFTX(e){return e===0?"0e-00":e.toExponential().replace("e-","e-0")}};const Mq=me,{ArgumentsRequired:So,AuthenticationError:Ud,ExchangeError:af,ExchangeNotAvailable:H1,OrderNotFound:$d,InvalidOrder:st,CancelPending:Pq,RateLimitExceeded:um,InsufficientFunds:fm,BadRequest:Ui,BadSymbol:hm,PermissionDenied:Aq}=oe,{TICK_SIZE:Bq}=pe,It=ke;var w_=class extends Mq{describe(){return this.deepExtend(super.describe(),{id:"aax",name:"AAX",countries:["MT"],rateLimit:600,version:"v2",hostname:"aaxpro.com",pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createDepositAddress:!1,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchCanceledOrders:!0,fetchClosedOrder:void 0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:void 0,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchL3OrderBook:void 0,fetchLedger:void 0,fetchLedgerEntry:void 0,fetchLeverage:void 0,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:void 0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrders:!0,fetchOrderTrades:void 0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:"emulated",fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTradingLimits:void 0,fetchTransactionFee:void 0,fetchTransactionFees:void 0,fetchTransactions:void 0,fetchTransfer:!1,fetchTransfers:!0,fetchWithdrawal:!1,fetchWithdrawals:!0,fetchWithdrawalWhitelist:!1,reduceMargin:!1,setLeverage:!0,setMargin:!0,setMarginMode:!1,setPositionMode:void 0,signIn:void 0,transfer:!0,withdraw:!1},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","12h":"12h","1d":"1d","3d":"3d","1w":"1w"},urls:{logo:"https://user-images.githubusercontent.com/1294454/104140087-a27f2580-53c0-11eb-87c1-5d9e81208fe9.jpg",test:{v1:"https://api.testnet.{hostname}/marketdata/v1",public:"https://api.testnet.{hostname}",private:"https://api.testnet.{hostname}"},api:{v1:"https://api.{hostname}/marketdata/v1",public:"https://api.{hostname}",private:"https://api.{hostname}"},www:"https://www.aax.com",doc:"https://www.aax.com/apidoc/index.html",fees:"https://www.aax.com/en-US/vip/",referral:"https://www.aax.com/invite/sign-up?inviteCode=JXGm5Fy7R2MB"},api:{v1:{get:["getHistMarketData"]},public:{get:{currencies:1.2,"announcement/maintenance":1.2,time:1.2,instruments:1.2,"market/orderbook":1.2,"futures/position/openInterest":1.2,"market/tickers":1.2,"market/candles":1.2,"market/history/candles":1.2,"market/trades":1.2,"market/markPrice":1.2,"futures/funding/predictedFunding/{symbol}":1.2,"futures/funding/prevFundingRate/{symbol}":1.2,"futures/funding/fundingRate":1.2,"market/candles/index":1.2,"market/index/candles":1.2}},private:{get:{"user/info":1.2,"account/balances":1.2,"account/deposit/address":1.2,"account/deposits":1.2,"account/transfer":1.2,"account/withdraws":1.2,"spot/trades":1.2,"spot/openOrders":1.2,"spot/orders":1.2,"futures/position":1.2,"futures/position/closed":1.2,"futures/trades":1.2,"futures/openOrders":1.2,"futures/orders":1.2,"futures/funding/fundingFee":1.2,"futures/funding/predictedFundingFee/{symbol}":1.2},post:{"account/transfer":1.2,"spot/orders":1.2,"spot/orders/cancelAllOnTimeout":10,"futures/orders":1.2,"futures/orders/cancelAllOnTimeout":10,"futures/position/sltp":1.2,"futures/position/close":1.2,"futures/position/leverage":30,"futures/position/margin":1.2},put:{"spot/orders":1.2,"futures/orders":1.2},delete:{"spot/orders/cancel/{orderID}":1,"spot/orders/cancel/all":10,"futures/orders/cancel/{orderID}":1,"futures/orders/cancel/all":10}}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.0006"),taker:this.parseNumber("0.001")},funding:{tierBased:!1,percentage:!0,withdraw:{}}},commonCurrencies:{XBT:"XBT"},exceptions:{exact:{2002:fm,2003:$d,10003:Ui,10006:Ud,10007:Ud,11007:Ud,20001:fm,20009:st,3e4:$d,30001:st,30004:st,30005:st,30006:st,30007:st,30008:st,30009:st,30010:st,30011:Pq,30012:Ui,30013:hm,30014:$d,30015:st,30016:af,30017:st,30018:st,30019:st,30020:st,30021:st,30022:st,30023:st,30024:st,30025:st,30026:st,30027:st,30028:hm,30029:st,30030:st,30031:st,30032:st,30033:st,30034:um,30035:um,30036:H1,30037:st,30038:af,30039:fm,30040:st,30041:st,30042:st,30043:st,30044:Ui,30045:st,30046:st,30047:st,30048:st,30049:st,30050:st,40004:Ui,40009:um,40102:Ud,40103:Ud,40303:Aq,41001:Ui,41002:Ui,42001:H1,50001:af,50002:af},broad:{}},precisionMode:Bq,options:{defaultType:"spot",accountsByType:{spot:"SPTP",future:"FUTP",otc:"F2CP",saving:"VLTP"},accountsById:{SPTP:"spot",FUTP:"future",F2CP:"otc",VLTP:"saving"},networks:{ETH:"ERC20",TRX:"TRC20",SOL:"SPL"},transfer:{fillResponseFromRequest:!0}}})}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeInteger(t,"data")}async fetchStatus(e={}){const t=await this.publicGetAnnouncementMaintenance(e),s=this.milliseconds(),i=this.safeInteger(t,"ts",s),n=this.safeValue(t,"data",{});let r,a;if(n){const o=this.parse8601(this.safeString(n,"startTime")),d=this.parse8601(this.safeString(n,"endTime"));if(d!==void 0){const c=o===void 0?!0:i<o,u=i>d||c;a=d,r=u?"ok":"maintenance"}else r=n}else a=void 0,r="ok";return{status:r,updated:i,eta:a,url:void 0,info:t}}async fetchMarkets(e={}){const t=await this.publicGetInstruments(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeString(r,"base"),d=this.safeString(r,"quote"),c=this.safeString(r,"settleCurrency"),u=this.safeCurrencyCode(o),h=this.safeCurrencyCode(d),l=this.safeCurrencyCode(c),p=this.safeString(r,"status"),m=this.safeString(r,"type");let g,y,b;const w=m==="spot",S=m==="futures",k=this.safeStringLower(r,"settleType");k!==void 0&&(g=k==="inverse",y=k==="vanilla",b=k==="quanto");let T=u+"/"+h,I="spot",_,N,M;if(S){T=T+":"+l,I="swap",_=this.safeNumber(r,"multiplier"),N="1";const x=this.safeString(r,"imRate");M=It.stringDiv("1",x)}i.push({id:a,symbol:T,base:u,quote:h,settle:l,baseId:o,quoteId:d,settleId:c,type:I,spot:w,margin:!1,swap:S,future:!1,option:!1,active:p==="enable",contract:S,linear:y,inverse:g,quanto:b,taker:this.safeNumber(r,"takerFee"),maker:this.safeNumber(r,"makerFee"),contractSize:_,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(r,"lotSize"),price:this.safeNumber(r,"tickSize")},limits:{leverage:{min:this.parseNumber(N),max:this.parseNumber(M)},amount:{min:this.safeNumber(r,"minQuantity"),max:this.safeNumber(r,"maxQuantity")},price:{min:this.safeNumber(r,"minPrice"),max:this.safeNumber(r,"maxPrice")},cost:{min:void 0,max:void 0}},info:r})}return i}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s={},i=this.safeValue(t,"data",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.safeString(r,"network"),c=this.safeValue(r,"enableWithdraw"),u=this.safeValue(r,"enableDeposit"),h=this.safeValue(r,"visible"),l=c&&u&&h,p={info:r,id:d,network:this.safeCurrencyCode(d),limits:{withdraw:{min:this.safeNumber(r,"withdrawMin"),max:void 0},deposit:{min:this.safeNumber(r,"depositMin"),max:void 0}},active:l,withdraw:c&&h,deposit:u&&h,fee:this.safeNumber(r,"withdrawFee"),precision:this.safeNumber(r,"withdrawPrecision")},m=this.safeValue(s,o),g=this.safeString(r,"withdrawFee"),y=this.safeString(r,"withdrawPrecision"),b=this.safeString(r,"depositMin"),w=this.safeString(r,"withdrawMin");if(m!==void 0){m.networks.push(p);const S=m.precision.toString(),k=m.limits.deposit.min.toString(),T=m.limits.withdraw.min.toString(),I=m.fee.toString();m.precision=this.parseNumber(It.stringMax(S,y)),m.limits.deposit.min=this.parseNumber(It.stringMin(k,b)),m.limits.withdraw.min=this.parseNumber(It.stringMin(T,w)),m.fee=this.parseNumber(It.stringMin(I,g))}else{const S=this.safeString(r,"displayName"),k=u&&h,T=c&&h;s[o]={info:{},id:a,name:S,code:o,precision:this.parseNumber(y),active:l,deposit:k,withdraw:T,fee:this.parseNumber(g),networks:[p],limits:{amount:{min:void 0,max:void 0},deposit:{min:this.parseNumber(b),max:void 0},withdraw:{min:this.parseNumber(w),max:void 0}}}}}return s}parseTicker(e,t=void 0){const s=this.safeInteger(e,"t"),i=this.safeString(e,"s"),n=this.safeSymbol(i,t),r=this.safeString(e,"c"),a=this.safeString(e,"o"),o=this.safeString(e,"v");return this.safeTicker({symbol:n,timestamp:s,datetime:void 0,high:this.safeString(e,"h"),low:this.safeString(e,"l"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:a,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:o,info:e},t)}async setMargin(e,t,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id,margin:t},r=await this.privatePostFuturesPositionMargin(this.extend(n,s)),a=this.safeValue(r,"data",{});return this.parseModifyMargin(a,i)}parseModifyMargin(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeString(e,"quote");return{info:e,type:"set",amount:void 0,total:this.safeNumber(e,"posMargin"),code:this.safeCurrencyCode(i),symbol:this.safeSymbol(s,t),status:void 0}}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetMarketTickers(t),i=this.safeValue(s,"tickers",[]),n=[],r=this.safeInteger(s,"t");for(let a=0;a<i.length;a++){const o=this.parseTicker(this.extend(i[a],{t:r}));n.push(o)}return this.filterByArray(n,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);if(e=i.symbol,t===void 0)t=20;else if(t!==20&&t!==50)throw new Ui(this.id+" fetchOrderBook() limit argument must be undefined, 20 or 50");const n={symbol:i.id,level:t},r=await this.publicGetMarketOrderbook(this.extend(n,s)),a=this.safeInteger(r,"t");return this.parseOrderBook(r,e,a)}parseTrade(e,t=void 0){let s=this.safeInteger(e,"t");s===void 0&&(s=this.parse8601(this.safeString(e,"createTime")));let i=this.safeString2(e,"tid","tradeID");i=this.safeString(e,"i",i);const n=this.safeString(e,"symbol");t=this.safeMarket(n,t);let r=this.safeString2(e,"p","filledPrice");const a=this.safeString2(e,"q","filledQty"),o=this.safeString(e,"orderID"),d=this.safeValue(e,"taker");let c;d!==void 0&&(c=d?"taker":"maker");let u=this.safeString(e,"side");u==="1"?u="buy":u==="2"&&(u="sell"),u===void 0&&(u=r[0]==="-"?"sell":"buy"),r=It.stringAbs(r);const h=this.parseOrderType(this.safeString(e,"orderType"));let l;const p=this.safeString(e,"commission");if(p!==void 0){let m;u==="buy"?m=t.base:u==="sell"&&(m=t.quote),l={currency:m,cost:p}}return this.safeTrade({info:e,id:i,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:h,side:u,order:o,takerOrMaker:c,price:r,amount:a,cost:void 0,fee:l},t)}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.currency=n.id),t!==void 0&&(r.startTime=t);const a=await this.privateGetAccountTransfer(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransfers(o,n,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);s=s===void 0?2e3:s,s=Math.min(s,2e3);const r={symbol:n.id,limit:s},a=await this.publicGetMarketTrades(r),o=this.safeValue(a,"trades",[]);return this.parseTrades(o,n,t,s)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,5),this.safeNumber(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,6)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,timeFrame:this.timeframes[t]};i=i===void 0?500:i;const o=this.parseTimeframe(t);if(s===void 0){const u=this.seconds();a.start=u-o*i,a.end=u}else{const u=parseInt(s/1e3);a.start=u,a.end=this.sum(u,o*i)}const d=await this.publicGetMarketHistoryCandles(this.extend(a,n)),c=this.safeValue(d,"data",[]);return this.parseOHLCVs(c,r,t,s,i)}async fetchAccounts(e={}){const t=await this.privateGetAccountBalances(e),s=this.safeValue(t,"data",{});return this.parseAccounts(s)}parseAccount(e){const t=this.safeString(e,"currency"),s=this.safeString(e,"purseType"),i=this.safeValue(this.options,"accountsById",{});return{info:e,id:void 0,code:this.safeCurrencyCode(t),type:this.safeString(i,s,s)}}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString2(this.options,"fetchBalance","defaultType","spot"),s=this.safeString(e,"type",t),i=this.safeValue(this.options,"accountsByType",{}),n=this.safeString(i,s,s),r={purseType:n};e=this.omit(e,"type");const a=await this.privateGetAccountBalances(this.extend(r,e)),o=this.safeValue(a,"data",[]),d=this.safeInteger(a,"ts"),c={info:a,timestamp:d,datetime:this.iso8601(d)};for(let u=0;u<o.length;u++){const h=o[u];if(this.safeString(h,"purseType")===n){const p=this.safeString(h,"currency"),m=this.safeCurrencyCode(p),g=this.account();g.free=this.safeString(h,"available"),g.used=this.safeString(h,"unavailable"),c[m]=g}}return this.safeBalance(c)}async createOrder(e,t,s,i,n=void 0,r={}){let a=t.toUpperCase();const o=s.toUpperCase();await this.loadMarkets();const d=this.market(e),c={symbol:d.id,orderQty:this.amountToPrecision(e,i),side:o},u=this.safeString2(r,"clOrdID","clientOrderId");u!==void 0&&(c.clOrdID=u);const h=this.isPostOnly(a==="MARKET",void 0,r),l=this.safeString(r,"timeInForce");h&&(c.execInst="Post-Only"),l!==void 0&&l!=="PO"&&(c.timeInForce=l);const p=this.safeValue2(r,"triggerPrice","stopPrice");if(r=this.omit(r,["clOrdID","clientOrderId","postOnly","timeInForce","stopPrice","triggerPrice"]),p===void 0){if(a==="STOP-LIMIT"||a==="STOP")throw new So(this.id+" createOrder() requires a stopPrice parameter for "+a+" orders")}else a==="LIMIT"?a="STOP-LIMIT":a==="MARKET"&&(a="STOP"),c.stopPrice=this.priceToPrecision(e,p);(a==="LIMIT"||a==="STOP-LIMIT")&&(c.price=this.priceToPrecision(e,n)),c.orderType=a;let m;d.spot?m="privatePostSpotOrders":d.contract&&(m="privatePostFuturesOrders");const g=await this[m](this.extend(c,r)),y=this.safeValue(g,"data",{});return this.parseOrder(y,d)}async editOrder(e,t,s,i,n,r=void 0,a={}){await this.loadMarkets();const o=this.market(t),d={orderID:e},c=this.safeValue2(a,"triggerPrice","stopPrice");c!==void 0&&(d.stopPrice=this.priceToPrecision(t,c),a=this.omit(a,"stopPrice")),r!==void 0&&(d.price=this.priceToPrecision(t,r)),n!==void 0&&(d.orderQty=this.amountToPrecision(t,n));let u;o.spot?u="privatePutSpotOrders":o.contract&&(u="privatePutFuturesOrders");const h=await this[u](this.extend(d,a)),l=this.safeValue(h,"data",{});return this.parseOrder(l,o)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderID:e};let n;t!==void 0&&(n=this.market(t));const[r,a]=this.handleMarketTypeAndParams("cancelOrder",n,s),o=this.getSupportedMapping(r,{spot:"privateDeleteSpotOrdersCancelOrderID",swap:"privateDeleteFuturesOrdersCancelOrderID",future:"privateDeleteFuturesOrdersCancelOrderID"}),d=await this[o](this.extend(i,a)),c=this.safeValue(d,"data",{});return this.parseOrder(c,n)}async cancelOrders(e,t=void 0,s={}){if(t===void 0)throw new So(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={symbol:i.id};let r;i.spot?r="privateDeleteSpotOrdersCancelAll":i.contract&&(r="privateDeleteFuturesOrdersCancelAll");const a=this.safeValue(s,"clientOrderIds");return a!==void 0?(s=this.omit(s,["clientOrderIds"]),n.clOrdID=a.join(",")):e!==void 0&&(n.orderID=e.join(",")),await this[r](this.extend(n,s))}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new So(this.id+" cancelAllOrders() requires a symbol argument");await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let n;return s.spot?n="privateDeleteSpotOrdersCancelAll":s.contract&&(n="privateDeleteFuturesOrdersCancelAll"),await this[n](this.extend(i,t))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeString2(this.options,"fetchOrder","defaultType","spot");s.type=this.safeString(s,"type",i);const n={},r=this.safeString2(s,"clOrdID","clientOrderId");r===void 0?n.orderID=e:(n.clOrdID=r,s=this.omit(s,["clOrdID","clientOrderId"]));const a=await this.fetchOrders(t,void 0,void 0,this.extend(n,s)),o=this.safeValue(a,0);if(o===void 0)throw r===void 0?new $d(this.id+" fetchOrder() could not find order id "+e):new $d(this.id+" fetchOrder() could not find order clientOrderID "+r);return o}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id);const[a,o]=this.handleMarketTypeAndParams("fetchOpenOrders",r,i),d=this.getSupportedMapping(a,{spot:"privateGetSpotOpenOrders",swap:"privateGetFuturesOpenOrders",future:"privateGetFuturesOpenOrders"}),c=this.safeString2(i,"clOrdID","clientOrderId");c!==void 0&&(n.clOrdID=c,i=this.omit(i,["clOrdID","clientOrderId"])),s!==void 0&&(n.pageSize=s);const u=await this[d](this.extend(n,o)),h=this.safeValue(u,"data",{}),l=this.safeValue(h,"list",[]);return this.parseOrders(l,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={orderStatus:"2"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){const n={orderStatus:"3"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id);const[a,o]=this.handleMarketTypeAndParams("fetchOrders",r,i),d=this.getSupportedMapping(a,{spot:"privateGetSpotOrders",swap:"privateGetFuturesOrders",future:"privateGetFuturesOrders"}),c=this.safeString2(i,"clOrdID","clientOrderId");c!==void 0&&(n.clOrdID=c,i=this.omit(i,["clOrdID","clientOrderId"])),s!==void 0&&(n.pageSize=s),t!==void 0&&(n.startDate=this.yyyymmdd(t));const u=await this[d](this.extend(n,o)),h=this.safeValue(u,"data",{}),l=this.safeValue(h,"list",[]);return this.parseOrders(l,r,t,s)}parseOrderStatus(e){const t={0:"open",1:"open",2:"open",3:"closed",4:"canceled",5:"canceled",6:"rejected",10:"expired",11:"rejected"};return this.safeString(t,e,e)}parseOrderType(e){const t={1:"market",2:"limit",3:"stop",4:"stop-limit",7:"stop-loss",8:"take-profit"};return this.safeString(t,e,e)}parseTimeInForce(e){const t={1:"GTC",3:"IOC",4:"FOK"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){let s=this.safeValue(e,"createTime");typeof s=="string"&&(s=this.parse8601(s));const i=this.parseOrderStatus(this.safeString(e,"orderStatus")),n=this.parseOrderType(this.safeString(e,"orderType"));let r=this.safeString(e,"side");r==="1"?r="buy":r==="2"&&(r="sell");const a=this.safeString(e,"orderID"),o=this.safeString(e,"clOrdID"),d=this.safeString(e,"symbol");t=this.safeMarket(d,t);const c=this.safeString(e,"price"),u=this.safeNumber(e,"stopPrice"),h=this.parseTimeInForce(this.safeString(e,"timeInForce")),p=this.safeString(e,"execInst")==="Post-Only",m=this.safeString(e,"avgPrice"),g=this.safeString(e,"orderQty"),y=this.safeString(e,"cumQty");let b=this.safeString(e,"leavesQty");It.stringEquals(y,"0")&&It.stringEquals(b,"0")&&(b=void 0);let w=this.safeValue(e,"transactTime");typeof w=="string"&&(w=this.parse8601(w));let S;const k=this.safeNumber(e,"commission");if(k!==void 0){let T;r==="buy"?T=t.base:r==="sell"&&(T=t.quote),S={currency:T,cost:k}}return this.safeOrder({id:a,info:e,clientOrderId:o,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:w,status:i,symbol:t.symbol,type:n,timeInForce:h,postOnly:p,side:r,price:c,stopPrice:u,average:m,amount:g,filled:y,remaining:b,cost:void 0,trades:void 0,fee:S},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id);const[a,o]=this.handleMarketTypeAndParams("fetchMyTrades",r,i),d=this.getSupportedMapping(a,{spot:"privateGetSpotTrades",swap:"privateGetFuturesTrades",future:"privateGetFuturesTrades"});s!==void 0&&(n.pageSize=s),t!==void 0&&(n.startDate=this.yyyymmdd(t));const c=await this[d](this.extend(n,o)),u=this.safeValue(c,"data",{}),h=this.safeValue(u,"list",[]);return this.parseTrades(h,r,t,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id};if("network"in t){const a=this.safeValue(this.options,"networks",{}),o=this.safeStringUpper(t,"network");t=this.omit(t,"network"),i.network=this.safeStringUpper(a,o,o)}const n=await this.privateGetAccountDepositAddress(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseDepositAddress(r,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.currency(e),n.currency=r.id),t!==void 0){const d=parseInt(t/1e3);n.startTime=d,n.endTime=this.sum(d,90*24*60*60)}const a=await this.privateGetAccountDeposits(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.currency(e),n.currency=r.id),t!==void 0){const d=parseInt(t/1e3);n.startTime=d,n.endTime=this.sum(d,90*24*60*60)}const a=await this.privateGetAccountWithdraws(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,r,t,s)}parseTransactionStatusByType(e,t=void 0){const s={deposit:{1:"pending",2:"ok",3:"failed"},withdrawal:{0:"pending",1:"pending",2:"pending",3:"failed",4:"pending",5:"ok",6:"failed"}};return this.safeString(this.safeValue(s,t,{}),e,e)}parseAddressByType(e,t,s=void 0){let i,n,r,a;return s==="deposit"?(i=e,r=t):s==="withdrawal"&&(n=e,a=t),[i,r,n,a]}parseTransaction(e,t=void 0){const s=this.safeString(e,"fee");let i="withdrawal";s===void 0&&(i="deposit");const n=this.safeCurrencyCode(this.safeString(e,"currency")),r=this.safeString(e,"txHash"),a=this.safeString(e,"address"),o=this.safeString(e,"addressTag"),[d,c,u,h]=this.parseAddressByType(a,o,i),l=this.safeString(e,"quantity"),p=this.parse8601(this.safeString(e,"createdTime")),m=this.parse8601(this.safeString(e,"updatedTime")),g=this.parseTransactionStatusByType(this.safeString(e,"status"),i),y=this.safeString(e,"network");return{id:void 0,info:e,txid:r,timestamp:p,datetime:this.iso8601(p),network:y,addressFrom:d,address:a,addressTo:u,amount:this.parseNumber(l),type:i,currency:n,status:g,updated:m,tagFrom:c,tag:o,tagTo:h,comment:void 0,fee:s}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new Ui("Funding rates only exist for swap contracts");const i={symbol:s.id},n=await this.publicGetFuturesFundingPrevFundingRateSymbol(this.extend(i,t)),r=this.safeValue(n,"data");return this.parseFundingRate(r)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeNumber(e,"markPrice"),r=this.safeNumber(e,"fundingRate"),a=this.safeString(e,"fundingTime"),o=this.safeString(e,"nextFundingTime");return{info:e,symbol:i,markPrice:n,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:void 0,fundingTimestamp:this.parse8601(o),fundingDatetime:o,nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:r,previousFundingTimestamp:this.parse8601(a),previousFundingDatetime:a}}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"tag");let n=this.safeString(e,"currency");const r=this.safeString(e,"network");r!==void 0&&(n=n.replace(r,""));const a=this.safeCurrencyCode(n);return{info:e,currency:a,address:s,tag:i,network:r}}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new So(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};t!==void 0&&(r.startTime=parseInt(t/1e3));const a=this.safeInteger2(i,"until","till");i=this.omit(i,["till","until"]),a!==void 0&&(r.endTime=parseInt(a/1e3)),s!==void 0&&(r.limit=s);const o=await this.publicGetFuturesFundingFundingRate(this.extend(r,i)),d=this.safeValue(o,"data",[]),c=[];for(let h=0;h<d.length;h++){const l=d[h],p=this.safeString(l,"symbol"),m=this.safeSymbol(p),g=this.safeString(l,"fundingTime");c.push({info:l,symbol:m,fundingRate:this.safeNumber(l,"fundingRate"),timestamp:this.parse8601(g),datetime:g})}const u=this.sortBy(c,"timestamp");return this.filterBySymbolSinceLimit(u,n.symbol,t,s)}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),e===void 0)throw new So(this.id+" fetchFundingHistory() requires a symbol argument");if(s===void 0)s=100;else if(s>1e3)throw new Ui(this.id+" fetchFundingHistory() limit argument cannot exceed 1000");const r={symbol:this.market(e).id,limit:s};t!==void 0&&(r.startTime=t);const a=await this.privateGetFuturesFundingFundingFee(this.extend(r,i)),o=this.safeValue(a,"data",[]),d=[];for(let c=0;c<o.length;c++){const u=o[c],h=this.safeString(u,"fundingTime");d.push({info:u,symbol:e,code:this.safeCurrencyCode(this.safeString(u,"currency")),timestamp:this.parse8601(h),datetime:h,id:void 0,amount:this.safeNumber(u,"fundingFee")})}return d}async setLeverage(e,t=void 0,s={}){if(await this.loadMarkets(),t===void 0)throw new So(this.id+" setLeverage() requires a symbol argument");if(e<1||e>100)throw new Ui(this.id+" leverage should be between 1 and 100");const i=this.market(t);if(i.type!=="swap")throw new hm(this.id+" setLeverage() supports swap contracts only");const n={symbol:i.id,leverage:e};return await this.privatePostFuturesPositionLeverage(this.extend(n,s))}parseTransfer(e,t=void 0){const s=this.safeString(e,"transferID"),i=this.safeNumber(e,"quantity"),n=this.parse8601(this.safeString(e,"transferTime")),r=this.safeValue(this.options,"accounts",{}),a=this.safeString(e,"fromPurse"),o=this.safeString(e,"toPurse"),d=this.safeString(r,a),c=this.safeString(r,o),u=this.safeString(e,"currency"),h=this.safeCurrencyCode(u,t);return{info:e,id:s,timestamp:n,datetime:this.iso8601(n),currency:h,amount:i,fromAccount:d,toAccount:c,status:void 0}}parseTransferStatus(e){const t={1:"ok"};return this.safeString(t,e,"canceled")}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c={currency:r.id,fromPurse:o,toPurse:d,quantity:t},u=await this.privatePostAccountTransfer(this.extend(c,n)),h=this.safeValue(u,"data",{}),l=this.parseTransfer(h,r),p=this.safeValue(this.options,"transfer",{});return this.safeValue(p,"fillResponseFromRequest",!0)&&(l.fromAccount===void 0&&(l.fromAccount=s),l.toAccount===void 0&&(l.toAccount=i),l.amount===void 0&&(l.amount=t)),l.status=this.parseTransferStatus(this.safeString(u,"code")),l}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeString(e,"currentQty");let n;It.stringGt(i,"0")?n="long":It.stringLt(i,"0")&&(n="short");const r=this.safeString(e,"leverage"),a=this.safeString(e,"unrealisedPnl"),o=this.safeString(e,"currentQty"),d=this.safeString(t,"contractSize"),c=It.stringMul(o,d),u=this.safeString(e,"marketPrice"),h=this.safeInteger(e,"ts"),l=this.safeString(e,"liquidationPrice"),p=this.safeValue(t,"info"),m=this.safeString(p,"multiplier"),g=this.safeString(e,"settleType"),y=this.safeString(e,"avgEntryPrice"),b=this.safeString(e,"commission");let w,S,k;if(g==="VANILLA"){k=It.stringMul(c,u),w=It.stringDiv(It.stringMul(It.stringMul(o,y),m),r);const N=It.stringDiv(It.stringMul(o,m),It.stringMul(y,r));S=It.stringAdd(N,b)}else k=It.stringDiv(c,u),w=It.stringDiv(o,It.stringMul(r,y)),S=w;const T=this.safeString(e,"posMargin"),I=It.stringDiv(a,w),_=It.stringDiv(S,T);return{info:e,id:void 0,symbol:this.safeString(t,"symbol"),timestamp:h,datetime:this.iso8601(h),initialMargin:this.parseNumber(w),initialMarginPercentage:this.parseNumber(It.stringDiv(w,k)),maintenanceMargin:this.parseNumber(S),maintenanceMarginPercentage:this.parseNumber(It.stringDiv(S,k)),entryPrice:this.parseNumber(y),notional:this.parseNumber(k),leverage:this.parseNumber(r),unrealizedPnl:this.parseNumber(a),contracts:this.parseNumber(i),contractSize:this.parseNumber(d),marginRatio:this.parseNumber(_),liquidationPrice:l,markPrice:this.safeNumber(e,"marketPrice"),collateral:this.parseNumber(T),marginMode:"isolated",side:n,percentage:this.parseNumber(I)}}async fetchPosition(e=void 0,t={}){await this.loadMarkets();const i={symbol:this.market(e).id},n=await this.privateGetFuturesPosition(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeInteger(n,"ts"),o=this.safeValue(r,0),d=this.parsePosition(o);return this.extend(d,{timestamp:a,datetime:this.iso8601(a)})}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s={};if(e!==void 0){let o;if(Array.isArray(e)){if(e.length>1)throw new Ui(this.id+" fetchPositions() symbols argument cannot contain more than 1 symbol");o=e[0]}else o=e;e=this.marketSymbols(e);const d=this.market(o);s.symbol=d.id}const i=await this.privateGetFuturesPosition(this.extend(s,t)),n=[],r=this.safeValue(i,"data",[]),a=this.safeInteger(i,"ts");for(let o=0;o<r.length;o++){const d=this.parsePosition(r[o]);n.push(this.extend(d,{timestamp:a,datetime:this.iso8601(a)}))}return this.filterByArray(n,"symbol",e,!1)}async fetchOpenInterest(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.contract)throw new Ui(this.id+" fetchOpenInterest() supports contract markets only");const i={symbol:s.id},n=await this.publicGetFuturesPositionOpenInterest(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeInteger(n,"ts"),o=this.parseOpenInterest(r,s);return this.extend(o,{timestamp:a,datetime:this.iso8601(a)})}parseOpenInterest(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeNumber(e,"openInterest"),n=this.safeNumber(e,"openInterestUSD");return{symbol:this.safeSymbol(s),openInterestAmount:i,baseVolume:i,openInterestValue:n,quoteVolume:n,timestamp:void 0,datetime:void 0,info:e}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="v1")Object.keys(o).length&&(a+="?"+this.urlencode(o));else if(a="/"+this.version+a,t==="public")Object.keys(o).length&&(a+="?"+this.urlencode(o));else if(t==="private"){this.checkRequiredCredentials();const d=this.nonce().toString();n={"X-ACCESS-KEY":this.apiKey,"X-ACCESS-NONCE":d};let c=d+":"+s;s==="GET"?(Object.keys(o).length&&(a+="?"+this.urlencode(o)),c+=a):(n["Content-Type"]="application/json",r=this.json(o),c+=a+r);const u=this.hmac(this.encode(c),this.encode(this.secret));n["X-ACCESS-SIGN"]=u}return a=this.implodeHostname(this.urls.api[t])+a,{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"code");if(c!==void 0&&c!=="1"){const u=this.id+" "+this.json(a);this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,r,u)}}};const Nq=me,{ExchangeError:Eq,BadRequest:G1,PermissionDenied:U1,BadSymbol:Vq,NotSupported:qq,InsufficientFunds:Lq,InvalidOrder:Rq}=oe,{TICK_SIZE:Fq}=pe;var Dq=class extends Nq{describe(){return this.deepExtend(super.describe(),{id:"alpaca",name:"Alpaca",countries:["US"],rateLimit:333,hostname:"alpaca.markets",urls:{logo:"https://user-images.githubusercontent.com/1294454/187234005-b864db3d-f1e3-447a-aaf9-a9fc7b955d07.jpg",www:"https://alpaca.markets",api:{public:"https://api.{hostname}/{version}",private:"https://api.{hostname}/{version}",cryptoPublic:"https://data.{hostname}/{version}",markets:"https://api.{hostname}/{version}"},test:{public:"https://paper-api.{hostname}/{version}",private:"https://paper-api.{hostname}/{version}",cryptoPublic:"https://data.{hostname}/{version}",markets:"https://api.{hostname}/{version}"},doc:"https://alpaca.markets/docs/",fees:"https://alpaca.markets/support/what-are-the-fees-associated-with-crypto-trading/"},has:{CORS:!1,spot:!0,margin:!1,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,fetchBalance:!0,fetchBidsAsks:!1,fetchClosedOrders:!1,fetchCurrencies:!1,fetchDepositAddress:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRates:!1,fetchL1OrderBook:!0,fetchL2OrderBook:!1,fetchMarkets:!0,fetchMyTrades:!1,fetchOHLCV:!1,fetchOpenOrder:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchPositions:!1,fetchStatus:!1,fetchTicker:!1,fetchTickers:!1,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfers:!1,fetchWithdrawals:!1,setLeverage:!1,setMarginMode:!1,transfer:!1,withdraw:!1},api:{markets:{get:["assets/public/beta"]},private:{get:["account","orders","orders/{order_id}","positions","positions/{symbol}","account/activities/{activity_type}"],post:["orders"],delete:["orders","orders/{order_id}"]},cryptoPublic:{get:["crypto/latest/orderbooks","crypto/trades","crypto/quotes","crypto/latest/quotes","crypto/bars","crypto/snapshots"]}},timeframes:{"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1H","2h":"2H","4h":"4H","6h":"6H","8h":"8H","12h":"12H","1d":"1D","3d":"3D","1w":"1W","1M":"1M"},precisionMode:Fq,requiredCredentials:{apiKey:!0,secret:!0},fees:{trading:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.003"),taker:this.parseNumber("0.003"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.003")],[this.parseNumber("500000"),this.parseNumber("0.0028")],[this.parseNumber("1000000"),this.parseNumber("0.0025")],[this.parseNumber("5000000"),this.parseNumber("0.002")],[this.parseNumber("10000000"),this.parseNumber("0.0018")],[this.parseNumber("25000000"),this.parseNumber("0.0015")],[this.parseNumber("50000000"),this.parseNumber("0.00125")],[this.parseNumber("100000000"),this.parseNumber("0.001")]],maker:[[this.parseNumber("0"),this.parseNumber("0.003")],[this.parseNumber("500000"),this.parseNumber("0.0028")],[this.parseNumber("1000000"),this.parseNumber("0.0025")],[this.parseNumber("5000000"),this.parseNumber("0.002")],[this.parseNumber("10000000"),this.parseNumber("0.0018")],[this.parseNumber("25000000"),this.parseNumber("0.0015")],[this.parseNumber("50000000"),this.parseNumber("0.00125")],[this.parseNumber("100000000"),this.parseNumber("0.001")]]}}},headers:{"APCA-PARTNER-ID":"ccxt"},options:{fetchTradesMethod:"cryptoPublicGetCryptoTrades",fetchOHLCVMethod:"cryptoPublicGetCryptoBars",versions:{public:"v2",private:"v2",cryptoPublic:"v1beta2",markets:"v2"},defaultExchange:"CBSE",exchanges:["CBSE","FTX","GNSS","ERSX"],defaultTimeInForce:"gtc",clientOrderId:"ccxt_{id}"},exceptions:{exact:{"forbidden.":U1,4041e4:Rq,40010001:G1,4011e4:U1,4031e4:Lq},broad:{"Invalid format for parameter":G1,"Invalid symbol":Vq}}})}async fetchMarkets(e={}){const t={asset_class:"crypto",tradeable:!0},s=await this.marketsGetAssetsPublicBeta(this.extend(t,e)),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=a.split("/"),d=this.safeString(o,0),c=this.safeString(o,1),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),l=u+"/"+h,m=this.safeString(r,"status")==="active",g=this.safeNumber(r,"min_order_size"),y=this.safeNumber(r,"min_trade_increment"),b=this.safeNumber(r,"price_increment");i.push({id:a,symbol:l,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:void 0,swap:!1,future:!1,option:!1,active:m,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:y,price:b},limits:{leverage:{min:void 0,max:void 0},amount:{min:g,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),a={symbols:n.id};t!==void 0&&(a.start=this.iso8601(t)),s!==void 0&&(a.limit=parseInt(s));const o=this.safeString(this.options,"fetchTradesMethod","cryptoPublicGetCryptoTrades"),d=await this[o](this.extend(a,i)),c=this.safeValue(d,"trades",{}),u=this.safeValue(c,n.id,{});return this.parseTrades(u,n,t,s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n=i.id,r={symbols:n},a=await this.cryptoPublicGetCryptoLatestOrderbooks(this.extend(r,s)),o=this.safeValue(a,"orderbooks",{}),d=this.safeValue(o,n,{}),c=this.parse8601(this.safeString(d,"t"));return this.parseOrderBook(d,i.symbol,c,"b","a","p","s")}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbols:r.id,timeframe:this.timeframes[t]};i!==void 0&&(a.limit=i),s!==void 0&&(a.start=parseInt(s/1e3));const o=this.safeString(this.options,"fetchOHLCVMethod","cryptoPublicGetCryptoBars"),d=await this[o](this.extend(a,n)),c=this.safeValue(d,"bars",{}),u=this.safeValue(c,r.id,{});return this.parseOHLCVs(u,r,t,s,i)}parseOHLCV(e,t=void 0){const s=this.safeString(e,"t");return[this.parse8601(s),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),d={symbol:a.id,qty:this.amountToPrecision(e,i),side:s,type:t},c=this.safeStringN(r,["triggerPrice","stop_price"]);if(c!==void 0){let w;if(t.indexOf("limit")>=0)w="stop_limit";else throw new qq(this.id+" createOrder() does not support stop orders for "+t+" orders, only stop_limit orders are supported");d.stop_price=this.priceToPrecision(e,c),d.type=w}t.indexOf("limit")>=0&&(d.limit_price=this.priceToPrecision(e,n));const u=this.safeString(this.options,"defaultTimeInForce");d.time_in_force=this.safeString(r,"timeInForce",u),r=this.omit(r,["timeInForce","triggerPrice"]);const h=this.safeString(this.options,"clientOrderId"),m=this.uuid().split("-").join(""),g=this.implodeParams(h,{id:m}),y=this.safeString(r,"clientOrderId",g);d.client_order_id=y,r=this.omit(r,["clientOrderId"]);const b=await this.privatePostOrders(this.extend(d,r));return this.parseOrder(b,a)}async cancelOrder(e,t=void 0,s={}){const i={order_id:e},n=await this.privateDeleteOrdersOrderId(this.extend(i,s));return this.safeValue(n,"message",{})}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privateGetOrdersOrderId(this.extend(i,s)),r=this.safeString(n,"symbol"),a=this.safeMarket(r);return this.parseOrder(n,a)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));const r=await this.privateGetOrders(i);return this.parseOrders(r,n,t,s)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeString(e,"status"),r=this.parseOrderStatus(n),a=this.safeString(e,"commission");let o;a!==void 0&&(o={cost:a,currency:"USD"});let d=this.safeString(e,"order_type");d.indexOf("limit")>=0&&(d="limit");const c=this.safeString(e,"submitted_at"),u=this.parse8601(c);return this.safeOrder({id:this.safeString(e,"id"),clientOrderId:this.safeString(e,"client_order_id"),timestamp:u,datetime:c,lastTradeTimeStamp:void 0,status:r,symbol:i,type:d,timeInForce:this.parseTimeInForce(this.safeString(e,"time_in_force")),postOnly:void 0,side:this.safeString(e,"side"),price:this.safeNumber(e,"limit_price"),stopPrice:this.safeNumber(e,"stop_price"),cost:void 0,average:this.safeNumber(e,"filled_avg_price"),amount:this.safeNumber(e,"qty"),filled:this.safeNumber(e,"filled_qty"),remaining:void 0,trades:void 0,fee:o,info:e},t)}parseOrderStatus(e){const t={pending_new:"open",accepted:"open",new:"open",partially_filled:"open",activated:"open",filled:"closed"};return this.safeString(t,e,e)}parseTimeInForce(e){const t={day:"Day"};return this.safeString(t,e,e)}parseTrade(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeString(e,"t"),n=this.parse8601(i),r=this.safeString(e,"tks");let a;r==="B"?a="buy":r==="S"&&(a="sell");const o=this.safeString(e,"p"),d=this.safeString(e,"s");return this.safeTrade({info:e,id:this.safeString(e,"i"),timestamp:n,datetime:this.iso8601(n),symbol:s,order:void 0,type:void 0,side:a,takerOrMaker:"taker",price:o,amount:d,cost:void 0,fee:void 0},t)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.safeValue(this.options,"versions"),o=this.safeString(a,t);let d="/"+this.implodeParams(e,i),c=this.implodeParams(this.urls.api[t],{version:o});c=this.implodeHostname(c),n=n!==void 0?n:{},t==="private"&&(n["APCA-API-KEY-ID"]=this.apiKey,n["APCA-API-SECRET-KEY"]=this.secret);const u=this.omit(i,this.extractParams(e));return Object.keys(u).length&&(s==="GET"||s==="DELETE"?d+="?"+this.urlencode(u):(r=this.json(u),n["Content-Type"]="application/json")),c=c+d,{url:c,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.id+" "+r,u=this.safeString(a,"code");e!==void 0&&this.throwExactlyMatchedException(this.exceptions.exact,u,c);const h=this.safeValue(a,"message",void 0);if(h!==void 0)throw this.throwExactlyMatchedException(this.exceptions.exact,h,c),this.throwBroadlyMatchedException(this.exceptions.broad,h,c),new Eq(c)}};const Hq=me,{ArgumentsRequired:lm,AuthenticationError:of,ExchangeError:zs,InsufficientFunds:pm,InvalidOrder:Ss,BadSymbol:Ta,PermissionDenied:$1,BadRequest:si}=oe,{TICK_SIZE:Gq}=pe,j1=ke;var S_=class extends Hq{describe(){return this.deepExtend(super.describe(),{id:"ascendex",name:"AscendEX",countries:["SG"],rateLimit:400,certified:!1,pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!0,option:!1,addMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:"emulated",fetchFundingRateHistory:!1,fetchFundingRates:!0,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!0,fetchMarginMode:!1,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!1,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,reduceMargin:!0,setLeverage:!0,setMarginMode:!0,setPositionMode:!1,transfer:!0},timeframes:{"1m":"1","5m":"5","15m":"15","30m":"30","1h":"60","2h":"120","4h":"240","6h":"360","12h":"720","1d":"1d","1w":"1w","1M":"1m"},version:"v2",urls:{logo:"https://user-images.githubusercontent.com/1294454/112027508-47984600-8b48-11eb-9e17-d26459cc36c6.jpg",api:{rest:"https://ascendex.com"},test:{rest:"https://api-test.ascendex-sandbox.com"},www:"https://ascendex.com",doc:["https://ascendex.github.io/ascendex-pro-api/#ascendex-pro-api-documentation"],fees:"https://ascendex.com/en/feerate/transactionfee-traderate",referral:{url:"https://ascendex.com/en-us/register?inviteCode=EL6BXBQM",discount:.25}},api:{v1:{public:{get:{assets:1,products:1,ticker:1,"barhist/info":1,barhist:1,depth:1,trades:1,"cash/assets":1,"cash/products":1,"margin/assets":1,"margin/products":1,"futures/collateral":1,"futures/contracts":1,"futures/ref-px":1,"futures/market-data":1,"futures/funding-rates":1,"risk-limit-info":1,"exchange-info":1}},private:{get:{info:1,"wallet/transactions":1,"wallet/deposit/address":1,"data/balance/snapshot":1,"data/balance/history":1},accountCategory:{get:{balance:1,"order/open":1,"order/status":1,"order/hist/current":1,risk:1},post:{order:1,"order/batch":1},delete:{order:1,"order/all":1,"order/batch":1}},accountGroup:{get:{"cash/balance":1,"margin/balance":1,"margin/risk":1,"futures/collateral-balance":1,"futures/position":1,"futures/risk":1,"futures/funding-payments":1,"order/hist":1,"spot/fee":1},post:{transfer:1,"futures/transfer/deposit":1,"futures/transfer/withdraw":1}}}},v2:{public:{get:{assets:1,"futures/contract":1,"futures/collateral":1,"futures/pricing-data":1,"futures/ticker":1}},private:{get:{"account/info":1},accountGroup:{get:{"order/hist":1,"futures/position":1,"futures/free-margin":1,"futures/order/hist/current":1,"futures/order/open":1,"futures/order/status":1},post:{"futures/isolated-position-margin":1,"futures/margin-type":1,"futures/leverage":1,"futures/transfer/deposit":1,"futures/transfer/withdraw":1,"futures/order":1,"futures/order/batch":1,"futures/order/open":1,"subuser/subuser-transfer":1,"subuser/subuser-transfer-hist":1},delete:{"futures/order":1,"futures/order/batch":1,"futures/order/all":1}}}}},fees:{trading:{feeSide:"get",tierBased:!0,percentage:!0,taker:this.parseNumber("0.002"),maker:this.parseNumber("0.002")}},precisionMode:Gq,options:{"account-category":"cash","account-group":void 0,fetchClosedOrders:{method:"v1PrivateAccountGroupGetOrderHist"},defaultType:"spot",accountsByType:{spot:"cash",swap:"futures",future:"futures",margin:"margin"},transfer:{fillResponseFromRequest:!0}},exceptions:{exact:{1900:si,2100:of,5002:Ta,6001:Ta,6010:pm,60060:Ss,600503:Ss,100001:si,100002:si,100003:si,100004:si,100005:si,100006:si,100007:si,100008:Ta,100009:of,100010:si,100011:si,100012:si,100013:si,100101:zs,150001:si,200001:of,200002:zs,200003:zs,200004:zs,200005:zs,200006:zs,200007:zs,200008:zs,200009:zs,200010:of,200011:zs,200012:zs,200013:zs,200014:$1,200015:$1,300001:Ss,300002:Ss,300003:Ss,300004:Ss,300005:Ss,300006:Ss,300007:Ss,300008:Ss,300009:Ss,300011:pm,300012:Ta,300013:Ss,300014:Ss,300020:Ss,300021:Ss,300031:Ss,310001:pm,310002:Ss,310003:Ss,310004:Ta,310005:Ss,510001:zs,900001:zs},broad:{}},commonCurrencies:{BOND:"BONDED",BTCBEAR:"BEAR",BTCBULL:"BULL",BYN:"BeyondFi",PLN:"Pollen"}})}getAccount(e={}){const s=this.safeValue(e,"account",this.options.account).toLowerCase();return this.capitalize(s)}async fetchCurrencies(e={}){const t=await this.v1PublicGetAssets(e),s=await this.v1PublicGetMarginAssets(e),i=await this.v1PublicGetCashAssets(e),n=this.safeValue(t,"data",[]),r=this.safeValue(s,"data",[]),a=this.safeValue(i,"data",[]),o=this.indexBy(n,"assetCode"),d=this.indexBy(r,"assetCode"),c=this.indexBy(a,"assetCode"),u=this.deepExtend(o,d,c),h=Object.keys(u),l={};for(let p=0;p<h.length;p++){const m=h[p],g=u[m],y=this.safeCurrencyCode(m),b=this.safeString2(g,"precisionScale","nativeScale"),w=this.parseNumber(this.parsePrecision(b)),S=this.safeNumber2(g,"withdrawFee","withdrawalFee"),T=this.safeString2(g,"status","statusCode")==="Normal",I="borrowAssetCode"in g;l[y]={id:m,code:y,info:g,type:void 0,margin:I,name:this.safeString(g,"assetName"),active:T,deposit:void 0,withdraw:void 0,fee:S,precision:w,limits:{amount:{min:w,max:void 0},withdraw:{min:this.safeNumber(g,"minWithdrawalAmt"),max:void 0}}}}return l}async fetchMarkets(e={}){const t=await this.v1PublicGetProducts(e),s=await this.v1PublicGetCashProducts(e),i=await this.v2PublicGetFuturesContract(e),n=this.safeValue(t,"data",[]),r=this.indexBy(n,"symbol"),a=this.safeValue(s,"data",[]),o=this.safeValue(i,"data",[]),d=this.arrayConcat(a,o),c=this.indexBy(d,"symbol"),u=this.deepExtend(r,c),h=Object.keys(u),l=[];for(let p=0;p<h.length;p++){const m=h[p],g=u[m];let y=this.safeString(g,"baseAsset"),b=this.safeString(g,"quoteAsset");const w=this.safeValue(g,"settlementAsset");let S=this.safeCurrencyCode(y),k=this.safeCurrencyCode(b);const T=this.safeCurrencyCode(w),I=this.safeString(g,"status"),_=this.safeString(g,"domain");let N=!1;(I==="Normal"||I==="InternalTrading")&&_!=="LeveragedETF"&&(N=!0);const M=T===void 0,x=!M,v=x?!0:void 0;let O=this.safeNumber(g,"minQty"),A=this.safeNumber(g,"maxQty"),V=this.safeNumber(g,"tickSize"),q,R=S+"/"+k;if(x){const P=this.safeValue(g,"lotSizeFilter");O=this.safeNumber(P,"minQty"),A=this.safeNumber(P,"maxQty");const E=this.safeValue(g,"priceFilter");V=this.safeNumber(E,"minPrice"),q=this.safeNumber(E,"maxPrice");const X=this.safeString(g,"underlying").split("/");y=this.safeString(X,0),b=this.safeString(X,1),S=this.safeCurrencyCode(y),k=this.safeCurrencyCode(b),R=S+"/"+k+":"+T}const H=this.safeNumber(g,"commissionReserveRate"),F=this.safeValue(g,"marginTradable",!1);l.push({id:m,symbol:R,base:S,quote:k,settle:T,baseId:y,quoteId:b,settleId:w,type:x?"swap":"spot",spot:M,margin:M?F:void 0,swap:x,future:!1,option:!1,active:N,contract:x,linear:v,inverse:x?!v:void 0,taker:H,maker:H,contractSize:x?this.parseNumber("1"):void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(g,"lotSize"),price:this.safeNumber(g,"tickSize")},limits:{leverage:{min:void 0,max:void 0},amount:{min:O,max:A},price:{min:V,max:q},cost:{min:this.safeNumber(g,"minNotional"),max:this.safeNumber(g,"maxNotional")}},info:g})}return l}async fetchTime(e={}){const t={requestTime:this.milliseconds()},s=await this.v1PublicGetExchangeInfo(this.extend(t,e)),i=this.safeValue(s,"data");return this.safeInteger(i,"requestReceiveAt")}async fetchAccounts(e={}){let t=this.safeString(this.options,"account-group"),s;if(t===void 0){s=await this.v1PrivateGetInfo(e);const i=this.safeValue(s,"data",{});t=this.safeString(i,"accountGroup"),this.options["account-group"]=t}return[{id:t,type:void 0,currency:void 0,info:s}]}parseBalance(e){const t=this.milliseconds(),s={info:e,timestamp:t,datetime:this.iso8601(t)},i=this.safeValue(e,"data",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeCurrencyCode(this.safeString(r,"asset")),o=this.account();o.free=this.safeString(r,"availableBalance"),o.total=this.safeString(r,"totalBalance"),s[a]=o}return this.safeBalance(s)}parseSwapBalance(e){const t=this.milliseconds(),s={info:e,timestamp:t,datetime:this.iso8601(t)},i=this.safeValue(e,"data",{}),n=this.safeValue(i,"collaterals",[]);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeCurrencyCode(this.safeString(a,"asset")),d=this.account();d.total=this.safeString(a,"balance"),s[o]=d}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets(),await this.loadAccounts();const[t,s]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),i=this.safeValue(this.options,"fetchBalance",{}),n=this.safeValue(this.options,"accountsByType",{}),r=this.safeString(n,t,"cash"),a=this.safeValue(this.accounts,0,{}),d={"account-group":this.safeString(a,"id")},c=this.safeString(i,"method","v1PrivateAccountCategoryGetBalance"),u=this.getSupportedMapping(t,{spot:c,margin:c,swap:"v2PrivateAccountGroupGetFuturesPosition"});(r==="cash"||r==="margin")&&(d["account-category"]=r);const h=await this[u](this.extend(d,s));return t==="swap"?this.parseSwapBalance(h):this.parseBalance(h)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={symbol:this.market(e).id},r=await this.v1PublicGetDepth(this.extend(n,s)),a=this.safeValue(r,"data",{}),o=this.safeValue(a,"data",{}),d=this.safeInteger(o,"ts"),c=this.parseOrderBook(o,e,d);return c.nonce=this.safeInteger(o,"seqnum"),c}parseTicker(e,t=void 0){const i=this.safeString(e,"symbol"),r=this.safeString(e,"type")==="spot"?"/":void 0,a=this.safeSymbol(i,t,r),o=this.safeString(e,"close"),d=this.safeValue(e,"bid",[]),c=this.safeValue(e,"ask",[]),u=this.safeString(e,"open");return this.safeTicker({symbol:a,timestamp:void 0,datetime:void 0,high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(d,0),bidVolume:this.safeString(d,1),ask:this.safeString(c,0),askVolume:this.safeString(c,1),vwap:void 0,open:u,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.v1PublicGetTicker(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};let i;if(e!==void 0){const o=this.safeValue(e,0);i=this.market(o);const d=this.marketIds(e);s.symbol=d.join(",")}let n;[n,t]=this.handleMarketTypeAndParams("fetchTickers",i,t);let r;n==="spot"?r=await this.v1PublicGetTicker(this.extend(s,t)):r=await this.v2PublicGetFuturesTicker(this.extend(s,t));const a=this.safeValue(r,"data",[]);return Array.isArray(a)?this.parseTickers(a,e):this.parseTickers([a],e)}parseOHLCV(e,t=void 0){const s=this.safeValue(e,"data",{});return[this.safeInteger(s,"ts"),this.safeNumber(s,"o"),this.safeNumber(s,"h"),this.safeNumber(s,"l"),this.safeNumber(s,"c"),this.safeNumber(s,"v")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,interval:this.timeframes[t]},o=this.parseTimeframe(t),d=this.safeValue(this.options,"fetchOHLCV",{}),c=this.safeInteger(d,"limit",500);s!==void 0?(a.from=s,i===void 0?i=c:i=Math.min(i,c),a.to=this.sum(s,i*o*1e3,1)):i!==void 0&&(a.n=i);const u=await this.v1PublicGetBarhist(this.extend(a,n)),h=this.safeValue(u,"data",[]);return this.parseOHLCVs(h,r,t,s,i)}parseTrade(e,t=void 0){const s=this.safeInteger(e,"ts"),i=this.safeString2(e,"price","p"),n=this.safeString(e,"q"),r=this.safeValue(e,"bm",!1),a=r?"maker":"taker",o=r?"buy":"sell";return t=this.safeMarket(void 0,t),this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,id:void 0,order:void 0,type:void 0,takerOrMaker:a,side:o,price:i,amount:n,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.n=s);const a=await this.v1PublicGetTrades(this.extend(r,i)),o=this.safeValue(a,"data",[]),d=this.safeValue(o,"data",[]);return this.parseTrades(d,n,t,s)}parseOrderStatus(e){const t={PendingNew:"open",New:"open",PartiallyFilled:"open",Filled:"closed",Canceled:"canceled",Rejected:"rejected"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString(e,"status")),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t,"/");let r=this.safeInteger2(e,"timestamp","sendingTime");const a=this.safeInteger(e,"lastExecTime");r===void 0&&(r=a);const o=this.safeString(e,"price"),d=this.safeString(e,"orderQty"),c=this.safeString(e,"avgPx"),u=this.safeString2(e,"cumFilledQty","cumQty"),h=this.safeString(e,"orderId");let l=this.safeString(e,"id");l!==void 0&&l.length<1&&(l=void 0);const p=this.safeStringLower(e,"orderType");let m=p;p!==void 0&&(p==="stoplimit"&&(m="limit"),p==="stopmarket"&&(m="market"));const g=this.safeStringLower(e,"side"),y=this.safeNumber(e,"cumFee");let b;if(y!==void 0){const I=this.safeString(e,"feeAsset"),_=this.safeCurrencyCode(I);b={cost:y,currency:_}}const w=this.safeNumber(e,"stopPrice");let S;const k=this.safeString(e,"execInst");k==="reduceOnly"&&(S=!0);let T;return k==="Post"&&(T=!0),this.safeOrder({info:e,id:h,clientOrderId:l,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:a,symbol:n,type:m,timeInForce:void 0,postOnly:T,reduceOnly:S,side:g,price:o,stopPrice:w,amount:d,cost:void 0,average:c,filled:u,remaining:void 0,status:s,fee:b,trades:void 0},t)}async fetchTradingFees(e={}){await this.loadMarkets(),await this.loadAccounts();const t=this.safeValue(this.accounts,0,{}),i={"account-group":this.safeString(t,"id")},n=await this.v1PrivateAccountGroupGetSpotFee(this.extend(i,e)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"fees",[]),o={};for(let d=0;d<a.length;d++){const c=a[d],u=this.safeString(c,"symbol"),h=this.safeSymbol(u,void 0,"/"),l=this.safeValue(c,"fee",{});o[h]={info:c,symbol:h,maker:this.safeNumber(l,"maker"),taker:this.safeNumber(l,"taker")}}return o}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets(),await this.loadAccounts();const a=this.market(e);let o;[o,r]=this.handleMarketTypeAndParams("createOrder",a,r);const d=this.safeValue(this.options,"createOrder",{}),c=this.safeValue(this.options,"accountsByType",{}),u=this.safeString(c,o,"cash"),h=this.safeValue(this.accounts,0,{}),l=this.safeValue(h,"id"),p=this.safeString2(r,"clientOrderId","id"),m={"account-group":l,"account-category":u,symbol:a.id,time:this.milliseconds(),orderQty:this.amountToPrecision(e,i),orderType:t,side:s},g=t==="market"||t==="stop_market",y=t==="limit"||t==="stop_limit",b=this.safeString(r,"timeInForce"),w=this.isPostOnly(g,!1,r),S=this.safeValue(r,"reduceOnly",!1),k=this.safeValue2(r,"triggerPrice","stopPrice");if(r=this.omit(r,["timeInForce","postOnly","reduceOnly","stopPrice","triggerPrice"]),S){if(o!=="swap")throw new Ss(this.id+" createOrder() does not support reduceOnly for "+o+" orders, reduceOnly orders are supported for perpetuals only");m.execInst="ReduceOnly"}y&&(m.orderPrice=this.priceToPrecision(e,n)),b==="IOC"&&(m.timeInForce="IOC"),b==="FOK"&&(m.timeInForce="FOK"),w&&(m.postOnly=!0),k!==void 0&&(m.stopPrice=this.priceToPrecision(e,k),y?m.orderType="stop_limit":g&&(m.orderType="stop_market")),p!==void 0&&(m.id=p);const T=this.safeString(d,"method","v1PrivateAccountCategoryPostOrder"),I=this.getSupportedMapping(o,{spot:T,margin:T,swap:"v2PrivateAccountGroupPostFuturesOrder"});I==="v1PrivateAccountCategoryPostOrder"?u!==void 0&&(m.category=u):m["account-category"]=u;const _=await this[I](this.extend(m,r)),N=this.safeValue(_,"data",{}),M=this.safeValue2(N,"order","info",{});return this.parseOrder(M,a)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets(),await this.loadAccounts();let i;t!==void 0&&(i=this.market(t));const[n,r]=this.handleMarketTypeAndParams("fetchOrder",i,s),a=this.safeValue(this.options,"fetchOrder",{}),o=this.safeValue(this.options,"accountsByType",{}),d=this.safeString(o,n,"cash"),c=this.safeValue(this.accounts,0,{}),h={"account-group":this.safeValue(c,"id"),"account-category":d,orderId:e},l=this.safeString(a,"method","v1PrivateAccountCategoryGetOrderStatus"),p=this.getSupportedMapping(n,{spot:l,margin:l,swap:"v2PrivateAccountGroupGetFuturesOrderStatus"});p==="v1PrivateAccountCategoryGetOrderStatus"?d!==void 0&&(h.category=d):h["account-category"]=d;const m=await this[p](this.extend(h,r)),g=this.safeValue(m,"data",{});return this.parseOrder(g,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.loadAccounts();let n;e!==void 0&&(n=this.market(e),e=n.symbol);const r=this.safeValue(this.accounts,0,{}),a=this.safeValue(r,"id"),[o,d]=this.handleMarketTypeAndParams("fetchOpenOrders",n,i),c=this.safeValue(this.options,"accountsByType",{}),u=this.safeString(c,o,"cash"),h={"account-group":a,"account-category":u},l=this.safeValue(this.options,"fetchOpenOrders",{}),p=this.safeString(l,"method","v1PrivateAccountCategoryGetOrderOpen"),m=this.getSupportedMapping(o,{spot:p,margin:p,swap:"v2PrivateAccountGroupGetFuturesOrderOpen"});m==="v1PrivateAccountCategoryGetOrderOpen"?u!==void 0&&(h.category=u):h["account-category"]=u;const g=await this[m](this.extend(h,d)),y=this.safeValue(g,"data",[]);if(u==="futures")return this.parseOrders(y,n,t,s);const b=[];for(let w=0;w<y.length;w++){const S=this.parseOrder(y[w],n);b.push(S)}return this.filterBySymbolSinceLimit(b,e,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.loadAccounts();const n=this.safeValue(this.accounts,0,{}),a={"account-group":this.safeValue(n,"id")};let o;e!==void 0&&(o=this.market(e),a.symbol=o.id);const[d,c]=this.handleMarketTypeAndParams("fetchClosedOrders",o,i),u=this.safeValue(this.options,"fetchClosedOrders",{}),h=this.safeString(u,"method","v1PrivateAccountGroupGetOrderHist"),l=this.getSupportedMapping(d,{spot:h,margin:h,swap:"v2PrivateAccountGroupGetFuturesOrderHistCurrent"}),p=this.safeValue(this.options,"accountsByType",{}),m=this.safeString(p,d,"cash");l==="v1PrivateAccountGroupGetOrderHist"?m!==void 0&&(a.category=m):a["account-category"]=m,t!==void 0&&(a.startTime=t),s!==void 0&&(a.pageSize=s);const g=await this[l](this.extend(a,c));let y=this.safeValue(g,"data");return Array.isArray(y)||(y=this.safeValue(y,"data",[])),this.parseOrders(y,o,t,s)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new lm(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets(),await this.loadAccounts();const i=this.market(t),[n,r]=this.handleMarketTypeAndParams("cancelOrder",i,s),a=this.safeValue(this.options,"cancelOrder",{}),o=this.safeValue(this.options,"accountsByType",{}),d=this.safeString(o,n,"cash"),c=this.safeValue(this.accounts,0,{}),h={"account-group":this.safeValue(c,"id"),"account-category":d,symbol:i.id,time:this.milliseconds(),id:"foobar"},l=this.safeString(a,"method","v1PrivateAccountCategoryDeleteOrder"),p=this.getSupportedMapping(n,{spot:l,margin:l,swap:"v2PrivateAccountGroupDeleteFuturesOrder"});p==="v1PrivateAccountCategoryDeleteOrder"?d!==void 0&&(h.category=d):h["account-category"]=d;const m=this.safeString2(s,"clientOrderId","id");m===void 0?h.orderId=e:(h.id=m,s=this.omit(s,["clientOrderId","id"]));const g=await this[p](this.extend(h,r)),y=this.safeValue(g,"data",{}),b=this.safeValue2(y,"order","info",{});return this.parseOrder(b,i)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets(),await this.loadAccounts();let s;e!==void 0&&(s=this.market(e));const[i,n]=this.handleMarketTypeAndParams("cancelAllOrders",s,t),r=this.safeValue(this.options,"cancelAllOrders",{}),a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,i,"cash"),d=this.safeValue(this.accounts,0,{}),u={"account-group":this.safeValue(d,"id"),"account-category":o,time:this.milliseconds()};e!==void 0&&(u.symbol=s.id);const h=this.safeString(r,"method","v1PrivateAccountCategoryDeleteOrderAll"),l=this.getSupportedMapping(i,{spot:h,margin:h,swap:"v2PrivateAccountGroupDeleteFuturesOrderAll"});return l==="v1PrivateAccountCategoryDeleteOrderAll"?o!==void 0&&(u.category=o):u["account-category"]=o,await this[l](this.extend(u,n))}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"tagId"),n=this.safeString(e,i);this.checkAddress(s);const r=t===void 0?void 0:t.code,a=this.safeString(e,"chainName"),o=this.safeNetwork(a);return{currency:r,address:s,tag:n,network:o,info:e}}safeNetwork(e){const t={TRC20:"TRC20",ERC20:"ERC20",GO20:"GO20",BEP2:"BEP2","BEP20 (BSC)":"BEP20",Bitcoin:"BTC","Bitcoin ABC":"BCH",Litecoin:"LTC","Matic Network":"MATIC",Solana:"SOL",xDai:"STAKE",Akash:"AKT"};return this.safeString(t,e,e)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i=this.safeString(t,"chainName");t=this.omit(t,"chainName");const n={asset:s.id},r=await this.v1PrivateGetWalletDepositAddress(this.extend(n,t)),a=this.safeValue(r,"data",{}),o=this.safeValue(a,"address",[]),d=o.length;let c;if(d>1){const h=this.indexBy(o,"chainName");if(i===void 0){const p=Object.keys(h).join(", ");throw new lm(this.id+" fetchDepositAddress() returned more than one address, a chainName parameter is required, one of "+p)}c=this.safeValue(h,i,{})}else c=this.safeValue(o,0,{});const u=this.parseDepositAddress(c,s);return this.extend(u,{info:r})}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){const n={txType:"deposit"};return await this.fetchTransactions(e,t,s,this.extend(n,i))}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const n={txType:"withdrawal"};return await this.fetchTransactions(e,t,s,this.extend(n,i))}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.asset=r.id),t!==void 0&&(n.startTs=t),s!==void 0&&(n.pageSize=s);const a=await this.v1PrivateGetWalletTransactions(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"data",[]);return this.parseTransactions(d,r,t,s)}parseTransactionStatus(e){const t={reviewing:"pending",pending:"pending",confirmed:"ok",rejected:"rejected"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"requestId"),i=this.safeNumber(e,"amount"),n=this.safeValue(e,"destAddress",{}),r=this.safeString(n,"address"),a=this.safeString(n,"destTag"),o=this.safeString(e,"networkTransactionId"),d=this.safeString(e,"transactionType"),c=this.safeInteger(e,"time"),u=this.safeString(e,"asset"),h=this.safeCurrencyCode(u,t),l=this.parseTransactionStatus(this.safeString(e,"status")),p=this.safeNumber(e,"commission");return{info:e,id:s,currency:h,amount:i,network:void 0,address:r,addressTo:r,addressFrom:void 0,tag:a,tagTo:a,tagFrom:void 0,status:l,type:d,updated:void 0,txid:o,timestamp:c,datetime:this.iso8601(c),fee:{currency:h,cost:p}}}async fetchPositions(e=void 0,t={}){await this.loadMarkets(),await this.loadAccounts();const s=this.safeValue(this.accounts,0,{}),n={"account-group":this.safeString(s,"id")},r=await this.v2PrivateAccountGroupGetFuturesPosition(this.extend(n,t)),a=this.safeValue(r,"data",{}),o=this.safeValue(a,"contracts",[]),d=[];for(let c=0;c<o.length;c++)d.push(this.parsePosition(o[c]));return e=this.marketSymbols(e),this.filterByArray(d,"symbol",e,!1)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);let i=this.safeNumber(e,"buyOpenOrderNotional");i===0&&(i=this.safeNumber(e,"sellOpenOrderNotional"));const n=this.safeString(e,"marginType");let r;return n==="isolated"&&(r=this.safeNumber(e,"isolatedMargin")),{info:e,id:void 0,symbol:t.symbol,notional:i,marginMode:n,liquidationPrice:void 0,entryPrice:this.safeNumber(e,"avgOpenPrice"),unrealizedPnl:this.safeNumber(e,"unrealizedPnl"),percentage:void 0,contracts:this.safeNumber(e,"position"),contractSize:this.safeNumber(t,"contractSize"),markPrice:this.safeNumber(e,"markPrice"),side:this.safeStringLower(e,"side"),hedged:void 0,timestamp:void 0,datetime:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,collateral:r,initialMargin:void 0,initialMarginPercentage:void 0,leverage:this.safeInteger(e,"leverage"),marginRatio:void 0}}parseFundingRate(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeInteger(e,"time"),r=this.safeNumber(e,"fundingRate"),a=this.safeInteger(e,"nextFundingTime");return{info:e,symbol:i,markPrice:this.safeNumber(e,"markPrice"),indexPrice:this.safeNumber(e,"indexPrice"),interestRate:this.parseNumber("0"),estimatedSettlePrice:void 0,timestamp:n,datetime:this.iso8601(n),previousFundingRate:void 0,nextFundingRate:void 0,previousFundingTimestamp:void 0,nextFundingTimestamp:void 0,previousFundingDatetime:void 0,nextFundingDatetime:void 0,fundingRate:r,fundingTimestamp:a,fundingDatetime:this.iso8601(a)}}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.v2PublicGetFuturesPricingData(t),i=this.safeValue(s,"data",{}),n=this.safeValue(i,"contracts",[]),r=this.parseFundingRates(n);return this.filterByArray(r,"symbol",e)}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets(),await this.loadAccounts();const n=this.market(e),r=this.safeValue(this.accounts,0,{}),a=this.safeString(r,"id");t=this.amountToPrecision(e,t);const o={"account-group":a,symbol:n.id,amount:t},d=await this.v2PrivateAccountGroupPostFuturesIsolatedPositionMargin(this.extend(o,i));return s==="reduce"&&(t=j1.stringAbs(t)),this.extend(this.parseMarginModification(d,n),{amount:this.parseNumber(t),type:s})}parseMarginModification(e,t=void 0){const i=this.safeString(e,"code")==="0"?"ok":"failed";return{info:e,type:void 0,amount:void 0,code:t.quote,symbol:t.symbol,status:i}}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"reduce",s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"add",s)}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new lm(this.id+" setLeverage() requires a symbol argument");if(e<1||e>100)throw new si(this.id+" leverage should be between 1 and 100");await this.loadMarkets(),await this.loadAccounts();const i=this.market(t);if(i.type!=="future")throw new Ta(this.id+" setLeverage() supports futures contracts only");const n=this.safeValue(this.accounts,0,{}),a={"account-group":this.safeString(n,"id"),symbol:i.id,leverage:e};return await this.v2PrivateAccountGroupPostFuturesLeverage(this.extend(a,s))}async setMarginMode(e,t=void 0,s={}){if(e=e.toLowerCase(),e==="cross"&&(e="crossed"),e!=="isolated"&&e!=="crossed")throw new si(this.id+" setMarginMode() marginMode argument should be isolated or cross");await this.loadMarkets(),await this.loadAccounts();const i=this.market(t),n=this.safeValue(this.accounts,0,{}),a={"account-group":this.safeString(n,"id"),symbol:i.id,marginMode:e};if(i.type!=="future")throw new Ta(this.id+" setMarginMode() supports futures contracts only");return await this.v2PrivateAccountGroupPostFuturesMarginType(this.extend(a,s))}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const s=await this.v2PublicGetFuturesContract(t),i=this.safeValue(s,"data");return e=this.marketSymbols(e),this.parseLeverageTiers(i,e,"symbol")}parseMarketLeverageTiers(e,t=void 0){const s=this.safeValue(e,"marginRequirements",[]),i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const n=[];for(let r=0;r<s.length;r++){const a=s[r],o=this.safeString(a,"initialMarginRate");n.push({tier:this.sum(r,1),currency:t.quote,minNotional:this.safeNumber(a,"positionNotionalLowerBound"),maxNotional:this.safeNumber(a,"positionNotionalUpperBound"),maintenanceMarginRate:this.safeNumber(a,"maintenanceMarginRate"),maxLeverage:this.parseNumber(j1.stringDiv("1",o)),info:a})}return n}async transfer(e,t,s,i,n={}){await this.loadMarkets(),await this.loadAccounts();const r=this.safeValue(this.accounts,0,{}),a=this.safeString(r,"id"),o=this.currency(e);t=this.currencyToPrecision(e,t);const d=this.safeValue(this.options,"accountsByType",{}),c=this.safeString(d,s,s),u=this.safeString(d,i,i);if(c!=="cash"&&u!=="cash")throw new zs(this.id+" transfer() only supports direct balance transfer between spot and future, spot and margin");const h={"account-group":a,amount:t,asset:o.id,fromAccount:c,toAccount:u},l=await this.v1PrivateAccountGroupPostTransfer(this.extend(h,n)),p=this.safeValue(this.options,"transfer",{}),m=this.safeValue(p,"fillResponseFromRequest",!0),g=this.parseTransfer(l,o);return m&&(g.fromAccount=s,g.toAccount=i,g.amount=t,g.currency=e),g}parseTransfer(e,t=void 0){const s=this.safeInteger(e,"code"),i=this.safeCurrencyCode(void 0,t),n=this.milliseconds();return{info:e,id:void 0,timestamp:n,datetime:this.iso8601(n),currency:i,amount:void 0,fromAccount:void 0,toAccount:void 0,status:this.parseTransferStatus(s)}}parseTransferStatus(e){return e===0?"ok":"failed"}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=t[0],o=t[1],d=this.safeString(t,2);let c="";const u=d==="accountCategory";(u||d==="accountGroup")&&(c+=this.implodeParams("/{account-group}",i),i=this.omit(i,"account-group"));let h=this.implodeParams(e,i);if(c+="/api/pro/",a==="v2"?h=a+"/"+h:c+=a+"/",u&&(c+=this.implodeParams("{account-category}/",i)),i=this.omit(i,"account-category"),c+=h,(a==="v1"&&h==="cash/balance"||h==="margin/balance")&&(h="balance"),a==="v1"&&h==="spot/fee"&&(h="fee"),h.indexOf("subuser")>=0&&(h=h.split("/")[2]),i=this.omit(i,this.extractParams(e)),o==="public")Object.keys(i).length&&(c+="?"+this.urlencode(i));else{this.checkRequiredCredentials();const l=this.milliseconds().toString(),p=l+"+"+h,m=this.hmac(this.encode(p),this.encode(this.secret),"sha256","base64");n={"x-auth-key":this.apiKey,"x-auth-timestamp":l,"x-auth-signature":m},s==="GET"?Object.keys(i).length&&(c+="?"+this.urlencode(i)):(n["Content-Type"]="application/json",r=this.json(i))}return c=this.urls.api.rest+c,{url:c,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"code"),u=this.safeString(a,"message");if(c!==void 0&&c!=="0"||u!==void 0){const l=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,l),this.throwExactlyMatchedException(this.exceptions.exact,u,l),this.throwBroadlyMatchedException(this.exceptions.broad,u,l),new zs(l)}}};const Uq=me,{BadSymbol:W1,PermissionDenied:$q,ExchangeError:jd,ExchangeNotAvailable:jq,OrderNotFound:mm,InsufficientFunds:Wq,InvalidOrder:ko,RequestTimeout:zq,AuthenticationError:Kq}=oe,{TRUNCATE:Xq,TICK_SIZE:z1}=pe,Yq=ke;var Dl=class extends Uq{describe(){return this.deepExtend(super.describe(),{id:"hitbtc",name:"HitBTC",countries:["HK"],rateLimit:3.333,version:"2",pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,createReduceOnlyOrder:!1,editOrder:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:void 0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:void 0,fetchOrderTrades:!0,fetchPosition:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactions:!0,fetchWithdrawals:void 0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"M1","3m":"M3","5m":"M5","15m":"M15","30m":"M30","1h":"H1","4h":"H4","1d":"D1","1w":"D7","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766555-8eaec20e-5edc-11e7-9c5b-6dc69fc42f5e.jpg",test:{public:"https://api.demo.hitbtc.com",private:"https://api.demo.hitbtc.com"},api:{public:"https://api.hitbtc.com",private:"https://api.hitbtc.com"},www:"https://hitbtc.com",referral:"https://hitbtc.com/?ref_id=5a5d39a65d466",doc:["https://api.hitbtc.com/v2"],fees:["https://hitbtc.com/fees-and-limits","https://support.hitbtc.com/hc/en-us/articles/115005148605-Fees-and-limits"]},api:{public:{get:{currency:3,"currency/{currency}":3,symbol:3,"symbol/{symbol}":3,ticker:3,"ticker/{symbol}":3,trades:3,"trades/{symbol}":3,orderbook:3,"orderbook/{symbol}":3,candles:3,"candles/{symbol}":3}},private:{get:{"trading/balance":15.0015,order:15.0015,"order/{clientOrderId}":15.0015,"trading/fee/all":15.0015,"trading/fee/{symbol}":15.0015,"margin/account":15.0015,"margin/account/{symbol}":15.0015,"margin/position":15.0015,"margin/position/{symbol}":15.0015,"margin/order":15.0015,"margin/order/{clientOrderId}":15.0015,"history/order":15.0015,"history/trades":15.0015,"history/order/{orderId}/trades":15.0015,"account/balance":15.0015,"account/crypto/address/{currency}":15.0015,"account/crypto/addresses/{currency}":15.0015,"account/crypto/used-addresses/{currency}":15.0015,"account/crypto/estimate-withdraw":15.0015,"account/crypto/is-mine/{address}":15.0015,"account/transactions":15.0015,"account/transactions/{id}":15.0015,"sub-acc":15.0015,"sub-acc/acl":15.0015,"sub-acc/balance/{subAccountUserID}":15.0015,"sub-acc/deposit-address/{subAccountUserId}/{currency}":15.0015},post:{order:1,"margin/order":1,"account/crypto/address/{currency}":1,"account/crypto/withdraw":1,"account/crypto/transfer-convert":1,"account/transfer":1,"account/transfer/internal":1,"sub-acc/freeze":1,"sub-acc/activate":1,"sub-acc/transfer":1},put:{"order/{clientOrderId}":1,"margin/account/{symbol}":1,"margin/order/{clientOrderId}":1,"account/crypto/withdraw/{id}":1,"sub-acc/acl/{subAccountUserId}":1},delete:{order:1,"order/{clientOrderId}":1,"margin/account":1,"margin/account/{symbol}":1,"margin/position":1,"margin/position/{symbol}":1,"margin/order":1,"margin/order/{clientOrderId}":1,"account/crypto/withdraw/{id}":1},patch:{"order/{clientOrderId}":1}}},precisionMode:z1,fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.002")}},options:{networks:{ETH:"T20",ERC20:"T20",TRX:"TTRX",TRC20:"TTRX",OMNI:""},defaultTimeInForce:"FOK",accountsByType:{funding:"bank",spot:"exchange"},fetchBalanceMethod:{account:"account",bank:"account",main:"account",funding:"account",exchange:"trading",spot:"trading",trade:"trading",trading:"trading"}},commonCurrencies:{AUTO:"Cube",BCC:"BCC",BDP:"BidiPass",BET:"DAO.Casino",BIT:"BitRewards",BOX:"BOX Token",CPT:"Cryptaur",GET:"Themis",GMT:"GMT Token",HSR:"HC",IQ:"IQ.Cash",LNC:"LinkerCoin",PLA:"PlayChip",PNT:"Penta",SBTC:"Super Bitcoin",STEPN:"GMT",STX:"STOX",TV:"Tokenville",USD:"USDT",XMT:"MTL",XPNT:"PNT"},exceptions:{504:zq,1002:Kq,1003:$q,2010:ko,2001:W1,2011:ko,2020:ko,20002:mm,20001:Wq,20010:W1,20045:ko}})}feeToPrecision(e,t){return this.decimalToPrecision(t,Xq,1e-8,z1)}async fetchMarkets(e={}){const t=await this.publicGetSymbol(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"id"),a=this.safeString(n,"baseCurrency"),o=this.safeString(n,"quoteCurrency"),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o);let u=d+"/"+c;r.indexOf("_")>=0&&(u=r);const h=this.safeString(n,"quantityIncrement"),l=this.safeString(n,"tickSize"),p=this.parseNumber(h),m=this.parseNumber(l),g=this.safeString(n,"feeCurrency");s.push(this.extend(this.fees.trading,{id:r,symbol:u,base:d,quote:c,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(n,"takeLiquidityRate"),maker:this.safeNumber(n,"provideLiquidityRate"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,feeCurrency:this.safeCurrencyCode(g),precision:{amount:p,price:m},limits:{leverage:{min:void 0,max:void 0},amount:{min:p,max:void 0},price:{min:m,max:void 0},cost:{min:this.parseNumber(Yq.stringMul(h,l)),max:void 0}},info:n}))}return s}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.currencyToPrecision(e,t),o={currency:r.id,amount:a};let d=this.safeString(n,"type");if(d===void 0){const h=this.safeValue(this.options,"accountsByType",{}),l=this.safeString(h,s,s),p=this.safeString(h,i,i);if(l===p)throw new jd(this.id+" transfer() from and to cannot be the same account");d=l+"To"+this.capitalize(p)}o.type=d;const c=await this.privatePostAccountTransfer(this.extend(o,n)),u=this.parseTransfer(c,r);return this.extend(u,{fromAccount:s,toAccount:i,amount:this.parseNumber(a)})}parseTransfer(e,t=void 0){const s=this.milliseconds();return{id:this.safeString(e,"id"),timestamp:s,datetime:this.iso8601(s),currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0,info:e}}async fetchCurrencies(e={}){const t=await this.publicGetCurrency(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"id"),a=this.safeString(n,"precisionTransfer","8"),o=this.safeCurrencyCode(r),d=this.safeValue(n,"payinEnabled"),c=this.safeValue(n,"payoutEnabled"),u=this.safeValue(n,"transferEnabled");let h=d&&c&&u;"disabled"in n&&n.disabled&&(h=!1);let l="fiat";"crypto"in n&&n.crypto&&(l="crypto");const p=this.safeString(n,"fullName");s[o]={id:r,code:o,type:l,payin:d,payout:c,transfer:u,info:n,name:p,active:h,deposit:d,withdraw:c,fee:this.safeNumber(n,"payoutFee"),precision:this.parseNumber(this.parsePrecision(a)),limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}}}return s}parseTradingFee(e,t=void 0){return{info:e,symbol:this.safeSymbol(void 0,t),maker:this.safeNumber(e,"provideLiquidityRate"),taker:this.safeNumber(e,"takeLiquidityRate"),percentage:!0,tierBased:!0}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.privateGetTradingFeeSymbol(i);return this.parseTradingFee(n,s)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"available"),a.used=this.safeString(i,"reserved"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"type","trading"),s=this.safeValue(this.options,"fetchBalanceMethod",{}),i=this.safeString(s,t);if(i===void 0)throw new jd(this.id+" fetchBalance() account type must be either main or trading");const n="privateGet"+this.capitalize(i)+"Balance",r=this.omit(e,"type"),a=await this[n](r);return this.parseBalance(a)}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"timestamp")),this.safeNumber(e,"open"),this.safeNumber(e,"max"),this.safeNumber(e,"min"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,period:this.timeframes[t]};s!==void 0&&(a.from=this.iso8601(s)),i!==void 0&&(a.limit=i);const o=await this.publicGetCandlesSymbol(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetOrderbookSymbol(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"bid","ask","price","size")}parseTicker(e,t=void 0){const s=this.parse8601(e.timestamp),i=this.safeSymbol(void 0,t),n=this.safeString(e,"volume"),r=this.safeString(e,"volumeQuote"),a=this.safeString(e,"open"),o=this.safeString(e,"last");return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:a,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:n,quoteVolume:r,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTicker(t),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeMarket(a),d=o.symbol;i[d]=this.parseTicker(r,o)}return this.filterByArray(i,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetTickerSymbol(this.extend(i,t));if("message"in n)throw new jd(this.id+" "+n.message);return this.parseTicker(n,s)}parseTrade(e,t=void 0){const s=this.parse8601(e.timestamp),i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const n=t.symbol;let r;const a=this.safeString(e,"fee");if(a!==void 0){const l=t?t.feeCurrency:void 0;r={cost:a,currency:l}}const o=this.safeString(e,"clientOrderId"),d=this.safeString(e,"price"),c=this.safeString(e,"quantity"),u=this.safeString(e,"side"),h=this.safeString(e,"id");return this.safeTrade({info:e,id:h,order:o,timestamp:s,datetime:this.iso8601(s),symbol:n,type:void 0,side:u,takerOrMaker:void 0,price:d,amount:c,cost:void 0,fee:r},t)}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.asset=n.id),t!==void 0&&(r.startTime=t);const a=await this.privateGetAccountTransactions(this.extend(r,i));return this.parseTransactions(a,n,t,s)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.parse8601(this.safeString(e,"createdAt")),n=this.parse8601(this.safeString(e,"updatedAt")),r=this.safeString(e,"currency"),a=this.safeCurrencyCode(r,t),o=this.parseTransactionStatus(this.safeString(e,"status")),d=this.safeNumber(e,"amount"),c=this.safeString(e,"address"),u=this.safeString(e,"hash");let h;const l=this.safeNumber(e,"fee");l!==void 0&&(h={cost:l,currency:a});const p=this.parseTransactionType(this.safeString(e,"type"));return{info:e,id:s,txid:u,timestamp:i,datetime:this.iso8601(i),network:void 0,address:c,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:p,amount:d,currency:a,status:o,updated:n,fee:h}}parseTransactionStatus(e){const t={pending:"pending",failed:"failed",success:"ok"};return this.safeString(t,e,e)}parseTransactionType(e){const t={payin:"deposit",payout:"withdrawal",withdraw:"withdrawal"};return this.safeString(t,e,e)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s),t!==void 0&&(r.sort="ASC",r.from=this.iso8601(t));const a=await this.publicGetTradesSymbol(this.extend(r,i));return this.parseTrades(a,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);let c=this.uuid().split("-").join("");c=c.slice(0,32),i=parseFloat(i);const u={clientOrderId:c,symbol:a.id,side:s,quantity:this.amountToPrecision(e,i),type:t};t==="limit"?u.price=this.priceToPrecision(e,n):u.timeInForce=this.options.defaultTimeInForce;const h=await this.privatePostOrder(this.extend(u,r)),l=this.parseOrder(h);if(l.status==="rejected")throw new ko(this.id+" order was rejected by the exchange "+this.json(l));return l}async editOrder(e,t,s,i,n=void 0,r=void 0,a={}){await this.loadMarkets();let c=this.uuid().split("-").join("");c=c.slice(0,32);const u={clientOrderId:e,requestClientId:c};n!==void 0&&(u.quantity=this.amountToPrecision(t,n)),r!==void 0&&(u.price=this.priceToPrecision(t,r));const h=await this.privatePatchOrderClientOrderId(this.extend(u,a));return this.parseOrder(h)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={clientOrderId:e},n=await this.privateDeleteOrderClientOrderId(this.extend(i,s));return this.parseOrder(n)}parseOrderStatus(e){const t={new:"open",suspended:"open",partiallyFilled:"open",filled:"closed",canceled:"canceled",expired:"failed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parse8601(this.safeString(e,"createdAt")),i=this.parse8601(this.safeString(e,"updatedAt")),n=this.safeString(e,"symbol");t=this.safeMarket(n,t);const r=t.symbol,a=this.safeString(e,"quantity"),o=this.safeString(e,"cumQuantity"),d=this.parseOrderStatus(this.safeString(e,"status")),c=this.safeString(e,"clientOrderId"),u=c,h=this.safeString(e,"price"),l=this.safeString(e,"type"),p=this.safeString(e,"side"),m=this.safeValue(e,"tradesReport"),g=void 0,y=this.safeString(e,"avgPrice"),b=this.safeString(e,"timeInForce");return this.safeOrder({id:c,clientOrderId:u,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:i,status:d,symbol:r,type:l,timeInForce:b,side:p,price:h,stopPrice:void 0,average:y,amount:a,cost:void 0,filled:o,remaining:void 0,fee:g,trades:m,info:e},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={clientOrderId:e},n=await this.privateGetHistoryOrder(this.extend(i,s));if(n.length>0)return this.parseOrder(n[0]);throw new mm(this.id+" order "+e+" not found")}async fetchOpenOrder(e,t=void 0,s={}){await this.loadMarkets();const i={clientOrderId:e},n=await this.privateGetOrderClientOrderId(this.extend(i,s));return this.parseOrder(n)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id);const a=await this.privateGetOrder(this.extend(r,i));return this.parseOrders(a,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),s!==void 0&&(r.limit=s),t!==void 0&&(r.from=this.iso8601(t));const a=await this.privateGetHistoryOrder(this.extend(r,i)),o=this.parseOrders(a,n),d=[];for(let c=0;c<o.length;c++){const u=o[c],h=u.status;(h==="closed"||h==="canceled")&&d.push(u)}return this.filterBySinceLimit(d,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),t!==void 0&&(n.from=this.iso8601(t)),s!==void 0&&(n.limit=s);const a=await this.privateGetHistoryTrades(this.extend(n,i));return this.parseTrades(a,r,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;t!==void 0&&(r=this.market(t));const a={orderId:e},o=await this.privateGetHistoryOrderOrderIdTrades(this.extend(a,n));if(o.length>0)return this.parseTrades(o,r,s,i);throw new mm(this.id+" order "+e+" not found, "+this.id+'.fetchOrderTrades() requires an exchange-specific order id, you need to grab it from order["info"]["id"]')}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=await this.privatePostAccountCryptoAddressCurrency(this.extend(i,t)),r=this.safeString(n,"address");this.checkAddress(r);const a=this.safeString(n,"paymentId");return{currency:s,address:r,tag:a,info:n}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=this.safeString(t,"network");if(n!==void 0){t=this.omit(t,"network");const d=this.safeValue(this.options,"networks"),c=this.safeString(d,n,n);i.currency+=c}const r=await this.privateGetAccountCryptoAddressCurrency(this.extend(i,t)),a=this.safeString(r,"address");this.checkAddress(a);const o=this.safeString(r,"paymentId");return{currency:s.code,address:a,tag:o,network:void 0,info:r}}async convertCurrencyNetwork(e,t,s,i,n){await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"networks",{});if(s=this.safeString(a,s,s),i=this.safeString(a,i,i),s===i)throw new jd(this.id+" convertCurrencyNetwork() fromNetwork cannot be the same as toNetwork");const o={fromCurrency:r.id+s,toCurrency:r.id+i,amount:parseFloat(this.currencyToPrecision(e,t))};return{info:await this.privatePostAccountCryptoTransferConvert(this.extend(o,n))}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets(),this.checkAddress(s);const r=this.currency(e),a={currency:r.id,amount:parseFloat(t),address:s};i&&(a.paymentId=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeString(o,d,d),d!==void 0&&(a.currency+=d,n=this.omit(n,"network"));const c=await this.privatePostAccountCryptoWithdraw(this.extend(a,n));return this.parseTransaction(c,r)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/api/"+this.version+"/";const o=this.omit(i,this.extractParams(e));if(t==="public")a+=t+"/"+this.implodeParams(e,i),Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials(),a+=this.implodeParams(e,i),s==="GET"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):Object.keys(o).length&&(r=this.json(o));const d=this.encode(this.apiKey+":"+this.secret),c=this.stringToBase64(d);n={Authorization:"Basic "+this.decode(c),"Content-Type":"application/json"}}return a=this.urls.api[t]+a,{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&e>=400){const c=this.id+" "+r;if(e===503||e===504)throw new jq(c);if(e===429)return;if(r[0]==="{"&&"error"in a){const u=this.safeString(a.error,"code");if(this.throwExactlyMatchedException(this.exceptions,u,c),this.safeString(a.error,"message")==="Duplicate clientOrderId")throw new ko(c)}throw new jd(c)}}};const Qq=Dl;var Zq=class extends Qq{describe(){return this.deepExtend(super.describe(),{id:"bequant",name:"Bequant",countries:["MT"],pro:!0,urls:{logo:"https://user-images.githubusercontent.com/1294454/55248342-a75dfe00-525a-11e9-8aa2-05e9dca943c6.jpg",api:{public:"https://api.bequant.io",private:"https://api.bequant.io"},www:"https://bequant.io",doc:["https://api.bequant.io/"],fees:["https://bequant.io/fees-and-limits"],referral:"https://bequant.io"}})}};const Jq=me,{ExchangeError:vo,AccountSuspended:e4,ArgumentsRequired:df,AuthenticationError:cf,DDoSProtection:t4,ExchangeNotAvailable:s4,InvalidOrder:tr,OrderNotFound:i4,PermissionDenied:n4,InsufficientFunds:K1,BadSymbol:r4,RateLimitExceeded:X1,BadRequest:Nr}=oe,{TICK_SIZE:a4}=pe,uf=ke;var o4=class extends Jq{describe(){return this.deepExtend(super.describe(),{id:"bibox",name:"Bibox",countries:["CN","US","KR"],rateLimit:166.667,version:"v3.1",hostname:"bibox.com",has:{CORS:void 0,spot:!0,margin:void 0,swap:void 0,future:void 0,option:void 0,cancelAllOrders:!0,cancelOrder:!0,createMarketOrder:void 0,createOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRates:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchDepositWithdrawFee:!0,fetchDepositWithdrawFees:!1,fetchLedger:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrdersByStatus:!0,fetchPositionMode:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!0,fetchWithdrawals:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/51840849/77257418-3262b000-6c85-11ea-8fb8-20bdf20b3592.jpg",api:{rest:"https://api.{hostname}"},www:"https://www.{hostname}",doc:["https://biboxcom.github.io/en/","https://biboxcom.github.io/v3/spot/en/","https://biboxcom.github.io/api/spot/v4"],fees:"https://bibox.zendesk.com/hc/en-us/articles/360002336133"},api:{v1:{public:{get:{cquery:1,mdata:1,cdata:1,orderpending:1},post:{mdata:1}},private:{post:{credit:1,cquery:1,ctrade:1,user:1,orderpending:1,transfer:1}}},"v1.1":{public:{get:["cquery"]},private:{post:["cquery","ctrade"]}},v2:{public:{get:["mdata/kline","mdata/depth"]},private:{post:["assets/transfer/spot"]}},v3:{public:{get:["mdata/ping","mdata/pairList","mdata/kline","mdata/marketAll","mdata/market","mdata/depth","mdata/deals","mdata/ticker","cbc/timestamp","cbu/timestamp"]},private:{post:["assets/transfer/spot","assets/transfer/cbc","cbc/order/open","cbc/order/close","cbc/order/closeBatch","cbc/order/closeAll","cbc/changeMargin","cbc/changeMode","cbc/assets","cbc/position","cbc/order/list","cbc/order/detail","cbc/order/listBatch","cbc/order/listBatchByClientOid","cbuassets/transfer","cbu/order/open","cbu/order/close","cbu/order/closeBatch","cbu/order/closeAll","cbu/order/planOpen","cbu/order/planOrderList","cbu/order/planClose","cbu/order/planCloseAll","cbu/changeMargin","cbu/changeMode","cbu/assets","cbu/position","cbu/order/list","bu/order/detail","cbu/order/listBatch","cbu/order/listBatchByClientOid"]}},"v3.1":{public:{get:["mdata/ping","cquery/buFundRate","cquery/buTagPrice","cquery/buValue","cquery/buUnit","cquery/bcFundRate","cquery/bcTagPrice","cquery/bcValue","cquery/bcUnit"]},private:{get:["orderpending/tradeLimit"],post:["transfer/mainAssets","spot/account/assets","transfer/transferIn","transfer/transferOut","transfer/transferInList","transfer/transferOutList","transfer/coinConfig","transfer/withdrawInfo","orderpending/trade","orderpending/cancelTrade","orderpending/orderPendingList","orderpending/pendingHistoryList","orderpending/orderDetail","orderpending/order","orderpending/orderHistoryList","orderpending/orderDetailsLast","credit/transferAssets/base2credit","credit/transferAssets/credit2base","credit/lendOrder/get","credit/borrowOrder/get","credit/lendOrderbook/get","credit/transferAssets/lendAssets","credit/transferAssets/borrowAssets","credit/borrowOrder/autobook","credit/borrowOrder/refund","credit/lendOrderbook/publish","credit/lendOrderbook/cancel","credit/trade/trade","credit/trade/cancel","cquery/base_u/dealLog","cquery/base_u/orderDetail","cquery/base_u/orderHistory","cquery/base_u/orderById","cquery/base_coin/dealLog","cquery/base_coin/orderDetail","cquery/base_coin/orderHistory","cquery/base_coin/orderById"]}},v4:{public:{get:["marketdata/pairs","marketdata/order_book","marketdata/candles","marketdata/trades","marketdata/ticker"]},private:{get:["userdata/accounts","userdata/ledger","userdata/order","userdata/orders","userdata/fills"],post:["userdata/order"],delete:["userdata/order","userdata/orders","userdata/fills"]}}},fees:{trading:{tierBased:!1,percentage:!0,taker:this.parseNumber("0.002"),maker:this.parseNumber("0.001")},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}},precisionMode:a4,exceptions:{2011:e4,2015:cf,2021:K1,2027:K1,2033:i4,2065:tr,2066:tr,2067:tr,2068:tr,2078:tr,2085:tr,2091:X1,2092:tr,2131:tr,3e3:Nr,3002:Nr,3012:cf,3016:r4,3024:n4,3025:cf,4e3:s4,4003:t4,"-2004":tr,"-2102":X1},commonCurrencies:{"APENFT(NFT)":"NFT",BOX:"DefiBox",BPT:"BlockPool Token",BUSDT:"USDT",GMT:"GMT Token",KEY:"Bihu",MTC:"MTC Mesh Network",NFT:"NFT Protocol",PAI:"PCHAIN",REVO:"Revo Network",STAR:"Starbase",TERN:"Ternio-ERC20"},options:{typesByAccount:{base:"main",credit:"margin"}}})}async fetchMarkets(e={}){const t=await this.v4PublicGetMarketdataPairs(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"symbol"),a=this.safeString(n,"base"),o=this.safeString(n,"quote"),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o),u=d+"/"+c,h="spot",l=!0,p=this.safeString(n,"quantity_scale"),m=this.safeString(n,"price_scale");s.push({id:r,symbol:u,baseId:a,quoteId:o,settleId:void 0,base:d,quote:c,settle:void 0,type:h,spot:l,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(p)),price:this.parseNumber(this.parsePrecision(m))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(n,"min_quantity"),max:this.safeNumber(n,"max_quantity")},price:{min:this.safeNumber(n,"min_price"),max:this.safeNumber(n,"max_price")},cost:{min:this.safeNumber(n,"min_order_value"),max:void 0}},info:n})}return s}parseTicker(e,t=void 0){const s=this.safeInteger2(e,"timestamp","t"),i=this.safeString(e,"coin_symbol"),n=this.safeString(e,"currency_symbol");let r=this.safeString(e,"s");r===void 0&&i!==void 0&&n!==void 0&&(r=i+"_"+n),t=this.safeMarket(r,t);const a=this.safeString2(e,"last","p");let o=this.safeString(e,"percent");return o!==void 0&&(o=o.replace("%","")),this.safeTicker({symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeString2(e,"high","h"),low:this.safeString2(e,"low","l"),bid:this.safeString(e,"bp"),bidVolume:this.safeString(e,"bq"),ask:this.safeString(e,"ap"),askVolume:this.safeString(e,"aq"),vwap:void 0,open:this.safeString(e,"o"),close:a,last:a,previousClose:void 0,change:this.safeString(e,"change"),percentage:o,average:void 0,baseVolume:this.safeString2(e,"a","vol24H"),quoteVolume:this.safeString2(e,"v","amount"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.v4PublicGetMarketdataTicker(this.extend(i,t)),r=this.safeValue(n,0);return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={cmd:"marketAll"},i=await this.v1PublicGetMdata(this.extend(s,t)),n=this.parseTickers(i.result,e),r=this.indexBy(n,"symbol");return this.filterByArray(r,"symbol",e)}parseTrade(e,t=void 0){const s=this.safeString(e,"i"),i=this.safeString(e,"s"),n=this.safeInteger(e,"t"),r=this.safeValue(e,"f"),a=this.safeString(r,"a"),o=this.safeString(e,"q");let d=this.safeString(e,"T"),c="buy";const u=this.safeString(e,"o");return t=this.safeMarket(i,t),i==="buy"||i==="sell"?c=i:uf.stringLt(o,"0")&&(c="sell"),uf.stringLt(s,"9999999999")&&(d=s),this.safeTrade({info:e,id:d,order:u,timestamp:n,datetime:this.iso8601(n),symbol:t.symbol,type:void 0,takerOrMaker:this.safeString(e,"l","taker"),side:c,price:this.safeString(e,"p"),amount:o,cost:void 0,fee:{cost:this.safeString(r,"m"),currency:this.safeCurrencyCode(a)}},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r=this.safeInteger(i,"until"),a={symbol:n.id};s!==void 0&&(a.limit=s),t!==void 0&&(a.start_time=t),r!==void 0&&(a.end_time=r);const o=await this.v4PublicGetMarketdataTrades(this.extend(a,i));return this.parseTrades(o,n,t,s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};if(t!==void 0){const a=[1,2,5,10,20,50,100,200,500,1e3];if(!this.inArray(t,a))throw new Nr(this.id+" fetchOrderBook limit argument by only be one of 1, 2, 5, 10, 20, 50, 100, 200, 500 or 1000");n.level=t}const r=await this.v4PublicGetMarketdataOrderBook(this.extend(n,s));return this.parseOrderBook(r,i.symbol,this.safeInteger(r,"t"),"b","a")}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.safeInteger(n,"until"),o={symbol:r.id,time_frame:this.timeframes[t]};if(i!==void 0&&(o.limit=i),s!==void 0&&a!==void 0)throw new Nr(this.id+' fetchOHLCV cannot take both a since parameter and params["until"]');s!==void 0?o.after=s:a!==void 0&&(o.before=a);const d=await this.v4PublicGetMarketdataCandles(this.extend(o,n));let c=this.safeValue(d,"e",[]);return c===void 0&&(Array.isArray(d)?c=d:c=[]),this.parseOHLCVs(c,r,t,s,i)}async fetchCurrencies(e={}){return this.checkRequiredCredentials(!1)?await this.fetchCurrenciesPrivate(e):await this.fetchCurrenciesPublic(e)}async fetchCurrenciesPublic(e={}){const t={cmd:"currencies"},s=await this.v1PublicGetCdata(this.extend(t,e)),i=this.safeValue(s,"result",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"symbol"),d=this.safeString(a,"name"),c=this.safeCurrencyCode(o),u=this.parseNumber(this.parsePrecision(this.safeString(a,"valid_decimals"))),h=this.safeValue(a,"enable_deposit"),l=this.safeValue(a,"enable_withdraw"),p=h&&l;n[c]={id:o,code:c,info:a,name:d,active:p,deposit:h,withdraw:l,fee:void 0,precision:u,limits:{amount:{min:u,max:void 0},withdraw:{min:this.safeNumber(a,"withdraw_min"),max:void 0}}}}return n}async fetchCurrenciesPrivate(e={}){if(!this.checkRequiredCredentials(!1))throw new cf(this.id+" fetchCurrencies is an authenticated endpoint, therefore it requires 'apiKey' and 'secret' credentials. If you don't need currency details, set exchange.has['fetchCurrencies'] = false before calling its methods.");const t={cmd:"transfer/coinList",body:{}},s=await this.v1PrivatePostTransfer(this.extend(t,e)),i=this.safeValue(s,"result"),n=this.safeValue(i,0,{}),r=this.safeValue(n,"result",[]),a={};for(let o=0;o<r.length;o++){const d=r[o],c=this.safeString(d,"symbol"),u=d.name,h=this.safeCurrencyCode(c),l=this.parseNumber("0.00000001"),p=this.safeValue(d,"enable_deposit"),m=this.safeValue(d,"enable_withdraw"),g=p&&m;a[h]={id:c,code:h,info:d,name:u,active:g,fee:void 0,precision:l,limits:{amount:{min:l,max:void 0},withdraw:{min:void 0,max:void 0}}}}return a}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString2(i,"s","coin_symbol"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString2(i,"a","balance"),a.used=this.safeString2(i,"h","freeze"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),i={};let n;if(t==="spot"){const r=this.safeString(s,"code"),a=this.omit(s,"code");if(r!==void 0){const o=this.currency(r);i.asset=o.id}n=await this.v4PrivateGetUserdataAccounts(this.extend(i,a))}else if(t==="main"||t==="wallet"||t==="funding"){const r="v3.1PrivatePostTransferMainAssets";i.select=1;const a=await this[r](this.extend(i,s)),o=this.safeValue(a,"result",{});n=this.safeValue(o,"assets_list",[])}return this.parseBalance(n)}parseLedgerEntry(e,t=void 0){const s={transfer_in:"transfer",transfer_out:"transfer",trade_finish_ask:"trade",trade_finish_bid:"trade"},i=this.safeString(e,"i"),n=this.safeString(e,"s"),r=this.safeString(e,"T"),a=this.safeInteger(e,"t"),o=this.safeString(e,"a");let d="in";return uf.stringLt(o,"0")&&(d="out"),{id:i,direction:d,account:void 0,referenceId:i,referenceAccount:void 0,type:this.safeString(s,r,r),currency:this.safeCurrencyCode(n,t),amount:this.parseNumber(o),timestamp:a,datetime:this.iso8601(a),before:void 0,after:this.safeNumber(e,"b"),status:void 0,fee:void 0,info:e}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r=this.safeInteger(i,"until");i=this.omit(i,"until");const a={};e!==void 0&&(n=this.currency(e),a.asset=n.id),t!==void 0&&(a.start_time=t),s!==void 0&&(a.limit=s),r!==void 0&&(a.end_time=r);const o=await this.v4PrivateGetUserdataLedger(this.extend(a,i));return this.parseLedger(o,n,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),s===void 0&&(s=50);const r={page:this.safeInteger(i,"page",1),size:s};let a;e!==void 0&&(a=this.currency(e),r.coin_symbol=a.id);const d=await this["v3.1PrivatePostTransferTransferInList"](this.extend(r,i)),c=this.safeValue(d,"result"),u=this.safeValue(c,"items");for(let h=0;h<u.length;h++)u[h].type="deposit";return this.parseTransactions(u,a,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),s===void 0&&(s=50);const r={page:this.safeInteger(i,"page",1),size:s};let a;e!==void 0&&(a=this.currency(e),r.coin_symbol=a.id);const d=await this["v3.1PrivatePostTransferTransferOutList"](this.extend(r,i)),c=this.safeValue(d,"result"),u=this.safeValue(c,"items");for(let h=0;h<u.length;h++)u[h].type="withdrawal";return this.parseTransactions(u,a,t,s)}parseTransaction(e,t=void 0){const s=this.safeString(e,"to_address"),i=this.safeString(e,"coin_symbol"),n=this.safeCurrencyCode(i,t),r=this.safeInteger(e,"createdAt");let a=this.safeString(e,"addr_remark");const o=this.safeString(e,"type"),d=this.safeNumber(e,"amount");let c=this.safeNumber(e,"fee");o==="deposit"&&(c=0,a=void 0);const u={cost:c,currency:n};return{info:e,id:this.safeString2(e,"id","result"),txid:this.safeString(e,"tx_id"),timestamp:r,datetime:this.iso8601(r),network:this.safeString(e,"chain_type"),address:s,addressTo:s,addressFrom:void 0,tag:a,tagTo:void 0,tagFrom:void 0,type:o,amount:d,currency:n,status:this.parseTransactionStatusByType(this.safeString(e,"status"),o),updated:void 0,fee:u}}parseTransactionStatusByType(e,t=void 0){const s={deposit:{1:"pending",2:"ok"},withdrawal:{0:"pending",3:"ok"}};return this.safeString(this.safeValue(s,t,{}),e,e)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);if(t=t.toLowerCase(),t==="market")throw new Nr(this.id+" createOrder () does not support market orders, only limit orders are allowed");if(n===void 0)throw new df(this.id+" createOrder () requires a price argument for limit orders");const o={symbol:a.id,side:s,type:t,quantity:this.amountToPrecision(e,i),price:this.priceToPrecision(e,n)},d=this.safeStringLower(r,"timeInForce");d!==void 0&&(o.time_in_force=d);const c=this.isPostOnly(!1,void 0,r);c&&(o.post_only=c);const u=this.safeString(r,"clientOrderId");u!==void 0&&(o.client_order_id=u),r=this.omit(r,["postOnly","timeInForce","clientOrderId"]);const h=await this.v4PrivatePostUserdataOrder(this.deepExtend(o,r));return this.parseOrder(h,a)}async cancelAllOrders(e=void 0,t={}){if(await this.loadMarkets(),e===void 0)throw new df(this.id+" cancelAllOrders requires a symbol argument");const s=this.market(e),i={symbol:s.id},n=await this.v4PrivateDeleteUserdataOrders(this.extend(i,t));return this.parseOrders(n,s)}async cancelOrder(e,t=void 0,s={}){const i={id:e},n=await this.v4PrivateDeleteUserdataOrder(this.extend(i,s));return this.parseOrder(n)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.v4PrivateGetUserdataOrder(this.extend(i,s));return this.parseOrder(n)}parseOrder(e,t=void 0){const s=this.safeString(e,"m");t=this.safeMarket(s,t);const i=this.safeInteger(e,"C");let n=this.safeString(e,"Q");n=uf.stringAbs(n);const r=this.safeString(e,"s"),a=[],o=this.safeValue(e,"f",[]);for(let u=0;u<o.length;u++)a.push({currency:this.safeCurrencyCode(this.safeString(o[u],"a")),cost:this.safeString(o[u],"m")});const d=this.safeValue(e,"F"),c=[];for(let u=0;u<d.length;u++){const h=this.parseTrade(d[u]);c.push(h)}return this.safeOrder({info:e,id:this.safeString(e,"i"),clientOrderId:this.omitZero(this.safeString(e,"I")),timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,symbol:t.symbol,type:this.safeString(e,"T"),timeInForce:this.safeStringUpper(e,"t"),postOnly:this.safeValue(e,"o"),side:r,price:this.safeString(e,"P"),stopPrice:void 0,amount:n,cost:this.safeString(e,"e"),average:void 0,filled:this.safeString(e,"E"),remaining:void 0,status:this.parseOrderStatus(this.safeString(e,"S")),fee:this.safeValue(a,0),fees:a,trades:c},t)}parseOrderStatus(e){const t={1:"open",2:"open",accepted:"open",3:"closed",4:"canceled",5:"canceled",6:"canceled",rejected:"rejected","-1":"rejected"};return this.safeString(t,e,e)}async fetchOrdersByStatus(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a;const o=this.safeInteger(n,"until"),d=e==="open",c=e==="unsettled";n=this.omit(n,"until"),o!==void 0&&(r.end_time=o),i!==void 0&&(r.limit=i),s!==void 0&&(r.start_time=s),r.status=d||c?"unsettled":"settled",t!==void 0&&(a=this.market(t),r.symbol=a.id);const u=await this.v4PrivateGetUserdataOrders(this.extend(r,n));return this.parseOrders(u,a,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("open",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new df(this.id+" fetchClosedOrders requires a symbol argument");return await this.fetchOrdersByStatus("closed",e,t,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={},a=this.safeInteger(i,"until");if(i=this.omit(i,"until"),e===void 0&&this.safeString(i,"order_id")===void 0)throw new df(this.id+' fetchMyTrades requires either a symbol parameter of params["order_id"]');e!==void 0&&(n=this.market(e),r.symbol=n.id),t!==void 0&&(r.start_time=t),s!==void 0&&(r.limit=s),a!==void 0&&(r.end_time=a);const o=await this.v4PrivateGetUserdataFills(this.extend(r,i));return this.parseTrades(o,n,t,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={cmd:"transfer/transferIn",body:this.extend({coin_symbol:s.id},t)},n=await this.v1PrivatePostTransfer(i),r=this.safeValue(n,"result"),a=this.safeValue(r,0,{}),o=this.safeValue(a,"result");let d=o,c;if(this.isJsonEncodedObject(o)){const u=JSON.parse(o);d=this.safeString(u,"account"),c=this.safeString(u,"memo")}return{currency:e,address:d,tag:c,network:void 0,info:n}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e);if(this.password===void 0&&!("trade_pwd"in n))throw new vo(this.id+" withdraw() requires this.password set on the exchange instance or a trade_pwd parameter");if(!("totp_code"in n))throw new vo(this.id+" withdraw() requires a totp_code parameter for 2FA authentication");const a={trade_pwd:this.password,coin_symbol:r.id,amount:t,addr:s};i!==void 0&&(a.address_remark=i);const o=await this.v1PrivatePostTransfer({cmd:"transfer/transferOut",body:this.extend(a,n)}),d=this.safeValue(o,"result"),c=this.safeValue(d,0,{});return this.parseTransaction(c,r)}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s={},i={};e===void 0&&(e=Object.keys(this.currencies));for(let n=0;n<e.length;n++){const r=e[n],a=this.currency(r),o={cmd:"transfer/coinConfig",body:this.extend({coin_symbol:a.id},t)},d=await this.v1PrivatePostTransfer(o),c=this.safeValue(d,"result",[]),u=this.safeValue(c,0,{}),h=this.safeValue(u,"result",[]),l=this.safeValue(h,0,{});i[r]=l,s[r]=this.safeNumber(l,"withdraw_fee")}return{info:i,withdraw:s,deposit:{}}}async fetchDepositWithdrawFee(e,t={}){await this.loadMarkets();const s=this.currency(e),i={cmd:"transfer/coinConfig",body:this.extend({coin_symbol:s.id},t)},n=await this.v1PrivatePostTransfer(i),r=this.safeValue(n,"result",[]),a=this.safeValue(r,0,{}),o=this.safeValue(a,"result",[]),d=this.safeValue(o,0,{});return this.parseDepositWithdrawFee(d,s)}parseDepositWithdrawFee(e,t=void 0){return{info:e,withdraw:{fee:this.safeNumber(e,"withdraw_fee"),percentage:void 0},deposit:{fee:void 0,percentage:void 0},networks:{}}}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=s==="main"||s==="wallet"||s==="funding",o=s==="spot",d=i==="main"||i==="wallet"||i==="funding",c=i==="spot",u=i==="cross",h=s==="cross",l=this.inArray(i,this.symbols),p=this.inArray(s,this.symbols),m=i==="swap",g=s==="swap";let y="v3PrivatePostAssetsTransferSpot";const b={amount:t};if(c||o)if(b.symbol=r.id,a)b.type=0;else if(d)b.type=1;else throw new Nr(this.id+" cannot transfer from "+s+" to "+i);else if((h||p)&&d)y="v3.1PrivatePostCreditTransferAssetsCredit2base",b.coin_symbol=r.id,b.pair=p?this.marketId(s):"*_USDT";else if((u||l)&&a)y="v3.1PrivatePostCreditTransferAssetsBase2credit",b.coin_symbol=r.id,b.pair=l?this.marketId(i):"*_USDT";else if(m||g){if(e==="USDT"?y="v3PrivatePostCbuassetsTransfer":y="v3PrivatePostAssetsTransferCbc",d)b.type=1;else if(a)b.type=0;else throw new Nr(this.id+" cannot transfer from "+s+" to "+i);b.symbol=r.id}else throw new Nr(this.id+" cannot transfer from "+s+" to "+i);const w=await this[y](this.extend(b,n));return this.parseTransfer(w,r)}parseTransfer(e,t=void 0){const s=this.safeString(e,"cmd");let i,n;if(s!==void 0){const a=this.safeString(s.split("/"),1).split("2");i=this.safeString(a,0),n=this.safeString(a,1),i=this.safeString(this.options.typesByAccount,i,i),n=this.safeString(this.options.typesByAccount,n,n)}return{info:e,id:this.safeString2(e,"id","result"),timestamp:void 0,datetime:void 0,currency:this.safeString(t,"code"),amount:void 0,fromAccount:i,toAccount:n,status:void 0}}sign(e,t="v1Public",s="GET",i={},n=void 0,r=void 0){const[a,o]=t,d=a==="v1",c=a==="v4",u=c?"/api":"";let h=this.implodeHostname(this.urls.api.rest)+u+"/"+a+"/"+e;const l=d?this.json([i]):this.json(i);if(n={"content-type":"application/json"},o==="public")s!=="GET"?d?r={cmds:l}:r={body:l}:Object.keys(i).length&&(h+="?"+this.urlencode(i));else if(this.checkRequiredCredentials(),a==="v3"||a==="v3.1"){const p=this.numberToString(this.milliseconds());let m=p;l!=="{}"&&(m+=l);const g=this.hmac(this.encode(m),this.encode(this.secret),"md5");n["bibox-api-key"]=this.apiKey,n["bibox-api-sign"]=g,n["bibox-timestamp"]=p,s==="GET"?h+="?"+this.urlencode(i):l!=="{}"&&(r=i)}else if(c){let p="";const m=this.keysort(i);s==="GET"?(h+="?"+this.urlencode(m),p=this.urlencode(m)):(l!=="{}"&&(r=m),p=this.json(r,{convertArraysToObjects:!0}));const g=this.hmac(this.encode(p),this.encode(this.secret),"sha256");n["Bibox-Api-Key"]=this.apiKey,n["Bibox-Api-Sign"]=g}else{const p=this.hmac(this.encode(l),this.encode(this.secret),"md5");r={apikey:this.apiKey,sign:p},d?r.cmds=l:r.body=l}return r!==void 0&&(r=this.json(r,{convertArraysToObjects:!0})),{url:h,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0){if("state"in a){if(this.safeNumber(a,"state")===0)return;throw new vo(this.id+" "+r)}if("error"in a)if(typeof a.error=="object"){if("code"in a.error){const c=this.safeString(a.error,"code"),u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions,c,u),new vo(u)}throw new vo(this.id+" "+r)}else{const c=this.safeString(a,"error"),u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions,c,u),new vo(u)}}}};const d4=me,{ExchangeError:Oa,ArgumentsRequired:gm,AuthenticationError:ym,InsufficientFunds:Y1,PermissionDenied:Q1,BadRequest:Z1,BadSymbol:J1,RateLimitExceeded:c4,InvalidOrder:To}=oe,{TICK_SIZE:u4}=pe;var f4=class extends d4{describe(){return this.deepExtend(super.describe(),{id:"bigone",name:"BigONE",countries:["CN"],version:"v3",rateLimit:1200,has:{CORS:void 0,spot:!0,margin:void 0,swap:void 0,future:void 0,option:void 0,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!1,fetchWithdrawals:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"min1","5m":"min5","15m":"min15","30m":"min30","1h":"hour1","3h":"hour3","4h":"hour4","6h":"hour6","12h":"hour12","1d":"day1","1w":"week1","1M":"month1"},hostname:"big.one",urls:{logo:"https://user-images.githubusercontent.com/1294454/69354403-1d532180-0c91-11ea-88ed-44c06cefdf87.jpg",api:{public:"https://{hostname}/api/v3",private:"https://{hostname}/api/v3/viewer"},www:"https://big.one",doc:"https://open.big.one/docs/api.html",fees:"https://bigone.zendesk.com/hc/en-us/articles/115001933374-BigONE-Fee-Policy",referral:"https://b1.run/users/new?code=D3LLBVFT"},api:{public:{get:["ping","asset_pairs","asset_pairs/{asset_pair_name}/depth","asset_pairs/{asset_pair_name}/trades","asset_pairs/{asset_pair_name}/ticker","asset_pairs/{asset_pair_name}/candles","asset_pairs/tickers"]},private:{get:["accounts","fund/accounts","assets/{asset_symbol}/address","orders","orders/{id}","orders/multi","trades","withdrawals","deposits"],post:["orders","orders/{id}/cancel","orders/cancel","withdrawals","transfer"]}},fees:{trading:{maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")},funding:{withdraw:{}}},options:{accountsByType:{spot:"SPOT",funding:"FUND",future:"CONTRACT",swap:"CONTRACT"},transfer:{fillResponseFromRequest:!0},exchangeMillisecondsCorrection:-100},precisionMode:u4,exceptions:{exact:{10001:Z1,10005:Oa,"Amount's scale must greater than AssetPair's base scale":To,"Price mulit with amount should larger than AssetPair's min_quote_value":To,10007:Z1,10011:Oa,10013:J1,10014:Y1,10403:Q1,10429:c4,40004:ym,40103:ym,40104:ym,40301:Q1,40302:Oa,40601:Oa,40602:Oa,40603:Y1,40604:To,40605:To,40120:To,40121:To,60100:J1},broad:{}},commonCurrencies:{CRE:"Cybereits",FXT:"FXTTOKEN",FREE:"FreeRossDAO",MBN:"Mobilian Coin",ONE:"BigONE Token"}})}async fetchMarkets(e={}){const t=await this.publicGetAssetPairs(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"name"),o=this.safeString(r,"id"),d=this.safeValue(r,"base_asset",{}),c=this.safeValue(r,"quote_asset",{}),u=this.safeString(d,"symbol"),h=this.safeString(c,"symbol"),l=this.safeCurrencyCode(u),p=this.safeCurrencyCode(h),m={id:a,uuid:o,symbol:l+"/"+p,base:l,quote:p,settle:void 0,baseId:u,quoteId:h,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"base_scale"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"quote_scale")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(r,"min_quote_value"),max:this.safeNumber(r,"max_quote_value")}},info:r};i.push(m)}return i}async loadMarkets(e=!1,t={}){const s=await super.loadMarkets(e,t);let i=this.safeValue(this.options,"marketsByUuid");if(i===void 0||e){i={};for(let n=0;n<this.symbols.length;n++){const r=this.symbols[n],a=this.markets[r],o=this.safeString(a,"uuid");i[o]=a}this.options.marketsByUuid=i}return s}parseTicker(e,t=void 0){const s=this.safeString(e,"asset_pair_name"),i=this.safeSymbol(s,t,"-"),n=void 0,r=this.safeString(e,"close"),a=this.safeValue(e,"bid",{}),o=this.safeValue(e,"ask",{});return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(a,"price"),bidVolume:this.safeString(a,"quantity"),ask:this.safeString(o,"price"),askVolume:this.safeString(o,"quantity"),vwap:void 0,open:this.safeString(e,"open"),close:r,last:r,previousClose:void 0,change:this.safeString(e,"daily_change"),percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={asset_pair_name:s.id},n=await this.publicGetAssetPairsAssetPairNameTicker(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};if(e=this.marketSymbols(e),e!==void 0){const a=this.marketIds(e);s.pair_names=a.join(",")}const i=await this.publicGetAssetPairsTickers(this.extend(s,t)),n=this.safeValue(i,"data",[]),r={};for(let a=0;a<n.length;a++){const o=this.parseTicker(n[a]),d=o.symbol;r[d]=o}return this.filterByArray(r,"symbol",e)}async fetchTime(e={}){const t=await this.publicGetPing(e),s=this.safeValue(t,"data",{}),i=this.safeInteger(s,"timestamp");return parseInt(i/1e6)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={asset_pair_name:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetAssetPairsAssetPairNameDepth(this.extend(n,s)),a=this.safeValue(r,"data",{});return this.parseOrderBook(a,i.symbol,void 0,"bids","asks","price","quantity")}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString2(e,"created_at","inserted_at")),i=this.safeString(e,"price"),n=this.safeString(e,"amount"),r=this.safeString(e,"asset_pair_name");t=this.safeMarket(r,t,"-");let a=this.safeString(e,"side");const o=this.safeString(e,"taker_side");let d;o!==void 0&&a!==void 0&&a!=="SELF_TRADING"&&(d=o===a?"taker":"maker"),a===void 0?a=o==="ASK"?"sell":"buy":a==="BID"?a="buy":a==="ASK"&&(a="sell");const c=this.safeString(e,"maker_order_id"),u=this.safeString(e,"taker_order_id");let h;c!==void 0?u!==void 0?h=[c,u]:h=c:u!==void 0&&(h=u);const p={id:this.safeString(e,"id"),timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:h,type:"limit",side:a,takerOrMaker:d,price:i,amount:n,cost:void 0,info:e};let m,g;d!==void 0?a==="buy"?d==="maker"?(m=t.base,g=t.quote):(m=t.quote,g=t.base):d==="maker"?(m=t.quote,g=t.base):(m=t.base,g=t.quote):a==="SELF_TRADING"&&(o==="BID"?(m=t.quote,g=t.base):o==="ASK"&&(m=t.base,g=t.quote));const y=this.safeString(e,"maker_fee"),b=this.safeString(e,"taker_fee");return y!==void 0?b!==void 0?p.fees=[{cost:y,currency:m},{cost:b,currency:g}]:p.fee={cost:y,currency:m}:b!==void 0?p.fee={cost:b,currency:g}:p.fee=void 0,this.safeTrade(p,t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={asset_pair_name:n.id},a=await this.publicGetAssetPairsAssetPairNameTrades(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"time")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);i===void 0&&(i=100);const a={asset_pair_name:r.id,period:this.timeframes[t],limit:i};if(s!==void 0){const c=this.parseTimeframe(t),u=this.sum(s,i*c*1e3);a.time=this.iso8601(u)}const o=await this.publicGetAssetPairsAssetPairNameCandles(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseOHLCVs(d,r,t,s,i)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"data",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeString(n,"asset_symbol"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(n,"balance"),o.used=this.safeString(n,"locked_balance"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"type","");e=this.omit(e,"type");const s="privateGet"+this.capitalize(t)+"Accounts",i=await this[s](e);return this.parseBalance(i)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"asset_pair_name"),n=this.safeSymbol(i,t,"-"),r=this.parse8601(this.safeString(e,"created_at")),a=this.safeString(e,"price"),o=this.safeString(e,"amount"),d=this.safeString(e,"avg_deal_price"),c=this.safeString(e,"filled_amount"),u=this.parseOrderStatus(this.safeString(e,"state"));let h=this.safeString(e,"side");h==="BID"?h="buy":h="sell";const l=this.parse8601(this.safeString(e,"updated_at"));return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:l,symbol:n,type:void 0,timeInForce:void 0,postOnly:void 0,side:h,price:a,stopPrice:void 0,amount:o,cost:void 0,average:d,filled:c,remaining:void 0,status:u,fee:void 0,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);s=s==="buy"?"BID":"ASK";const o=t.toUpperCase(),d={asset_pair_name:a.id,side:s,amount:this.amountToPrecision(e,i),type:o};if(o==="LIMIT")d.price=this.priceToPrecision(e,n);else{const h=o==="STOP_LIMIT";if(h||o==="STOP_MARKET"){const p=this.safeNumber2(r,"stop_price","stopPrice");if(p===void 0)throw new gm(this.id+" createOrder() requires a stop_price parameter");d.stop_price=this.priceToPrecision(e,p),r=this.omit(r,["stop_price","stopPrice"])}h&&(d.price=this.priceToPrecision(e,n))}const c=await this.privatePostOrders(this.extend(d,r)),u=this.safeValue(c,"data");return this.parseOrder(u,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privatePostOrdersIdCancel(this.extend(i,s)),r=this.safeValue(n,"data");return this.parseOrder(r)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const i={asset_pair_name:this.market(e).id};return await this.privatePostOrdersCancel(this.extend(i,t))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetOrdersId(this.extend(i,s)),r=this.safeValue(n,"data",{});return this.parseOrder(r)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new gm(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={asset_pair_name:n.id};s!==void 0&&(r.limit=s);const a=await this.privateGetOrders(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseOrders(o,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),e===void 0)throw new gm(this.id+" fetchMyTrades() requires a symbol argument");const n=this.market(e),r={asset_pair_name:n.id};s!==void 0&&(r.limit=s);const a=await this.privateGetTrades(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}parseOrderStatus(e){const t={PENDING:"open",FILLED:"closed",CANCELLED:"canceled"};return this.safeString(t,e)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={state:"PENDING"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={state:"FILLED"};return await this.fetchOrders(e,t,s,this.extend(n,i))}nonce(){const e=this.safeInteger(this.options,"exchangeMillisecondsCorrection",0)*1e6;return this.microseconds()*1e3+e}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.omit(i,this.extractParams(e));let d=this.implodeHostname(this.urls.api[t])+"/"+this.implodeParams(e,i);if(n={},t==="public")Object.keys(a).length&&(d+="?"+this.urlencode(a));else{this.checkRequiredCredentials();const c=this.nonce().toString(),u={type:"OpenAPIV2",sub:this.apiKey,nonce:c},h=this.jwt(u,this.encode(this.secret));n.Authorization="Bearer "+h,s==="GET"?Object.keys(a).length&&(d+="?"+this.urlencode(a)):s==="POST"&&(n["Content-Type"]="application/json",r=this.json(a))}return n["User-Agent"]="ccxt/"+this.id+"-"+this.version,{url:d,method:s,body:r,headers:n}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={asset_symbol:this.currency(e).id},n=await this.privateGetAssetsAssetSymbolAddress(this.extend(i,t)),r=this.safeValue(n,"data",[]);if(r.length<1)throw new Oa(this.id+" fetchDepositAddress() returned empty address response");const o=r[0],d=this.safeString(o,"value"),c=this.safeString(o,"memo");return this.checkAddress(d),{currency:e,address:d,tag:c,network:void 0,info:n}}parseTransactionStatus(e){const t={WITHHOLD:"ok",UNCONFIRMED:"pending",CONFIRMED:"ok",COMPLETED:"ok",PENDING:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"asset_symbol"),i=this.safeCurrencyCode(s),n=this.safeInteger(e,"id"),r=this.safeNumber(e,"amount"),a=this.parseTransactionStatus(this.safeString(e,"state")),o=this.parse8601(this.safeString(e,"inserted_at")),d=this.parse8601(this.safeString2(e,"updated_at","completed_at")),c=this.safeString(e,"txid"),u=this.safeString(e,"target_address"),h=this.safeString(e,"memo"),l="customer_id"in e?"deposit":"withdrawal";return{info:e,id:n,txid:c,timestamp:o,datetime:this.iso8601(o),network:void 0,addressFrom:void 0,address:void 0,addressTo:u,tagFrom:void 0,tag:h,tagTo:void 0,type:l,amount:r,currency:i,status:a,updated:d,fee:void 0}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.asset_symbol=r.id),s!==void 0&&(n.limit=s);const a=await this.privateGetDeposits(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.asset_symbol=r.id),s!==void 0&&(n.limit=s);const a=await this.privateGetWithdrawals(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,r,t,s)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c=this.safeString(n,"guid",this.uuid()),u={symbol:r.id,amount:this.currencyToPrecision(e,t),from:o,to:d,guid:c},h=await this.privatePostTransfer(this.extend(u,n)),l=this.parseTransfer(h,r),p=this.safeValue(this.options,"transfer",{});return this.safeValue(p,"fillResponseFromRequest",!0)&&(l.fromAccount=s,l.toAccount=i,l.amount=t,l.id=c),l}parseTransfer(e,t=void 0){const s=this.safeNumber(e,"code");return{info:e,id:void 0,timestamp:void 0,datetime:void 0,currency:s,amount:void 0,fromAccount:void 0,toAccount:void 0,status:this.parseTransferStatus(s)}}parseTransferStatus(e){const t={0:"ok"};return this.safeString(t,e,"failed")}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets();const r=this.currency(e),a={symbol:r.id,target_address:s,amount:this.currencyToPrecision(e,t)};i!==void 0&&(a.memo=i);const o=await this.privatePostWithdrawals(this.extend(a,n)),d=this.safeValue(o,"data",{});return this.parseTransaction(d,r)}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"code"),u=this.safeString(a,"message");if(c!=="0"){const h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwExactlyMatchedException(this.exceptions.exact,c,h),this.throwBroadlyMatchedException(this.exceptions.broad,u,h),new Oa(h)}}};const h4=me,{ExchangeError:at,ArgumentsRequired:ii,ExchangeNotAvailable:Wd,InsufficientFunds:Ut,OrderNotFound:eS,InvalidOrder:Ms,DDoSProtection:zd,InvalidNonce:l4,AuthenticationError:Ls,RateLimitExceeded:Kd,PermissionDenied:En,NotSupported:ni,BadRequest:ge,BadSymbol:Oo,AccountSuspended:Io,OrderImmediatelyFillable:ff,OnMaintenance:p4,BadResponse:tS,RequestTimeout:m4,OrderNotFillable:g4,MarginModeAlreadySet:sS}=oe,{TRUNCATE:hf,DECIMAL_PLACES:y4}=pe,_e=ke;var Eu=class extends h4{describe(){return this.deepExtend(super.describe(),{id:"binance",name:"Binance",countries:["JP","MT"],rateLimit:50,certified:!0,pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!0,option:void 0,addMargin:!0,borrowMargin:!0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:void 0,createDepositAddress:!1,createOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!1,createStopOrder:!0,fetchAccounts:void 0,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowInterest:!0,fetchBorrowRate:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!0,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchCanceledOrders:!1,fetchClosedOrder:!1,fetchClosedOrders:"emulated",fetchCurrencies:!0,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!0,fetchL3OrderBook:!1,fetchLedger:void 0,fetchLeverage:!1,fetchLeverageTiers:!0,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!0,fetchOpenOrder:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:void 0,fetchPositions:!0,fetchPositionsRisk:!0,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTradingLimits:void 0,fetchTransactionFee:void 0,fetchTransactionFees:!0,fetchTransactions:!1,fetchTransfers:!0,fetchWithdrawal:!1,fetchWithdrawals:!0,fetchWithdrawalWhitelist:!1,reduceMargin:!0,repayMargin:!0,setLeverage:!0,setMargin:!1,setMarginMode:!0,setPositionMode:!0,signIn:!1,transfer:!0,withdraw:!0},timeframes:{"1s":"1s","1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/29604020-d5483cdc-87ee-11e7-94c7-d1a8d9169293.jpg",test:{dapiPublic:"https://testnet.binancefuture.com/dapi/v1",dapiPrivate:"https://testnet.binancefuture.com/dapi/v1",eapiPublic:"https://testnet.binanceops.com/eapi/v1",eapiPrivate:"https://testnet.binanceops.com/eapi/v1",fapiPublic:"https://testnet.binancefuture.com/fapi/v1",fapiPrivate:"https://testnet.binancefuture.com/fapi/v1",fapiPrivateV2:"https://testnet.binancefuture.com/fapi/v2",public:"https://testnet.binance.vision/api/v3",private:"https://testnet.binance.vision/api/v3",v1:"https://testnet.binance.vision/api/v1"},api:{wapi:"https://api.binance.com/wapi/v3",sapi:"https://api.binance.com/sapi/v1",sapiV3:"https://api.binance.com/sapi/v3",dapiPublic:"https://dapi.binance.com/dapi/v1",dapiPrivate:"https://dapi.binance.com/dapi/v1",eapiPublic:"https://eapi.binance.com/eapi/v1",eapiPrivate:"https://eapi.binance.com/eapi/v1",dapiPrivateV2:"https://dapi.binance.com/dapi/v2",dapiData:"https://dapi.binance.com/futures/data",fapiPublic:"https://fapi.binance.com/fapi/v1",fapiPrivate:"https://fapi.binance.com/fapi/v1",fapiData:"https://fapi.binance.com/futures/data",fapiPrivateV2:"https://fapi.binance.com/fapi/v2",public:"https://api.binance.com/api/v3",private:"https://api.binance.com/api/v3",v1:"https://api.binance.com/api/v1"},www:"https://www.binance.com",referral:{url:"https://accounts.binance.com/en/register?ref=D7YA7CLY",discount:.1},doc:["https://binance-docs.github.io/apidocs/spot/en"],api_management:"https://www.binance.com/en/usercenter/settings/api-management",fees:"https://www.binance.com/en/fee/schedule"},depth:1,api:{sapi:{get:{"system/status":.1,accountSnapshot:240,"margin/asset":1,"margin/pair":1,"margin/allAssets":.1,"margin/allPairs":.1,"margin/priceIndex":1,"asset/assetDividend":1,"asset/dribblet":.1,"asset/transfer":.1,"asset/assetDetail":.1,"asset/tradeFee":.1,"asset/ledger-transfer/cloud-mining/queryByPage":4,"margin/loan":1,"margin/repay":1,"margin/account":1,"margin/transfer":.1,"margin/interestHistory":.1,"margin/forceLiquidationRec":.1,"margin/order":1,"margin/openOrders":1,"margin/allOrders":20,"margin/myTrades":1,"margin/maxBorrowable":5,"margin/maxTransferable":5,"margin/tradeCoeff":1,"margin/isolated/transfer":.1,"margin/isolated/account":1,"margin/isolated/pair":1,"margin/isolated/allPairs":1,"margin/isolated/accountLimit":.1,"margin/interestRateHistory":.1,"margin/orderList":1,"margin/allOrderList":20,"margin/openOrderList":1,"margin/crossMarginData":{cost:.1,noCoin:.5},"margin/isolatedMarginData":{cost:.1,noCoin:1},"margin/isolatedMarginTier":.1,"margin/rateLimit/order":2,"margin/dribblet":.1,"loan/income":40,"loan/ongoing/orders":40,"loan/ltv/adjustment/history":40,"loan/borrow/history":40,"loan/repay/history":40,"loan/loanable/data":40,"loan/collateral/data":40,"loan/repay/collateral/rate":600,"loan/vip/ongoing/orders":40,"loan/vip/repay/history":40,"fiat/orders":600.03,"fiat/payments":.1,"futures/transfer":1,"futures/loan/borrow/history":1,"futures/loan/repay/history":1,"futures/loan/wallet":1,"futures/loan/adjustCollateral/history":1,"futures/loan/liquidationHistory":1,"rebate/taxQuery":20.001,"capital/config/getall":1,"capital/deposit/address":1,"capital/deposit/hisrec":.1,"capital/deposit/subAddress":.1,"capital/deposit/subHisrec":.1,"capital/withdraw/history":.1,"convert/tradeFlow":.6667,"convert/exchangeInfo":50,"convert/assetInfo":10,"convert/orderStatus":.6667,"account/status":.1,"account/apiTradingStatus":.1,"account/apiRestrictions/ipRestriction":.1,bnbBurn:.1,"sub-account/futures/account":1,"sub-account/futures/accountSummary":.1,"sub-account/futures/positionRisk":1,"sub-account/futures/internalTransfer":.1,"sub-account/list":.1,"sub-account/margin/account":1,"sub-account/margin/accountSummary":1,"sub-account/spotSummary":.1,"sub-account/status":1,"sub-account/sub/transfer/history":.1,"sub-account/transfer/subUserHistory":.1,"sub-account/universalTransfer":.1,"sub-account/apiRestrictions/ipRestriction/thirdPartyList":1,"managed-subaccount/asset":.1,"managed-subaccount/accountSnapshot":240,"lending/daily/product/list":.1,"lending/daily/userLeftQuota":.1,"lending/daily/userRedemptionQuota":.1,"lending/daily/token/position":.1,"lending/union/account":.1,"lending/union/purchaseRecord":.1,"lending/union/redemptionRecord":.1,"lending/union/interestHistory":.1,"lending/project/list":.1,"lending/project/position/list":.1,"mining/pub/algoList":.1,"mining/pub/coinList":.1,"mining/worker/detail":.5,"mining/worker/list":.5,"mining/payment/list":.5,"mining/statistics/user/status":.5,"mining/statistics/user/list":.5,"mining/payment/uid":.5,"bswap/pools":.1,"bswap/liquidity":{cost:.1,noPoolId:1},"bswap/liquidityOps":20.001,"bswap/quote":1.00005,"bswap/swap":20.001,"bswap/poolConfigure":1.00005,"bswap/addLiquidityPreview":1.00005,"bswap/removeLiquidityPreview":1.00005,"bswap/unclaimedRewards":6.667,"bswap/claimedHistory":6.667,"blvt/tokenInfo":.1,"blvt/subscribe/record":.1,"blvt/redeem/record":.1,"blvt/userLimit":.1,"apiReferral/ifNewUser":1,"apiReferral/customization":1,"apiReferral/userCustomization":1,"apiReferral/rebate/recentRecord":1,"apiReferral/rebate/historicalRecord":1,"apiReferral/kickback/recentRecord":1,"apiReferral/kickback/historicalRecord":1,"broker/subAccountApi":1,"broker/subAccount":1,"broker/subAccountApi/commission/futures":1,"broker/subAccountApi/commission/coinFutures":1,"broker/info":1,"broker/transfer":1,"broker/transfer/futures":1,"broker/rebate/recentRecord":1,"broker/rebate/historicalRecord":1,"broker/subAccount/bnbBurn/status":1,"broker/subAccount/depositHist":1,"broker/subAccount/spotSummary":1,"broker/subAccount/marginSummary":1,"broker/subAccount/futuresSummary":1,"broker/rebate/futures/recentRecord":1,"broker/subAccountApi/ipRestriction":1,"broker/universalTransfer":1,"account/apiRestrictions":.1,"c2c/orderMatch/listUserOrderHistory":.1,"nft/history/transactions":20.001,"nft/history/deposit":20.001,"nft/history/withdraw":20.001,"nft/user/getAsset":20.001,"pay/transactions":20.001,"giftcard/verify":.1,"giftcard/cryptography/rsa-public-key":.1,"giftcard/buyCode/token-limit":.1,"algo/futures/openOrders":.1,"algo/futures/historicalOrders":.1,"algo/futures/subOrders":.1,"portfolio/account":.1,"portfolio/collateralRate":5,"portfolio/pmLoan":3.3335,"staking/productList":.1,"staking/position":.1,"staking/stakingRecord":.1,"staking/personalLeftQuota":.1},post:{"asset/dust":1,"asset/dust-btc":.1,"asset/transfer":.1,"asset/get-funding-asset":.1,"asset/convert-transfer":.033335,"asset/convert-transfer/queryByPage":.033335,"account/disableFastWithdrawSwitch":.1,"account/enableFastWithdrawSwitch":.1,"capital/withdraw/apply":4.0002,"margin/transfer":1,"margin/loan":20.001,"margin/repay":20.001,"margin/order":.040002,"margin/order/oco":.040002,"margin/isolated/transfer":4.0002,"margin/isolated/account":2.0001,bnbBurn:.1,"sub-account/virtualSubAccount":.1,"sub-account/margin/transfer":4.0002,"sub-account/margin/enable":.1,"sub-account/futures/enable":.1,"sub-account/futures/transfer":.1,"sub-account/futures/internalTransfer":.1,"sub-account/transfer/subToSub":.1,"sub-account/transfer/subToMaster":.1,"sub-account/universalTransfer":.1,"managed-subaccount/deposit":.1,"managed-subaccount/withdraw":.1,userDataStream:.1,"userDataStream/isolated":.1,"futures/transfer":.1,"lending/customizedFixed/purchase":.1,"lending/daily/purchase":.1,"lending/daily/redeem":.1,"bswap/liquidityAdd":60,"bswap/liquidityRemove":60,"bswap/swap":60,"bswap/claimRewards":6.667,"blvt/subscribe":.1,"blvt/redeem":.1,"apiReferral/customization":1,"apiReferral/userCustomization":1,"apiReferral/rebate/historicalRecord":1,"apiReferral/kickback/historicalRecord":1,"broker/subAccount":1,"broker/subAccount/margin":1,"broker/subAccount/futures":1,"broker/subAccountApi":1,"broker/subAccountApi/permission":1,"broker/subAccountApi/commission":1,"broker/subAccountApi/commission/futures":1,"broker/subAccountApi/commission/coinFutures":1,"broker/transfer":1,"broker/transfer/futures":1,"broker/rebate/historicalRecord":1,"broker/subAccount/bnbBurn/spot":1,"broker/subAccount/bnbBurn/marginInterest":1,"broker/subAccount/blvt":1,"broker/subAccountApi/ipRestriction":1,"broker/subAccountApi/ipRestriction/ipList":1,"broker/universalTransfer":1,"broker/subAccountApi/permission/universalTransfer":1,"broker/subAccountApi/permission/vanillaOptions":1,"giftcard/createCode":.1,"giftcard/redeemCode":.1,"giftcard/buyCode":.1,"algo/futures/newOrderVp":20.001,"algo/futures/newOrderTwap":20.001,"staking/purchase":.1,"staking/redeem":.1,"staking/setAutoStaking":.1,"portfolio/repay":20.001,"loan/borrow":40,"loan/repay":40,"loan/adjust/ltv":40,"loan/customize/margin_call":40,"loan/vip/repay":40,"convert/getQuote":20.001,"convert/acceptQuote":3.3335},put:{userDataStream:.1,"userDataStream/isolated":.1},delete:{"margin/openOrders":.1,"margin/order":.0066667,"margin/orderList":.0066667,"margin/isolated/account":2.0001,userDataStream:.1,"userDataStream/isolated":.1,"broker/subAccountApi":1,"broker/subAccountApi/ipRestriction/ipList":1,"algo/futures/order":.1}},sapiV3:{get:{"sub-account/assets":1},post:{"asset/getUserAsset":.5}},wapi:{post:{withdraw:1,"sub-account/transfer":1},get:{depositHistory:1,withdrawHistory:1,depositAddress:1,accountStatus:1,systemStatus:1,apiTradingStatus:1,userAssetDribbletLog:1,tradeFee:1,assetDetail:1,"sub-account/list":1,"sub-account/transfer/history":1,"sub-account/assets":1}},dapiPublic:{get:{ping:1,time:1,exchangeInfo:1,depth:{cost:2,byLimit:[[50,2],[100,5],[500,10],[1e3,20]]},trades:5,historicalTrades:20,aggTrades:20,premiumIndex:10,fundingRate:1,klines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},continuousKlines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},indexPriceKlines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},markPriceKlines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},"ticker/24hr":{cost:1,noSymbol:40},"ticker/price":{cost:1,noSymbol:2},"ticker/bookTicker":{cost:1,noSymbol:2},openInterest:1,pmExchangeInfo:1}},dapiData:{get:{openInterestHist:1,topLongShortAccountRatio:1,topLongShortPositionRatio:1,globalLongShortAccountRatio:1,takerBuySellVol:1,basis:1}},dapiPrivate:{get:{"positionSide/dual":30,order:1,openOrder:1,openOrders:{cost:1,noSymbol:5},allOrders:{cost:20,noSymbol:40},balance:1,account:5,"positionMargin/history":1,positionRisk:1,userTrades:{cost:20,noSymbol:40},income:20,leverageBracket:1,forceOrders:{cost:20,noSymbol:50},adlQuantile:5,orderAmendment:1,pmAccountInfo:5},post:{"positionSide/dual":1,order:4,batchOrders:5,countdownCancelAll:10,leverage:1,marginType:1,positionMargin:1,listenKey:1},put:{listenKey:1,order:1,batchOrders:5},delete:{order:1,allOpenOrders:1,batchOrders:5,listenKey:1}},dapiPrivateV2:{get:{leverageBracket:1}},fapiPublic:{get:{ping:1,time:1,exchangeInfo:1,depth:{cost:2,byLimit:[[50,2],[100,5],[500,10],[1e3,20]]},trades:5,historicalTrades:20,aggTrades:20,klines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},continuousKlines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},markPriceKlines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},indexPriceKlines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},fundingRate:1,premiumIndex:1,"ticker/24hr":{cost:1,noSymbol:40},"ticker/price":{cost:1,noSymbol:2},"ticker/bookTicker":{cost:1,noSymbol:2},openInterest:1,indexInfo:1,apiTradingStatus:{cost:1,noSymbol:10},lvtKlines:1,pmExchangeInfo:1}},fapiData:{get:{openInterestHist:1,topLongShortAccountRatio:1,topLongShortPositionRatio:1,globalLongShortAccountRatio:1,takerlongshortRatio:1}},fapiPrivate:{get:{forceOrders:{cost:20,noSymbol:50},allOrders:5,openOrder:1,openOrders:1,order:1,account:5,balance:5,leverageBracket:1,"positionMargin/history":1,positionRisk:5,"positionSide/dual":30,userTrades:5,income:30,commissionRate:20,apiTradingStatus:1,multiAssetsMargin:30,"apiReferral/ifNewUser":1,"apiReferral/customization":1,"apiReferral/userCustomization":1,"apiReferral/traderNum":1,"apiReferral/overview":1,"apiReferral/tradeVol":1,"apiReferral/rebateVol":1,"apiReferral/traderSummary":1,adlQuantile:5,pmAccountInfo:5},post:{batchOrders:5,"positionSide/dual":1,positionMargin:1,marginType:1,order:4,leverage:1,listenKey:1,countdownCancelAll:10,multiAssetsMargin:1,"apiReferral/customization":1,"apiReferral/userCustomization":1},put:{listenKey:1},delete:{batchOrders:1,order:1,allOpenOrders:1,listenKey:1}},fapiPrivateV2:{get:{account:1,balance:1,positionRisk:1}},eapiPublic:{get:{ping:1,time:1,exchangeInfo:1,index:1,ticker:5,mark:5,depth:1,klines:1,trades:5,historicalTrades:20,exerciseHistory:3,openInterest:3}},eapiPrivate:{get:{account:3,position:5,openOrders:{cost:1,noSymbol:40},historyOrders:3,userTrades:5,exerciseRecord:5,bill:1,marginAccount:3,mmp:1,countdownCancelAll:1},post:{transfer:1,order:1,batchOrders:5,listenKey:1,mmpSet:1,mmpReset:1,countdownCancelAll:1,countdownCancelAllHeartBeat:10},put:{listenKey:1},delete:{order:1,batchOrders:1,allOpenOrders:1,allOpenOrdersByUnderlying:1,listenKey:1}},public:{get:{ping:1,time:1,depth:{cost:1,byLimit:[[100,1],[500,5],[1e3,10],[5e3,50]]},trades:1,aggTrades:1,historicalTrades:5,klines:1,"ticker/24hr":{cost:1,noSymbol:40},"ticker/price":{cost:1,noSymbol:2},"ticker/bookTicker":{cost:1,noSymbol:2},exchangeInfo:10},put:{userDataStream:1},post:{userDataStream:1},delete:{userDataStream:1}},private:{get:{allOrderList:10,openOrderList:3,orderList:2,order:2,openOrders:{cost:3,noSymbol:40},allOrders:10,account:10,myTrades:10,"rateLimit/order":20},post:{"order/oco":1,order:1,"order/test":1},delete:{openOrders:1,orderList:1,order:1}}},fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0.001")},future:{trading:{feeSide:"quote",tierBased:!0,percentage:!0,taker:this.parseNumber("0.000400"),maker:this.parseNumber("0.000200"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.000400")],[this.parseNumber("250"),this.parseNumber("0.000400")],[this.parseNumber("2500"),this.parseNumber("0.000350")],[this.parseNumber("7500"),this.parseNumber("0.000320")],[this.parseNumber("22500"),this.parseNumber("0.000300")],[this.parseNumber("50000"),this.parseNumber("0.000270")],[this.parseNumber("100000"),this.parseNumber("0.000250")],[this.parseNumber("200000"),this.parseNumber("0.000220")],[this.parseNumber("400000"),this.parseNumber("0.000200")],[this.parseNumber("750000"),this.parseNumber("0.000170")]],maker:[[this.parseNumber("0"),this.parseNumber("0.000200")],[this.parseNumber("250"),this.parseNumber("0.000160")],[this.parseNumber("2500"),this.parseNumber("0.000140")],[this.parseNumber("7500"),this.parseNumber("0.000120")],[this.parseNumber("22500"),this.parseNumber("0.000100")],[this.parseNumber("50000"),this.parseNumber("0.000080")],[this.parseNumber("100000"),this.parseNumber("0.000060")],[this.parseNumber("200000"),this.parseNumber("0.000040")],[this.parseNumber("400000"),this.parseNumber("0.000020")],[this.parseNumber("750000"),this.parseNumber("0")]]}}},delivery:{trading:{feeSide:"base",tierBased:!0,percentage:!0,taker:this.parseNumber("0.000500"),maker:this.parseNumber("0.000100"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.000500")],[this.parseNumber("250"),this.parseNumber("0.000450")],[this.parseNumber("2500"),this.parseNumber("0.000400")],[this.parseNumber("7500"),this.parseNumber("0.000300")],[this.parseNumber("22500"),this.parseNumber("0.000250")],[this.parseNumber("50000"),this.parseNumber("0.000240")],[this.parseNumber("100000"),this.parseNumber("0.000240")],[this.parseNumber("200000"),this.parseNumber("0.000240")],[this.parseNumber("400000"),this.parseNumber("0.000240")],[this.parseNumber("750000"),this.parseNumber("0.000240")]],maker:[[this.parseNumber("0"),this.parseNumber("0.000100")],[this.parseNumber("250"),this.parseNumber("0.000080")],[this.parseNumber("2500"),this.parseNumber("0.000050")],[this.parseNumber("7500"),this.parseNumber("0.0000030")],[this.parseNumber("22500"),this.parseNumber("0")],[this.parseNumber("50000"),this.parseNumber("-0.000050")],[this.parseNumber("100000"),this.parseNumber("-0.000060")],[this.parseNumber("200000"),this.parseNumber("-0.000070")],[this.parseNumber("400000"),this.parseNumber("-0.000080")],[this.parseNumber("750000"),this.parseNumber("-0.000090")]]}}},option:{}},commonCurrencies:{BCC:"BCC",YOYO:"YOYOW"},precisionMode:y4,options:{fetchCurrencies:!0,defaultTimeInForce:"GTC",defaultType:"spot",hasAlreadyAuthenticatedSuccessfully:!1,warnOnFetchOpenOrdersWithoutSymbol:!0,throwMarginModeAlreadySet:!1,fetchPositions:"positionRisk",recvWindow:10*1e3,timeDifference:0,adjustForTimeDifference:!1,newOrderRespType:{market:"FULL",limit:"FULL"},quoteOrderQty:!0,broker:{spot:"x-R4BD3S82",margin:"x-R4BD3S82",future:"x-xcKtGhcu",delivery:"x-xcKtGhcu"},accountsByType:{main:"MAIN",spot:"MAIN",funding:"FUNDING",margin:"MARGIN",cross:"MARGIN",future:"UMFUTURE",delivery:"CMFUTURE"},accountsById:{MAIN:"spot",FUNDING:"funding",MARGIN:"margin",UMFUTURE:"future",CMFUTURE:"delivery"},networks:{ERC20:"ETH",TRC20:"TRX",BEP2:"BNB",BEP20:"BSC",OMNI:"OMNI",EOS:"EOS",SPL:"SOL"},reverseNetworks:{"tronscan.org":"TRC20","etherscan.io":"ERC20","bscscan.com":"BSC","explorer.binance.org":"BEP2","bithomp.com":"XRP","bloks.io":"EOS","stellar.expert":"XLM","blockchair.com/bitcoin":"BTC","blockchair.com/bitcoin-cash":"BCH","blockchair.com/ecash":"XEC","explorer.litecoin.net":"LTC","explorer.avax.network":"AVAX","solscan.io":"SOL","polkadot.subscan.io":"DOT","dashboard.internetcomputer.org":"ICP","explorer.chiliz.com":"CHZ","cardanoscan.io":"ADA","mainnet.theoan.com":"AION","algoexplorer.io":"ALGO","explorer.ambrosus.com":"AMB","viewblock.io/zilliqa":"ZIL","viewblock.io/arweave":"AR","explorer.ark.io":"ARK","atomscan.com":"ATOM","www.mintscan.io":"CTK","explorer.bitcoindiamond.org":"BCD","btgexplorer.com":"BTG","bts.ai":"BTS","explorer.celo.org":"CELO","explorer.nervos.org":"CKB","cerebro.cortexlabs.ai":"CTXC","chainz.cryptoid.info":"VIA","explorer.dcrdata.org":"DCR","digiexplorer.info":"DGB","dock.subscan.io":"DOCK","dogechain.info":"DOGE","explorer.elrond.com":"EGLD","blockscout.com":"ETC","explore-fetchhub.fetch.ai":"FET","filfox.info":"FIL","fio.bloks.io":"FIO","explorer.firo.org":"FIRO","neoscan.io":"NEO","ftmscan.com":"FTM","explorer.gochain.io":"GO","block.gxb.io":"GXS","hash-hash.info":"HBAR","www.hiveblockexplorer.com":"HIVE","explorer.helium.com":"HNT","tracker.icon.foundation":"ICX","www.iostabc.com":"IOST","explorer.iota.org":"IOTA","iotexscan.io":"IOTX","irishub.iobscan.io":"IRIS","kava.mintscan.io":"KAVA","scope.klaytn.com":"KLAY","kmdexplorer.io":"KMD","kusama.subscan.io":"KSM","explorer.lto.network":"LTO","polygonscan.com":"POLYGON","explorer.ont.io":"ONT","minaexplorer.com":"MINA","nanolooker.com":"NANO","explorer.nebulas.io":"NAS","explorer.nbs.plus":"NBS","explorer.nebl.io":"NEBL","nulscan.io":"NULS","nxscan.com":"NXS","explorer.harmony.one":"ONE","explorer.poa.network":"POA","qtum.info":"QTUM","explorer.rsk.co":"RSK","www.oasisscan.com":"ROSE","ravencoin.network":"RVN","sc.tokenview.com":"SC","secretnodes.com":"SCRT","explorer.skycoin.com":"SKY","steemscan.com":"STEEM","explorer.stacks.co":"STX","www.thetascan.io":"THETA","scan.tomochain.com":"TOMO","explore.vechain.org":"VET","explorer.vite.net":"VITE","www.wanscan.org":"WAN","wavesexplorer.com":"WAVES","wax.eosx.io":"WAXP","waltonchain.pro":"WTC","chain.nem.ninja":"XEM","verge-blockchain.info":"XVG","explorer.yoyow.org":"YOYOW","explorer.zcha.in":"ZEC","explorer.zensystem.io":"ZEN"},impliedNetworks:{ETH:{ERC20:"ETH"},TRX:{TRC20:"TRX"}},legalMoney:{MXN:!0,UGX:!0,SEK:!0,CHF:!0,VND:!0,AED:!0,DKK:!0,KZT:!0,HUF:!0,PEN:!0,PHP:!0,USD:!0,TRY:!0,EUR:!0,NGN:!0,PLN:!0,BRL:!0,ZAR:!0,KES:!0,ARS:!0,RUB:!0,AUD:!0,NOK:!0,CZK:!0,GBP:!0,UAH:!0,GHS:!0,HKD:!0,CAD:!0,INR:!0,JPY:!0,NZD:!0}},exceptions:{exact:{"System is under maintenance.":p4,"System abnormality":at,"You are not authorized to execute this request.":En,"API key does not exist":Ls,"Order would trigger immediately.":ff,"Stop price would trigger immediately.":ff,"Order would immediately match and take.":ff,"Account has insufficient balance for requested action.":Ut,"Rest API trading is not enabled.":Wd,"You don't have permission.":En,"Market is closed.":Wd,"Too many requests. Please try again later.":zd,"This action disabled is on this account.":Io,"This type of sub-account exceeds the maximum number limit":ge,"This symbol is not permitted for this account.":En,"-1000":Wd,"-1001":Wd,"-1002":Ls,"-1003":Kd,"-1004":zd,"-1005":En,"-1006":tS,"-1007":m4,"-1010":tS,"-1011":En,"-1013":Ms,"-1014":Ms,"-1015":Kd,"-1016":Wd,"-1020":ge,"-1021":l4,"-1022":Ls,"-1023":ge,"-1099":Ls,"-1100":ge,"-1101":ge,"-1102":ge,"-1103":ge,"-1104":ge,"-1105":ge,"-1106":ge,"-1108":ge,"-1109":Ls,"-1110":ge,"-1111":ge,"-1112":Ms,"-1113":ge,"-1114":ge,"-1115":ge,"-1116":ge,"-1117":ge,"-1118":ge,"-1119":ge,"-1120":ge,"-1121":Oo,"-1125":Ls,"-1127":ge,"-1128":ge,"-1130":ge,"-1131":ge,"-1136":ge,"-2008":Ls,"-2010":at,"-2011":eS,"-2013":eS,"-2014":Ls,"-2015":Ls,"-2016":ge,"-2018":Ut,"-2019":Ut,"-2020":g4,"-2021":ff,"-2022":Ms,"-2023":Ut,"-2024":Ut,"-2025":Ms,"-2026":Ms,"-2027":Ms,"-2028":Ut,"-3000":at,"-3001":Ls,"-3002":Oo,"-3003":ge,"-3004":at,"-3005":Ut,"-3006":Ut,"-3007":at,"-3008":Ut,"-3009":ge,"-3010":ge,"-3011":ge,"-3012":Ut,"-3013":ge,"-3014":Io,"-3015":ge,"-3016":ge,"-3017":at,"-3018":Io,"-3019":Io,"-3020":Ut,"-3021":ge,"-3022":Io,"-3023":ge,"-3024":at,"-3025":ge,"-3026":ge,"-3027":Oo,"-3028":Oo,"-3029":at,"-3036":Io,"-3037":at,"-3038":ge,"-3041":Ut,"-3042":ge,"-3043":ge,"-3044":zd,"-3045":at,"-3999":at,"-4001":ge,"-4002":ge,"-4003":ge,"-4004":Ls,"-4005":Kd,"-4006":ge,"-4007":ge,"-4008":ge,"-4010":ge,"-4011":ge,"-4012":ge,"-4013":Ls,"-4014":En,"-4015":at,"-4016":En,"-4017":En,"-4018":Oo,"-4019":Oo,"-4021":ge,"-4022":ge,"-4023":at,"-4024":Ut,"-4025":Ut,"-4026":Ut,"-4027":at,"-4028":ge,"-4029":ge,"-4030":at,"-4031":at,"-4032":at,"-4033":ge,"-4034":at,"-4035":En,"-4036":ge,"-4037":at,"-4038":at,"-4039":ge,"-4040":ge,"-4041":at,"-4042":at,"-4043":ge,"-4044":ge,"-4045":at,"-4046":Ls,"-4047":ge,"-5001":ge,"-5002":Ut,"-5003":Ut,"-5004":ge,"-5005":Ut,"-5006":ge,"-5007":ge,"-5008":Ut,"-5009":ge,"-5010":at,"-5011":ge,"-5012":at,"-5013":Ut,"-5021":ge,"-6001":ge,"-6003":ge,"-6004":at,"-6005":Ms,"-6006":ge,"-6007":ge,"-6008":ge,"-6009":Kd,"-6011":ge,"-6012":Ut,"-6013":at,"-6014":ge,"-6015":ge,"-6016":ge,"-6017":ge,"-6018":ge,"-6019":Ls,"-6020":ge,"-7001":ge,"-7002":ge,"-9000":Ut,"-10017":ge,"-11008":Ut,"-12014":Kd,"-13000":ge,"-13001":ge,"-13002":ge,"-13003":ge,"-13004":ge,"-13005":ge,"-13006":Ms,"-13007":Ls,"-21001":ge,"-21002":ge,"-21003":ge,100001003:ge},broad:{"has no operation privilege":En,MAX_POSITION:Ms}}})}costToPrecision(e,t){return this.decimalToPrecision(t,hf,this.markets[e].precision.quote,this.precisionMode,this.paddingMode)}currencyToPrecision(e,t,s=void 0){return this.safeValue(this.currencies[e],"precision")!==void 0?this.decimalToPrecision(t,hf,this.currencies[e].precision,this.precisionMode,this.paddingMode):this.numberToString(t)}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchTime(e={}){const t=this.safeString2(this.options,"fetchTime","defaultType","spot"),s=this.safeString(e,"type",t),i=this.omit(e,"type");let n="publicGetTime";s==="future"?n="fapiPublicGetTime":s==="delivery"&&(n="dapiPublicGetTime");const r=await this[n](i);return this.safeInteger(r,"serverTime")}async fetchCurrencies(e={}){if(!this.safeValue(this.options,"fetchCurrencies")||!this.checkRequiredCredentials(!1)||this.safeString(this.urls,"apiBackup")!==void 0)return;const i=await this.sapiGetCapitalConfigGetall(e),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"coin"),d=this.safeString(a,"name"),c=this.safeCurrencyCode(o);let u,h=!0,l=!0;const p=this.safeValue(a,"networkList",[]),m={};let g;for(let S=0;S<p.length;S++){const k=p[S],T=this.safeString(k,"network"),I=this.safeNumber(k,"withdrawFee"),_=this.safeValue(k,"depositEnable"),N=this.safeValue(k,"withdrawEnable");l=l||_,h=h||N,m[T]=I,(this.safeValue(k,"isDefault")||g===void 0)&&(g=I);const x=this.safeString(k,"withdrawIntegerMultiple");_e.stringEq(x,"0")||(u=u===void 0?x:_e.stringMin(u,x))}const y=this.safeValue(a,"trading"),b=h&&l&&y;let w;u!==void 0&&(w=this.parseNumber(this.numberToString(this.precisionFromString(u)))),n[c]={id:o,name:d,code:c,precision:w,info:a,active:b,deposit:l,withdraw:h,networks:p,fee:g,fees:m,limits:this.limits}}return n}async fetchMarkets(e={}){const t=this.safeString2(this.options,"fetchMarkets","defaultType","spot"),s=this.safeString(e,"type",t),i=this.omit(e,"type"),n=s==="spot",r=s==="margin",a=s==="future",o=s==="delivery";if(!n&&!r&&!a&&!o)throw new at(this.id+" does not support '"+s+"' type, set exchange.options['defaultType'] to 'spot', 'margin', 'delivery' or 'future'");let d="publicGetExchangeInfo";a?d="fapiPublicGetExchangeInfo":o&&(d="dapiPublicGetExchangeInfo");const c=await this[d](i);this.options.adjustForTimeDifference&&await this.loadTimeDifference();const u=this.safeValue(c,"symbols",[]),h=[];for(let l=0;l<u.length;l++){const p=u[l],m=this.safeString(p,"symbol"),g=this.safeStringLower(p,"symbol"),y=this.safeString(p,"baseAsset"),b=this.safeString(p,"quoteAsset"),w=this.safeString(p,"marginAsset"),S=this.safeCurrencyCode(y),k=this.safeCurrencyCode(b),T=this.safeCurrencyCode(w),I=a||o,_=this.safeString(p,"contractType"),N=I&&_!=="PERPETUAL";let M,x;N?(M=m,x=this.safeInteger(p,"deliveryDate")):M=S+"/"+k;const v=this.safeValue(p,"filters",[]),O=this.indexBy(v,"filterType"),A=this.safeString2(p,"status","contractStatus");let V,q=this.fees,R,H;I&&(V=this.safeNumber(p,"contractSize",this.parseNumber("1")),q=this.fees[s],R=T===k,H=T===S);let F=A==="TRADING";if(n){const j=this.safeValue(p,"permissions",[]);for(let X=0;X<j.length;X++)if(j[X]==="TRD_GRP_003"){F=!1;break}}const P=this.safeValue(p,"isMarginTradingAllowed",!1),E={id:m,lowercaseId:g,symbol:M,base:S,quote:k,settle:T,baseId:y,quoteId:b,settleId:w,type:s,spot:n,margin:n&&P,swap:a,future:a,delivery:o,option:!1,active:F,contract:I,linear:R,inverse:H,taker:q.trading.taker,maker:q.trading.maker,contractSize:V,expiry:x,expiryDatetime:this.iso8601(x),strike:void 0,optionType:void 0,precision:{amount:this.safeInteger(p,"quantityPrecision"),price:this.safeInteger(p,"pricePrecision"),base:this.safeInteger(p,"baseAssetPrecision"),quote:this.safeInteger(p,"quotePrecision")},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:p};if("PRICE_FILTER"in O){const j=this.safeValue(O,"PRICE_FILTER",{});E.limits.price={min:this.safeNumber(j,"minPrice"),max:this.safeNumber(j,"maxPrice")},E.precision.price=this.precisionFromString(j.tickSize)}if("LOT_SIZE"in O){const j=this.safeValue(O,"LOT_SIZE",{}),X=this.safeString(j,"stepSize");E.precision.amount=this.precisionFromString(X),E.limits.amount={min:this.safeNumber(j,"minQty"),max:this.safeNumber(j,"maxQty")}}if("MARKET_LOT_SIZE"in O){const j=this.safeValue(O,"MARKET_LOT_SIZE",{});E.limits.market={min:this.safeNumber(j,"minQty"),max:this.safeNumber(j,"maxQty")}}if("MIN_NOTIONAL"in O){const j=this.safeValue(O,"MIN_NOTIONAL",{});E.limits.cost.min=this.safeNumber2(j,"minNotional","notional")}h.push(E)}return h}parseBalanceHelper(e){const t=this.account();t.used=this.safeString(e,"locked"),t.free=this.safeString(e,"free");const s=this.safeString(e,"interest"),i=this.safeString(e,"borrowed");return t.debt=_e.stringAdd(i,s),t}parseBalance(e,t=void 0,s=void 0){const i={info:e};let n;const r=s==="isolated",a=t==="margin"||s==="cross";if(!r&&(t==="spot"||a)){n=this.safeInteger(e,"updateTime");const o=this.safeValue2(e,"balances","userAssets",[]);for(let d=0;d<o.length;d++){const c=o[d],u=this.safeString(c,"asset"),h=this.safeCurrencyCode(u),l=this.account();if(l.free=this.safeString(c,"free"),l.used=this.safeString(c,"locked"),a){const p=this.safeString(c,"borrowed"),m=this.safeString(c,"interest");l.debt=_e.stringAdd(p,m)}i[h]=l}}else if(r){const o=this.safeValue(e,"assets");for(let d=0;d<o.length;d++){const c=o[d],u=this.safeValue(c,"symbol"),h=this.safeSymbol(u),l=this.safeValue(c,"baseAsset",{}),p=this.safeValue(c,"quoteAsset",{}),m=this.safeCurrencyCode(this.safeString(l,"asset")),g=this.safeCurrencyCode(this.safeString(p,"asset")),y={};y[m]=this.parseBalanceHelper(l),y[g]=this.parseBalanceHelper(p),i[h]=this.safeBalance(y)}}else if(t==="savings"){const o=this.safeValue(e,"positionAmountVos",[]);for(let d=0;d<o.length;d++){const c=o[d],u=this.safeString(c,"asset"),h=this.safeCurrencyCode(u),l=this.account(),p=this.safeString(c,"amount");l.total=p,l.used=p,i[h]=l}}else if(t==="funding")for(let o=0;o<e.length;o++){const d=e[o],c=this.account(),u=this.safeString(d,"asset"),h=this.safeCurrencyCode(u);c.free=this.safeString(d,"free");const l=this.safeString(d,"freeze"),p=this.safeString(d,"withdrawing"),m=this.safeString(d,"locked");c.used=_e.stringAdd(l,_e.stringAdd(m,p)),i[h]=c}else{let o=e;Array.isArray(e)||(o=this.safeValue(e,"assets",[]));for(let d=0;d<o.length;d++){const c=o[d],u=this.safeString(c,"asset"),h=this.safeCurrencyCode(u),l=this.account();l.free=this.safeString(c,"availableBalance"),l.used=this.safeString(c,"initialMargin"),l.total=this.safeString2(c,"marginBalance","balance"),i[h]=l}}return i.timestamp=n,i.datetime=this.iso8601(n),r?i:this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString2(this.options,"fetchBalance","defaultType","spot"),s=this.safeString(e,"type",t),[i,n]=this.handleMarginModeAndParams("fetchBalance",e);let r="privateGetAccount";const a={};if(s==="future"){const c=this.safeValue(this.options,s,{}),u=this.safeValue(c,"fetchBalance",{});r=this.safeString(u,"method","fapiPrivateV2GetAccount")}else if(s==="delivery"){const c=this.safeValue(this.options,s,{}),u=this.safeValue(c,"fetchBalance",{});r=this.safeString(u,"method","dapiPrivateGetAccount")}else if(s==="margin"||i==="cross")r="sapiGetMarginAccount";else if(s==="savings")r="sapiGetLendingUnionAccount";else if(s==="funding")r="sapiPostAssetGetFundingAsset";else if(i==="isolated"){r="sapiGetMarginIsolatedAccount";const c=this.safeValue(e,"symbols");if(c!==void 0){let u="";if(this.isArray(c)){u=this.marketId(c[0]);for(let h=1;h<c.length;h++){const l=c[h],p=this.marketId(l);u+=","+p}}else u=c;a.symbols=u}}const o=this.omit(n,["type","symbols"]),d=await this[r](this.extend(a,o));return this.parseBalance(d,s,i)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit=t);let r="publicGetDepth";i.linear?r="fapiPublicGetDepth":i.inverse&&(r="dapiPublicGetDepth");const a=await this[r](this.extend(n,s)),o=this.safeInteger(a,"T"),d=this.parseOrderBook(a,e,o);return d.nonce=this.safeInteger(a,"lastUpdateId"),d}parseTicker(e,t=void 0){const s=this.safeInteger(e,"closeTime"),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.safeString(e,"lastPrice"),a="baseVolume"in e;let o,d;return a?(o=this.safeString(e,"baseVolume"),d=this.safeString(e,"volume")):(o=this.safeString(e,"volume"),d=this.safeString(e,"quoteVolume")),this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"highPrice"),low:this.safeString(e,"lowPrice"),bid:this.safeString(e,"bidPrice"),bidVolume:this.safeString(e,"bidQty"),ask:this.safeString(e,"askPrice"),askVolume:this.safeString(e,"askQty"),vwap:this.safeString(e,"weightedAvgPrice"),open:this.safeString(e,"openPrice"),close:r,last:r,previousClose:this.safeString(e,"prevClosePrice"),change:this.safeString(e,"priceChange"),percentage:this.safeString(e,"priceChangePercent"),average:void 0,baseVolume:o,quoteVolume:d,info:e},t)}async fetchStatus(e={}){const t=await this.sapiGetSystemStatus(e),s=this.safeString(t,"status");return{status:this.safeString({0:"ok",1:"maintenance"},s,s),updated:void 0,eta:void 0,url:void 0,info:t}}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let n="publicGetTicker24hr";s.linear?n="fapiPublicGetTicker24hr":s.inverse&&(n="dapiPublicGetTicker24hr");const r=await this[n](this.extend(i,t));if(Array.isArray(r)){const a=this.safeValue(r,0,{});return this.parseTicker(a,s)}return this.parseTicker(r,s)}async fetchBidsAsks(e=void 0,t={}){await this.loadMarkets();const s=this.safeString2(this.options,"fetchBidsAsks","defaultType","spot"),i=this.safeString(t,"type",s),n=this.omit(t,"type");let r;i==="future"?r="fapiPublicGetTickerBookTicker":i==="delivery"?r="dapiPublicGetTickerBookTicker":r="publicGetTickerBookTicker";const a=await this[r](n);return this.parseTickers(a,e)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=this.safeString2(this.options,"fetchTickers","defaultType","spot"),i=this.safeString(t,"type",s),n=this.omit(t,"type");let r;i==="future"?r="fapiPublicGetTicker24hr":i==="delivery"?r="dapiPublicGetTicker24hr":r="publicGetTicker24hr";const a=this.safeString(this.options,"fetchTickersMethod",r),o=await this[a](n);return this.parseTickers(o,e)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=500,o=1500,d=this.safeString(n,"price"),c=this.safeInteger(n,"until");n=this.omit(n,["price","until"]),i=i===void 0?a:Math.min(i,o);const u={interval:this.timeframes[t],limit:i};if(d==="index"?u.pair=r.id:u.symbol=r.id,s!==void 0&&(u.startTime=s,r.inverse&&s>0)){const p=this.parseTimeframe(t),m=this.sum(s,i*p*1e3-1),g=this.milliseconds();u.endTime=Math.min(g,m)}c!==void 0&&(u.endTime=c);let h="publicGetKlines";d==="mark"?r.inverse?h="dapiPublicGetMarkPriceKlines":h="fapiPublicGetMarkPriceKlines":d==="index"?r.inverse?h="dapiPublicGetIndexPriceKlines":h="fapiPublicGetIndexPriceKlines":r.linear?h="fapiPublicGetKlines":r.inverse&&(h="dapiPublicGetKlines");const l=await this[h](this.extend(u,n));return this.parseOHLCVs(l,r,t,s,i)}parseTrade(e,t=void 0){if("isDustTrade"in e)return this.parseDustTrade(e,t);const s=this.safeInteger2(e,"T","time"),i=this.safeString2(e,"p","price"),n=this.safeString2(e,"q","qty"),r=this.safeString2(e,"quoteQty","baseQty"),a=this.safeString(e,"symbol"),o=this.safeSymbol(a,t);let d=this.safeString2(e,"t","a");d=this.safeString2(e,"id","tradeId",d);let c;const u=this.safeString(e,"orderId"),h=this.safeValue2(e,"m","isBuyerMaker");let l;h!==void 0?c=h?"sell":"buy":"side"in e?c=this.safeStringLower(e,"side"):"isBuyer"in e&&(c=e.isBuyer?"buy":"sell");let p;return"commission"in e&&(p={cost:this.safeString(e,"commission"),currency:this.safeCurrencyCode(this.safeString(e,"commissionAsset"))}),"isMaker"in e&&(l=e.isMaker?"maker":"taker"),"maker"in e&&(l=e.maker?"maker":"taker"),this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:o,id:d,order:u,type:void 0,side:c,takerOrMaker:l,price:i,amount:n,cost:r,fee:p},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id},[a,o]=this.handleMarketTypeAndParams("fetchTrades",n,i);let d;a==="future"?n.linear?d="fapiPublicGetAggTrades":n.inverse&&(d="dapiPublicGetAggTrades"):a==="delivery"?d="dapiPublicGetAggTrades":d="publicGetAggTrades";let c=this.safeString(this.options,"fetchTradesMethod",d);c==="publicGetAggTrades"?a==="future"?n.linear?c="fapiPublicGetAggTrades":n.inverse&&(c="dapiPublicGetAggTrades"):a==="delivery"&&(c="dapiPublicGetAggTrades"):c==="publicGetHistoricalTrades"&&(a==="future"?n.linear?c="fapiPublicGetHistoricalTrades":n.inverse&&(c="dapiPublicGetHistoricalTrades"):a==="delivery"&&(c="dapiPublicGetHistoricalTrades")),t!==void 0&&(r.startTime=t,r.endTime=this.sum(t,36e5)),s!==void 0&&(r.limit=s);const u=await this[c](this.extend(r,o));return this.parseTrades(u,n,t,s)}parseOrderStatus(e){const t={NEW:"open",PARTIALLY_FILLED:"open",FILLED:"closed",CANCELED:"canceled",PENDING_CANCEL:"canceling",REJECTED:"rejected",EXPIRED:"expired"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString(e,"status")),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.safeString(e,"executedQty","0");let a,o;"time"in e?a=this.safeInteger(e,"time"):"transactTime"in e?a=this.safeInteger(e,"transactTime"):"updateTime"in e&&s==="open"&&(_e.stringGt(r,"0")?o=this.safeInteger(e,"updateTime"):a=this.safeInteger(e,"updateTime"));const d=this.safeString(e,"avgPrice"),c=this.safeString(e,"price"),u=this.safeString(e,"origQty");let h=this.safeString2(e,"cummulativeQuoteQty","cumQuote");h=this.safeString(e,"cumBase",h);const l=this.safeString(e,"orderId");let p=this.safeStringLower(e,"type");const m=this.safeStringLower(e,"side"),g=this.safeValue(e,"fills",[]),y=this.safeString(e,"clientOrderId");let b=this.safeString(e,"timeInForce");b==="GTX"&&(b="PO");const w=p==="limit_maker"||b==="PO";p==="limit_maker"&&(p="limit");const S=this.safeString(e,"stopPrice"),k=this.parseNumber(this.omitZero(S));return this.safeOrder({info:e,id:l,clientOrderId:y,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:o,symbol:n,type:p,timeInForce:b,postOnly:w,reduceOnly:this.safeValue(e,"reduceOnly"),side:m,price:c,stopPrice:k,amount:u,cost:h,average:d,filled:r,remaining:void 0,status:s,fee:void 0,trades:g},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeString2(this.options,"createOrder","defaultType","spot"),d=this.safeString(r,"type",o),c=this.safeString2(r,"newClientOrderId","clientOrderId"),u=this.safeValue(r,"postOnly",!1),[h,l]=this.handleMarginModeAndParams("createOrder",r),p={symbol:a.id,side:s.toUpperCase()};let m="privatePostOrder";d==="future"?m="fapiPrivatePostOrder":d==="delivery"?m="dapiPrivatePostOrder":(d==="margin"||h!==void 0)&&(m="sapiPostMarginOrder",this.safeValue(r,"reduceOnly")&&(p.sideEffectType="AUTO_REPAY",r=this.omit(r,"reduceOnly"))),(a.spot||d==="margin")&&(this.safeValue(l,"test",!1)&&(m+="Test"),u&&(t="LIMIT_MAKER"));const g=t.toUpperCase();let y=g;p.type=y;const b=this.safeNumber(l,"stopPrice");b!==void 0&&(y==="MARKET"?y=a.contract?"STOP_MARKET":"STOP_LOSS":y==="LIMIT"&&(y=a.contract?"STOP":"STOP_LOSS_LIMIT"));const w=this.safeValue(a.info,"orderTypes");if(!this.inArray(y,w))throw g!==y?new Ms(this.id+" stopPrice parameter is not allowed for "+e+" "+t+" orders"):new Ms(this.id+" "+t+" is not a valid order type for the "+e+" market");if(h==="isolated"&&(p.isIsolated=!0),c===void 0){const M=this.safeValue(this.options,"broker");if(M!==void 0){const x=this.safeString(M,d);x!==void 0&&(p.newClientOrderId=x+this.uuid22())}}else p.newClientOrderId=c;d==="spot"||d==="margin"?p.newOrderRespType=this.safeValue(this.options.newOrderRespType,t,"RESULT"):p.newOrderRespType="RESULT";let S=!1,k=!1,T=!1,I=!1;if(y==="MARKET")if(a.spot)if(this.safeValue(this.options,"quoteOrderQty",!0)){const x=this.safeValue2(l,"quoteOrderQty","cost"),v=a.precision.price;if(x!==void 0)p.quoteOrderQty=this.decimalToPrecision(x,hf,v,this.precisionMode);else if(n!==void 0){const O=this.numberToString(i),A=this.numberToString(n),V=_e.stringMul(O,A);p.quoteOrderQty=this.decimalToPrecision(V,hf,v,this.precisionMode)}else I=!0}else I=!0;else I=!0;else if(y==="LIMIT")k=!0,S=!0,I=!0;else if(y==="STOP_LOSS"||y==="TAKE_PROFIT")T=!0,I=!0,(a.linear||a.inverse)&&(k=!0);else if(y==="STOP_LOSS_LIMIT"||y==="TAKE_PROFIT_LIMIT")I=!0,T=!0,k=!0,S=!0;else if(y==="LIMIT_MAKER")k=!0,I=!0;else if(y==="STOP")I=!0,T=!0,k=!0;else if(y==="STOP_MARKET"||y==="TAKE_PROFIT_MARKET")this.safeValue(l,"closePosition")===void 0&&(I=!0),T=!0;else if(y==="TRAILING_STOP_MARKET"&&(I=!0,this.safeNumber(l,"callbackRate")===void 0))throw new Ms(this.id+" createOrder() requires a callbackRate extra param for a "+t+" order");if(I&&(p.quantity=this.amountToPrecision(e,i)),k){if(n===void 0)throw new Ms(this.id+" createOrder() requires a price argument for a "+t+" order");p.price=this.priceToPrecision(e,n)}if(S&&(p.timeInForce=this.options.defaultTimeInForce),T){if(b===void 0)throw new Ms(this.id+" createOrder() requires a stopPrice extra param for a "+t+" order");p.stopPrice=this.priceToPrecision(e,b)}const _=this.omit(r,["quoteOrderQty","cost","stopPrice","test","type","newClientOrderId","clientOrderId","postOnly"]),N=await this[m](this.extend(p,_));return this.parseOrder(N,a)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new ii(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=this.safeString2(this.options,"fetchOrder","defaultType","spot"),r=this.safeString(s,"type",n),[a,o]=this.handleMarginModeAndParams("fetchOrder",s),d={symbol:i.id};let c="privateGetOrder";r==="future"?c="fapiPrivateGetOrder":r==="delivery"?c="dapiPrivateGetOrder":(r==="margin"||a!==void 0)&&(c="sapiGetMarginOrder",a==="isolated"&&(d.isIsolated=!0));const u=this.safeValue2(s,"origClientOrderId","clientOrderId");u!==void 0?d.origClientOrderId=u:d.orderId=e;const h=this.omit(o,["type","clientOrderId","origClientOrderId"]),l=await this[c](this.extend(d,h));return this.parseOrder(l,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new ii(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=this.safeString2(this.options,"fetchOrders","defaultType","spot"),a=this.safeString(i,"type",r),[o,d]=this.handleMarginModeAndParams("fetchOrders",i),c={symbol:n.id};let u="privateGetAllOrders";a==="future"?u="fapiPrivateGetAllOrders":a==="delivery"?u="dapiPrivateGetAllOrders":(a==="margin"||o!==void 0)&&(u="sapiGetMarginAllOrders",o==="isolated"&&(c.isIsolated=!0)),t!==void 0&&(c.startTime=t),s!==void 0&&(c.limit=s);const h=this.omit(d,["type"]),l=await this[u](this.extend(c,h));return this.parseOrders(l,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r;const a={},[o,d]=this.handleMarginModeAndParams("fetchOpenOrders",i);if(e!==void 0){n=this.market(e),a.symbol=n.id;const l=this.safeString2(this.options,"fetchOpenOrders","defaultType","spot"),p="type"in n?n.type:l;r=this.safeString(d,"type",p)}else if(this.options.warnOnFetchOpenOrdersWithoutSymbol){const p=this.symbols.length,m=parseInt(p/2);throw new at(this.id+" fetchOpenOrders() WARNING: fetching open orders without specifying a symbol is rate-limited to one call per "+m.toString()+" seconds. Do not call this method frequently to avoid ban. Set "+this.id+'.options["warnOnFetchOpenOrdersWithoutSymbol"] = false to suppress this warning message.')}else{const l=this.safeString2(this.options,"fetchOpenOrders","defaultType","spot");r=this.safeString(d,"type",l)}const c=this.omit(d,"type");let u="privateGetOpenOrders";if(r==="future")u="fapiPrivateGetOpenOrders";else if(r==="delivery")u="dapiPrivateGetOpenOrders";else if((r==="margin"||o!==void 0)&&(u="sapiGetMarginOpenOrders",o==="isolated"&&(a.isIsolated=!0,e===void 0)))throw new ii(this.id+" fetchOpenOrders() requires a symbol argument for isolated markets");const h=await this[u](this.extend(a,c));return this.parseOrders(h,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n=await this.fetchOrders(e,t,s,i);return this.filterBy(n,"status","closed")}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new ii(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=this.safeString2(this.options,"cancelOrder","defaultType","spot"),r=this.safeString(s,"type",n),a=this.safeValue2(s,"origClientOrderId","clientOrderId"),[o,d]=this.handleMarginModeAndParams("cancelOrder",s),c={symbol:i.id};a===void 0?c.orderId=e:c.origClientOrderId=a;let u="privateDeleteOrder";if(r==="future")u="fapiPrivateDeleteOrder";else if(r==="delivery")u="dapiPrivateDeleteOrder";else if((r==="margin"||o!==void 0)&&(u="sapiDeleteMarginOrder",o==="isolated"&&(c.isIsolated=!0,t===void 0)))throw new ii(this.id+" cancelOrder() requires a symbol argument for isolated markets");const h=this.omit(d,["type","origClientOrderId","clientOrderId"]),l=await this[u](this.extend(c,h));return this.parseOrder(l,i)}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new ii(this.id+" cancelAllOrders () requires a symbol argument");await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=this.safeString2(this.options,"cancelAllOrders","defaultType","spot"),r=this.safeString(t,"type",n);t=this.omit(t,["type"]);const[a,o]=this.handleMarginModeAndParams("cancelAllOrders",t);let d="privateDeleteOpenOrders";r==="future"?d="fapiPrivateDeleteAllOpenOrders":r==="delivery"?d="dapiPrivateDeleteAllOpenOrders":(r==="margin"||a!==void 0)&&(d="sapiDeleteMarginOpenOrders",a==="isolated"&&(i.isIsolated=!0));const c=await this[d](this.extend(i,o));return Array.isArray(c)?this.parseOrders(c,s):c}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){if(t===void 0)throw new ii(this.id+" fetchOrderTrades() requires a symbol argument");await this.loadMarkets();const r=this.market(t),a=this.safeString(n,"type",r.type);if(n=this.omit(n,"type"),a!=="spot")throw new ni(this.id+" fetchOrderTrades() supports spot markets only");const o={orderId:e};return await this.fetchMyTrades(t,s,i,this.extend(o,n))}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new ii(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=this.safeString(i,"type",n.type);i=this.omit(i,"type");let o;const d=a==="future",c=a==="delivery";let u;[u,i]=this.handleMarginModeAndParams("fetchMyTrades",i),a==="spot"||a==="margin"?(o="privateGetMyTrades",(a==="margin"||u!==void 0)&&(o="sapiGetMarginMyTrades",u==="isolated"&&(r.isIsolated=!0))):d?o="fapiPrivateGetUserTrades":c&&(o="dapiPrivateGetUserTrades");let h=this.safeInteger2(i,"until","endTime");if(t!==void 0){const p=parseInt(t);r.startTime=p;const m=this.milliseconds(),g=7*24*60*60*1e3;m-p>=g&&h===void 0&&d&&(h=this.sum(p,g),h=Math.min(h,m))}h!==void 0&&(r.endTime=h,i=this.omit(i,["endTime","until"])),s!==void 0&&((a==="future"||a==="delivery")&&(s=Math.min(s,1e3)),r.limit=s);const l=await this[o](this.extend(r,i));return this.parseTrades(l,n,t,s)}async fetchMyDustTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.startTime=t,n.endTime=this.sum(t,7776e6));const r=await this.sapiGetAssetDribblet(this.extend(n,i)),a=this.safeValue(r,"userAssetDribblets",[]),o=this.safeInteger(r,"total",0),d=[];for(let u=0;u<o;u++){const h=this.safeValue(a[u],"userAssetDribbletDetails",[]);for(let l=0;l<h.length;l++)h[l].isDustTrade=!0,d.push(h[l])}const c=this.parseTrades(d,void 0,t,s);return this.filterBySinceLimit(c,t,s)}parseDustTrade(e,t=void 0){const s=this.safeString(e,"transId"),i=this.safeInteger(e,"operateTime"),n=this.safeString(e,"fromAsset"),r=this.safeCurrencyCode(n),o=this.currency("BNB").code,d=o+"/"+r;let c=!1;d in this.markets&&(c=!0);const u=this.safeString(e,"serviceChargeAmount"),h={currency:o,cost:this.parseNumber(u)};let l,p,m,g;c?(l=d,p=this.safeString(e,"transferedAmount"),m=this.safeString(e,"amount"),g="buy"):(l=r+"/"+o,p=this.safeString(e,"amount"),m=this.safeString(e,"transferedAmount"),g="sell");let y;m!==void 0&&p&&(y=_e.stringDiv(m,p));const b=void 0,w=this.parseNumber(p),S=this.parseNumber(y),k=this.parseNumber(m),T=void 0,I=void 0;return{id:b,timestamp:i,datetime:this.iso8601(i),symbol:l,order:s,type:T,takerOrMaker:I,side:g,amount:w,price:S,cost:k,fee:h,info:e}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r;const a={},o=this.safeValue(this.options,"legalMoney",{}),d=this.safeInteger(i,"until");if(e in o){e!==void 0&&(n=this.currency(e)),a.transactionType=0,t!==void 0&&(a.beginTime=t),d!==void 0&&(a.endTime=d);const c=await this.sapiGetFiatOrders(this.extend(a,i));r=this.safeValue(c,"data")}else{if(e!==void 0&&(n=this.currency(e),a.coin=n.id),t!==void 0){a.startTime=t;let c=this.sum(t,7776e6);d!==void 0&&(c=Math.min(c,d)),a.endTime=c}s!==void 0&&(a.limit=s),r=await this.sapiGetCapitalDepositHisrec(this.extend(a,i))}return this.parseTransactions(r,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeValue(this.options,"legalMoney",{}),r={};let a,o;if(e in n){e!==void 0&&(o=this.currency(e)),r.transactionType=1,t!==void 0&&(r.beginTime=t);const d=await this.sapiGetFiatOrders(this.extend(r,i));a=this.safeValue(d,"data")}else e!==void 0&&(o=this.currency(e),r.coin=o.id),t!==void 0&&(r.startTime=t,r.endTime=this.sum(t,7776e6)),s!==void 0&&(r.limit=s),a=await this.sapiGetCapitalWithdrawHistory(this.extend(r,i));return this.parseTransactions(a,o,t,s)}parseTransactionStatusByType(e,t=void 0){const s={deposit:{0:"pending",1:"ok",Processing:"pending",Failed:"failed",Successful:"ok",Refunding:"canceled",Refunded:"canceled","Refund Failed":"failed"},withdrawal:{0:"pending",1:"canceled",2:"pending",3:"failed",4:"pending",5:"failed",6:"ok",Processing:"pending",Failed:"failed",Successful:"ok",Refunding:"canceled",Refunded:"canceled","Refund Failed":"failed"}},i=this.safeValue(s,t,{});return this.safeString(i,e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"id","orderNo"),i=this.safeString(e,"address");let n=this.safeString(e,"addressTag");n!==void 0&&n.length<1&&(n=void 0);let r=this.safeString(e,"txId");r!==void 0&&r.indexOf("Internal transfer ")>=0&&(r=r.slice(18));const a=this.safeString2(e,"coin","fiatCurrency"),o=this.safeCurrencyCode(a,t);let d;const c=this.safeInteger2(e,"insertTime","createTime"),u=this.parse8601(this.safeString(e,"applyTime"));let h=this.safeString(e,"type");h===void 0&&(c!==void 0&&u===void 0?(h="deposit",d=c):c===void 0&&u!==void 0&&(h="withdrawal",d=u));const l=this.parseTransactionStatusByType(this.safeString(e,"status"),h),p=this.safeNumber(e,"amount"),m=this.safeNumber2(e,"transactionFee","totalFee");let g;m!==void 0&&(g={currency:o,cost:m});const y=this.safeInteger2(e,"successTime","updateTime");let b=this.safeInteger(e,"transferType");b!==void 0&&(b=!!b);const w=this.safeString(e,"network");return{info:e,id:s,txid:r,timestamp:d,datetime:this.iso8601(d),network:w,address:i,addressTo:i,addressFrom:void 0,tag:n,tagTo:n,tagFrom:void 0,type:h,amount:p,currency:o,status:l,updated:y,internal:b,fee:g}}parseTransferStatus(e){const t={CONFIRMED:"ok"};return this.safeString(t,e,e)}parseTransfer(e,t=void 0){const s=this.safeString(e,"tranId"),i=this.safeString(e,"asset"),n=this.safeCurrencyCode(i,t),r=this.safeNumber(e,"amount"),a=this.safeString(e,"type");let o,d;const c=this.safeValue(this.options,"accountsById",{});if(a!==void 0){const l=a.split("_");o=this.safeValue(l,0),d=this.safeValue(l,1),o=this.safeString(c,o,o),d=this.safeString(c,d,d)}const u=this.safeInteger(e,"timestamp"),h=this.parseTransferStatus(this.safeString(e,"status"));return{info:e,id:s,timestamp:u,datetime:this.iso8601(u),currency:n,amount:r,fromAccount:o,toAccount:d,status:h}}parseIncome(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeNumber(e,"income"),r=this.safeString(e,"asset"),a=this.safeCurrencyCode(r),o=this.safeString(e,"tranId"),d=this.safeInteger(e,"time");return{info:e,symbol:i,code:a,timestamp:d,datetime:this.iso8601(d),id:o,amount:n}}parseIncomes(e,t=void 0,s=void 0,i=void 0){const n=[];for(let a=0;a<e.length;a++){const o=e[a],d=this.parseIncome(o,t);n.push(d)}const r=this.sortBy(n,"timestamp");return this.filterBySinceLimit(r,s,i)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a={asset:r.id,amount:this.currencyToPrecision(e,t)};a.type=this.safeString(n,"type");let o="sapiPostAssetTransfer";if(a.type===void 0){const u=this.safeString(n,"symbol");u!==void 0&&(n=this.omit(n,"symbol"));let h=this.convertTypeToAccount(s).toUpperCase(),l=this.convertTypeToAccount(i).toUpperCase();if(h==="ISOLATED"){if(u===void 0)throw new ii(this.id+' transfer () requires params["symbol"] when fromAccount is '+s);h=this.marketId(u)}if(l==="ISOLATED"){if(u===void 0)throw new ii(this.id+' transfer () requires params["symbol"] when toAccount is '+i);l=this.marketId(u)}const p=this.safeValue(this.options,"accountsById",{}),m=!(h in p),g=!(l in p);if(m||g){const y=h==="UMFUTURE"||h==="CMFUTURE",b=l==="UMFUTURE"||l==="CMFUTURE",w=h==="MAIN",S=l==="MAIN";if((m||g)&&(y||b||(h==="MINING"||l==="MINING")||(h==="FUNDING"||l==="FUNDING")))throw new ge(this.id+" transfer () does not allow transfers between "+s+" and "+i);S&&m?(o="sapiPostMarginIsolatedTransfer",a.transFrom="ISOLATED_MARGIN",a.transTo="SPOT",a.symbol=h):w&&g?(o="sapiPostMarginIsolatedTransfer",a.transFrom="SPOT",a.transTo="ISOLATED_MARGIN",a.symbol=l):(m&&(a.fromSymbol=h,h="ISOLATEDMARGIN"),g&&(a.toSymbol=l,l="ISOLATEDMARGIN"),a.type=h+"_"+l)}else a.type=h+"_"+l}n=this.omit(n,"type");const d=await this[o](this.extend(a,n)),c=this.parseTransfer(d,r);return this.extend(c,{amount:t,currency:e,fromAccount:s,toAccount:i})}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r=this.safeString2(this.options,"fetchTransfers","defaultType","spot"),a=this.safeString(i,"fromAccount",r),o=a==="future"?"spot":"future",d=this.safeString(i,"toAccount",o);let c=this.safeString(i,"type");const u=this.safeValue(this.options,"accountsByType",{}),h=this.safeString(u,a),l=this.safeString(u,d);if(c===void 0){if(h===void 0){const y=Object.keys(u);throw new at(this.id+" fromAccount parameter must be one of "+y.join(", "))}if(l===void 0){const y=Object.keys(u);throw new at(this.id+" toAccount parameter must be one of "+y.join(", "))}c=h+"_"+l}const p={type:c};t!==void 0&&(p.startTime=t),s!==void 0&&(p.size=s);const m=await this.sapiGetAssetTransfer(this.extend(p,i)),g=this.safeValue(m,"rows",[]);return this.parseTransfers(g,n,t,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={coin:this.currency(e).id},n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper(t,"network");r=this.safeString(n,r,r),r!==void 0&&(i.network=r,t=this.omit(t,"network"));const a=await this.sapiGetCapitalDepositAddress(this.extend(i,t)),o=this.safeString(a,"address"),d=this.safeString(a,"url");let c;if(d!==void 0){const h=this.safeValue(this.options,"reverseNetworks",{}),l=d.split("/");let p=this.safeString(l,2);if(p==="blockchair.com"||p==="viewblock.io"){const g=this.safeString(l,3);g!==void 0&&(p=p+"/"+g)}c=this.safeString(h,p);const m=this.safeValue(this.options,"impliedNetworks",{ETH:{ERC20:"ETH"},TRX:{TRC20:"TRX"}});if(e in m){const g=this.safeValue(m,e,{});c=this.safeString(g,c,c)}}let u=this.safeString(a,"tag","");return u.length===0&&(u=void 0),this.checkAddress(o),{currency:e,address:o,tag:u,network:c,info:a}}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.sapiGetCapitalConfigGetall(t),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"coin"),o=this.safeCurrencyCode(a),d=this.safeValue(r,"networkList",[]);i[o]={};for(let c=0;c<d.length;c++){const u=d[c],h=this.safeString(u,"network"),l=this.safeCurrencyCode(h),p=this.safeNumber(u,"withdrawFee");i[o][l]=p}}return{withdraw:i,deposit:{},info:s}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={coin:r.id,address:s,amount:t};i!==void 0&&(a.addressTag=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeString(o,d,d),d!==void 0&&(a.network=d,n=this.omit(n,"network"));const c=await this.sapiPostCapitalWithdrawApply(this.extend(a,n));return this.parseTransaction(c,r)}parseTradingFee(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s);return{info:e,symbol:i,maker:this.safeNumber(e,"makerCommission"),taker:this.safeNumber(e,"takerCommission")}}async fetchTradingFee(e,t={}){await this.loadMarkets();const i={symbol:this.market(e).id},n=await this.sapiGetAssetTradeFee(this.extend(i,t)),r=this.safeValue(n,0,{});return this.parseTradingFee(r)}async fetchTradingFees(e={}){await this.loadMarkets();let t;const s=this.safeString2(this.options,"fetchTradingFees","defaultType","future"),i=this.safeString(e,"type",s),n=this.omit(e,"type");i==="spot"||i==="margin"?t="sapiGetAssetTradeFee":i==="future"?t="fapiPrivateGetAccount":i==="delivery"&&(t="dapiPrivateGetAccount");const r=await this[t](n);if(i==="spot"||i==="margin"){const a={};for(let o=0;o<r.length;o++){const d=this.parseTradingFee(r[o]),c=d.symbol;a[c]=d}return a}else if(i==="future"){const a=Object.keys(this.markets),o={},d=this.safeInteger(r,"feeTier"),c=this.fees[i].trading.tiers,u=c.maker[d][1],h=c.taker[d][1];for(let l=0;l<a.length;l++){const p=a[l];o[p]={info:{feeTier:d},symbol:p,maker:u,taker:h}}return o}else if(i==="delivery"){const a=Object.keys(this.markets),o={},d=this.safeInteger(r,"feeTier"),c=this.fees[i].trading.tiers,u=c.maker[d][1],h=c.taker[d][1];for(let l=0;l<a.length;l++){const p=a[l];o[p]={info:{feeTier:d},symbol:p,maker:u,taker:h}}return o}}async futuresTransfer(e,t,s,i={}){if(s<1||s>4)throw new ii(this.id+" type must be between 1 and 4");await this.loadMarkets();const n=this.currency(e),r={asset:n.id,amount:t,type:s},a=await this.sapiPostFuturesTransfer(this.extend(r,i));return this.parseTransfer(a,n)}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let n;if(s.linear)n="fapiPublicGetPremiumIndex";else if(s.inverse)n="dapiPublicGetPremiumIndex";else throw new ni(this.id+" fetchFundingRate() supports linear and inverse contracts only");let r=await this[n](this.extend(i,t));return s.inverse&&(r=r[0]),this.parseFundingRate(r,s)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;const a=this.safeString2(this.options,"fetchFundingRateHistory","defaultType","future"),o=this.safeString(i,"type",a);if(i=this.omit(i,"type"),o==="future"?r="fapiPublicGetFundingRate":o==="delivery"&&(r="dapiPublicGetFundingRate"),e!==void 0){const p=this.market(e);e=p.symbol,n.symbol=p.id,p.linear?r="fapiPublicGetFundingRate":p.inverse&&(r="dapiPublicGetFundingRate")}if(r===void 0)throw new ni(this.id+" fetchFundingRateHistory() is not supported for "+o+" markets");t!==void 0&&(n.startTime=t);const d=this.safeInteger2(i,"until","till"),c=this.safeInteger(i,"endTime",d);i=this.omit(i,["endTime","till","until"]),c!==void 0&&(n.endTime=c),s!==void 0&&(n.limit=s);const u=await this[r](this.extend(n,i)),h=[];for(let p=0;p<u.length;p++){const m=u[p],g=this.safeInteger(m,"fundingTime");h.push({info:m,symbol:this.safeSymbol(this.safeString(m,"symbol")),fundingRate:this.safeNumber(m,"fundingRate"),timestamp:g,datetime:this.iso8601(g)})}const l=this.sortBy(h,"timestamp");return this.filterBySymbolSinceLimit(l,e,t,s)}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s;const i=this.safeString2(this.options,"fetchFundingRates","defaultType","future"),n=this.safeString(t,"type",i),r=this.omit(t,"type");if(n==="future")s="fapiPublicGetPremiumIndex";else if(n==="delivery")s="dapiPublicGetPremiumIndex";else throw new ni(this.id+" fetchFundingRates() supports linear and inverse contracts only");const a=await this[s](r),o=[];for(let d=0;d<a.length;d++){const c=a[d],u=this.parseFundingRate(c);o.push(u)}return this.filterByArray(o,"symbol",e)}parseFundingRate(e,t=void 0){const s=this.safeInteger(e,"time"),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.safeNumber(e,"markPrice"),a=this.safeNumber(e,"indexPrice"),o=this.safeNumber(e,"interestRate"),d=this.safeNumber(e,"estimatedSettlePrice"),c=this.safeNumber(e,"lastFundingRate"),u=this.safeInteger(e,"nextFundingTime");return{info:e,symbol:n,markPrice:r,indexPrice:a,interestRate:o,estimatedSettlePrice:d,timestamp:s,datetime:this.iso8601(s),fundingRate:c,fundingTimestamp:u,fundingDatetime:this.iso8601(u),nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}parseAccountPositions(e){const t=this.safeValue(e,"positions"),s=this.safeValue(e,"assets",[]),i={};for(let r=0;r<s.length;r++){const a=s[r],o=this.safeString(a,"asset"),d=this.safeCurrencyCode(o),c=this.safeString(a,"crossWalletBalance"),u=this.safeString(a,"crossUnPnl");i[d]={crossMargin:_e.stringAdd(c,u),crossWalletBalance:c}}const n=[];for(let r=0;r<t.length;r++){const a=t[r],o=this.safeString(a,"symbol"),d=this.safeMarket(o),c=this.options.defaultType==="future"?d.quote:d.base;if(c in i){const u=this.parseAccountPosition(this.extend(a,{crossMargin:i[c].crossMargin,crossWalletBalance:i[c].crossWalletBalance}),d);n.push(u)}}return n}parseAccountPosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeString(t,"symbol"),n=this.safeString(e,"leverage"),r=parseInt(n),a=this.safeString(e,"initialMargin"),o=this.parseNumber(a);let d=_e.stringDiv("1",n,8);1e3%r===0||(d=_e.stringDiv(_e.stringAdd(d,"1e-8"),"1",8));const u="notional"in e,h=this.safeString(e,"maintMargin"),l=this.parseNumber(h),p=this.safeString(e,"entryPrice");let m=this.parseNumber(p);const g=this.safeString2(e,"notional","notionalValue"),y=_e.stringAbs(g),b=this.parseNumber(y);let w=this.safeString(e,"positionAmt"),S=_e.stringAbs(w);if(w===void 0){const xe=_e.stringMul(_e.stringMul(n,a),p),Ae=this.safeString(t,"contractSize");w=_e.stringDiv(xe,Ae),S=_e.stringDiv(_e.stringAdd(w,"0.5"),"1",0)}const k=this.parseNumber(S),T=this.safeValue(this.options,"leverageBrackets",{}),I=this.safeValue(T,i,[]);let _;for(let xe=0;xe<I.length;xe++){const Ae=I[xe];if(_e.stringLt(y,Ae[0]))break;_=Ae[1]}const N=this.parseNumber(_),M=this.safeString(e,"unrealizedProfit"),x=this.parseNumber(M);let v=this.safeInteger(e,"updateTime");v===0&&(v=void 0);const O=this.safeValue(e,"isolated");let A,V,q;O?(A="isolated",q=this.safeString(e,"isolatedWallet"),V=_e.stringAdd(q,M)):(A="cross",q=this.safeString(e,"crossWalletBalance"),V=this.safeString(e,"crossMargin"));const R=this.parseNumber(V);let H,F,P,E,j;const X=this.safeValue(t,"contractSize"),Q=this.numberToString(X);if(_e.stringEquals(g,"0"))m=void 0;else{if(F=_e.stringLt(g,"0")?"short":"long",H=this.parseNumber(_e.stringDiv(_e.stringAdd(_e.stringDiv(h,V),"5e-5"),"1",4)),P=this.parseNumber(_e.stringMul(_e.stringDiv(M,a,4),"100")),u){let G,U=p;F==="short"?G=_e.stringAdd("1",_):(G=_e.stringAdd("-1",_),U=_e.stringMul("-1",U));const W=_e.stringDiv(q,_e.stringMul(S,G)),J=_e.stringDiv(U,G);E=_e.stringAdd(W,J)}else{let G,U=p;F==="short"?G=_e.stringSub("1",_):(G=_e.stringSub("-1",_),U=_e.stringMul("-1",U));const W=_e.stringMul(S,Q),J=_e.stringMul(W,G),ee=_e.stringSub(_e.stringMul(_e.stringDiv("1",U),W),q);E=_e.stringDiv(J,ee)}const xe=t.precision.price,Re=(xe+1).toString(),qt=new _e("5e-"+Re).toString(),D=_e.stringAdd(qt,E);let $=_e.stringDiv(D,"1",xe);$[0]==="-"&&($=void 0),j=this.parseNumber($)}const he=this.safeString(e,"positionSide")!=="BOTH";return{info:e,id:void 0,symbol:i,timestamp:v,datetime:this.iso8601(v),initialMargin:o,initialMarginPercentage:this.parseNumber(d),maintenanceMargin:l,maintenanceMarginPercentage:N,entryPrice:m,notional:b,leverage:this.parseNumber(n),unrealizedPnl:x,contracts:k,contractSize:X,marginRatio:H,liquidationPrice:j,markPrice:void 0,collateral:R,marginMode:A,side:F,hedged:he,percentage:P}}parsePositionRisk(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeString(t,"symbol"),n=this.safeValue(this.options,"leverageBrackets",{}),r=this.safeValue(n,i,[]),a=this.safeString2(e,"notional","notionalValue"),o=_e.stringAbs(a);let d;for(let Se=0;Se<r.length;Se++){const he=r[Se];if(_e.stringLt(o,he[0]))break;d=he[1]}const c=this.parseNumber(o),u=_e.stringAbs(this.safeString(e,"positionAmt")),h=this.parseNumber(u),l=this.safeString(e,"unRealizedProfit"),p=this.parseNumber(l),m=this.safeString(e,"leverage"),g=parseInt(m),y=this.omitZero(this.safeString(e,"liquidationPrice")),b=this.parseNumber(y);let w;const S=this.safeString(e,"marginType");let k;_e.stringGt(a,"0")?k="long":_e.stringLt(a,"0")&&(k="short");const T=this.safeString(e,"entryPrice"),I=this.parseNumber(T),_=this.safeValue(t,"contractSize"),N=this.numberToString(_),M="notional"in e;if(S==="cross"){const Se=this.safeValue(t,"precision",{});if(M){let he,xe=T;k==="short"?(he=_e.stringAdd("1",d),xe=_e.stringMul("-1",xe)):he=_e.stringAdd("-1",d);const Ae=_e.stringMul(y,he),Re=_e.stringAdd(Ae,xe),He=this.safeInteger(Se,"price"),qt=this.safeInteger(Se,"quote",He);qt!==void 0&&(w=_e.stringDiv(_e.stringMul(Re,u),"1",qt))}else{let he,xe=T;k==="short"?he=_e.stringSub("1",d):(he=_e.stringSub("-1",d),xe=_e.stringMul("-1",xe));const Ae=_e.stringMul(u,N),Re=_e.stringSub(_e.stringDiv("1",xe),_e.stringDiv(he,y)),He=this.safeInteger(Se,"base");He!==void 0&&(w=_e.stringDiv(_e.stringMul(Ae,Re),"1",He))}}else w=this.safeString(e,"isolatedMargin");w=w===void 0?"0":w;const x=this.parseNumber(w),v=this.parseNumber(this.omitZero(this.safeString(e,"markPrice")));let O=this.safeInteger(e,"updateTime");O===0&&(O=void 0);const A=this.parseNumber(d),V=_e.stringMul(d,o),q=this.parseNumber(V);let R=_e.stringDiv("1",m,8);1e3%g===0||(R=_e.stringAdd(R,"1e-8"));const F=_e.stringDiv(_e.stringMul(o,R),"1",8),P=this.parseNumber(F);let E,j;_e.stringEquals(w,"0")||(E=this.parseNumber(_e.stringDiv(_e.stringAdd(_e.stringDiv(V,w),"5e-5"),"1",4)),j=this.parseNumber(_e.stringMul(_e.stringDiv(l,F,4),"100")));const Q=this.safeString(e,"positionSide")!=="BOTH";return{info:e,id:void 0,symbol:i,contracts:h,contractSize:_,unrealizedPnl:p,leverage:this.parseNumber(m),liquidationPrice:b,collateral:x,notional:c,markPrice:v,entryPrice:I,timestamp:O,initialMargin:P,initialMarginPercentage:this.parseNumber(R),maintenanceMargin:q,maintenanceMarginPercentage:A,marginRatio:E,datetime:this.iso8601(O),marginMode:S,marginType:S,side:k,hedged:Q,percentage:j}}async loadLeverageBrackets(e=!1,t={}){if(await this.loadMarkets(),this.safeValue(this.options,"leverageBrackets")===void 0||e){let i;const n=this.safeString(this.options,"defaultType","future"),r=this.safeString(t,"type",n),a=this.omit(t,"type");if(r==="future")i="fapiPrivateGetLeverageBracket";else if(r==="delivery")i="dapiPrivateV2GetLeverageBracket";else throw new ni(this.id+" loadLeverageBrackets() supports linear and inverse contracts only");const o=await this[i](a);this.options.leverageBrackets={};for(let d=0;d<o.length;d++){const c=o[d],u=this.safeString(c,"symbol"),h=this.safeSymbol(u),l=this.safeValue(c,"brackets",[]),p=[];for(let m=0;m<l.length;m++){const g=l[m],y=this.safeString2(g,"notionalFloor","qtyFloor"),b=this.safeString(g,"maintMarginRatio");p.push([y,b])}this.options.leverageBrackets[h]=p}}return this.options.leverageBrackets}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const[s,i]=this.handleMarketTypeAndParams("fetchLeverageTiers",void 0,t);let n;if(s==="future")n="fapiPrivateGetLeverageBracket";else if(s==="delivery")n="dapiPrivateV2GetLeverageBracket";else throw new ni(this.id+" fetchLeverageTiers() supports linear and inverse contracts only");const r=await this[n](i);return this.parseLeverageTiers(r,e,"symbol")}parseMarketLeverageTiers(e,t){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeValue(e,"brackets",[]),n=[];for(let r=0;r<i.length;r++){const a=i[r];n.push({tier:this.safeNumber(a,"bracket"),currency:t.quote,minNotional:this.safeNumber2(a,"notionalFloor","qtyFloor"),maxNotional:this.safeNumber2(a,"notionalCap","qtyCap"),maintenanceMarginRate:this.safeNumber(a,"maintMarginRatio"),maxLeverage:this.safeNumber(a,"initialLeverage"),info:a})}return n}async fetchPositions(e=void 0,t={}){const s=this.safeString(this.options,"fetchPositions","positionRisk");if(s==="positionRisk")return await this.fetchPositionsRisk(e,t);if(s==="account")return await this.fetchAccountPositions(e,t);throw new ni(this.id+'.options["fetchPositions"] = "'+s+'" is invalid, please choose between "account" and "positionRisk"')}async fetchAccountPositions(e=void 0,t={}){if(e!==void 0&&!Array.isArray(e))throw new ii(this.id+" fetchPositions() requires an array argument for symbols");await this.loadMarkets(),await this.loadLeverageBrackets(!1,t);let s;const i=this.safeString(this.options,"defaultType","future"),n=this.safeString(t,"type",i),r=this.omit(t,"type");if(n==="future")s="fapiPrivateGetAccount";else if(n==="delivery")s="dapiPrivateGetAccount";else throw new ni(this.id+" fetchPositions() supports linear and inverse contracts only");const a=await this[s](r),o=this.parseAccountPositions(a);return e=this.marketSymbols(e),this.filterByArray(o,"symbol",e,!1)}async fetchPositionsRisk(e=void 0,t={}){if(e!==void 0&&!Array.isArray(e))throw new ii(this.id+" fetchPositionsRisk() requires an array argument for symbols");await this.loadMarkets(),await this.loadLeverageBrackets(!1,t);const s={};let i,n="future";n=this.safeString(this.options,"defaultType",n);const r=this.safeString(t,"type",n);if(t=this.omit(t,"type"),r==="future"||r==="linear")i="fapiPrivateGetPositionRisk";else if(r==="delivery"||r==="inverse")i="dapiPrivateGetPositionRisk";else throw new ni(this.id+" fetchPositionsRisk() supports linear and inverse contracts only");const a=await this[i](this.extend(s,t)),o=[];for(let d=0;d<a.length;d++){const c=this.parsePositionRisk(a[d]);o.push(c)}return e=this.marketSymbols(e),this.filterByArray(o,"symbol",e,!1)}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r,a="future";const o={incomeType:"FUNDING_FEE"};if(e!==void 0)if(n=this.market(e),o.symbol=n.id,n.linear)a="future";else if(n.inverse)a="delivery";else throw new ni(this.id+" fetchFundingHistory() supports linear and inverse contracts only");t!==void 0&&(o.startTime=t),s!==void 0&&(o.limit=s),a=this.safeString2(this.options,"fetchFundingHistory","defaultType",a);const d=this.safeString(i,"type",a);if(i=this.omit(i,"type"),d==="future"||d==="linear")r="fapiPrivateGetIncome";else if(d==="delivery"||d==="inverse")r="dapiPrivateGetIncome";else throw new ni(this.id+" fetchFundingHistory() supports linear and inverse contracts only");const c=await this[r](this.extend(o,i));return this.parseIncomes(c,n,t,s)}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new ii(this.id+" setLeverage() requires a symbol argument");if(e<1||e>125)throw new ge(this.id+" leverage should be between 1 and 125");await this.loadMarkets();const i=this.market(t);let n;if(i.linear)n="fapiPrivatePostLeverage";else if(i.inverse)n="dapiPrivatePostLeverage";else throw new ni(this.id+" setLeverage() supports linear and inverse contracts only");const r={symbol:i.id,leverage:e};return await this[n](this.extend(r,s))}async setMarginMode(e,t=void 0,s={}){if(t===void 0)throw new ii(this.id+" setMarginMode() requires a symbol argument");if(e=e.toUpperCase(),e==="CROSS"&&(e="CROSSED"),e!=="ISOLATED"&&e!=="CROSSED")throw new ge(this.id+" marginMode must be either isolated or cross");await this.loadMarkets();const i=this.market(t);let n;if(i.linear)n="fapiPrivatePostMarginType";else if(i.inverse)n="dapiPrivatePostMarginType";else throw new ni(this.id+" setMarginMode() supports linear and inverse contracts only");const r={symbol:i.id,marginType:e};let a;try{a=await this[n](this.extend(r,s))}catch(o){if(o instanceof sS){if(this.safeValue(this.options,"throwMarginModeAlreadySet",!1))throw o;a={code:-4046,msg:"No need to change margin type."}}}return a}async setPositionMode(e,t=void 0,s={}){const i=this.safeString(this.options,"defaultType","future"),n=this.safeString(s,"type",i);s=this.omit(s,["type"]);let r;e?r="true":r="false";const a={dualSidePosition:r};let o;return n==="delivery"?o="dapiPrivatePostPositionSideDual":o="fapiPrivatePostPositionSideDual",await this[o](this.extend(a,s))}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){if(!(t in this.urls.api))throw new ni(this.id+" does not have a testnet/sandbox URL for "+t+" endpoints");let a=this.urls.api[t];if(a+="/"+e,t==="wapi"&&(a+=".html"),e==="historicalTrades")if(this.apiKey)n={"X-MBX-APIKEY":this.apiKey};else throw new Ls(this.id+" historicalTrades endpoint requires `apiKey` credential");if(e==="userDataStream"||e==="listenKey")if(this.apiKey)n={"X-MBX-APIKEY":this.apiKey,"Content-Type":"application/x-www-form-urlencoded"},s!=="GET"&&(r=this.urlencode(i));else throw new Ls(this.id+" userDataStream endpoint requires `apiKey` credential");else if(t==="private"||t==="eapiPrivate"||t==="sapi"&&e!=="system/status"||t==="sapiV3"||t==="wapi"&&e!=="systemStatus"||t==="dapiPrivate"||t==="dapiPrivateV2"||t==="fapiPrivate"||t==="fapiPrivateV2"){this.checkRequiredCredentials();let d;const c=this.safeInteger(this.options,"recvWindow"),u=this.extend({timestamp:this.nonce()},i);c!==void 0&&(u.recvWindow=c);const h=this.safeInteger(i,"recvWindow");h!==void 0&&(u.recvWindow=h),t==="sapi"&&e==="asset/dust"?d=this.urlencodeWithArrayRepeat(u):e==="batchOrders"||e.indexOf("sub-account")>=0||e==="capital/withdraw/apply"||e.indexOf("staking")>=0?d=this.rawencode(u):d=this.urlencode(u);const l=this.hmac(this.encode(d),this.encode(this.secret));d+="&signature="+l,n={"X-MBX-APIKEY":this.apiKey},s==="GET"||s==="DELETE"||t==="wapi"?a+="?"+d:(r=d,n["Content-Type"]="application/x-www-form-urlencoded")}else Object.keys(i).length&&(a+="?"+this.urlencode(i));return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(e===418||e===429)throw new zd(this.id+" "+e.toString()+" "+t+" "+r);if(e>=400){if(r.indexOf("Price * QTY is zero or less")>=0)throw new Ms(this.id+" order cost = amount * price is zero or less "+r);if(r.indexOf("LOT_SIZE")>=0)throw new Ms(this.id+" order amount should be evenly divisible by lot size "+r);if(r.indexOf("PRICE_FILTER")>=0)throw new Ms(this.id+" order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid value in general, use this.priceToPrecision (symbol, amount) "+r)}if(a===void 0)return;const c=this.safeValue(a,"success",!0);if(!c){const l=this.safeString(a,"msg");let p;if(l!==void 0){try{p=JSON.parse(l)}catch{p=void 0}p!==void 0&&(a=p)}}const u=this.safeString(a,"msg");u!==void 0&&(this.throwExactlyMatchedException(this.exceptions.exact,u,this.id+" "+u),this.throwBroadlyMatchedException(this.exceptions.broad,u,this.id+" "+u));const h=this.safeString(a,"code");if(h!==void 0){if(h==="200"||_e.stringEquals(h,"0"))return;if(h==="-2015"&&this.options.hasAlreadyAuthenticatedSuccessfully)throw new zd(this.id+" "+r);const l=this.id+" "+r;throw u==="No need to change margin type."?new sS(l):(this.throwExactlyMatchedException(this.exceptions.exact,h,l),new at(l))}if(!c)throw new at(this.id+" "+r)}calculateRateLimiterCost(e,t,s,i,n={},r={}){if("noCoin"in n&&!("coin"in i))return n.noCoin;if("noSymbol"in n&&!("symbol"in i))return n.noSymbol;if("noPoolId"in n&&!("poolId"in i))return n.noPoolId;if("byLimit"in n&&"limit"in i){const a=i.limit,o=n.byLimit;for(let d=0;d<o.length;d++){const c=o[d];if(a<=c[0])return c[1]}}return this.safeValue(n,"cost",1)}async request(e,t="public",s="GET",i={},n=void 0,r=void 0,a={},o={}){const d=await this.fetch2(e,t,s,i,n,r,a,o);return(t==="private"||t==="wapi")&&(this.options.hasAlreadyAuthenticatedSuccessfully=!0),d}async modifyMarginHelper(e,t,s,i={}){let n=this.safeString(this.options,"defaultType","future");n==="spot"&&(n="future");const r=this.safeString(i,"type",n);if(r==="margin"||r==="spot")throw new ni(this.id+" add / reduce margin only supported with type future or delivery");await this.loadMarkets();const a=this.market(e);t=this.amountToPrecision(e,t);const o={type:s,symbol:a.id,amount:t};let d,c;r==="future"?(d="fapiPrivatePostPositionMargin",c=a.quote):(d="dapiPrivatePostPositionMargin",c=a.base);const u=await this[d](this.extend(o,i));return this.extend(this.parseMarginModification(u,a),{code:c})}parseMarginModification(e,t=void 0){const i=this.safeInteger(e,"type")===1?"add":"reduce",n=this.safeNumber(e,"amount"),a=this.safeString(e,"code")==="200"?"ok":"failed";return{info:e,type:i,amount:n,code:void 0,symbol:t.symbol,status:a}}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,2,s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,1,s)}async fetchBorrowRate(e,t={}){await this.loadMarkets();const i={asset:this.currency(e).id},n=await this.sapiGetMarginInterestRateHistory(this.extend(i,t)),r=this.safeValue(n,0);return this.parseBorrowRate(r)}async fetchBorrowRateHistory(e,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),s===void 0)s=93;else if(s>93)throw new ge(this.id+" fetchBorrowRateHistory() limit parameter cannot exceed 92");const r={asset:this.currency(e).id,limit:s};if(t!==void 0){r.startTime=t;const o=this.sum(t,s*864e5)-1,d=this.milliseconds();r.endTime=Math.min(o,d)}const a=await this.sapiGetMarginInterestRateHistory(this.extend(r,i));return this.parseBorrowRateHistory(a)}parseBorrowRateHistory(e,t,s,i){const n=[];for(let a=0;a<e.length;a++){const o=e[a],d=this.parseBorrowRate(o);n.push(d)}const r=this.sortBy(n,"timestamp");return this.filterByCurrencySinceLimit(r,t,s,i)}parseBorrowRate(e,t=void 0){const s=this.safeNumber(e,"timestamp");return t=this.safeString(e,"asset"),{currency:this.safeCurrencyCode(t),rate:this.safeNumber(e,"dailyInterestRate"),period:864e5,timestamp:s,datetime:this.iso8601(s),info:e}}async createGiftCode(e,t,s={}){await this.loadMarkets();const n={token:this.currency(e).id,amount:t},r=await this.sapiPostGiftcardCreateCode(this.extend(n,s)),a=this.safeValue(r,"data"),o=this.safeString(a,"code"),d=this.safeString(a,"referenceNo");return{info:r,id:d,code:o,currency:e,amount:t}}async redeemGiftCode(e,t={}){const s={code:e};return await this.sapiPostGiftcardRedeemCode(this.extend(s,t))}async verifyGiftCode(e,t={}){const s={referenceNo:e};return await this.sapiGetGiftcardVerify(this.extend(s,t))}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a;if(e!==void 0){const u=this.currency(e);r.asset=u.id}s!==void 0&&(r.startTime=s),i!==void 0&&(r.size=i),t!==void 0&&(a=this.market(t),r.isolatedSymbol=a.id);const o=await this.sapiGetMarginInterestHistory(this.extend(r,n)),d=this.safeValue(o,"rows"),c=this.parseBorrowInterests(d,a);return this.filterByCurrencySinceLimit(c,e,s,i)}parseBorrowInterest(e,t){const s=this.safeString(e,"isolatedSymbol"),i=this.safeNumber(e,"interestAccuredTime");return{account:s===void 0?"cross":s,symbol:s,marginMode:s===void 0?"cross":"isolated",currency:this.safeCurrencyCode(this.safeString(e,"asset")),interest:this.safeNumber(e,"interest"),interestRate:this.safeNumber(e,"interestRate"),amountBorrowed:this.safeNumber(e,"principal"),timestamp:i,datetime:this.iso8601(i),info:e}}async repayMargin(e,t,s=void 0,i={}){const[n,r]=this.handleMarginModeAndParams("repayMargin",i);this.checkRequiredMarginArgument("repayMargin",s,n),await this.loadMarkets();const a=this.currency(e),o={asset:a.id,amount:this.currencyToPrecision(e,t)};if(s!==void 0){const c=this.market(s);o.symbol=c.id,o.isIsolated="TRUE"}const d=await this.sapiPostMarginRepay(this.extend(o,r));return this.parseMarginLoan(d,a)}async borrowMargin(e,t,s=void 0,i={}){const[n,r]=this.handleMarginModeAndParams("borrowMargin",i);this.checkRequiredMarginArgument("borrowMargin",s,n),await this.loadMarkets();const a=this.currency(e),o={asset:a.id,amount:this.currencyToPrecision(e,t)};if(s!==void 0){const c=this.market(s);o.symbol=c.id,o.isIsolated="TRUE"}const d=await this.sapiPostMarginLoan(this.extend(o,r));return this.parseMarginLoan(d,a)}parseMarginLoan(e,t=void 0){return{id:this.safeInteger(e,"tranId"),currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}async fetchOpenInterestHistory(e,t="5m",s=void 0,i=void 0,n={}){if(t==="1m")throw new ge(this.id+"fetchOpenInterestHistory cannot use the 1m timeframe");await this.loadMarkets();const r=this.market(e),a={period:this.timeframes[t]};i!==void 0&&(a.limit=i);const o=r.linear?"symbol":"pair";a[o]=r.id,r.delivery&&(a.contractType=this.safeString(n,"contractType","CURRENT_QUARTER")),s!==void 0&&(a.startTime=s);const d=this.safeInteger2(n,"until","till"),c=this.safeInteger(n,"endTime",d);if(n=this.omit(n,["endTime","until","till"]),c)a.endTime=c;else if(s){i===void 0&&(i=30);const l=this.parseTimeframe(t);a.endTime=this.sum(s,l*i*1e3)}let u="fapiDataGetOpenInterestHist";r.inverse&&(u="dapiDataGetOpenInterestHist");const h=await this[u](this.extend(a,n));return this.parseOpenInterests(h,e,s,i)}parseOpenInterest(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const n=this.safeNumber(e,"sumOpenInterest"),r=this.safeNumber(e,"sumOpenInterestValue");return{symbol:this.safeSymbol(i),baseVolume:n,quoteVolume:r,openInterestAmount:n,openInterestValue:r,timestamp:s,datetime:this.iso8601(s),info:e}}};const b4=Eu;var w4=class extends b4{describe(){return this.deepExtend(super.describe(),{id:"binancecoinm",name:"Binance COIN-M",urls:{logo:"https://user-images.githubusercontent.com/1294454/117738721-668c8d80-b205-11eb-8c49-3fad84c4a07f.jpg",doc:["https://binance-docs.github.io/apidocs/delivery/en/","https://binance-docs.github.io/apidocs/spot/en"]},has:{CORS:void 0,spot:!1,margin:!1,swap:!0,future:!0,option:void 0,createStopMarketOrder:!0},options:{defaultType:"delivery",leverageBrackets:void 0}})}async transferIn(e,t,s={}){return await this.futuresTransfer(e,t,3,s)}async transferOut(e,t,s={}){return await this.futuresTransfer(e,t,4,s)}};const S4=Eu;var k4=class extends S4{describe(){return this.deepExtend(super.describe(),{id:"binanceus",name:"Binance US",countries:["US"],certified:!1,pro:!0,urls:{logo:"https://user-images.githubusercontent.com/1294454/65177307-217b7c80-da5f-11e9-876e-0b748ba0a358.jpg",api:{web:"https://www.binance.us",sapi:"https://api.binance.us/sapi/v1",wapi:"https://api.binance.us/wapi/v3",public:"https://api.binance.us/api/v3",private:"https://api.binance.us/api/v3"},www:"https://www.binance.us",referral:"https://www.binance.us/?ref=35005074",doc:"https://github.com/binance-us/binance-official-api-docs",fees:"https://www.binance.us/en/fee/schedule"},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0.001")}},options:{quoteOrderQty:!1}})}};const v4=Eu;var T4=class extends v4{describe(){return this.deepExtend(super.describe(),{id:"binanceusdm",name:"Binance USD\u24C8-M",urls:{logo:"https://user-images.githubusercontent.com/1294454/117738721-668c8d80-b205-11eb-8c49-3fad84c4a07f.jpg",doc:["https://binance-docs.github.io/apidocs/futures/en/","https://binance-docs.github.io/apidocs/spot/en"]},has:{CORS:void 0,spot:!1,margin:!1,swap:!0,future:!0,option:void 0,createStopMarketOrder:!0},options:{defaultType:"future",leverageBrackets:void 0,marginTypes:{},marginModes:{}}})}async transferIn(e,t,s={}){return await this.futuresTransfer(e,t,1,s)}async transferOut(e,t,s={}){return await this.futuresTransfer(e,t,2,s)}};const O4=me,{ArgumentsRequired:I4,ExchangeError:iS,InvalidNonce:x4,AuthenticationError:_4,PermissionDenied:C4,NotSupported:M4}=oe,{TICK_SIZE:P4}=pe,nS=ke;var A4=class extends O4{describe(){return this.deepExtend(super.describe(),{id:"bit2c",name:"Bit2C",countries:["IL"],rateLimit:3e3,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchDepositAddress:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766119-3593220e-5ece-11e7-8b3a-5a041f6bcc3f.jpg",api:{rest:"https://bit2c.co.il"},www:"https://www.bit2c.co.il",referral:"https://bit2c.co.il/Aff/63bfed10-e359-420c-ab5a-ad368dab0baf",doc:["https://www.bit2c.co.il/home/api","https://github.com/OferE/bit2c"]},api:{public:{get:["Exchanges/{pair}/Ticker","Exchanges/{pair}/orderbook","Exchanges/{pair}/trades","Exchanges/{pair}/lasttrades"]},private:{post:["Merchant/CreateCheckout","Funds/AddCoinFundsRequest","Order/AddFund","Order/AddOrder","Order/AddOrderMarketPriceBuy","Order/AddOrderMarketPriceSell","Order/CancelOrder","Order/AddCoinFundsRequest","Order/AddStopOrder","Payment/GetMyId","Payment/Send","Payment/Pay"],get:["Account/Balance","Account/Balance/v2","Order/MyOrders","Order/GetById","Order/AccountHistory","Order/OrderHistory"]}},markets:{"BTC/NIS":{id:"BtcNis",symbol:"BTC/NIS",base:"BTC",quote:"NIS",baseId:"Btc",quoteId:"Nis",type:"spot",spot:!0},"ETH/NIS":{id:"EthNis",symbol:"ETH/NIS",base:"ETH",quote:"NIS",baseId:"Eth",quoteId:"Nis",type:"spot",spot:!0},"LTC/NIS":{id:"LtcNis",symbol:"LTC/NIS",base:"LTC",quote:"NIS",baseId:"Ltc",quoteId:"Nis",type:"spot",spot:!0},"USDC/NIS":{id:"UsdcNis",symbol:"USDC/NIS",base:"USDC",quote:"NIS",baseId:"Usdc",quoteId:"Nis",type:"spot",spot:!0}},fees:{trading:{maker:this.parseNumber("0.005"),taker:this.parseNumber("0.005")}},options:{fetchTradesMethod:"public_get_exchanges_pair_trades"},precisionMode:P4,exceptions:{exact:{"Please provide valid APIkey":_4},broad:{"Please provide valid nonce":x4,"please approve new terms of use on site":C4}}})}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=Object.keys(this.currencies);for(let i=0;i<s.length;i++){const n=s[i],r=this.account(),o=this.currency(n).id.toUpperCase();o in e&&(r.free=this.safeString(e,"AVAILABLE_"+o),r.total=this.safeString(e,o)),t[n]=r}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountBalanceV2(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id},r=await this.publicGetExchangesPairOrderbook(this.extend(n,s));return this.parseOrderBook(r,i.symbol)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.milliseconds(),n=this.safeString(e,"av"),r=this.safeString(e,"a"),a=this.safeString(e,"ll");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:void 0,low:void 0,bid:this.safeString(e,"h"),bidVolume:void 0,ask:this.safeString(e,"l"),askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:n,baseVolume:r,quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetExchangesPairTicker(this.extend(i,t));return this.parseTicker(n,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r=this.options.fetchTradesMethod,a={pair:n.id};t!==void 0&&(a.date=parseInt(t)),s!==void 0&&(a.limit=s);const o=await this[r](this.extend(a,i));if(typeof o=="string")throw new iS(o);return this.parseTrades(o,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetAccountBalance(e),s=this.safeValue(t,"Fees",{}),i=Object.keys(s),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeSymbol(a),d=this.safeValue(s,a),c=this.safeString(d,"FeeMaker"),u=this.safeString(d,"FeeTaker"),h=this.parseNumber(nS.stringDiv(c,"100")),l=this.parseNumber(nS.stringDiv(u,"100"));n[o]={info:d,symbol:o,taker:l,maker:h,percentage:!0,tierBased:!1}}return n}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();let a="privatePostOrderAddOrder";const o=this.market(e),d={Amount:i,Pair:o.id};t==="market"?a+="MarketPrice"+this.capitalize(s):(d.Price=n,d.Total=i*n,d.IsBid=s==="buy");const c=await this[a](this.extend(d,r));return{info:c,id:c.NewOrder.id}}async cancelOrder(e,t=void 0,s={}){const i={id:e};return await this.privatePostOrderCancelOrder(this.extend(i,s))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new I4(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={pair:n.id},a=await this.privateGetOrderMyOrders(this.extend(r,i)),o=this.safeValue(a,n.id,{}),d=this.safeValue(o,"ask",[]),c=this.safeValue(o,"bid",[]);return this.parseOrders(this.arrayConcat(d,c),n,t,s)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"created"),i=this.safeString(e,"price"),n=this.safeString(e,"amount");t=this.safeMarket(void 0,t);let r=this.safeValue(e,"type");r===0?r="buy":r===1&&(r="sell");const a=this.safeString(e,"id"),o=this.safeString(e,"status");return this.safeOrder({id:a,clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,status:o,symbol:t.symbol,type:void 0,timeInForce:void 0,postOnly:void 0,side:r,price:i,stopPrice:void 0,amount:n,filled:void 0,remaining:void 0,cost:void 0,trades:void 0,fee:void 0,info:e,average:void 0},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};s!==void 0&&(r.take=s),r.take=s,t!==void 0&&(r.toTime=this.yyyymmdd(this.milliseconds(),"."),r.fromTime=this.yyyymmdd(t,".")),e!==void 0&&(n=this.market(e),r.pair=n.id);const a=await this.privateGetOrderOrderHistory(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseTrade(e,t=void 0){let s,i,n,r,a,o,d;const c=this.safeString(e,"reference");if(c!==void 0){s=this.safeTimestamp(e,"ticks"),n=this.safeString(e,"price"),r=this.safeString(e,"firstAmount");const u=c.split("|"),h=this.safeString(e,"pair");t=this.safeMarket(h,t),t=this.safeMarket(u[0],t),a=u[1],i=u[2],d=this.safeInteger(e,"action"),d===0?d="buy":d===1&&(d="sell");const l=this.safeString(e,"feeAmount");l!==void 0&&(o={cost:l,currency:"NIS"})}else s=this.safeTimestamp(e,"date"),i=this.safeString(e,"tid"),n=this.safeString(e,"price"),r=this.safeString(e,"amount"),d=this.safeValue(e,"isBid"),d!==void 0&&(d?d="buy":d="sell");return t=this.safeMarket(void 0,t),this.safeTrade({info:e,id:i,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:a,type:void 0,side:d,takerOrMaker:void 0,price:n,amount:r,cost:void 0,fee:o},t)}isFiat(e){return e==="NIS"}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e);if(this.isFiat(e))throw new M4(this.id+" fetchDepositAddress() does not support fiat currencies");const i={Coin:s.id},n=await this.privatePostFundsAddCoinFundsRequest(this.extend(i,t));return this.parseDepositAddress(n,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address");return this.checkAddress(s),{currency:this.safeCurrencyCode(void 0,t),network:void 0,address:s,tag:void 0,info:e}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.implodeParams(e,i);if(t==="public")a+=".json";else{this.checkRequiredCredentials();const o=this.nonce(),d=this.extend({nonce:o},i),c=this.urlencode(d);s==="GET"?Object.keys(d).length&&(a+="?"+c):r=c;const u=this.hmac(this.encode(c),this.encode(this.secret),"sha512","base64");n={"Content-Type":"application/x-www-form-urlencoded",key:this.apiKey,sign:u}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"error");if(c!==void 0){const u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u),new iS(u)}}};const B4=me,{ExchangeError:bm,AuthenticationError:lf,InvalidNonce:N4,InsufficientFunds:E4,InvalidOrder:wm,OrderNotFound:pf,PermissionDenied:V4}=oe,{TICK_SIZE:q4}=pe;var L4=class extends B4{describe(){return this.deepExtend(super.describe(),{id:"bitbank",name:"bitbank",countries:["JP"],version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchDepositAddress:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","4h":"4hour","8h":"8hour","12h":"12hour","1d":"1day","1w":"1week"},hostname:"bitbank.cc",urls:{logo:"https://user-images.githubusercontent.com/1294454/37808081-b87f2d9c-2e59-11e8-894d-c1900b7584fe.jpg",api:{public:"https://public.{hostname}",private:"https://api.{hostname}",markets:"https://api.{hostname}"},www:"https://bitbank.cc/",doc:"https://docs.bitbank.cc/",fees:"https://bitbank.cc/docs/fees/"},api:{public:{get:["{pair}/ticker","{pair}/depth","{pair}/transactions","{pair}/transactions/{yyyymmdd}","{pair}/candlestick/{candletype}/{yyyymmdd}"]},private:{get:["user/assets","user/spot/order","user/spot/active_orders","user/spot/trade_history","user/withdrawal_account"],post:["user/spot/order","user/spot/cancel_order","user/spot/cancel_orders","user/spot/orders_info","user/request_withdrawal"]},markets:{get:["spot/pairs"]}},precisionMode:q4,exceptions:{20001:lf,20002:lf,20003:lf,20005:lf,20004:N4,40020:wm,40021:wm,40025:bm,40013:pf,40014:pf,50008:V4,50009:pf,50010:pf,60001:E4,60005:wm}})}async fetchMarkets(e={}){const t=await this.marketsGetSpotPairs(e),s=this.safeValue(t,"data"),i=this.safeValue(s,"pairs",[]),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"name"),d=this.safeString(a,"base_asset"),c=this.safeString(a,"quote_asset"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c);n.push({id:o,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:this.safeValue(a,"is_enabled"),contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(a,"taker_fee_rate_quote"),maker:this.safeNumber(a,"maker_fee_rate_quote"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(a,"amount_digits"))),price:this.parseNumber(this.parsePrecision(this.safeString(a,"price_digits")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(a,"unit_amount"),max:this.safeNumber(a,"limit_max_amount")},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:a})}return n}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeInteger(e,"timestamp"),n=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"vol"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetPairTicker(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTicker(r,s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id},r=await this.publicGetPairDepth(this.extend(n,s)),a=this.safeValue(r,"data",{}),o=this.safeInteger(a,"timestamp");return this.parseOrderBook(a,i.symbol,o)}parseTrade(e,t=void 0){const s=this.safeInteger(e,"executed_at");t=this.safeMarket(void 0,t);const i=this.safeString(e,"price"),n=this.safeString(e,"amount"),r=this.safeString2(e,"transaction_id","trade_id"),a=this.safeString(e,"maker_taker");let o;const d=this.safeString(e,"fee_amount_quote");d!==void 0&&(o={currency:t.quote,cost:d});const c=this.safeString(e,"order_id"),u=this.safeString(e,"type"),h=this.safeString(e,"side");return this.safeTrade({timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,id:r,order:c,type:u,side:h,takerOrMaker:a,price:i,amount:n,cost:void 0,fee:o,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id},a=await this.publicGetPairTransactions(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"transactions",[]);return this.parseTrades(d,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.marketsGetSpotPairs(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"pairs",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"name"),c=this.safeMarket(o).symbol;n[c]={info:a,symbol:c,maker:this.safeNumber(a,"maker_fee_rate_quote"),taker:this.safeNumber(a,"taker_fee_rate_quote"),percentage:!0,tierBased:!1}}return n}parseOHLCV(e,t=void 0){return[this.safeInteger(e,5),this.safeNumber(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){if(s===void 0){i===void 0&&(i=1e3);const l=this.parseTimeframe(t);s=this.milliseconds()-l*1e3*i}await this.loadMarkets();const r=this.market(e),a={pair:r.id,candletype:this.timeframes[t],yyyymmdd:this.yyyymmdd(s,"")},o=await this.publicGetPairCandlestickCandletypeYyyymmdd(this.extend(a,n)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"candlestick",[]),u=this.safeValue(c,0,{}),h=this.safeValue(u,"ohlcv",[]);return this.parseOHLCVs(h,r,t,s,i)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"data",{}),i=this.safeValue(s,"assets",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"asset"),o=this.safeCurrencyCode(a),d=this.account();d.free=this.safeString(r,"free_amount"),d.used=this.safeString(r,"locked_amount"),d.total=this.safeString(r,"onhand_amount"),t[o]=d}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetUserAssets(e);return this.parseBalance(t)}parseOrderStatus(e){const t={UNFILLED:"open",PARTIALLY_FILLED:"open",FULLY_FILLED:"closed",CANCELED_UNFILLED:"canceled",CANCELED_PARTIALLY_FILLED:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"order_id"),i=this.safeString(e,"pair");t=this.safeMarket(i,t);const n=this.safeInteger(e,"ordered_at"),r=this.safeString(e,"price"),a=this.safeString(e,"start_amount"),o=this.safeString(e,"executed_amount"),d=this.safeString(e,"remaining_amount"),c=this.safeString(e,"average_price"),u=this.parseOrderStatus(this.safeString(e,"status")),h=this.safeStringLower(e,"type"),l=this.safeStringLower(e,"side");return this.safeOrder({id:s,clientOrderId:void 0,datetime:this.iso8601(n),timestamp:n,lastTradeTimestamp:void 0,status:u,symbol:t.symbol,type:h,timeInForce:void 0,postOnly:void 0,side:l,price:r,stopPrice:void 0,cost:void 0,average:c,amount:a,filled:o,remaining:d,trades:void 0,fee:void 0,info:e},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={pair:a.id,amount:this.amountToPrecision(e,i),side:s,type:t};t==="limit"&&(o.price=this.priceToPrecision(e,n));const d=await this.privatePostUserSpotOrder(this.extend(o,r)),c=this.safeValue(d,"data");return this.parseOrder(c,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(t),n={order_id:e,pair:i.id},r=await this.privatePostUserSpotCancelOrder(this.extend(n,s));return this.safeValue(r,"data")}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(t),n={order_id:e,pair:i.id},r=await this.privateGetUserSpotOrder(this.extend(n,s)),a=this.safeValue(r,"data");return this.parseOrder(a,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id};s!==void 0&&(r.count=s),t!==void 0&&(r.since=parseInt(t/1e3));const a=await this.privateGetUserSpotActiveOrders(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"orders",[]);return this.parseOrders(d,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.pair=r.id),s!==void 0&&(n.count=s),t!==void 0&&(n.since=parseInt(t/1e3));const a=await this.privateGetUserSpotTradeHistory(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"trades",[]);return this.parseTrades(d,r,t,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={asset:s.id},n=await this.privateGetUserWithdrawalAccount(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"accounts",[]),o=this.safeValue(a,0,{}),d=this.safeString(o,"address");return{currency:s,address:d,tag:void 0,network:void 0,info:n}}async withdraw(e,t,s,i=void 0,n={}){if([i,n]=this.handleWithdrawTagAndParams(i,n),!("uuid"in n))throw new bm(this.id+" uuid is required for withdrawal");await this.loadMarkets();const r=this.currency(e),a={asset:r.id,amount:t},o=await this.privatePostUserRequestWithdrawal(this.extend(a,n)),d=this.safeValue(o,"data",{});return this.parseTransaction(d,r)}parseTransaction(e,t=void 0){const s=this.safeString(e,"txid");return t=this.safeCurrency(void 0,t),{id:s,txid:s,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0,info:e}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.omit(i,this.extractParams(e)),o=this.implodeHostname(this.urls.api[t])+"/";if(t==="public"||t==="markets")o+=this.implodeParams(e,i),Object.keys(a).length&&(o+="?"+this.urlencode(a));else{this.checkRequiredCredentials();const d=this.nonce().toString();let c=d;o+=this.version+"/"+this.implodeParams(e,i),s==="POST"?(r=this.json(a),c+=r):(c+="/"+this.version+"/"+e,Object.keys(a).length&&(a=this.urlencode(a),o+="?"+a,c+="?"+a)),n={"Content-Type":"application/json","ACCESS-KEY":this.apiKey,"ACCESS-NONCE":d,"ACCESS-SIGNATURE":this.hmac(this.encode(c),this.encode(this.secret))}}return{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeInteger(a,"success"),u=this.safeValue(a,"data");if(!c||!u){const h={1e4:"URL does not exist",10001:"A system error occurred. Please contact support",10002:"Invalid JSON format. Please check the contents of transmission",10003:"A system error occurred. Please contact support",10005:"A timeout error occurred. Please wait for a while and try again",20001:"API authentication failed",20002:"Illegal API key",20003:"API key does not exist",20004:"API Nonce does not exist",20005:"API signature does not exist",20011:"Two-step verification failed",20014:"SMS authentication failed",30001:"Please specify the order quantity",30006:"Please specify the order ID",30007:"Please specify the order ID array",30009:"Please specify the stock",30012:"Please specify the order price",30013:"Trade Please specify either",30015:"Please specify the order type",30016:"Please specify asset name",30019:"Please specify uuid",30039:"Please specify the amount to be withdrawn",40001:"The order quantity is invalid",40006:"Count value is invalid",40007:"End time is invalid",40008:"end_id Value is invalid",40009:"The from_id value is invalid",40013:"The order ID is invalid",40014:"The order ID array is invalid",40015:"Too many specified orders",40017:"Incorrect issue name",40020:"The order price is invalid",40021:"The trading classification is invalid",40022:"Start date is invalid",40024:"The order type is invalid",40025:"Incorrect asset name",40028:"uuid is invalid",40048:"The amount of withdrawal is illegal",50003:"Currently, this account is in a state where you can not perform the operation you specified. Please contact support",50004:"Currently, this account is temporarily registered. Please try again after registering your account",50005:"Currently, this account is locked. Please contact support",50006:"Currently, this account is locked. Please contact support",50008:"User identification has not been completed",50009:"Your order does not exist",50010:"Can not cancel specified order",50011:"API not found",60001:"The number of possessions is insufficient",60002:"It exceeds the quantity upper limit of the tender buying order",60003:"The specified quantity exceeds the limit",60004:"The specified quantity is below the threshold",60005:"The specified price is above the limit",60006:"The specified price is below the lower limit",70001:"A system error occurred. Please contact support",70002:"A system error occurred. Please contact support",70003:"A system error occurred. Please contact support",70004:"We are unable to accept orders as the transaction is currently suspended",70005:"Order can not be accepted because purchase order is currently suspended",70006:"We can not accept orders because we are currently unsubscribed ",70009:"We are currently temporarily restricting orders to be carried out. Please use the limit order.",70010:"We are temporarily raising the minimum order quantity as the system load is now rising."},l=this.exceptions,p=this.safeString(u,"code"),m=this.safeString(h,p,"Error"),g=this.safeValue(l,p);throw g!==void 0?new g(m):new bm(this.id+" "+this.json(a))}}};const R4=me,{InvalidNonce:rS,InsufficientFunds:aS,AuthenticationError:Sm,InvalidOrder:Er,ExchangeError:Vn,OrderNotFound:F4,AccountSuspended:D4,BadSymbol:H4,OrderImmediatelyFillable:G4,RateLimitExceeded:U4,OnMaintenance:$4,PermissionDenied:j4}=oe,{TICK_SIZE:W4}=pe,oS=ke;var k_=class extends R4{describe(){return this.deepExtend(super.describe(),{id:"zonda",name:"Zonda",countries:["EE"],rateLimit:1e3,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!1,cancelOrder:!0,cancelOrders:!1,createDepositAddress:!1,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:!0,fetchDeposits:void 0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!1,fetchOpenOrders:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:void 0,fetchTransfer:!1,fetchWithdrawal:!1,fetchWithdrawals:void 0,reduceMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,setPositionMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"60","3m":"180","5m":"300","15m":"900","30m":"1800","1h":"3600","2h":"7200","4h":"14400","6h":"21600","12h":"43200","1d":"86400","3d":"259200","1w":"604800"},hostname:"zonda.exchange",urls:{referral:"https://auth.zondaglobal.com/ref/jHlbB4mIkdS1",logo:"https://user-images.githubusercontent.com/1294454/159202310-a0e38007-5e7c-4ba9-a32f-c8263a0291fe.jpg",www:"https://zondaglobal.com",api:{public:"https://{hostname}/API/Public",private:"https://{hostname}/API/Trading/tradingApi.php",v1_01Public:"https://api.{hostname}/rest",v1_01Private:"https://api.{hostname}/rest"},doc:["https://docs.zonda.exchange/","https://github.com/BitBayNet/API"],support:"https://zondaglobal.com/en/helpdesk/zonda-exchange",fees:"https://zondaglobal.com/legal/zonda-exchange/fees"},api:{public:{get:["{id}/all","{id}/market","{id}/orderbook","{id}/ticker","{id}/trades"]},private:{post:["info","trade","cancel","orderbook","orders","transfer","withdraw","history","transactions"]},v1_01Public:{get:["trading/ticker","trading/ticker/{symbol}","trading/stats","trading/stats/{symbol}","trading/orderbook/{symbol}","trading/transactions/{symbol}","trading/candle/history/{symbol}/{resolution}"]},v1_01Private:{get:["api_payments/deposits/crypto/addresses","payments/withdrawal/{detailId}","payments/deposit/{detailId}","trading/offer","trading/stop/offer","trading/config/{symbol}","trading/history/transactions","balances/BITBAY/history","balances/BITBAY/balance","fiat_cantor/rate/{baseId}/{quoteId}","fiat_cantor/history"],post:["trading/offer/{symbol}","trading/stop/offer/{symbol}","trading/config/{symbol}","balances/BITBAY/balance","balances/BITBAY/balance/transfer/{source}/{destination}","fiat_cantor/exchange"],delete:["trading/offer/{symbol}/{id}/{side}/{price}","trading/stop/offer/{symbol}/{id}/{side}/{price}"],put:["balances/BITBAY/balance/{id}"]}},fees:{trading:{maker:this.parseNumber("0.0"),taker:this.parseNumber("0.001"),percentage:!0,tierBased:!1},fiat:{maker:this.parseNumber("0.0030"),taker:this.parseNumber("0.0043"),percentage:!0,tierBased:!0,tiers:{taker:[[this.parseNumber("0.0043"),this.parseNumber("0")],[this.parseNumber("0.0042"),this.parseNumber("1250")],[this.parseNumber("0.0041"),this.parseNumber("3750")],[this.parseNumber("0.0040"),this.parseNumber("7500")],[this.parseNumber("0.0039"),this.parseNumber("10000")],[this.parseNumber("0.0038"),this.parseNumber("15000")],[this.parseNumber("0.0037"),this.parseNumber("20000")],[this.parseNumber("0.0036"),this.parseNumber("25000")],[this.parseNumber("0.0035"),this.parseNumber("37500")],[this.parseNumber("0.0034"),this.parseNumber("50000")],[this.parseNumber("0.0033"),this.parseNumber("75000")],[this.parseNumber("0.0032"),this.parseNumber("100000")],[this.parseNumber("0.0031"),this.parseNumber("150000")],[this.parseNumber("0.0030"),this.parseNumber("200000")],[this.parseNumber("0.0029"),this.parseNumber("250000")],[this.parseNumber("0.0028"),this.parseNumber("375000")],[this.parseNumber("0.0027"),this.parseNumber("500000")],[this.parseNumber("0.0026"),this.parseNumber("625000")],[this.parseNumber("0.0025"),this.parseNumber("875000")]],maker:[[this.parseNumber("0.0030"),this.parseNumber("0")],[this.parseNumber("0.0029"),this.parseNumber("1250")],[this.parseNumber("0.0028"),this.parseNumber("3750")],[this.parseNumber("0.0028"),this.parseNumber("7500")],[this.parseNumber("0.0027"),this.parseNumber("10000")],[this.parseNumber("0.0026"),this.parseNumber("15000")],[this.parseNumber("0.0025"),this.parseNumber("20000")],[this.parseNumber("0.0025"),this.parseNumber("25000")],[this.parseNumber("0.0024"),this.parseNumber("37500")],[this.parseNumber("0.0023"),this.parseNumber("50000")],[this.parseNumber("0.0023"),this.parseNumber("75000")],[this.parseNumber("0.0022"),this.parseNumber("100000")],[this.parseNumber("0.0021"),this.parseNumber("150000")],[this.parseNumber("0.0021"),this.parseNumber("200000")],[this.parseNumber("0.0020"),this.parseNumber("250000")],[this.parseNumber("0.0019"),this.parseNumber("375000")],[this.parseNumber("0.0018"),this.parseNumber("500000")],[this.parseNumber("0.0018"),this.parseNumber("625000")],[this.parseNumber("0.0017"),this.parseNumber("875000")]]}},funding:{withdraw:{}}},options:{fiatCurrencies:["EUR","USD","GBP","PLN"],transfer:{fillResponseFromRequest:!0}},precisionMode:W4,exceptions:{400:Vn,401:Er,402:Er,403:Er,404:Er,405:Er,406:aS,408:Er,501:Sm,502:Sm,503:rS,504:Vn,505:Sm,506:D4,509:Vn,510:H4,FUNDS_NOT_SUFFICIENT:aS,OFFER_FUNDS_NOT_EXCEEDING_MINIMUMS:Er,OFFER_NOT_FOUND:F4,OFFER_WOULD_HAVE_BEEN_PARTIALLY_FILLED:G4,ACTION_LIMIT_EXCEEDED:U4,UNDER_MAINTENANCE:$4,REQUEST_TIMESTAMP_TOO_OLD:rS,PERMISSIONS_NOT_SUFFICIENT:j4,INVALID_STOP_RATE:Er},commonCurrencies:{GGC:"Global Game Coin"}})}async fetchMarkets(e={}){const t=await this.v1_01PublicGetTradingTicker(e),s=this.safeValue(this.options,"fiatCurrencies",[]),i=[],n=this.safeValue(t,"items",{}),r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=n[o],c=this.safeValue(d,"market",{}),u=this.safeValue(c,"first",{}),h=this.safeValue(c,"second",{}),l=this.safeString(u,"currency"),p=this.safeString(h,"currency"),m=this.safeCurrencyCode(l),g=this.safeCurrencyCode(p);let y=this.safeValue(this.fees,"trading",{});(this.inArray(m,s)||this.inArray(g,s))&&(y=this.safeValue(this.fees,"fiat",{})),i.push({id:o,symbol:m+"/"+g,base:m,quote:g,settle:void 0,baseId:l,quoteId:p,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(y,"taker"),maker:this.safeNumber(y,"maker"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,optionType:void 0,strike:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(u,"scale"))),price:this.parseNumber(this.parsePrecision(this.safeString(h,"scale")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(u,"minOffer"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(h,"minOffer"),max:void 0}},info:d})}return i}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={},r=await this.v1_01PrivateGetTradingOffer(this.extend(n,i)),a=this.safeValue(r,"items",[]);return this.parseOrders(a,void 0,t,s,{status:"open"})}parseOrder(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeSymbol(s,t,"-"),n=this.safeInteger(e,"time"),r=this.safeString(e,"startAmount"),a=this.safeString(e,"currentAmount"),o=this.safeValue(e,"postOnly");return this.safeOrder({id:this.safeString(e,"id"),clientOrderId:void 0,info:e,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,status:void 0,symbol:i,type:this.safeString(e,"mode"),timeInForce:void 0,postOnly:o,side:this.safeStringLower(e,"offerType"),price:this.safeString(e,"rate"),stopPrice:void 0,amount:r,cost:void 0,filled:void 0,remaining:a,average:void 0,fee:void 0,trades:void 0},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};if(e){const c=[this.marketId(e)];e=this.symbol(e),n.markets=c}const r={query:this.json(this.extend(n,i))},a=await this.v1_01PrivateGetTradingHistoryTransactions(r),o=this.safeValue(a,"items"),d=this.parseTrades(o,void 0,t,s);return e===void 0?d:this.filterBySymbol(d,e)}parseBalance(e){const t=this.safeValue(e,"balances");if(t===void 0)throw new Vn(this.id+" empty balance response "+this.json(e));const s={info:e};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.used=this.safeString(n,"lockedFunds"),o.free=this.safeString(n,"availableFunds"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.v1_01PrivateGetBalancesBITBAYBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id},r=await this.v1_01PublicGetTradingOrderbookSymbol(this.extend(n,s)),a=this.safeValue(r,"buy",[]),o=this.safeValue(r,"sell",[]),d=this.safeInteger(r,"timestamp");return{symbol:i.symbol,bids:this.parseBidsAsks(a,"ra","ca"),asks:this.parseBidsAsks(o,"ra","ca"),timestamp:d,datetime:this.iso8601(d),nonce:this.safeInteger(r,"seqNo")}}parseTicker(e,t=void 0){const s=this.safeString(e,"r24h"),i=this.safeString(e,"h"),n=this.safeString(e,"l"),r=this.safeString(e,"v"),a=this.safeString(e,"m");t=this.safeMarket(a,t,"-");const o=t.symbol;return this.safeTicker({symbol:o,timestamp:void 0,datetime:void 0,high:i,low:n,bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:s,close:void 0,last:void 0,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.v1_01PublicGetTradingStatsSymbol(this.extend(i,t)),r=this.safeValue(n,"stats");return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.v1_01PublicGetTradingStats(t),i=this.safeValue(s,"items");return this.parseTickers(i,e)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){const n=[];if(e!==void 0){const d=this.currency(e);n.push(d.id)}let r={balanceCurrencies:n};t!==void 0&&(r.fromTime=t),s!==void 0&&(r.limit=s),r=this.extend(r,i);const o=(await this.v1_01PrivateGetBalancesBITBAYHistory({query:this.json(r)})).items;return this.parseLedger(o,void 0,t,s)}parseLedgerEntry(e,t=void 0){const s=this.safeInteger(e,"time"),i=this.safeValue(e,"balance",{}),n=this.safeString(i,"currency"),r=this.safeValue(e,"change",{});let a=this.safeString(r,"total"),o="in";oS.stringLt(a,"0")&&(o="out",a=oS.stringNeg(a));const d=this.safeValue(e,"fundsBefore",{}),c=this.safeValue(e,"fundsAfter",{});return{info:e,id:this.safeString(e,"historyId"),direction:o,account:void 0,referenceId:this.safeString(e,"detailId"),referenceAccount:void 0,type:this.parseLedgerEntryType(this.safeString(e,"type")),currency:this.safeCurrencyCode(n),amount:a,before:this.safeNumber(d,"total"),after:this.safeNumber(c,"total"),status:"ok",timestamp:s,datetime:this.iso8601(s),fee:void 0}}parseLedgerEntryType(e){const t={ADD_FUNDS:"transaction",BITCOIN_GOLD_FORK:"transaction",CREATE_BALANCE:"transaction",FUNDS_MIGRATION:"transaction",WITHDRAWAL_LOCK_FUNDS:"transaction",WITHDRAWAL_SUBTRACT_FUNDS:"transaction",WITHDRAWAL_UNLOCK_FUNDS:"transaction",TRANSACTION_COMMISSION_OUTCOME:"fee",TRANSACTION_COMMISSION_RETURN:"fee",TRANSACTION_OFFER_ABORTED_RETURN:"trade",TRANSACTION_OFFER_COMPLETED_RETURN:"trade",TRANSACTION_POST_INCOME:"trade",TRANSACTION_POST_OUTCOME:"trade",TRANSACTION_PRE_LOCKING:"trade"};return this.safeString(t,e,e)}parseOHLCV(e,t=void 0){const s=this.safeValue(e,1,{});return[this.safeInteger(e,0),this.safeNumber(s,"o"),this.safeNumber(s,"h"),this.safeNumber(s,"l"),this.safeNumber(s,"c"),this.safeNumber(s,"v")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),o={symbol:r.baseId+"-"+r.quoteId,resolution:this.timeframes[t]};i===void 0&&(i=100);const d=this.parseTimeframe(t),c=i*d*1e3;s===void 0?(o.to=this.milliseconds(),o.from=o.to-c):(o.from=parseInt(s),o.to=this.sum(o.from,c));const u=await this.v1_01PublicGetTradingCandleHistorySymbolResolution(this.extend(o,n)),h=this.safeValue(u,"items",[]);return this.parseOHLCVs(h,r,t,s,i)}parseTrade(e,t=void 0){const s=this.safeInteger2(e,"time","t"),i=this.safeStringLower2(e,"userAction","ty"),n=this.safeValue(e,"wasTaker");let r;n!==void 0&&(r=n?"taker":"maker");const a=this.safeString2(e,"rate","r"),o=this.safeString2(e,"amount","a"),d=this.safeString(e,"commissionValue"),c=this.safeString(e,"market");t=this.safeMarket(c,t,"-");const u=t.symbol;let h;d!==void 0&&(h={currency:i==="buy"?t.base:t.quote,cost:d});const l=this.safeString(e,"offerId");let p;return l!==void 0&&(p=l?"limit":"market"),this.safeTrade({id:this.safeString(e,"id"),order:l,timestamp:s,datetime:this.iso8601(s),symbol:u,type:p,side:i,price:a,amount:o,cost:void 0,takerOrMaker:r,fee:h,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),a={symbol:n.baseId+"-"+n.quoteId};t!==void 0&&(a.fromTime=t-1),s!==void 0&&(a.limit=s);const o=await this.v1_01PublicGetTradingTransactionsSymbol(this.extend(a,i)),d=this.safeValue(o,"items");return this.parseTrades(d,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=a.baseId+"-"+a.quoteId;i=parseFloat(this.amountToPrecision(e,i));const d={symbol:o,offerType:s.toUpperCase(),amount:i},c=this.safeValue2(r,"stopPrice","stopLossPrice"),u=c!==void 0,h=t==="limit",l=t==="market",p=t==="stop-limit"||h&&u,m=t==="stop-market"||l&&u,g=p||m,y=g?"v1_01PrivatePostTradingStopOfferSymbol":"v1_01PrivatePostTradingOfferSymbol";if(h||p)d.rate=this.priceToPrecision(e,n),d.mode=p?"stop-limit":"limit";else if(l||m)d.mode=m?"stop-market":"market";else throw new Vn(this.id+" createOrder() invalid type");if(g){if(!u)throw new Vn(this.id+" createOrder() zonda requires `triggerPrice` or `stopPrice` parameter for stop-limit or stop-market orders");d.stopRate=this.priceToPrecision(e,c)}r=this.omit(r,["stopPrice","stopLossPrice"]);const b=await this[y](this.extend(d,r)),w=this.safeString2(b,"offerId","stopOfferId"),k=this.safeValue(b,"completed",!1)?"closed":"open",T=this.safeValue(b,"transactions");return this.safeOrder({id:w,info:b,timestamp:void 0,datetime:void 0,lastTradeTimestamp:void 0,status:k,symbol:e,type:t,side:s,price:n,amount:i,cost:void 0,filled:void 0,remaining:void 0,average:void 0,fee:void 0,trades:T,clientOrderId:void 0})}async cancelOrder(e,t=void 0,s={}){const i=this.safeString(s,"side");if(i===void 0)throw new Vn(this.id+' cancelOrder() requires a `side` parameter ("buy" or "sell")');const n=this.safeValue(s,"price");if(n===void 0)throw new Vn(this.id+" cancelOrder() requires a `price` parameter (float or string)");await this.loadMarkets();const r=this.market(t),o={symbol:r.baseId+"-"+r.quoteId,id:e,side:i,price:n};return await this.v1_01PrivateDeleteTradingOfferSymbolIdSidePrice(this.extend(o,s))}isFiat(e){const t={USD:!0,EUR:!0,PLN:!0};return this.safeValue(t,e,!1)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"currency"),i=this.safeString(e,"address");return this.checkAddress(i),{currency:this.safeCurrencyCode(s,t),address:i,tag:this.safeString(e,"tag"),network:void 0,info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=await this.v1_01PrivateGetApiPaymentsDepositsCryptoAddresses(this.extend(i,t)),r=this.safeValue(n,"data"),a=this.safeValue(r,0);return this.parseDepositAddress(a,s)}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s=await this.v1_01PrivateGetApiPaymentsDepositsCryptoAddresses(t),i=this.safeValue(s,"data");return this.parseDepositAddresses(i,e)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a={source:s,destination:i,currency:e,funds:this.currencyToPrecision(e,t)},o=await this.v1_01PrivatePostBalancesBITBAYBalanceTransferSourceDestination(this.extend(a,n)),d=this.parseTransfer(o,r),c=this.safeValue(this.options,"transfer",{});return this.safeValue(c,"fillResponseFromRequest",!0)&&(d.amount=t),d}parseTransfer(e,t=void 0){const s=this.safeString(e,"status"),i=this.safeValue(e,"from",{}),n=this.safeString(i,"id"),r=this.safeValue(e,"to",{}),a=this.safeString(r,"id"),o=this.safeString(i,"currency");return{info:e,id:void 0,timestamp:void 0,datetime:void 0,currency:this.safeCurrencyCode(o,t),amount:void 0,fromAccount:n,toAccount:a,status:this.parseTransferStatus(s)}}parseTransferStatus(e){const t={Ok:"ok",Fail:"failed"};return this.safeString(t,e,e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();let r;const a=this.currency(e),o={currency:a.id,quantity:t};this.isFiat(e)?r="privatePostWithdraw":(r="privatePostTransfer",i!==void 0&&(s+="?dt="+i.toString()),o.address=s);const d=await this[r](this.extend(o,n)),c=this.safeValue(d,"data");return this.parseTransaction(c,a)}parseTransaction(e,t=void 0){return t=this.safeCurrency(void 0,t),{id:this.safeString(e,"id"),txid:void 0,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0,info:e}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.implodeHostname(this.urls.api[t]);if(t==="public"){const o=this.omit(i,this.extractParams(e));a+="/"+this.implodeParams(e,i)+".json",Object.keys(o).length&&(a+="?"+this.urlencode(o))}else if(t==="v1_01Public"){const o=this.omit(i,this.extractParams(e));a+="/"+this.implodeParams(e,i),Object.keys(o).length&&(a+="?"+this.urlencode(o))}else if(t==="v1_01Private"){this.checkRequiredCredentials();const o=this.omit(i,this.extractParams(e));a+="/"+this.implodeParams(e,i);const d=this.milliseconds().toString();let c;s!=="POST"?(Object.keys(o).length&&(a+="?"+this.urlencode(o)),c=this.apiKey+d):r===void 0&&(r=this.json(o),c=this.apiKey+d+r),n={"Request-Timestamp":d,"Operation-Id":this.uuid(),"API-Key":this.apiKey,"API-Hash":this.hmac(this.encode(c),this.encode(this.secret),"sha512"),"Content-Type":"application/json"}}else this.checkRequiredCredentials(),r=this.urlencode(this.extend({method:e,moment:this.nonce()},i)),n={"Content-Type":"application/x-www-form-urlencoded","API-Key":this.apiKey,"API-Hash":this.hmac(this.encode(r),this.encode(this.secret),"sha512")};return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0){if("code"in a){const c=this.safeString(a,"code"),u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions,c,u),new Vn(u)}else if("status"in a&&this.safeString(a,"status")==="Fail"){const u=this.safeValue(a,"errors"),h=this.id+" "+r;for(let l=0;l<u.length;l++){const p=u[l];this.throwExactlyMatchedException(this.exceptions,p,h)}throw new Vn(h)}}}};const z4=k_;var K4=class extends z4{describe(){return this.deepExtend(super.describe(),{id:"bitbay",alias:!0})}};const X4=me,{ExchangeError:mf,ArgumentsRequired:Ia,InsufficientFunds:Y4,OrderNotFound:Q4,BadRequest:Z4,BadSymbol:J4}=oe,{TICK_SIZE:e5}=pe,t5=ke;var s5=class extends X4{describe(){return this.deepExtend(super.describe(),{id:"bitbns",name:"Bitbns",countries:["IN"],rateLimit:1e3,certified:!1,pro:!1,version:"v2",has:{CORS:void 0,spot:!0,margin:void 0,swap:!1,future:!1,option:void 0,cancelOrder:!0,createOrder:!0,fetchBalance:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:void 0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:"emulated",fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,transfer:!1,withdraw:!1},timeframes:{},urls:{logo:"https://user-images.githubusercontent.com/1294454/117201933-e7a6e780-adf5-11eb-9d80-98fc2a21c3d6.jpg",api:{www:"https://bitbns.com",v1:"https://api.bitbns.com/api/trade/v1",v2:"https://api.bitbns.com/api/trade/v2"},www:"https://bitbns.com",referral:"https://ref.bitbns.com/1090961",doc:["https://bitbns.com/trade/#/api-trading/"],fees:"https://bitbns.com/fees"},api:{www:{get:["order/fetchMarkets","order/fetchTickers","order/fetchOrderbook","order/getTickerWithVolume","exchangeData/ohlc","exchangeData/orderBook","exchangeData/tradedetails"]},v1:{get:["platform/status","tickers","orderbook/sell/{symbol}","orderbook/buy/{symbol}"],post:["currentCoinBalance/EVERYTHING","getApiUsageStatus/USAGE","getOrderSocketToken/USAGE","currentCoinBalance/{symbol}","orderStatus/{symbol}","depositHistory/{symbol}","withdrawHistory/{symbol}","withdrawHistoryAll/{symbol}","depositHistoryAll/{symbol}","listOpenOrders/{symbol}","listOpenStopOrders/{symbol}","getCoinAddress/{symbol}","placeSellOrder/{symbol}","placeBuyOrder/{symbol}","buyStopLoss/{symbol}","sellStopLoss/{symbol}","placeSellOrder/{symbol}","cancelOrder/{symbol}","cancelStopLossOrder/{symbol}","listExecutedOrders/{symbol}","placeMarketOrder/{symbol}","placeMarketOrderQnty/{symbol}"]},v2:{post:["orders","cancel","getordersnew","marginOrders"]}},fees:{trading:{feeSide:"quote",tierBased:!1,percentage:!0,taker:this.parseNumber("0.0025"),maker:this.parseNumber("0.0025")}},precisionMode:e5,exceptions:{exact:{400:Z4,409:J4,416:Y4,417:Q4},broad:{}}})}async fetchStatus(e={}){const t=await this.v1GetPlatformStatus(e),s=this.safeString(t,"status");return{status:this.safeString({1:"ok"},s,s),updated:void 0,eta:void 0,url:void 0,info:t}}async fetchMarkets(e={}){const t=await this.wwwGetOrderFetchMarkets(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"id"),a=this.safeString(n,"base"),o=this.safeString(n,"quote"),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o),u=this.safeValue(n,"precision",{}),h=this.safeValue(n,"limits",{}),l=this.safeValue(h,"amount",{}),p=this.safeValue(h,"price",{}),m=this.safeValue(h,"cost",{}),y=o==="USDT"?a+"_"+o:a;s.push({id:r,uppercaseId:y,symbol:d+"/"+c,base:d,quote:c,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(u,"amount"))),price:this.parseNumber(this.parsePrecision(this.safeString(u,"price")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(l,"min"),max:this.safeNumber(l,"max")},price:{min:this.safeNumber(p,"min"),max:this.safeNumber(p,"max")},cost:{min:this.safeNumber(m,"min"),max:this.safeNumber(m,"max")}},info:n})}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit=t);const r=await this.wwwGetOrderFetchOrderbook(this.extend(n,s)),a=this.safeInteger(r,"timestamp");return this.parseOrderBook(r,i.symbol,a)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.safeString(e,"last");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:this.safeString(e,"bidVolume"),ask:this.safeString(e,"ask"),askVolume:this.safeString(e,"askVolume"),vwap:this.safeString(e,"vwap"),open:this.safeString(e,"open"),close:r,last:r,previousClose:this.safeString(e,"previousClose"),change:this.safeString(e,"change"),percentage:this.safeString(e,"percentage"),average:this.safeString(e,"average"),baseVolume:this.safeString(e,"baseVolume"),quoteVolume:this.safeString(e,"quoteVolume"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.wwwGetOrderFetchTickers(t);return this.parseTickers(s,e)}parseBalance(e){const s={info:e,timestamp:void 0,datetime:this.iso8601(void 0)},i=this.safeValue(e,"data",{}),n=Object.keys(i);for(let r=0;r<n.length;r++){const a=n[r],o=a.split("availableorder");if(o.length>1){let c=this.safeString(o,1);c==="Money"&&(c="INR");const u=this.safeCurrencyCode(c),h=this.account();h.free=this.safeString(i,a),h.used=this.safeString(i,"inorder"+c),s[u]=h}}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.v1PostCurrentCoinBalanceEVERYTHING(e);return this.parseBalance(t)}parseOrderStatus(e){const t={0:"open"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString2(e,"id","entry_id"),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.parse8601(this.safeString(e,"time")),a=this.safeString(e,"rate"),o=this.safeString2(e,"amount","btc"),d=this.safeString(e,"filled"),c=this.safeString(e,"remaining"),u=this.safeString(e,"avg_cost"),h=this.safeString(e,"cost");let l=this.safeStringLower(e,"type");l==="0"&&(l="limit");const p=this.parseOrderStatus(this.safeString(e,"status")),m=this.safeStringLower(e,"side"),g=this.safeNumber(e,"fee");let y;return g!==void 0&&(y={cost:g,currency:void 0}),this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,symbol:n,type:l,timeInForce:void 0,postOnly:void 0,side:m,price:a,stopPrice:void 0,amount:o,cost:h,average:u,filled:d,remaining:c,status:p,fee:y,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){if(t!=="limit"&&t!=="market")throw new mf(this.id+" allows limit and market orders only");await this.loadMarkets();const a=this.market(e),o={side:s.toUpperCase(),symbol:a.uppercaseId,quantity:this.amountToPrecision(e,i)};let d="v2PostOrders";if(t==="limit")o.rate=this.priceToPrecision(e,n);else if(t==="market")d="v1PostPlaceMarketOrderQntySymbol",o.market=a.quoteId;else throw new mf(this.id+" allows limit and market orders only");const c=await this[d](this.extend(o,r));return this.parseOrder(c,a)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Ia(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=i.quoteId==="USDT"?"usdtcancelOrder":"cancelOrder",r={entry_id:e,symbol:i.uppercaseId,side:n},a=await this.v2PostCancel(this.extend(r,s));return this.parseOrder(a,i)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Ia(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={symbol:i.id,entry_id:e},r=await this.v1PostOrderStatusSymbol(this.extend(n,s)),a=this.safeValue(r,"data",[]),o=this.safeValue(a,0);return this.parseOrder(o,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Ia(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=n.quoteId==="USDT"?"usdtListOpenOrders":"listOpenOrders",a={symbol:n.uppercaseId,side:r,page:0},o=await this.v2PostGetordersnew(this.extend(a,i)),d=this.safeValue(o,"data",[]);return this.parseOrders(d,n,t,s)}parseTrade(e,t=void 0){t=this.safeMarket(void 0,t);const s=this.safeString2(e,"id","tradeId");let i=this.parse8601(this.safeString(e,"date"));i=this.safeInteger(e,"timestamp",i);const n=this.safeString2(e,"rate","price");let r=this.safeString(e,"amount"),a=this.safeStringLower(e,"type");a!==void 0&&(a.indexOf("buy")>=0?a="buy":a.indexOf("sell")>=0&&(a="sell"));const o=this.safeString(e,"factor");let d;o!==void 0?r=t5.stringDiv(r,o):(r=this.safeString(e,"base_volume"),d=this.safeString(e,"quote_volume"));const c=t.symbol;let u;const h=this.safeString(e,"fee");if(h!==void 0){const l=t.quote;u={cost:h,currency:l}}return this.safeTrade({info:e,timestamp:i,datetime:this.iso8601(i),symbol:c,id:s,order:s,type:void 0,side:a,takerOrMaker:void 0,price:n,amount:r,cost:d,fee:u},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Ia(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id,page:0};t!==void 0&&(r.since=this.iso8601(t));const a=await this.v1PostListExecutedOrdersSymbol(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){if(e===void 0)throw new Ia(this.id+" fetchTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={coin:n.baseId,market:n.quoteId},a=await this.wwwGetExchangeDataTradedetails(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Ia(this.id+" fetchDeposits() requires a currency code argument");await this.loadMarkets();const n=this.currency(e),r={symbol:n.id,page:0},a=await this.v1PostDepositHistorySymbol(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Ia(this.id+" fetchWithdrawals() requires a currency code argument");await this.loadMarkets();const n=this.currency(e),r={symbol:n.id,page:0},a=await this.v1PostWithdrawHistorySymbol(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s)}parseTransactionStatusByType(e,t=void 0){const s={deposit:{0:"pending",1:"ok"},withdrawal:{0:"pending",1:"canceled",2:"pending",3:"failed",4:"pending",5:"failed",6:"ok"}},i=this.safeValue(s,t,{});return this.safeString(i,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"unit"),i=this.safeCurrencyCode(s,t),n=this.parse8601(this.safeString2(e,"date","timestamp"));let r=this.safeString(e,"type");const a=this.safeString(e,"expTime","");let o;r!==void 0&&(r.indexOf("deposit")>=0?(r="deposit",o="ok"):(r.indexOf("withdraw")>=0||a.indexOf("withdraw")>=0)&&(r="withdrawal"));const d=this.safeNumber(e,"amount"),c=this.safeNumber(e,"fee");let u;return c!==void 0&&(u={currency:i,cost:c}),{info:e,id:void 0,txid:void 0,timestamp:n,datetime:this.iso8601(n),network:void 0,address:void 0,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:r,amount:d,currency:i,status:o,updated:void 0,internal:void 0,fee:u}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={symbol:this.currency(e).id},n=await this.v1PostGetCoinAddressSymbol(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeString(r,"token"),o=this.safeString(r,"tag");return this.checkAddress(a),{currency:e,address:a,tag:o,network:void 0,info:n}}nonce(){return this.milliseconds()}sign(e,t="www",s="GET",i={},n=void 0,r=void 0){if(!(t in this.urls.api))throw new mf(this.id+" does not have a testnet/sandbox URL for "+t+" endpoints");t!=="www"&&(this.checkRequiredCredentials(),n={"X-BITBNS-APIKEY":this.apiKey});let o=this.implodeHostname(this.urls.api[t])+"/"+this.implodeParams(e,i);const d=this.omit(i,this.extractParams(e)),c=this.nonce().toString();if(s==="GET")Object.keys(d).length&&(o+="?"+this.urlencode(d));else if(s==="POST"){Object.keys(d).length?r=this.json(d):r="{}";const u={timeStamp_nonce:c,body:r},h=this.stringToBase64(this.json(u)),l=this.hmac(h,this.encode(this.secret),"sha512");n["X-BITBNS-PAYLOAD"]=this.decode(h),n["X-BITBNS-SIGNATURE"]=l,n["Content-Type"]="application/x-www-form-urlencoded"}return{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"code"),u=this.safeString(a,"msg");if(c!==void 0&&c!=="200"&&c!=="204"||u!==void 0){const l=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,l),this.throwExactlyMatchedException(this.exceptions.exact,u,l),this.throwBroadlyMatchedException(this.exceptions.broad,u,l),new mf(l)}}};const i5=Dl;var v_=class extends i5{describe(){return this.deepExtend(super.describe(),{id:"fmfwio",name:"FMFW.io",countries:["KN"],urls:{logo:"https://user-images.githubusercontent.com/1294454/159177712-b685b40c-5269-4cea-ac83-f7894c49525d.jpg",api:{public:"https://api.fmfw.io",private:"https://api.fmfw.io"},www:"https://fmfw.io",doc:"https://api.fmfw.io/api/2/explore/",fees:"https://fmfw.io/fees-and-limits",referral:"https://fmfw.io/referral/da948b21d6c92d69"},fees:{trading:{maker:this.parseNumber("0.005"),taker:this.parseNumber("0.005")}}})}};const n5=v_;var r5=class extends n5{describe(){return this.deepExtend(super.describe(),{id:"bitcoincom",alias:!0})}};const a5=me,{NotSupported:o5,RateLimitExceeded:dS,AuthenticationError:cS,PermissionDenied:d5,ArgumentsRequired:uS,ExchangeError:xa,ExchangeNotAvailable:fS,InsufficientFunds:km,InvalidOrder:Xd,OrderNotFound:hS,InvalidNonce:c5,BadSymbol:u5}=oe,{SIGNIFICANT_DIGITS:f5,DECIMAL_PLACES:lS,TRUNCATE:pS,ROUND:h5}=pe,mS=ke;var T_=class extends a5{describe(){return this.deepExtend(super.describe(),{id:"bitfinex",name:"Bitfinex",countries:["VG"],version:"v1",rateLimit:666.666,pro:!0,has:{CORS:void 0,spot:!0,margin:void 0,swap:void 0,future:void 0,option:void 0,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,editOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchDepositAddress:!0,fetchDeposits:void 0,fetchIndexOHLCV:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFees:!0,fetchTransactions:!0,fetchWithdrawals:void 0,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","3h":"3h","4h":"4h","6h":"6h","12h":"12h","1d":"1D","1w":"7D","2w":"14D","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg",api:{v2:"https://api-pub.bitfinex.com",public:"https://api.bitfinex.com",private:"https://api.bitfinex.com"},www:"https://www.bitfinex.com",referral:"https://www.bitfinex.com/?refcode=P61eYxFL",doc:["https://docs.bitfinex.com/v1/docs","https://github.com/bitfinexcom/bitfinex-api-node"]},api:{v2:{get:{"platform/status":3,tickers:1,"ticker/{symbol}":1,"tickers/hist":1,"trades/{symbol}/hist":1,"book/{symbol}/{precision}":.375,"book/{symbol}/P0":.375,"book/{symbol}/P1":.375,"book/{symbol}/P2":.375,"book/{symbol}/P3":.375,"book/{symbol}/R0":.375,"stats1/{key}:{size}:{symbol}:{side}/{section}":1,"stats1/{key}:{size}:{symbol}/{section}":1,"stats1/{key}:{size}:{symbol}:long/last":1,"stats1/{key}:{size}:{symbol}:long/hist":1,"stats1/{key}:{size}:{symbol}:short/last":1,"stats1/{key}:{size}:{symbol}:short/hist":1,"candles/trade:{timeframe}:{symbol}/{section}":1,"candles/trade:{timeframe}:{symbol}/last":1,"candles/trade:{timeframe}:{symbol}/hist":1}},public:{get:{"book/{symbol}":1,"lendbook/{currency}":6,"lends/{currency}":3,"pubticker/{symbol}":3,"stats/{symbol}":6,symbols:18,symbols_details:18,tickers:1,"trades/{symbol}":3}},private:{post:{account_fees:18,account_infos:6,balances:9.036,basket_manage:6,credits:6,"deposit/new":18,"funding/close":6,history:6,"history/movements":6,key_info:6,margin_infos:3,mytrades:3,mytrades_funding:6,"offer/cancel":6,"offer/new":6,"offer/status":6,offers:6,"offers/hist":90.03,"order/cancel":.2,"order/cancel/all":.2,"order/cancel/multi":.2,"order/cancel/replace":.2,"order/new":.2,"order/new/multi":.2,"order/status":.2,orders:.2,"orders/hist":90.03,"position/claim":18,"position/close":18,positions:18,summary:18,taken_funds:6,total_taken_funds:6,transfer:18,unused_taken_funds:6,withdraw:18}}},fees:{trading:{feeSide:"get",tierBased:!0,percentage:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.002"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.002")],[this.parseNumber("500000"),this.parseNumber("0.002")],[this.parseNumber("1000000"),this.parseNumber("0.002")],[this.parseNumber("2500000"),this.parseNumber("0.002")],[this.parseNumber("5000000"),this.parseNumber("0.002")],[this.parseNumber("7500000"),this.parseNumber("0.002")],[this.parseNumber("10000000"),this.parseNumber("0.0018")],[this.parseNumber("15000000"),this.parseNumber("0.0016")],[this.parseNumber("20000000"),this.parseNumber("0.0014")],[this.parseNumber("25000000"),this.parseNumber("0.0012")],[this.parseNumber("30000000"),this.parseNumber("0.001")]],maker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("500000"),this.parseNumber("0.0008")],[this.parseNumber("1000000"),this.parseNumber("0.0006")],[this.parseNumber("2500000"),this.parseNumber("0.0004")],[this.parseNumber("5000000"),this.parseNumber("0.0002")],[this.parseNumber("7500000"),this.parseNumber("0")],[this.parseNumber("10000000"),this.parseNumber("0")],[this.parseNumber("15000000"),this.parseNumber("0")],[this.parseNumber("20000000"),this.parseNumber("0")],[this.parseNumber("25000000"),this.parseNumber("0")],[this.parseNumber("30000000"),this.parseNumber("0")]]}},funding:{tierBased:!1,percentage:!1,deposit:{},withdraw:{}}},commonCurrencies:{ALG:"ALGO",AMP:"AMPL",ATO:"ATOM",BCHABC:"XEC",BCHN:"BCH",DAT:"DATA",DOG:"MDOGE",DSH:"DASH",EDO:"PNT",EUS:"EURS",EUT:"EURT",IDX:"ID",IOT:"IOTA",IQX:"IQ",LUNA:"LUNC",LUNA2:"LUNA",MNA:"MANA",ORS:"ORS Group",PAS:"PASS",QSH:"QASH",QTM:"QTUM",RBT:"RBTC",SNG:"SNGLS",STJ:"STORJ",TERRAUST:"USTC",TSD:"TUSD",YGG:"YEED",YYW:"YOYOW",UDC:"USDC",UST:"USDT",VSY:"VSYS",WAX:"WAXP",XCH:"XCHF",ZBT:"ZB"},exceptions:{exact:{temporarily_unavailable:fS,"Order could not be cancelled.":hS,"No such order found.":hS,"Order price must be positive.":Xd,"Could not find a key matching the given X-BFX-APIKEY.":cS,'Key price should be a decimal number, e.g. "123.456"':Xd,'Key amount should be a decimal number, e.g. "123.456"':Xd,ERR_RATE_LIMIT:dS,Ratelimit:dS,"Nonce is too small.":c5,"No summary found.":xa,"Cannot evaluate your available balance, please try again":fS,"Unknown symbol":u5,"Cannot complete transfer. Exchange balance insufficient.":km,"Momentary balance check. Please wait few seconds and try the transfer again.":xa},broad:{"Invalid X-BFX-SIGNATURE":cS,"This API key does not have permission":d5,"not enough exchange balance for ":km,"minimum size for ":Xd,"Invalid order":Xd,"The available balance is only":km}},precisionMode:f5,options:{currencyNames:{AGI:"agi",AID:"aid",AIO:"aio",ANT:"ant",AVT:"aventus",BAT:"bat",BCH:"bab",BCI:"bci",BFT:"bft",BSV:"bsv",BTC:"bitcoin",BTG:"bgold",CFI:"cfi",COMP:"comp",DAI:"dai",DADI:"dad",DASH:"dash",DATA:"datacoin",DTH:"dth",EDO:"eidoo",ELF:"elf",EOS:"eos",ETC:"ethereumc",ETH:"ethereum",ETP:"metaverse",FUN:"fun",GNT:"golem",IOST:"ios",IOTA:"iota",LEO:"let",LINK:"link",LRC:"lrc",LTC:"litecoin",LYM:"lym",MANA:"mna",MIT:"mit",MKR:"mkr",MTN:"mtn",NEO:"neo",ODE:"ode",OMG:"omisego",OMNI:"mastercoin",QASH:"qash",QTUM:"qtum",RCN:"rcn",RDN:"rdn",REP:"rep",REQ:"req",RLC:"rlc",SAN:"santiment",SNGLS:"sng",SNT:"status",SPANK:"spk",STORJ:"stj",TNB:"tnb",TRX:"trx",TUSD:"tsd",USD:"wire",USDC:"udc",UTK:"utk",USDT:"tetheruso",VEE:"vee",WAX:"wax",XLM:"xlm",XMR:"monero",XRP:"ripple",XVG:"xvg",YOYOW:"yoyow",ZEC:"zcash",ZRX:"zrx",XTZ:"xtz"},orderTypes:{limit:"exchange limit",market:"exchange market"},fiat:{USD:"USD",EUR:"EUR",JPY:"JPY",GBP:"GBP",CNH:"CNH"},accountsByType:{spot:"exchange",margin:"trading",funding:"deposit",swap:"trading"}}})}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s={},i=await this.privatePostAccountFees(t),n=this.safeValue(i,"withdraw"),r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeCurrencyCode(o);e!==void 0&&!this.inArray(d,e)||(s[d]={withdraw:this.safeNumber(n,o),deposit:{},info:this.safeNumber(n,o)})}return s}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostSummary(e),s={},i=this.safeValue(this.options,"fiat",{}),n=this.safeNumber(t,"maker_fee"),r=this.safeNumber(t,"taker_fee"),a=this.safeNumber(t,"maker_fee_2fiat"),o=this.safeNumber(t,"taker_fee_2fiat"),d=this.safeNumber(t,"maker_fee_2deriv"),c=this.safeNumber(t,"taker_fee_2deriv");for(let u=0;u<this.symbols.length;u++){const h=this.symbols[u],l=this.market(h),p={info:t,symbol:h,percentage:!0,tierBased:!0};l.quote in i?(p.maker=a,p.taker=o):l.contract?(p.maker=d,p.taker=c):(p.maker=n,p.taker=r),s[h]=p}return s}async fetchMarkets(e={}){const t=await this.publicGetSymbols(),s=await this.publicGetSymbolsDetails(),i=[];for(let n=0;n<s.length;n++){const r=s[n];let a=this.safeString(r,"pair");if(!this.inArray(a,t))continue;a=a.toUpperCase();let o,d;if(a.indexOf(":")>=0){const h=a.split(":");o=h[0],d=h[1]}else o=a.slice(0,3),d=a.slice(3,6);const c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d);i.push({id:a,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:this.safeValue(r,"margin"),swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:parseInt("8"),price:this.safeInteger(r,"price_precision")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"minimum_order_size"),max:this.safeNumber(r,"maximum_order_size")},price:{min:this.parseNumber("1e-8"),max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}amountToPrecision(e,t){return this.decimalToPrecision(t,pS,this.markets[e].precision.amount,lS)}priceToPrecision(e,t){return t=this.decimalToPrecision(t,h5,this.markets[e].precision.price,this.precisionMode),this.decimalToPrecision(t,pS,8,lS)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeValue(this.options,"accountsByType",{}),s=this.safeString(e,"type","exchange"),i=this.safeString(t,s,s);if(i===void 0){const d=Object.keys(t);throw new xa(this.id+" fetchBalance() type parameter must be one of "+d.join(", "))}const n=this.omit(e,"type"),r=await this.privatePostBalances(n),a={info:r},o=s==="derivatives";for(let d=0;d<r.length;d++){const c=r[d],u=this.safeString(c,"type"),h=this.safeStringLower(c,"currency",""),l=h.length-2,p=h.slice(l)==="f0";if(i===u&&(!o||p)){const g=this.safeCurrencyCode(h);if(!(g in a)){const y=this.account();y.free=this.safeString(c,"available"),y.total=this.safeString(c,"amount"),a[g]=y}}}return this.safeBalance(a)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.safeValue(this.options,"accountsByType",{}),a=this.safeString(r,s,s),o=this.safeString(r,i,i),d=this.currency(e),c=this.convertDerivativesId(d.id,s),u=this.convertDerivativesId(d.id,i),h=this.currencyToPrecision(e,t),l={amount:h,currency:c,currency_to:u,walletfrom:a,walletto:o},p=await this.privatePostTransfer(this.extend(l,n)),m=this.safeValue(p,0);if(this.safeString(m,"message")===void 0)throw new xa(this.id+" transfer failed");return this.extend(this.parseTransfer(m,d),{fromAccount:s,toAccount:i,amount:this.parseNumber(h)})}parseTransfer(e,t=void 0){const s=this.milliseconds();return{info:e,id:void 0,timestamp:s,datetime:this.iso8601(s),currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:this.parseTransferStatus(this.safeString(e,"status"))}}parseTransferStatus(e){const t={SUCCESS:"ok"};return this.safeString(t,e,e)}convertDerivativesId(e,t){const s=e.length-2,i=e.slice(s)==="F0";return t!=="derivatives"&&t!=="trading"&&t!=="margin"&&i?e=e.slice(0,s):t==="derivatives"&&!i&&(e=e+"F0"),e}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit_bids=t,n.limit_asks=t);const r=await this.publicGetBookSymbol(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"bids","asks","price","amount")}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTickers(t),i={};for(let n=0;n<s.length;n++){const r=this.parseTicker(s[n]),a=r.symbol;i[a]=r}return this.filterByArray(i,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetPubtickerSymbol(this.extend(i,t));return this.parseTicker(n,s)}parseTicker(e,t=void 0){const s=this.safeTimestamp(e,"timestamp");let i;if(t!==void 0)i=t.symbol;else if("pair"in e){const r=this.safeString(e,"pair");if(r!==void 0)if(r in this.markets_by_id)t=this.markets_by_id[r],i=t.symbol;else{const a=r.slice(0,3),o=r.slice(3,6),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o);i=d+"/"+c}}const n=this.safeString(e,"last_price");return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeString(e,"mid"),baseVolume:this.safeString(e,"volume"),quoteVolume:void 0,info:e},t)}parseTrade(e,t=void 0){const s=this.safeString(e,"tid"),i=this.safeTimestamp(e,"timestamp"),n=void 0,r=this.safeStringLower(e,"type"),a=this.safeString(e,"order_id"),o=this.safeString(e,"price"),d=this.safeString(e,"amount");let c;if("fee_amount"in e){const u=mS.stringNeg(this.safeString(e,"fee_amount")),h=this.safeString(e,"fee_currency"),l=this.safeCurrencyCode(h);c={cost:u,currency:l}}return this.safeTrade({id:s,info:e,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,type:n,order:a,side:r,takerOrMaker:void 0,price:o,amount:d,cost:void 0,fee:c},t)}async fetchTrades(e,t=void 0,s=50,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id,limit_trades:s};t!==void 0&&(r.timestamp=parseInt(t/1e3));const a=await this.publicGetTradesSymbol(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new uS(this.id+" fetchMyTrades() requires a `symbol` argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit_trades=s),t!==void 0&&(r.timestamp=parseInt(t/1e3));const a=await this.privatePostMytrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeValue(r,"postOnly",!1);r=this.omit(r,["postOnly"]);const d={symbol:a.id,side:s,amount:this.amountToPrecision(e,i),type:this.safeString(this.options.orderTypes,t,t),ocoorder:!1,buy_price_oco:0,sell_price_oco:0};t==="market"?d.price=this.nonce().toString():d.price=this.priceToPrecision(e,n),o&&(d.is_postonly=!0);const c=await this.privatePostOrderNew(this.extend(d,r));return this.parseOrder(c,a)}async editOrder(e,t,s,i,n=void 0,r=void 0,a={}){await this.loadMarkets();const o={order_id:parseInt(e)};r!==void 0&&(o.price=this.priceToPrecision(t,r)),n!==void 0&&(o.amount=this.numberToString(n)),t!==void 0&&(o.symbol=this.marketId(t)),i!==void 0&&(o.side=i),s!==void 0&&(o.type=this.safeString(this.options.orderTypes,s,s));const d=await this.privatePostOrderCancelReplace(this.extend(o,a));return this.parseOrder(d)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:parseInt(e)};return await this.privatePostOrderCancel(this.extend(i,s))}async cancelAllOrders(e=void 0,t={}){return await this.privatePostOrderCancelAll(t)}parseOrder(e,t=void 0){const s=this.safeString(e,"side"),i=this.safeValue(e,"is_live"),n=this.safeValue(e,"is_cancelled");let r;i?r="open":n?r="canceled":r="closed";const a=this.safeStringUpper(e,"symbol"),o=this.safeSymbol(a,t);let d=this.safeString(e,"type","");d.indexOf("exchange ")>=0&&(d=e.type.split(" ")[1]);const u=this.safeTimestamp(e,"timestamp"),h=this.safeString(e,"id");return this.safeOrder({info:e,id:h,clientOrderId:void 0,timestamp:u,datetime:this.iso8601(u),lastTradeTimestamp:void 0,symbol:o,type:d,timeInForce:void 0,postOnly:void 0,side:s,price:this.safeString(e,"price"),stopPrice:void 0,average:this.safeString(e,"avg_execution_price"),amount:this.safeString(e,"original_amount"),remaining:this.safeString(e,"remaining_amount"),filled:this.safeString(e,"executed_amount"),status:r,fee:void 0,cost:void 0,trades:void 0},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),e!==void 0&&!(e in this.markets))throw new xa(this.id+" has no symbol "+e);const n=await this.privatePostOrders(i);let r=this.parseOrders(n,void 0,t,s);return e!==void 0&&(r=this.filterBy(r,"symbol",e)),r}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n={};s!==void 0&&(n.limit=s);const r=await this.privatePostOrdersHist(this.extend(n,i));let a=this.parseOrders(r,void 0,t,s);return e!==void 0&&(a=this.filterBy(a,"symbol",e)),a=this.filterByArray(a,"status",["closed","canceled"],!1),a}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:parseInt(e)},n=await this.privatePostOrderStatus(this.extend(i,s));return this.parseOrder(n)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets(),i===void 0&&(i=100);const r=this.market(e),o={symbol:"t"+r.id,timeframe:this.timeframes[t],sort:1,limit:i};s!==void 0&&(o.start=s);const d=await this.v2GetCandlesTradeTimeframeSymbolHist(this.extend(o,n));return this.parseOHLCVs(d,r,t,s,i)}getCurrencyName(e){if(e in this.options.currencyNames)return this.options.currencyNames[e];throw new o5(this.id+" "+e+" not supported for withdrawal")}async createDepositAddress(e,t={}){await this.loadMarkets();const s={renew:1};return await this.fetchDepositAddress(e,this.extend(s,t))}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={method:this.getCurrencyName(e),wallet_name:"exchange",renew:0},n=await this.privatePostDepositNew(this.extend(i,t));let r=this.safeValue(n,"address"),a;return"address_pool"in n&&(a=r,r=n.address_pool),this.checkAddress(r),{currency:e,address:r,tag:a,network:void 0,info:n}}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n=this.safeString(i,"currency");const r=this.omit(i,"currency");let a;if(n===void 0){if(e===void 0)throw new uS(this.id+" fetchTransactions() requires a currency `code` argument or a `currency` parameter");a=this.currency(e),n=a.id}r.currency=n,t!==void 0&&(r.since=parseInt(t/1e3));const o=await this.privatePostHistoryMovements(this.extend(r,i));return this.parseTransactions(o,a,t,s)}parseTransaction(e,t=void 0){const s=this.safeTimestamp(e,"timestamp_created"),i=this.safeTimestamp(e,"timestamp"),n=this.safeString(e,"currency"),r=this.safeCurrencyCode(n,t),a=this.safeStringLower(e,"type"),o=this.parseTransactionStatus(this.safeString(e,"status"));let d=this.safeString(e,"fee");d!==void 0&&(d=mS.stringAbs(d));const c=this.safeString(e,"description");return{info:e,id:this.safeString2(e,"id","withdrawal_id"),txid:this.safeString(e,"txid"),timestamp:s,datetime:this.iso8601(s),network:void 0,address:this.safeString(e,"address"),addressTo:void 0,addressFrom:void 0,tag:c,tagTo:void 0,tagFrom:void 0,type:a,amount:this.safeNumber(e,"amount"),currency:r,status:o,updated:i,fee:{currency:r,cost:this.parseNumber(d),rate:void 0}}}parseTransactionStatus(e){const t={SENDING:"pending",CANCELED:"canceled",ZEROCONFIRMED:"failed",COMPLETED:"ok"};return this.safeString(t,e,e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.getCurrencyName(e),a=this.currency(e),o={withdraw_type:r,walletselected:"exchange",amount:this.numberToString(t),address:s};i!==void 0&&(o.payment_id=i);const d=await this.privatePostWithdraw(this.extend(o,n)),c=this.safeValue(d,0,{}),u=this.safeNumber(c,"withdrawal_id"),h=this.safeString(c,"message"),l=this.findBroadlyMatchedKey(this.exceptions.broad,h);if(u===0){if(l!==void 0){const p=this.exceptions.broad[l];throw new p(this.id+" "+h)}throw new xa(this.id+" withdraw returned an id of zero: "+this.json(c))}return this.parseTransaction(c,a)}async fetchPositions(e=void 0,t={}){return await this.loadMarkets(),await this.privatePostPositions(t)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.implodeParams(e,i);t==="v2"?a="/"+t+a:a="/"+this.version+a;let o=this.omit(i,this.extractParams(e)),d=this.urls.api[t]+a;if((t==="public"||e.indexOf("/hist")>=0)&&Object.keys(o).length){const c="?"+this.urlencode(o);d+=c,a+=c}if(t==="private"){this.checkRequiredCredentials();const c=this.nonce();o=this.extend({nonce:c.toString(),request:a},o),r=this.json(o);const u=this.stringToBase64(r),h=this.encode(this.secret),l=this.hmac(u,h,"sha384");n={"X-BFX-APIKEY":this.apiKey,"X-BFX-PAYLOAD":this.decode(u),"X-BFX-SIGNATURE":l,"Content-Type":"application/json"}}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;let c=!1;if(e>=400)this.safeString(r,0)==="{"&&(c=!0);else{const u=this.safeValue(a,0,{});this.safeString(u,"status","")==="error"&&(c=!0)}if(c){const u=this.id+" "+r,h=this.safeString2(a,"message","error");throw this.throwExactlyMatchedException(this.exceptions.exact,h,u),this.throwBroadlyMatchedException(this.exceptions.broad,h,u),new xa(u)}}};const l5=me,{ExchangeError:_a,InvalidAddress:p5,ArgumentsRequired:Yd,InsufficientFunds:gS,AuthenticationError:m5,OrderNotFound:vm,InvalidOrder:gf,BadRequest:g5,InvalidNonce:y5,BadSymbol:b5,OnMaintenance:w5,NotSupported:yS,PermissionDenied:S5,ExchangeNotAvailable:k5}=oe,$i=ke,{SIGNIFICANT_DIGITS:v5,DECIMAL_PLACES:bS,TRUNCATE:wS,ROUND:T5}=pe;var O_=class extends l5{describe(){return this.deepExtend(super.describe(),{id:"bitfinex2",name:"Bitfinex",countries:["VG"],version:"v2",certified:!1,pro:!1,has:{CORS:void 0,spot:!0,margin:void 0,swap:void 0,future:void 0,option:void 0,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createLimitOrder:!0,createMarketOrder:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:void 0,fetchBalance:!0,fetchClosedOrder:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchIndexOHLCV:!1,fetchLedger:!0,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrder:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderTrades:!0,fetchPositionMode:!1,fetchStatus:!0,fetchTickers:!0,fetchTime:!1,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFees:void 0,fetchTransactions:!0,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","3h":"3h","4h":"4h","6h":"6h","12h":"12h","1d":"1D","1w":"7D","2w":"14D","1M":"1M"},rateLimit:250,urls:{logo:"https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg",api:{v1:"https://api.bitfinex.com",public:"https://api-pub.bitfinex.com",private:"https://api.bitfinex.com"},www:"https://www.bitfinex.com",doc:["https://docs.bitfinex.com/v2/docs/","https://github.com/bitfinexcom/bitfinex-api-node"],fees:"https://www.bitfinex.com/fees"},api:{public:{get:{"conf/{config}":2.66,"conf/pub:{action}:{object}":2.66,"conf/pub:{action}:{object}:{detail}":2.66,"conf/pub:map:{object}":2.66,"conf/pub:map:{object}:{detail}":2.66,"conf/pub:map:currency:{detail}":2.66,"conf/pub:map:currency:sym":2.66,"conf/pub:map:currency:label":2.66,"conf/pub:map:currency:unit":2.66,"conf/pub:map:currency:undl":2.66,"conf/pub:map:currency:pool":2.66,"conf/pub:map:currency:explorer":2.66,"conf/pub:map:currency:tx:fee":2.66,"conf/pub:map:tx:method":2.66,"conf/pub:list:{object}":2.66,"conf/pub:list:{object}:{detail}":2.66,"conf/pub:list:currency":2.66,"conf/pub:list:pair:exchange":2.66,"conf/pub:list:pair:margin":2.66,"conf/pub:list:pair:futures":2.66,"conf/pub:list:competitions":2.66,"conf/pub:info:{object}":2.66,"conf/pub:info:{object}:{detail}":2.66,"conf/pub:info:pair":2.66,"conf/pub:info:pair:futures":2.66,"conf/pub:info:tx:status":2.66,"conf/pub:fees":2.66,"platform/status":8,tickers:2.66,"ticker/{symbol}":2.66,"tickers/hist":2.66,"trades/{symbol}/hist":2.66,"book/{symbol}/{precision}":1,"book/{symbol}/P0":1,"book/{symbol}/P1":1,"book/{symbol}/P2":1,"book/{symbol}/P3":1,"book/{symbol}/R0":1,"stats1/{key}:{size}:{symbol}:{side}/{section}":2.66,"stats1/{key}:{size}:{symbol}:{side}/last":2.66,"stats1/{key}:{size}:{symbol}:{side}/hist":2.66,"stats1/{key}:{size}:{symbol}/{section}":2.66,"stats1/{key}:{size}:{symbol}/last":2.66,"stats1/{key}:{size}:{symbol}/hist":2.66,"stats1/{key}:{size}:{symbol}:long/last":2.66,"stats1/{key}:{size}:{symbol}:long/hist":2.66,"stats1/{key}:{size}:{symbol}:short/last":2.66,"stats1/{key}:{size}:{symbol}:short/hist":2.66,"candles/trade:{timeframe}:{symbol}:{period}/{section}":2.66,"candles/trade:{timeframe}:{symbol}/{section}":2.66,"candles/trade:{timeframe}:{symbol}/last":2.66,"candles/trade:{timeframe}:{symbol}/hist":2.66,"status/{type}":2.66,"status/deriv":2.66,"liquidations/hist":80,"rankings/{key}:{timeframe}:{symbol}/{section}":2.66,"rankings/{key}:{timeframe}:{symbol}/hist":2.66,"pulse/hist":2.66,"pulse/profile/{nickname}":2.66,"funding/stats/{symbol}/hist":10},post:{"calc/trade/avg":2.66,"calc/fx":2.66}},private:{post:{"auth/r/wallets":2.66,"auth/r/wallets/hist":2.66,"auth/r/orders":2.66,"auth/r/orders/{symbol}":2.66,"auth/w/order/submit":2.66,"auth/w/order/update":2.66,"auth/w/order/cancel":2.66,"auth/w/order/multi":2.66,"auth/w/order/cancel/multi":2.66,"auth/r/orders/{symbol}/hist":2.66,"auth/r/orders/hist":2.66,"auth/r/order/{symbol}:{id}/trades":2.66,"auth/r/trades/{symbol}/hist":2.66,"auth/r/trades/hist":2.66,"auth/r/ledgers/{currency}/hist":2.66,"auth/r/ledgers/hist":2.66,"auth/r/info/margin/{key}":2.66,"auth/r/info/margin/base":2.66,"auth/r/info/margin/sym_all":2.66,"auth/r/positions":2.66,"auth/w/position/claim":2.66,"auth/w/position/increase:":2.66,"auth/r/position/increase/info":2.66,"auth/r/positions/hist":2.66,"auth/r/positions/audit":2.66,"auth/r/positions/snap":2.66,"auth/w/deriv/collateral/set":2.66,"auth/w/deriv/collateral/limits":2.66,"auth/r/funding/offers":2.66,"auth/r/funding/offers/{symbol}":2.66,"auth/w/funding/offer/submit":2.66,"auth/w/funding/offer/cancel":2.66,"auth/w/funding/offer/cancel/all":2.66,"auth/w/funding/close":2.66,"auth/w/funding/auto":2.66,"auth/w/funding/keep":2.66,"auth/r/funding/offers/{symbol}/hist":2.66,"auth/r/funding/offers/hist":2.66,"auth/r/funding/loans":2.66,"auth/r/funding/loans/hist":2.66,"auth/r/funding/loans/{symbol}":2.66,"auth/r/funding/loans/{symbol}/hist":2.66,"auth/r/funding/credits":2.66,"auth/r/funding/credits/hist":2.66,"auth/r/funding/credits/{symbol}":2.66,"auth/r/funding/credits/{symbol}/hist":2.66,"auth/r/funding/trades/{symbol}/hist":2.66,"auth/r/funding/trades/hist":2.66,"auth/r/info/funding/{key}":2.66,"auth/r/info/user":2.66,"auth/r/summary":2.66,"auth/r/logins/hist":2.66,"auth/r/permissions":2.66,"auth/w/token":2.66,"auth/r/audit/hist":2.66,"auth/w/transfer":2.66,"auth/w/deposit/address":24,"auth/w/deposit/invoice":24,"auth/w/withdraw":24,"auth/r/movements/{currency}/hist":2.66,"auth/r/movements/hist":2.66,"auth/r/alerts":5.33,"auth/w/alert/set":2.66,"auth/w/alert/price:{symbol}:{price}/del":2.66,"auth/w/alert/{type}:{symbol}:{price}/del":2.66,"auth/calc/order/avail":2.66,"auth/w/settings/set":2.66,"auth/r/settings":2.66,"auth/w/settings/del":2.66,"auth/r/pulse/hist":2.66,"auth/w/pulse/add":16,"auth/w/pulse/del":2.66}}},fees:{trading:{feeSide:"get",percentage:!0,tierBased:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.002"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.002")],[this.parseNumber("500000"),this.parseNumber("0.002")],[this.parseNumber("1000000"),this.parseNumber("0.002")],[this.parseNumber("2500000"),this.parseNumber("0.002")],[this.parseNumber("5000000"),this.parseNumber("0.002")],[this.parseNumber("7500000"),this.parseNumber("0.002")],[this.parseNumber("10000000"),this.parseNumber("0.0018")],[this.parseNumber("15000000"),this.parseNumber("0.0016")],[this.parseNumber("20000000"),this.parseNumber("0.0014")],[this.parseNumber("25000000"),this.parseNumber("0.0012")],[this.parseNumber("30000000"),this.parseNumber("0.001")]],maker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("500000"),this.parseNumber("0.0008")],[this.parseNumber("1000000"),this.parseNumber("0.0006")],[this.parseNumber("2500000"),this.parseNumber("0.0004")],[this.parseNumber("5000000"),this.parseNumber("0.0002")],[this.parseNumber("7500000"),this.parseNumber("0")],[this.parseNumber("10000000"),this.parseNumber("0")],[this.parseNumber("15000000"),this.parseNumber("0")],[this.parseNumber("20000000"),this.parseNumber("0")],[this.parseNumber("25000000"),this.parseNumber("0")],[this.parseNumber("30000000"),this.parseNumber("0")]]}},funding:{withdraw:{}}},precisionMode:v5,options:{precision:"R0",exchangeTypes:{"EXCHANGE MARKET":"market","EXCHANGE LIMIT":"limit","EXCHANGE STOP":"market","EXCHANGE FOK":"limit","EXCHANGE STOP LIMIT":"limit","EXCHANGE IOC":"limit"},orderTypes:{market:"EXCHANGE MARKET",limit:"EXCHANGE LIMIT"},fiat:{USD:"USD",EUR:"EUR",JPY:"JPY",GBP:"GBP",CHN:"CHN"},v2AccountsByType:{spot:"exchange",exchange:"exchange",funding:"funding",margin:"margin",derivatives:"margin",future:"margin"}},exceptions:{exact:{10001:S5,10020:g5,10100:m5,10114:y5,20060:w5,temporarily_unavailable:k5},broad:{address:p5,"available balance is only":gS,"not enough exchange balance":gS,"Order not found":vm,"symbol: invalid":b5,"Invalid order":gf}},commonCurrencies:{UST:"USDT",EUTF0:"EURT",USTF0:"USDT",ALG:"ALGO",AMP:"AMPL",ATO:"ATOM",BCHABC:"XEC",BCHN:"BCH",DAT:"DATA",DOG:"MDOGE",DSH:"DASH",EDO:"PNT",EUS:"EURS",EUT:"EURT",IDX:"ID",IOT:"IOTA",IQX:"IQ",LUNA:"LUNC",LUNA2:"LUNA",MNA:"MANA",ORS:"ORS Group",PAS:"PASS",QSH:"QASH",QTM:"QTUM",RBT:"RBTC",SNG:"SNGLS",STJ:"STORJ",TERRAUST:"USTC",TSD:"TUSD",YGG:"YEED",YYW:"YOYOW",UDC:"USDC",VSY:"VSYS",WAX:"WAXP",XCH:"XCHF",ZBT:"ZB"}})}isFiat(e){return e in this.options.fiat}getCurrencyId(e){return"f"+e}getCurrencyName(e){if(e in this.options.currencyNames)return this.options.currencyNames[e];throw new yS(this.id+" "+e+" not supported for withdrawal")}amountToPrecision(e,t){return this.decimalToPrecision(t,wS,this.markets[e].precision.amount,bS)}priceToPrecision(e,t){return t=this.decimalToPrecision(t,T5,this.markets[e].precision.price,this.precisionMode),this.decimalToPrecision(t,wS,8,bS)}async fetchStatus(e={}){const t=await this.publicGetPlatformStatus(e),s=this.safeString(t,0);return{status:this.safeString({0:"maintenance",1:"ok"},s,s),updated:void 0,eta:void 0,url:void 0,info:t}}async fetchMarkets(e={}){let t=await this.publicGetConfPubInfoPair(e),s=await this.publicGetConfPubInfoPairFutures(e);t=this.safeValue(t,0,[]),s=this.safeValue(s,0,[]);const i=this.arrayConcat(t,s);let n=await this.publicGetConfPubListPairMargin(e);n=this.safeValue(n,0,[]);const r=[];for(let a=0;a<i.length;a++){const o=i[a],d=this.safeStringUpper(o,0),c=this.safeValue(o,1,{});let u=!0;d.indexOf("F0")>=0&&(u=!1);const h=!u;let l,p;if(d.indexOf(":")>=0){const _=d.split(":");l=_[0],p=_[1]}else l=d.slice(0,3),p=d.slice(3,6);let m=this.safeCurrencyCode(l),g=this.safeCurrencyCode(p);const y=m.split("F0"),b=g.split("F0");m=this.safeString(y,0),g=this.safeString(b,0);let w=m+"/"+g;l=this.getCurrencyId(l),p=this.getCurrencyId(p);let S;h&&(S=g,w=w+":"+S);const k=this.safeString(c,3),T=this.safeString(c,4);let I=!1;this.inArray(d,n)&&(I=!0),r.push({id:"t"+d,symbol:w,base:m,quote:g,settle:S,baseId:l,quoteId:p,settleId:p,type:u?"spot":"swap",spot:u,margin:I,swap:h,future:!1,option:!1,active:!0,contract:h,linear:h?!0:void 0,inverse:h?!1:void 0,contractSize:h?this.parseNumber("1"):void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:parseInt("8"),price:parseInt("5")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.parseNumber(k),max:this.parseNumber(T)},price:{min:this.parseNumber("1e-8"),max:void 0},cost:{min:void 0,max:void 0}},info:c})}return r}async fetchCurrencies(e={}){const i={config:["pub:list:currency","pub:map:currency:sym","pub:map:currency:label","pub:map:currency:unit","pub:map:currency:undl","pub:map:currency:pool","pub:map:currency:explorer","pub:map:currency:tx:fee","pub:map:tx:method"].join(",")},n=await this.publicGetConfConfig(this.extend(i,e)),r={sym:this.indexBy(this.safeValue(n,1,[]),0),label:this.indexBy(this.safeValue(n,2,[]),0),unit:this.indexBy(this.safeValue(n,3,[]),0),undl:this.indexBy(this.safeValue(n,4,[]),0),pool:this.indexBy(this.safeValue(n,5,[]),0),explorer:this.indexBy(this.safeValue(n,6,[]),0),fees:this.indexBy(this.safeValue(n,7,[]),0)},a=this.safeValue(n,0,[]),o={};for(let d=0;d<a.length;d++){const c=a[d];if(c.indexOf("F0")>=0)continue;const u=this.safeCurrencyCode(c),h=this.safeValue(r.label,c,[]),l=this.safeString(h,1),p=this.safeValue(r.pool,c,[]),m=this.safeString(p,1),g=this.safeValue(r.fees,c,[]),y=this.safeValue(g,1,[]),b=this.safeNumber(y,1),w=this.safeValue(r.undl,c,[]),S="8",k="f"+c;o[u]={id:k,uppercaseId:c,code:u,info:[c,h,p,g,w],type:m,name:l,active:!0,deposit:void 0,withdraw:void 0,fee:b,precision:parseInt(S),limits:{amount:{min:this.parseNumber(this.parsePrecision(S)),max:void 0},withdraw:{min:b,max:void 0}}};const T={},I=this.safeValue(n,8,[]),_=c.replace("F0","");for(let x=0;x<I.length;x++){const v=I[x],O=this.safeString(v,0);if(this.safeString(this.safeValue(v,1,[]),0)===_){const V=this.safeNetwork(O);T[V]={info:O,id:O.toLowerCase(),network:O,active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,precision:void 0,limits:{withdraw:{min:void 0,max:void 0}}}}}Object.keys(T).length>0&&(o[u].networks=T)}return o}safeNetwork(e){const t={BITCOIN:"BTC",LITECOIN:"LTC",ETHEREUM:"ERC20",TETHERUSE:"ERC20",TETHERUSO:"OMNI",TETHERUSL:"LIQUID",TETHERUSX:"TRC20",TETHERUSS:"EOS",TETHERUSDTAVAX:"AVAX",TETHERUSDTSOL:"SOL",TETHERUSDTALG:"ALGO",TETHERUSDTBCH:"BCH",TETHERUSDTKSM:"KSM",TETHERUSDTDVF:"DVF",TETHERUSDTOMG:"OMG"};return this.safeString(t,e,e)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeValue(this.options,"v2AccountsByType",{}),s=this.safeString(e,"type","exchange"),i=this.safeString(t,s,s);if(i===void 0){const d=Object.keys(t);throw new _a(this.id+" fetchBalance() type parameter must be one of "+d.join(", "))}const n=s==="derivatives",r=this.omit(e,"type"),a=await this.privatePostAuthRWallets(r),o={info:a};for(let d=0;d<a.length;d++){const c=a[d],u=this.safeString(c,0),h=this.safeStringLower(c,1,""),l=h.length-2,p=h.slice(l)==="f0";if(i===u&&(!n||p)){const g=this.safeCurrencyCode(h),y=this.account();y.total=this.safeString(c,2),y.free=this.safeString(c,4),o[g]=y}}return this.safeBalance(o)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.safeValue(this.options,"v2AccountsByType",{}),a=this.safeString(r,s);if(a===void 0){const g=Object.keys(r);throw new Yd(this.id+" transfer() fromAccount must be one of "+g.join(", "))}const o=this.safeString(r,i);if(o===void 0){const g=Object.keys(r);throw new Yd(this.id+" transfer() toAccount must be one of "+g.join(", "))}const d=this.currency(e),c=this.convertDerivativesId(d,s),u=this.convertDerivativesId(d,i),l={amount:this.currencyToPrecision(e,t),currency:c,currency_to:u,from:a,to:o},p=await this.privatePostAuthWTransfer(this.extend(l,n));if(this.safeString(p,0)==="error"){const g=this.safeString(p,2,"");throw this.throwExactlyMatchedException(this.exceptions.exact,g,this.id+" "+g),new _a(this.id+" "+g)}return this.parseTransfer(p,d)}parseTransfer(e,t=void 0){const s=this.safeInteger(e,0),i=this.safeValue(e,4),n=this.safeString(i,1),r=this.safeString(i,2),a=this.safeString(i,5),o=this.safeString(e,6);return{id:void 0,timestamp:s,datetime:this.iso8601(s),status:this.parseTransferStatus(o),amount:this.safeNumber(i,7),currency:this.safeCurrencyCode(a,t),fromAccount:n,toAccount:r,info:e}}parseTransferStatus(e){const t={SUCCESS:"ok",ERROR:"failed",FAILURE:"failed"};return this.safeString(t,e,e)}convertDerivativesId(e,t){const s=this.safeValue(e,"info"),i=this.safeString(s,0),n=this.safeValue(s,4,[]);let r;if(t==="derivatives"){r=this.safeString(n,0,i);const a=r.length-2;r.slice(a)==="F0"||(r=r+"F0")}else t!=="margin"?r=this.safeString(n,1,i):r=i;return r}async fetchOrder(e,t=void 0,s={}){throw new yS(this.id+" fetchOrder() is not supported yet. Consider using fetchOpenOrder() or fetchClosedOrder() instead.")}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue(this.options,"precision","R0"),n=this.market(e),r={symbol:n.id,precision:i};t!==void 0&&(r.len=t);const a=this.extend(r,s),o=await this.publicGetBookSymbolPrecision(a),d=this.milliseconds(),c={symbol:n.symbol,bids:[],asks:[],timestamp:d,datetime:this.iso8601(d),nonce:void 0},u=a.precision==="R0"?1:0;for(let h=0;h<o.length;h++){const l=o[h],p=this.safeNumber(l,u),m=this.safeString(l,2),g=$i.stringAbs(m),y=$i.stringGt(m,"0")?"bids":"asks";c[y].push([p,this.parseNumber(g)])}return c.bids=this.sortBy(c.bids,0,!0),c.asks=this.sortBy(c.asks,0),c}parseTicker(e,t=void 0){const s=this.milliseconds(),i=this.safeSymbol(void 0,t),n=e.length,r=this.safeString(e,n-4),a=this.safeString(e,n-5);return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,n-2),low:this.safeString(e,n-1),bid:this.safeString(e,n-10),bidVolume:void 0,ask:this.safeString(e,n-8),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:this.safeString(e,n-6),percentage:$i.stringMul(a,"100"),average:void 0,baseVolume:this.safeString(e,n-3),quoteVolume:void 0,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={};if(e!==void 0){const r=this.marketIds(e);s.symbols=r.join(",")}else s.symbols="ALL";const i=await this.publicGetTickers(this.extend(s,t)),n={};for(let r=0;r<i.length;r++){const a=i[r],o=a[0];if(o in this.markets_by_id){const d=this.markets_by_id[o],c=d.symbol;n[c]=this.parseTicker(a,d)}}return this.filterByArray(n,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetTickerSymbol(this.extend(i,t));return this.parseTicker(n,s)}parseSymbol(e){if(e===void 0)return e;e=e.replace("t","");let t,s;if(e.indexOf(":")>=0){const r=e.split(":");t=r[0],s=r[1]}else t=e.slice(0,3),s=e.slice(3,6);const i=this.safeCurrencyCode(t),n=this.safeCurrencyCode(s);return i+"/"+n}parseTrade(e,t=void 0){const i=e.length>5,n=this.safeString(e,0),r=i?4:2;let a,o=this.safeString(e,r);const d=i?5:3,c=this.safeString(e,d);o[0]==="-"?(a="sell",o=$i.stringAbs(o)):a="buy";let u,h,l,p,m;const g=i?2:1,y=this.safeInteger(e,g);if(i){const b=e[1];b in this.markets_by_id?(t=this.markets_by_id[b],m=t.symbol):m=this.parseSymbol(b),u=this.safeString(e,3),h=this.safeInteger(e,8)===1?"maker":"taker";let S=this.safeString(e,9);S=$i.stringNeg(S);const k=this.safeString(e,10),T=this.safeCurrencyCode(k);p={cost:S,currency:T};const I=e[6];l=this.safeString(this.options.exchangeTypes,I)}return m===void 0&&t!==void 0&&(m=t.symbol),this.safeTrade({id:n,timestamp:y,datetime:this.iso8601(y),symbol:m,order:u,side:a,type:l,takerOrMaker:h,price:c,amount:o,cost:void 0,fee:p,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);let r="-1";const a={symbol:n.id};t!==void 0&&(a.start=t,r="1"),s!==void 0&&(a.limit=s),a.sort=r;const o=await this.publicGetTradesSymbolHist(this.extend(a,i)),d=this.sortBy(o,1);return this.parseTrades(d,n,void 0,s)}async fetchOHLCV(e,t="1m",s=void 0,i=100,n={}){await this.loadMarkets();const r=this.market(e);if(i===void 0&&(i=100),s===void 0){const d=this.parseTimeframe(t);s=this.milliseconds()-d*i*1e3}const a={symbol:r.id,timeframe:this.timeframes[t],sort:1,start:s,limit:i},o=await this.publicGetCandlesTradeTimeframeSymbolHist(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,5)]}parseOrderStatus(e){if(e===void 0)return e;const t=e.split(" "),s=this.safeString(t,0),i={ACTIVE:"open",PARTIALLY:"open",EXECUTED:"closed",CANCELED:"canceled",INSUFFICIENT:"canceled","POSTONLY CANCELED":"canceled",RSN_DUST:"rejected",RSN_PAUSE:"rejected","IOC CANCELED":"canceled","FILLORKILL CANCELED":"canceled"};return this.safeString(i,s,e)}parseOrderFlags(e){const t={1024:["reduceOnly"],4096:["postOnly"],5120:["reduceOnly","postOnly"]};return this.safeValue(t,e,void 0)}parseTimeInForce(e){const t={"EXCHANGE IOC":"IOC","EXCHANGE FOK":"FOK",IOC:"IOC",FOK:"FOK"};return this.safeString(t,e,"GTC")}parseOrder(e,t=void 0){const s=this.safeString(e,0);let i;const n=this.safeString(e,3);n in this.markets_by_id?t=this.markets_by_id[n]:i=this.parseSymbol(n),i===void 0&&t!==void 0&&(i=t.symbol);const r=this.safeInteger(e,5),a=$i.stringAbs(this.safeString(e,6)),o=this.safeString(e,7),d=$i.stringAbs(o),c=$i.stringLt(o,"0")?"sell":"buy",u=this.safeString(e,8),h=this.safeString(this.safeValue(this.options,"exchangeTypes"),u),l=this.parseTimeInForce(u),p=this.safeString(e,12),m=this.parseOrderFlags(p);let g=!1;if(m!==void 0)for(let I=0;I<m.length;I++)m[I]==="postOnly"&&(g=!0);let y=this.safeString(e,16),b;(u==="EXCHANGE STOP"||u==="EXCHANGE STOP LIMIT")&&(y=void 0,b=this.safeNumber(e,16),u==="EXCHANGE STOP LIMIT"&&(y=this.safeNumber(e,19)));let w;const S=this.safeString(e,13);if(S!==void 0){const I=S.split(" @ ");w=this.parseOrderStatus(this.safeString(I,0))}const k=this.safeString(e,17),T=this.safeString(e,2);return this.safeOrder({info:e,id:s,clientOrderId:T,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,symbol:i,type:h,timeInForce:l,postOnly:g,side:c,price:y,stopPrice:b,amount:d,cost:void 0,average:k,filled:void 0,remaining:a,status:w,fee:void 0,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeValue(this.options,"orderTypes",{}),d=this.safeStringUpper(o,t,t),c=this.safeString2(r,"stopPrice","triggerPrice"),u=this.safeString(r,"timeInForce"),h=this.safeValue(r,"postOnly",!1),l=this.safeValue(r,"reduceOnly",!1),p=this.safeValue2(r,"cid","clientOrderId");r=this.omit(r,["triggerPrice","stopPrice","timeInForce","postOnly","reduceOnly","price_aux_limit"]);let m=this.amountToPrecision(e,i);m=s==="buy"?m:$i.stringNeg(m);const g={type:d,symbol:a.id,amount:m},y=d==="EXCHANGE STOP LIMIT"||d==="EXCHANGE LIMIT"&&c!==void 0,b=d==="EXCHANGE STOP",w=d==="EXCHANGE MARKET",S=b||w&&c!==void 0,k=d==="EXCHANGE IOC"||u==="IOC",T=d==="EXCHANGE FOK"||u==="FOK",I=h||u==="PO";if((k||T)&&n===void 0)throw new gf(this.id+" createOrder() requires a price argument with IOC and FOK orders");if((k||T)&&w)throw new gf(this.id+" createOrder() does not allow market IOC and FOK orders");d!=="MARKET"&&!w&&!b&&(g.price=this.priceToPrecision(e,n)),(y||S)&&(g.price=this.priceToPrecision(e,c),S?g.type="EXCHANGE STOP":y&&(g.type="EXCHANGE STOP LIMIT",g.price_aux_limit=this.priceToPrecision(e,n))),k?g.type="EXCHANGE IOC":T&&(g.type="EXCHANGE FOK");let _=0;I&&(_=this.sum(_,4096)),l&&(_=this.sum(_,1024)),_!==0&&(g.flags=_),p!==void 0&&(g.cid=p,r=this.omit(r,["cid","clientOrderId"]));const N=await this.privatePostAuthWOrderSubmit(this.extend(g,r));if(this.safeString(N,6)!=="SUCCESS"){const O=N[5],A=N[7];throw new _a(this.id+" "+N[6]+": "+A+" (#"+O+")")}const x=this.safeValue(N,4,[]),v=this.safeValue(x,0);return this.parseOrder(v,a)}async cancelAllOrders(e=void 0,t={}){const s={all:1},i=await this.privatePostAuthWOrderCancelMulti(this.extend(s,t)),n=this.safeValue(i,4,[]);return this.parseOrders(n)}async cancelOrder(e,t=void 0,s={}){const i=this.safeValue2(s,"cid","clientOrderId");let n;if(i!==void 0){const o=this.safeValue(s,"cidDate");if(o===void 0)throw new gf(this.id+" canceling an order by clientOrderId ('cid') requires both 'cid' and 'cid_date' ('YYYY-MM-DD')");n={cid:i,cid_date:o},s=this.omit(s,["cid","clientOrderId"])}else n={id:parseInt(e)};const r=await this.privatePostAuthWOrderCancel(this.extend(n,s)),a=this.safeValue(r,4);return this.parseOrder(a)}async fetchOpenOrder(e,t=void 0,s={}){const i={id:[parseInt(e)]},n=await this.fetchOpenOrders(t,void 0,void 0,this.extend(i,s)),r=this.safeValue(n,0);if(r===void 0)throw new vm(this.id+" order "+e+" not found");return r}async fetchClosedOrder(e,t=void 0,s={}){const i={id:[parseInt(e)]},n=await this.fetchClosedOrders(t,void 0,void 0,this.extend(i,s)),r=this.safeValue(n,0);if(r===void 0)throw new vm(this.id+" order "+e+" not found");return r}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r,a;return e===void 0?a=await this.privatePostAuthROrders(this.extend(n,i)):(r=this.market(e),n.symbol=r.id,a=await this.privatePostAuthROrdersSymbol(this.extend(n,i))),this.parseOrders(a,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.start=t),s!==void 0&&(n.limit=s);let r,a;return e===void 0?a=await this.privatePostAuthROrdersHist(this.extend(n,i)):(r=this.market(e),n.symbol=r.id,a=await this.privatePostAuthROrdersSymbolHist(this.extend(n,i))),this.parseOrders(a,r,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){if(t===void 0)throw new Yd(this.id+" fetchOrderTrades() requires a symbol argument");await this.loadMarkets();const r=this.market(t),o={id:parseInt(e),symbol:r.id},d=await this.privatePostAuthROrderSymbolIdTrades(this.extend(o,n));return this.parseTrades(d,r,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={end:this.milliseconds()};t!==void 0&&(r.start=t),s!==void 0&&(r.limit=s);let a="privatePostAuthRTradesHist";e!==void 0&&(n=this.market(e),r.symbol=n.id,a="privatePostAuthRTradesSymbolHist");const o=await this[a](this.extend(r,i));return this.parseTrades(o,n,t,s)}async createDepositAddress(e,t={}){await this.loadMarkets();const s={op_renew:1};return await this.fetchDepositAddress(e,this.extend(s,t))}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i=this.safeString(t,"network",e),n=this.safeValue(s,"networks",{}),r=this.safeValue(n,i),a=this.safeString(r,"id");if(a===void 0)throw new Yd(this.id+" fetchDepositAddress() could not find a network for '"+e+"'. You can specify it by providing the 'network' value inside params");const o=this.safeString(t,"wallet","exchange");t=this.omit(t,"network","wallet");const d={method:a,wallet:o,op_renew:0},c=await this.privatePostAuthWDepositAddress(this.extend(d,t)),u=this.safeValue(c,4,[]),h=this.safeString(u,5),l=h===void 0?this.safeString(u,4):h,p=h===void 0?void 0:this.safeString(u,4);return this.checkAddress(l),{currency:e,address:l,tag:p,network:void 0,info:c}}parseTransactionStatus(e){const t={SUCCESS:"ok",ERROR:"failed",FAILURE:"failed",CANCELED:"canceled",COMPLETED:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=e.length;let i,n,r,a,o,d,c,u,h,l,p;if(s===8){const m=this.safeValue(e,4,[]);i=this.safeInteger(e,0),t!==void 0&&(r=t.code),h=this.safeString(m,8),h!==void 0&&(h=$i.stringNeg(h)),a=this.safeNumber(m,5),o=this.safeValue(m,0),d="ok",o===0&&(o=void 0,d="failed"),c=this.safeString(m,3),u="withdrawal"}else if(s===22){o=this.safeString(e,0);const m=this.safeString(e,1);r=this.safeCurrencyCode(m,t),i=this.safeInteger(e,5),n=this.safeInteger(e,6),d=this.parseTransactionStatus(this.safeString(e,9)),a=this.safeString(e,12),a!==void 0&&($i.stringLt(a,"0")?u="withdrawal":u="deposit"),h=this.safeString(e,13),h!==void 0&&(h=$i.stringNeg(h)),p=this.safeString(e,16),l=this.safeString(e,20)}return{info:e,id:o,txid:l,timestamp:i,datetime:this.iso8601(i),network:void 0,addressFrom:void 0,address:p,addressTo:p,tagFrom:void 0,tag:c,tagTo:c,type:u,amount:this.parseNumber(a),currency:r,status:d,updated:n,fee:{currency:r,cost:this.parseNumber(h),rate:void 0}}}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostAuthRSummary(e),s={},i=this.safeValue(this.options,"fiat",{}),n=this.safeValue(t,4,[]),r=this.safeValue(n,0,[]),a=this.safeValue(n,1,[]),o=this.safeNumber(r,0),d=this.safeNumber(r,2),c=this.safeNumber(r,5),u=this.safeNumber(a,0),h=this.safeNumber(a,2),l=this.safeNumber(a,5);for(let p=0;p<this.symbols.length;p++){const m=this.symbols[p],g=this.market(m),y={info:t,symbol:m,percentage:!0,tierBased:!0};g.quote in i?(y.maker=d,y.taker=h):g.contract?(y.maker=c,y.taker=l):(y.maker=o,y.taker=u),s[m]=y}return s}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};let a="privatePostAuthRMovementsHist";e!==void 0&&(n=this.currency(e),r.currency=n.uppercaseId,a="privatePostAuthRMovementsCurrencyHist"),t!==void 0&&(r.start=t),s!==void 0&&(r.limit=s);const o=await this[a](this.extend(r,i));return this.parseTransactions(o,n,t,s)}async withdraw(e,t,s,i=void 0,n={}){this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a=this.safeString(n,"network",e);n=this.omit(n,"network");const o=this.safeValue(r,"networks",{}),d=this.safeValue(o,a),c=this.safeString(d,"id");if(c===void 0)throw new Yd(this.id+" fetchDepositAddress() could not find a network for '"+e+"'. You can specify it by providing the 'network' value inside params");const u=this.safeString(n,"wallet","exchange");n=this.omit(n,"network","wallet");const h={method:c,wallet:u,amount:this.numberToString(t),address:s};i!==void 0&&(h.payment_id=i);const l=await this.privatePostAuthWWithdraw(this.extend(h,n));if(this.safeString(l,0)==="error"){const y=this.id+" "+l,b=this.safeString(l,2,"");throw this.throwExactlyMatchedException(this.exceptions.exact,b,y),this.throwBroadlyMatchedException(this.exceptions.broad,b,y),new _a(y)}const m=this.safeString(l,7);m!=="success"&&this.throwBroadlyMatchedException(this.exceptions.broad,m,m);const g=this.parseTransaction(l,r);return this.extend(g,{address:s})}async fetchPositions(e=void 0,t={}){return await this.loadMarkets(),await this.privatePostAuthRPositions(t)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));t==="v1"?a=t+a:a=this.version+a;let d=this.urls.api[t]+"/"+a;if(t==="public"&&Object.keys(o).length&&(d+="?"+this.urlencode(o)),t==="private"){this.checkRequiredCredentials();const c=this.nonce().toString();r=this.json(o);const u="/api/"+a+c+r,h=this.hmac(this.encode(u),this.encode(this.secret),"sha384");n={"bfx-nonce":c,"bfx-apikey":this.apiKey,"bfx-signature":h,"Content-Type":"application/json"}}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0){if(!Array.isArray(a)){const c=this.safeString2(a,"message","error"),u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u),new _a(this.id+" "+r)}}else if(a==="")throw new _a(this.id+" returned empty response");if(e===500){const c=this.numberToString(a[1]),u=a[2],h=this.id+" "+u;throw this.throwBroadlyMatchedException(this.exceptions.broad,u,h),this.throwExactlyMatchedException(this.exceptions.exact,c,h),this.throwExactlyMatchedException(this.exceptions.exact,u,h),new _a(this.id+" "+u+" (#"+c+")")}return a}parseLedgerEntryType(e){if(e!==void 0)return e.indexOf("fee")>=0||e.indexOf("charged")>=0?"fee":e.indexOf("exchange")>=0||e.indexOf("position")>=0?"trade":e.indexOf("rebate")>=0?"rebate":e.indexOf("deposit")>=0||e.indexOf("withdrawal")>=0?"transaction":e.indexOf("transfer")>=0?"transfer":e.indexOf("payment")>=0?"payout":e}parseLedgerEntry(e,t=void 0){let s;const i=this.safeString(e,0),n=this.safeString(e,1),r=this.safeCurrencyCode(n,t),a=this.safeInteger(e,3),o=this.safeNumber(e,5),d=this.safeNumber(e,6),c=this.safeString(e,8);if(c!==void 0){const u=c.split(" @ "),h=this.safeStringLower(u,0);s=this.parseLedgerEntryType(h)}return{id:i,direction:void 0,account:void 0,referenceId:i,referenceAccount:void 0,type:s,currency:r,amount:o,timestamp:a,datetime:this.iso8601(a),before:void 0,after:d,status:void 0,fee:void 0,info:e}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.loadMarkets();let n;const r={};let a="privatePostAuthRLedgersHist";e!==void 0&&(n=this.currency(e),r.currency=n.uppercaseId,a="privatePostAuthRLedgersCurrencyHist"),t!==void 0&&(r.start=t),s!==void 0&&(r.limit=s);const o=await this[a](this.extend(r,i));return this.parseLedger(o,n,t,s)}};const O5=me,{ExchangeError:I5,ArgumentsRequired:Qd,OrderNotFound:x5}=oe,{TICK_SIZE:_5}=pe;var C5=class extends O5{describe(){return this.deepExtend(super.describe(),{id:"bitflyer",name:"bitFlyer",countries:["JP"],version:"v1",rateLimit:1e3,hostname:"bitflyer.com",has:{CORS:void 0,spot:!0,margin:!1,swap:void 0,future:void 0,option:!1,cancelOrder:!0,createOrder:!0,fetchBalance:!0,fetchClosedOrders:"emulated",fetchDeposits:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOpenOrders:"emulated",fetchOrder:"emulated",fetchOrderBook:!0,fetchOrders:!0,fetchPositionMode:!1,fetchPositions:!0,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawals:!0,transfer:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/28051642-56154182-660e-11e7-9b0d-6042d1e6edd8.jpg",api:{rest:"https://api.{hostname}"},www:"https://bitflyer.com",doc:"https://lightning.bitflyer.com/docs?lang=en"},api:{public:{get:["getmarkets/usa","getmarkets/eu","getmarkets","getboard","getticker","getexecutions","gethealth","getboardstate","getchats"]},private:{get:["getpermissions","getbalance","getbalancehistory","getcollateral","getcollateralhistory","getcollateralaccounts","getaddresses","getcoinins","getcoinouts","getbankaccounts","getdeposits","getwithdrawals","getchildorders","getparentorders","getparentorder","getexecutions","getpositions","gettradingcommission"],post:["sendcoin","withdraw","sendchildorder","cancelchildorder","sendparentorder","cancelparentorder","cancelallchildorders"]}},fees:{trading:{maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},precisionMode:_5})}parseExpiryDate(e){const t=e.slice(0,2),s=e.slice(2,5),i=e.slice(5,9),n={JAN:"01",FEB:"02",MAR:"03",APR:"04",MAY:"05",JUN:"06",JUL:"07",AUG:"08",SEP:"09",OCT:"10",NOV:"11",DEC:"12"},r=this.safeString(n,s);return this.parse8601(i+"-"+r+"-"+t+"T00:00:00Z")}async fetchMarkets(e={}){const t=await this.publicGetGetmarkets(e),s=await this.publicGetGetmarketsUsa(e),i=await this.publicGetGetmarketsEu(e);let n=this.arrayConcat(t,s);n=this.arrayConcat(n,i);const r=[];for(let a=0;a<n.length;a++){const o=n[a],d=this.safeString(o,"product_code"),c=d.split("_"),u=this.safeString(o,"market_type"),h=u==="FX",l=u==="Futures",p=!h&&!l;let m="spot",g,y,b,w;if(p)y=this.safeString(c,0),b=this.safeString(c,1);else if(h)m="swap",y=this.safeString(c,1),b=this.safeString(c,2);else if(l){const M=this.safeString(o,"alias");if(M===void 0){y=d.slice(0,3),b=d.slice(3,6);const x=d.slice(-9);w=this.parseExpiryDate(x)}else{const x=M.split("_"),v=this.safeString(x,0);y=v.slice(0,-3),b=v.slice(-3);const O=d.split(v),A=this.safeString(O,1);w=this.parseExpiryDate(A)}m="future"}const S=this.safeCurrencyCode(y),k=this.safeCurrencyCode(b);let T=S+"/"+k,I=this.fees.trading.taker,_=this.fees.trading.maker;const N=h||l;N&&(_=0,I=0,g="JPY",T=T+":"+g,l&&(T=T+"-"+this.yymmdd(w))),r.push({id:d,symbol:T,base:S,quote:k,settle:g,baseId:y,quoteId:b,settleId:void 0,type:m,spot:p,margin:!1,swap:h,future:l,option:!1,active:!0,contract:N,linear:p?void 0:!0,inverse:p?void 0:!1,taker:I,maker:_,contractSize:void 0,expiry:w,expiryDatetime:this.iso8601(w),strike:void 0,optionType:void 0,precision:{amount:void 0,price:void 0},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:o})}return r}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency_code"),r=this.safeCurrencyCode(n),a=this.account();a.total=this.safeString(i,"amount"),a.free=this.safeString(i,"available"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetGetbalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={product_code:i.id},r=await this.publicGetGetboard(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"bids","asks","price","size")}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.parse8601(this.safeString(e,"timestamp")),n=this.safeString(e,"ltp");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:void 0,low:void 0,bid:this.safeString(e,"best_bid"),bidVolume:void 0,ask:this.safeString(e,"best_ask"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume_by_product"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={product_code:s.id},n=await this.publicGetGetticker(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){let s=this.safeStringLower(e,"side");s!==void 0&&s.length<1&&(s=void 0);let i;if(s!==void 0){const d=s+"_child_order_acceptance_id";d in e&&(i=e[d])}i===void 0&&(i=this.safeString(e,"child_order_acceptance_id"));const n=this.parse8601(this.safeString(e,"exec_date")),r=this.safeString(e,"price"),a=this.safeString(e,"size"),o=this.safeString(e,"id");return t=this.safeMarket(void 0,t),this.safeTrade({id:o,info:e,timestamp:n,datetime:this.iso8601(n),symbol:t.symbol,order:i,type:void 0,side:s,takerOrMaker:void 0,price:r,amount:a,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={product_code:n.id};s!==void 0&&(r.count=s);const a=await this.publicGetGetexecutions(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={product_code:s.id},n=await this.privateGetGettradingcommission(this.extend(i,t)),r=this.safeNumber(n,"commission_rate");return{info:n,symbol:s.symbol,maker:r,taker:r}}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a={product_code:this.marketId(e),child_order_type:t.toUpperCase(),side:s.toUpperCase(),price:n,size:i},o=await this.privatePostSendchildorder(this.extend(a,r)),d=this.safeString(o,"child_order_acceptance_id");return{info:o,id:d}}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Qd(this.id+" cancelOrder() requires a `symbol` argument");await this.loadMarkets();const i={product_code:this.marketId(t),child_order_acceptance_id:e};return await this.privatePostCancelchildorder(this.extend(i,s))}parseOrderStatus(e){const t={ACTIVE:"open",COMPLETED:"closed",CANCELED:"canceled",EXPIRED:"canceled",REJECTED:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parse8601(this.safeString(e,"child_order_date")),i=this.safeString(e,"price"),n=this.safeString(e,"size"),r=this.safeString(e,"executed_size"),a=this.safeString(e,"outstanding_size"),o=this.parseOrderStatus(this.safeString(e,"child_order_state")),d=this.safeStringLower(e,"child_order_type"),c=this.safeStringLower(e,"side"),u=this.safeString(e,"product_code"),h=this.safeSymbol(u,t);let l;const p=this.safeNumber(e,"total_commission");p!==void 0&&(l={cost:p,currency:void 0,rate:void 0});const m=this.safeString(e,"child_order_acceptance_id");return this.safeOrder({id:m,clientOrderId:void 0,info:e,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,status:o,symbol:h,type:d,timeInForce:void 0,postOnly:void 0,side:c,price:i,stopPrice:void 0,cost:void 0,amount:n,filled:r,remaining:a,fee:l,average:void 0,trades:void 0},t)}async fetchOrders(e=void 0,t=void 0,s=100,i={}){if(e===void 0)throw new Qd(this.id+" fetchOrders() requires a `symbol` argument");await this.loadMarkets();const n=this.market(e),r={product_code:n.id,count:s},a=await this.privateGetGetchildorders(this.extend(r,i));let o=this.parseOrders(a,n,t,s);return e!==void 0&&(o=this.filterBy(o,"symbol",e)),o}async fetchOpenOrders(e=void 0,t=void 0,s=100,i={}){const n={child_order_state:"ACTIVE"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=100,i={}){const n={child_order_state:"COMPLETED"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Qd(this.id+" fetchOrder() requires a `symbol` argument");const i=await this.fetchOrders(t),n=this.indexBy(i,"id");if(e in n)return n[e];throw new x5(this.id+" No order found with id "+e)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Qd(this.id+" fetchMyTrades() requires a `symbol` argument");await this.loadMarkets();const n=this.market(e),r={product_code:n.id};s!==void 0&&(r.count=s);const a=await this.privateGetGetexecutions(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchPositions(e=void 0,t={}){if(e===void 0)throw new Qd(this.id+" fetchPositions() requires a `symbols` argument, exactly one symbol in an array");await this.loadMarkets();const s={product_code:this.marketIds(e)};return await this.privateGetpositions(this.extend(s,t))}async withdraw(e,t,s,i=void 0,n={}){if(this.checkAddress(s),await this.loadMarkets(),e!=="JPY"&&e!=="USD"&&e!=="EUR")throw new I5(this.id+" allows withdrawing JPY, USD, EUR only, "+e+" is not supported");const r=this.currency(e),a={currency_code:r.id,amount:t},o=await this.privatePostWithdraw(this.extend(a,n));return this.parseTransaction(o,r)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e)),s!==void 0&&(r.count=s);const a=await this.privateGetGetcoinins(this.extend(r,i));return this.parseTransactions(a,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e)),s!==void 0&&(r.count=s);const a=await this.privateGetGetcoinouts(this.extend(r,i));return this.parseTransactions(a,n,t,s)}parseDepositStatus(e){const t={PENDING:"pending",COMPLETED:"ok"};return this.safeString(t,e,e)}parseWithdrawalStatus(e){const t={PENDING:"pending",COMPLETED:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"id","message_id"),i=this.safeString(e,"address"),n=this.safeString(e,"currency_code"),r=this.safeCurrencyCode(n,t),a=this.parse8601(this.safeString(e,"event_date")),o=this.safeNumber(e,"amount"),d=this.safeString(e,"tx_hash"),c=this.safeString(e,"status");let u,h,l;if("fee"in e){u="withdrawal",h=this.parseWithdrawalStatus(c);const p=this.safeNumber(e,"fee"),m=this.safeNumber(e,"additional_fee");l={currency:r,cost:p+m}}else u="deposit",h=this.parseDepositStatus(c);return{info:e,id:s,txid:d,timestamp:a,datetime:this.iso8601(a),network:void 0,address:i,addressTo:i,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:u,amount:o,currency:r,status:h,updated:void 0,internal:void 0,fee:l}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.version+"/";t==="private"&&(a+="me/"),a+=e,s==="GET"&&Object.keys(i).length&&(a+="?"+this.urlencode(i));const d=this.implodeHostname(this.urls.api.rest)+a;if(t==="private"){this.checkRequiredCredentials();const c=this.nonce().toString();let u=[c,s,a].join("");Object.keys(i).length&&s!=="GET"&&(r=this.json(i),u+=r),n={"ACCESS-KEY":this.apiKey,"ACCESS-TIMESTAMP":c,"ACCESS-SIGN":this.hmac(this.encode(u),this.encode(this.secret)),"Content-Type":"application/json"}}return{url:d,method:s,body:r,headers:n}}};const M5=me,{ExchangeError:P5,ArgumentsRequired:SS,AuthenticationError:kS,OrderNotFound:vS,InsufficientFunds:A5,DDoSProtection:B5,PermissionDenied:N5,BadSymbol:TS,InvalidOrder:OS}=oe,{TICK_SIZE:E5}=pe;var V5=class extends M5{describe(){return this.deepExtend(super.describe(),{id:"bitforex",name:"Bitforex",countries:["CN"],rateLimit:500,version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:void 0,future:!1,option:!1,cancelOrder:!0,createOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:void 0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:void 0,fetchPositionMode:!1,fetchTicker:!0,fetchTickers:void 0,fetchTrades:!0,fetchTransactionFees:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!1,transfer:!1,withdraw:!1},timeframes:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","2h":"2hour","4h":"4hour","12h":"12hour","1d":"1day","1w":"1week","1M":"1month"},urls:{logo:"https://user-images.githubusercontent.com/51840849/87295553-1160ec00-c50e-11ea-8ea0-df79276a9646.jpg",api:{rest:"https://api.bitforex.com"},www:"https://www.bitforex.com",doc:"https://github.com/githubdev2020/API_Doc_en/wiki",fees:"https://help.bitforex.com/en_us/?cat=13",referral:"https://www.bitforex.com/en/invitationRegister?inviterId=1867438"},api:{public:{get:{"api/v1/market/symbols":20,"api/v1/market/ticker":4,"api/v1/market/ticker-all":4,"api/v1/market/depth":4,"api/v1/market/depth-all":4,"api/v1/market/trades":20,"api/v1/market/kline":20}},private:{post:{"api/v1/fund/mainAccount":1,"api/v1/fund/allAccount":30,"api/v1/trade/placeOrder":1,"api/v1/trade/placeMultiOrder":10,"api/v1/trade/cancelOrder":1,"api/v1/trade/cancelMultiOrder":20,"api/v1/trade/cancelAllOrder":20,"api/v1/trade/orderInfo":1,"api/v1/trade/multiOrderInfo":10,"api/v1/trade/orderInfos":20}}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")},funding:{tierBased:!1,percentage:!0,deposit:{},withdraw:{}}},commonCurrencies:{BKC:"Bank Coin",CAPP:"Crypto Application Token",CREDIT:"TerraCredit",CTC:"Culture Ticket Chain",EWT:"EcoWatt Token",IQ:"IQ.Cash",MIR:"MIR COIN",NOIA:"METANOIA",TON:"To The Moon"},precisionMode:E5,exceptions:{1e3:vS,1003:TS,1013:kS,1016:kS,1017:N5,1019:TS,3002:A5,4002:OS,4003:OS,4004:vS,10204:B5}})}async fetchMarkets(e={}){const s=(await this.publicGetApiV1MarketSymbols(e)).data,i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=a.split("-"),d=o[2],c=o[1],u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c);i.push({id:a,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDateTime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"amountPrecision"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"pricePrecision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"minOrderAmount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}parseTrade(e,t=void 0){t=this.safeMarket(void 0,t);const s=this.safeInteger(e,"time"),i=this.safeString(e,"tid"),n=void 0,r=this.safeString(e,"price"),a=this.safeString(e,"amount"),o=this.safeInteger(e,"direction"),d=this.parseSide(o);return this.safeTrade({info:e,id:i,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:void 0,side:d,price:r,amount:a,cost:void 0,order:n,fee:void 0,takerOrMaker:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={symbol:this.marketId(e)};s!==void 0&&(n.size=s);const r=this.market(e),a=await this.publicGetApiV1MarketTrades(this.extend(n,i));return this.parseTrades(a.data,r,t,s)}parseBalance(e){const t=e.data,s={info:e};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.used=this.safeString(n,"frozen"),o.free=this.safeString(n,"active"),o.total=this.safeString(n,"fix"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostApiV1FundAllAccount(e);return this.parseBalance(t)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeInteger(e,"date");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:this.safeString(e,"last"),last:this.safeString(e,"last"),previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"vol"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.markets[e],i={symbol:s.id},n=await this.publicGetApiV1MarketTickerAll(this.extend(i,t)),r=this.safeValue(n,"data");return this.parseTicker(r,s)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"time"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"vol")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,ktype:this.timeframes[t]};i!==void 0&&(a.size=i);const o=await this.publicGetApiV1MarketKline(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseOHLCVs(d,r,t,s,i)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.size=t);const r=await this.publicGetApiV1MarketDepthAll(this.extend(n,s)),a=this.safeValue(r,"data"),o=this.safeInteger(r,"time");return this.parseOrderBook(a,i.symbol,o,"bids","asks","price","amount")}parseOrderStatus(e){const t={0:"open",1:"open",2:"closed",3:"canceled",4:"canceled"};return e in t?t[e]:e}parseSide(e){return e===1?"buy":e===2?"sell":void 0}parseOrder(e,t=void 0){const s=this.safeString(e,"orderId"),i=this.safeNumber(e,"createTime"),n=this.safeNumber(e,"lastTime"),r=t.symbol,a=this.safeInteger(e,"tradeType"),o=this.parseSide(a),d=void 0,c=this.safeString(e,"orderPrice"),u=this.safeString(e,"avgPrice"),h=this.safeString(e,"orderAmount"),l=this.safeString(e,"dealAmount"),p=this.parseOrderStatus(this.safeString(e,"orderState")),g=t[o==="buy"?"base":"quote"],y={cost:this.safeNumber(e,"tradeFee"),currency:g};return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:n,symbol:r,type:d,timeInForce:void 0,postOnly:void 0,side:o,price:c,stopPrice:void 0,cost:void 0,average:u,amount:h,filled:l,remaining:void 0,status:p,fee:y,trades:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(t),n={symbol:this.marketId(t),orderId:e},r=await this.privatePostApiV1TradeOrderInfo(this.extend(n,s));return this.parseOrder(r.data,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new SS(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:this.marketId(e),state:0},a=await this.privatePostApiV1TradeOrderInfos(this.extend(r,i));return this.parseOrders(a.data,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new SS(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:this.marketId(e),state:1},a=await this.privatePostApiV1TradeOrderInfos(this.extend(r,i));return this.parseOrders(a.data,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();let a;s==="buy"?a=1:s==="sell"&&(a=2);const d={symbol:this.market(e).id,price:n,amount:i,tradeType:a},c=await this.privatePostApiV1TradePlaceOrder(this.extend(d,r)),u=c.data;return{info:c,id:this.safeString(u,"orderId")}}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e};t!==void 0&&(i.symbol=this.marketId(t));const n=await this.privatePostApiV1TradeCancelOrder(this.extend(i,s)),r=n.success;return{info:n,success:r}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials();let d=this.urlencode({accessKey:this.apiKey});o.nonce=this.milliseconds(),Object.keys(o).length&&(d+="&"+this.urlencode(this.keysort(o)));const c="/"+e+"?"+d,u=this.hmac(this.encode(c),this.encode(this.secret));r=d+"&signData="+u,n={"Content-Type":"application/x-www-form-urlencoded"}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(typeof r=="string"&&(r[0]==="{"||r[0]==="[")){const c=this.id+" "+r,u=this.safeValue(a,"success");if(u!==void 0&&!u){const h=this.safeString(a,"code");throw this.throwExactlyMatchedException(this.exceptions,h,c),new P5(c)}}}};const q5=me,{ExchangeError:Z,ExchangeNotAvailable:Zd,NotSupported:L5,OnMaintenance:Tm,ArgumentsRequired:ks,BadRequest:Ve,AccountSuspended:Vr,InvalidAddress:IS,PermissionDenied:yt,DDoSProtection:Om,InsufficientFunds:mi,InvalidNonce:Jd,CancelPending:R5,InvalidOrder:le,OrderNotFound:yf,AuthenticationError:pt,RequestTimeout:xS,BadSymbol:sr,RateLimitExceeded:Im}=oe,{TICK_SIZE:F5}=pe,ec=ke;var D5=class extends q5{describe(){return this.deepExtend(super.describe(),{id:"bitget",name:"Bitget",countries:["SG"],version:"v1",rateLimit:50,certified:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!0,future:!1,option:!1,addMargin:!0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchAccounts:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!0,fetchLeverageTiers:!1,fetchMarginMode:void 0,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:void 0,fetchWithdrawal:!1,fetchWithdrawals:!0,reduceMargin:!0,setLeverage:!0,setMarginMode:!0,setPositionMode:!1,transfer:!0,withdraw:!1},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},hostname:"bitget.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/195989417-4253ddb0-afbe-4a1c-9dea-9dbcd121fa5d.jpg",api:{spot:"https://api.{hostname}",mix:"https://api.{hostname}"},www:"https://www.bitget.com",doc:["https://bitgetlimited.github.io/apidoc/en/mix","https://bitgetlimited.github.io/apidoc/en/spot","https://bitgetlimited.github.io/apidoc/en/broker"],fees:"https://www.bitget.cc/zh-CN/rate?tab=1",referral:"https://www.bitget.com/expressly?languageType=0&channelCode=ccxt&vipCode=tg9j"},api:{public:{spot:{get:{"public/time":1,"public/currencies":1,"public/products":1,"public/product":1,"market/ticker":1,"market/tickers":1,"market/fills":1,"market/candles":1,"market/depth":1}},mix:{get:{"market/contracts":1,"market/depth":1,"market/ticker":1,"market/tickers":1,"market/fills":1,"market/candles":1,"market/index":1,"market/funding-time":1,"market/history-fundRate":1,"market/current-fundRate":1,"market/open-interest":1,"market/mark-price":1,"market/symbol-leverage":1}}},private:{spot:{get:{"account/getInfo":20,"account/assets":2,"account/transferRecords":4,"wallet/deposit-address":4,"wallet/withdrawal-inner":4,"wallet/withdrawal-list":1,"wallet/deposit-list":1},post:{"account/bills":2,"trade/orders":2,"trade/batch-orders":4,"trade/cancel-order":2,"trade/cancel-batch-orders":4,"trade/orderInfo":1,"trade/open-orders":1,"trade/history":1,"trade/fills":1,"wallet/transfer":4,"wallet/withdrawal":4,"wallet/subTransfer":10}},mix:{get:{"account/account":2,"account/accounts":2,"account/open-count":1,"order/current":2,"order/history":2,"order/detail":2,"order/fills":2,"order/historyProductType":8,"order/allFills":2,"plan/currentPlan":2,"plan/historyPlan":2,"position/singlePosition":2,"position/allPosition":2,"trace/currentTrack":2,"trace/followerOrder":2,"trace/historyTrack":2,"trace/summary":2,"trace/profitSettleTokenIdGroup":2,"trace/profitDateGroupList":2,"trade/profitDateList":2,"trace/waitProfitDateList":2,"trace/traderSymbols":2,"order/marginCoinCurrent":2},post:{"account/setLeverage":8,"account/setMargin":8,"account/setMarginMode":8,"order/placeOrder":2,"order/batch-orders":2,"order/cancel-order":2,"order/cancel-all-orders":2,"order/cancel-batch-orders":2,"plan/placePlan":2,"plan/modifyPlan":2,"plan/modifyPlanPreset":2,"plan/placeTPSL":2,"plan/placePositionsTPSL":2,"plan/modifyTPSLPlan":2,"plan/cancelPlan":2,"trace/closeTrackOrder":2,"trace/setUpCopySymbols":2}}}},fees:{spot:{taker:this.parseNumber("0.002"),maker:this.parseNumber("0.002")},swap:{taker:this.parseNumber("0.0006"),maker:this.parseNumber("0.0004")}},requiredCredentials:{apiKey:!0,secret:!0,password:!0},exceptions:{exact:{1:Z,"failure to get a peer from the ring-balancer":Zd,4010:yt,4001:Z,4002:Z,30001:pt,30002:pt,30003:pt,30004:pt,30005:Jd,30006:pt,30007:Ve,30008:xS,30009:Z,30010:pt,30011:yt,30012:pt,30013:pt,30014:Om,30015:pt,30016:Z,30017:Z,30018:Z,30019:Zd,30020:Ve,30021:Ve,30022:yt,30023:Ve,30024:sr,30025:Ve,30026:Om,30027:pt,30028:yt,30029:Vr,30030:Z,30031:Ve,30032:sr,30033:Ve,30034:Z,30035:Z,30036:Z,30037:Zd,30038:Tm,32001:Vr,32002:yt,32003:R5,32004:Z,32005:le,32006:le,32007:le,32008:le,32009:le,32010:Z,32011:Z,32012:Z,32013:Z,32014:Z,32015:Z,32016:Z,32017:Z,32018:Z,32019:Z,32020:Z,32021:Z,32022:Z,32023:Z,32024:Z,32025:Z,32026:Z,32027:Z,32028:Vr,32029:Z,32030:le,32031:ks,32038:pt,32040:Z,32044:Z,32045:Z,32046:Z,32047:Z,32048:le,32049:Z,32050:le,32051:le,32052:Z,32053:Z,32057:Z,32054:Z,32055:le,32056:Z,32058:Z,32059:le,32060:le,32061:le,32062:le,32063:le,32064:Z,32065:Z,32066:Z,32067:Z,32068:Z,32069:Z,32070:Z,32071:Z,32072:Z,32073:Z,32074:Z,32075:Z,32076:Z,32077:Z,32078:Z,32079:Z,32080:Z,32083:Z,33001:yt,33002:Vr,33003:mi,33004:Z,33005:Z,33006:Z,33007:Z,33008:mi,33009:Z,33010:Z,33011:Z,33012:Z,33013:le,33014:yf,33015:le,33016:Z,33017:mi,33018:Z,33020:Z,33021:Ve,33022:le,33023:Z,33024:le,33025:le,33026:Z,33027:le,33028:le,33029:le,33034:Z,33035:Z,33036:Z,33037:Z,33038:Z,33039:Z,33040:Z,33041:Z,33042:Z,33043:Z,33044:Z,33045:Z,33046:Z,33047:Z,33048:Z,33049:Z,33050:Z,33051:Z,33059:Ve,33060:Ve,33061:Z,33062:Z,33063:Z,33064:Z,33065:Z,21009:Z,34001:yt,34002:IS,34003:Z,34004:Z,34005:Z,34006:Z,34007:Z,34008:mi,34009:Z,34010:Z,34011:Z,34012:Z,34013:Z,34014:Z,34015:Z,34016:yt,34017:Vr,34018:pt,34019:yt,34020:yt,34021:IS,34022:Z,34023:yt,34026:Z,34036:Z,34037:Z,34038:Z,34039:Z,35001:Z,35002:Z,35003:Z,35004:Z,35005:pt,35008:le,35010:le,35012:le,35014:le,35015:le,35017:Z,35019:le,35020:le,35021:le,35022:Z,35024:Z,35025:mi,35026:Z,35029:yf,35030:le,35031:le,35032:Z,35037:Z,35039:Z,35040:le,35044:Z,35046:mi,35047:mi,35048:Z,35049:le,35050:le,35052:mi,35053:Z,35055:mi,35057:Z,35058:Z,35059:Ve,35060:Ve,35061:Ve,35062:le,35063:le,35064:le,35066:le,35067:le,35068:le,35069:le,35070:le,35071:le,35072:le,35073:le,35074:le,35075:le,35076:le,35077:le,35078:le,35079:le,35080:le,35081:le,35082:le,35083:le,35084:le,35085:le,35086:le,35087:le,35088:le,35089:le,35090:Z,35091:Z,35092:Z,35093:Z,35094:Z,35095:Ve,35096:Z,35097:Z,35098:Z,35099:Z,36001:Ve,36002:Ve,36005:Z,36101:pt,36102:yt,36103:Vr,36104:yt,36105:yt,36106:Vr,36107:yt,36108:mi,36109:yt,36201:yt,36202:yt,36203:le,36204:Z,36205:Ve,36206:Ve,36207:le,36208:le,36209:le,36210:le,36211:le,36212:le,36213:le,36214:Z,36216:yf,36217:le,36218:le,36219:le,36220:le,36221:le,36222:le,36223:le,36224:le,36225:le,36226:le,36227:le,36228:le,36229:le,36230:le,400:Ve,401:pt,403:yt,404:Ve,405:Ve,415:Ve,429:Om,500:Zd,1001:Im,1002:Z,1003:Z,40001:pt,40002:pt,40003:pt,40004:Jd,40005:Jd,40006:pt,40007:Ve,40008:Jd,40009:pt,40010:pt,40011:pt,40012:pt,40013:Z,40014:yt,40015:Z,40016:yt,40017:Z,40018:yt,40102:Ve,40103:Ve,40104:Z,40105:Z,40106:Z,40107:Z,40108:le,40109:yf,40200:Tm,40201:le,40202:Z,40203:Ve,40204:Ve,40205:Ve,40206:Ve,40207:Ve,40208:Ve,40209:Ve,40300:Z,40301:yt,40302:Ve,40303:Ve,40304:Ve,40305:Ve,40306:Z,40308:Tm,40309:sr,40400:Z,40401:Z,40402:Ve,40403:Ve,40404:Ve,40405:Ve,40406:Ve,40407:Z,40408:Z,40409:Z,40500:le,40501:Z,40502:Z,40503:Z,40504:Z,40505:Z,40506:pt,40507:pt,40508:Z,40509:Z,40600:Z,40601:Z,40602:Z,40603:Z,40604:Zd,40605:Z,40606:Z,40607:Z,40608:Z,40609:Z,40700:Ve,40701:Z,40702:Z,40703:Z,40704:Z,40705:Ve,40706:le,40707:Ve,40708:Ve,40709:Z,40710:Z,40711:mi,40712:mi,40713:Z,40714:Z,"invalid sign":pt,"invalid currency":sr,"invalid symbol":sr,"invalid period":Ve,"invalid user":Z,"invalid amount":le,"invalid type":le,"invalid orderId":le,"invalid record":Z,"invalid accountId":Ve,"invalid address":Ve,"accesskey not null":pt,"illegal accesskey":pt,"sign not null":pt,"req_time is too much difference from server time":Jd,"permissions not right":yt,"illegal sign invalid":pt,"user locked":Vr,"Request Frequency Is Too High":Im,"more than a daily rate of cash":Ve,"more than the maximum daily withdrawal amount":Ve,"need to bind email or mobile":Z,"user forbid":yt,"User Prohibited Cash Withdrawal":yt,"Cash Withdrawal Is Less Than The Minimum Value":Ve,"Cash Withdrawal Is More Than The Maximum Value":Ve,"the account with in 24 hours ban coin":yt,"order cancel fail":Ve,"base symbol error":sr,"base date error":Z,"api signature not valid":pt,"gateway internal error":Z,"audit failed":Z,"order queryorder invalid":Ve,"market no need price":le,"limit need price":le,"userid not equal to account_id":Z,"your balance is low":mi,"address invalid cointype":Z,"system exception":Z,50003:Z,50004:sr,50006:yt,50007:yt,50008:xS,50009:Im,50010:Z,50014:le,50015:le,50016:le,50017:le,50018:le,50019:le,50020:mi,50021:le,50026:le,"invalid order query time":Z,"invalid start time":Ve,"invalid end time":Ve,20003:Z,"01001":Z,43111:yt},broad:{"invalid size, valid range":Z}},precisionMode:F5,commonCurrencies:{JADE:"Jade Protocol"},options:{timeframes:{spot:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"1h","4h":"4h","6h":"6h","12h":"12h","1d":"1day","3d":"3day","1w":"1week","1M":"1M"},swap:{"1m":"60","5m":"300","15m":"900","30m":"1800","1h":"3600","4h":"14400","12h":"43200","1d":"86400","1w":"604800"}},fetchMarkets:["spot","swap"],defaultType:"spot",defaultSubType:"linear",createMarketBuyOrderRequiresPrice:!0,broker:{spot:"CCXT#",swap:"CCXT#"},withdraw:{fillResponseFromRequest:!0}}})}async fetchTime(e={}){const t=await this.publicSpotGetPublicTime(e);return this.safeInteger(t,"data")}async fetchMarkets(e={}){const t=this.safeValue(this.options,"fetchMarkets",["spot","swap"]);let s=[];for(let i=0;i<t.length;i++){const n=t[i];if(n==="swap"){const r=["umcbl","dmcbl","cmcbl","sumcbl","sdmcbl","scmcbl"];for(let a=0;a<r.length;a++){const o=await this.fetchMarketsByType(n,this.extend(e,{productType:r[a]}));s=this.arrayConcat(s,o)}}else{const r=await this.fetchMarketsByType(t[i],e);s=this.arrayConcat(s,r)}}return s}parseMarkets(e){const t=[];for(let s=0;s<e.length;s++)t.push(this.parseMarket(e[s]));return t}parseMarket(e){const t=this.safeString(e,"symbol"),s=this.safeString(e,"quoteCoin"),i=this.safeString(e,"baseCoin"),n=this.safeCurrencyCode(s),r=this.safeCurrencyCode(i),a=this.safeValue(e,"supportMarginCoins",[]),o=this.safeString(a,0),d=this.safeCurrencyCode(o);let c=r+"/"+n;const u=t.split("_"),h=this.safeString(u,1);let l,p=!1,m=!1,g=!1,y=!1,b,w,S,k,T,I;if(h==="SPBL")l="spot",m=!0,b=this.parseNumber(this.parsePrecision(this.safeString(e,"priceScale"))),w=this.parseNumber(this.parsePrecision(this.safeString(e,"quantityScale")));else{const M=this.safeString(u,2);if(M!==void 0){const j="20"+M.slice(0,2),X=M.slice(2,4),Q=M.slice(4,6);I=j+"-"+X+"-"+Q+"T00:00:00Z",T=this.parse8601(I),l="future",g=!0,c=c+":"+d+"-"+M}else l="swap",p=!0,c=c+":"+d;y=!0;const x=h==="SUMCBL",v=h==="SDMCBL",O=h==="SCMCBL";S=h==="UMCBL"||h==="CMCBL"||x||O,k=!S,(x||v||O)&&(c=t);const A=this.safeInteger(e,"pricePlace"),V=this.safeInteger(e,"volumePlace"),q=this.safeString(e,"priceEndStep"),R=this.safeString(e,"minTradeNum"),H=new ec(q);H.decimals=Math.max(H.decimals,A),H.reduce();const F=H.toString();b=this.parseNumber(F);const P=new ec(R);P.decimals=Math.max(P.decimals,V),P.reduce();const E=P.toString();w=this.parseNumber(E)}const _=this.safeString(e,"status");let N;return _!==void 0&&(N=_==="online"),{id:t,symbol:c,base:r,quote:n,settle:d,baseId:i,quoteId:s,settleId:o,type:l,spot:m,margin:!1,swap:p,future:g,option:!1,active:N,contract:y,linear:S,inverse:k,taker:this.safeNumber(e,"takerFeeRate"),maker:this.safeNumber(e,"makerFeeRate"),contractSize:this.safeNumber(e,"sizeMultiplier"),expiry:T,expiryDatetime:I,strike:void 0,optionType:void 0,precision:{amount:w,price:b},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(e,"minTradeNum"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:e}}async fetchMarketsByType(e,t={}){const s=this.getSupportedMapping(e,{spot:"publicSpotGetPublicProducts",swap:"publicMixGetMarketContracts"}),i=await this[s](t),n=this.safeValue(i,"data",[]);return this.parseMarkets(n)}async fetchCurrencies(e={}){const t=await this.publicSpotGetPublicCurrencies(e),s={},i=this.safeValue(t,"data",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"coinId"),o=this.safeCurrencyCode(this.safeString(r,"coinName")),d=this.safeValue(r,"chains",[]),c={};for(let u=0;u<d.length;u++){const h=d[u],l=this.safeString(h,"chain"),p=this.safeCurrencyCode(l),m=this.safeString(h,"withdrawable"),g=this.safeString(h,"rechargeable");c[p]={info:h,id:l,network:p,limits:{withdraw:{min:this.safeNumber(h,"minWithdrawAmount"),max:void 0},deposit:{min:this.safeNumber(h,"minDepositAmount"),max:void 0}},active:void 0,withdraw:m==="true",deposit:g==="true",fee:this.safeNumber(h,"withdrawFee"),precision:void 0}}s[o]={info:r,id:a,code:o,networks:c,type:void 0,name:void 0,active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,precision:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}}}return s}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),e===void 0)throw new ks(this.id+" fetchDeposits() requires a `code` argument");const n=this.currency(e);t===void 0&&(t=this.milliseconds()-31556952e3);const r={coin:n.code,startTime:t,endTime:this.milliseconds()};s!==void 0&&(r.pageSize=s);const a=await this.privateSpotGetWalletDepositList(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s)}async withdraw(e,t,s,i=void 0,n={}){this.checkAddress(s);const r=this.safeString(n,"chain");if(r===void 0)throw new ks(this.id+" withdraw() requires a chain parameter");await this.loadMarkets();const o={coin:this.currency(e).code,address:s,chain:r,amount:t};i!==void 0&&(o.tag=i);const d=await this.privateSpotPostWalletWithdrawal(this.extend(o,n)),c={id:this.safeString(d,"data"),info:d,txid:void 0,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:"withdrawal",currency:void 0,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0},u=this.safeValue(this.options,"withdraw",{});return this.safeValue(u,"fillResponseFromRequest",!0)&&(c.currency=e,c.timestamp=this.milliseconds(),c.datetime=this.iso8601(this.milliseconds()),c.amount=t,c.tag=i,c.address=s,c.addressTo=s,c.network=r),c}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),e===void 0)throw new ks(this.id+" fetchWithdrawals() requires a `code` argument");const n=this.currency(e);t===void 0&&(t=this.milliseconds()-31556952e3);const r={coin:n.code,startTime:t,endTime:this.milliseconds()};s!==void 0&&(r.pageSize=s);const a=await this.privateSpotGetWalletWithdrawalList(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s)}parseTransaction(e,t=void 0){const s=this.safeInteger(e,"cTime"),i=this.safeString(e,"chain"),n=this.safeString(e,"coin"),r=this.safeString(e,"status");return{id:this.safeString(e,"id"),info:e,txid:this.safeString(e,"txId"),timestamp:s,datetime:this.iso8601(s),network:i,addressFrom:void 0,address:this.safeString(e,"toAddress"),addressTo:this.safeString(e,"toAddress"),amount:this.safeNumber(e,"amount"),type:this.safeString(e,"type"),currency:this.safeCurrencyCode(n),status:this.parseTransactionStatus(r),updated:this.safeNumber(e,"uTime"),tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0}}parseTransactionStatus(e){const t={success:"ok",Pending:"pending",pending_review:"pending",pending_review_fail:"failed",reject:"failed"};return this.safeString(t,e,e)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={coin:s.code},n=await this.privateSpotGetWalletDepositAddress(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseDepositAddress(r,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"coin"),i=this.safeString(e,"chain");return{currency:this.safeCurrencyCode(s,t),address:this.safeString(e,"address"),tag:this.safeString(e,"tag"),network:i,info:e}}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),[n,r]=this.handleMarketTypeAndParams("fetchOrderBook",i,s),a=this.getSupportedMapping(n,{spot:"publicSpotGetMarketDepth",swap:"publicMixGetMarketDepth"}),o={symbol:i.id};t!==void 0&&(o.limit=t);const d=await this[a](this.extend(o,r)),c=this.safeValue(d,"data"),u=this.safeInteger(c,"timestamp");return this.parseOrderBook(c,e,u)}parseTicker(e,t=void 0){let s=this.safeString(e,"symbol");s in this.markets_by_id||(s+="_SPBL");const i=this.safeSymbol(s,t),n=this.safeString(e,"high24h"),r=this.safeString(e,"low24h"),a=this.safeString2(e,"close","last"),o=this.safeString2(e,"quoteVol","quoteVolume"),d=this.safeString2(e,"baseVol","baseVolume"),c=this.safeInteger2(e,"ts","timestamp"),u=this.iso8601(c),h=this.safeString2(e,"buyOne","bestBid"),l=this.safeString2(e,"sellOne","bestAsk"),p=ec.stringMul(this.safeString(e,"priceChangePercent"),"100");return this.safeTicker({symbol:i,timestamp:c,datetime:u,high:n,low:r,bid:h,bidVolume:void 0,ask:l,askVolume:void 0,vwap:void 0,open:void 0,close:a,last:void 0,previousClose:void 0,change:void 0,percentage:p,average:void 0,baseVolume:d,quoteVolume:o,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},[n,r]=this.handleMarketTypeAndParams("fetchTicker",s,t),a=this.getSupportedMapping(n,{spot:"publicSpotGetMarketTicker",swap:"publicMixGetMarketTicker"}),o=await this[a](this.extend(i,r)),d=this.safeValue(o,"data");return this.parseTicker(d,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();let s,i;if(e!==void 0){const d=this.safeValue(e,0);i=this.market(d)}[s,t]=this.handleMarketTypeAndParams("fetchTickers",i,t);const n=this.getSupportedMapping(s,{spot:"publicSpotGetMarketTickers",swap:"publicMixGetMarketTickers"}),r={};if(n==="publicMixGetMarketTickers"){const d=this.safeString(this.options,"defaultSubType");r.productType=d==="linear"?"UMCBL":"DMCBL"}const a=await this[n](this.extend(r,t)),o=this.safeValue(a,"data");return this.parseTickers(o,e)}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeString2(e,"tradeId","fillId"),r=this.safeString(e,"orderId"),a=this.safeString(e,"side"),o=this.safeString2(e,"fillPrice","price");let d=this.safeString2(e,"fillQuantity","size");d=this.safeString(e,"sizeQty",d);let c=this.safeInteger2(e,"fillTime","timestamp");c=this.safeInteger(e,"cTime",c);let u;const h=this.safeString(e,"fees"),l=this.safeString(e,"orderType");if(h!==void 0){const m=this.safeCurrencyCode(this.safeString(e,"feeCcy"));u={code:m,currency:m,cost:h}}const p=this.iso8601(c);return this.safeTrade({info:e,id:n,order:r,symbol:i,side:a,type:l,takerOrMaker:void 0,price:o,amount:d,cost:void 0,fee:u,timestamp:c,datetime:p},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};t!==void 0&&(r.limit=t);const[a,o]=this.handleMarketTypeAndParams("fetchTrades",n,i),d=this.getSupportedMapping(a,{spot:"publicSpotGetMarketFills",swap:"publicMixGetMarketFills"}),c=await this[d](this.extend(r,o)),u=this.safeValue(c,"data",[]);return this.parseTrades(u,n,s,t)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicSpotGetPublicProduct(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTradingFee(r,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicSpotGetPublicProducts(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.parseTradingFee(r),o=a.symbol;i[o]=a}return i}parseTradingFee(e,t=void 0){const s=this.safeString(e,"symbol");return{info:e,symbol:this.safeSymbol(s,t),maker:this.safeNumber(e,"makerFeeRate"),taker:this.safeNumber(e,"takerFeeRate")}}parseOHLCV(e,t=void 0,s="1m"){return[this.safeInteger2(e,0,"ts"),this.safeNumber2(e,1,"open"),this.safeNumber2(e,2,"high"),this.safeNumber2(e,3,"low"),this.safeNumber2(e,4,"close"),this.safeNumber2(e,5,"baseVol")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id},[o,d]=this.handleMarketTypeAndParams("fetchOHLCV",r,n),c=this.getSupportedMapping(o,{spot:"publicSpotGetMarketCandles",swap:"publicMixGetMarketCandles"}),u=this.safeInteger2(n,"until","till");if(n=this.omit(n,["until","till"]),i===void 0&&(i=100),r.type==="spot"){if(a.period=this.options.timeframes.spot[t],a.limit=i,s!==void 0&&(a.after=s,u===void 0)){const p=this.options.timeframes.swap[t]*1e3;a.before=this.sum(s,p*i)}u!==void 0&&(a.before=u)}else if(r.type==="swap"){a.granularity=this.options.timeframes.swap[t];const p=this.parseTimeframe(t),m=this.milliseconds();s===void 0?(a.startTime=m-(i-1)*(p*1e3),a.endTime=m):(a.startTime=this.sum(s,p*1e3),u!==void 0?a.endTime=u:a.endTime=this.sum(s,i*p*1e3))}const h=await this[c](this.extend(a,d)),l=this.safeValue(h,"data",h);return this.parseOHLCVs(l,r,t,s,i)}async fetchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),i=this.getSupportedMapping(t,{spot:"privateSpotGetAccountAssets",swap:"privateMixGetAccountAccounts"}),n={};if(t==="swap"){const o=this.safeString(this.options,"defaultSubType");n.productType=o==="linear"?"UMCBL":"DMCBL"}const r=await this[i](this.extend(n,s)),a=this.safeValue(r,"data");return this.parseBalance(a)}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString2(i,"coinId","marginCoin"),r=this.safeCurrencyCode(n),a=this.account();a.used=this.safeString2(i,"lock","locked"),a.free=this.safeString(i,"available"),t[r]=a}return this.safeBalance(t)}parseOrderStatus(e){const t={new:"open",full_fill:"closed",filled:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s);const i=t.symbol,n=this.safeString(e,"orderId"),r=this.safeString2(e,"price","executePrice"),a=this.safeString2(e,"quantity","size"),o=this.safeString2(e,"fillQuantity","filledQty"),d=this.safeString2(e,"fillTotalAmount","filledAmount"),c=this.safeString(e,"fillPrice"),u=this.safeString(e,"orderType"),h=this.safeInteger(e,"cTime");let l=this.safeString2(e,"side","posSide");l==="open_long"||l==="close_short"?l="buy":(l==="close_long"||l==="open_short")&&(l="sell");const p=this.safeString2(e,"clientOrderId","clientOid"),m=void 0,g=this.safeString2(e,"status","state"),y=this.parseOrderStatus(g),b=this.safeInteger(e,"uTime");return this.safeOrder({info:e,id:n,clientOrderId:p,timestamp:h,datetime:this.iso8601(h),lastTradeTimestamp:b,symbol:i,type:u,timeInForce:void 0,postOnly:void 0,side:l,price:r,stopPrice:this.safeNumber(e,"triggerPrice"),average:c,cost:d,amount:a,filled:o,remaining:void 0,status:y,fee:m,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),[o,d]=this.handleMarketTypeAndParams("createOrder",a,r),c={symbol:a.id,orderType:t},u=t==="market",h=this.safeValue2(r,"stopPrice","triggerPrice"),l=h!==void 0,p=this.safeValue(r,"stopLossPrice"),m=p!==void 0,g=this.safeValue(r,"takeProfitPrice"),y=g!==void 0,b=m||y;if(this.sum(l,m,y)>1)throw new Z(this.id+" createOrder() params can only contain one of triggerPrice, stopLossPrice, takeProfitPrice");t==="limit"&&h===void 0&&(c.price=this.priceToPrecision(e,n));let w=this.safeString2(r,"client_oid","clientOrderId");if(w===void 0){const M=this.safeValue(this.options,"broker");if(M!==void 0){const x=this.safeString(M,a.type);x!==void 0&&(w=x+this.uuid22())}}let S=this.getSupportedMapping(o,{spot:"privateSpotPostTradeOrders",swap:"privateMixPostOrderPlaceOrder"});const k=this.safeString2(r,"force","timeInForceValue"),T=this.isPostOnly(u,k==="post_only",r);if(o==="spot"){if(b)throw new le(this.id+" createOrder() does not support stop orders on spot markets, only swap markets");if(this.safeValue(this.options,"createMarketBuyOrderRequiresPrice",!0)&&u&&s==="buy"){if(n===void 0)throw new le(this.id+" createOrder() requires price argument for market buy orders on spot markets to calculate the total amount to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option to false and pass in the cost to spend into the amount parameter");{const x=this.numberToString(i),v=this.numberToString(n),O=this.parseNumber(ec.stringMul(x,v));c.quantity=this.priceToPrecision(e,O)}}else c.quantity=this.amountToPrecision(e,i);c.clientOrderId=w,c.side=s,T?c.force="post_only":c.force="gtc"}else{c.clientOid=w,c.size=this.amountToPrecision(e,i),T&&(c.timeInForceValue="post_only");const M=this.safeValue(r,"reduceOnly",!1);if(h!==void 0){const x=this.safeString(r,"triggerType","market_price");c.triggerType=x,c.triggerPrice=this.priceToPrecision(e,h),c.executePrice=this.priceToPrecision(e,n),S="privateMixPostPlanPlacePlan"}if(b){if(!u)throw new Z(this.id+" createOrder() bitget stopLoss or takeProfit orders must be market orders");m?(c.triggerPrice=this.priceToPrecision(e,p),c.planType="loss_plan"):y&&(c.triggerPrice=this.priceToPrecision(e,g),c.planType="profit_plan"),c.holdSide=s==="buy"?"long":"short",S="privateMixPostPlanPlaceTPSL"}else M?c.side=s==="buy"?"close_short":"close_long":c.side=s==="buy"?"open_long":"open_short";c.marginCoin=a.settleId}const I=this.omit(d,["stopPrice","triggerType","stopLossPrice","takeProfitPrice","postOnly"]),_=await this[S](this.extend(c,I)),N=this.safeValue(_,"data");return this.parseOrder(N,a)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new ks(this.id+" cancelOrder() requires a symbol argument for spot orders");await this.loadMarkets();const i=this.market(t),[n,r]=this.handleMarketTypeAndParams("cancelOrder",i,s);let a=this.getSupportedMapping(n,{spot:"privateSpotPostTradeCancelOrder",swap:"privateMixPostOrderCancelOrder"});const o={symbol:i.id,orderId:e};if(this.safeValue(s,"stop")){const u=this.safeString(s,"planType");if(u===void 0)throw new ks(this.id+" cancelOrder() requires a planType parameter for stop orders, either normal_plan, profit_plan or loss_plan");o.planType=u,a="privateMixPostPlanCancelPlan",s=this.omit(s,["stop","planType"])}n==="swap"&&(o.marginCoin=i.settleId);const c=await this[a](this.extend(o,r));return this.parseOrder(c,i)}async cancelOrders(e,t=void 0,s={}){if(t===void 0)throw new ks(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=this.safeString(s,"type",i.type);if(n===void 0)throw new ks(this.id+" cancelOrders() requires a type parameter (one of 'spot', 'swap').");s=this.omit(s,"type");const r={};let a;if(n==="spot"){a="apiPostOrderOrdersBatchcancel",r.method="batchcancel";const c=this.json(e).split('"');r.order_ids=c.join("")}else n==="swap"&&(a="privateMixPostOrderCancelBatchOrders",r.symbol=i.id,r.marginCoin=i.quote,r.orderIds=e);return await this[a](this.extend(r,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s=this.safeString2(t,"code","marginCoin");if(s===void 0)throw new ks(this.id+" cancelAllOrders () requires a code argument in the params");let i,n=this.safeString(this.options,"defaultSubType");e!==void 0&&(i=this.market(e),n=i.linear?"linear":"inverse");const r=n==="linear"?"UMCBL":"DMCBL",[a,o]=this.handleMarketTypeAndParams("cancelAllOrders",i,t);if(a==="spot")throw new L5(this.id+" cancelAllOrders () does not support spot markets");const d=this.currency(s),c={marginCoin:this.safeCurrencyCode(s,d),productType:r};return t=this.omit(o,["code","marginCoin"]),await this.privateMixPostOrderCancelAllOrders(this.extend(c,t))}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new ks(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),[n,r]=this.handleMarketTypeAndParams("fetchOrder",i,s),a=this.getSupportedMapping(n,{spot:"privateSpotPostTradeOrderInfo",swap:"privateMixGetOrderDetail"}),o={symbol:i.id,orderId:e},d=await this[a](this.extend(o,r)),c=this.safeValue(d,"data"),u=this.safeValue(c,0,c);return this.parseOrder(u,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new ks(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),[r,a]=this.handleMarketTypeAndParams("fetchOpenOrders",n,i),o={symbol:n.id};let d=this.getSupportedMapping(r,{spot:"privateSpotPostTradeOpenOrders",swap:"privateMixGetOrderCurrent"});this.safeValue(i,"stop")&&(d="privateMixGetPlanCurrentPlan",i=this.omit(i,"stop"));const u=await this[d](this.extend(o,a)),h=this.safeValue(u,"data",[]);return this.parseOrders(h,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new ks(this.id+" fetchClosedOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),[r,a]=this.handleMarketTypeAndParams("fetchClosedOrders",n,i),o={symbol:n.id},d=this.getSupportedMapping(r,{spot:"privateSpotPostTradeHistory",swap:"privateMixGetOrderHistory"});r==="swap"&&(s===void 0&&(s=100),o.pageSize=s,t===void 0&&(t=0),o.startTime=t,o.endTime=this.milliseconds());const c=await this[d](this.extend(o,a)),u=this.safeValue(c,"data"),h=this.safeValue(u,"orderList",u);return this.parseOrders(h,n,t,s)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.coinId=n.id);const a=await this.privateSpotPostAccountBills(this.extend(r,i)),o=this.safeValue(a,"data");return this.parseLedger(o,n,t,s)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"billId"),i=this.safeString(e,"coinId"),n=this.safeCurrencyCode(i),r=this.parseNumber(ec.stringAbs(this.safeString(e,"quantity"))),a=this.safeInteger(e,"cTime"),o=this.safeString(e,"bizType");let d;o!==void 0&&o.indexOf("-")>=0&&(d=o.split("-")[1]);const c=this.safeString(e,"groupType"),u=this.safeNumber(e,"fees"),h=this.safeNumber(e,"balance");return{info:e,id:s,timestamp:a,datetime:this.iso8601(a),direction:d,account:void 0,referenceId:void 0,referenceAccount:void 0,type:c,currency:n,amount:r,before:void 0,after:h,status:void 0,fee:u}}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new ks(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e);if(n.swap)throw new sr(this.id+" fetchMyTrades() only supports spot markets");const r={symbol:n.id};s!==void 0&&(r.limit=s);const a=await this.privateSpotPostTradeFills(this.extend(r,i)),o=this.safeValue(a,"data");return this.parseTrades(o,n,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){if(t===void 0)throw new ks(this.id+" fetchOrderTrades() requires a symbol argument");await this.loadMarkets();const r=this.market(t),[a,o]=this.handleMarketTypeAndParams("fetchOrderTrades",r,n),d=this.getSupportedMapping(a,{spot:"privateSpotPostTradeFills",swap:"privateMixGetOrderFills"}),c={symbol:r.id,orderId:e},u=await this[d](this.extend(c,o)),h=this.safeValue(u,"data");return await this.parseTrades(h,r,s,i)}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id,marginCoin:s.settleId},n=await this.privateMixGetPositionSinglePosition(this.extend(i,t)),r=this.safeValue(n,"data",[]);return this.parsePosition(r[0],s)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const i={productType:this.safeString(this.options,"defaultSubType")==="linear"?"UMCBL":"DMCBL"},n=await this.privateMixGetPositionAllPosition(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=[];for(let o=0;o<r.length;o++)a.push(this.parsePosition(r[o]));return e=this.marketSymbols(e),this.filterByArray(a,"symbol",e,!1)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeInteger(e,"cTime");let n=this.safeString(e,"marginMode");n==="fixed"?n="isolated":n==="crossed"&&(n="cross");let r=this.safeString(e,"holdMode");r==="double_hold"?r=!0:r==="single_hold"&&(r=!1);let a=this.safeInteger(e,"openDelegateCount"),o=this.safeNumber(e,"liquidationPrice");return a===0&&(a=void 0),o===0&&(o=void 0),{info:e,id:void 0,symbol:t.symbol,notional:void 0,marginMode:n,liquidationPrice:o,entryPrice:this.safeNumber(e,"averageOpenPrice"),unrealizedPnl:this.safeNumber(e,"unrealizedPL"),percentage:void 0,contracts:a,contractSize:this.safeNumber(e,"total"),markPrice:void 0,side:this.safeString(e,"holdSide"),hedged:r,timestamp:i,datetime:this.iso8601(i),maintenanceMargin:void 0,maintenanceMarginPercentage:this.safeNumber(e,"keepMarginRate"),collateral:this.safeNumber(e,"margin"),initialMargin:void 0,initialMarginPercentage:void 0,leverage:this.safeNumber(e,"leverage"),marginRatio:void 0}}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new ks(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.pageSize=s);const a=await this.publicMixGetMarketHistoryFundRate(this.extend(r,i)),o=this.safeValue(a,"data",[]),d=[];for(let u=0;u<o.length;u++){const h=o[u],l=this.safeString(h,"symbol"),p=this.safeSymbol(l,n),m=this.safeInteger(h,"settleTime");d.push({info:h,symbol:p,fundingRate:this.safeString(h,"fundingRate"),timestamp:m,datetime:this.iso8601(m)})}const c=this.sortBy(d,"timestamp");return this.filterBySymbolSinceLimit(c,n.symbol,t,s)}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new sr(this.id+" fetchFundingRate() supports swap contracts only");const i={symbol:s.id},n=await this.publicMixGetMarketCurrentFundRate(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseFundingRate(r,s)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t);return{info:e,symbol:i,markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeNumber(e,"fundingRate"),fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets();const n=this.safeString(i,"holdSide"),r=this.market(e),a=r.linear?r.quote:r.base,o={symbol:r.id,marginCoin:a,amount:this.amountToPrecision(e,t),holdSide:n};i=this.omit(i,"holdSide");const d=await this.privateMixPostAccountSetMargin(this.extend(o,i));return this.extend(this.parseMarginModification(d,r),{amount:this.parseNumber(t),type:s})}parseMarginModification(e,t=void 0){const i=this.safeString(e,"code")==="00000"?"ok":"failed",n=t.linear?t.quote:t.base;return{info:e,type:void 0,amount:void 0,code:n,symbol:t.symbol,status:i}}async reduceMargin(e,t,s={}){if(t>0)throw new Ve(this.id+" reduceMargin() amount parameter must be a negative value");if(this.safeString(s,"holdSide")===void 0)throw new ks(this.id+" reduceMargin() requires a holdSide parameter, either long or short");return await this.modifyMarginHelper(e,t,"reduce",s)}async addMargin(e,t,s={}){if(this.safeString(s,"holdSide")===void 0)throw new ks(this.id+" addMargin() requires a holdSide parameter, either long or short");return await this.modifyMarginHelper(e,t,"add",s)}async fetchLeverage(e,t={}){await this.loadMarkets();const i={symbol:this.market(e).id};return await this.publicMixGetMarketSymbolLeverage(this.extend(i,t))}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new ks(this.id+" setLeverage() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={symbol:i.id,marginCoin:i.settleId,leverage:e};return await this.privateMixPostAccountSetLeverage(this.extend(n,s))}async setMarginMode(e,t=void 0,s={}){if(t===void 0)throw new ks(this.id+" setMarginMode() requires a symbol argument");if(e=e.toLowerCase(),e!=="fixed"&&e!=="crossed")throw new ks(this.id+' setMarginMode() marginMode must be "fixed" or "crossed"');await this.loadMarkets();const i=this.market(t),n={symbol:i.id,marginCoin:i.settleId,marginMode:e};return await this.privateMixPostAccountSetMarginMode(this.extend(n,s))}async fetchOpenInterest(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.contract)throw new Ve(this.id+" fetchOpenInterest() supports contract markets only");const i={symbol:s.id},n=await this.publicMixGetMarketOpenInterest(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseOpenInterest(r,s)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=s==="swap",o=i==="swap",d=r.code==="USDT";a?s=d?"mix_usdt":"mix_usd":o&&(i=d?"mix_usdt":"mix_usd");const c={fromType:s,toType:i,amount:t,coin:r.info.coinName},u=await this.privateSpotPostWalletTransfer(this.extend(c,n));return this.parseTransfer(u,r)}parseTransfer(e,t=void 0){const s=this.safeInteger(e,"requestTime"),i=this.safeString(e,"msg");return{info:e,id:this.safeString(e,"id"),timestamp:s,datetime:this.iso8601(s),currency:this.safeString(t,"code"),amount:this.safeNumber(e,"size"),fromAccount:void 0,toAccount:void 0,status:i==="success"?"ok":i}}parseTransferStatus(e){const t={success:"ok"};return this.safeString(t,e,e)}parseOpenInterest(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const n=this.safeNumber(e,"amount");return{symbol:this.safeSymbol(i),baseVolume:n,quoteVolume:void 0,openInterestAmount:n,openInterestValue:void 0,timestamp:s,datetime:this.iso8601(s),info:e}}handleErrors(e,t,s,i,n,r,a,o,d){if(!a)return;const c=this.safeString(a,"err_msg"),u=this.safeString2(a,"code","err_code"),h=this.id+" "+r,l=c!==void 0&&c!=="";l&&(this.throwExactlyMatchedException(this.exceptions.exact,c,h),this.throwBroadlyMatchedException(this.exceptions.broad,c,h));const p=u!==void 0&&u!=="00000";if(p&&this.throwExactlyMatchedException(this.exceptions.exact,u,h),p||l)throw new Z(h)}sign(e,t=[],s="GET",i={},n=void 0,r=void 0){const a=t[0]==="private",o=t[1],d=o==="spot"?"/api/spot/v1":"/api/mix/v1",c="/"+this.implodeParams(e,i),u=d+c;let h=this.implodeHostname(this.urls.api[o])+u;const l=this.omit(i,this.extractParams(e));if(!a&&s==="GET"&&Object.keys(l).length>0&&(h=h+"?"+this.urlencode(l)),a){this.checkRequiredCredentials();const p=this.milliseconds().toString();let m=p+s+u;if(s==="POST")r=this.json(i),m+=r;else if(Object.keys(i).length){const y="?"+this.urlencode(this.keysort(i));h+=y,m+=y}const g=this.hmac(this.encode(m),this.encode(this.secret),"sha256","base64");n={"ACCESS-KEY":this.apiKey,"ACCESS-SIGN":g,"ACCESS-TIMESTAMP":p,"ACCESS-PASSPHRASE":this.password},s==="POST"&&(n["Content-Type"]="application/json")}return{url:h,method:s,body:r,headers:n}}};const H5=me,{ExchangeError:bf,ExchangeNotAvailable:G5,AuthenticationError:xm,BadRequest:_m,PermissionDenied:_S,InvalidAddress:U5,ArgumentsRequired:tc,InvalidOrder:$5}=oe,{DECIMAL_PLACES:j5,SIGNIFICANT_DIGITS:W5,TRUNCATE:z5}=pe,K5=ke;var X5=class extends H5{describe(){return this.deepExtend(super.describe(),{id:"bithumb",name:"Bithumb",countries:["KR"],rateLimit:500,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTransfer:!1,fetchTransfers:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},hostname:"bithumb.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/30597177-ea800172-9d5e-11e7-804c-b9d4fa9b56b0.jpg",api:{public:"https://api.{hostname}/public",private:"https://api.{hostname}"},www:"https://www.bithumb.com",doc:"https://apidocs.bithumb.com",fees:"https://en.bithumb.com/customer_support/info_fee"},api:{public:{get:["ticker/{currency}","ticker/all","ticker/ALL_BTC","ticker/ALL_KRW","orderbook/{currency}","orderbook/all","transaction_history/{currency}","transaction_history/all","candlestick/{currency}/{interval}"]},private:{post:["info/account","info/balance","info/wallet_address","info/ticker","info/orders","info/user_transactions","info/order_detail","trade/place","trade/cancel","trade/btc_withdrawal","trade/krw_deposit","trade/krw_withdrawal","trade/market_buy","trade/market_sell"]}},fees:{trading:{maker:this.parseNumber("0.0025"),taker:this.parseNumber("0.0025")}},precisionMode:W5,exceptions:{"Bad Request(SSL)":_m,"Bad Request(Bad Method)":_m,"Bad Request.(Auth Data)":xm,"Not Member":xm,"Invalid Apikey":xm,"Method Not Allowed.(Access IP)":_S,"Method Not Allowed.(BTC Adress)":U5,"Method Not Allowed.(Access)":_S,"Database Fail":G5,"Invalid Parameter":_m,5600:bf,"Unknown Error":bf,"After May 23th, recent_transactions is no longer, hence users will not be able to connect to recent_transactions":bf},timeframes:{"1m":"1m","3m":"3m","5m":"5m","10m":"10m","30m":"30m","1h":"1h","6h":"6h","12h":"12h","1d":"24h"},options:{quoteCurrencies:{BTC:{limits:{cost:{min:2e-4,max:100}}},KRW:{limits:{cost:{min:500,max:5e9}}}}},commonCurrencies:{FTC:"FTC2",SOC:"Soda Coin"}})}amountToPrecision(e,t){return this.decimalToPrecision(t,z5,this.markets[e].precision.amount,j5)}async fetchMarkets(e={}){const t=[],s=this.safeValue(this.options,"quoteCurrencies",{}),i=Object.keys(s);for(let n=0;n<i.length;n++){const r=i[n],a=r,o=this.safeValue(s,r,{}),d="publicGetTickerALL"+r,c=await this[d](e),u=this.safeValue(c,"data"),h=Object.keys(u);for(let l=0;l<h.length;l++){const p=h[l];if(p==="date")continue;const m=u[p],g=this.safeCurrencyCode(p);let y=!0;Array.isArray(m)&&m.length===0&&(y=!1);const b=this.deepExtend({id:p,symbol:g+"/"+r,base:g,quote:r,settle:void 0,baseId:p,quoteId:a,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:y,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDateTime:void 0,strike:void 0,optionType:void 0,precision:{amount:parseInt("4"),price:parseInt("4")},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{}},info:m},o);t.push(b)}}return t}parseBalance(e){const t={info:e},s=this.safeValue(e,"data"),i=Object.keys(this.currencies);for(let n=0;n<i.length;n++){const r=i[n],a=this.account(),o=this.currency(r),d=this.safeStringLower(o,"id");a.total=this.safeString(s,"total_"+d),a.used=this.safeString(s,"in_use_"+d),a.free=this.safeString(s,"available_"+d),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t={currency:"ALL"},s=await this.privatePostInfoBalance(this.extend(t,e));return this.parseBalance(s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={currency:i.base+"_"+i.quote};t!==void 0&&(n.count=t);const r=await this.publicGetOrderbookCurrency(this.extend(n,s)),a=this.safeValue(r,"data",{}),o=this.safeInteger(a,"timestamp");return this.parseOrderBook(a,e,o,"bids","asks","price","quantity")}parseTicker(e,t=void 0){const s=this.safeInteger(e,"date"),i=this.safeSymbol(void 0,t),n=this.safeString(e,"opening_price"),r=this.safeString(e,"closing_price"),a=this.safeString(e,"units_traded_24H"),o=this.safeString(e,"acc_trade_value_24H");return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"max_price"),low:this.safeString(e,"min_price"),bid:this.safeString(e,"buy_price"),bidVolume:void 0,ask:this.safeString(e,"sell_price"),askVolume:void 0,vwap:void 0,open:n,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:a,quoteVolume:o,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTickerAll(t),i={},n=this.safeValue(s,"data",{}),r=this.safeInteger(n,"date"),a=this.omit(n,"date"),o=Object.keys(a);for(let d=0;d<o.length;d++){const c=o[d],u=this.safeMarket(c),h=u.symbol,l=a[c];Array.isArray(l)||(l.date=r,i[h]=this.parseTicker(l,u))}return this.filterByArray(i,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={currency:s.base},n=await this.publicGetTickerCurrency(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTicker(r,s)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={currency:r.base,interval:this.timeframes[t]},o=await this.publicGetCandlestickCurrencyInterval(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseOHLCVs(d,r,t,s,i)}parseTrade(e,t=void 0){let s;const i=this.safeString(e,"transaction_date");if(i!==void 0){const l=i.split(" ");if(l.length>1){const m=l[0];let g=l[1];g.length<8&&(g="0"+g),s=this.parse8601(m+" "+g)}else s=this.safeIntegerProduct(e,"transaction_date",.001)}s!==void 0&&(s-=9*36e5);const n=void 0;let r=this.safeString(e,"type");r=r==="ask"?"sell":"buy";const a=this.safeString(e,"cont_no");t=this.safeMarket(void 0,t);const o=this.safeString(e,"price"),d=this.fixCommaNumber(this.safeString2(e,"units_traded","units")),c=this.safeString(e,"total");let u;const h=this.safeString(e,"fee");if(h!==void 0){const l=this.safeString(e,"fee_currency"),p=this.commonCurrencyCode(l);u={cost:h,currency:p}}return this.safeTrade({id:a,info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:void 0,type:n,side:r,takerOrMaker:void 0,price:o,amount:d,cost:c,fee:u},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={currency:n.base};s===void 0&&(r.count=s);const a=await this.publicGetTransactionHistoryCurrency(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={order_currency:a.id,payment_currency:a.quote,units:i};let d="privatePostTradePlace";t==="limit"?(o.price=n,o.type=s==="buy"?"bid":"ask"):d="privatePostTradeMarket"+this.capitalize(s);const c=await this[d](this.extend(o,r)),u=this.safeString(c,"order_id");if(u===void 0)throw new $5(this.id+" createOrder() did not return an order id");return{info:c,symbol:e,type:t,side:s,id:u}}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new tc(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={order_id:e,count:1,order_currency:i.base,payment_currency:i.quote},r=await this.privatePostInfoOrderDetail(this.extend(n,s)),a=this.safeValue(r,"data");return this.parseOrder(this.extend(a,{order_id:e}),i)}parseOrderStatus(e){const t={Pending:"open",Completed:"closed",Cancel:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeIntegerProduct(e,"order_date",.001),n=this.safeValue2(e,"type","side")==="bid"?"buy":"sell",r=this.parseOrderStatus(this.safeString(e,"order_status")),a=this.safeString2(e,"order_price","price");let o="limit";K5.stringEquals(a,"0")&&(o="market");const d=this.fixCommaNumber(this.safeString2(e,"order_qty","units"));let c=this.fixCommaNumber(this.safeString(e,"units_remaining"));c===void 0&&(r==="closed"?c="0":r!=="canceled"&&(c=d));let u;const h=this.safeString(e,"order_currency"),l=this.safeString(e,"payment_currency"),p=this.safeCurrencyCode(h),m=this.safeCurrencyCode(l);p!==void 0&&m!==void 0&&(u=p+"/"+m),u===void 0&&(t=this.safeMarket(void 0,t),u=t.symbol);const g=this.safeString(e,"order_id"),y=this.safeValue(e,"contract",[]);return this.safeOrder({info:e,id:g,clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,symbol:u,type:o,timeInForce:void 0,postOnly:void 0,side:n,price:a,stopPrice:void 0,amount:d,cost:void 0,average:void 0,filled:void 0,remaining:c,status:r,fee:void 0,trades:y},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new tc(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e);s===void 0&&(s=100);const r={count:s,order_currency:n.base,payment_currency:n.quote};t!==void 0&&(r.after=t);const a=await this.privatePostInfoOrders(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseOrders(o,n,t,s)}async cancelOrder(e,t=void 0,s={}){if(!("side"in s))throw new tc(this.id+" cancelOrder() requires a `side` parameter (sell or buy)");if(t===void 0)throw new tc(this.id+" cancelOrder() requires a `symbol` argument");const n=this.market(t),r=s.side==="buy"?"bid":"ask";s=this.omit(s,["side","currency"]);const a={order_id:e,type:r,order_currency:n.base,payment_currency:n.quote};return await this.privatePostTradeCancel(this.extend(a,s))}cancelUnifiedOrder(e,t={}){const s={side:e.side};return this.cancelOrder(e.id,e.symbol,this.extend(s,t))}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={units:t,address:s,currency:r.id};if(r==="XRP"||r==="XMR"||r==="EOS"||r==="STEEM"){const d=this.safeString(n,"destination");if(i===void 0&&d===void 0)throw new tc(this.id+" "+e+" withdraw() requires a tag argument or an extra destination param");i!==void 0&&(a.destination=i)}const o=await this.privatePostTradeBtcWithdrawal(this.extend(a,n));return this.parseTransaction(o,r)}parseTransaction(e,t=void 0){return t=this.safeCurrency(void 0,t),{id:void 0,txid:void 0,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0,info:e}}fixCommaNumber(e){if(e===void 0)return;let t=e;for(;t.indexOf(",")>-1;)t=t.replace(",","");return t}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a="/"+this.implodeParams(e,i);let o=this.implodeHostname(this.urls.api[t])+a;const d=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(d).length&&(o+="?"+this.urlencode(d));else{this.checkRequiredCredentials(),r=this.urlencode(this.extend({endpoint:a},d));const c=this.nonce().toString(),u=a+"\0"+r+"\0"+c,h=this.hmac(this.encode(u),this.encode(this.secret),"sha512"),l=this.decode(this.stringToBase64(h));n={Accept:"application/json","Content-Type":"application/x-www-form-urlencoded","Api-Key":this.apiKey,"Api-Sign":l,"Api-Nonce":c}}return{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&"status"in a){const c=this.safeString(a,"status"),u=this.safeString(a,"message");if(c!==void 0){if(c==="0000")return;if(u==="\uAC70\uB798 \uC9C4\uD589\uC911\uC778 \uB0B4\uC5ED\uC774 \uC874\uC7AC\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4")return;const h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions,c,h),this.throwExactlyMatchedException(this.exceptions,u,h),new bf(h)}}}};const Y5=me,{AuthenticationError:ir,ExchangeNotAvailable:CS,AccountSuspended:Cm,PermissionDenied:Ca,RateLimitExceeded:Q5,InvalidNonce:Z5,InvalidAddress:MS,ArgumentsRequired:mn,ExchangeError:vt,InvalidOrder:Ct,InsufficientFunds:sc,BadRequest:$t,OrderNotFound:PS,BadSymbol:ic,NotSupported:gn}=oe,{TICK_SIZE:J5,TRUNCATE:e6}=pe,Mm=ke;var I_=class extends Y5{describe(){return this.deepExtend(super.describe(),{id:"bitmart",name:"BitMart",countries:["US","CN","HK","KR"],rateLimit:33.34,version:"v2",certified:!0,pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:void 0,future:!1,option:void 0,borrowMargin:!0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!1,createOrder:!0,createPostOnlyOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowInterest:!0,fetchBorrowRate:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!0,fetchCanceledOrders:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchFundingHistory:void 0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchOrderTrades:!0,fetchPositionMode:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactionFee:!0,fetchTransactionFees:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawAddressesByNetwork:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,reduceMargin:!1,repayMargin:!0,setLeverage:!1,setMarginMode:!1,transfer:!0,withdraw:!0},hostname:"bitmart.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/129991357-8f47464b-d0f4-41d6-8a82-34122f0d1398.jpg",api:{rest:"https://api-cloud.{hostname}"},www:"https://www.bitmart.com/",doc:"https://developer-pro.bitmart.com/",referral:{url:"http://www.bitmart.com/?r=rQCFLh",discount:.3},fees:"https://www.bitmart.com/fee/en"},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},api:{public:{get:{"system/time":3,"system/service":3,"spot/v1/currencies":7.5,"spot/v1/symbols":7.5,"spot/v1/symbols/details":5,"spot/v1/ticker":5,"spot/v2/ticker":5,"spot/v1/steps":30,"spot/v1/symbols/kline":5,"spot/v1/symbols/book":5,"spot/v1/symbols/trades":5,"contract/v1/tickers":15,"contract/public/details":5,"contract/public/depth":5,"contract/public/open-interest":30,"contract/public/funding-rate":30,"contract/public/kline":5}},private:{get:{"account/sub-account/v1/transfer-list":7.5,"account/sub-account/v1/transfer-history":7.5,"account/sub-account/main/v1/wallet":5,"account/sub-account/main/v1/subaccount-list":7.5,"account/v1/wallet":5,"account/v1/currencies":30,"spot/v1/wallet":5,"account/v1/deposit/address":30,"account/v1/withdraw/charge":32,"account/v2/deposit-withdraw/history":7.5,"account/v1/deposit-withdraw/detail":7.5,"spot/v1/order_detail":1,"spot/v2/orders":5,"spot/v1/trades":5,"spot/v2/trades":5,"spot/v3/orders":5,"spot/v2/order_detail":1,"spot/v1/margin/isolated/borrow_record":1,"spot/v1/margin/isolated/repay_record":1,"spot/v1/margin/isolated/pairs":1,"spot/v1/margin/isolated/account":6,"spot/v1/trade_fee":6,"spot/v1/user_fee":6,"contract/private/assets-detail":5,"contract/private/order":2,"contract/private/order-history":10,"contract/private/position":10},post:{"account/sub-account/main/v1/sub-to-main":30,"account/sub-account/sub/v1/sub-to-main":30,"account/sub-account/main/v1/main-to-sub":30,"account/sub-account/sub/v1/sub-to-sub":30,"account/sub-account/main/v1/sub-to-sub":30,"account/v1/withdraw/apply":7.5,"spot/v1/submit_order":1,"spot/v1/batch_orders":1,"spot/v2/cancel_order":1,"spot/v1/cancel_orders":15,"spot/v3/cancel_order":1,"spot/v2/batch_orders":1,"spot/v2/submit_order":1,"spot/v1/margin/submit_order":1,"spot/v1/margin/isolated/borrow":6,"spot/v1/margin/isolated/repay":6,"spot/v1/margin/isolated/transfer":6,"contract/private/trades":10}}},timeframes:{"1m":1,"3m":3,"5m":5,"15m":15,"30m":30,"45m":45,"1h":60,"2h":120,"3h":180,"4h":240,"1d":1440,"1w":10080,"1M":43200},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0025"),maker:this.parseNumber("0.0025"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.0020")],[this.parseNumber("10"),this.parseNumber("0.18")],[this.parseNumber("50"),this.parseNumber("0.0016")],[this.parseNumber("250"),this.parseNumber("0.0014")],[this.parseNumber("1000"),this.parseNumber("0.0012")],[this.parseNumber("5000"),this.parseNumber("0.0010")],[this.parseNumber("25000"),this.parseNumber("0.0008")],[this.parseNumber("50000"),this.parseNumber("0.0006")]],maker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("10"),this.parseNumber("0.0009")],[this.parseNumber("50"),this.parseNumber("0.0008")],[this.parseNumber("250"),this.parseNumber("0.0007")],[this.parseNumber("1000"),this.parseNumber("0.0006")],[this.parseNumber("5000"),this.parseNumber("0.0005")],[this.parseNumber("25000"),this.parseNumber("0.0004")],[this.parseNumber("50000"),this.parseNumber("0.0003")]]}}},precisionMode:J5,exceptions:{exact:{3e4:vt,30001:ir,30002:ir,30003:Cm,30004:ir,30005:ir,30006:ir,30007:ir,30008:ir,30010:Ca,30011:ir,30012:ir,30013:Q5,30014:CS,6e4:$t,60001:$t,60002:$t,60003:vt,60004:vt,60005:vt,60006:vt,60007:MS,60008:sc,60009:vt,60010:vt,60011:MS,60012:vt,60020:Ca,60021:Ca,60022:Ca,60030:$t,60031:$t,60050:vt,60051:vt,61001:sc,61003:$t,5e4:$t,50001:ic,50002:$t,50003:$t,50004:$t,50005:PS,50006:Ct,50007:Ct,50008:Ct,50009:Ct,50010:Ct,50011:Ct,50012:Ct,50013:Ct,50014:$t,50015:$t,50016:$t,50017:$t,50018:$t,50019:$t,51004:sc,50020:sc,50021:$t,50022:CS,50023:ic,50029:Ct,50030:Ct,50032:PS,50035:Ct,50034:Ct,53e3:Cm,53001:Cm,57001:$t,58001:$t,59001:vt,59002:vt,40001:vt,40002:vt,40003:vt,40004:vt,40005:vt,40006:Ca,40007:$t,40008:Z5,40009:$t,40010:$t,40011:$t,40012:vt,40013:vt,40014:ic,40015:ic,40016:Ct,40017:Ct,40018:Ct,40019:vt,40020:Ct,40021:vt,40022:vt,40023:vt,40024:vt,40025:vt,40026:vt,40027:sc,40028:Ca,40029:Ct,40030:Ct,40031:Ct,40032:Ct,40033:Ct,40034:ic,53002:Ca},broad:{}},commonCurrencies:{$GM:"GOLDMINER",$HERO:"Step Hero",$PAC:"PAC",BP:"BEYOND",GDT:"Gorilla Diamond",GLD:"Goldario",MVP:"MVP Coin",TRU:"Truebit"},options:{networks:{TRX:"TRC20",ETH:"ERC20"},defaultNetworks:{USDT:"ERC20"},defaultType:"spot",fetchBalance:{type:"spot"},createMarketBuyOrderRequiresPrice:!0}})}async fetchTime(e={}){const t=await this.publicGetSystemTime(e),s=this.safeValue(t,"data",{});return this.safeInteger(s,"server_time")}async fetchStatus(e={}){const t=this.safeValue(this.options,"fetchStatus",{}),s=this.safeString(this.options,"defaultType");let i=this.safeString(t,"type",s);i=this.safeString(e,"type",i),e=this.omit(e,"type");const n=await this.publicGetSystemService(e),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"service",[]),o=this.indexBy(a,"service_type");i==="swap"&&(i="contract");const d=this.safeValue(o,i);let c,u;return d!==void 0&&(this.safeInteger(d,"status")===2?c="ok":(c="maintenance",u=this.safeInteger(d,"end_time"))),{status:c,updated:void 0,eta:u,url:void 0,info:n}}async fetchSpotMarkets(e={}){const t=await this.publicGetSpotV1SymbolsDetails(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"symbols",[]),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"symbol"),d=this.safeInteger(a,"symbol_id"),c=this.safeString(a,"base_currency"),u=this.safeString(a,"quote_currency"),h=this.safeCurrencyCode(c),l=this.safeCurrencyCode(u),p=h+"/"+l,m=this.safeString(a,"min_buy_amount"),g=this.safeString(a,"min_sell_amount"),y=Mm.stringMax(m,g),b=this.safeNumber(a,"base_min_size");n.push({id:o,numericId:d,symbol:p,base:h,quote:l,settle:void 0,baseId:c,quoteId:u,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:b,price:this.parseNumber(this.parsePrecision(this.safeString(a,"price_max_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:b,max:this.safeNumber(a,"base_max_size")},price:{min:void 0,max:void 0},cost:{min:this.parseNumber(y),max:void 0}},info:a})}return n}async fetchContractMarkets(e={}){const t=await this.publicGetContractV1Tickers(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"tickers",[]),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"contract_symbol"),d=o.slice(0,-4),c=o.slice(-4),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),l="USDT",p=u+"/"+h+":"+l;n.push({id:o,numericId:void 0,symbol:p,base:u,quote:h,settle:l,baseId:d,quoteId:c,settleId:void 0,type:"swap",spot:!1,margin:!1,swap:!0,future:!1,option:!1,active:!0,contract:!0,linear:!0,inverse:!1,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:void 0,price:void 0},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:a})}return n}async fetchMarkets(e={}){const t=await this.fetchSpotMarkets(e),s=await this.fetchContractMarkets(e);return this.arrayConcat(t,s)}async fetchCurrencies(e={}){const t=await this.publicGetSpotV1Currencies(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"currencies",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"id"),d=this.safeCurrencyCode(o),c=this.safeString(a,"name"),u=this.safeValue(a,"withdraw_enabled"),h=this.safeValue(a,"deposit_enabled"),l=u&&h;n[d]={id:o,code:d,name:c,info:a,active:l,deposit:h,withdraw:u,fee:void 0,precision:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}}}return n}async fetchTransactionFee(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.privateGetAccountV1WithdrawCharge(this.extend(i,t)),r=n.data,a={};return a[e]=this.safeNumber(r,"withdraw_fee"),{info:n,withdraw:a,deposit:{}}}parseTicker(e,t=void 0){const s=this.safeInteger(e,"timestamp",this.milliseconds()),i=this.safeString2(e,"symbol","contract_symbol");t=this.safeMarket(i,t);const n=t.symbol,r=this.safeString2(e,"close_24h","last_price");let a=this.safeString(e,"price_change_percent_24h");if(a===void 0){const l=this.safeString(e,"fluctuation");if(l!==void 0&&l!=="0"){const p=l[0];a=p+Mm.stringMul(l.replace(p,""),"100")}else l==="0"&&(a="0")}const o=this.safeString(e,"base_volume_24h");let d=this.safeString(e,"quote_volume_24h");d=this.safeString(e,"volume_24h",d);const c=this.safeString2(e,"avg_price","index_price"),u=this.safeString2(e,"high_24h","high_price"),h=this.safeString2(e,"low_24h","low_price");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:u,low:h,bid:this.safeString(e,"best_bid"),bidVolume:this.safeString(e,"best_bid_size"),ask:this.safeString(e,"best_ask"),askVolume:this.safeString(e,"best_ask_size"),vwap:void 0,open:this.safeString(e,"open_24h"),close:r,last:r,previousClose:void 0,change:void 0,percentage:a,average:c,baseVolume:o,quoteVolume:d,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={};let n;s.swap?(n="publicGetContractV1Tickers",i.contract_symbol=s.id):s.spot&&(n="publicGetSpotV1Ticker",i.symbol=s.id);const r=await this[n](this.extend(i,t)),a=this.safeValue(r,"data",{}),o=this.safeValue(a,"tickers",[]);let d;s.spot?d=this.indexBy(o,"symbol"):s.swap&&(d=this.indexBy(o,"contract_symbol"));const c=this.safeValue(d,s.id);return this.parseTicker(c,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s,i;if(e!==void 0){const c=this.safeValue(e,0);i=this.market(c)}[s,t]=this.handleMarketTypeAndParams("fetchTickers",i,t);const n=this.getSupportedMapping(s,{spot:"publicGetSpotV2Ticker",swap:"publicGetContractV1Tickers"}),r=await this[n](t),a=this.safeValue(r,"data",{}),o=this.safeValue(a,"tickers",[]),d={};for(let c=0;c<o.length;c++){const u=this.parseTicker(o[c]),h=u.symbol;d[h]=u}return this.filterByArray(d,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);if(!i.spot)throw new gn(this.id+" fetchOrderBook() does not support "+i.type+" markets, only spot markets are accepted");const n={symbol:i.id};t!==void 0&&(n.size=t);const r=await this.publicGetSpotV1SymbolsBook(this.extend(n,s)),a=this.safeValue(r,"data",{}),o=this.safeInteger(a,"timestamp");return this.parseOrderBook(a,e,o,"buys","sells","price","amount")}parseTrade(e,t=void 0){const s=this.safeString(e,"detail_id"),i=this.safeInteger2(e,"order_time","create_time"),n=void 0,r=this.safeStringLower2(e,"type","side");let a;const o=this.safeString(e,"exec_type");o!==void 0&&(a=o==="M"?"maker":"taker");let d=this.safeString(e,"price");d=this.safeString(e,"price_avg",d);let c=this.safeString(e,"count");c=this.safeString(e,"size",c);const u=this.safeString2(e,"amount","notional"),h=this.safeString(e,"order_id"),l=this.safeString(e,"symbol");t=this.safeMarket(l,t,"_");const p=this.safeString(e,"fees");let m;if(p!==void 0){const g=this.safeString(e,"fee_coin_name");let y=this.safeCurrencyCode(g);y===void 0&&(y=r==="buy"?t.base:t.quote),m={cost:p,currency:y}}return this.safeTrade({info:e,id:s,order:h,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,type:n,side:r,price:d,amount:c,cost:u,takerOrMaker:a,fee:m},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);if(!n.spot)throw new gn(this.id+" fetchTrades() does not support "+n.type+" orders, only spot orders are accepted");const r={symbol:n.id},a=await this.publicGetSpotV1SymbolsTrades(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"trades",[]);return this.parseTrades(d,n,t,s)}parseOHLCV(e,t=void 0){return Array.isArray(e)?[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]:[this.safeTimestamp(e,"timestamp"),this.safeNumber2(e,"open","open_price"),this.safeNumber2(e,"high","high_price"),this.safeNumber2(e,"low","low_price"),this.safeNumber2(e,"close","close_price"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=r.type,o=this.parseTimeframe(t),d={symbol:r.id,step:this.timeframes[t]},c=500;i===void 0&&(i=c),i=Math.min(c,i);const u=parseInt(this.milliseconds()/1e3),h=a==="spot"?"from":"start_time",l=a==="spot"?"to":"end_time";if(s===void 0){const w=u-i*o;d[h]=w,d[l]=u}else{const w=parseInt(s/1e3)-1,S=this.sum(w,i*o);d[h]=w,d[l]=Math.min(S,u)}let p="publicGetSpotV1SymbolsKline";a==="swap"&&(p="publicGetContractPublicKline");const m=await this[p](this.extend(d,n)),g=this.safeValue(m,"data",{}),y=this.safeValue(g,"klines",[]),b=a==="spot"?y:g;return this.parseOHLCVs(b,r,t,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new mn(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e);if(!n.spot)throw new gn(this.id+" fetchMyTrades() does not support "+n.type+" orders, only spot orders are accepted");const r=this.safeValue(this.options,"fetchMyTrades",{}),a=this.safeInteger(r,"limit",200);s===void 0&&(s=a);const o={symbol:n.id,N:s},d=await this.privateGetSpotV2Trades(this.extend(o,i)),c=this.safeValue(d,"data",{}),u=this.safeValue(c,"trades",[]);return this.parseTrades(u,n,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){if(t===void 0)throw new mn(this.id+" fetchOrderTrades() requires a symbol argument");await this.loadMarkets();const r=this.market(t);if(!r.spot)throw new gn(this.id+" fetchOrderTrades() does not support "+r.type+" orders, only spot orders are accepted");const a=this.safeValue(this.options,"fetchOrderTrades",{}),o=this.safeInteger(a,"limit",200);i===void 0&&(i=o);const d={symbol:r.id,order_id:e,N:i},c=await this.privateGetSpotV2Trades(this.extend(d,n)),u=this.safeValue(c,"data",{}),h=this.safeValue(u,"trades",[]);return this.parseTrades(h,r,s,i)}parseBalance(e,t){let s;if(t==="swap")s=this.safeValue(e,"data",[]);else{const n=this.safeValue(e,"data",{});s=this.safeValue(n,"wallet",[])}const i={info:e};for(let n=0;n<s.length;n++){const r=s[n];let a=this.safeString2(r,"id","currency");a=this.safeString(r,"coin_code",a);const o=this.safeCurrencyCode(a),d=this.account();d.free=this.safeString2(r,"available","available_balance"),d.used=this.safeString2(r,"frozen","frozen_balance"),i[o]=d}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),i=this.getSupportedMapping(t,{spot:"privateGetSpotV1Wallet",swap:"privateGetContractPrivateAssetsDetail",account:"privateGetAccountV1Wallet"}),n=await this[i](s);return this.parseBalance(n,t)}parseTradingFee(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s);return{info:e,symbol:i,maker:this.safeNumber(e,"maker_fee_rate"),taker:this.safeNumber(e,"taker_fee_rate")}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.spot)throw new gn(this.id+" fetchTradingFee() does not support "+s.type+" orders, only spot orders are accepted");const i={symbol:s.id},n=await this.privateGetSpotV1TradeFee(this.extend(i,t)),r=this.safeValue(n,"data");return this.parseTradingFee(r)}parseOrder(e,t=void 0){let s;typeof e=="string"&&(s=e,e={}),s=this.safeString(e,"order_id",s);const i=this.safeInteger(e,"create_time"),n=this.safeString(e,"symbol"),r=this.safeSymbol(n,t,"_");let a;t!==void 0&&(a=this.parseOrderStatusByType(t.type,this.safeString(e,"status")));const o=this.safeString(e,"size"),d=this.safeString(e,"filled_size"),c=this.safeString(e,"price_avg"),u=this.safeString(e,"price"),h=this.safeString(e,"side");let l=this.safeString(e,"type"),p,m;return l==="limit_maker"&&(l="limit",m=!0,p="PO"),l==="ioc"&&(l="limit",p="IOC"),this.safeOrder({id:s,clientOrderId:void 0,info:e,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,symbol:r,type:l,timeInForce:p,postOnly:m,side:h,price:u,stopPrice:void 0,amount:o,cost:void 0,average:c,filled:d,remaining:void 0,status:a,fee:void 0,trades:void 0},t)}parseOrderStatusByType(e,t){const s={spot:{1:"failed",2:"open",3:"failed",4:"open",5:"open",6:"closed",7:"canceling",8:"canceled"},swap:{1:"open",2:"open",4:"closed"}},i=this.safeValue(s,e,{});return this.safeString(i,t,t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={},d=this.safeString(r,"timeInForce");if(d==="FOK")throw new Ct(this.id+" createOrder() only accepts timeInForce parameter values of IOC or PO");const c=t==="market",u=this.isPostOnly(c,t==="limit_maker",r);r=this.omit(r,["timeInForce","postOnly"]);const h=d==="IOC"||t==="ioc",l=t==="limit"||u||h;let p;if(a.spot){if(o.symbol=a.id,o.side=s,o.type=t,p="privatePostSpotV2SubmitOrder",l)o.size=this.amountToPrecision(e,i),o.price=this.priceToPrecision(e,n);else if(c)if(s==="buy"){let S=this.safeNumber(r,"notional");if(this.safeValue(this.options,"createMarketBuyOrderRequiresPrice",!0)){if(n!==void 0){if(S===void 0){const T=this.numberToString(i),I=this.numberToString(n);S=this.parseNumber(Mm.stringMul(T,I))}}else if(S===void 0)throw new Ct(this.id+" createOrder () requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total cost value in the 'amount' argument or in the 'notional' extra parameter (the exchange-specific behaviour)")}else S=S===void 0?i:S;o.notional=this.decimalToPrecision(S,e6,a.precision.price,this.precisionMode)}else s==="sell"&&(o.size=this.amountToPrecision(e,i))}else if(a.swap)throw new gn(this.id+" createOrder() does not accept swap orders, only spot orders are allowed");u&&(o.type="limit_maker"),h&&(o.type="ioc");const[m,g]=this.handleMarginModeAndParams("createOrder",r);m!==void 0&&(p="privatePostSpotV1MarginSubmitOrder");const y=await this[p](this.extend(o,g)),b=this.safeValue(y,"data",{}),w=this.parseOrder(b,a);return this.extend(w,{type:t,side:s,amount:i,price:n})}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new mn(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t);if(!i.spot)throw new gn(this.id+" cancelOrder() does not support "+i.type+" orders, only spot orders are accepted");const n={order_id:e.toString(),symbol:i.id},r=await this.privatePostSpotV3CancelOrder(this.extend(n,s)),a=this.safeValue(r,"data");if(a===!0)return this.parseOrder(e,i);const o=this.safeValue(a,"succeed");if(o!==void 0){if(e=this.safeString(o,0),e===void 0)throw new Ct(this.id+" cancelOrder() failed to cancel "+t+" order id "+e)}else if(!this.safeValue(a,"result"))throw new Ct(this.id+" cancelOrder() "+t+" order id "+e+" is filled or canceled");const d=this.parseOrder(e,i);return this.extend(d,{id:e})}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new mn(this.id+" cancelAllOrders() requires a symbol argument");const s=this.safeString(t,"side");if(s===void 0)throw new mn(this.id+" cancelAllOrders() requires a `side` parameter ('buy' or 'sell')");await this.loadMarkets();const i=this.market(e);if(!i.spot)throw new gn(this.id+" cancelAllOrders() does not support "+i.type+" orders, only spot orders are accepted");const n={symbol:i.id,side:s};return await this.privatePostSpotV1CancelOrders(this.extend(n,t))}async fetchOrdersByStatus(e,t=void 0,s=void 0,i=void 0,n={}){if(t===void 0)throw new mn(this.id+" fetchOrdersByStatus() requires a symbol argument");await this.loadMarkets();const r=this.market(t);if(!r.spot)throw new gn(this.id+" fetchOrdersByStatus() does not support "+r.type+" orders, only spot orders are accepted");const a={symbol:r.id,offset:1,N:100};e==="open"?a.status=9:e==="closed"?a.status=6:e==="canceled"?a.status=8:a.status=e;const o=await this.privateGetSpotV3Orders(this.extend(a,n)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"orders",[]);return this.parseOrders(c,r,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("open",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("closed",e,t,s,i)}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("canceled",e,t,s,i)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new mn(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t);if(!i.spot)throw new gn(this.id+" fetchOrder() does not support "+i.type+" orders, only spot orders are accepted");typeof e!="string"&&(e=e.toString());const n={symbol:i.id,order_id:e},r=await this.privateGetSpotV2OrderDetail(this.extend(n,s)),a=this.safeValue(r,"data",{});return this.parseOrder(a,i)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id};if(e==="USDT"){const u=this.safeValue(this.options,"defaultNetworks"),h=this.safeStringUpper(u,e),l=this.safeValue(this.options,"networks",{});let p=this.safeStringUpper(t,"network",h);p=this.safeString(l,p,p),p!==void 0&&(i.currency+="-"+p,t=this.omit(t,"network"))}const n=await this.privateGetAccountV1DepositAddress(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeString(r,"address"),o=this.safeString(r,"address_memo"),d=this.safeString(r,"chain");let c;if(d!==void 0){const u=d.split("-"),h=this.safeString(u,1);c=this.safeNetwork(h)}return this.checkAddress(a),{currency:e,address:a,tag:o,network:c,info:n}}safeNetwork(e){return e}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,amount:t,destination:"To Digital Address",address:s};if(i!==void 0&&(a.address_memo=i),e==="USDT"){const u=this.safeValue(this.options,"defaultNetworks"),h=this.safeStringUpper(u,e),l=this.safeValue(this.options,"networks",{});let p=this.safeStringUpper(n,"network",h);p=this.safeString(l,p,p),p!==void 0&&(a.currency+="-"+p,n=this.omit(n,"network"))}const o=await this.privatePostAccountV1WithdrawApply(this.extend(a,n)),d=this.safeValue(o,"data"),c=this.parseTransaction(d,r);return this.extend(c,{code:e,address:s,tag:i})}async fetchTransactionsByType(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets(),i===void 0&&(i=50);const r={operation_type:e,offset:1,N:i};let a;if(t!==void 0&&(a=this.currency(t),r.currency=a.id),t==="USDT"){const u=this.safeValue(this.options,"defaultNetworks"),h=this.safeStringUpper(u,t),l=this.safeValue(this.options,"networks",{});let p=this.safeStringUpper(n,"network",h);p=this.safeString(l,p,p),p!==void 0&&(r.currency+="-"+p,a.code=r.currency,n=this.omit(n,"network"))}const o=await this.privateGetAccountV2DepositWithdrawHistory(this.extend(r,n)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"records",[]);return this.parseTransactions(c,a,s,i)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetAccountV1DepositWithdrawDetail(this.extend(i,s)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"record",{});return this.parseTransaction(a)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByType("deposit",e,t,s,i)}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateAccountGetDepositWithdrawDetail(this.extend(i,s)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"record",{});return this.parseTransaction(a)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByType("withdraw",e,t,s,i)}parseTransactionStatus(e){const t={0:"pending",1:"pending",2:"pending",3:"ok",4:"canceled",5:"failed"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){let s;const i=this.safeString(e,"withdraw_id"),n=this.safeString(e,"deposit_id");let r;i!==void 0&&i!==""?(r="withdraw",s=i):n!==void 0&&n!==""&&(r="deposit",s=n);const a=this.safeNumber(e,"arrival_amount"),o=this.safeInteger(e,"apply_time"),d=this.safeString(e,"currency"),c=this.safeCurrencyCode(d,t),u=this.parseTransactionStatus(this.safeString(e,"status")),h=this.safeNumber(e,"fee");let l;h!==void 0&&(l={cost:h,currency:c});const p=this.safeString(e,"tx_id"),m=this.safeString(e,"address"),g=this.safeString(e,"address_memo");return{info:e,id:s,currency:c,amount:a,network:void 0,address:m,addressFrom:void 0,addressTo:void 0,tag:g,tagFrom:void 0,tagTo:void 0,status:u,type:r,updated:void 0,txid:p,timestamp:o!==0?o:void 0,datetime:o!==0?this.iso8601(o):void 0,fee:l}}async repayMargin(e,t,s=void 0,i={}){if(await this.loadMarkets(),s===void 0)throw new mn(this.id+" repayMargin() requires a symbol argument");let n;[n,i]=this.handleMarginModeAndParams("repayMargin",i),n===void 0&&(n="isolated");const r=this.market(s),a=this.currency(e),o={symbol:r.id,currency:a.id,amount:this.currencyToPrecision(e,t)},d=await this.privatePostSpotV1MarginIsolatedRepay(this.extend(o,i)),c=this.safeValue(d,"data",{}),u=this.parseMarginLoan(c,a);return this.extend(u,{amount:t,symbol:s})}async borrowMargin(e,t,s=void 0,i={}){if(await this.loadMarkets(),s===void 0)throw new mn(this.id+" borrowMargin() requires a symbol argument");let n;[n,i]=this.handleMarginModeAndParams("borrowMargin",i),n===void 0&&(n="isolated");const r=this.market(s),a=this.currency(e),o={symbol:r.id,currency:a.id,amount:this.currencyToPrecision(e,t)},d=await this.privatePostSpotV1MarginIsolatedBorrow(this.extend(o,i)),c=this.safeValue(d,"data",{}),u=this.parseMarginLoan(c,a);return this.extend(u,{amount:t,symbol:s})}parseMarginLoan(e,t=void 0){const s=this.milliseconds();return{id:this.safeString2(e,"borrow_id","repay_id"),currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:s,datetime:this.iso8601(s),info:e}}async fetchBorrowRate(e,t={}){await this.loadMarkets();let s;if(e in this.markets)s=this.market(e);else{const d=this.safeString(this.options,"defaultSettle","USDT");e==="USDT"?s=this.market("BTC/"+d):s=this.market(e+"/"+d)}const i={symbol:s.id},n=await this.privateGetSpotV1MarginIsolatedPairs(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"symbols",[]),o=e==="USDT"?s.quote:s.base;return this.parseBorrowRate(a,o)}parseBorrowRate(e,t=void 0){const s=this.milliseconds(),i=t==="USDT"?this.safeValue(e[0],"quote",{}):this.safeValue(e[0],"base",{});return{currency:this.safeCurrencyCode(t),rate:this.safeNumber(i,"hourly_interest"),period:36e5,timestamp:s,datetime:this.iso8601(s),info:e}}async fetchBorrowRates(e={}){await this.loadMarkets();const t=await this.privateGetSpotV1MarginIsolatedPairs(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"symbols",[]);return this.parseBorrowRates(i,void 0)}parseBorrowRates(e,t){const s=this.milliseconds(),i=[];for(let n=0;n<e.length;n++){const r=e[n],a=this.safeValue(r,"base",{});i.push({currency:this.safeCurrencyCode(this.safeString(a,"currency")),rate:this.safeNumber(a,"hourly_interest"),period:36e5,timestamp:s,datetime:this.iso8601(s),info:r})}return i}async transfer(e,t,s,i,n={}){const r=this.safeString(n,"symbol");if(r===void 0)throw new mn(this.id+" transfer() requires a symbol argument");await this.loadMarkets();const a=this.market(r),o=this.currency(e),d=this.currencyToPrecision(e,t),c={amount:d,currency:o.id,symbol:a.id};s==="spot"&&i==="margin"?c.side="in":s==="margin"&&i==="spot"&&(c.side="out"),n=this.omit(n,"symbol");const u=await this.privatePostSpotV1MarginIsolatedTransfer(this.extend(c,n));return this.extend(this.parseTransfer(u,o),{amount:this.parseNumber(d),fromAccount:s,toAccount:i})}parseTransferStatus(e){const t={1e3:"ok",OK:"ok"};return this.safeString(t,e,e)}parseTransfer(e,t=void 0){const s=this.safeValue(e,"data",{});return{id:this.safeString(s,"transfer_id"),timestamp:void 0,datetime:void 0,currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:this.parseTransferStatus(this.safeString2(e,"code","message"))}}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){if(t===void 0)throw new mn(this.id+" fetchBorrowInterest() requires a symbol argument");await this.loadMarkets();const r=this.market(t),a={symbol:r.id};i!==void 0&&(a.N=i),s!==void 0&&(a.start_time=s);const o=await this.privateGetSpotV1MarginIsolatedBorrowRecord(this.extend(a,n)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"records",[]),u=this.parseBorrowInterests(c,r);return this.filterByCurrencySinceLimit(u,e,s,i)}parseBorrowInterest(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeInteger(e,"create_time");return{symbol:this.safeString(t,"symbol"),marginMode:"isolated",currency:this.safeCurrencyCode(this.safeString(e,"currency")),interest:this.safeNumber(e,"interest_amount"),interestRate:this.safeNumber(e,"hourly_interest"),amountBorrowed:this.safeNumber(e,"borrow_amount"),timestamp:i,datetime:this.iso8601(i),info:e}}handleMarginModeAndParams(e,t={},s=void 0){const i=this.safeString(this.options,"defaultType"),n=this.safeValue(t,"margin",!1);let r;if([r,t]=super.handleMarginModeAndParams(e,t,s),r!==void 0){if(r!=="isolated")throw new gn(this.id+" only isolated margin is supported")}else(i==="margin"||n===!0)&&(r="isolated");return[r,t]}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let o=this.implodeHostname(this.urls.api.rest)+"/"+this.implodeParams(e,i);const d=this.omit(i,this.extractParams(e));let c="";const u=s==="GET"||s==="DELETE";if(u&&Object.keys(d).length&&(c=this.urlencode(d),o+="?"+c),t==="private"){this.checkRequiredCredentials();const h=this.milliseconds().toString();n={"X-BM-KEY":this.apiKey,"X-BM-TIMESTAMP":h,"Content-Type":"application/json"},u||(r=this.json(d),c=r);const l=h+"#"+this.uid+"#"+c,p=this.hmac(this.encode(l),this.encode(this.secret));n["X-BM-SIGN"]=p}return{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeStringLower(a,"message"),u=this.safeString(a,"code");if(u!==void 0&&u!=="1000"||c!==void 0&&c!=="ok"){const h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwBroadlyMatchedException(this.exceptions.broad,u,h),this.throwExactlyMatchedException(this.exceptions.exact,c,h),this.throwBroadlyMatchedException(this.exceptions.broad,c,h),new vt(h)}}};const t6=me,{TICK_SIZE:s6}=pe,{AuthenticationError:AS,BadRequest:Pm,DDoSProtection:i6,ExchangeError:Am,ExchangeNotAvailable:BS,InsufficientFunds:n6,InvalidOrder:xo,OrderNotFound:NS,PermissionDenied:Bm,ArgumentsRequired:Nm,BadSymbol:Em}=oe,Rs=ke;var x_=class extends t6{describe(){return this.deepExtend(super.describe(),{id:"bitmex",name:"BitMEX",countries:["SC"],version:"v1",userAgent:void 0,rateLimit:100,pro:!0,has:{CORS:void 0,spot:!1,margin:!1,swap:!0,future:!0,option:!1,addMargin:void 0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createOrder:!0,createReduceOnlyOrder:!0,editOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchDepositAddress:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTransactions:"emulated",fetchTransfer:!1,fetchTransfers:!1,reduceMargin:void 0,setLeverage:!0,setMargin:void 0,setMarginMode:!0,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","1h":"1h","1d":"1d"},urls:{test:{public:"https://testnet.bitmex.com",private:"https://testnet.bitmex.com"},logo:"https://user-images.githubusercontent.com/1294454/27766319-f653c6e6-5ed4-11e7-933d-f0bc3699ae8f.jpg",api:{public:"https://www.bitmex.com",private:"https://www.bitmex.com"},www:"https://www.bitmex.com",doc:["https://www.bitmex.com/app/apiOverview","https://github.com/BitMEX/api-connectors/tree/master/official-http"],fees:"https://www.bitmex.com/app/fees",referral:"https://www.bitmex.com/register/upZpOX"},api:{public:{get:{announcement:5,"announcement/urgent":5,funding:5,instrument:5,"instrument/active":5,"instrument/activeAndIndices":5,"instrument/activeIntervals":5,"instrument/compositeIndex":5,"instrument/indices":5,insurance:5,leaderboard:5,liquidation:5,orderBook:5,"orderBook/L2":5,quote:5,"quote/bucketed":5,schema:5,"schema/websocketHelp":5,settlement:5,stats:5,"stats/history":5,trade:5,"trade/bucketed":5,"wallet/assets":5,"wallet/networks":5}},private:{get:{apiKey:5,chat:5,"chat/channels":5,"chat/connected":5,execution:5,"execution/tradeHistory":5,notification:5,order:5,position:5,user:5,"user/affiliateStatus":5,"user/checkReferralCode":5,"user/commission":5,"user/depositAddress":5,"user/executionHistory":5,"user/margin":5,"user/minWithdrawalFee":5,"user/wallet":5,"user/walletHistory":5,"user/walletSummary":5,"wallet/assets":5,"wallet/networks":5,userEvent:5},post:{apiKey:5,"apiKey/disable":5,"apiKey/enable":5,chat:5,order:1,"order/bulk":5,"order/cancelAllAfter":5,"order/closePosition":5,"position/isolate":1,"position/leverage":1,"position/riskLimit":5,"position/transferMargin":1,"user/cancelWithdrawal":5,"user/confirmEmail":5,"user/confirmEnableTFA":5,"user/confirmWithdrawal":5,"user/disableTFA":5,"user/logout":5,"user/logoutAll":5,"user/preferences":5,"user/requestEnableTFA":5,"user/requestWithdrawal":5},put:{order:1,"order/bulk":5,user:5},delete:{apiKey:5,order:1,"order/all":1}}},exceptions:{exact:{"Invalid API Key.":AS,"This key is disabled.":Bm,"Access Denied":Bm,"Duplicate clOrdID":xo,"orderQty is invalid":xo,"Invalid price":xo,"Invalid stopPx for ordType":xo},broad:{"Signature not valid":AS,overloaded:BS,"Account has insufficient Available Balance":n6,"Service unavailable":BS,"Server Error":Am,"Unable to cancel order due to existing state":xo,"We require all new traders to verify":Bm}},precisionMode:s6,options:{"api-expires":5,fetchOHLCVOpenTimestamp:!0},commonCurrencies:{USDt:"USDT",XBt:"BTC",XBT:"BTC",Gwei:"ETH",GWEI:"ETH"}})}async fetchMarkets(e={}){const t=await this.publicGetInstrumentActiveAndIndices(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"symbol"),a=this.safeString(n,"underlying"),o=this.safeString(n,"quoteCurrency"),d=this.safeString(n,"settlCurrency",""),c=this.safeCurrencyCode(a),u=this.safeCurrencyCode(o),h=this.safeCurrencyCode(d),l=a+o,p=r===l;let m,g=!1,y=!1,b=!1,w=c+"/"+u+":"+h;const S=this.safeString(n,"expiry"),k=this.parse8601(S),T=this.safeValue(n,"isInverse");let _=this.safeString(n,"state")!=="Unlisted";p?m="swap":r.indexOf("B_")>=0?(y=!0,m="prediction",w=r):k!==void 0?(g=!0,m="future",w=w+"-"+this.yymmdd(k)):(b=!0,m="index",w=r,_=!1);const N=this.safeString2(n,"positionCurrency","underlying"),x=this.safeCurrencyCode(N)===u,v=this.safeNumber(n,"maxOrderQty"),O=!b,A=this.safeString(n,"initMargin","1"),V=this.parseNumber(Rs.stringDiv("1",A)),q=Rs.stringAbs(this.safeString(n,"multiplier"));s.push({id:r,symbol:w,base:c,quote:u,settle:h,baseId:a,quoteId:o,settleId:d,type:m,spot:!1,margin:!1,swap:p,future:g,option:!1,prediction:y,index:b,active:_,contract:O,linear:O?!T:void 0,inverse:O?T:void 0,taker:this.safeNumber(n,"takerFee"),maker:this.safeNumber(n,"makerFee"),contractSize:this.parseNumber(q),expiry:k,expiryDatetime:S,strike:this.safeNumber(n,"optionStrikePrice"),optionType:void 0,precision:{amount:this.safeNumber(n,"lotSize"),price:this.safeNumber(n,"tickSize"),quote:this.safeNumber(n,"tickSize"),base:this.safeNumber(n,"tickSize")},limits:{leverage:{min:O?this.parseNumber("1"):void 0,max:O?V:void 0},amount:{min:void 0,max:x?void 0:v},price:{min:void 0,max:this.safeNumber(n,"maxPrice")},cost:{min:void 0,max:x?v:void 0}},info:n})}return s}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();let o=this.safeString(i,"availableMargin"),d=this.safeString(i,"marginBalance");r!=="USDT"?(o=Rs.stringDiv(o,"1e8"),d=Rs.stringDiv(d,"1e8")):(o=Rs.stringDiv(o,"1e6"),d=Rs.stringDiv(d,"1e6")),a.free=o,a.total=d,t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t={currency:"all"},s=await this.privateGetUserMargin(this.extend(t,e));return this.parseBalance(s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={symbol:this.market(e).id};t!==void 0&&(n.depth=t);const r=await this.publicGetOrderBookL2(this.extend(n,s)),a={symbol:e,bids:[],asks:[],timestamp:void 0,datetime:void 0,nonce:void 0};for(let o=0;o<r.length;o++){const d=r[o],c=d.side==="Sell"?"asks":"bids",u=this.safeNumber(d,"size"),h=this.safeNumber(d,"price");h!==void 0&&a[c].push([h,u])}return a.bids=this.sortBy(a.bids,0,!0),a.asks=this.sortBy(a.asks,0),a}async fetchOrder(e,t=void 0,s={}){const i={filter:{orderID:e}},n=await this.fetchOrders(t,void 0,void 0,this.deepExtend(i,s));if(n.length===1)return n[0];throw new NS(this.id+": The order "+e+" not found.")}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),t!==void 0&&(r.startTime=this.iso8601(t)),s!==void 0&&(r.count=s),r=this.deepExtend(r,i),"filter"in r&&(r.filter=this.json(r.filter));const a=await this.privateGetOrder(r);return this.parseOrders(a,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={filter:{open:!0}};return await this.fetchOrders(e,t,s,this.deepExtend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n=await this.fetchOrders(e,t,s,i);return this.filterBy(n,"status","closed")}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),t!==void 0&&(r.startTime=this.iso8601(t)),s!==void 0&&(r.count=s),r=this.deepExtend(r,i),"filter"in r&&(r.filter=this.json(r.filter));const a=await this.privateGetExecutionTradeHistory(r);return this.parseTrades(a,n,t,s)}parseLedgerEntryType(e){const t={Withdrawal:"transaction",RealisedPNL:"margin",UnrealisedPNL:"margin",Deposit:"transaction",Transfer:"transfer",AffiliatePayout:"referral"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"transactID"),i=this.safeString(e,"account"),n=this.safeString(e,"tx"),r=void 0,a=this.parseLedgerEntryType(this.safeString(e,"transactType")),o=this.safeString(e,"currency"),d=this.safeCurrencyCode(o,t);let c=this.safeNumber(e,"amount");c!==void 0&&(c=c/1e8);let u=this.parse8601(this.safeString(e,"transactTime"));u===void 0&&(u=0);let h=this.safeNumber(e,"fee",0);h!==void 0&&(h=h/1e8);const l={cost:h,currency:d};let p=this.safeNumber(e,"walletBalance");p!==void 0&&(p=p/1e8);const m=this.sum(p,-c);let g;c<0?(g="out",c=Math.abs(c)):g="in";const y=this.parseTransactionStatus(this.safeString(e,"transactStatus"));return{id:s,info:e,timestamp:u,datetime:this.iso8601(u),direction:g,account:i,referenceId:n,referenceAccount:r,type:a,currency:d,amount:c,before:m,after:p,status:y,fee:l}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r={};s!==void 0&&(r.count=s);const a=await this.privateGetUserWalletHistory(this.extend(r,i));return this.parseLedger(a,n,t,s)}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={currency:"all"};s!==void 0&&(n.count=s);const r=await this.privateGetUserWalletHistory(this.extend(n,i)),a=this.filterByArray(r,"transactType",["Withdrawal","Deposit"],!1);let o;return e!==void 0&&(o=this.currency(e)),this.parseTransactions(a,o,t,s)}parseTransactionStatus(e){const t={Canceled:"canceled",Completed:"ok",Pending:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"transactID"),i=this.safeString(e,"currency");t=this.safeCurrency(i,t);const n=this.parse8601(this.safeString(e,"transactTime")),r=this.parse8601(this.safeString(e,"timestamp")),a=this.safeStringLower(e,"transactType");let o,d,c;a==="withdrawal"&&(o=this.safeString(e,"address"),d=this.safeString(e,"tx"),c=o);let u=this.safeString(e,"amount");const h=t.code==="BTC"?"1e8":"1e6";u=Rs.stringDiv(Rs.stringAbs(u),h);let l=this.safeString(e,"fee");l=Rs.stringDiv(l,h);const p={cost:this.parseNumber(l),currency:t.code};let m=this.safeString(e,"transactStatus");return m!==void 0&&(m=this.parseTransactionStatus(m)),{info:e,id:s,txid:void 0,timestamp:n,datetime:this.iso8601(n),network:void 0,addressFrom:d,address:o,addressTo:c,tagFrom:void 0,tag:void 0,tagTo:void 0,type:a,amount:this.parseNumber(u),currency:t.code,status:m,updated:r,comment:void 0,fee:p}}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=await this.fetchTickers([s.symbol],t),n=this.safeValue(i,s.symbol);if(n===void 0)throw new Em(this.id+" fetchTicker() symbol "+e+" not found");return n}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetInstrumentActiveAndIndices(t),i={};for(let n=0;n<s.length;n++){const r=this.parseTicker(s[n]),a=this.safeString(r,"symbol");a!==void 0&&(i[a]=r)}return this.filterByArray(i,"symbol",e)}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.parse8601(this.safeString(e,"timestamp")),r=this.safeString(e,"prevPrice24h"),a=this.safeString(e,"lastPrice");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"highPrice"),low:this.safeString(e,"lowPrice"),bid:this.safeString(e,"bidPrice"),bidVolume:void 0,ask:this.safeString(e,"askPrice"),askVolume:void 0,vwap:this.safeString(e,"vwap"),open:r,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"homeNotional24h"),quoteVolume:this.safeString(e,"foreignNotional24h"),info:e},t)}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"timestamp")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,binSize:this.timeframes[t],partial:!0};i!==void 0&&(a.count=i);const o=this.parseTimeframe(t)*1e3,d=this.safeValue(this.options,"fetchOHLCVOpenTimestamp",!0);if(s!==void 0){let h=s;d&&(h=this.sum(h,o));const l=this.ymdhms(h);a.startTime=l}else a.reverse=!0;const c=await this.publicGetTradeBucketed(this.extend(a,n)),u=this.parseOHLCVs(c,r,t,s,i);if(d)for(let h=0;h<u.length;h++)u[h][0]=u[h][0]-o;return u}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"timestamp")),i=this.safeString2(e,"avgPx","price"),n=this.safeString2(e,"size","lastQty"),r=this.safeString(e,"execCost"),a=Rs.stringDiv(Rs.stringAbs(r),"1e8"),o=this.safeString(e,"trdMatchID"),d=this.safeString(e,"orderID"),c=this.safeStringLower(e,"side");let u;const h=Rs.stringDiv(this.safeString(e,"execComm"),"1e8");if(h!==void 0){const b=this.safeString(e,"settlCurrency"),w=this.safeCurrencyCode(b),S=this.safeString(e,"commission");u={cost:h,currency:w,rate:S}}const l=this.safeString(e,"execType");let p;h!==void 0&&l==="Trade"&&(p=Rs.stringLt(h,"0")?"maker":"taker");const m=this.safeString(e,"symbol"),g=this.safeSymbol(m,t),y=this.safeStringLower(e,"ordType");return this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:g,id:o,order:d,type:y,takerOrMaker:p,side:c,price:i,cost:a,amount:n,fee:u},t)}parseOrderStatus(e){const t={New:"open",PartiallyFilled:"open",Filled:"closed",DoneForDay:"open",Canceled:"canceled",PendingCancel:"open",PendingNew:"open",Rejected:"rejected",Expired:"expired",Stopped:"open",Untriggered:"open",Triggered:"open"};return this.safeString(t,e,e)}parseTimeInForce(e){const t={Day:"Day",GoodTillCancel:"GTC",ImmediateOrCancel:"IOC",FillOrKill:"FOK"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString(e,"ordStatus")),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.parse8601(this.safeString(e,"timestamp")),a=this.parse8601(this.safeString(e,"transactTime")),o=this.safeString(e,"price"),d=this.safeString(e,"orderQty"),c=this.safeString(e,"cumQty"),u=this.safeString(e,"avgPx"),h=this.safeString(e,"orderID"),l=this.safeStringLower(e,"ordType"),p=this.safeStringLower(e,"side"),m=this.safeString(e,"clOrdID"),g=this.parseTimeInForce(this.safeString(e,"timeInForce")),y=this.safeNumber(e,"stopPx"),b=this.safeString(e,"execInst");let w;return b!==void 0&&(w=b==="ParticipateDoNotInitiate"),this.safeOrder({info:e,id:h,clientOrderId:m,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:a,symbol:n,type:l,timeInForce:g,postOnly:w,side:p,price:o,stopPrice:y,amount:d,cost:void 0,average:u,filled:c,remaining:void 0,status:s,fee:void 0,trades:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};t!==void 0?r.startTime=this.iso8601(t):r.reverse=!0,s!==void 0&&(r.count=s);const a=await this.publicGetTrade(this.extend(r,i));return this.parseTrades(a,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.capitalize(t),d=this.safeValue(r,"reduceOnly");if(d!==void 0&&a.type!=="swap"&&a.type!=="future")throw new xo(this.id+" createOrder() does not support reduceOnly for "+a.type+" orders, reduceOnly orders are supported for swap and future markets only");const c={symbol:a.id,side:this.capitalize(s),orderQty:parseFloat(this.amountToPrecision(e,i)),ordType:o};if(d&&(c.execInst="ReduceOnly"),o==="Stop"||o==="StopLimit"||o==="MarketIfTouched"||o==="LimitIfTouched"){const l=this.safeNumber2(r,"stopPx","stopPrice");if(l===void 0)throw new Nm(this.id+" createOrder() requires a stopPx or stopPrice parameter for the "+o+" order type");c.stopPx=parseFloat(this.priceToPrecision(e,l)),r=this.omit(r,["stopPx","stopPrice"])}(o==="Limit"||o==="StopLimit"||o==="LimitIfTouched")&&(c.price=parseFloat(this.priceToPrecision(e,n)));const u=this.safeString2(r,"clOrdID","clientOrderId");u!==void 0&&(c.clOrdID=u,r=this.omit(r,["clOrdID","clientOrderId"]));const h=await this.privatePostOrder(this.extend(c,r));return this.parseOrder(h,a)}async editOrder(e,t,s,i,n=void 0,r=void 0,a={}){await this.loadMarkets();const o={},d=this.safeString2(a,"origClOrdID","clientOrderId");if(d!==void 0){o.origClOrdID=d;const u=this.safeString(a,"clOrdID","clientOrderId");u!==void 0&&(o.clOrdID=u),a=this.omit(a,["origClOrdID","clOrdID","clientOrderId"])}else o.orderID=e;n!==void 0&&(o.orderQty=n),r!==void 0&&(o.price=r);const c=await this.privatePutOrder(this.extend(o,a));return this.parseOrder(c)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue2(s,"clOrdID","clientOrderId"),n={};i===void 0?n.orderID=e:(n.clOrdID=i,s=this.omit(s,["clOrdID","clientOrderId"]));const r=await this.privateDeleteOrder(this.extend(n,s)),a=this.safeValue(r,0,{}),o=this.safeString(a,"error");if(o!==void 0&&o.indexOf("Unable to cancel order due to existing state")>=0)throw new NS(this.id+" cancelOrder() failed: "+o);return this.parseOrder(a)}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue2(s,"clOrdID","clientOrderId"),n={};i===void 0?n.orderID=e:(n.clOrdID=i,s=this.omit(s,["clOrdID","clientOrderId"]));const r=await this.privateDeleteOrder(this.extend(n,s));return this.parseOrders(r)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;e!==void 0&&(i=this.market(e),s.symbol=i.id);const n=await this.privateDeleteOrderAll(this.extend(s,t));return this.parseOrders(n,i)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetPosition(t);return this.parsePositions(s,e)}parsePosition(e,t=void 0){t=this.safeMarket(this.safeString(e,"symbol"),t);const s=t.symbol,i=this.safeString(e,"timestamp"),r=this.safeValue(e,"crossMargin")===!0?"cross":"isolated";let a;t.quote==="USDT"||t.quote==="USD"||t.quote==="EUR"?a=Rs.stringMul(this.safeString(e,"foreignNotional"),"-1"):a=this.safeString(e,"homeNotional");const o=this.safeNumber(e,"maintMargin"),d=this.safeNumber(e,"unrealisedPnl"),c=this.omitZero(this.safeNumber(e,"currentQty"));return{info:e,id:this.safeString(e,"account"),symbol:s,timestamp:this.parse8601(i),datetime:i,hedged:void 0,side:void 0,contracts:this.convertValue(c,t),contractSize:void 0,entryPrice:this.safeNumber(e,"avgEntryPrice"),markPrice:this.safeNumber(e,"markPrice"),notional:a,leverage:this.safeNumber(e,"leverage"),collateral:void 0,initialMargin:this.safeNumber(e,"initMargin"),initialMarginPercentage:this.safeNumber(e,"initMarginReq"),maintenanceMargin:this.convertValue(o,t),maintenanceMarginPercentage:this.safeNumber(e,"maintMarginReq"),unrealizedPnl:this.convertValue(d,t),liquidationPrice:this.safeNumber(e,"liquidationPrice"),marginMode:r,marginRatio:void 0,percentage:this.safeNumber(e,"unrealisedPnlPcnt")}}convertValue(e,t=void 0){if(e===void 0||t===void 0)return e;let s;if(e=this.numberToString(e),t.quote==="USD"||t.quote==="EUR")s=Rs.stringMul(e,"0.00000001");else if(t.quote==="USDT")s=Rs.stringMul(e,"0.000001");else{let i;t.quote!==void 0&&(i=this.currency(t.quote)),i!==void 0&&(s=Rs.stringMul(e,this.numberToString(i.precision)))}return s=s!==void 0?parseFloat(s):void 0,s}isFiat(e){return e==="EUR"||e==="PLN"}async withdraw(e,t,s,i=void 0,n={}){if([i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets(),e!=="BTC")throw new Am(this.id+" supoprts BTC withdrawals only, other currencies coming soon...");const r=this.currency(e),a={currency:"XBt",amount:t,address:s},o=await this.privatePostUserRequestWithdrawal(this.extend(a,n));return this.parseTransaction(o,r)}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetInstrumentActiveAndIndices(t),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeMarket(a);this.safeValue(o,"swap",!1)&&i.push(r)}return this.parseFundingRates(i,e)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"timestamp"),i=this.safeString(e,"symbol"),n=this.safeString(e,"fundingTimestamp");return{info:e,symbol:this.safeSymbol(i,t),markPrice:this.safeNumber(e,"markPrice"),indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:this.safeNumber(e,"indicativeSettlePrice"),timestamp:this.parse8601(s),datetime:s,fundingRate:this.safeNumber(e,"fundingRate"),fundingTimestamp:this.iso8601(n),fundingDatetime:n,nextFundingRate:this.safeNumber(e,"indicativeFundingRate"),nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e in this.currencies){const d=this.currency(e);n.symbol=d.id}else if(e!==void 0){const d=e.split(":"),c=d.length,u=["nearest","daily","weekly","monthly","quarterly","biquarterly","perpetual"];c>1&&this.inArray(d[1],u)?(e=this.currency(d[0]).id+":"+d[1],n.symbol=e):(r=this.market(e),n.symbol=r.id)}t!==void 0&&(n.startTime=this.iso8601(t)),s!==void 0&&(n.count=s);const a=this.safeInteger2(i,"until","till");i=this.omit(i,["until","till"]),a!==void 0&&(n.endTime=this.iso8601(a));const o=await this.publicGetFunding(this.extend(n,i));return this.parseFundingRateHistories(o,r,t,s)}parseFundingRateHistory(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeString(e,"timestamp");return{info:e,symbol:this.safeSymbol(s,t),fundingRate:this.safeNumber(e,"fundingRate"),timestamp:this.parse8601(i),datetime:i}}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new Nm(this.id+" setLeverage() requires a symbol argument");if(e<.01||e>100)throw new Pm(this.id+" leverage should be between 0.01 and 100");await this.loadMarkets();const i=this.market(t);if(i.type!=="swap"&&i.type!=="future")throw new Em(this.id+" setLeverage() supports future and swap contracts only");const n={symbol:i.id,leverage:e};return await this.privatePostPositionLeverage(this.extend(n,s))}async setMarginMode(e,t=void 0,s={}){if(t===void 0)throw new Nm(this.id+" setMarginMode() requires a symbol argument");if(e=e.toLowerCase(),e!=="isolated"&&e!=="cross")throw new Pm(this.id+" setMarginMode() marginMode argument should be isolated or cross");await this.loadMarkets();const i=this.market(t);if(i.type!=="swap"&&i.type!=="future")throw new Em(this.id+" setMarginMode() supports swap and future contracts only");const n=e!=="cross",r={symbol:i.id,enabled:n};return await this.privatePostPositionIsolate(this.extend(r,s))}calculateRateLimiterCost(e,t,s,i,n={},r={}){const a=this.checkRequiredCredentials(!1),o=this.safeValue(n,"cost",1);return o!==1?a?o:20:o}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0){if(e===429)throw new i6(this.id+" "+r);if(e>=400){const c=this.safeValue(a,"error",{}),u=this.safeString(c,"message"),h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwBroadlyMatchedException(this.exceptions.broad,u,h),e===400?new Pm(h):new Am(h)}}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/api/"+this.version+"/"+e;if(s==="GET")Object.keys(i).length&&(a+="?"+this.urlencode(i));else{const c=this.safeString(i,"_format");c!==void 0&&(a+="?"+this.urlencode({_format:c}),i=this.omit(i,"_format"))}const o=this.urls.api[t]+a,d=this.checkRequiredCredentials(!1);if(t==="private"||t==="public"&&d){this.checkRequiredCredentials();let c=s+a,u=this.safeInteger(this.options,"api-expires");n={"Content-Type":"application/json","api-key":this.apiKey},u=this.sum(this.seconds(),u),u=u.toString(),c+=u,n["api-expires"]=u,(s==="POST"||s==="PUT"||s==="DELETE")&&Object.keys(i).length&&(r=this.json(i),c+=r),n["api-signature"]=this.hmac(this.encode(c),this.encode(this.secret))}return{url:o,method:s,body:r,headers:n}}};const r6=me,{ExchangeError:ES,ArgumentsRequired:qr,AuthenticationError:a6,InvalidOrder:Vm,InsufficientFunds:o6,BadRequest:_o}=oe,{TICK_SIZE:d6}=pe,c6=ke;var __=class extends r6{describe(){return this.deepExtend(super.describe(),{id:"bitopro",name:"BitoPro",countries:["TW"],version:"v3",rateLimit:100,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createOrder:!0,editOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchOrderTrades:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,setLeverage:!1,setMarginMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","3h":"3h","6h":"6h","12h":"12h","1d":"1d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/158227251-3a92a220-9222-453c-9277-977c6677fe71.jpg",api:{rest:"https://api.bitopro.com/v3"},www:"https://www.bitopro.com",doc:["https://github.com/bitoex/bitopro-offical-api-docs/blob/master/v3-1/rest-1/rest.md"],fees:"https://www.bitopro.com/fees"},requiredCredentials:{apiKey:!0,secret:!0},api:{public:{get:["order-book/{pair}","tickers","tickers/{pair}","trades/{pair}","provisioning/currencies","provisioning/trading-pairs","provisioning/limitations-and-fees","trading-history/{pair}"]},private:{get:["accounts/balance","orders/history","orders/all/{pair}","orders/trades/{pair}","orders/{pair}/{orderId}","wallet/withdraw/{currency}/{serial}","wallet/withdraw/{currency}/id/{id}","wallet/depositHistory/{currency}","wallet/withdrawHistory/{currency}"],post:["orders/{pair}","orders/batch","wallet/withdraw/{currency}"],put:["orders"],delete:["orders/{pair}/{id}","orders/all","orders/{pair}"]}},fees:{trading:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.002"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.002")],[this.parseNumber("3000000"),this.parseNumber("0.00194")],[this.parseNumber("5000000"),this.parseNumber("0.0015")],[this.parseNumber("30000000"),this.parseNumber("0.0014")],[this.parseNumber("300000000"),this.parseNumber("0.0013")],[this.parseNumber("550000000"),this.parseNumber("0.0012")],[this.parseNumber("1300000000"),this.parseNumber("0.0011")]],maker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("3000000"),this.parseNumber("0.00097")],[this.parseNumber("5000000"),this.parseNumber("0.0007")],[this.parseNumber("30000000"),this.parseNumber("0.0006")],[this.parseNumber("300000000"),this.parseNumber("0.0005")],[this.parseNumber("550000000"),this.parseNumber("0.0004")],[this.parseNumber("1300000000"),this.parseNumber("0.0003")]]}}},options:{networks:{ERC20:"ERC20",ETH:"ERC20",TRX:"TRX",TRC20:"TRX"}},precisionMode:d6,exceptions:{exact:{"Unsupported currency.":_o,"Unsupported order type":_o,"Invalid body":_o,"Invalid Signature":a6,"Address not in whitelist.":_o},broad:{"Invalid amount":Vm,"Balance for ":o6,"Invalid ":_o,"Wrong parameter":_o}},commonCurrencies:{}})}async fetchCurrencies(e={}){const t=await this.publicGetProvisioningCurrencies(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.safeValue(r,"deposit"),c=this.safeValue(r,"withdraw"),u=this.safeNumber(r,"withdrawFee"),h=this.safeNumber(r,"minWithdraw"),l=this.safeNumber(r,"maxWithdraw"),p={withdraw:{min:h,max:l},amount:{min:void 0,max:void 0}};i[o]={id:a,code:o,info:r,type:void 0,name:void 0,active:d&&c,deposit:d,withdraw:c,fee:u,precision:void 0,limits:p}}return i}async fetchMarkets(e={}){const t=await this.publicGetProvisioningTradingPairs(),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=!this.safeValue(r,"maintain"),o=this.safeString(r,"pair"),d=o.toUpperCase(),c=this.safeString(r,"base"),u=this.safeString(r,"quote"),h=this.safeCurrencyCode(c),l=this.safeCurrencyCode(u),p=h+"/"+l,m={amount:{min:this.safeNumber(r,"minLimitBaseAmount"),max:this.safeNumber(r,"maxLimitBaseAmount")},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0},leverage:{min:void 0,max:void 0}};i.push({id:o,uppercaseId:d,symbol:p,base:h,quote:l,baseId:h,quoteId:l,settle:void 0,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,derivative:!1,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,limits:m,precision:{price:this.parseNumber(this.parsePrecision(this.safeString(r,"quotePrecision"))),amount:this.parseNumber(this.parsePrecision(this.safeString(r,"basePrecision")))},active:a,info:r})}return i}parseTicker(e,t=void 0){const s=this.safeString(e,"pair");t=this.safeMarket(s,t);const i=this.safeString(t,"symbol");return this.safeTicker({symbol:i,timestamp:void 0,datetime:void 0,high:this.safeString(e,"high24hr"),low:this.safeString(e,"low24hr"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:this.safeString(e,"lastPrice"),last:this.safeString(e,"lastPrice"),previousClose:void 0,change:void 0,percentage:this.safeString(e,"priceChange24hr"),average:void 0,baseVolume:this.safeString(e,"volume24hr"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetTickersPair(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickers(),i=this.safeValue(s,"data",[]);return this.parseTickers(i,e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetOrderBookPair(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"bids","asks","price","amount")}parseTrade(e,t){const s=this.safeString(e,"tradeId"),i=this.safeString(e,"orderId");let n;s===void 0?n=this.safeTimestamp(e,"timestamp"):n=this.safeInteger(e,"timestamp");const r=this.safeString(e,"pair");t=this.safeMarket(r,t);const a=this.safeString(t,"symbol"),o=this.safeString(e,"price"),d=this.safeStringLower(e,"type");let c=this.safeStringLower(e,"action");c===void 0&&(this.safeValue(e,"isBuyer")?c="buy":c="sell");let u=this.safeString(e,"amount");u===void 0&&(u=this.safeString(e,"baseAmount"));let h;const l=this.safeString(e,"fee"),p=this.safeCurrencyCode(this.safeString(e,"feeSymbol"));l!==void 0&&(h={cost:l,currency:p,rate:void 0});const m=this.safeValue(e,"isTaker");let g;return m!==void 0&&(m?g="taker":g="maker"),this.safeTrade({id:s,info:e,order:i,timestamp:n,datetime:this.iso8601(n),symbol:a,takerOrMaker:g,type:d,side:c,price:o,amount:u,cost:void 0,fee:h},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id},a=await this.publicGetTradesPair(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetProvisioningLimitationsAndFees(e),s=this.safeValue(t,"tradingFeeRate",{}),i=this.safeValue(s,0),n={},r=this.safeNumber(i,"makerFee"),a=this.safeNumber(i,"takerFee");for(let o=0;o<this.symbols.length;o++){const d=this.symbols[o];n[d]={info:i,symbol:d,maker:r,taker:a,percentage:!0,tierBased:!0}}return n}parseOHLCV(e,t=void 0,s="1m",i=void 0,n=void 0){return[this.safeInteger(e,"timestamp"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.timeframes[t],o={pair:r.id,resolution:a};i===void 0&&(i=500);const d=this.parseTimeframe(t);let c;if(s===void 0)o.to=this.seconds(),o.from=o.to-i*d;else{const p=d*1e3;c=Math.floor(s/p)*p,o.from=Math.floor(s/1e3),o.to=this.sum(o.from,i*d)}const u=await this.publicGetTradingHistoryPair(this.extend(o,n)),h=this.safeValue(u,"data",[]),l=this.parseOHLCVs(h,r,t,s,i);return this.insertMissingCandles(l,d,c,i)}insertMissingCandles(e,t,s,i){if(e.length===0)return e;const r=[];let a=e[0],o;s===void 0?o=a[0]:o=s;let d=0;const c=e.length;let u=0;for(;u<i&&d<c;){const h=e[d];if(h[0]===o)r.push(h),d=this.sum(d,1);else{const l=this.arrayConcat([],a);l[0]=o,l[1]=l[4],l[2]=l[4],l[3]=l[4],l[5]=this.parseNumber("0"),r.push(l)}o=this.sum(o,t*1e3),u=r.length,a=r[u-1]}return r}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.safeString(i,"amount"),d={free:this.safeString(i,"available"),total:a};t[r]=d}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountsBalance(e),s=this.safeValue(t,"data",[]);return this.parseBalance(s)}parseOrderStatus(e){const t={"-1":"open",0:"open",1:"open",2:"closed",3:"closed",4:"canceled"};return this.safeString(t,e,void 0)}parseOrder(e,t=void 0){const s=this.safeString2(e,"id","orderId"),i=this.safeInteger2(e,"timestamp","createdTimestamp");let n=this.safeString(e,"action");n=n.toLowerCase();const r=this.safeString2(e,"amount","originalAmount"),a=this.safeString(e,"price"),o=this.safeString(e,"pair");t=this.safeMarket(o,t,"_");const d=this.safeString(t,"symbol"),c=this.safeString(e,"status"),u=this.parseOrderStatus(c),h=this.safeStringLower(e,"type"),l=this.safeString(e,"avgExecutionPrice"),p=this.safeString(e,"executedAmount"),m=this.safeString(e,"remainingAmount"),g=this.safeString(e,"timeInForce");let y;const b=this.safeString(e,"fee"),w=this.safeCurrencyCode(this.safeString(e,"feeSymbol"));return c6.stringGt(b,"0")&&(y={currency:w,cost:b}),this.safeOrder({id:s,clientOrderId:void 0,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:this.safeInteger(e,"updatedTimestamp"),symbol:d,type:h,timeInForce:g,postOnly:void 0,side:n,price:a,stopPrice:void 0,amount:r,cost:void 0,average:l,filled:p,remaining:m,status:u,fee:y,trades:void 0,info:e},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={type:t,pair:a.id,action:s,amount:this.amountToPrecision(e,i),timestamp:this.milliseconds()},d=t.toUpperCase();if(d==="LIMIT"&&(o.price=this.priceToPrecision(e,n)),d==="STOP_LIMIT"){o.price=this.priceToPrecision(e,n);const u=this.safeValue2(r,"triggerPrice","stopPrice");if(r=this.omit(r,["triggerPrice","stopPrice"]),u===void 0)throw new Vm(this.id+" createOrder() requires a stopPrice parameter for "+d+" orders");o.stopPrice=this.priceToPrecision(e,u);const h=this.safeString(r,"condition");if(h===void 0)throw new Vm(this.id+" createOrder() requires a condition parameter for "+d+" orders");o.condition=h}const c=await this.privatePostOrdersPair(this.extend(o,r),r);return this.parseOrder(c,a)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new qr(this.id+" cancelOrder() requires the symbol argument");await this.loadMarkets();const i=this.market(t),n={id:e,pair:i.id},r=await this.privateDeleteOrdersPairId(this.extend(n,s));return this.parseOrder(r,i)}async cancelOrders(e,t=void 0,s={}){if(t===void 0)throw new qr(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(t).uppercaseId,r={};return r[n]=e,await this.privatePutOrders(this.extend(r,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i=this.safeString(this.options,"privateDeleteOrdersPair","privateDeleteOrdersAll");if(e!==void 0){const a=this.market(e);s.pair=a.id,i="privateDeleteOrdersPair"}const n=await this[i](this.extend(s,t));return this.safeValue(n,"data",{})}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new qr(this.id+" fetchOrder() requires the symbol argument");await this.loadMarkets();const i=this.market(t),n={orderId:e,pair:i.id},r=await this.privateGetOrdersPairOrderId(this.extend(n,s));return this.parseOrder(r,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new qr(this.id+" fetchOrders() requires the symbol argument");await this.loadMarkets();const n=this.market(e),r={pair:n.id};t!==void 0&&(r.startTimestamp=t),s!==void 0&&(r.limit=s);const a=await this.privateGetOrdersAllPair(this.extend(r,i),i);let o=this.safeValue(a,"data");return o===void 0&&(o=[]),this.parseOrders(o,n,t,s)}fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={statusKind:"OPEN"};return this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={statusKind:"DONE"};return this.fetchOrders(e,t,s,this.extend(n,i))}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new qr(this.id+" fetchMyTrades() requires the symbol argument");await this.loadMarkets();const n=this.market(e),r={pair:n.id},a=await this.privateGetOrdersTradesPair(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}parseTransactionStatus(e){const t={COMPLETE:"ok",INVALID:"failed",PROCESSING:"pending",WAIT_PROCESS:"pending",FAILED:"failed",EXPIRED:"failed",CANCELLED:"failed",EMAIL_VERIFICATION:"pending",WAIT_CONFIRMATION:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"coin"),i=this.safeCurrencyCode(s,t),n=this.safeString(e,"serial"),r=this.safeString(e,"txid"),a=this.safeInteger(e,"timestamp"),o=this.safeNumber(e,"total"),d=this.safeString(e,"address"),c=this.safeString(e,"message"),u=this.safeString(e,"status"),h=this.safeNumber(e,"fee");return{info:e,id:n,txid:r,timestamp:a,datetime:this.iso8601(a),network:void 0,addressFrom:void 0,address:d,addressTo:d,tagFrom:void 0,tag:c,tagTo:c,type:void 0,amount:o,currency:i,status:this.parseTransactionStatus(u),updated:void 0,fee:{currency:i,cost:h,rate:void 0}}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new qr(this.id+" fetchDeposits() requires the code argument");await this.loadMarkets();const n=this.safeCurrency(e),r={currency:n.id};t!==void 0&&(r.startTimestamp=t),s!==void 0&&(r.limit=s);const a=await this.privateGetWalletDepositHistoryCurrency(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new qr(this.id+" fetchWithdrawals() requires the code argument");await this.loadMarkets();const n=this.safeCurrency(e),r={currency:n.id};t!==void 0&&(r.startTimestamp=t),s!==void 0&&(r.limit=s);const a=await this.privateGetWalletWithdrawHistoryCurrency(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s,{type:"withdrawal"})}async fetchWithdrawal(e,t=void 0,s={}){if(t===void 0)throw new qr(this.id+" fetchWithdrawal() requires the code argument");await this.loadMarkets();const i=this.safeCurrency(t),n={serial:e,currency:i.id},r=await this.privateGetWalletWithdrawCurrencySerial(this.extend(n,s)),a=this.safeValue(r,"data",{});return this.parseTransaction(a,i)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets(),this.checkAddress(s);const r=this.currency(e),a={currency:r.id,amount:this.numberToString(t),address:s};if("network"in n){const c=this.safeValue(this.options,"networks",{}),u=this.safeStringUpper(n,"network");n=this.omit(n,["network"]);const h=this.safeString(c,u);if(h===void 0)throw new ES(this.id+" invalid network "+u);a.protocol=h}i!==void 0&&(a.message=i);const o=await this.privatePostWalletWithdrawCurrency(this.extend(a,n)),d=this.safeValue(o,"data",{});return this.parseTransaction(d,r)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(n===void 0&&(n={}),n["X-BITOPRO-API"]="ccxt",t==="private"){if(this.checkRequiredCredentials(),s==="POST"||s==="PUT"){r=this.json(i);const d=this.stringToBase64(r),c=this.hmac(d,this.encode(this.secret),"sha384");n["X-BITOPRO-APIKEY"]=this.apiKey,n["X-BITOPRO-PAYLOAD"]=d,n["X-BITOPRO-SIGNATURE"]=c}else if(s==="GET"||s==="DELETE"){Object.keys(o).length&&(a+="?"+this.urlencode(o));let c={nonce:this.milliseconds()};c=this.json(c);const u=this.stringToBase64(c),h=this.hmac(u,this.encode(this.secret),"sha384");n["X-BITOPRO-APIKEY"]=this.apiKey,n["X-BITOPRO-PAYLOAD"]=u,n["X-BITOPRO-SIGNATURE"]=h}}else t==="public"&&s==="GET"&&Object.keys(o).length&&(a+="?"+this.urlencode(o));return a=this.urls.api.rest+a,{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0||e>=200&&e<300)return;const c=this.id+" "+r,u=this.safeString(a,"error");throw this.throwExactlyMatchedException(this.exceptions.exact,u,c),this.throwBroadlyMatchedException(this.exceptions.broad,u,c),new ES(c)}};const u6=me,{AuthenticationError:gi,ExchangeError:VS,PermissionDenied:qS,BadRequest:bt,ArgumentsRequired:ji,OrderNotFound:qm,InsufficientFunds:LS,ExchangeNotAvailable:Lm,DDoSProtection:RS,InvalidAddress:FS,InvalidOrder:Wi}=oe,{TICK_SIZE:f6}=pe,wf=ke;var h6=class extends u6{describe(){return this.deepExtend(super.describe(),{id:"bitpanda",name:"Bitpanda Pro",countries:["AT"],rateLimit:300,version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createDepositAddress:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchAccounts:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,privateAPI:!0,publicAPI:!0,reduceMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1/MINUTES","5m":"5/MINUTES","15m":"15/MINUTES","30m":"30/MINUTES","1h":"1/HOURS","4h":"4/HOURS","1d":"1/DAYS","1w":"1/WEEKS","1M":"1/MONTHS"},urls:{logo:"https://user-images.githubusercontent.com/51840849/87591171-9a377d80-c6f0-11ea-94ac-97a126eac3bc.jpg",api:{public:"https://api.exchange.bitpanda.com/public",private:"https://api.exchange.bitpanda.com/public"},www:"https://www.bitpanda.com/en/pro",doc:["https://developers.bitpanda.com/exchange/"],fees:"https://www.bitpanda.com/en/pro/fees"},api:{public:{get:["currencies","candlesticks/{instrument_code}","fees","instruments","order-book/{instrument_code}","market-ticker","market-ticker/{instrument_code}","price-ticks/{instrument_code}","time"]},private:{get:["account/balances","account/deposit/crypto/{currency_code}","account/deposit/fiat/EUR","account/deposits","account/deposits/bitpanda","account/withdrawals","account/withdrawals/bitpanda","account/fees","account/orders","account/orders/{order_id}","account/orders/{order_id}/trades","account/trades","account/trades/{trade_id}","account/trading-volume"],post:["account/deposit/crypto","account/withdraw/crypto","account/withdraw/fiat","account/fees","account/orders"],delete:["account/orders","account/orders/{order_id}","account/orders/client/{client_id}"]}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0015"),maker:this.parseNumber("0.001"),tiers:[{taker:[[this.parseNumber("0"),this.parseNumber("0.0015")],[this.parseNumber("100"),this.parseNumber("0.0013")],[this.parseNumber("250"),this.parseNumber("0.0013")],[this.parseNumber("1000"),this.parseNumber("0.001")],[this.parseNumber("5000"),this.parseNumber("0.0009")],[this.parseNumber("10000"),this.parseNumber("0.00075")],[this.parseNumber("20000"),this.parseNumber("0.00065")]],maker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("100"),this.parseNumber("0.001")],[this.parseNumber("250"),this.parseNumber("0.0009")],[this.parseNumber("1000"),this.parseNumber("0.00075")],[this.parseNumber("5000"),this.parseNumber("0.0006")],[this.parseNumber("10000"),this.parseNumber("0.0005")],[this.parseNumber("20000"),this.parseNumber("0.0005")]]}]}},requiredCredentials:{apiKey:!0,secret:!1},precisionMode:f6,exceptions:{exact:{INVALID_CLIENT_UUID:Wi,ORDER_NOT_FOUND:qm,ONLY_ONE_ERC20_ADDRESS_ALLOWED:FS,DEPOSIT_ADDRESS_NOT_USED:FS,INVALID_CREDENTIALS:gi,MISSING_CREDENTIALS:gi,INVALID_APIKEY:gi,INVALID_SCOPES:gi,INVALID_SUBJECT:gi,INVALID_ISSUER:gi,INVALID_AUDIENCE:gi,INVALID_DEVICE_ID:gi,INVALID_IP_RESTRICTION:gi,APIKEY_REVOKED:gi,APIKEY_EXPIRED:gi,SYNCHRONIZER_TOKEN_MISMATCH:gi,SESSION_EXPIRED:gi,INTERNAL_ERROR:gi,CLIENT_IP_BLOCKED:qS,MISSING_PERMISSION:qS,ILLEGAL_CHARS:bt,UNSUPPORTED_MEDIA_TYPE:bt,ACCOUNT_HISTORY_TIME_RANGE_TOO_BIG:bt,CANDLESTICKS_TIME_RANGE_TOO_BIG:bt,INVALID_INSTRUMENT_CODE:bt,INVALID_ORDER_TYPE:bt,INVALID_UNIT:bt,INVALID_PERIOD:bt,INVALID_TIME:bt,INVALID_DATE:bt,INVALID_CURRENCY:bt,INVALID_AMOUNT:bt,INVALID_PRICE:bt,INVALID_LIMIT:bt,INVALID_QUERY:bt,INVALID_CURSOR:bt,INVALID_ACCOUNT_ID:bt,INVALID_SIDE:Wi,INVALID_ACCOUNT_HISTORY_FROM_TIME:bt,INVALID_ACCOUNT_HISTORY_MAX_PAGE_SIZE:bt,INVALID_ACCOUNT_HISTORY_TIME_PERIOD:bt,INVALID_ACCOUNT_HISTORY_TO_TIME:bt,INVALID_CANDLESTICKS_GRANULARITY:bt,INVALID_CANDLESTICKS_UNIT:bt,INVALID_ORDER_BOOK_DEPTH:bt,INVALID_ORDER_BOOK_LEVEL:bt,INVALID_PAGE_CURSOR:bt,INVALID_TIME_RANGE:bt,INVALID_TRADE_ID:bt,INVALID_UI_ACCOUNT_SETTINGS:bt,NEGATIVE_AMOUNT:Wi,NEGATIVE_PRICE:Wi,MIN_SIZE_NOT_SATISFIED:Wi,BAD_AMOUNT_PRECISION:Wi,BAD_PRICE_PRECISION:Wi,BAD_TRIGGER_PRICE_PRECISION:Wi,MAX_OPEN_ORDERS_EXCEEDED:bt,MISSING_PRICE:Wi,MISSING_ORDER_TYPE:Wi,MISSING_SIDE:Wi,MISSING_CANDLESTICKS_PERIOD_PARAM:ji,MISSING_CANDLESTICKS_UNIT_PARAM:ji,MISSING_FROM_PARAM:ji,MISSING_INSTRUMENT_CODE:ji,MISSING_ORDER_ID:Wi,MISSING_TO_PARAM:ji,MISSING_TRADE_ID:ji,INVALID_ORDER_ID:qm,NOT_FOUND:qm,INSUFFICIENT_LIQUIDITY:LS,INSUFFICIENT_FUNDS:LS,NO_TRADING:Lm,SERVICE_UNAVAILABLE:Lm,GATEWAY_TIMEOUT:Lm,RATELIMIT:RS,CF_RATELIMIT:RS,INTERNAL_SERVER_ERROR:VS},broad:{}},commonCurrencies:{MIOTA:"IOTA"},options:{fetchTradingFees:{method:"fetchPrivateTradingFees"},fiat:["EUR","CHF"]}})}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeInteger(t,"epoch_millis")}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"code"),a=this.safeCurrencyCode(r);s[a]={id:r,code:a,name:void 0,info:n,active:void 0,fee:void 0,precision:this.parseNumber(this.parsePrecision(this.safeString(n,"precision"))),limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}}}return s}async fetchMarkets(e={}){const t=await this.publicGetInstruments(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeValue(n,"base",{}),a=this.safeValue(n,"quote",{}),o=this.safeString(r,"code"),d=this.safeString(a,"code"),c=o+"_"+d,u=this.safeCurrencyCode(o),h=this.safeCurrencyCode(d),l=this.safeString(n,"state");s.push({id:c,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:l==="ACTIVE",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(n,"amount_precision"))),price:this.parseNumber(this.parsePrecision(this.safeString(n,"market_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(n,"min_size"),max:void 0}},info:n})}return s}async fetchTradingFees(e={}){let t=this.safeString(e,"method");if(e=this.omit(e,"method"),t===void 0){const s=this.safeValue(this.options,"fetchTradingFees",{});t=this.safeString(s,"method","fetchPrivateTradingFees")}return await this[t](e)}async fetchPublicTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetFees(e),s=this.safeValue(t,0,{}),i=this.safeValue(s,"fee_tiers"),n=this.parseFeeTiers(i),r=this.safeValue(i,0,{}),a={};for(let o=0;o<this.symbols.length;o++){const d=this.symbols[o];a[d]={info:s,symbol:d,maker:this.safeNumber(r,"maker_fee"),taker:this.safeNumber(r,"taker_fee"),percentage:!0,tierBased:!0,tiers:n}}return a}async fetchPrivateTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetAccountFees(e),s=this.safeValue(t,"active_fee_tier",{});let i=this.safeString(s,"maker_fee"),n=this.safeString(s,"taker_fee");i=wf.stringDiv(i,"100"),n=wf.stringDiv(n,"100");const r=this.safeValue(t,"fee_tiers"),a={},o=this.parseFeeTiers(r);for(let d=0;d<this.symbols.length;d++){const c=this.symbols[d];a[c]={info:t,symbol:c,maker:this.parseNumber(i),taker:this.parseNumber(n),percentage:!0,tierBased:!0,tiers:o}}return a}parseFeeTiers(e,t=void 0){const s=[],i=[];for(let n=0;n<e.length;n++){const r=e[n],a=this.safeNumber(r,"volume");let o=this.safeString(r,"taker_fee"),d=this.safeString(r,"maker_fee");d=wf.stringDiv(d,"100"),o=wf.stringDiv(o,"100"),i.push([a,this.parseNumber(d)]),s.push([a,this.parseNumber(o)])}return{maker:i,taker:s}}parseTicker(e,t=void 0){const s=this.parse8601(this.safeString(e,"time")),i=this.safeString(e,"instrument_code"),n=this.safeSymbol(i,t,"_"),r=this.safeString(e,"last_price"),a=this.safeString(e,"price_change_percentage"),o=this.safeString(e,"price_change"),d=this.safeString(e,"base_volume"),c=this.safeString(e,"quote_volume");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"best_bid"),bidVolume:void 0,ask:this.safeString(e,"best_ask"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:o,percentage:a,average:void 0,baseVolume:d,quoteVolume:c,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={instrument_code:s.id},n=await this.publicGetMarketTickerInstrumentCode(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetMarketTicker(t),i={};for(let n=0;n<s.length;n++){const r=this.parseTicker(s[n]),a=r.symbol;i[a]=r}return this.filterByArray(i,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={instrument_code:i.id};t!==void 0&&(n.depth=t);const r=await this.publicGetOrderBookInstrumentCode(this.extend(n,s)),a=this.parse8601(this.safeString(r,"time"));return this.parseOrderBook(r,i.symbol,a,"bids","asks","price","amount")}parseOHLCV(e,t=void 0){const s=this.safeValue(e,"granularity"),i=this.safeString(s,"unit"),n=this.safeString(s,"period"),r={MINUTES:"m",HOURS:"h",DAYS:"d",WEEKS:"w",MONTHS:"M"},a=this.safeString(r,i),o=n+a,c=this.parseTimeframe(o)*1e3,u=this.parse8601(this.safeString(e,"time")),h=c*parseInt(u/c),l=this.safeValue(this.options,"fetchOHLCV",{}),p=this.safeString(l,"volume","total_amount");return[h,this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,p)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.safeString(this.timeframes,t),[o,d]=a.split("/"),u=this.parseTimeframe(t)*1e3;i===void 0&&(i=1500);const h={instrument_code:r.id,period:o,unit:d};if(s===void 0){const p=this.milliseconds();h.to=this.iso8601(p),h.from=this.iso8601(p-i*u)}else h.from=this.iso8601(s),h.to=this.iso8601(this.sum(s,i*u));const l=await this.publicGetCandlesticksInstrumentCode(this.extend(h,n));return this.parseOHLCVs(l,r,t,s,i)}parseTrade(e,t=void 0){const s=this.safeValue(e,"fee",{});e=this.safeValue(e,"trade",e);let i=this.safeInteger(e,"trade_timestamp");i===void 0&&(i=this.parse8601(this.safeString(e,"time")));const n=this.safeStringLower2(e,"side","taker_side"),r=this.safeString(e,"price"),a=this.safeString(e,"amount"),o=this.safeString(e,"volume"),d=this.safeString(e,"instrument_code"),c=this.safeSymbol(d,t,"_"),u=this.safeString(s,"fee_amount");let h,l;if(u!==void 0){const p=this.safeString(s,"fee_currency"),m=this.safeCurrencyCode(p),g=this.safeString(s,"fee_percentage");l={cost:u,currency:m,rate:g},h=this.safeStringLower(s,"fee_type")}return this.safeTrade({id:this.safeString2(e,"trade_id","sequence"),order:this.safeString(e,"order_id"),timestamp:i,datetime:this.iso8601(i),symbol:c,type:void 0,side:n,price:r,amount:a,cost:o,takerOrMaker:h,fee:l,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={instrument_code:n.id};t!==void 0&&(r.from=this.iso8601(t),r.to=this.iso8601(this.sum(t,144e5)));const a=await this.publicGetPriceTicksInstrumentCode(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseBalance(e){const t=this.safeValue(e,"balances",[]),s={info:e};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency_code"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(n,"available"),o.used=this.safeString(n,"locked"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountBalances(e);return this.parseBalance(t)}parseDepositAddress(e,t=void 0){let s;t!==void 0&&(s=t.code);const i=this.safeString(e,"address"),n=this.safeString(e,"destination_tag");return this.checkAddress(i),{currency:s,address:i,tag:n,network:void 0,info:e}}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=await this.privatePostAccountDepositCrypto(this.extend(i,t));return this.parseDepositAddress(n,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency_code:s.id},n=await this.privateGetAccountDepositCryptoCurrencyCode(this.extend(i,t));return this.parseDepositAddress(n,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.currency(e),n.currency_code=r.id),s!==void 0&&(n.max_page_size=s),t!==void 0){if(this.safeString(i,"to")===void 0)throw new ji(this.id+' fetchDeposits() requires a "to" iso8601 string param with the since argument is specified');n.from=this.iso8601(t)}const a=await this.privateGetAccountDeposits(this.extend(n,i)),o=this.safeValue(a,"deposit_history",[]);return this.parseTransactions(o,r,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.currency(e),n.currency_code=r.id),s!==void 0&&(n.max_page_size=s),t!==void 0){if(this.safeString(i,"to")===void 0)throw new ji(this.id+' fetchWithdrawals() requires a "to" iso8601 string param with the since argument is specified');n.from=this.iso8601(t)}const a=await this.privateGetAccountWithdrawals(this.extend(n,i)),o=this.safeValue(a,"withdrawal_history",[]);return this.parseTransactions(o,r,t,s,{type:"withdrawal"})}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency:e,amount:this.currencyToPrecision(e,t)},o=this.safeValue(this.options,"fiat",[]),d=this.inArray(e,o),c=d?"privatePostAccountWithdrawFiat":"privatePostAccountWithdrawCrypto";if(d){if(this.safeString(n,"payout_account_id")===void 0)throw new ji(this.id+" withdraw() requires a payout_account_id param for fiat "+e+" withdrawals")}else{const h={address:s};i!==void 0&&(h.destination_tag=i),a.recipient=h}const u=await this[c](this.extend(a,n));return this.parseTransaction(u,r)}parseTransaction(e,t=void 0){const s=this.safeString(e,"transaction_id"),i=this.safeNumber(e,"amount"),n=this.parse8601(this.safeString(e,"time")),r=this.safeString(e,"currency");t=this.safeCurrency(r,t);const a="ok",o=this.safeNumber2(e,"fee_amount","fee");let d;const c=this.safeString(e,"recipient"),u=this.safeString(e,"destination_tag");if(o!==void 0){const h=this.safeString(e,"fee_currency",r),l=this.safeCurrencyCode(h);d={cost:o,currency:l}}return{info:e,id:s,currency:t.code,amount:i,network:void 0,address:c,addressFrom:void 0,addressTo:c,tag:u,tagFrom:void 0,tagTo:u,status:a,type:void 0,updated:void 0,txid:this.safeString(e,"blockchain_transaction_id"),timestamp:n,datetime:this.iso8601(n),fee:d}}parseOrderStatus(e){const t={FILLED:"open",FILLED_FULLY:"closed",FILLED_CLOSED:"canceled",FILLED_REJECTED:"rejected",OPEN:"open",REJECTED:"rejected",CLOSED:"canceled",FAILED:"failed",STOP_TRIGGERED:"triggered"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeValue(e,"order",e),i=this.safeString(s,"order_id"),n=this.safeString(s,"client_id"),r=this.parse8601(this.safeString(s,"time")),a=this.parseOrderStatus(this.safeString(s,"status")),o=this.parseOrderStatus(a),d=this.safeString(s,"instrument_code"),c=this.safeSymbol(d,t,"_"),u=this.safeString(s,"price"),h=this.safeString(s,"amount"),l=this.safeString(s,"filled_amount"),p=this.safeStringLower(s,"side"),m=this.safeStringLower(s,"type"),g=this.parseTimeInForce(this.safeString(s,"time_in_force")),y=this.safeNumber(s,"trigger_price"),b=this.safeValue(s,"is_post_only"),w=this.safeValue(e,"trades",[]);return this.safeOrder({id:i,clientOrderId:n,info:e,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,symbol:c,type:m,timeInForce:g,postOnly:b,side:p,price:u,stopPrice:y,amount:h,cost:void 0,average:void 0,filled:l,remaining:void 0,status:o,trades:w},t)}parseTimeInForce(e){const t={GOOD_TILL_CANCELLED:"GTC",GOOD_TILL_TIME:"GTT",IMMEDIATE_OR_CANCELLED:"IOC",FILL_OR_KILL:"FOK"};return this.safeString(t,e,e)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=t.toUpperCase(),d={instrument_code:a.id,type:o,side:s.toUpperCase(),amount:this.amountToPrecision(e,i)};let c=!1;if((o==="LIMIT"||o==="STOP")&&(c=!0),o==="STOP"){const l=this.safeNumber(r,"trigger_price");if(l===void 0)throw new ji(this.id+" createOrder() requires a trigger_price param for "+t+" orders");d.trigger_price=this.priceToPrecision(e,l),r=this.omit(r,"trigger_price")}c&&(d.price=this.priceToPrecision(e,n));const u=this.safeString2(r,"clientOrderId","client_id");u!==void 0&&(d.client_id=u,r=this.omit(r,["clientOrderId","client_id"]));const h=await this.privatePostAccountOrders(this.extend(d,r));return this.parseOrder(h,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeString2(s,"clientOrderId","client_id");s=this.omit(s,["clientOrderId","client_id"]);let n="privateDeleteAccountOrdersOrderId";const r={};return i!==void 0?(n="privateDeleteAccountOrdersClientClientId",r.client_id=i):r.order_id=e,await this[n](this.extend(r,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};if(e!==void 0){const n=this.market(e);s.instrument_code=n.id}return await this.privateDeleteAccountOrders(this.extend(s,t))}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i={ids:e.join(",")};return await this.privateDeleteAccountOrders(this.extend(i,s))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privateGetAccountOrdersOrderId(this.extend(i,s));return this.parseOrder(n)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.market(e),n.instrument_code=r.id),t!==void 0){if(this.safeString(i,"to")===void 0)throw new ji(this.id+' fetchOpenOrders() requires a "to" iso8601 string param with the since argument is specified, max range is 100 days');n.from=this.iso8601(t)}s!==void 0&&(n.max_page_size=s);const a=await this.privateGetAccountOrders(this.extend(n,i)),o=this.safeValue(a,"order_history",[]);return this.parseOrders(o,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={with_cancelled_and_rejected:!0};return await this.fetchOpenOrders(e,t,s,this.extend(n,i))}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={order_id:e};i!==void 0&&(r.max_page_size=i);const a=await this.privateGetAccountOrdersOrderIdTrades(this.extend(r,n)),o=this.safeValue(a,"trade_history",[]);let d;return t!==void 0&&(d=this.market(t)),this.parseTrades(o,d,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.market(e),n.instrument_code=r.id),t!==void 0){if(this.safeString(i,"to")===void 0)throw new ji(this.id+' fetchMyTrades() requires a "to" iso8601 string param with the since argument is specified, max range is 100 days');n.from=this.iso8601(t)}s!==void 0&&(n.max_page_size=s);const a=await this.privateGetAccountTrades(this.extend(n,i)),o=this.safeValue(a,"trade_history",[]);return this.parseTrades(o,r,t,s)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));return t==="public"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):t==="private"&&(this.checkRequiredCredentials(),n={Accept:"application/json",Authorization:"Bearer "+this.apiKey},s==="POST"?(r=this.json(o),n["Content-Type"]="application/json"):Object.keys(o).length&&(a+="?"+this.urlencode(o))),{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"error");if(c!==void 0){const u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u),new VS(u)}}};const l6=me,{ExchangeError:Ma,ArgumentsRequired:Lr,ExchangeNotAvailable:nc,InsufficientFunds:qn,OrderNotFound:DS,InvalidOrder:Rr,DDoSProtection:Rm,InvalidNonce:p6,AuthenticationError:Pa,RateLimitExceeded:HS,PermissionDenied:Fm,BadRequest:cs,BadSymbol:m6,AccountSuspended:g6,OrderImmediatelyFillable:Dm,OnMaintenance:y6}=oe,{TRUNCATE:GS,TICK_SIZE:b6}=pe,US=ke;var w6=class extends l6{describe(){return this.deepExtend(super.describe(),{id:"bitrue",name:"Bitrue",countries:["SG"],rateLimit:1e3,certified:!1,version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:void 0,future:void 0,option:!1,cancelAllOrders:!1,cancelOrder:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!1,fetchDeposits:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchPositionMode:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfers:!1,fetchWithdrawals:!0,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1H","2h":"2H","4h":"4H","1d":"1D","1w":"1W"},urls:{logo:"https://user-images.githubusercontent.com/1294454/139516488-243a830d-05dd-446b-91c6-c1f18fe30c63.jpg",api:{v1:"https://www.bitrue.com/api/v1",v2:"https://www.bitrue.com/api/v2",kline:"https://www.bitrue.com/kline-api"},www:"https://www.bitrue.com",referral:"https://www.bitrue.com/activity/task/task-landing?inviteCode=EZWETQE&cn=900000",doc:["https://github.com/Bitrue-exchange/bitrue-official-api-docs"],fees:"https://bitrue.zendesk.com/hc/en-001/articles/4405479952537"},api:{kline:{public:{get:{"public.json":1,"public{currency}.json":1}}},v1:{public:{get:{ping:1,time:1,exchangeInfo:1,depth:{cost:1,byLimit:[[100,1],[500,5],[1e3,10]]},trades:1,historicalTrades:5,aggTrades:1,"ticker/24hr":{cost:1,noSymbol:40},"ticker/price":{cost:1,noSymbol:2},"ticker/bookTicker":{cost:1,noSymbol:2},"market/kline":1}},private:{get:{order:1,openOrders:1,allOrders:5,account:5,myTrades:{cost:5,noSymbol:40},"etf/net-value/{symbol}":1,"withdraw/history":1,"deposit/history":1},post:{order:4,"withdraw/commit":1},delete:{order:1}}},v2:{private:{get:{myTrades:5}}}},fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,taker:this.parseNumber("0.00098"),maker:this.parseNumber("0.00098")},future:{trading:{feeSide:"quote",tierBased:!0,percentage:!0,taker:this.parseNumber("0.000400"),maker:this.parseNumber("0.000200"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.000400")],[this.parseNumber("250"),this.parseNumber("0.000400")],[this.parseNumber("2500"),this.parseNumber("0.000350")],[this.parseNumber("7500"),this.parseNumber("0.000320")],[this.parseNumber("22500"),this.parseNumber("0.000300")],[this.parseNumber("50000"),this.parseNumber("0.000270")],[this.parseNumber("100000"),this.parseNumber("0.000250")],[this.parseNumber("200000"),this.parseNumber("0.000220")],[this.parseNumber("400000"),this.parseNumber("0.000200")],[this.parseNumber("750000"),this.parseNumber("0.000170")]],maker:[[this.parseNumber("0"),this.parseNumber("0.000200")],[this.parseNumber("250"),this.parseNumber("0.000160")],[this.parseNumber("2500"),this.parseNumber("0.000140")],[this.parseNumber("7500"),this.parseNumber("0.000120")],[this.parseNumber("22500"),this.parseNumber("0.000100")],[this.parseNumber("50000"),this.parseNumber("0.000080")],[this.parseNumber("100000"),this.parseNumber("0.000060")],[this.parseNumber("200000"),this.parseNumber("0.000040")],[this.parseNumber("400000"),this.parseNumber("0.000020")],[this.parseNumber("750000"),this.parseNumber("0")]]}}},delivery:{trading:{feeSide:"base",tierBased:!0,percentage:!0,taker:this.parseNumber("0.000500"),maker:this.parseNumber("0.000100"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.000500")],[this.parseNumber("250"),this.parseNumber("0.000450")],[this.parseNumber("2500"),this.parseNumber("0.000400")],[this.parseNumber("7500"),this.parseNumber("0.000300")],[this.parseNumber("22500"),this.parseNumber("0.000250")],[this.parseNumber("50000"),this.parseNumber("0.000240")],[this.parseNumber("100000"),this.parseNumber("0.000240")],[this.parseNumber("200000"),this.parseNumber("0.000240")],[this.parseNumber("400000"),this.parseNumber("0.000240")],[this.parseNumber("750000"),this.parseNumber("0.000240")]],maker:[[this.parseNumber("0"),this.parseNumber("0.000100")],[this.parseNumber("250"),this.parseNumber("0.000080")],[this.parseNumber("2500"),this.parseNumber("0.000050")],[this.parseNumber("7500"),this.parseNumber("0.0000030")],[this.parseNumber("22500"),this.parseNumber("0")],[this.parseNumber("50000"),this.parseNumber("-0.000050")],[this.parseNumber("100000"),this.parseNumber("-0.000060")],[this.parseNumber("200000"),this.parseNumber("-0.000070")],[this.parseNumber("400000"),this.parseNumber("-0.000080")],[this.parseNumber("750000"),this.parseNumber("-0.000090")]]}}}},options:{fetchMyTradesMethod:"v2PrivateGetMyTrades",hasAlreadyAuthenticatedSuccessfully:!1,recvWindow:5*1e3,timeDifference:0,adjustForTimeDifference:!1,parseOrderToPrecision:!1,newOrderRespType:{market:"FULL",limit:"FULL"},networks:{ERC20:"ETH",TRC20:"TRX",TRON:"TRX"}},commonCurrencies:{MIM:"MIM Swarm"},precisionMode:b6,exceptions:{exact:{"System is under maintenance.":y6,"System abnormality":Ma,"You are not authorized to execute this request.":Fm,"API key does not exist":Pa,"Order would trigger immediately.":Dm,"Stop price would trigger immediately.":Dm,"Order would immediately match and take.":Dm,"Account has insufficient balance for requested action.":qn,"Rest API trading is not enabled.":nc,"You don't have permission.":Fm,"Market is closed.":nc,"Too many requests. Please try again later.":Rm,"-1000":nc,"-1001":nc,"-1002":Pa,"-1003":HS,"-1013":Rr,"-1015":HS,"-1016":nc,"-1020":cs,"-1021":p6,"-1022":Pa,"-1100":cs,"-1101":cs,"-1102":cs,"-1103":cs,"-1104":cs,"-1105":cs,"-1106":cs,"-1111":cs,"-1112":Rr,"-1114":cs,"-1115":cs,"-1116":cs,"-1117":cs,"-1118":cs,"-1119":cs,"-1120":cs,"-1121":m6,"-1125":Pa,"-1127":cs,"-1128":cs,"-1130":cs,"-1131":cs,"-2008":Pa,"-2010":Ma,"-2011":DS,"-2013":DS,"-2014":Pa,"-2015":Pa,"-2019":qn,"-3005":qn,"-3006":qn,"-3008":qn,"-3010":Ma,"-3015":Ma,"-3022":g6,"-4028":cs,"-3020":qn,"-3041":qn,"-5013":qn,"-11008":qn,"-4051":qn},broad:{"has no operation privilege":Fm,MAX_POSITION:Rr}}})}costToPrecision(e,t){return this.decimalToPrecision(t,GS,this.markets[e].precision.quote,this.precisionMode,this.paddingMode)}currencyToPrecision(e,t,s=void 0){return this.safeValue(this.currencies[e],"precision")!==void 0?this.decimalToPrecision(t,GS,this.currencies[e].precision,this.precisionMode,this.paddingMode):this.numberToString(t)}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchStatus(e={}){const t=await this.v1PublicGetPing(e);return{status:Object.keys(t).length?"maintenance":"ok",updated:void 0,eta:void 0,url:void 0,info:t}}async fetchTime(e={}){const t=await this.v1PublicGetTime(e);return this.safeInteger(t,"serverTime")}safeNetwork(e){const t=e.toUpperCase(),s={Aeternity:"Aeternity",AION:"AION",Algorand:"Algorand",ASK:"ASK",ATOM:"ATOM","AVAX C-Chain":"AVAX C-Chain",bch:"bch",BCH:"BCH",BEP2:"BEP2",BEP20:"BEP20",Bitcoin:"Bitcoin",BRP20:"BRP20",Cardano:"ADA",CasinoCoin:"CasinoCoin","CasinoCoin XRPL":"CasinoCoin XRPL",Contentos:"Contentos",Dash:"Dash",Decoin:"Decoin",DeFiChain:"DeFiChain",DGB:"DGB",Divi:"Divi",dogecoin:"DOGE",EOS:"EOS",ERC20:"ERC20",ETC:"ETC",Filecoin:"Filecoin",FREETON:"FREETON",HBAR:"HBAR","Hedera Hashgraph":"Hedera Hashgraph",HRC20:"HRC20",ICON:"ICON",ICP:"ICP",Ignis:"Ignis","Internet Computer":"Internet Computer",IOTA:"IOTA",KAVA:"KAVA",KSM:"KSM",LiteCoin:"LiteCoin",Luna:"Luna",MATIC:"MATIC","Mobile Coin":"Mobile Coin",MonaCoin:"MonaCoin",Monero:"Monero",NEM:"NEM",NEP5:"NEP5",OMNI:"OMNI",PAC:"PAC",Polkadot:"Polkadot",Ravencoin:"Ravencoin",Safex:"Safex",SOLANA:"SOL",Songbird:"Songbird","Stellar Lumens":"Stellar Lumens",Symbol:"Symbol",Tezos:"XTZ",theta:"theta",THETA:"THETA",TRC20:"TRC20",VeChain:"VeChain",VECHAIN:"VECHAIN",Wanchain:"Wanchain","XinFin Network":"XinFin Network",XRP:"XRP",XRPL:"XRPL",ZIL:"ZIL"};return this.safeString2(s,e,t,e)}async fetchCurrencies(e={}){const t=await this.v1PublicGetExchangeInfo(e),s={},i=this.safeValue(t,"coins",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"coin"),o=this.safeString(r,"coinFulName"),d=this.safeCurrencyCode(a),c=this.safeValue(r,"enableDeposit"),u=this.safeValue(r,"enableWithdraw"),h=this.safeValue(r,"chains",[]),l={};for(let m=0;m<h.length;m++){const g=h[m],y=this.safeNetwork(g);l[y]={info:g,id:g,network:y,active:void 0,fee:void 0,precision:void 0,limits:{withdraw:{min:void 0,max:void 0}}}}const p=u&&c;s[d]={id:a,name:o,code:d,precision:void 0,info:r,active:p,deposit:c,withdraw:u,networks:l,fee:this.safeNumber(r,"withdrawFee"),limits:{withdraw:{min:this.safeNumber(r,"minWithdraw"),max:this.safeNumber(r,"maxWithdraw")}}}}return s}async fetchMarkets(e={}){const t=await this.v1PublicGetExchangeInfo(e);this.options.adjustForTimeDifference&&await this.loadTimeDifference();const s=this.safeValue(t,"symbols",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeStringLower(r,"symbol"),d=this.safeString(r,"baseAsset"),c=this.safeString(r,"quoteAsset"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),l=this.safeValue(r,"filters",[]),p=this.indexBy(l,"filterType"),m=this.safeString(r,"status"),g=this.safeValue(p,"PRICE_FILTER",{}),y=this.safeValue(p,"LOT_SIZE",{}),b=this.safeString(r,"pricePrecision"),w=this.safeString(r,"quantityPrecision"),S=this.safeString(g,"priceScale",b),k=this.safeString(y,"volumeScale",w),T={id:a,lowercaseId:o,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:m==="TRADING",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(k)),price:this.parseNumber(this.parsePrecision(S)),base:this.parseNumber(this.parsePrecision(this.safeString(r,"baseAssetPrecision"))),quote:this.parseNumber(this.parsePrecision(this.safeString(r,"quotePrecision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(y,"minQty"),max:this.safeNumber(y,"maxQty")},price:{min:this.safeNumber(g,"minPrice"),max:this.safeNumber(g,"maxPrice")},cost:{min:this.safeNumber(y,"minVal"),max:void 0}},info:r};i.push(T)}return i}parseBalance(e){const t={info:e},s=this.safeInteger(e,"updateTime"),i=this.safeValue(e,"balances",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"asset"),o=this.safeCurrencyCode(a),d=this.account();d.free=this.safeString(r,"free"),d.used=this.safeString(r,"locked"),t[o]=d}return t.timestamp=s,t.datetime=this.iso8601(s),this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.v1PrivateGetAccount(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={symbol:this.market(e).id};t!==void 0&&(n.limit=t);const r=await this.v1PublicGetDepth(this.extend(n,s)),a=this.parseOrderBook(r,e);return a.nonce=this.safeInteger(r,"lastUpdateId"),a}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:void 0,datetime:void 0,high:this.safeString(e,"high24hr"),low:this.safeString(e,"low24hr"),bid:this.safeString(e,"highestBid"),bidVolume:void 0,ask:this.safeString(e,"lowestAsk"),askVolume:void 0,vwap:void 0,open:void 0,close:i,last:i,previousClose:void 0,change:void 0,percentage:this.safeString(e,"percentChange"),average:void 0,baseVolume:this.safeString(e,"baseVolume"),quoteVolume:this.safeString(e,"quoteVolume"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=this.safeStringUpper(s,"baseId"),n=this.safeStringUpper(s,"quoteId"),r={currency:n,command:"returnTicker"},a=await this.klinePublicGetPublicCurrencyJson(this.extend(r,t)),o=this.safeValue(a,"data",{}),d=i+"_"+n,c=this.safeValue(o,d);if(c===void 0)throw new Ma(this.id+" fetchTicker() could not find the ticker for "+s.symbol);return this.parseTicker(c,s)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,scale:this.timeframes[t]};i!==void 0&&(a.limit=i);const o=await this.v1PublicGetMarketKline(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseOHLCVs(d,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"i"),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}async fetchBidsAsks(e=void 0,t={}){await this.loadMarkets();const s=this.safeString2(this.options,"fetchBidsAsks","defaultType","spot"),i=this.safeString(t,"type",s),n=this.omit(t,"type");let r;i==="future"?r="fapiPublicGetTickerBookTicker":i==="delivery"?r="dapiPublicGetTickerBookTicker":r="publicGetTickerBookTicker";const a=await this[r](n);return this.parseTickers(a,e)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={command:"returnTicker"},i=await this.klinePublicGetPublicJson(this.extend(s,t)),n=this.safeValue(i,"data",{}),r={},a=Object.keys(n);for(let o=0;o<a.length;o++){const d=a[o].replace("_","");r[d]=n[a[o]]}return this.parseTickers(r,e)}parseTrade(e,t=void 0){const s=this.safeInteger2(e,"T","time"),i=this.safeString2(e,"p","price"),n=this.safeString2(e,"q","qty"),r=this.safeString(e,"symbol"),a=this.safeSymbol(r,t);let o=this.safeString2(e,"t","a");o=this.safeString2(e,"id","tradeId",o);let d;const c=this.safeString(e,"orderId");"m"in e?d=e.m?"sell":"buy":"isBuyerMaker"in e?d=e.isBuyerMaker?"sell":"buy":"side"in e?d=this.safeStringLower(e,"side"):"isBuyer"in e&&(d=e.isBuyer?"buy":"sell");let u;"commission"in e&&(u={cost:this.safeString(e,"commission"),currency:this.safeCurrencyCode(this.safeString(e,"commissionAssert"))});let h;return"isMaker"in e&&(h=e.isMaker?"maker":"taker"),"maker"in e&&(h=e.maker?"maker":"taker"),this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:a,id:o,order:c,type:void 0,side:d,takerOrMaker:h,price:i,amount:n,cost:void 0,fee:u},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=this.safeString(this.options,"fetchTradesMethod","v1PublicGetAggTrades");s!==void 0&&(r.limit=s);const o=await this[a](this.extend(r,i));return this.parseTrades(o,n,t,s)}parseOrderStatus(e){const t={NEW:"open",PARTIALLY_FILLED:"open",FILLED:"closed",CANCELED:"canceled",PENDING_CANCEL:"canceling",REJECTED:"rejected",EXPIRED:"expired"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString(e,"status")),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.safeString(e,"executedQty");let a,o;"time"in e?a=this.safeInteger(e,"time"):"transactTime"in e?a=this.safeInteger(e,"transactTime"):"updateTime"in e&&s==="open"&&(US.stringGt(r,"0")?o=this.safeInteger(e,"updateTime"):a=this.safeInteger(e,"updateTime"));const d=this.safeString(e,"avgPrice"),c=this.safeString(e,"price"),u=this.safeString(e,"origQty"),h=this.safeString2(e,"cummulativeQuoteQty","cumQuote"),l=this.safeString(e,"orderId");let p=this.safeStringLower(e,"type");const m=this.safeStringLower(e,"side"),g=this.safeValue(e,"fills",[]),y=this.safeString(e,"clientOrderId"),b=this.safeString(e,"timeInForce"),w=p==="limit_maker"||b==="GTX";p==="limit_maker"&&(p="limit");const S=this.safeString(e,"stopPrice"),k=this.parseNumber(this.omitZero(S));return this.safeOrder({info:e,id:l,clientOrderId:y,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:o,symbol:n,type:p,timeInForce:b,postOnly:w,side:m,price:c,stopPrice:k,amount:u,cost:h,average:d,filled:r,remaining:void 0,status:s,fee:void 0,trades:g},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=t.toUpperCase(),d=this.safeValue(a.info,"orderTypes");if(!this.inArray(o,d))throw new Rr(this.id+" "+t+" is not a valid order type in market "+e);const c={symbol:a.id,side:s.toUpperCase(),type:o,quantity:this.amountToPrecision(e,i)},u=this.safeString2(r,"newClientOrderId","clientOrderId");if(u!==void 0&&(r=this.omit(r,["newClientOrderId","clientOrderId"]),c.newClientOrderId=u),o==="LIMIT"){if(n===void 0)throw new Rr(this.id+" createOrder() requires a price argument");c.price=this.priceToPrecision(e,n)}const h=this.safeValue2(r,"triggerPrice","stopPrice");h!==void 0&&(r=this.omit(r,["triggerPrice","stopPrice"]),c.stopPrice=this.priceToPrecision(e,h));const l=await this.v1PrivatePostOrder(this.extend(c,r));return this.parseOrder(l,a)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Lr(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={symbol:i.id},r=this.safeValue2(s,"origClientOrderId","clientOrderId");r!==void 0?n.origClientOrderId=r:n.orderId=e;const a=this.omit(s,["type","clientOrderId","origClientOrderId"]),o=await this.v1PrivateGetOrder(this.extend(n,a));return this.parseOrder(o,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Lr(this.id+" fetchClosedOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=s);const a=await this.v1PrivateGetAllOrders(this.extend(r,i));return this.parseOrders(a,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Lr(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.v1PrivateGetOpenOrders(this.extend(r,i));return this.parseOrders(a,n,t,s)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Lr(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=this.safeValue2(s,"origClientOrderId","clientOrderId"),r={symbol:i.id};n===void 0?r.orderId=e:r.origClientOrderId=n;const a=this.omit(s,["type","origClientOrderId","clientOrderId"]),o=await this.v1PrivateDeleteOrder(this.extend(r,a));return this.parseOrder(o,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeString(this.options,"fetchMyTradesMethod","v2PrivateGetMyTrades");if(e===void 0&&n==="v2PrivateGetMyTrades")throw new Lr(this.id+" v2PrivateGetMyTrades() requires a symbol argument");await this.loadMarkets();const r={};let a;e!==void 0&&(a=this.market(e),r.symbol=a.id),t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=s);const o=await this[n](this.extend(r,i));return this.parseTrades(o,a,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Lr(this.id+" fetchDeposits() requires a code argument");await this.loadMarkets();const n=this.currency(e),r={coin:n.id,status:1};t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=s);const a=await this.v1PrivateGetDepositHistory(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Lr(this.id+" fetchWithdrawals() requires a code argument");await this.loadMarkets();const n=this.currency(e),r={coin:n.id,status:5};t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=s);const a=await this.v1PrivateGetWithdrawHistory(this.extend(r,i)),o=this.safeValue(a,"data",{});return this.parseTransactions(o,n)}parseTransactionStatusByType(e,t=void 0){const s={deposit:{0:"pending",1:"ok"},withdrawal:{0:"pending",5:"ok",6:"canceled"}},i=this.safeValue(s,t,{});return this.safeString(i,e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"id","withdrawId"),i=this.safeString(e,"tagType");let n=this.safeString(e,"addressTo"),r=this.safeString(e,"addressFrom"),a,o;if(i!==void 0){if(n!==void 0){const T=n.split("_");n=this.safeString(T,0),a=this.safeString(T,1)}if(r!==void 0){const T=r.split("_");r=this.safeString(T,0),o=this.safeString(T,1)}}const d=this.safeString(e,"txid"),c=this.safeInteger(e,"createdAt"),u=this.safeInteger(e,"updatedAt"),h="payAmount"in e,l="ctime"in e,p=h||l?"withdrawal":"deposit",m=this.parseTransactionStatusByType(this.safeString(e,"status"),p),g=this.safeNumber(e,"amount");let y,b=this.safeString2(e,"symbol","coin");if(b!==void 0){const T=b.split("_");b=this.safeString(T,0);const I=this.safeString(T,1);I!==void 0&&(y=I.toUpperCase())}const w=this.safeCurrencyCode(b,t),S=this.safeNumber(e,"fee");let k;return S!==void 0&&(k={currency:w,cost:S}),{info:e,id:s,txid:d,timestamp:c,datetime:this.iso8601(c),network:y,address:n,addressTo:n,addressFrom:r,tag:a,tagTo:a,tagFrom:o,type:p,amount:g,currency:w,status:m,updated:u,internal:!1,fee:k}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e);let a=this.safeString(n,"chainName");if(a===void 0){const u=this.safeValue(r,"networks",{}),h=this.safeValue(this.options,"networks",{});let l=this.safeStringUpper(n,"network");l=this.safeString(h,l,l);const p=this.safeValue(u,l,{});if(a=this.safeString(p,"id"),a===void 0)throw new Lr(this.id+" withdraw() requires a network parameter or a chainName parameter");n=this.omit(n,"network")}const o={coin:r.id.toUpperCase(),amount:t,addressTo:s,chainName:a};i!==void 0&&(o.tag=i);const d=await this.v1PrivatePostWithdrawCommit(this.extend(o,n)),c=this.safeValue(d,"data");return this.parseTransaction(c,r)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const[a,o]=t;let d=this.urls.api[a]+"/"+this.implodeParams(e,i);if(i=this.omit(i,this.extractParams(e)),o==="private"){this.checkRequiredCredentials();const c=this.safeInteger(this.options,"recvWindow",5e3);let u=this.urlencode(this.extend({timestamp:this.nonce(),recvWindow:c},i));const h=this.hmac(this.encode(u),this.encode(this.secret));u+="&signature="+h,n={"X-MBX-APIKEY":this.apiKey},s==="GET"||s==="DELETE"?d+="?"+u:(r=u,n["Content-Type"]="application/x-www-form-urlencoded")}else Object.keys(i).length&&(d+="?"+this.urlencode(i));return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(e===418||e===429)throw new Rm(this.id+" "+e.toString()+" "+t+" "+r);if(e>=400){if(r.indexOf("Price * QTY is zero or less")>=0)throw new Rr(this.id+" order cost = amount * price is zero or less "+r);if(r.indexOf("LOT_SIZE")>=0)throw new Rr(this.id+" order amount should be evenly divisible by lot size "+r);if(r.indexOf("PRICE_FILTER")>=0)throw new Rr(this.id+" order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid float value in general, use this.priceToPrecision (symbol, amount) "+r)}if(a===void 0)return;const c=this.safeValue(a,"success",!0);if(!c){const l=this.safeString(a,"msg");let p;if(l!==void 0){try{p=JSON.parse(l)}catch{p=void 0}p!==void 0&&(a=p)}}const u=this.safeString(a,"msg");u!==void 0&&(this.throwExactlyMatchedException(this.exceptions.exact,u,this.id+" "+u),this.throwBroadlyMatchedException(this.exceptions.broad,u,this.id+" "+u));const h=this.safeString(a,"code");if(h!==void 0){if(h==="200"||US.stringEquals(h,"0"))return;if(h==="-2015"&&this.options.hasAlreadyAuthenticatedSuccessfully)throw new Rm(this.id+" temporary banned: "+r);const l=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,h,l),new Ma(l)}if(!c)throw new Ma(this.id+" "+r)}calculateRateLimiterCost(e,t,s,i,n={},r={}){if("noSymbol"in n&&!("symbol"in i))return n.noSymbol;if("byLimit"in n&&"limit"in i){const a=i.limit,o=n.byLimit;for(let d=0;d<o.length;d++){const c=o[d];if(a<=c[0])return c[1]}}return this.safeValue(n,"cost",1)}};const S6=me,{ExchangeError:rc,InvalidNonce:k6,AuthenticationError:v6,OrderNotFound:T6,NotSupported:O6,BadRequest:I6,ArgumentsRequired:x6}=oe,{TICK_SIZE:_6}=pe,Co=ke;var C6=class extends S6{describe(){return this.deepExtend(super.describe(),{id:"bitso",name:"Bitso",countries:["MX"],rateLimit:2e3,version:"v3",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createDepositAddress:!1,createOrder:!0,createReduceOnlyOrder:!1,fetchAccounts:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchDeposit:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!1,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFee:!1,fetchTransactionFees:!0,fetchTransactions:!1,fetchTransfer:!1,fetchTransfers:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/51840849/87295554-11f98280-c50e-11ea-80d6-15b3bafa8cbf.jpg",api:{rest:"https://api.bitso.com"},www:"https://bitso.com",doc:"https://bitso.com/api_info",fees:"https://bitso.com/fees",referral:"https://bitso.com/?ref=itej"},precisionMode:_6,options:{precision:{XRP:1e-6,MXN:.01,TUSD:.01},defaultPrecision:1e-8},timeframes:{"1m":"60","5m":"300","15m":"900","30m":"1800","1h":"3600","4h":"14400","12h":"43200","1d":"86400","1w":"604800"},api:{public:{get:["available_books","ticker","order_book","trades","ohlc"]},private:{get:["account_status","balance","fees","fundings","fundings/{fid}","funding_destination","kyc_documents","ledger","ledger/trades","ledger/fees","ledger/fundings","ledger/withdrawals","mx_bank_codes","open_orders","order_trades/{oid}","orders/{oid}","user_trades","user_trades/{tid}","withdrawals/","withdrawals/{wid}"],post:["bitcoin_withdrawal","debit_card_withdrawal","ether_withdrawal","ripple_withdrawal","bcash_withdrawal","litecoin_withdrawal","orders","phone_number","phone_verification","phone_withdrawal","spei_withdrawal","ripple_withdrawal","bcash_withdrawal","litecoin_withdrawal"],delete:["orders","orders/{oid}","orders/all"]}},exceptions:{"0201":v6,104:k6,"0304":I6}})}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){const n={};s!==void 0&&(n.limit=s);const r=await this.privateGetLedger(this.extend(n,i)),a=this.safeValue(r,"payload",[]);return this.parseLedger(a,e,t,s)}parseLedgerEntryType(e){const t={funding:"transaction",withdrawal:"transaction",trade:"trade",fee:"fee"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"operation"),i=this.parseLedgerEntryType(s),n=this.safeValue(e,"balance_updates",[]),r=this.safeValue(n,0,{});let a,o;const d=this.safeString(r,"amount"),c=this.safeString(r,"currency"),u=this.safeCurrencyCode(c,t),h=this.safeValue(e,"details",{});let l=this.safeString2(h,"fid","wid");l===void 0&&(l=this.safeString(h,"tid")),s==="funding"?a="in":s==="withdrawal"?a="out":s==="trade"?a=void 0:s==="fee"&&(a="out",o={cost:Co.stringAbs(d),currency:t});const p=this.parse8601(this.safeString(e,"created_at"));return this.safeLedgerEntry({id:this.safeString(e,"eid"),direction:a,account:void 0,referenceId:l,referenceAccount:void 0,type:i,currency:u,amount:d,timestamp:p,datetime:this.iso8601(p),before:void 0,after:void 0,status:"ok",fee:o,info:e},t)}async fetchMarkets(e={}){const t=await this.publicGetAvailableBooks(e),s=this.safeValue(t,"payload",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"book"),[o,d]=a.split("_");let c=o.toUpperCase(),u=d.toUpperCase();c=this.safeCurrencyCode(c),u=this.safeCurrencyCode(u);const h=this.safeValue(r,"fees",{}),l=this.safeValue(h,"flat_rate",{}),p=this.safeString(l,"taker"),m=this.safeString(l,"maker"),g=this.parseNumber(Co.stringDiv(p,"100")),y=this.parseNumber(Co.stringDiv(m,"100")),b=this.safeValue(h,"structure",[]),w={taker:g,maker:y,percentage:!0,tierBased:!0},S=[],k=[];for(let _=0;_<b.length;_++){const N=b[_],M=this.safeNumber(N,"volume"),x=this.safeNumber(N,"taker"),v=this.safeNumber(N,"maker");S.push([M,x]),k.push([M,v]),_===0&&(w.taker=x,w.maker=v)}const T={taker:S,maker:k};w.tiers=T;const I=this.safeNumber(this.options.precision,u,this.options.defaultPrecision);i.push(this.extend({id:a,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,taker:g,maker:y,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(this.options.precision,c,this.options.defaultPrecision),price:this.safeNumber(r,"tick_size",I)},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"minimum_amount"),max:this.safeNumber(r,"maximum_amount")},price:{min:this.safeNumber(r,"minimum_price"),max:this.safeNumber(r,"maximum_price")},cost:{min:this.safeNumber(r,"minimum_value"),max:this.safeNumber(r,"maximum_value")}},info:r},w))}return i}parseBalance(e){const t=this.safeValue(e,"payload",{}),s=this.safeValue(t,"balances",[]),i={info:e,timestamp:void 0,datetime:void 0};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.account();d.free=this.safeString(r,"available"),d.used=this.safeString(r,"locked"),d.total=this.safeString(r,"total"),i[o]=d}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={book:i.id},r=await this.publicGetOrderBook(this.extend(n,s)),a=this.safeValue(r,"payload"),o=this.parse8601(this.safeString(a,"updated_at"));return this.parseOrderBook(a,i.symbol,o,"bids","asks","price","amount")}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.parse8601(this.safeString(e,"created_at")),n=this.safeString(e,"vwap"),r=this.safeString(e,"volume"),a=Co.stringMul(r,n),o=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:n,open:void 0,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:a,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={book:s.id},n=await this.publicGetTicker(this.extend(i,t)),r=this.safeValue(n,"payload");return this.parseTicker(r,s)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={book:r.id,time_bucket:this.timeframes[t]};if(s!==void 0){if(a.start=s,i!==void 0){const c=this.parseTimeframe(t);a.end=this.sum(s,c*i*1e3)}}else if(i!==void 0){const c=this.milliseconds();a.end=c,a.start=c-this.parseTimeframe(t)*1e3*i}const o=await this.publicGetOhlc(this.extend(a,n)),d=this.safeValue(o,"payload",[]);return this.parseOHLCVs(d,r,t,s,i)}parseOHLCV(e,t=void 0,s="1m"){return[this.safeInteger(e,"bucket_start_time"),this.safeNumber(e,"first_rate"),this.safeNumber(e,"max_rate"),this.safeNumber(e,"min_rate"),this.safeNumber(e,"last_rate"),this.safeNumber(e,"volume")]}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"created_at")),i=this.safeString(e,"book"),n=this.safeSymbol(i,t,"_"),r=this.safeString2(e,"side","maker_side"),a=this.safeString(e,"maker_side");let o;r===a?o="maker":o="taker";let d=this.safeString2(e,"amount","major");d!==void 0&&(d=Co.stringAbs(d));let c;const u=this.safeString(e,"fees_amount");if(u!==void 0){const g=this.safeString(e,"fees_currency"),y=this.safeCurrencyCode(g);c={cost:u,currency:y}}let h=this.safeString(e,"minor");h!==void 0&&(h=Co.stringAbs(h));const l=this.safeString(e,"price"),p=this.safeString(e,"oid"),m=this.safeString(e,"tid");return this.safeTrade({id:m,info:e,timestamp:s,datetime:this.iso8601(s),symbol:n,order:p,type:void 0,side:r,takerOrMaker:o,price:l,amount:d,cost:h,fee:c},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={book:n.id},a=await this.publicGetTrades(this.extend(r,i));return this.parseTrades(a.payload,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetFees(e),s=this.safeValue(t,"payload",{}),i=this.safeValue(s,"fees",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"book"),d=this.safeSymbol(o,void 0,"_");n[d]={info:a,symbol:d,maker:this.safeNumber(a,"maker_fee_decimal"),taker:this.safeNumber(a,"taker_fee_decimal"),percentage:!0,tierBased:!0}}return n}async fetchMyTrades(e=void 0,t=void 0,s=25,i={}){await this.loadMarkets();const n=this.market(e),r="marker"in i;if(t!==void 0&&!r)throw new rc(this.id+" fetchMyTrades() does not support fetching trades starting from a timestamp with the `since` argument, use the `marker` extra param to filter starting from an integer trade id");r&&(i=this.extend(i,{marker:parseInt(i.marker)}));const a={book:n.id,limit:s},o=await this.privateGetUserTrades(this.extend(a,i));return this.parseTrades(o.payload,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={book:a.id,side:s,type:t,major:this.amountToPrecision(a.symbol,i)};t==="limit"&&(o.price=this.priceToPrecision(a.symbol,n));const d=await this.privatePostOrders(this.extend(o,r)),c=this.safeString(d.payload,"oid");return{info:d,id:c}}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={oid:e};return await this.privateDeleteOrdersOid(this.extend(i,s))}async cancelOrders(e,t=void 0,s={}){if(!Array.isArray(e))throw new x6(this.id+" cancelOrders() ids argument should be an array");let i;t!==void 0&&(i=this.market(t));const r={oids:e.join(",")},a=await this.privateDeleteOrders(this.extend(r,s)),o=this.safeValue(a,"payload",[]),d=[];for(let c=0;c<o.length;c++){const u=o[c];d.push(this.parseOrder(u,i))}return d}async cancelAllOrders(e=void 0,t={}){if(e!==void 0)throw new O6(this.id+" cancelAllOrders() deletes all orders for user, it does not support filtering by symbol.");const s=await this.privateDeleteOrdersAll(t),i=this.safeValue(s,"payload",[]),n=[];for(let r=0;r<i.length;r++){const a=this.parseOrder(i[r]);n.push(a)}return n}parseOrderStatus(e){const t={"partial-fill":"open",completed:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){let s;typeof e=="string"?s=e:s=this.safeString(e,"oid");const i=this.safeString(e,"side"),n=this.parseOrderStatus(this.safeString(e,"status")),r=this.safeString(e,"book"),a=this.safeSymbol(r,t,"_"),o=this.safeString(e,"type"),d=this.parse8601(this.safeString(e,"created_at")),c=this.safeString(e,"price"),u=this.safeString(e,"original_amount"),h=this.safeString(e,"unfilled_amount"),l=this.safeString(e,"client_id");return this.safeOrder({info:e,id:s,clientOrderId:l,timestamp:d,datetime:this.iso8601(d),lastTradeTimestamp:void 0,symbol:a,type:o,timeInForce:void 0,postOnly:void 0,side:i,price:c,stopPrice:void 0,amount:u,cost:void 0,remaining:h,filled:void 0,status:n,fee:void 0,average:void 0,trades:void 0},t)}async fetchOpenOrders(e=void 0,t=void 0,s=25,i={}){await this.loadMarkets();const n=this.market(e),r="marker"in i;if(t!==void 0&&!r)throw new rc(this.id+" fetchOpenOrders() does not support fetching orders starting from a timestamp with the `since` argument, use the `marker` extra param to filter starting from an integer trade id");r&&(i=this.extend(i,{marker:parseInt(i.marker)}));const a={book:n.id,limit:s},o=await this.privateGetOpenOrders(this.extend(a,i));return this.parseOrders(o.payload,n,t,s)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=await this.privateGetOrdersOid({oid:e}),n=this.safeValue(i,"payload");if(Array.isArray(n)&&i.payload.length===1)return this.parseOrder(n[0]);throw new T6(this.id+": The order "+e+" not found.")}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(t),a={oid:e},o=await this.privateGetOrderTradesOid(this.extend(a,n));return this.parseTrades(o.payload,r)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const i={fid:e},n=await this.privateGetFundingsFid(this.extend(i,s)),r=this.safeValue(n,"payload",[]),a=this.safeValue(r,0,{});return this.parseTransaction(a)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r=await this.privateGetFundings(i),a=this.safeValue(r,"payload",[]);return this.parseTransactions(a,n,t,s,i)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={fund_currency:this.currency(e).id},n=await this.privateGetFundingDestination(this.extend(i,t));let r=this.safeString(n.payload,"account_identifier"),a;if(r.indexOf("?dt=")>=0){const o=r.split("?dt=");r=this.safeString(o,0),a=this.safeString(o,1)}return this.checkAddress(r),{currency:e,address:r,tag:a,network:void 0,info:n}}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetFees(t),i={},n=this.safeValue(s,"payload",{}),r=this.safeValue(n,"deposit_fees",[]);for(let d=0;d<r.length;d++){const c=r[d],u=this.safeString(c,"currency"),h=this.safeCurrencyCode(u);e!==void 0&&!this.inArray(h,e)||(i[h]={deposit:this.safeNumber(c,"fee"),withdraw:void 0,info:{deposit:c,withdraw:void 0}})}const a=this.safeValue(n,"withdrawal_fees",[]),o=Object.keys(a);for(let d=0;d<o.length;d++){const c=o[d],u=this.safeCurrencyCode(c);e!==void 0&&!this.inArray(u,e)||(i[u]={deposit:this.safeValue(i[u],"deposit"),withdraw:this.safeNumber(a,c),info:{deposit:this.safeValue(i[u].info,"deposit"),withdraw:this.safeNumber(a,c)}})}return i}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r={BTC:"Bitcoin",ETH:"Ether",XRP:"Ripple",BCH:"Bcash",LTC:"Litecoin"},a=this.currency(e),o=e in r?r[e]:void 0;if(o===void 0)throw new rc(this.id+" not valid withdraw coin: "+e);const d={amount:t,address:s,destination_tag:i},c="privatePost"+o+"Withdrawal",u=await this[c](this.extend(d,n)),h=this.safeValue(u,"payload",[]),l=this.safeValue(h,0);return this.parseTransaction(l,a)}safeNetwork(e){if(e===void 0)return;e=e.toUpperCase();const t={trx:"TRC20",erc20:"ERC20",bsc:"BEP20",bep2:"BEP2"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"currency","asset");t=this.safeCurrency(s,t);const i=this.safeValue(e,"details",{}),n=this.safeString(e,"created_at"),r=this.safeString(i,"withdrawal_address"),a=this.safeString(i,"receiving_address"),o=this.safeString2(e,"network","method"),d=this.safeString(e,"status"),c=this.safeString(e,"wid");return{id:this.safeString2(e,"wid","fid"),txid:this.safeString(i,"tx_hash"),timestamp:this.parse8601(n),datetime:n,network:this.safeNetwork(o),addressFrom:a,address:r!==void 0?r:a,addressTo:r,amount:this.safeString(e,"amount"),type:c===void 0?"deposit":"withdrawal",currency:this.safeCurrencyCode(s,t),status:this.parseTransactionStatus(d),updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0,info:e}}parseTransactionStatus(e){const t={pending:"pending",in_progress:"pending",complete:"ok",failed:"failed"};return this.safeString(t,e,e)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));(s==="GET"||s==="DELETE")&&Object.keys(o).length&&(a+="?"+this.urlencode(o));const d=this.urls.api.rest+a;if(t==="private"){this.checkRequiredCredentials();const c=this.nonce().toString();let u=[c,s,a].join("");s!=="GET"&&s!=="DELETE"&&Object.keys(o).length&&(r=this.json(o),u+=r);const h=this.hmac(this.encode(u),this.encode(this.secret));n={Authorization:"Bitso "+(this.apiKey+":"+c+":"+h),"Content-Type":"application/json"}}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&"success"in a){let c=this.safeValue(a,"success",!1);if(typeof c=="string"&&(c==="true"||c==="1"?c=!0:c=!1),!c){const u=this.id+" "+this.json(a),h=this.safeValue(a,"error");if(h===void 0)throw new rc(u);const l=this.safeString(h,"code");throw this.throwExactlyMatchedException(this.exceptions,l,u),new rc(u)}}}};const M6=me,{AuthenticationError:Mo,BadRequest:P6,ExchangeError:$S,NotSupported:A6,PermissionDenied:Sf,InvalidNonce:B6,OrderNotFound:N6,InsufficientFunds:E6,InvalidAddress:V6,InvalidOrder:Hm,OnMaintenance:q6,ExchangeNotAvailable:L6}=oe,{TICK_SIZE:R6}=pe,Fr=ke;var C_=class extends M6{describe(){return this.deepExtend(super.describe(),{id:"bitstamp",name:"Bitstamp",countries:["GB"],rateLimit:75,version:"v2",userAgent:this.userAgents.chrome,pro:!0,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransactionFees:!0,fetchTransactions:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27786377-8c8ab57e-5fe9-11e7-8ea4-2b05b6bcceec.jpg",api:{public:"https://www.bitstamp.net/api",private:"https://www.bitstamp.net/api"},www:"https://www.bitstamp.net",doc:"https://www.bitstamp.net/api"},timeframes:{"1m":"60","3m":"180","5m":"300","15m":"900","30m":"1800","1h":"3600","2h":"7200","4h":"14400","6h":"21600","12h":"43200","1d":"86400","1w":"259200"},requiredCredentials:{apiKey:!0,secret:!0},api:{public:{get:{"ohlc/{pair}/":1,"order_book/{pair}/":1,"ticker_hour/{pair}/":1,"ticker/{pair}/":1,"transactions/{pair}/":1,"trading-pairs-info/":1}},private:{post:{"balance/":1,"balance/{pair}/":1,"bch_withdrawal/":1,"bch_address/":1,"user_transactions/":1,"user_transactions/{pair}/":1,"open_orders/all/":1,"open_orders/{pair}/":1,"order_status/":1,"cancel_order/":1,"cancel_all_orders/":1,"cancel_all_orders/{pair}/":1,"buy/{pair}/":1,"buy/market/{pair}/":1,"buy/instant/{pair}/":1,"sell/{pair}/":1,"sell/market/{pair}/":1,"sell/instant/{pair}/":1,"transfer-to-main/":1,"transfer-from-main/":1,"withdrawal-requests/":1,"withdrawal/open/":1,"withdrawal/status/":1,"withdrawal/cancel/":1,"liquidation_address/new/":1,"liquidation_address/info/":1,"btc_unconfirmed/":1,"websockets_token/":1,"btc_withdrawal/":1,"btc_address/":1,"ripple_withdrawal/":1,"ripple_address/":1,"ltc_withdrawal/":1,"ltc_address/":1,"eth_withdrawal/":1,"eth_address/":1,"xrp_withdrawal/":1,"xrp_address/":1,"xlm_withdrawal/":1,"xlm_address/":1,"pax_withdrawal/":1,"pax_address/":1,"link_withdrawal/":1,"link_address/":1,"usdc_withdrawal/":1,"usdc_address/":1,"omg_withdrawal/":1,"omg_address/":1,"dai_withdrawal/":1,"dai_address/":1,"knc_withdrawal/":1,"knc_address/":1,"mkr_withdrawal/":1,"mkr_address/":1,"zrx_withdrawal/":1,"zrx_address/":1,"gusd_withdrawal/":1,"gusd_address/":1,"aave_withdrawal/":1,"aave_address/":1,"bat_withdrawal/":1,"bat_address/":1,"uma_withdrawal/":1,"uma_address/":1,"snx_withdrawal/":1,"snx_address/":1,"uni_withdrawal/":1,"uni_address/":1,"yfi_withdrawal/":1,yfi_address:1,"audio_withdrawal/":1,"audio_address/":1,"crv_withdrawal/":1,"crv_address/":1,"algo_withdrawal/":1,"algo_address/":1,"comp_withdrawal/":1,"comp_address/":1,grt_withdrawal:1,"grt_address/":1,"usdt_withdrawal/":1,"usdt_address/":1,"eurt_withdrawal/":1,"eurt_address/":1,"matic_withdrawal/":1,"matic_address/":1,"sushi_withdrawal/":1,"sushi_address/":1,"chz_withdrawal/":1,"chz_address/":1,"enj_withdrawal/":1,"enj_address/":1,"alpha_withdrawal/":1,"alpha_address/":1,"ftt_withdrawal/":1,"ftt_address/":1,"storj_withdrawal/":1,"storj_address/":1,"axs_withdrawal/":1,"axs_address/":1,"sand_withdrawal/":1,"sand_address/":1,"hbar_withdrawal/":1,"hbar_address/":1,"rgt_withdrawal/":1,"rgt_address/":1,"fet_withdrawal/":1,"fet_address/":1,"skl_withdrawal/":1,"skl_address/":1,"cel_withdrawal/":1,"cel_address/":1,"sxp_withdrawal/":1,"sxp_address/":1,"ada_withdrawal/":1,"ada_address/":1,"slp_withdrawal/":1,"slp_address/":1,"ftm_withdrawal/":1,"ftm_address/":1,"perp_withdrawal/":1,"perp_address/":1,"dydx_withdrawal/":1,"dydx_address/":1,"gala_withdrawal/":1,"gala_address/":1,"shib_withdrawal/":1,"shib_address/":1,"amp_withdrawal/":1,"amp_address/":1,"sgb_withdrawal/":1,"sgb_address/":1,"avax_withdrawal/":1,"avax_address/":1,"wbtc_withdrawal/":1,"wbtc_address/":1,"ctsi_withdrawal/":1,"ctsi_address/":1,"cvx_withdrawal/":1,"cvx_address/":1,"imx_withdrawal/":1,"imx_address/":1,"nexo_withdrawal/":1,"nexo_address/":1,"ust_withdrawal/":1,"ust_address/":1,"ant_withdrawal/":1,"ant_address/":1,"gods_withdrawal/":1,"gods_address/":1,"rad_withdrawal/":1,"rad_address/":1,"band_withdrawal/":1,"band_address/":1,"inj_withdrawal/":1,"inj_address/":1,"rly_withdrawal/":1,"rly_address/":1,"rndr_withdrawal/":1,"rndr_address/":1,"vega_withdrawal/":1,"vega_address/":1,"1inch_withdrawal/":1,"1inch_address/":1,"ens_withdrawal/":1,"ens_address/":1,"mana_withdrawal/":1,"mana_address/":1,"lrc_withdrawal/":1,"lrc_address/":1,"ape_withdrawal/":1,"ape_address/":1,"mpl_withdrawal/":1,"mpl_address/":1,"euroc_withdrawal/":1,"euroc_address/":1,"sol_withdrawal/":1,"sol_address/":1,"dot_withdrawal/":1,"dot_address/":1,"near_withdrawal/":1,"near_address/":1}}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.005"),maker:this.parseNumber("0.005"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.005")],[this.parseNumber("20000"),this.parseNumber("0.0025")],[this.parseNumber("100000"),this.parseNumber("0.0024")],[this.parseNumber("200000"),this.parseNumber("0.0022")],[this.parseNumber("400000"),this.parseNumber("0.0020")],[this.parseNumber("600000"),this.parseNumber("0.0015")],[this.parseNumber("1000000"),this.parseNumber("0.0014")],[this.parseNumber("2000000"),this.parseNumber("0.0013")],[this.parseNumber("4000000"),this.parseNumber("0.0012")],[this.parseNumber("20000000"),this.parseNumber("0.0011")],[this.parseNumber("50000000"),this.parseNumber("0.0010")],[this.parseNumber("100000000"),this.parseNumber("0.0007")],[this.parseNumber("500000000"),this.parseNumber("0.0005")],[this.parseNumber("2000000000"),this.parseNumber("0.0003")],[this.parseNumber("6000000000"),this.parseNumber("0.0001")],[this.parseNumber("20000000000"),this.parseNumber("0.00005")],[this.parseNumber("20000000001"),this.parseNumber("0")]],maker:[[this.parseNumber("0"),this.parseNumber("0.005")],[this.parseNumber("20000"),this.parseNumber("0.0025")],[this.parseNumber("100000"),this.parseNumber("0.0024")],[this.parseNumber("200000"),this.parseNumber("0.0022")],[this.parseNumber("400000"),this.parseNumber("0.0020")],[this.parseNumber("600000"),this.parseNumber("0.0015")],[this.parseNumber("1000000"),this.parseNumber("0.0014")],[this.parseNumber("2000000"),this.parseNumber("0.0013")],[this.parseNumber("4000000"),this.parseNumber("0.0012")],[this.parseNumber("20000000"),this.parseNumber("0.0011")],[this.parseNumber("50000000"),this.parseNumber("0.0010")],[this.parseNumber("100000000"),this.parseNumber("0.0007")],[this.parseNumber("500000000"),this.parseNumber("0.0005")],[this.parseNumber("2000000000"),this.parseNumber("0.0003")],[this.parseNumber("6000000000"),this.parseNumber("0.0001")],[this.parseNumber("20000000000"),this.parseNumber("0.00005")],[this.parseNumber("20000000001"),this.parseNumber("0")]]}},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{BTC:0,BCH:0,LTC:0,ETH:0,XRP:0,XLM:0,PAX:0,USD:7.5,EUR:0}}},precisionMode:R6,commonCurrencies:{UST:"USTC"},exceptions:{exact:{"No permission found":Sf,"API key not found":Mo,"IP address not allowed":Sf,"Invalid nonce":B6,"Invalid signature":Mo,"Authentication failed":Mo,"Missing key, signature and nonce parameters":Mo,"Wrong API key format":Mo,"Your account is frozen":Sf,"Please update your profile with your FATCA information, before using API.":Sf,"Order not found.":N6,"Price is more than 20% below market price.":Hm,"Bitstamp.net is under scheduled maintenance. We'll be back soon.":q6,"Order could not be placed.":L6,"Invalid offset.":P6},broad:{"Minimum order size is":Hm,"Check your account balance for details.":E6,"Ensure this value has at least":V6,"Ensure that there are no more than":Hm}}})}async fetchMarkets(e={}){const t=await this.fetchMarketsFromCache(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"name");let[a,o]=r.split("/");const d=a.toLowerCase(),c=o.toLowerCase();a=this.safeCurrencyCode(a),o=this.safeCurrencyCode(o);const h=this.safeString(n,"minimum_order").split(" "),l=this.safeString(n,"trading");s.push({id:this.safeString(n,"url_symbol"),marketId:d+"_"+c,symbol:a+"/"+o,base:a,quote:o,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,future:!1,swap:!1,option:!1,active:l==="Enabled",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(n,"base_decimals"))),price:this.parseNumber(this.parsePrecision(this.safeString(n,"counter_decimals")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(h,0),max:void 0}},info:n})}return s}constructCurrencyObject(e,t,s,i,n,r){let a="crypto";const o=this.describe();this.isFiat(t)&&(a="fiat");const d=this.parseNumber(this.parsePrecision(this.numberToString(i)));return{id:e,code:t,info:r,type:a,name:s,active:!0,deposit:void 0,withdraw:void 0,fee:this.safeNumber(o.fees.funding.withdraw,t),precision:d,limits:{amount:{min:d,max:void 0},price:{min:d,max:void 0},cost:{min:n,max:void 0},withdraw:{min:void 0,max:void 0}}}}async fetchMarketsFromCache(e={}){const t=this.safeValue(this.options,"fetchMarkets",{}),s=this.safeInteger(t,"timestamp"),i=this.safeInteger(t,"expires",1e3),n=this.milliseconds();if(s===void 0||n-s>i){const r=await this.publicGetTradingPairsInfo(e);this.options.fetchMarkets=this.extend(t,{response:r,timestamp:n})}return this.safeValue(this.options.fetchMarkets,"response")}async fetchCurrencies(e={}){const t=await this.fetchMarketsFromCache(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"name");let[a,o]=r.split("/");const d=a.toLowerCase(),c=o.toLowerCase();a=this.safeCurrencyCode(a),o=this.safeCurrencyCode(o);const u=this.safeString(n,"description"),[h,l]=u.split(" / "),g=this.safeString(n,"minimum_order").split(" ")[0];if(!(a in s)){const y=this.safeInteger(n,"base_decimals");s[a]=this.constructCurrencyObject(d,a,h,y,void 0,n)}if(!(o in s)){const y=this.safeInteger(n,"counter_decimals");s[o]=this.constructCurrencyObject(c,o,l,y,this.parseNumber(g),n)}}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id},r=await this.publicGetOrderBookPair(this.extend(n,s)),a=this.safeInteger(r,"microtimestamp"),o=parseInt(a/1e3),d=this.parseOrderBook(r,i.symbol,o);return d.nonce=a,d}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeTimestamp(e,"timestamp"),n=this.safeString(e,"vwap"),r=this.safeString(e,"volume"),a=Fr.stringMul(r,n),o=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:n,open:this.safeString(e,"open"),close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:a,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetTickerPair(this.extend(i,t));return this.parseTicker(n,s)}getCurrencyIdFromTransaction(e){const t=this.safeStringLower(e,"currency");if(t!==void 0)return t;e=this.omit(e,["fee","price","datetime","type","status","id"]);const s=Object.keys(e);for(let i=0;i<s.length;i++){const n=s[i];if(n.indexOf("_")<0){const r=this.safeNumber(e,n);if(r!==void 0&&r!==0)return n}}}getMarketFromTrade(e){e=this.omit(e,["fee","price","datetime","tid","type","order_id","side"]);const t=Object.keys(e),s=t.length;if(s>2)throw new $S(this.id+" getMarketFromTrade() too many keys: "+this.json(t)+" in the trade: "+this.json(e));if(s===2){let i=t[0]+t[1];if(i in this.markets_by_id)return this.markets_by_id[i];if(i=t[1]+t[0],i in this.markets_by_id)return this.markets_by_id[i]}}parseTrade(e,t=void 0){const s=this.safeString2(e,"id","tid");let i,n,r=this.safeString(e,"price"),a=this.safeString(e,"amount");const o=this.safeString(e,"order_id"),d=void 0;let c=this.safeString(e,"cost"),u,h,l;if(t===void 0){const T=Object.keys(e);for(let I=0;I<T.length;I++){const _=T[I];if(_!=="order_id"&&_.indexOf("_")>=0){const N=_.replace("_","");if(N in this.markets_by_id)t=this.markets_by_id[N];else{l=_;const M=_.split("_");u=this.safeString(M,0),h=this.safeString(M,1),t=this.safeMarket(N)}}}}t===void 0&&(t=this.getMarketFromTrade(e));const p=this.safeString(e,"fee"),m=t.quote!==void 0?t.quote:h,g=t.baseId!==void 0?t.baseId:u,y=t.quoteId!==void 0?t.quoteId:h,b=l!==void 0?l:t.marketId;r=this.safeString(e,b,r),a=this.safeString(e,g,a),c=this.safeString(e,y,c),i=t.symbol;const w=this.safeString2(e,"date","datetime");let S;w!==void 0&&(w.indexOf(" ")>=0?S=this.parse8601(w):(S=parseInt(w),S=S*1e3)),"id"in e?a!==void 0&&(Fr.stringLt(a,"0")?(n="sell",a=Fr.stringNeg(a)):n="buy"):(n=this.safeString(e,"type"),n==="1"?n="sell":n==="0"?n="buy":n=void 0),c!==void 0&&(c=Fr.stringAbs(c));let k;return p!==void 0&&(k={cost:p,currency:m}),this.safeTrade({id:s,info:e,timestamp:S,datetime:this.iso8601(S),symbol:i,order:o,type:d,side:n,takerOrMaker:void 0,price:r,amount:a,cost:c,fee:k},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id,time:"hour"},a=await this.publicGetTransactionsPair(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"timestamp"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id,step:this.timeframes[t]},o=this.parseTimeframe(t);if(i===void 0)if(s===void 0)a.limit=1e3;else{i=1e3;const h=parseInt(s/1e3);a.start=h,a.end=this.sum(h,i*o),a.limit=i}else{if(s!==void 0){const h=parseInt(s/1e3);a.start=h,a.end=this.sum(h,i*o)}a.limit=Math.min(i,1e3)}const d=await this.publicGetOhlcPair(this.extend(a,n)),c=this.safeValue(d,"data",{}),u=this.safeValue(c,"ohlc",[]);return this.parseOHLCVs(u,r,t,s,i)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=Object.keys(this.currencies);for(let i=0;i<s.length;i++){const n=s[i],a=this.currency(n).id,o=this.account();o.free=this.safeString(e,a+"_available"),o.used=this.safeString(e,a+"_reserved"),o.total=this.safeString(e,a+"_balance"),t[n]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalance(e);return this.parseBalance(t)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.privatePostBalancePair(this.extend(i,t));return this.parseTradingFee(n,s)}parseTradingFee(e,t=void 0){t=this.safeMarket(void 0,t);const s=this.safeString(e,t.id+"_fee"),i=Fr.stringDiv(s,"100"),n=this.parseNumber(i);return{info:e,symbol:t.symbol,maker:n,taker:n}}parseTradingFees(e){const t={info:e},s=this.symbols;for(let i=0;i<s.length;i++){const n=s[i],r=this.market(n),a=this.parseTradingFee(e,r);t[n]=a}return t}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostBalance(e);return this.parseTradingFees(t)}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.privatePostBalance(t);return this.parseTransactionFees(s,e)}parseTransactionFees(e,t=void 0){t===void 0&&(t=Object.keys(this.currencies));const s={};let i;const n=Object.keys(e);for(let r=0;r<n.length;r++){const a=n[r],o=a.split("_")[0],d=this.safeCurrencyCode(o);t!==void 0&&!this.inArray(d,t)||(a.indexOf("_available")>=0&&(i=o,s[d]={deposit:void 0,withdraw:void 0,info:{}}),o===i&&(s[d].info[a]=this.safeNumber(e,a)),a.indexOf("_withdrawal_fee")>=0&&(s[d].withdraw=this.safeNumber(e,a)))}return s}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o="privatePost"+this.capitalize(s);const d={pair:a.id,amount:this.amountToPrecision(e,i)};t==="market"?o+="Market":t==="instant"?o+="Instant":d.price=this.priceToPrecision(e,n),o+="Pair";const c=this.safeString2(r,"client_order_id","clientOrderId");c!==void 0&&(d.client_order_id=c,r=this.omit(r,["client_order_id","clientOrderId"]));const u=await this[o](this.extend(d,r)),h=this.parseOrder(u,a);return this.extend(h,{type:t})}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e};return await this.privatePostCancelOrder(this.extend(i,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();let s;const i={};let n="privatePostCancelAllOrders";return e!==void 0&&(s=this.market(e),i.pair=s.id,n="privatePostCancelAllOrdersPair"),await this[n](this.extend(i,t))}parseOrderStatus(e){const t={"In Queue":"open",Open:"open",Finished:"closed",Canceled:"canceled"};return this.safeString(t,e,e)}async fetchOrderStatus(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue2(s,"client_order_id","clientOrderId"),n={};i!==void 0?(n.client_order_id=i,s=this.omit(s,["client_order_id","clientOrderId"])):n.id=e;const r=await this.privatePostOrderStatus(this.extend(n,s));return this.parseOrderStatus(this.safeString(r,"status"))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));const n=this.safeValue2(s,"client_order_id","clientOrderId"),r={};n!==void 0?(r.client_order_id=n,s=this.omit(s,["client_order_id","clientOrderId"])):r.id=e;const a=await this.privatePostOrderStatus(this.extend(r,s));return this.parseOrder(a,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r="privatePostUserTransactions",a;e!==void 0&&(a=this.market(e),n.pair=a.id,r+="Pair"),s!==void 0&&(n.limit=s);const o=await this[r](this.extend(n,i)),d=this.filterBy(o,"type","2");return this.parseTrades(d,a,t,s)}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};s!==void 0&&(n.limit=s);const r=await this.privatePostUserTransactions(this.extend(n,i));let a;e!==void 0&&(a=this.currency(e));const o=this.filterByArray(r,"type",["0","1"],!1);return this.parseTransactions(o,a,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0?n.timedelta=this.milliseconds()-t:n.timedelta=5e7;const r=await this.privatePostWithdrawalRequests(this.extend(n,i));return this.parseTransactions(r,void 0,t,s)}parseTransaction(e,t=void 0){const s=this.parse8601(this.safeString(e,"datetime")),i=this.safeString(e,"id"),n=this.getCurrencyIdFromTransaction(e),r=this.safeCurrencyCode(n,t),a=this.safeString(e,"fee");let o,d;"amount"in e?d=this.safeString(e,"amount"):t!==void 0?(d=this.safeString(e,t.id,d),o=t.code):r!==void 0&&n!==void 0&&(d=this.safeString(e,n,d),o=r),d!==void 0&&(d=Fr.stringAbs(d));let c="ok";"status"in e&&(c=this.parseTransactionStatus(this.safeString(e,"status")));let u;if("type"in e){const S=this.safeString(e,"type");S==="0"?u="deposit":S==="1"&&(u="withdrawal")}else u="withdrawal";const h=this.safeString(e,"transaction_id");let l,p=this.safeString(e,"address");if(p!==void 0){const S=p.split("?dt=");S.length>1&&(p=S[0],l=S[1])}const m=void 0,g=p,y=void 0,b=l;let w;return a!==void 0&&(w={currency:o,cost:a,rate:void 0}),{info:e,id:i,txid:h,timestamp:s,datetime:this.iso8601(s),network:void 0,addressFrom:m,addressTo:g,address:p,tagFrom:y,tagTo:b,tag:l,type:u,amount:this.parseNumber(d),currency:r,status:c,updated:void 0,fee:w}}parseTransactionStatus(e){const t={0:"pending",1:"pending",2:"ok",3:"canceled",4:"failed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"client_order_id");let n=this.safeString(e,"type");n!==void 0&&(n=n==="1"?"sell":"buy");const r=this.parse8601(this.safeString(e,"datetime")),a=this.safeStringLower(e,"currency_pair"),o=this.safeSymbol(a,t,"/"),d=this.parseOrderStatus(this.safeString(e,"status")),c=this.safeString(e,"amount"),u=this.safeValue(e,"transactions",[]),h=this.safeString(e,"price");return this.safeOrder({id:s,clientOrderId:i,datetime:this.iso8601(r),timestamp:r,lastTradeTimestamp:void 0,status:d,symbol:o,type:void 0,timeInForce:void 0,postOnly:void 0,side:n,price:h,stopPrice:void 0,cost:void 0,amount:c,filled:void 0,remaining:void 0,trades:u,fee:void 0,info:e,average:void 0},t)}parseLedgerEntryType(e){const t={0:"transaction",1:"transaction",2:"trade",14:"transfer"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.parseLedgerEntryType(this.safeString(e,"type"));if(s==="trade"){const i=this.parseTrade(e);let n;const r=Object.keys(e);for(let o=0;o<r.length;o++)if(r[o].indexOf("_")>=0){const d=r[o].replace("_","");d in this.markets_by_id&&(n=this.markets_by_id[d])}n===void 0&&(n=this.getMarketFromTrade(e));const a=i.side==="buy"?"in":"out";return{id:i.id,info:e,timestamp:i.timestamp,datetime:i.datetime,direction:a,account:void 0,referenceId:i.order,referenceAccount:void 0,type:s,currency:n.base,amount:i.amount,before:void 0,after:void 0,status:"ok",fee:i.fee}}else{const i=this.parseTransaction(e,t);let n;if("amount"in e){const r=this.safeString(e,"amount");n=Fr.stringGt(r,"0")?"in":"out"}else if("currency"in i&&i.currency!==void 0){const r=this.safeString(i,"currency");t=this.currency(r);const a=this.safeString(e,t.id);n=Fr.stringGt(a,"0")?"in":"out"}return{id:i.id,info:e,timestamp:i.timestamp,datetime:i.datetime,direction:n,account:void 0,referenceId:i.txid,referenceAccount:void 0,type:s,currency:i.currency,amount:i.amount,before:void 0,after:void 0,status:i.status,fee:i.fee}}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};s!==void 0&&(n.limit=s);const r=await this.privatePostUserTransactions(this.extend(n,i));let a;return e!==void 0&&(a=this.currency(e)),this.parseLedger(r,a,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){let n;await this.loadMarkets(),e!==void 0&&(n=this.market(e));const r=await this.privatePostOpenOrdersAll(i);return this.parseOrders(r,n,t,s,{status:"open",type:"limit"})}getCurrencyName(e){return e.toLowerCase()}isFiat(e){return e==="USD"||e==="EUR"||e==="GBP"}async fetchDepositAddress(e,t={}){if(this.isFiat(e))throw new A6(this.id+" fiat fetchDepositAddress() for "+e+" is not supported!");const s=this.getCurrencyName(e),i="privatePost"+this.capitalize(s)+"Address",n=await this[i](t),r=this.safeString(n,"address"),a=this.safeString2(n,"memo_id","destination_tag");return this.checkAddress(r),{currency:e,address:r,tag:a,network:void 0,info:n}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets(),this.checkAddress(s);const r={amount:t};let a,o;if(this.isFiat(e))o="privatePostWithdrawalOpen",a=this.currency(e),r.iban=s,r.account_currency=a.id;else{const c=this.getCurrencyName(e);o="privatePost"+this.capitalize(c)+"Withdrawal",e==="XRP"?i!==void 0&&(r.destination_tag=i):(e==="XLM"||e==="HBAR")&&i!==void 0&&(r.memo_id=i),r.address=s}const d=await this[o](this.extend(r,n));return this.parseTransaction(d,a)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/";a+=this.version+"/",a+=this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials();const d="BITSTAMP "+this.apiKey,c=this.uuid(),u=this.milliseconds().toString(),h="v2";let l="";n={"X-Auth":d,"X-Auth-Nonce":c,"X-Auth-Timestamp":u,"X-Auth-Version":h},s==="POST"&&(Object.keys(o).length?(r=this.urlencode(o),l="application/x-www-form-urlencoded",n["Content-Type"]=l):(r=this.urlencode({foo:"bar"}),l="application/x-www-form-urlencoded",n["Content-Type"]=l));const p=r||"",m=d+s+a.replace("https://","")+l+c+u+h+p,g=this.hmac(this.encode(m),this.encode(this.secret));n["X-Auth-Signature"]=g}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"status"),u=this.safeValue(a,"error");if(c==="error"||u!==void 0){let h=[];if(typeof u=="string")h.push(u);else if(u!==void 0){const g=Object.keys(u);for(let y=0;y<g.length;y++){const b=g[y],w=this.safeValue(u,b);Array.isArray(w)?h=this.arrayConcat(h,w):h.push(w)}}const l=this.safeValue(a,"reason",{});if(typeof l=="string")h.push(l);else{const g=this.safeValue(l,"__all__",[]);for(let y=0;y<g.length;y++)h.push(g[y])}if(this.safeString(a,"code")==="API0005")throw new Mo(this.id+" invalid signature, use the uid for the main account if you have subaccounts");const m=this.id+" "+r;for(let g=0;g<h.length;g++){const y=h[g];this.throwExactlyMatchedException(this.exceptions.exact,y,m),this.throwBroadlyMatchedException(this.exceptions.broad,y,m)}throw new $S(m)}}};const F6=me,{BadSymbol:D6,ExchangeError:ac}=oe,{TICK_SIZE:H6}=pe,G6=ke;var U6=class extends F6{describe(){return this.deepExtend(super.describe(),{id:"bitstamp1",name:"Bitstamp",countries:["GB"],rateLimit:1e3,version:"v1",has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOrder:void 0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/27786377-8c8ab57e-5fe9-11e7-8ea4-2b05b6bcceec.jpg",api:{rest:"https://www.bitstamp.net/api"},www:"https://www.bitstamp.net",doc:"https://www.bitstamp.net/api"},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},api:{public:{get:["ticker","ticker_hour","order_book","transactions","eur_usd"]},private:{post:["balance","user_transactions","open_orders","order_status","cancel_order","cancel_all_orders","buy","sell","bitcoin_deposit_address","unconfirmed_btc","ripple_withdrawal","ripple_address","withdrawal_requests","bitcoin_withdrawal"]}},precisionMode:H6,markets:{"BTC/USD":{id:"btcusd",symbol:"BTC/USD",base:"BTC",quote:"USD",baseId:"btc",quoteId:"usd",maker:.005,taker:.005,type:"spot",spot:!0},"BTC/EUR":{id:"btceur",symbol:"BTC/EUR",base:"BTC",quote:"EUR",baseId:"btc",quoteId:"eur",maker:.005,taker:.005,type:"spot",spot:!0},"EUR/USD":{id:"eurusd",symbol:"EUR/USD",base:"EUR",quote:"USD",baseId:"eur",quoteId:"usd",maker:.005,taker:.005,type:"spot",spot:!0},"XRP/USD":{id:"xrpusd",symbol:"XRP/USD",base:"XRP",quote:"USD",baseId:"xrp",quoteId:"usd",maker:.005,taker:.005,type:"spot",spot:!0},"XRP/EUR":{id:"xrpeur",symbol:"XRP/EUR",base:"XRP",quote:"EUR",baseId:"xrp",quoteId:"eur",maker:.005,taker:.005,type:"spot",spot:!0},"XRP/BTC":{id:"xrpbtc",symbol:"XRP/BTC",base:"XRP",quote:"BTC",baseId:"xrp",quoteId:"btc",maker:.005,taker:.005,type:"spot",spot:!0},"LTC/USD":{id:"ltcusd",symbol:"LTC/USD",base:"LTC",quote:"USD",baseId:"ltc",quoteId:"usd",maker:.005,taker:.005,type:"spot",spot:!0},"LTC/EUR":{id:"ltceur",symbol:"LTC/EUR",base:"LTC",quote:"EUR",baseId:"ltc",quoteId:"eur",maker:.005,taker:.005,type:"spot",spot:!0},"LTC/BTC":{id:"ltcbtc",symbol:"LTC/BTC",base:"LTC",quote:"BTC",baseId:"ltc",quoteId:"btc",maker:.005,taker:.005,type:"spot",spot:!0},"ETH/USD":{id:"ethusd",symbol:"ETH/USD",base:"ETH",quote:"USD",baseId:"eth",quoteId:"usd",maker:.005,taker:.005,type:"spot",spot:!0},"ETH/EUR":{id:"etheur",symbol:"ETH/EUR",base:"ETH",quote:"EUR",baseId:"eth",quoteId:"eur",maker:.005,taker:.005,type:"spot",spot:!0},"ETH/BTC":{id:"ethbtc",symbol:"ETH/BTC",base:"ETH",quote:"BTC",baseId:"eth",quoteId:"btc",maker:.005,taker:.005,type:"spot",spot:!0}}})}async fetchOrderBook(e,t=void 0,s={}){if(e!=="BTC/USD")throw new ac(this.id+" "+this.version+" fetchOrderBook doesn't support "+e+", use it for BTC/USD only");await this.loadMarkets();const i=await this.publicGetOrderBook(s),n=this.safeTimestamp(i,"timestamp");return this.parseOrderBook(i,e,n)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeTimestamp(e,"timestamp"),n=this.safeString(e,"vwap"),r=this.safeString(e,"volume"),a=G6.stringMul(r,n),o=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:n,open:this.safeString(e,"open"),close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:a,info:e},t)}async fetchTicker(e,t={}){if(e!=="BTC/USD")throw new ac(this.id+" "+this.version+" fetchTicker doesn't support "+e+", use it for BTC/USD only");await this.loadMarkets();const s=this.market(e),i=await this.publicGetTicker(t);return this.parseTicker(i,s)}parseTrade(e,t=void 0){const s=this.safeTimestamp2(e,"date","datetime"),i=e.type===0?"buy":"sell",n=this.safeString(e,"order_id"),r=this.safeString(e,"tid"),a=this.safeString(e,"price"),o=this.safeString(e,"amount"),d=this.safeString(e,"currency_pair");return t=this.safeMarket(d,t),this.safeTrade({id:r,info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:n,type:void 0,side:i,takerOrMaker:void 0,price:a,amount:o,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){if(e!=="BTC/USD")throw new D6(this.id+" "+this.version+" fetchTrades doesn't support "+e+", use it for BTC/USD only");await this.loadMarkets();const n=this.market(e),r={time:"minute"},a=await this.publicGetTransactions(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseBalance(e){const t={info:e},s=Object.keys(this.currencies);for(let i=0;i<s.length;i++){const n=s[i],a=this.currency(n).id,o=this.account();o.free=this.safeString(e,a+"_available"),o.used=this.safeString(e,a+"_reserved"),o.total=this.safeString(e,a+"_balance"),t[n]=o}return this.safeBalance(t)}async fetchBalance(e={}){const t=await this.privatePostBalance(e);return this.parseBalance(t)}async createOrder(e,t,s,i,n=void 0,r={}){if(t!=="limit")throw new ac(this.id+" "+this.version+" accepts limit orders only");if(e!=="BTC/USD")throw new ac(this.id+" v1 supports BTC/USD orders only");await this.loadMarkets();const a="privatePost"+this.capitalize(s),o={amount:i,price:n},d=await this[a](this.extend(o,r)),c=this.safeString(d,"id");return{info:d,id:c}}async cancelOrder(e,t=void 0,s={}){return await this.privatePostCancelOrder({id:e})}parseOrderStatus(e){const t={"In Queue":"open",Open:"open",Finished:"closed",Canceled:"canceled"};return this.safeString(t,e,e)}async fetchOrderStatus(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privatePostOrderStatus(this.extend(i,s));return this.parseOrderStatus(n)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));const a={id:n?n.id:"all"},o=await this.privatePostOpenOrdersId(this.extend(a,i));return this.parseTrades(o,n,t,s)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.implodeParams(e,i),o=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials();const d=this.nonce().toString(),c=d+this.uid+this.apiKey,u=this.encode(this.hmac(this.encode(c),this.encode(this.secret)));o=this.extend({key:this.apiKey,signature:u.toUpperCase(),nonce:d},o),r=this.urlencode(o),n={"Content-Type":"application/x-www-form-urlencoded"}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;if(this.safeString(a,"status")==="error")throw new ac(this.id+" "+this.json(a))}};const $6=me,{ArgumentsRequired:j6,BadSymbol:jS,ExchangeError:WS,ExchangeNotAvailable:W6,AuthenticationError:oc,InvalidOrder:Dr,InsufficientFunds:z6,OrderNotFound:Po,DDoSProtection:zS,PermissionDenied:K6,AddressPending:KS,OnMaintenance:X6,BadRequest:Gm,InvalidAddress:Y6}=oe,{TRUNCATE:Q6,TICK_SIZE:Z6}=pe;var M_=class extends $6{describe(){return this.deepExtend(super.describe(),{id:"bittrex",name:"Bittrex",countries:["US"],version:"v3",rateLimit:1500,certified:!1,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createMarketOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransactionFees:void 0,fetchTransactions:void 0,fetchWithdrawal:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},timeframes:{"1m":"MINUTE_1","5m":"MINUTE_5","1h":"HOUR_1","1d":"DAY_1"},hostname:"bittrex.com",urls:{logo:"https://user-images.githubusercontent.com/51840849/87153921-edf53180-c2c0-11ea-96b9-f2a9a95a455b.jpg",api:{public:"https://api.bittrex.com",private:"https://api.bittrex.com"},www:"https://bittrex.com",doc:["https://bittrex.github.io/api/v3"],fees:["https://bittrex.zendesk.com/hc/en-us/articles/115003684371-BITTREX-SERVICE-FEES-AND-WITHDRAWAL-LIMITATIONS","https://bittrex.zendesk.com/hc/en-us/articles/115000199651-What-fees-does-Bittrex-charge-"],referral:"https://bittrex.com/Account/Register?referralCode=1ZE-G0G-M3B"},api:{public:{get:["ping","currencies","currencies/{symbol}","markets","markets/tickers","markets/summaries","markets/{marketSymbol}","markets/{marketSymbol}/summary","markets/{marketSymbol}/orderbook","markets/{marketSymbol}/trades","markets/{marketSymbol}/ticker","markets/{marketSymbol}/candles/{candleInterval}/recent","markets/{marketSymbol}/candles/{candleInterval}/historical/{year}/{month}/{day}","markets/{marketSymbol}/candles/{candleInterval}/historical/{year}/{month}","markets/{marketSymbol}/candles/{candleInterval}/historical/{year}"]},private:{get:["account","account/fees/fiat","account/fees/fiat/{currencySymbol}","account/fees/trading","account/fees/trading/{marketSymbol}","account/volume","account/permissions/markets","account/permissions/markets/{marketSymbol}","account/permissions/currencies","account/permissions/currencies/{currencySymbol}","addresses","addresses/{currencySymbol}","balances","balances/{currencySymbol}","deposits/open","deposits/closed","deposits/ByTxId/{txId}","deposits/{depositId}","executions","executions/last-id","executions/{executionId}","orders/closed","orders/open","orders/{orderId}","orders/{orderId}/executions","ping","subaccounts/{subaccountId}","subaccounts","subaccounts/withdrawals/open","subaccounts/withdrawals/closed","subaccounts/deposits/open","subaccounts/deposits/closed","withdrawals/open","withdrawals/closed","withdrawals/ByTxId/{txId}","withdrawals/{withdrawalId}","withdrawals/allowed-addresses","conditional-orders/{conditionalOrderId}","conditional-orders/closed","conditional-orders/open","transfers/sent","transfers/received","transfers/{transferId}","funds-transfer-methods/{fundsTransferMethodId}"],post:["addresses","orders","subaccounts","withdrawals","conditional-orders","transfers","batch"],delete:["orders/open","orders/{orderId}","withdrawals/{withdrawalId}","conditional-orders/{conditionalOrderId}"]}},fees:{trading:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.0075"),taker:this.parseNumber("0.0075")},funding:{tierBased:!1,percentage:!1}},precisionMode:Z6,exceptions:{exact:{BAD_REQUEST:Gm,STARTDATE_OUT_OF_RANGE:Gm,APISIGN_NOT_PROVIDED:oc,APIKEY_INVALID:oc,INVALID_SIGNATURE:oc,INVALID_CURRENCY:WS,INVALID_PERMISSION:oc,INSUFFICIENT_FUNDS:z6,INVALID_CEILING_MARKET_BUY:Dr,INVALID_FIAT_ACCOUNT:Dr,INVALID_ORDER_TYPE:Dr,QUANTITY_NOT_PROVIDED:Dr,MIN_TRADE_REQUIREMENT_NOT_MET:Dr,NOT_FOUND:Po,ORDER_NOT_OPEN:Po,INVALID_ORDER:Dr,UUID_INVALID:Po,RATE_NOT_PROVIDED:Dr,INVALID_MARKET:jS,WHITELIST_VIOLATION_IP:K6,DUST_TRADE_DISALLOWED_MIN_VALUE:Dr,RESTRICTED_MARKET:jS,"We are down for scheduled maintenance, but we\u2019ll be back up shortly.":X6},broad:{throttled:zS,problem:W6}},options:{fetchTicker:{method:"publicGetMarketsMarketSymbolTicker"},fetchTickers:{method:"publicGetMarketsTickers"},fetchDeposits:{status:"ok"},fetchWithdrawals:{status:"ok"},parseOrderStatus:!1,hasAlreadyAuthenticatedSuccessfully:!1,tag:{NXT:!0,CRYPTO_NOTE_PAYMENTID:!0,BITSHAREX:!0,RIPPLE:!0,NEM:!0,STELLAR:!0,STEEM:!0},subaccountId:void 0,fetchClosedOrdersFilterBySince:!0},commonCurrencies:{BIFI:"Bifrost Finance",BTR:"BTRIPS",GMT:"GMT Token",MEME:"Memetic",MER:"Mercury",PROS:"Pros.Finance",REPV2:"REP",TON:"Tokamak Network"}})}feeToPrecision(e,t){return this.decimalToPrecision(t,Q6,this.markets[e].precision.price,this.precisionMode)}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"baseCurrencySymbol"),a=this.safeString(n,"quoteCurrencySymbol"),o=this.safeCurrencyCode(r),d=this.safeCurrencyCode(a),c=this.safeString(n,"status");s.push({id:this.safeString(n,"symbol"),symbol:o+"/"+d,base:o,quote:d,settle:void 0,baseId:r,quoteId:a,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:c==="ONLINE",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber("0.00000001"),price:this.parseNumber(this.parsePrecision(this.safeString(n,"precision","8")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(n,"minTradeSize"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:n})}return s}parseBalance(e){const t={info:e},s=this.indexBy(e,"currencySymbol"),i=Object.keys(s);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeCurrencyCode(r),o=this.account(),d=s[r];o.free=this.safeString(d,"available"),o.total=this.safeString(d,"total"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalances(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={marketSymbol:i.id};if(t!==void 0){if(t!==1&&t!==25&&t!==500)throw new Gm(this.id+" fetchOrderBook() limit argument must be undefined, 1, 25 or 500, default is 25");n.depth=t}const r=await this.publicGetMarketsMarketSymbolOrderbook(this.extend(n,s)),a=this.safeInteger(this.last_response_headers,"Sequence"),o=this.parseOrderBook(r,i.symbol,void 0,"bid","ask","rate","quantity");return o.nonce=a,o}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"symbol"),a=this.safeCurrencyCode(r),o=this.parseNumber("0.00000001"),d=this.safeNumber(n,"txFee"),c=this.safeString(n,"status");s[a]={id:r,code:a,address:this.safeString(n,"baseAddress"),info:n,type:this.safeString(n,"coinType"),name:this.safeString(n,"name"),active:c==="ONLINE",deposit:void 0,withdraw:void 0,fee:d,precision:o,limits:{amount:{min:o,max:void 0},withdraw:{min:d,max:void 0}}}}return s}parseTicker(e,t=void 0){const s=this.parse8601(this.safeString(e,"updatedAt")),i=this.safeString(e,"symbol");t=this.safeMarket(i,t,"-");const n=t.symbol,r=this.safeString(e,"percentChange"),a=this.safeString(e,"lastTradeRate");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bidRate"),bidVolume:void 0,ask:this.safeString(e,"askRate"),askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:r,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:this.safeString(e,"quoteVolume"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeValue(this.options,"fetchTickers",{}),i=this.safeString(s,"method","publicGetMarketsTickers"),n=this.safeString(t,"method",i);t=this.omit(t,"method");const r=await this[n](t),a=[];for(let o=0;o<r.length;o++){const d=this.parseTicker(r[o]);a.push(d)}return this.filterByArray(a,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={marketSymbol:s.id},n=this.safeValue(this.options,"fetchTicker",{}),r=this.safeString(n,"method","publicGetMarketsMarketSymbolTicker"),a=this.safeString(t,"method",r);t=this.omit(t,"method");const o=await this[a](this.extend(i,t));return this.parseTicker(o,s)}async fetchBidsAsks(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetMarketsTickers(t);return this.parseTickers(s,e)}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"executedAt")),i=this.safeString(e,"id"),n=this.safeString(e,"orderId"),r=this.safeString(e,"marketSymbol");t=this.safeMarket(r,t,"-");const a=this.safeString(e,"rate"),o=this.safeString(e,"quantity");let d,c=this.safeStringLower2(e,"takerSide","direction");const u=this.safeValue(e,"isTaker");u!==void 0&&(d=u?"taker":"maker",u||(c==="buy"?c="sell":c==="sell"&&(c="buy")));let h;const l=this.safeString(e,"commission");return l!==void 0&&(h={cost:l,currency:t.quote}),this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,id:i,order:n,takerOrMaker:d,type:void 0,side:c,price:a,amount:o,cost:void 0,fee:h},t)}async fetchTime(e={}){const t=await this.publicGetPing(e);return this.safeInteger(t,"serverTime")}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={marketSymbol:n.id},a=await this.publicGetMarketsMarketSymbolTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={marketSymbol:s.id},n=await this.privateGetAccountFeesTradingMarketSymbol(this.extend(i,t));return this.parseTradingFee(n,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetAccountFeesTrading(e);return this.parseTradingFees(t)}parseTradingFee(e,t=void 0){const s=this.safeString(e,"marketSymbol"),i=this.safeNumber(e,"makerRate"),n=this.safeNumber(e,"takerRate");return{info:e,symbol:this.safeSymbol(s,t),maker:i,taker:n}}parseTradingFees(e){const t={info:e};for(let s=0;s<e.length;s++){const i=this.parseTradingFee(e[s]),n=i.symbol;t[n]=i}return t}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"startsAt")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=r.baseId+"-"+r.quoteId,o={candleInterval:this.timeframes[t],marketSymbol:a};let d="publicGetMarketsMarketSymbolCandlesCandleIntervalRecent";if(s!==void 0){const u=this.milliseconds(),h=Math.abs(u-s),p=this.yyyymmdd(s).split("-"),m=this.safeInteger(p,0),g=this.safeInteger(p,1),y=this.safeInteger(p,2);t==="1d"?h>316224e5&&(d="publicGetMarketsMarketSymbolCandlesCandleIntervalHistoricalYear",o.year=m):t==="1h"?h>26784e5&&(d="publicGetMarketsMarketSymbolCandlesCandleIntervalHistoricalYearMonth",o.year=m,o.month=g):h>864e5&&(d="publicGetMarketsMarketSymbolCandlesCandleIntervalHistoricalYearMonthDay",o.year=m,o.month=g,o.day=y)}const c=await this[d](this.extend(o,n));return this.parseOHLCVs(c,r,t,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;const a=this.safeValue(i,"stop");e!==void 0&&(r=this.market(e),n.marketSymbol=r.id);let o="privateGetOrdersOpen";a&&(o="privateGetConditionalOrdersOpen");const d=this.omit(i,"stop"),c=await this[o](this.extend(n,d));return this.parseOrders(c,r,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={orderId:e},a=await this.privateGetOrdersOrderIdExecutions(this.extend(r,n));let o;return t!==void 0&&(o=this.market(t)),this.parseTrades(a,o,s,i)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o;t!==void 0&&(o=t.toUpperCase());const d=a.baseId+"-"+a.quoteId,c=this.safeValue(r,"stop"),u=this.safeNumber2(r,"triggerPrice","stopPrice"),h={marketSymbol:d};let l="privatePostOrders";if(c||u){l="privatePostConditionalOrders";const g=this.safeString(r,"operand");if(g===void 0)throw new j6(this.id+" createOrder() requires an operand parameter");const y=this.safeNumber(r,"trailingStopPercent"),b=this.safeValue(r,"orderToCreate"),w=this.safeValue(r,"orderToCancel");if(u===void 0&&(h.trailingStopPercent=this.priceToPrecision(e,y)),b){const S=o==="CEILING_LIMIT",k=o==="CEILING_MARKET",T=S||k;let I,_,N;if(T){let M;S?(_=this.priceToPrecision(e,n),M=this.safeNumber2(r,"ceiling","cost",i)):k&&(M=this.safeNumber2(r,"ceiling","cost"),M===void 0&&(n===void 0?M=i:M=i*n)),I=this.costToPrecision(e,M),N="IMMEDIATE_OR_CANCEL"}else o==="LIMIT"?(_=this.priceToPrecision(e,n),N="GOOD_TIL_CANCELLED"):N="IMMEDIATE_OR_CANCEL";h.orderToCreate={marketSymbol:d,direction:s.toUpperCase(),type:o,quantity:this.amountToPrecision(e,i),ceiling:I,limit:_,timeInForce:N,clientOrderId:this.safeString(r,"clientOrderId"),useAwards:this.safeValue(r,"useAwards")}}w&&(h.orderToCancel=w),h.triggerPrice=this.priceToPrecision(e,u),h.operand=g}else{s!==void 0&&(h.direction=s.toUpperCase()),h.type=o;const g=o==="CEILING_LIMIT",y=o==="CEILING_MARKET";if(g||y){let w;g?(h.limit=this.priceToPrecision(e,n),w=this.safeNumber2(r,"ceiling","cost",i)):y&&(w=this.safeNumber2(r,"ceiling","cost"),w===void 0&&(n===void 0?w=i:w=i*n)),h.ceiling=this.costToPrecision(e,w),h.timeInForce="IMMEDIATE_OR_CANCEL"}else h.quantity=this.amountToPrecision(e,i),o==="LIMIT"?(h.limit=this.priceToPrecision(e,n),h.timeInForce="GOOD_TIL_CANCELLED"):h.timeInForce="IMMEDIATE_OR_CANCEL"}const p=this.omit(r,["stop","stopPrice","ceiling","cost","operand","trailingStopPercent","orderToCreate","orderToCancel"]),m=await this[l](this.extend(h,p));return this.parseOrder(m,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue(s,"stop");let n={},r,a;t!==void 0&&(a=this.market(t)),i?(r="privateDeleteConditionalOrdersConditionalOrderId",n={conditionalOrderId:e}):(r="privateDeleteOrdersOrderId",n={orderId:e});const o=this.omit(s,"stop"),d=await this[r](this.extend(n,o));return this.extend(this.parseOrder(d,a),{id:e,info:d,status:"canceled"})}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;e!==void 0&&(i=this.market(e),s.marketSymbol=i.id);const n=await this.privateDeleteOrdersOpen(this.extend(s,t)),r=[];for(let a=0;a<n.length;a++){const o=this.safeValue(n[a],"result",{});r.push(o)}return this.parseOrders(r,i)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const i={txId:e};let n;t!==void 0&&(n=this.currency(t));const r=await this.privateGetDepositsByTxIdTxId(this.extend(i,s)),a=this.parseTransactions(r,n,void 0,void 0);return this.safeValue(a,0)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.currency(e),n.currencySymbol=r.id),t!==void 0){const h=parseInt(t/1e3)*1e3;n.startDate=this.iso8601(h)}s!==void 0&&(n.pageSize=s);let a;const o=this.safeValue(this.options,"fetchDeposits",{}),d=this.safeString(o,"status","ok");this.safeString(i,"status",d)==="pending"?a="privateGetDepositsOpen":a="privateGetDepositsClosed",i=this.omit(i,"status");const u=await this[a](this.extend(n,i));return this.parseTransactions(u,r,void 0,s)}async fetchPendingDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.loadMarkets(),this.fetchDeposits(e,t,s,this.extend(i,{status:"pending"}))}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const i={txId:e};let n;t!==void 0&&(n=this.currency(t));const r=await this.privateGetWithdrawalsByTxIdTxId(this.extend(i,s)),a=this.parseTransactions(r,n,void 0,void 0);return this.safeValue(a,0)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.currency(e),n.currencySymbol=r.id),t!==void 0){const h=parseInt(t/1e3)*1e3;n.startDate=this.iso8601(h)}s!==void 0&&(n.pageSize=s);let a;const o=this.safeValue(this.options,"fetchWithdrawals",{}),d=this.safeString(o,"status","ok");this.safeString(i,"status",d)==="pending"?a="privateGetWithdrawalsOpen":a="privateGetWithdrawalsClosed",i=this.omit(i,"status");const u=await this[a](this.extend(n,i));return this.parseTransactions(u,r,t,s)}async fetchPendingWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.loadMarkets(),this.fetchWithdrawals(e,t,s,this.extend(i,{status:"pending"}))}parseTransaction(e,t=void 0){const s=this.safeString2(e,"id","clientWithdrawalId"),i=this.safeNumber(e,"quantity"),n=this.safeString(e,"cryptoAddress");let r,a;this.safeString(e,"source")==="BLOCKCHAIN"?a=n:r=n;const d=this.safeString(e,"txId"),c=this.parse8601(this.safeString(e,"updatedAt")),u=this.parse8601(this.safeString(e,"createdAt")),h=u||c,l=u===void 0?"deposit":"withdrawal",p=this.safeString(e,"currencySymbol"),m=this.safeCurrencyCode(p,t);let g="pending";if(l==="deposit")g="ok";else{const b=this.safeString(e,"status");b==="ERROR_INVALID_ADDRESS"?g="failed":b==="CANCELLED"?g="canceled":b==="PENDING"?g="pending":(b==="COMPLETED"||b==="AUTHORIZED"&&d!==void 0)&&(g="ok")}let y=this.safeNumber(e,"txCost");return y===void 0&&l==="deposit"&&(y=0),{info:e,id:s,currency:m,amount:i,network:void 0,address:n,addressTo:r,addressFrom:a,tag:void 0,tagTo:void 0,tagFrom:void 0,status:g,type:l,updated:c,txid:d,timestamp:h,datetime:this.iso8601(h),fee:{currency:m,cost:y}}}parseTimeInForce(e){const t={GOOD_TIL_CANCELLED:"GTC",IMMEDIATE_OR_CANCEL:"IOC",FILL_OR_KILL:"FOK",POST_ONLY_GOOD_TIL_CANCELLED:"PO"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"marketSymbol");t=this.safeMarket(s,t,"-");const i=t.symbol,n=t.quote,r=this.safeString(e,"createdAt"),a=this.safeString(e,"updatedAt"),o=this.safeString(e,"closedAt"),d=this.safeString(e,"clientOrderId");let c;o!==void 0?c=this.parse8601(o):a&&(c=this.parse8601(a));const u=this.parse8601(r);let h=this.safeStringLower(e,"direction");if(h===void 0){let T=this.safeValue(e,"orderToCreate");T===void 0&&(T=this.safeValue(e,"orderToCancel")),h=this.safeStringLower(T,"direction")}let l=this.safeStringLower(e,"type");if(l===void 0){let T=this.safeValue(e,"orderToCreate");T===void 0&&(T=this.safeValue(e,"orderToCancel")),l=this.safeStringLower(T,"type")}let p=this.safeString(e,"quantity");if(p===void 0){let T=this.safeValue(e,"orderToCreate");T===void 0&&(T=this.safeValue(e,"orderToCancel")),p=this.safeString(T,"quantity")}let m=this.safeString(e,"limit");if(m===void 0){let T=this.safeValue(e,"orderToCreate");T===void 0&&(T=this.safeValue(e,"orderToCancel")),m=this.safeString(T,"limit")}let g=this.parseTimeInForce(this.safeString(e,"timeInForce"));if(g===void 0){let T=this.safeValue(e,"orderToCreate");T===void 0&&(T=this.safeValue(e,"orderToCancel")),g=this.parseTimeInForce(this.safeString(T,"timeInForce"))}const y=this.safeString(e,"fillQuantity"),b=this.safeNumber(e,"commission"),w=this.safeString(e,"proceeds"),S=this.safeStringLower(e,"status"),k=g==="PO";return this.safeOrder({id:this.safeString(e,"id"),clientOrderId:d,timestamp:u,datetime:this.iso8601(u),lastTradeTimestamp:c,symbol:i,type:l,timeInForce:g,postOnly:k,side:h,price:m,stopPrice:this.safeString(e,"triggerPrice"),cost:w,average:void 0,amount:p,filled:y,remaining:void 0,status:S,fee:{cost:b,currency:n},info:e,trades:void 0},t)}parseOrders(e,t=void 0,s=void 0,i=void 0,n={}){return this.options.fetchClosedOrdersFilterBySince?super.parseOrders(e,t,s,i,n):super.parseOrders(e,t,void 0,i,n)}parseOrderStatus(e){const t={CLOSED:"closed",OPEN:"open",CANCELLED:"canceled",CANCELED:"canceled"};return this.safeString(t,e,e)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue(s,"stop");let n;t!==void 0&&(n=this.market(t));let r,a;try{const o={};i?(a="privateGetConditionalOrdersConditionalOrderId",o.conditionalOrderId=e):(a="privateGetOrdersOrderId",o.orderId=e);const d=this.omit(s,"stop");r=await this[a](this.extend(o,d))}catch(o){throw this.last_json_response&&this.safeString(this.last_json_response,"message")==="UUID_INVALID"?new Po(this.id+" fetchOrder() error: "+this.last_http_response):o}return this.parseOrder(r,n)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};s!==void 0&&(n.pageSize=s),t!==void 0&&(n.startDate=this.ymdhms(t,"T")+"Z");let r;e!==void 0&&(r=this.market(e),e=r.symbol,n.marketSymbol=r.id);const a=await this.privateGetExecutions(this.extend(n,i)),o=this.parseTrades(a,r);return this.filterBySymbolSinceLimit(o,e,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeValue(i,"stop"),r={};s!==void 0&&(r.pageSize=s),t!==void 0&&(r.startDate=this.ymdhms(t,"T")+"Z");let a;e!==void 0&&(a=this.market(e),r.marketSymbol=a.base+"-"+a.quote);let o="privateGetOrdersClosed";n&&(o="privateGetConditionalOrdersClosed");const d=this.omit(i,"stop"),c=await this[o](this.extend(r,d));return this.parseOrders(c,a,t,s)}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currencySymbol:s.id},n=await this.privatePostAddresses(this.extend(i,t));let r=this.safeString(n,"cryptoAddress");const a=this.safeString(n,"status");if(!r||a==="REQUESTED")throw new KS(this.id+" the address for "+e+" is being generated (pending, not ready yet, retry again later)");let o=this.safeString(n,"cryptoAddressTag");return o===void 0&&s.type in this.options.tag&&(o=r,r=s.address),this.checkAddress(r),{currency:e,address:r,tag:o,info:n}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currencySymbol:s.id},n=await this.privateGetAddressesCurrencySymbol(this.extend(i,t));let r=this.safeString(n,"cryptoAddress");const a=this.safeString(n,"status");if(!r||a==="REQUESTED")throw new KS(this.id+" the address for "+e+" is being generated (pending, not ready yet, retry again later)");let o=this.safeString(n,"cryptoAddressTag");return o===void 0&&s.type in this.options.tag&&(o=r,r=s.address),this.checkAddress(r),{currency:e,address:r,tag:o,network:void 0,info:n}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currencySymbol:r.id,quantity:t,cryptoAddress:s};i!==void 0&&(a.cryptoAddressTag=i);const o=await this.privatePostWithdrawals(this.extend(a,n));return this.parseTransaction(o,r)}sign(e,t="v3",s="GET",i={},n=void 0,r=void 0){let a=this.implodeParams(this.urls.api[t],{hostname:this.hostname})+"/";if(t==="private"){a+=this.version+"/",this.checkRequiredCredentials(),a+=this.implodeParams(e,i),i=this.omit(i,this.extractParams(e));let o="";s==="POST"?(r=this.json(i),o=r):Object.keys(i).length&&(a+="?"+this.rawencode(i));const d=this.hash(this.encode(o),"sha512","hex"),c=this.milliseconds().toString();let u=c+a+s+d;const h=this.safeValue(this.options,"subaccountId");h!==void 0&&(u+=h);const l=this.hmac(this.encode(u),this.encode(this.secret),"sha512");n={"Api-Key":this.apiKey,"Api-Timestamp":c,"Api-Content-Hash":d,"Api-Signature":l},h!==void 0&&(n["Api-Subaccount-Id"]=h),s==="POST"&&(n["Content-Type"]="application/json")}else t==="public"&&(a+=this.version+"/"),a+=this.implodeParams(e,i),i=this.omit(i,this.extractParams(e)),Object.keys(i).length&&(a+="?"+this.urlencode(i));return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&r[0]==="{"){const c=this.id+" "+r;let u=this.safeValue(a,"success");if(u===void 0){const h=this.safeString(a,"code");if(h==="NOT_FOUND"&&s.indexOf("addresses")>=0)throw new Y6(c);h!==void 0&&(this.throwExactlyMatchedException(this.exceptions.exact,h,c),this.throwBroadlyMatchedException(this.exceptions.broad,h,c));return}if(typeof u=="string"&&(u=u==="true"),!u){const h=this.safeString(a,"message");if(h==="APIKEY_INVALID")throw this.options.hasAlreadyAuthenticatedSuccessfully?new zS(c):new oc(c);if(h==="INVALID_ORDER"){const l="cancel";if(s.indexOf(l)>=0){const m=s.split("?");if(m.length>1){const b=m[1].split("&"),w=b.length;let S;for(let k=0;k<w;k++){const I=b[k].split("=");if(I[0]==="uuid"){S=I[1];break}}throw S!==void 0?new Po(this.id+" cancelOrder "+S+" "+this.json(a)):new Po(this.id+" cancelOrder "+this.json(a))}}}throw this.throwExactlyMatchedException(this.exceptions.exact,h,c),h!==void 0&&this.throwBroadlyMatchedException(this.exceptions.broad,h,c),new WS(c)}}}};const J6=me,{ExchangeError:yn,BadSymbol:XS,AuthenticationError:nr,InsufficientFunds:YS,InvalidOrder:bn,ArgumentsRequired:dc,OrderNotFound:eL,InvalidAddress:Um,BadRequest:yi,RateLimitExceeded:QS,PermissionDenied:Aa,ExchangeNotAvailable:$m,AccountSuspended:tL,OnMaintenance:sL}=oe,{SIGNIFICANT_DIGITS:iL,DECIMAL_PLACES:jm,TRUNCATE:Wm,ROUND:nL}=pe;var P_=class extends J6{describe(){return this.deepExtend(super.describe(),{id:"bitvavo",name:"Bitvavo",countries:["NL"],rateLimit:60,version:"v2",certified:!0,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d"},urls:{logo:"https://user-images.githubusercontent.com/1294454/169202626-bd130fc5-fcf9-41bb-8d97-6093225c73cd.jpg",api:{public:"https://api.bitvavo.com",private:"https://api.bitvavo.com"},www:"https://bitvavo.com/",doc:"https://docs.bitvavo.com/",fees:"https://bitvavo.com/en/fees",referral:"https://bitvavo.com/?a=24F34952F7"},api:{public:{get:{time:1,markets:1,assets:1,"{market}/book":1,"{market}/trades":5,"{market}/candles":1,"ticker/price":1,"ticker/book":1,"ticker/24h":{cost:1,noMarket:25}}},private:{get:{account:1,order:1,orders:5,ordersOpen:{cost:1,noMarket:25},trades:5,balance:5,deposit:1,depositHistory:5,withdrawalHistory:5},post:{order:1,withdrawal:1},put:{order:1},delete:{order:1,orders:1}}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0025"),maker:this.parseNumber("0.002"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.0025")],[this.parseNumber("100000"),this.parseNumber("0.0020")],[this.parseNumber("250000"),this.parseNumber("0.0016")],[this.parseNumber("500000"),this.parseNumber("0.0012")],[this.parseNumber("1000000"),this.parseNumber("0.0010")],[this.parseNumber("2500000"),this.parseNumber("0.0008")],[this.parseNumber("5000000"),this.parseNumber("0.0006")],[this.parseNumber("10000000"),this.parseNumber("0.0005")],[this.parseNumber("25000000"),this.parseNumber("0.0004")]],maker:[[this.parseNumber("0"),this.parseNumber("0.0015")],[this.parseNumber("100000"),this.parseNumber("0.0010")],[this.parseNumber("250000"),this.parseNumber("0.0008")],[this.parseNumber("500000"),this.parseNumber("0.0006")],[this.parseNumber("1000000"),this.parseNumber("0.0005")],[this.parseNumber("2500000"),this.parseNumber("0.0004")],[this.parseNumber("5000000"),this.parseNumber("0.0004")],[this.parseNumber("10000000"),this.parseNumber("0.0003")],[this.parseNumber("25000000"),this.parseNumber("0.0003")]]}}},requiredCredentials:{apiKey:!0,secret:!0},exceptions:{exact:{101:yn,102:yi,103:QS,104:QS,105:Aa,107:$m,108:$m,109:$m,110:yi,200:yi,201:yi,202:yi,203:XS,204:yi,205:yi,206:yi,210:bn,211:bn,212:bn,213:bn,214:bn,215:bn,216:YS,217:bn,230:yn,231:yn,232:yi,233:bn,234:bn,235:yn,236:yi,240:eL,300:nr,301:nr,302:nr,303:nr,304:nr,305:nr,306:nr,307:Aa,308:nr,309:nr,310:Aa,311:Aa,312:Aa,315:yi,317:tL,400:yn,401:yn,402:Aa,403:Aa,404:sL,405:yn,406:yi,407:yn,408:YS,409:Um,410:yn,411:yi,412:Um,413:Um,414:yn},broad:{"start parameter is invalid":yi,"symbol parameter is invalid":XS,"amount parameter is invalid":bn,"orderId parameter is invalid":bn}},options:{"BITVAVO-ACCESS-WINDOW":1e4,fetchCurrencies:{expires:1e3}},precisionMode:iL,commonCurrencies:{MIOTA:"IOTA"}})}currencyToPrecision(e,t,s=void 0){return this.decimalToPrecision(t,0,this.currencies[e].precision,jm)}amountToPrecision(e,t){return this.decimalToPrecision(t,Wm,this.markets[e].precision.amount,jm)}priceToPrecision(e,t){return t=this.decimalToPrecision(t,nL,this.markets[e].precision.price,this.precisionMode),this.decimalToPrecision(t,Wm,8,jm)}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeInteger(t,"time")}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=await this.fetchCurrenciesFromCache(e),i=this.indexBy(s,"symbol"),n=[];for(let r=0;r<t.length;r++){const a=t[r],o=this.safeString(a,"market"),d=this.safeString(a,"base"),c=this.safeString(a,"quote"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),l=this.safeString(a,"status"),p=this.safeValue(i,d);n.push({id:o,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:l==="trading",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeInteger(p,"decimals",8),price:this.safeInteger(a,"pricePrecision")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(a,"minOrderInBaseAsset"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(a,"minOrderInQuoteAsset"),max:void 0}},info:a})}return n}async fetchCurrenciesFromCache(e={}){const t=this.safeValue(this.options,"fetchCurrencies",{}),s=this.safeInteger(t,"timestamp"),i=this.safeInteger(t,"expires",1e3),n=this.milliseconds();if(s===void 0||n-s>i){const r=await this.publicGetAssets(e);this.options.fetchCurrencies=this.extend(t,{response:r,timestamp:n})}return this.safeValue(this.options.fetchCurrencies,"response")}async fetchCurrencies(e={}){const t=await this.fetchCurrenciesFromCache(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"symbol"),a=this.safeCurrencyCode(r),d=this.safeValue(n,"depositStatus")==="OK",u=this.safeValue(n,"withdrawalStatus")==="OK",h=d&&u,l=this.safeString(n,"name");s[a]={id:r,info:n,code:a,name:l,active:h,deposit:d,withdraw:u,fee:this.safeNumber(n,"withdrawalFee"),precision:this.safeInteger(n,"decimals",8),limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.safeNumber(n,"withdrawalMinAmount"),max:void 0}}}}return s}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id},n=await this.publicGetTicker24h(this.extend(i,t));return this.parseTicker(n,s)}parseTicker(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeSymbol(s,t,"-"),n=this.safeInteger(e,"timestamp"),r=this.safeString(e,"last"),a=this.safeString(e,"volume"),o=this.safeString(e,"volumeQuote"),d=this.safeString(e,"open");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:this.safeString(e,"bidSize"),ask:this.safeString(e,"ask"),askVolume:this.safeString(e,"askSize"),vwap:void 0,open:d,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:a,quoteVolume:o,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTicker24h(t);return this.parseTickers(s,e)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market:n.id};s!==void 0&&(r.limit=s),t!==void 0&&(r.start=t);const a=await this.publicGetMarketTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"price"),i=this.safeString(e,"amount"),n=this.safeInteger(e,"timestamp"),r=this.safeString(e,"side"),a=this.safeString2(e,"id","fillId"),o=this.safeString(e,"market"),d=this.safeSymbol(o,t,"-"),c=this.safeValue(e,"taker");let u;c!==void 0&&(u=c?"taker":"maker");const h=this.safeString(e,"fee");let l;if(h!==void 0){const m=this.safeString(e,"feeCurrency"),g=this.safeCurrencyCode(m);l={cost:h,currency:g}}const p=this.safeString(e,"orderId");return this.safeTrade({info:e,id:a,symbol:d,timestamp:n,datetime:this.iso8601(n),order:p,type:void 0,side:r,takerOrMaker:u,price:s,amount:i,cost:void 0,fee:l},t)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetAccount(e),s=this.safeValue(t,"fees"),i=this.safeNumber(s,"maker"),n=this.safeNumber(s,"taker"),r={};for(let a=0;a<this.symbols.length;a++){const o=this.symbols[a];r[o]={info:t,symbol:o,maker:i,taker:n,percentage:!0,tierBased:!0}}return r}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={market:i.id};t!==void 0&&(n.depth=t);const r=await this.publicGetMarketBook(this.extend(n,s)),a=this.parseOrderBook(r,i.symbol);return a.nonce=this.safeInteger(r,"nonce"),a}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={market:r.id,interval:this.timeframes[t]};if(s!==void 0){const d=this.parseTimeframe(t);a.start=s,i===void 0&&(i=1440),a.end=this.sum(s,i*d*1e3)}i!==void 0&&(a.limit=i);const o=await this.publicGetMarketCandles(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"symbol"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"available"),a.used=this.safeString(i,"inOrder"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalance(e);return this.parseBalance(t)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={symbol:this.currency(e).id},n=await this.privateGetDeposit(this.extend(i,t)),r=this.safeString(n,"address"),a=this.safeString(n,"paymentId");return this.checkAddress(r),{currency:e,address:r,tag:a,network:void 0,info:n}}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={market:a.id,side:s,orderType:t},d=t==="market"||t==="stopLoss"||t==="takeProfit",c=t==="limit"||t==="stopLossLimit"||t==="takeProfitLimit",u=this.safeString(r,"timeInForce");let h=this.safeStringN(r,["triggerPrice","stopPrice","triggerAmount"]);const l=this.isPostOnly(d,!1,r),p=this.safeValue(r,"stopLossPrice"),m=this.safeValue(r,"takeProfitPrice");if(r=this.omit(r,["timeInForce","triggerPrice","stopPrice","stopLossPrice","takeProfitPrice"]),d){let w;if(n!==void 0?w=i*n:w=this.safeNumber2(r,"cost","amountQuote"),w!==void 0){const S=a.precision.price;o.amountQuote=this.decimalToPrecision(w,Wm,S,this.precisionMode)}else o.amount=this.amountToPrecision(e,i);r=this.omit(r,["cost","amountQuote"])}else c&&(o.price=this.priceToPrecision(e,n),o.amount=this.amountToPrecision(e,i));const g=m!==void 0||t==="takeProfit"||t==="takeProfitLimit";p!==void 0||h!==void 0&&!g||t==="stopLoss"||t==="stopLossLimit"?(p!==void 0&&(h=p),o.orderType=d?"stopLoss":"stopLossLimit"):g&&(m!==void 0&&(h=m),o.orderType=d?"takeProfit":"takeProfitLimit"),h!==void 0&&(o.triggerAmount=this.priceToPrecision(e,h),o.triggerType="price",o.triggerReference="lastTrade"),u!==void 0&&u!=="PO"&&(o.timeInForce=u),l&&(o.postOnly=!0);const b=await this.privatePostOrder(this.extend(o,r));return this.parseOrder(b,a)}async editOrder(e,t,s,i,n=void 0,r=void 0,a={}){await this.loadMarkets();const o=this.market(t);let d={};const c=this.safeNumber(a,"amountRemaining");if(a=this.omit(a,"amountRemaining"),r!==void 0&&(d.price=this.priceToPrecision(t,r)),n!==void 0&&(d.amount=this.amountToPrecision(t,n)),c!==void 0&&(d.amountRemaining=this.amountToPrecision(t,c)),d=this.extend(d,a),Object.keys(d).length){d.orderId=e,d.market=o.id;const u=await this.privatePutOrder(this.extend(d,a));return this.parseOrder(u,o)}else throw new dc(this.id+" editOrder() requires an amount argument, or a price argument, or non-empty params")}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new dc(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={orderId:e,market:i.id},r=await this.privateDeleteOrder(this.extend(n,s));return this.parseOrder(r,i)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;e!==void 0&&(i=this.market(e),s.market=i.id);const n=await this.privateDeleteOrders(this.extend(s,t));return this.parseOrders(n,i)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new dc(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={orderId:e,market:i.id},r=await this.privateGetOrder(this.extend(n,s));return this.parseOrder(r,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new dc(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={market:n.id};t!==void 0&&(r.start=t),s!==void 0&&(r.limit=s);const a=await this.privateGetOrders(this.extend(r,i));return this.parseOrders(a,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.market=r.id);const a=await this.privateGetOrdersOpen(this.extend(n,i));return this.parseOrders(a,r,t,s)}parseOrderStatus(e){const t={new:"open",canceled:"canceled",canceledAuction:"canceled",canceledSelfTradePrevention:"canceled",canceledIOC:"canceled",canceledFOK:"canceled",canceledMarketProtection:"canceled",canceledPostOnly:"canceled",filled:"closed",partiallyFilled:"open",expired:"canceled",rejected:"canceled",awaitingTrigger:"open"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"orderId"),i=this.safeInteger(e,"created"),n=this.safeString(e,"market");t=this.safeMarket(n,t,"-");const r=t.symbol,a=this.parseOrderStatus(this.safeString(e,"status")),o=this.safeString(e,"side"),d=this.safeString(e,"orderType"),c=this.safeString(e,"price"),u=this.safeString(e,"amount"),h=this.safeString(e,"amountRemaining"),l=this.safeString(e,"filledAmount"),p=this.safeString(e,"filledAmountQuote");let m;const g=this.safeNumber(e,"feePaid");if(g!==void 0){const k=this.safeString(e,"feeCurrency"),T=this.safeCurrencyCode(k);m={cost:g,currency:T}}const y=this.safeValue(e,"fills",[]),b=this.safeString(e,"timeInForce"),w=this.safeValue(e,"postOnly"),S=this.safeNumber(e,"triggerPrice");return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,symbol:r,type:d,timeInForce:b,postOnly:w,side:o,price:c,stopPrice:S,amount:u,cost:p,average:void 0,filled:l,remaining:h,status:a,fee:m,trades:y},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new dc(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={market:n.id};t!==void 0&&(r.start=t),s!==void 0&&(r.limit=s);const a=await this.privateGetTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={symbol:r.id,amount:this.currencyToPrecision(e,t),address:s};i!==void 0&&(a.paymentId=i);const o=await this.privatePostWithdrawal(this.extend(a,n));return this.parseTransaction(o,r)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.symbol=r.id),t!==void 0&&(n.start=t),s!==void 0&&(n.limit=s);const a=await this.privateGetWithdrawalHistory(this.extend(n,i));return this.parseTransactions(a,r,t,s,{type:"withdrawal"})}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.symbol=r.id),t!==void 0&&(n.start=t),s!==void 0&&(n.limit=s);const a=await this.privateGetDepositHistory(this.extend(n,i));return this.parseTransactions(a,r,t,s,{type:"deposit"})}parseTransactionStatus(e){const t={awaiting_processing:"pending",awaiting_email_confirmation:"pending",awaiting_bitvavo_inspection:"pending",approved:"pending",sending:"pending",in_mempool:"pending",processed:"pending",completed:"ok",canceled:"canceled"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const i=this.safeInteger(e,"timestamp"),n=this.safeString(e,"symbol"),r=this.safeCurrencyCode(n,t),a=this.parseTransactionStatus(this.safeString(e,"status")),o=this.safeNumber(e,"amount"),d=this.safeString(e,"address"),c=this.safeString(e,"txId");let u;const h=this.safeNumber(e,"fee");h!==void 0&&(u={cost:h,currency:r});let l;"success"in e||"address"in e?l="withdrawal":l="deposit";const p=this.safeString(e,"paymentId");return{info:e,id:void 0,txid:c,timestamp:i,datetime:this.iso8601(i),addressFrom:void 0,address:d,addressTo:d,tagFrom:void 0,tag:p,tagTo:p,type:l,amount:o,currency:r,status:a,updated:void 0,fee:u}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.omit(i,this.extractParams(e));let o="/"+this.version+"/"+this.implodeParams(e,i);const d=s==="GET"||s==="DELETE";if(d&&Object.keys(a).length&&(o+="?"+this.urlencode(a)),t==="private"){this.checkRequiredCredentials();let c="";d||Object.keys(a).length&&(r=this.json(a),c=r);const u=this.milliseconds().toString(),h=u+s+o+c,l=this.hmac(this.encode(h),this.encode(this.secret)),p=this.safeString(this.options,"BITVAVO-ACCESS-WINDOW","10000");n={"BITVAVO-ACCESS-KEY":this.apiKey,"BITVAVO-ACCESS-SIGNATURE":l,"BITVAVO-ACCESS-TIMESTAMP":u,"BITVAVO-ACCESS-WINDOW":p},d||(n["Content-Type"]="application/json")}return o=this.urls.api[t]+o,{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"errorCode"),u=this.safeString(a,"error");if(c!==void 0){const h=this.id+" "+r;throw this.throwBroadlyMatchedException(this.exceptions.broad,u,h),this.throwExactlyMatchedException(this.exceptions.exact,c,h),new yn(h)}}calculateRateLimiterCost(e,t,s,i,n={},r={}){return"noMarket"in n&&!("market"in i)?n.noMarket:this.safeValue(n,"cost",1)}};const rL=me,{ExchangeError:aL,BadRequest:ZS,ArgumentsRequired:cc,InsufficientFunds:JS,InvalidOrder:oL}=oe,{TICK_SIZE:dL}=pe;var cL=class extends rL{describe(){return this.deepExtend(super.describe(),{id:"bkex",name:"BKEX",countries:["BVI"],rateLimit:100,version:"v2",certified:!1,has:{CORS:void 0,spot:void 0,margin:void 0,swap:void 0,future:void 0,option:void 0,addMargin:void 0,cancelAllOrders:void 0,cancelOrder:!0,cancelOrders:!0,createDepositAddress:void 0,createLimitOrder:void 0,createMarketOrder:void 0,createOrder:!0,editOrder:void 0,fetchAccounts:void 0,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowRate:void 0,fetchBorrowRateHistory:void 0,fetchBorrowRates:void 0,fetchBorrowRatesPerSymbol:void 0,fetchCanceledOrders:void 0,fetchClosedOrder:void 0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:void 0,fetchDepositAddressesByNetwork:void 0,fetchDeposits:!0,fetchFundingHistory:void 0,fetchFundingRate:void 0,fetchFundingRateHistory:void 0,fetchFundingRates:void 0,fetchIndexOHLCV:void 0,fetchL2OrderBook:void 0,fetchLedger:void 0,fetchLedgerEntry:void 0,fetchLeverageTiers:void 0,fetchMarginMode:!1,fetchMarketLeverageTiers:void 0,fetchMarkets:!0,fetchMarkOHLCV:void 0,fetchMyTrades:void 0,fetchOHLCV:!0,fetchOpenOrder:!0,fetchOpenOrders:!0,fetchOrder:!1,fetchOrderBook:!0,fetchOrderBooks:void 0,fetchOrders:void 0,fetchOrderTrades:void 0,fetchPosition:void 0,fetchPositionMode:!1,fetchPositions:void 0,fetchPositionsRisk:void 0,fetchPremiumIndexOHLCV:void 0,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTradingLimits:void 0,fetchTransactionFee:"emulated",fetchTransactionFees:!0,fetchTransactions:void 0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,privateAPI:!0,publicAPI:!0,reduceMargin:void 0,setLeverage:void 0,setMarginMode:void 0,setPositionMode:void 0,signIn:void 0,transfer:!1,withdraw:!1},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","1w":"1w"},urls:{logo:"https://user-images.githubusercontent.com/1294454/158043180-bb079a65-69e8-45a2-b393-f094d334e610.jpg",api:{public:"https://api.bkex.com",private:"https://api.bkex.com"},www:"https://www.bkex.com/",doc:["https://bkexapi.github.io/docs/api_en.htm"],fees:["https://www.bkex.com/help/instruction/33"]},api:{public:{get:{"/common/symbols":1,"/common/currencys":1,"/common/timestamp":1,"/q/kline":1,"/q/tickers":1,"/q/ticker/price":1,"/q/depth":1,"/q/deals":1,"/contract/common/brokerInfo":1,"/contract/q/index":1,"/contract/q/depth":1,"/contract/q/depthMerged":1,"/contract/q/trades":1,"/contract/q/kline":1,"/contract/q/ticker24hr":1}},private:{get:{"/u/api/info":1,"/u/account/balance":1,"/u/wallet/address":1,"/u/wallet/depositRecord":1,"/u/wallet/withdrawRecord":1,"/u/order/openOrders":1,"/u/order/openOrder/detail":1,"/u/order/historyOrders":1,"/contract/trade/getOrder":1,"/contract/trade/openOrders":1,"/contract/trade/historyOrders":1,"/contract/trade/myTrades":1,"/contract/trade/positions":1,"/contract/u/account":1},post:{"/u/account/transfer":1,"/u/wallet/withdraw":1,"/u/order/create":1,"/u/order/cancel":1,"/u/order/batchCreate":1,"/u/order/batchCancel":1,"/contract/trade/order":1,"/contract/trade/orderCancel":1,"/contract/trade/modifyMargin":1,"/contract/ws/dataStream/create":1,"/contract/ws/dataStream/update":1,"/contract/ws/dataStream/delete":1},delete:{}}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.0015"),taker:this.parseNumber("0.002")}},options:{timeframes:{spot:{},contract:{}},defaultType:"spot",networks:{TRX:"TRC-20",TRC20:"TRC-20",ETH:"ERC-20",ERC20:"ERC-20",BEP20:"BEP-20(BSC)"}},commonCurrencies:{},precisionMode:dL,exceptions:{exact:{1005:JS},broad:{"Not Enough balance":JS,"Order does not exist":oL,"System busy, please try again later":ZS}}})}async fetchMarkets(e={}){const t=await this.publicGetCommonSymbols(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),[o,d]=a.split("_"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d);i.push({id:a,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,future:!1,swap:!1,option:!1,active:this.safeValue(r,"supportTrade"),contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"volumePrecision"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"pricePrecision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"minimumOrderSize"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(r,"minimumTradeVolume"),max:void 0}},info:r})}return i}async fetchCurrencies(e={}){const t=await this.publicGetCommonCurrencys(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.safeString(r,"name"),c=this.safeValue(r,"supportWithdraw"),u=this.safeValue(r,"supportDeposit"),h=this.safeValue(r,"supportTrade"),l=c&&u&&h;i[o]={id:a,code:o,name:d,deposit:u,withdraw:c,active:l,fee:this.safeNumber(r,"withdrawFee"),precision:void 0,limits:{amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0},withdraw:{min:this.safeNumber(r,"minWithdrawSingle"),max:this.safeNumber(r,"maxWithdrawSingle")}},info:r}}return i}async fetchTime(e={}){const t=await this.publicGetCommonTimestamp(e);return this.safeInteger(t,"data")}async fetchStatus(e={}){const t=await this.publicGetCommonTimestamp(e),s=this.safeInteger(t,"status"),i=this.safeInteger(t,"code"),n=this.safeInteger(t,"data");return{status:s===0&&i===0?"ok":s,updated:n,eta:void 0,url:void 0,info:t}}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,period:this.timeframes[t]};if(i!==void 0&&(a.size=i),s!==void 0){a.from=s,i===void 0&&(i=500);const c=this.parseTimeframe(t),u=i*c*1e3;a.to=this.sum(a.from,u)}const o=await this.publicGetQKline(a),d=this.safeValue(o,"data",[]);return this.parseOHLCVs(d,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"ts"),this.safeFloat(e,"open"),this.safeFloat(e,"high"),this.safeFloat(e,"low"),this.safeFloat(e,"close"),this.safeFloat(e,"volume")]}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetQTickers(this.extend(i,t)),r=this.safeValue(n,"data"),a=this.safeValue(r,0);return this.parseTicker(a,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};if(e!==void 0&&!Array.isArray(e))throw new ZS(this.id+" fetchTickers () symbols argument should be an array");if(e!==void 0){const r=this.marketIds(e);s.symbol=r.join(",")}const i=await this.publicGetQTickers(this.extend(s,t)),n=this.safeValue(i,"data");return this.parseTickers(n,e,t)}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeInteger(e,"ts"),r=this.safeString(e,"close");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:r,last:r,previousClose:void 0,change:void 0,percentage:this.safeString(e,"change"),average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:this.safeString(e,"quoteVolume"),info:e},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.depth=Math.min(t,50));const r=await this.publicGetQDepth(this.extend(n,s)),a=this.safeValue(r,"data");return this.parseOrderBook(a,i.symbol,void 0,"bid","ask")}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.size=Math.min(s,50));const a=await this.publicGetQDeals(this.extend(r,i)),o=this.safeValue(a,"data");return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){const s=this.safeInteger(e,"ts"),i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const n=this.parseTradeSide(this.safeString(e,"direction")),r=this.safeNumber(e,"volume"),a=this.safeNumber(e,"price"),o=void 0,d="taker";let c=this.safeString(e,"tid");return c===void 0&&(c=this.syntheticTradeId(t,s,n,r,a,o,d)),this.safeTrade({id:c,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:void 0,type:o,side:n,takerOrMaker:d,price:a,amount:r,cost:void 0,fee:void 0,info:e},t)}parseTradeSide(e){const t={B:"buy",S:"sell"};return this.safeString(t,e,e)}syntheticTradeId(e=void 0,t=void 0,s=void 0,i=void 0,n=void 0,r=void 0,a=void 0){let o="";return t!==void 0&&(o=this.numberToString(t)+"-"+this.safeString(e,"id","_"),s!==void 0&&(o+="-"+s),r!==void 0&&(o+="-"+r),a!==void 0&&(o+="-"+a),i!==void 0&&(o+="-"+this.numberToString(i)),n!==void 0&&(o+="-"+this.numberToString(n))),o}async fetchBalance(e={}){await this.loadMarkets();const t=this.omit(e,"type"),s=await this.privateGetUAccountBalance(t),i=this.safeValue(s,"data"),n=this.safeValue(i,"WALLET",[]),r={info:n};for(let a=0;a<n.length;a++){const o=n[a],d=o.currency,c=this.safeCurrencyCode(d),u=this.account();u.free=this.safeNumber(o,"available"),u.used=this.safeNumber(o,"frozen"),u.total=this.safeNumber(o,"total"),r[c]=u}return this.safeBalance(r)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=await this.privateGetUWalletAddress(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseDepositAddress(r,s)}parseDepositAddress(e,t=void 0){const s=this.safeValue(e,0),i=this.safeString(s,"address"),n=this.safeString(s,"memo"),r=this.safeString(s,"currency");return t=this.safeCurrency(r,t),{currency:t.code,address:i,tag:n,network:void 0,info:e}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new cc(this.id+" fetchDeposits() requires code argument");await this.loadMarkets();const n=this.currency(e),r={currency:n.id};if(t!==void 0){r.startTime=t;const c=this.milliseconds();r.endTime=c}s!==void 0&&(r.Size=s);const a=await this.privateGetUWalletDepositRecord(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"data",[]);for(let c=0;c<d.length;c++)d[c].transactType="deposit";return this.parseTransactions(d,n,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new cc(this.id+" fetchWithdrawals() requires code argument");await this.loadMarkets();const n=this.currency(e),r={currency:n.id};if(t!==void 0){r.startTime=t;const c=this.milliseconds();r.endTime=c}s!==void 0&&(r.Size=s);const a=await this.privateGetUWalletWithdrawRecord(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"data",[]);for(let c=0;c<d.length;c++)d[c].transactType="withdrawal";return this.parseTransactions(d,n,t,s,i)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeNumber(e,"volume"),n=this.safeValue(e,"toAddress",{}),r=this.safeString(e,"fromAddress"),a=this.safeString(e,"hash"),o=this.safeString(e,"transactType"),d=this.safeInteger(e,"createTime"),c=this.safeString(e,"currency"),u=this.safeCurrencyCode(c,t),h=this.parseTransactionStatus(this.safeString(e,"status"));return{id:s,currency:u,amount:i,network:void 0,address:n,addressTo:n,addressFrom:r,tag:void 0,tagTo:void 0,tagFrom:void 0,status:h,type:o,updated:void 0,txid:a,timestamp:d,datetime:this.iso8601(d),fee:{currency:u,cost:void 0},info:e}}parseTransactionStatus(e){const t={"-1":"failed",0:"ok",3:"pending",5:"pending"};return this.safeString(t,e,e)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=s==="buy"?"BID":"ASK",d={symbol:a.id,type:t.toUpperCase(),volume:this.amountToPrecision(e,i),direction:o};t!=="market"&&n!==void 0&&(d.price=this.priceToPrecision(e,n));const c=await this.privatePostUOrderCreate(this.extend(d,r));return this.parseOrder(c,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=t!==void 0?this.market(t):void 0,n={orderId:e},r=await this.privatePostUOrderCancel(this.extend(n,s));return this.parseOrder(r,i)}async cancelOrders(e,t=void 0,s={}){if(!Array.isArray(e))throw new cc(this.id+" cancelOrders() ids argument should be an array");await this.loadMarkets();const i={orders:this.json(e)},n=await this.privatePostUOrderBatchCancel(this.extend(i,s)),r=this.safeValue(n,"data"),a=this.safeValue(r,"results"),o=t!==void 0?this.market(t):void 0;return this.parseOrders(a,o,void 0,void 0,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new cc(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.size=s);const a=await this.privateGetUOrderOpenOrders(this.extend(r,i)),o=this.safeValue(a,"data"),d=this.safeValue(o,"data");return this.parseOrders(d,n,t,s,i)}async fetchOpenOrder(e,t=void 0,s={}){const i={orderId:e},n=await this.privateGetUOrderOpenOrderDetail(this.extend(i,s)),r=this.safeValue(n,"data"),a=t!==void 0?this.market(t):void 0;return this.parseOrder(r,a)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new cc(this.id+" fetchClosedOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.size=s),t!==void 0&&(r.startTime=t);const a=await this.privateGetUOrderHistoryOrders(this.extend(r,i)),o=this.safeValue(a,"data"),d=this.safeValue(o,"data");return this.parseOrders(d,n,t,s,i)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"createdTime"),i=this.safeInteger(e,"updateTime"),n=this.safeString(e,"dealVolume"),r=this.parseOrderSide(this.safeString(e,"direction")),a=this.safeString2(e,"id","data"),o=this.safeString(e,"price"),d=this.safeString(e,"status"),c=this.safeString(e,"type"),u=this.parseOrderType(c);let h=!1;c==="LIMIT_MAKER"&&(h=!0);let l;s!==void 0&&(l=this.parseOrderStatus(d));const p=this.safeString(e,"symbol");t=this.safeMarket(p,t);const m=this.safeString(e,"totalVolume"),g=this.safeNumber(e,"stopPrice"),y=this.safeString(e,"dealAvgPrice");return this.safeOrder({id:a,clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:i,status:l,symbol:t.symbol,type:u,timeInForce:void 0,postOnly:h,side:r,price:o,stopPrice:g,average:y,amount:m,filled:n,remaining:void 0,cost:void 0,trades:void 0,fee:void 0,info:e},t)}parseOrderSide(e){const t={BID:"buy",ASK:"sell"};return this.safeString(t,e,e)}parseOrderStatus(e){const t={0:"open",1:"closed",2:"canceled",3:"open"};return this.safeString(t,e,e)}parseOrderType(e){const t={MARKET:"market",LIMIT:"limit",LIMIT_MAKER:"limit",STOP_LIMIT:"limit"};return this.safeString(t,e,e)}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetCommonCurrencys(t);return this.parseTransactionFees(s,e)}parseTransactionFees(e,t=void 0){const s=this.safeValue(e,"data"),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrency(a),d=this.safeString(o,"code");(t===void 0||this.inArray(d,t))&&(i[d]={withdraw:this.parseTransactionFee(r),deposit:void 0,info:r})}return i}parseTransactionFee(e,t=void 0){return this.safeNumber(e,"withdrawFee")}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/"+this.version+this.implodeParams(e,i);i=this.omit(i,this.extractParams(e));let o="";if(Object.keys(i).length&&(o=this.rawencode(this.keysort(i)),s==="GET"&&(a+="?"+o)),t==="private"){this.checkRequiredCredentials();const d=this.hmac(this.encode(o),this.encode(this.secret),"sha256");n={"Cache-Control":"no-cache","Content-type":"application/x-www-form-urlencoded",X_ACCESS_KEY:this.apiKey,X_SIGNATURE:d},s!=="GET"&&(r=o)}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0||this.safeValue(a,"msg")==="success")return;const u=this.safeString(a,"code");if(u!=="0"){const h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwBroadlyMatchedException(this.exceptions.broad,r,h),new aL(h)}}};const uL=me,{TICK_SIZE:fL}=pe,Ba=ke;var hL=class extends uL{describe(){return this.deepExtend(super.describe(),{id:"bl3p",name:"BL3P",countries:["NL"],rateLimit:1e3,version:"1",comment:"An exchange market by BitonicNL",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchOpenInterestHistory:!1,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/28501752-60c21b82-6feb-11e7-818b-055ee6d0e754.jpg",api:{rest:"https://api.bl3p.eu"},www:"https://bl3p.eu",doc:["https://github.com/BitonicNL/bl3p-api/tree/master/docs","https://bl3p.eu/api","https://bitonic.nl/en/api"]},api:{public:{get:["{market}/ticker","{market}/orderbook","{market}/trades"]},private:{post:["{market}/money/depth/full","{market}/money/order/add","{market}/money/order/cancel","{market}/money/order/result","{market}/money/orders","{market}/money/orders/history","{market}/money/trades/fetch","GENMKT/money/info","GENMKT/money/deposit_address","GENMKT/money/new_deposit_address","GENMKT/money/wallet/history","GENMKT/money/withdraw"]}},markets:{"BTC/EUR":{id:"BTCEUR",symbol:"BTC/EUR",base:"BTC",quote:"EUR",baseId:"BTC",quoteId:"EUR",maker:.0025,taker:.0025,type:"spot",spot:!0}},precisionMode:fL})}parseBalance(e){const t=this.safeValue(e,"data",{}),s=this.safeValue(t,"wallets",{}),i={info:t},n=Object.keys(this.currencies);for(let r=0;r<n.length;r++){const a=n[r],d=this.currency(a).id,c=this.safeValue(s,d,{}),u=this.safeValue(c,"available",{}),h=this.safeValue(c,"balance",{}),l=this.account();l.free=this.safeString(u,"value"),l.total=this.safeString(h,"value"),i[a]=l}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGENMKTMoneyInfo(e);return this.parseBalance(t)}parseBidAsk(e,t=0,s=1){const i=this.safeString(e,t),n=this.safeString(e,s);return[this.parseNumber(Ba.stringDiv(i,"100000.0")),this.parseNumber(Ba.stringDiv(n,"100000000.0"))]}async fetchOrderBook(e,t=void 0,s={}){const i=this.market(e),n={market:i.id},r=await this.publicGetMarketOrderbook(this.extend(n,s)),a=this.safeValue(r,"data");return this.parseOrderBook(a,i.symbol,void 0,"bids","asks","price_int","amount_int")}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeTimestamp(e,"timestamp"),n=this.safeString(e,"last"),r=this.safeValue(e,"volume",{});return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(r,"24h"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){const s=this.market(e),i={market:s.id},n=await this.publicGetMarketTicker(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"trade_id"),i=this.safeInteger(e,"date"),n=this.safeString(e,"price_int"),r=this.safeString(e,"amount_int");return t=this.safeMarket(void 0,t),this.safeTrade({id:s,info:e,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,type:void 0,side:void 0,order:void 0,takerOrMaker:void 0,price:Ba.stringDiv(n,"100000"),amount:Ba.stringDiv(r,"100000000"),cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){const n=this.market(e),r=await this.publicGetMarketTrades(this.extend({market:n.id},i));return this.parseTrades(r.data.trades,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostGENMKTMoneyInfo(e),s=this.safeValue(t,"data",{}),i=this.safeString(s,"trade_fee"),n=this.parseNumber(Ba.stringDiv(i,"100")),r={};for(let a=0;a<this.symbols.length;a++){const o=this.symbols[a];r[o]={info:s,symbol:o,maker:n,taker:n,percentage:!0,tierBased:!1}}return r}async createOrder(e,t,s,i,n=void 0,r={}){const a=this.market(e),o=this.numberToString(i),d=this.numberToString(n),c={market:a.id,amount_int:parseInt(Ba.stringMul(o,"100000000")),fee_currency:a.quote,type:s==="buy"?"bid":"ask"};t==="limit"&&(c.price_int=parseInt(Ba.stringMul(d,"100000.0")));const u=await this.privatePostMarketMoneyOrderAdd(this.extend(c,r)),h=this.safeString(u.data,"order_id");return{info:u,id:h}}async cancelOrder(e,t=void 0,s={}){const i={order_id:e};return await this.privatePostMarketMoneyOrderCancel(this.extend(i,s))}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.implodeParams(e,i);let o=this.urls.api.rest+"/"+this.version+"/"+a;const d=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(d).length&&(o+="?"+this.urlencode(d));else{this.checkRequiredCredentials();const c=this.nonce();r=this.urlencode(this.extend({nonce:c},d));const u=this.base64ToBinary(this.secret),h=a+"\0"+r,l=this.hmac(this.encode(h),u,"sha512","base64");n={"Content-Type":"application/x-www-form-urlencoded","Rest-Key":this.apiKey,"Rest-Sign":l}}return{url:o,method:s,body:r,headers:n}}};const lL=me,{ExchangeError:pL,AuthenticationError:mL,OrderNotFound:gL,InsufficientFunds:yL,ArgumentsRequired:bL}=oe,{TICK_SIZE:wL}=pe,kf=ke;var SL=class extends lL{describe(){return this.deepExtend(super.describe(),{id:"blockchaincom",secret:void 0,name:"Blockchain.com",countries:["LX"],rateLimit:500,version:"v3",has:{CORS:!1,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchCanceledOrders:!0,fetchClosedOrders:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchL2OrderBook:!0,fetchL3OrderBook:!0,fetchLedger:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!1,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,fetchWithdrawalWhitelist:!0,transfer:!1,withdraw:!0},timeframes:void 0,urls:{logo:"https://user-images.githubusercontent.com/1294454/147515585-1296e91b-7398-45e5-9d32-f6121538533f.jpeg",test:{public:"https://testnet-api.delta.exchange",private:"https://testnet-api.delta.exchange"},api:{public:"https://api.blockchain.com/v3/exchange",private:"https://api.blockchain.com/v3/exchange"},www:"https://blockchain.com",doc:["https://api.blockchain.com/v3"],fees:"https://exchange.blockchain.com/fees"},api:{public:{get:{tickers:1,"tickers/{symbol}":1,symbols:1,"symbols/{symbol}":1,"l2/{symbol}":1,"l3/{symbol}":1}},private:{get:{fees:1,orders:1,"orders/{orderId}":1,trades:1,fills:1,deposits:1,"deposits/{depositId}":1,accounts:1,"accounts/{account}/{currency}":1,whitelist:1,"whitelist/{currency}":1,withdrawals:1,"withdrawals/{withdrawalId}":1},post:{orders:1,"deposits/{currency}":1,withdrawals:1},delete:{orders:1,"orders/{orderId}":1}}},fees:{trading:{feeSide:"get",tierBased:!0,percentage:!0,tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.004")],[this.parseNumber("10000"),this.parseNumber("0.0022")],[this.parseNumber("50000"),this.parseNumber("0.002")],[this.parseNumber("100000"),this.parseNumber("0.0018")],[this.parseNumber("500000"),this.parseNumber("0.0018")],[this.parseNumber("1000000"),this.parseNumber("0.0018")],[this.parseNumber("2500000"),this.parseNumber("0.0018")],[this.parseNumber("5000000"),this.parseNumber("0.0016")],[this.parseNumber("25000000"),this.parseNumber("0.0014")],[this.parseNumber("100000000"),this.parseNumber("0.0011")],[this.parseNumber("500000000"),this.parseNumber("0.0008")],[this.parseNumber("1000000000"),this.parseNumber("0.0006")]],maker:[[this.parseNumber("0"),this.parseNumber("0.002")],[this.parseNumber("10000"),this.parseNumber("0.0012")],[this.parseNumber("50000"),this.parseNumber("0.001")],[this.parseNumber("100000"),this.parseNumber("0.0008")],[this.parseNumber("500000"),this.parseNumber("0.0007000000000000001")],[this.parseNumber("1000000"),this.parseNumber("0.0006")],[this.parseNumber("2500000"),this.parseNumber("0.0005")],[this.parseNumber("5000000"),this.parseNumber("0.0004")],[this.parseNumber("25000000"),this.parseNumber("0.0003")],[this.parseNumber("100000000"),this.parseNumber("0.0002")],[this.parseNumber("500000000"),this.parseNumber("0.0001")],[this.parseNumber("1000000000"),this.parseNumber("0")]]}}},requiredCredentials:{apiKey:!1,secret:!0},precisionMode:wL,exceptions:{exact:{401:mL,404:gL},broad:{}}})}async fetchMarkets(e={}){const t=await this.publicGetSymbols(e),s=Object.keys(t),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeValue(t,r),o=this.safeString(a,"base_currency"),d=this.safeString(a,"counter_currency"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d),h=this.safeNumber(a,"id");let l;this.safeString(a,"status")==="open"?l=!0:l=!1;const m=this.safeString(a,"min_price_increment"),g=this.safeString(a,"min_price_increment_scale"),y=this.parsePrecision(g),b=kf.stringMul(m,y),w=this.safeString(a,"lot_size"),S=this.safeString(a,"lot_size_scale"),k=this.parsePrecision(S),T=kf.stringMul(w,k),I=this.safeString(a,"min_order_size"),_=this.safeString(a,"min_order_size_scale"),N=this.parsePrecision(_),M=kf.stringMul(I,N),x=this.parseNumber(M);let v;if(v=this.safeString(a,"max_order_size"),v!=="0"){const O=this.safeString(a,"max_order_size_scale"),A=this.parsePrecision(O),V=kf.stringMul(v,A);v=this.parseNumber(V)}else v=void 0;i.push({info:a,id:r,numericId:h,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:l,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(T),price:this.parseNumber(b)},limits:{leverage:{min:void 0,max:void 0},amount:{min:x,max:v},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}}})}return i}async fetchOrderBook(e,t=void 0,s={}){return await this.fetchL3OrderBook(e,t,s)}async fetchL3OrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.depth=t);const r=await this.publicGetL3Symbol(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"bids","asks","px","qty")}async fetchL2OrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.depth=t);const r=await this.publicGetL2Symbol(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"bids","asks","px","qty")}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t,"-"),n=this.safeString(e,"last_trade_price"),r=this.safeString(e,"volume_24h"),a=this.safeString(e,"price_24h");return this.safeTicker({symbol:i,timestamp:void 0,datetime:void 0,high:void 0,low:void 0,bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:a,close:void 0,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetTickersSymbol(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickers(t);return this.parseTickers(s,e)}parseOrderState(e){const t={OPEN:"open",REJECTED:"rejected",FILLED:"closed",CANCELED:"canceled",PART_FILLED:"open",EXPIRED:"expired"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"clOrdId"),i=this.safeStringLower(e,"ordType"),n=this.safeString(e,"ordStatus"),r=this.parseOrderState(n),a=this.safeStringLower(e,"side"),o=this.safeString(e,"symbol"),d=this.safeSymbol(o,t,"-"),c=this.safeString(e,"exOrdId"),u=i!=="market"?this.safeString(e,"price"):void 0,h=this.safeNumber(e,"avgPx"),l=this.safeInteger(e,"timestamp"),p=this.iso8601(l),m=this.safeString(e,"cumQty"),g=this.safeString(e,"leavesQty");return this.safeOrder({id:c,clientOrderId:s,datetime:p,timestamp:l,lastTradeTimestamp:void 0,status:r,symbol:d,type:i,timeInForce:void 0,side:a,price:u,average:h,amount:void 0,filled:m,remaining:g,cost:void 0,trades:[],fees:{},info:e})}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),d=this.safeString(r,"ordType",t).toUpperCase(),c=this.safeString2(r,"clientOrderId","clOrdId",this.uuid16());r=this.omit(r,["ordType","clientOrderId","clOrdId"]);const u={ordType:d,symbol:a.id,side:s.toUpperCase(),orderQty:this.amountToPrecision(e,i),clOrdId:c},h=this.safeValue2(r,"stopPx","stopPrice");if(r=this.omit(r,["stopPx","stopPrice"]),(d==="STOP"||d==="STOPLIMIT")&&h===void 0)throw new bL(this.id+" createOrder() requires a stopPx or stopPrice param for a "+d+" order");h!==void 0&&(d==="MARKET"?u.ordType="STOP":d==="LIMIT"&&(u.ordType="STOPLIMIT"));let l=!1,p=!1;(u.ordType==="LIMIT"||u.ordType==="STOPLIMIT")&&(l=!0),(u.ordType==="STOP"||u.ordType==="STOPLIMIT")&&(p=!0),l&&(u.price=this.priceToPrecision(e,n)),p&&(u.stopPx=this.priceToPrecision(e,h));const m=await this.privatePostOrders(this.extend(u,r));return this.parseOrder(m,a)}async cancelOrder(e,t=void 0,s={}){const i={orderId:e},n=await this.privateDeleteOrdersOrderId(this.extend(i,s));return{id:e,info:n}}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};if(e!==void 0){const n=this.marketId(e);s.symbol=n}const i=await this.privateDeleteOrders(this.extend(s,t));return{symbol:e,info:i}}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetFees(e),s=this.safeNumber(t,"makerRate"),i=this.safeNumber(t,"takerRate"),n={};for(let r=0;r<this.symbols.length;r++){const a=this.symbols[r];n[a]={info:t,symbol:a,maker:s,taker:i}}return n}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){const n="CANCELED";return await this.fetchOrdersByState(n,e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n="FILLED";return await this.fetchOrdersByState(n,e,t,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n="OPEN";return await this.fetchOrdersByState(n,e,t,s,i)}async fetchOrdersByState(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={status:e,limit:100};let a;t!==void 0&&(a=this.market(t),r.symbol=a.id);const o=await this.privateGetOrders(this.extend(r,n));return this.parseOrders(o,a,s,i)}parseTrade(e,t=void 0){const s=this.safeString(e,"exOrdId"),i=this.safeString(e,"tradeId"),n=this.safeString(e,"side").toLowerCase(),r=this.safeString(e,"symbol"),a=this.safeString(e,"price"),o=this.safeString(e,"qty"),d=this.safeInteger(e,"timestamp"),c=this.iso8601(d);t=this.safeMarket(r,t,"-");const u=t.symbol;let h;const l=this.safeString(e,"fee");if(l!==void 0){const p=t.quote;h={cost:l,currency:p}}return this.safeTrade({id:i,timestamp:d,datetime:c,symbol:u,order:s,type:void 0,side:n,takerOrMaker:void 0,price:a,amount:o,cost:void 0,fee:h,info:e},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};s!==void 0&&(n.limit=s);let r;e!==void 0&&(n.symbol=this.marketId(e),r=this.market(e));const a=await this.privateGetFills(this.extend(n,i));return this.parseTrades(a,r,t,s,i)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=await this.privatePostDepositsCurrency(this.extend(i,t)),r=this.safeString(n,"address");let a,o;r!==void 0&&([o,a]=r.split(":"));const d={info:n};return d.currency=s.code,d.address=o,a!==void 0&&(d.tag=a),d}parseTransactionState(e){const t={COMPLETED:"ok",REJECTED:"failed",PENDING:"pending",FAILED:"failed",REFUNDED:"refunded"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){let s,i;const n=this.safeNumber(e,"amount"),r=this.safeInteger(e,"timestamp"),a=this.safeString(e,"currency"),o=this.safeCurrencyCode(a,t),d=this.safeString(e,"state");"depositId"in e?(s="deposit",i=this.safeString(e,"depositId")):"withdrawalId"in e&&(s="withdrawal",i=this.safeString(e,"withdrawalId"));const c=s==="withdrawal"?this.safeNumber(e,"fee"):void 0;let u;c!==void 0&&(u={currency:o,cost:c});const h=this.safeString(e,"address"),l=this.safeString(e,"txhash");return{info:e,id:i,txid:l,timestamp:r,datetime:this.iso8601(r),network:void 0,addressFrom:void 0,address:h,addressTo:h,tagFrom:void 0,tag:void 0,tagTo:void 0,type:s,amount:n,currency:o,status:this.parseTransactionState(d),updated:void 0,comment:void 0,fee:u}}async fetchWithdrawalWhitelist(e={}){await this.loadMarkets();const t=await this.privateGetWhitelist(),s=[];for(let i=0;i<t.length;i++){const n=t[i];s.push({beneficiaryId:this.safeString(n,"whitelistId"),name:this.safeString(n,"name"),currency:this.safeString(n,"currency"),info:n})}return s}async fetchWithdrawalWhitelistByCurrency(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.privateGetWhitelistCurrency(this.extend(i,t)),r=[];for(let a=0;a<n.length;a++){const o=n[a];r.push({beneficiaryId:this.safeString(o,"whitelistId"),name:this.safeString(o,"name"),currency:this.safeString(o,"currency"),info:o})}return r}async withdraw(e,t,s,i=void 0,n={}){await this.loadMarkets();const r=this.currency(e),a={amount:t,currency:r.id,beneficiary:s,sendMax:!1},o=await this.privatePostWithdrawals(this.extend(a,n));return this.parseTransaction(o,r)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.from=t);let r;e!==void 0&&(r=this.currency(e));const a=await this.privateGetWithdrawals(this.extend(n,i));return this.parseTransactions(a,r,t,s)}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const i={withdrawalId:e},n=await this.privateGetWithdrawalsWithdrawalId(this.extend(i,s));return this.parseTransaction(n)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.from=t);let r;e!==void 0&&(r=this.currency(e));const a=await this.privateGetDeposits(this.extend(n,i));return this.parseTransactions(a,r,t,s)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const n={depositId:this.safeString(s,"depositId",e)},r=await this.privateGetDepositsDepositId(this.extend(n,s));return this.parseTransaction(r)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"account","primary");e=this.omit(e,"account");const s={account:t},i=await this.privateGetAccounts(this.extend(s,e)),n=this.safeValue(i,t);if(n===void 0)throw new pL(this.id+' fetchBalance() could not find the "'+t+'" account');const r={info:i};for(let a=0;a<n.length;a++){const o=n[a],d=this.safeString(o,"currency"),c=this.safeCurrencyCode(d),u=this.account();u.free=this.safeString(o,"available"),u.total=this.safeString(o,"balance"),r[c]=u}return this.safeBalance(r)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e},n=await this.privateGetOrdersOrderId(this.extend(i,s));return this.parseOrder(n)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a="/"+this.implodeParams(e,i);let o=this.urls.api[t]+a;const d=this.omit(i,this.extractParams(e));return t==="public"?Object.keys(d).length&&(o+="?"+this.urlencode(d)):t==="private"&&(this.checkRequiredCredentials(),n={"X-API-Token":this.secret},s==="GET"?Object.keys(d).length&&(o+="?"+this.urlencode(d)):(r=this.json(d),n["Content-Type"]="application/json")),{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"text");if(c!==void 0&&c==="Insufficient Balance")throw new yL(this.id+" "+r);const u=this.safeString(a,"status"),h=this.safeString(a,"error");if(e!==void 0){const l=this.id+" "+this.json(a);this.throwExactlyMatchedException(this.exceptions.exact,u,l),this.throwBroadlyMatchedException(this.exceptions.broad,h,l)}}};const kL=me,{ExchangeError:vL,AuthenticationError:TL,DDoSProtection:OL,InvalidOrder:IL,InsufficientFunds:xL}=oe,{TICK_SIZE:_L}=pe,zm=ke;var CL=class extends kL{describe(){return this.deepExtend(super.describe(),{id:"btcalpha",name:"BTC-Alpha",countries:["US"],version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchDeposit:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchL2OrderBook:!0,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:void 0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!1},timeframes:{"5m":"5","15m":"15","30m":"30","1h":"60","4h":"240","1d":"D"},urls:{logo:"https://user-images.githubusercontent.com/1294454/42625213-dabaa5da-85cf-11e8-8f99-aa8f8f7699f0.jpg",api:{rest:"https://btc-alpha.com/api"},www:"https://btc-alpha.com",doc:"https://btc-alpha.github.io/api-docs",fees:"https://btc-alpha.com/fees/",referral:"https://btc-alpha.com/?r=123788"},api:{public:{get:["currencies/","pairs/","orderbook/{pair_name}","exchanges/","charts/{pair}/{type}/chart/"]},private:{get:["wallets/","orders/own/","order/{id}/","exchanges/own/","deposits/","withdraws/"],post:["order/","order-cancel/"]}},fees:{trading:{maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")},funding:{withdraw:{}}},commonCurrencies:{CBC:"Cashbery"},precisionMode:_L,exceptions:{exact:{},broad:{"Out of balance":xL}}})}async fetchMarkets(e={}){const t=await this.publicGetPairs(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"name"),a=this.safeString(n,"currency1"),o=this.safeString(n,"currency2"),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o),u=this.safeString(n,"price_precision"),h=this.parsePrecision(u),l=this.safeString(n,"minimum_order_size");s.push({id:r,symbol:d+"/"+c,base:d,quote:c,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(n,"amount_precision"))),price:this.parseNumber(this.parsePrecision(u))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.parseNumber(l),max:this.safeNumber(n,"maximum_order_size")},price:{min:this.parseNumber(h),max:void 0},cost:{min:this.parseNumber(zm.stringMul(h,l)),max:void 0}},info:n})}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair_name:i.id};t&&(n.limit_sell=t,n.limit_buy=t);const r=await this.publicGetOrderbookPairName(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"buy","sell","price","amount")}parseBidsAsks(e,t=0,s=1){const i=[];for(let n=0;n<e.length;n++){const r=e[n];r&&i.push(this.parseBidAsk(r,t,s))}return i}parseTrade(e,t=void 0){const s=this.safeString(e,"pair");t=this.safeMarket(s,t,"_");const i=this.safeString(e,"timestamp"),n=this.parseNumber(zm.stringMul(i,"1000000")),r=this.safeString(e,"price"),a=this.safeString(e,"amount"),o=this.safeString(e,"id"),d=this.safeString2(e,"my_side","type");return this.safeTrade({id:o,info:e,timestamp:n,datetime:this.iso8601(n),symbol:t.symbol,order:o,type:"limit",side:d,takerOrMaker:void 0,price:r,amount:a,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.pair=n.id),s!==void 0&&(r.limit=s);const a=await this.publicGetExchanges(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r=await this.privateGetDeposits(i);return this.parseTransactions(r,n,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.currency_id=n.id);const a=await this.privateGetWithdraws(this.extend(r,i));return this.parseTransactions(a,n,t,s,{type:"withdrawal"})}parseTransaction(e,t=void 0){const s=this.safeTimestamp(e,"timestamp"),i=this.safeString(e,"currency"),n=this.safeString(e,"status");return{id:this.safeString(e,"id"),info:e,timestamp:s,datetime:this.iso8601(s),network:void 0,address:void 0,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,currency:this.safeCurrencyCode(i,t),amount:this.safeNumber(e,"amount"),txid:void 0,type:void 0,status:this.parseTransactionStatus(n),comment:void 0,fee:void 0,updated:void 0}}parseTransactionStatus(e){const t={10:"pending",20:"pending",30:"ok",40:"failed",50:"canceled"};return this.safeString(t,e,e)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"time"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="5m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id,type:this.timeframes[t]};i!==void 0&&(a.limit=i),s!==void 0&&(a.since=parseInt(s/1e3));const o=await this.publicGetChartsPairTypeChart(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.used=this.safeString(i,"reserve"),a.total=this.safeString(i,"balance"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetWallets(e);return this.parseBalance(t)}parseOrderStatus(e){const t={1:"open",2:"canceled",3:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"pair");t=this.safeMarket(s,t,"_");const i=t.symbol,n=this.safeValue(e,"success",!1);let r;n?r=this.safeTimestamp(e,"date"):r=this.safeInteger(e,"date");const a=this.safeString(e,"price"),o=this.safeString(e,"amount"),d=this.safeString(e,"amount_filled"),c=this.safeString(e,"amount_original"),u=this.parseOrderStatus(this.safeString(e,"status")),h=this.safeString2(e,"oid","id"),l=this.safeValue(e,"trades"),p=this.safeString2(e,"my_side","type");return this.safeOrder({id:h,clientOrderId:void 0,datetime:this.iso8601(r),timestamp:r,status:u,symbol:i,type:"limit",timeInForce:void 0,postOnly:void 0,side:p,price:a,stopPrice:void 0,cost:void 0,amount:c,filled:d,remaining:o,trades:l,fee:void 0,info:e,lastTradeTimestamp:void 0,average:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={pair:a.id,type:s,amount:i,price:this.priceToPrecision(e,n)},d=await this.privatePostOrder(this.extend(o,r));if(!d.success)throw new IL(this.id+" "+this.json(d));const c=this.parseOrder(d,a),u=c.amount.toString();return i=zm.stringGt(u,"0")?c.amount:i,this.extend(c,{amount:this.parseNumber(i)})}async cancelOrder(e,t=void 0,s={}){const i={order:e};return await this.privatePostOrderCancel(this.extend(i,s))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetOrderId(this.extend(i,s));return this.parseOrder(n)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.pair=r.id),s!==void 0&&(n.limit=s);const a=await this.privateGetOrdersOwn(this.extend(n,i));return this.parseOrders(a,r,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"1"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"3"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};if(e!==void 0){const a=this.market(e);n.pair=a.id}s!==void 0&&(n.limit=s);const r=await this.privateGetExchangesOwn(this.extend(n,i));return this.parseTrades(r,void 0,t,s)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.urlencode(this.keysort(this.omit(i,this.extractParams(e))));let o=this.urls.api.rest+"/";if(e!=="charts/{pair}/{type}/chart/"&&(o+="v1/"),o+=this.implodeParams(e,i),n={Accept:"application/json"},t==="public")a.length&&(o+="?"+a);else{this.checkRequiredCredentials();let d=this.apiKey;s==="POST"?(n["Content-Type"]="application/x-www-form-urlencoded",r=a,d+=r):a.length&&(o+="?"+a),n["X-KEY"]=this.apiKey,n["X-SIGN"]=this.hmac(this.encode(d),this.encode(this.secret)),n["X-NONCE"]=this.nonce().toString()}return{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"error"),u=this.id+" "+r;if(c!==void 0&&(this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u)),e===401||e===403)throw new TL(u);if(e===429)throw new OL(u);if(!(e<400))throw new vL(u)}};const ML=me,{ExchangeError:ek,InsufficientFunds:PL,InvalidOrder:Km,AuthenticationError:AL,PermissionDenied:BL,InvalidNonce:NL,OrderNotFound:tk,DDoSProtection:EL}=oe,{TICK_SIZE:VL}=pe,qL=ke;var LL=class extends ML{describe(){return this.deepExtend(super.describe(),{id:"btcbox",name:"BtcBox",countries:["JP"],rateLimit:1e3,version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:void 0,fetchTrades:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!1},urls:{logo:"https://user-images.githubusercontent.com/51840849/87327317-98c55400-c53c-11ea-9a11-81f7d951cc74.jpg",api:{rest:"https://www.btcbox.co.jp/api"},www:"https://www.btcbox.co.jp/",doc:"https://blog.btcbox.jp/en/archives/8762",fees:"https://support.btcbox.co.jp/hc/en-us/articles/360001235694-Fees-introduction"},api:{public:{get:["depth","orders","ticker"]},private:{post:["balance","trade_add","trade_cancel","trade_list","trade_view","wallet"]}},markets:{"BTC/JPY":{id:"btc",symbol:"BTC/JPY",base:"BTC",quote:"JPY",baseId:"btc",quoteId:"jpy",taker:this.parseNumber("0.0005"),maker:this.parseNumber("0.0005"),type:"spot",spot:!0},"ETH/JPY":{id:"eth",symbol:"ETH/JPY",base:"ETH",quote:"JPY",baseId:"eth",quoteId:"jpy",taker:this.parseNumber("0.0010"),maker:this.parseNumber("0.0010"),type:"spot",spot:!0},"LTC/JPY":{id:"ltc",symbol:"LTC/JPY",base:"LTC",quote:"JPY",baseId:"ltc",quoteId:"jpy",taker:this.parseNumber("0.0010"),maker:this.parseNumber("0.0010"),type:"spot",spot:!0},"BCH/JPY":{id:"bch",symbol:"BCH/JPY",base:"BCH",quote:"JPY",baseId:"bch",quoteId:"jpy",taker:this.parseNumber("0.0010"),maker:this.parseNumber("0.0010"),type:"spot",spot:!0}},precisionMode:VL,exceptions:{104:AL,105:BL,106:NL,107:Km,200:PL,201:Km,202:Km,203:tk,401:tk,402:EL}})}parseBalance(e){const t={info:e},s=Object.keys(this.currencies);for(let i=0;i<s.length;i++){const n=s[i],a=this.currency(n).id,o=a+"_balance";if(o in e){const d=this.account(),c=a+"_lock";d.free=this.safeString(e,o),d.used=this.safeString(e,c),t[n]=d}}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={};this.symbols.length>1&&(n.coin=i.baseId);const a=await this.publicGetDepth(this.extend(n,s));return this.parseOrderBook(a,i.symbol)}parseTicker(e,t=void 0){const s=this.milliseconds(),i=this.safeSymbol(void 0,t),n=this.safeString(e,"last");return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"vol"),quoteVolume:this.safeString(e,"volume"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={};this.symbols.length>1&&(i.coin=s.baseId);const r=await this.publicGetTicker(this.extend(i,t));return this.parseTicker(r,s)}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"date");t=this.safeMarket(void 0,t);const i=this.safeString(e,"tid"),n=this.safeString(e,"price"),r=this.safeString(e,"amount"),a=void 0,o=this.safeString(e,"type");return this.safeTrade({info:e,id:i,order:void 0,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:a,side:o,takerOrMaker:void 0,price:n,amount:r,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={};this.symbols.length>1&&(r.coin=n.baseId);const o=await this.publicGetOrders(this.extend(r,i));return this.parseTrades(o,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={amount:i,price:n,type:s,coin:a.baseId},d=await this.privatePostTradeAdd(this.extend(o,r));return this.parseOrder(d,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets(),t===void 0&&(t="BTC/JPY");const i=this.market(t),n={id:e,coin:i.baseId},r=await this.privatePostTradeCancel(this.extend(n,s));return this.parseOrder(r,i)}parseOrderStatus(e){const t={part:"open",all:"closed",cancelled:"canceled",closed:"closed",no:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"datetime");let n;i!==void 0&&(n=this.parse8601(e.datetime+"+09:00"));const r=this.safeString(e,"amount_original"),a=this.safeString(e,"amount_outstanding"),o=this.safeString(e,"price");let d=this.parseOrderStatus(this.safeString(e,"status"));d===void 0&&qL.stringEquals(a,"0")&&(d="closed");const c=void 0;t=this.safeMarket(void 0,t);const u=this.safeString(e,"type");return this.safeOrder({id:s,clientOrderId:void 0,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,amount:r,remaining:a,filled:void 0,side:u,type:void 0,timeInForce:void 0,postOnly:void 0,status:d,symbol:t.symbol,price:o,stopPrice:void 0,cost:void 0,trades:c,fee:void 0,info:e,average:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets(),t===void 0&&(t="BTC/JPY");const i=this.market(t),n=this.extend({id:e,coin:i.baseId},s),r=await this.privatePostTradeView(this.extend(n,s));return this.parseOrder(r,i)}async fetchOrdersByType(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets(),t===void 0&&(t="BTC/JPY");const r=this.market(t),a={type:e,coin:r.baseId},o=await this.privatePostTradeList(this.extend(a,n)),d=this.parseOrders(o,r,s,i);if(e==="open")for(let c=0;c<d.length;c++)d[c].status="open";return d}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByType("all",e,t,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByType("open",e,t,s,i)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.version+"/"+e;if(t==="public")Object.keys(i).length&&(a+="?"+this.urlencode(i));else{this.checkRequiredCredentials();const o=this.nonce().toString(),d=this.extend({key:this.apiKey,nonce:o},i),c=this.urlencode(d),u=this.hash(this.encode(this.secret));d.signature=this.hmac(this.encode(c),this.encode(u)),r=this.urlencode(d),n={"Content-Type":"application/x-www-form-urlencoded"}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0||e>=400)return;const c=this.safeValue(a,"result");if(c===void 0||c===!0)return;const u=this.safeValue(a,"code"),h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions,u,h),new ek(h)}async request(e,t="public",s="GET",i={},n=void 0,r=void 0,a={},o={}){let d=await this.fetch2(e,t,s,i,n,r,a,o);if(typeof d=="string"){if(d=this.strip(d),!this.isJsonEncodedObject(d))throw new ek(this.id+" "+d);d=JSON.parse(d)}return d}};const RL=me,{TICK_SIZE:FL}=pe,{ExchangeError:vf,NotSupported:Xm,RequestTimeout:sk,DDoSProtection:Tf,InvalidOrder:us,InvalidAddress:Ym,BadRequest:nt,InsufficientFunds:ik,OrderNotFound:DL,AuthenticationError:Is,ExchangeNotAvailable:nk,ArgumentsRequired:Hr}=oe,Gr=ke;var HL=class extends RL{describe(){return this.deepExtend(super.describe(),{id:"btcex",name:"BTCEX",countries:["CA"],version:"v1",certified:!1,pro:!1,requiredCredentials:{apiKey:!0,secret:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/173489620-d49807a4-55cd-4f4e-aca9-534921298bbf.jpg",www:"https://www.btcex.com/",api:{rest:"https://api.btcex.com"},doc:"https://docs.btcex.com/",fees:"https://support.btcex.com/hc/en-us/articles/4415995130647",referral:{url:"https://www.btcex.com/en-us/register?i=48biatg1",discount:.1}},has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!0,option:!0,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,editOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchClosedOrders:!0,fetchCurrencies:!1,fetchDepositAddress:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!1,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:void 0,fetchWithdrawal:!0,fetchWithdrawals:!0,signIn:!0,withdraw:!1},timeframes:{"15s":"15","1m":"60","5m":"300","15m":"900","1h":"3600","4h":"14400","1d":"86400","3d":"259200","1w":"604800","2w":"1209600","1M":"2592000"},api:{public:{get:["get_last_trades_by_currency","get_last_trades_by_instrument","get_order_book","tickers","get_instruments","get_tradingview_chart_data","cmc_spot_summary","cmc_spot_ticker","cmc_spot_orderbook","cmc_market_trades","cmc_contracts","cmc_contract_orderbook","coin_gecko_spot_pairs","coin_gecko_spot_ticker","coin_gecko_spot_orderbook","coin_gecko_market_trades","coin_gecko_contracts","coin_gecko_contract_orderbook"],post:["auth"]},private:{get:["get_deposit_record","get_withdraw_record","get_position","get_positions","get_open_orders_by_currency","get_open_orders_by_instrument","get_order_history_by_currency","get_order_history_by_instrument","get_order_state","get_user_trades_by_currency","get_user_trades_by_instrument","get_user_trades_by_order"],post:["logout","get_assets_info","add_withdraw_address","buy","sell","cancel","cancel_all_by_currency","cancel_all_by_instrument","close_position"],delete:[]}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")},margin:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")},perpetual:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},exceptions:{exact:{9999:vf,9900:nk,401:Is,403:Is,1e3:nk,1001:nt,2e3:Is,2001:Is,2002:Is,2003:Is,3e3:Is,3002:Is,3003:Is,3004:nt,3005:Xm,3007:Is,3008:Is,3009:Is,3011:Is,3012:Is,3013:sk,3015:Is,3016:Is,3018:nt,3019:nt,3020:nt,3021:nt,3022:nt,3023:nt,3024:nt,3025:nt,3026:nt,3027:nt,3028:nt,3029:Tf,3030:Tf,3031:nt,3032:nt,3033:nt,3034:Is,3035:nt,3036:nt,3037:nt,3038:nt,3039:nt,3040:Is,3041:nt,4e3:nt,4001:Ym,4002:Ym,4003:nt,4004:Xm,4005:vf,4006:ik,4007:nt,4008:Xm,4009:Ym,4010:nt,4011:nt,5001:us,5002:DL,5003:us,5004:us,5005:us,5006:us,5007:us,5008:us,5009:us,5010:us,5011:us,5012:us,5013:us,5014:us,5109:us,5135:us,5901:us,5902:us,5903:us,5904:us,5905:us,5906:us,5907:ik,8e3:nt,8001:nt,8100:nt,8101:sk,8102:Tf,8103:nt,8104:nt,8105:nt,8106:Tf,8107:vf,11e3:nt},broad:{}},precisionMode:FL,options:{accountsByType:{wallet:"WALLET",spot:"SPOT",perpetual:"PERPETUAL",margin:"MARGIN",swap:"PERPETUAL",BTC:"BTC",ETH:"ETH"}},commonCurrencies:{}})}async fetchMarkets(e={}){const t=await this.publicGetGetInstruments(e),s=this.safeValue(t,"result",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"instrument_name"),o=this.safeString(r,"kind");let d=o;o==="perpetual"&&(d="swap");let c=this.safeString(r,"quote_currency");const u=this.safeString(r,"base_currency"),h=o==="perpetual",l=o==="spot",p=o==="margin",m=o==="option",g=o==="future",y=h||g||m;let b;(m||g)&&(c=this.safeString(r,"currency"),b=this.safeInteger(r,"expiration_timestamp"));let w,S,k;y&&(S=u,k=this.safeCurrencyCode(S));let T,I;m&&(T=this.safeString(r,"option_type"),I=this.safeNumber(r,"strike"));const _=this.safeCurrencyCode(c),N=this.safeCurrencyCode(u);let M;if(p?M=a:M=_+"/"+N,y&&(w=this.safeNumber(r,"contract_size"),M=M+":"+k,(g||m)&&(M=M+"-"+this.yymmdd(b),m))){const q=T==="call"?"C":"P";M=M+":"+this.numberToString(I)+":"+q}const x=this.safeNumber(r,"min_trade_amount"),v=this.safeNumber(r,"tick_size"),O=this.safeNumber(r,"maker_commission"),A=this.safeNumber(r,"taker_commission"),V=!(m||g);i.push({id:a,symbol:M,base:_,quote:N,baseId:c,quoteId:u,settleId:S,settle:k,type:d,maker:O,taker:A,percentage:V,spot:l,margin:p,swap:h,future:g,option:m,active:this.safeValue(r,"is_active"),contract:y,linear:y?!0:void 0,inverse:y?!1:void 0,contractSize:w,expiry:b,expiryDatetime:this.iso8601(b),strike:I,optionType:T,precision:{amount:x,price:v},limits:{leverage:{min:void 0,max:this.safeString(r,"leverage")},amount:{min:x,max:void 0},price:{min:v,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}parseTicker(e,t=void 0){const s=this.safeString(e,"instrument_name");t=this.safeMarket(s,t);const i=this.safeSymbol(s,t),n=this.safeInteger(e,"timestamp"),r=this.safeValue(e,"stats");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(r,"high"),low:this.safeString(r,"low"),bid:this.safeString(e,"best_bid_price"),bidVolume:this.safeString(e,"best_bid_amount"),ask:this.safeString(e,"best_ask_price"),askVolume:this.safeString(e,"best_ask_amount"),vwap:void 0,open:void 0,close:this.safeString(e,"last_price"),last:this.safeString(e,"last_price"),previousClose:void 0,change:void 0,percentage:this.safeString(r,"price_change"),average:void 0,baseVolume:this.safeString(r,"volume"),quoteVolume:this.safeString(r,"turnover"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={instrument_name:s.id},n=await this.publicGetTickers(this.extend(i,t)),r=this.safeValue(n,"result",{}),a=this.safeValue(r,0);return this.parseTicker(a,s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={instrument_name:i.id},r=await this.publicGetGetOrderBook(this.extend(n,s)),a=this.safeValue(r,"result",{}),o=this.safeInteger(a,"timestamp");return this.parseOrderBook(a,i.symbol,o)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"tick"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);i===void 0&&(i=10);const a={resolution:this.timeframes[t]};let o=r.id;if((r.spot||r.margin)&&(o=r.baseId+"-"+r.quoteId),a.instrument_name=o,s===void 0)a.end_timestamp=this.milliseconds(),a.start_timestamp=0;else{const h=this.parseTimeframe(t)*1e3;a.start_timestamp=s,a.end_timestamp=this.sum(a.start_timestamp,i*h)}const d=await this.publicGetGetTradingviewChartData(this.extend(a,n)),c=this.safeValue(d,"result",[]);return this.parseOHLCVs(c,r,t,s,i)}parseTrade(e,t=void 0){const s=this.safeString(e,"trade_id"),i=this.safeString(e,"instrument_name"),n=this.safeSymbol(i,t),r=this.safeInteger(e,"timestamp"),a=this.safeString(e,"direction"),o=this.safeString(e,"price"),d=this.safeString(e,"amount"),c=this.safeString(e,"role"),u=this.safeString(e,"fee");let h;if(u!==void 0){const l=this.safeString(e,"fee_coin_type"),p=this.safeCurrencyCode(l);h={cost:u,currency:p}}return this.safeTrade({info:e,id:s,timestamp:r,datetime:this.iso8601(r),symbol:n,order:this.safeString(e,"order_id"),type:this.safeString(e,"order_type"),side:a,takerOrMaker:c,price:o,amount:d,cost:void 0,fee:h},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={instrument_name:n.id};s!==void 0&&(r.count=s);const a=await this.publicGetGetLastTradesByInstrument(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"trades",[]);return this.parseTrades(d,n,t,s)}async signIn(e={}){let t=this.safeString(this.options,"accessToken");if(t!==void 0)return t;this.checkRequiredCredentials();const s={grant_type:"client_credentials",client_id:this.apiKey,client_secret:this.secret},i=await this.publicPostAuth(this.extend(s,e)),n=this.safeValue(i,"result");return t=this.safeString(n,"access_token"),this.options.accessToken=t,t}parseBalance(e){const t={info:e},s=Object.keys(e);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeValue(e,n);if(n==="WALLET"||n==="SPOT"){const a=this.safeValue(r,"details");if(a!==void 0)for(let o=0;o<a.length;o++){const d=a[o],c=this.safeString(d,"coin_type"),u=this.safeCurrencyCode(c),h=this.safeValue(t,u,this.account());h.free=this.safeString(d,"available"),h.used=this.safeString(d,"freeze"),h.total=this.safeString(d,"total"),t[u]=h}}else{const a="USDT",o=this.account();o.total=this.safeString(r,"wallet_balance"),o.free=this.safeString(r,"available_withdraw_funds"),t[a]=o}}return this.safeBalance(t)}async fetchBalance(e={}){await this.signIn(),await this.loadMarkets();const t=this.safeStringLower(e,"type","spot"),s=this.safeValue(this.options,"accountsByType",{}),i=this.safeString(s,t,t);e=this.omit(e,"type");const n={asset_type:[i]},r=await this.privatePostGetAssetsInfo(this.extend(n,e)),a=this.safeValue(r,"result",[]);return this.parseBalance(a)}parseOrderStatus(e){const t={open:"open",cancelled:"canceled",filled:"closed",rejected:"rejected"};return this.safeString(t,e,e)}parseTimeInForce(e){if(e==="-")return;const t={good_til_cancelled:"GTC",good_til_date:"GTD",fill_or_kill:"FOK",immediate_or_cancel:"IOC"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"creation_timestamp"),i=this.safeInteger(e,"last_update_timestamp"),n=this.safeString(e,"order_id"),r=this.safeString(e,"price"),a=this.safeString(e,"average_price"),o=this.safeString(e,"amount"),d=this.safeString(e,"filled_amount");let c;d!==void 0&&Gr.stringGt(d,"0")&&(c=i);const u=this.parseOrderStatus(this.safeString(e,"order_state")),h=this.safeString(e,"instrument_name");t=this.safeMarket(h,t);const l=this.safeStringLower(e,"direction");let p=this.safeString(e,"commission"),m;p!==void 0&&(p=Gr.stringAbs(p),m={cost:p,currency:t.base});const g=this.safeString(e,"order_type"),y=this.safeValue(e,"trades"),b=this.parseTimeInForce(this.safeString(e,"time_in_force")),w=this.safeValue(e,"trigger_price"),S=this.safeValue(e,"post_only");return this.safeOrder({info:e,id:n,clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:c,symbol:t.symbol,type:g,timeInForce:b,postOnly:S,side:l,price:r,stopPrice:w,amount:o,cost:void 0,average:a,filled:d,remaining:void 0,status:u,fee:m,trades:y},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privateGetGetOrderState(this.extend(i,s)),r=this.safeValue(n,"result");return this.parseOrder(r)}async createOrder(e,t,s,i,n=void 0,r={}){await this.signIn(),await this.loadMarkets();const a=this.market(e),o={instrument_name:a.id,amount:this.amountToPrecision(e,i),type:t};if(t==="limit"&&(o.price=this.priceToPrecision(e,n)),a.contract){const l=this.safeStringUpper(r,"timeInForce");l==="GTC"?o.time_in_force="good_till_cancelled":l==="FOK"?o.time_in_force="fill_or_kill":l==="IOC"&&(o.time_in_force="immediate_or_cancel");const p=t==="market",m=this.safeValue(r,"post_only",!1);this.isPostOnly(p,m,r)&&(o.post_only=!0),this.safeValue(r,"reduceOnly",!1)&&(o.reduce_only=!0),r=this.omit(r,["timeInForce","postOnly","reduceOnly"])}const d="privatePost"+this.capitalize(s),c=await this[d](this.extend(o,r)),u=this.safeValue(c,"result",{}),h=this.safeValue(u,"order");return this.parseOrder(h,a)}async cancelOrder(e,t=void 0,s={}){await this.signIn(),await this.loadMarkets();const i={order_id:e},n=await this.privatePostCancel(this.extend(i,s)),r=this.safeValue(n,"result",{});return this.parseOrder(r)}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new Hr(this.id+" cancelAllOrders() requires a symbol argument");await this.signIn(),await this.loadMarkets();const i={instrument_name:this.market(e).id};return await this.privatePostCancelAllByInstrument(this.extend(i,t))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Hr(this.id+" fetchOpenOrders() requires a symbol argument");await this.signIn(),await this.loadMarkets();const n=this.market(e),r={instrument_name:n.id},a=await this.privateGetGetOpenOrdersByInstrument(this.extend(r,i)),o=this.safeValue(a,"result",[]);return this.parseOrders(o,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Hr(this.id+" fetchClosedOrders() requires a symbol argument");await this.signIn(),await this.loadMarkets();const n=this.market(e),r={instrument_name:n.id};s!==void 0&&(r.count=s);const a=await this.privateGetGetOrderHistoryByInstrument(this.extend(r,i)),o=this.safeValue(a,"result",[]);return this.parseOrders(o,n,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){if(e===void 0)throw new Hr(this.id+" fetchOrderTrades() requires a id argument");await this.loadMarkets();const r={order_id:e};i!==void 0&&(r.count=i);const a=await this.privateGetGetUserTradesByOrder(this.extend(r,n)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"trades",[]);return this.parseTrades(d,void 0,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Hr(this.id+" fetchMyTrades() requires a id argument");await this.signIn(),await this.loadMarkets();const n={};let r;const a=this.market(e);n.instrument_name=a.id,t===void 0?r="privateGetGetUserTradesByInstrument":r="privateGetGetUserTradesByInstrumentAndTime",s!==void 0&&(n.count=s);const o=await this[r](this.extend(n,i)),d=this.safeValue(o,"result",{}),c=this.safeValue(d,"trades",[]);return this.parseTrades(c,a,t,s)}parsePosition(e,t=void 0){const s=this.safeString(e,"instrument_name");t=this.safeMarket(s,t);const i=this.safeString(e,"size");let n=this.safeString(e,"direction");n=n==="buy"?"long":"short";const r=this.safeString(e,"maintenance_margin"),a=this.safeString(e,"risk_level"),o=Gr.stringDiv(r,a),d=this.safeString(e,"mark_price"),c=Gr.stringMul(d,i),u=this.safeString(e,"floating_profit_loss"),h=this.safeString(e,"initial_margin"),l=Gr.stringMul(Gr.stringDiv(u,h),"100"),p=this.safeString(e,"margin_type");return{info:e,id:void 0,symbol:this.safeString(t,"symbol"),timestamp:void 0,datetime:void 0,initialMargin:this.parseNumber(h),initialMarginPercentage:this.parseNumber(Gr.stringDiv(h,c)),maintenanceMargin:this.parseNumber(r),maintenanceMarginPercentage:this.parseNumber(Gr.stringDiv(r,c)),entryPrice:this.safeNumber(e,"average_price"),notional:this.parseNumber(c),leverage:this.safeNumber(e,"leverage"),unrealizedPnl:this.parseNumber(u),contracts:this.parseNumber(i),contractSize:this.safeValue(t,"contractSize"),marginRatio:this.parseNumber(a),liquidationPrice:this.safeNumber(e,"liquid_price"),markPrice:this.parseNumber(d),collateral:this.parseNumber(o),marginType:p,side:n,percentage:this.parseNumber(l)}}async fetchPosition(e,t={}){await this.signIn(),await this.loadMarkets();const i={instrument_name:this.market(e).id},n=await this.privateGetGetPosition(this.extend(i,t)),r=this.safeValue(n,"result");return this.parsePosition(r)}async fetchPositions(e=void 0,t={}){await this.signIn(),await this.loadMarkets();const s={currency:"PERPETUAL"},i=await this.privateGetGetPositions(this.extend(s,t)),n=this.safeValue(i,"result");return this.parsePositions(n,e)}parseTransactionStatus(e){const t={deposit_confirmed:"ok",deposit_waiting_confirm:"pending",withdraw_init:"pending",withdraw_noticed_block_chain:"pending",withdraw_waiting_confirm:"pending",withdraw_confirmed:"ok",withdraw_failed:"failed",withdraw_auditing:"pending",withdraw_audit_reject:"failed"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"coin_type"),i=this.safeCurrencyCode(s,t),n=this.safeString(e,"id"),r=this.safeString(e,"tx_hash"),a=this.safeInteger(e,"create_time"),o=this.safeInteger(e,"update_time"),d=this.safeNumber(e,"amount"),c=this.safeString(e,"state");return{info:e,id:n,txid:r,timestamp:a,datetime:this.iso8601(a),network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,type:void 0,amount:d,currency:i,status:this.parseTransactionStatus(c),updated:o,fee:void 0}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Hr(this.id+" fetchDeposits() requires the code argument");await this.signIn(),await this.loadMarkets();const n=this.safeCurrency(e),r={coin_type:n.id},a=await this.privateGetGetDepositRecord(this.extend(r,i)),o=this.safeValue(a,"result",[]);return this.parseTransactions(o,n,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Hr(this.id+" fetchWithdrawals() requires the code argument");await this.signIn(),await this.loadMarkets();const n=this.safeCurrency(e),r={coin_type:n.id},a=await this.privateGetGetWithdrawRecord(this.extend(r,i)),o=this.safeValue(a,"result",[]);return this.parseTransactions(o,n,t,s,{type:"withdrawal"})}async fetchWithdrawal(e,t=void 0,s={}){if(t===void 0)throw new Hr(this.id+" fetchWithdrawal() requires the code argument");await this.signIn(),await this.loadMarkets();const i=this.safeCurrency(t),n={coin_type:i.id,withdraw_id:e},r=await this.privateGetGetWithdrawRecord(this.extend(n,s)),a=this.safeValue(r,"result",[]),o=this.filterBy(a,"id",e),d=this.safeValue(o,0);return this.parseTransaction(d,i)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/api/"+this.version+"/"+t+"/"+e;if(t==="public"&&Object.keys(i).length&&(a+="?"+this.urlencode(i)),t==="private"){this.checkRequiredCredentials(),s==="GET"&&Object.keys(i).length&&(a+="?"+this.urlencode(i));const d=this.safeString(this.options,"accessToken");if(d===void 0)throw new Is(this.id+" sign() requires access token");if(n={Authorization:"bearer "+d},s==="POST"&&(n["Content-Type"]="application/json",Object.keys(i).length)){const c={jsonrpc:"2.0",id:this.nonce(),method:"/"+t+"/"+e,params:i};r=this.json(c)}}return{url:this.urls.api.rest+a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeValue(a,"error");if(c){const u=this.id+" "+r,h=this.safeString(c,"code"),l=this.safeString(c,"message");throw this.throwExactlyMatchedException(this.exceptions.exact,h,u),this.throwBroadlyMatchedException(this.exceptions.broad,l,u),new vf(u)}}};const GL=me,{ArgumentsRequired:rk,ExchangeError:ak,OrderNotFound:UL,InvalidOrder:Ao,InsufficientFunds:$L,DDoSProtection:jL,BadRequest:WL}=oe,{TICK_SIZE:zL}=pe,ok=ke;var KL=class extends GL{describe(){return this.deepExtend(super.describe(),{id:"btcmarkets",name:"BTC Markets",countries:["AU"],rateLimit:1e3,version:"v3",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,cancelOrders:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:"emulated",fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTime:!0,fetchTrades:!0,fetchTransactions:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/51840849/89731817-b3fb8480-da52-11ea-817f-783b08aaf32b.jpg",api:{public:"https://api.btcmarkets.net",private:"https://api.btcmarkets.net"},www:"https://btcmarkets.net",doc:["https://api.btcmarkets.net/doc/v3","https://github.com/BTCMarkets/API"]},api:{public:{get:["markets","markets/{marketId}/ticker","markets/{marketId}/trades","markets/{marketId}/orderbook","markets/{marketId}/candles","markets/tickers","markets/orderbooks","time"]},private:{get:["orders","orders/{id}","batchorders/{ids}","trades","trades/{id}","withdrawals","withdrawals/{id}","deposits","deposits/{id}","transfers","transfers/{id}","addresses","withdrawal-fees","assets","accounts/me/trading-fees","accounts/me/withdrawal-limits","accounts/me/balances","accounts/me/transactions","reports/{id}"],post:["orders","batchorders","withdrawals","reports"],delete:["orders","orders/{id}","batchorders/{ids}"],put:["orders/{id}"]}},timeframes:{"1m":"1m","1h":"1h","1d":"1d"},precisionMode:zL,exceptions:{3:Ao,6:jL,InsufficientFund:$L,InvalidPrice:Ao,InvalidAmount:Ao,MissingArgument:Ao,OrderAlreadyCancelled:Ao,OrderNotFound:UL,OrderStatusIsFinal:Ao,InvalidPaginationParameter:WL},fees:{percentage:!0,tierBased:!0,maker:this.parseNumber("-0.0005"),taker:this.parseNumber("0.0020")},options:{fees:{AUD:{maker:this.parseNumber("0.0085"),taker:this.parseNumber("0.0085")}}}})}async fetchTransactionsWithMethod(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};i!==void 0&&(r.limit=i),s!==void 0&&(r.after=s);let a;t!==void 0&&(a=this.currency(t));const o=await this[e](this.extend(r,n));return this.parseTransactions(o,a,s,i)}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsWithMethod("privateGetTransfers",e,t,s,i)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsWithMethod("privateGetDeposits",e,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsWithMethod("privateGetWithdrawals",e,t,s,i)}parseTransactionStatus(e){const t={Accepted:"pending","Pending Authorization":"pending",Complete:"ok",Cancelled:"cancelled",Failed:"failed"};return this.safeString(t,e,e)}parseTransactionType(e){const t={Withdraw:"withdrawal",Deposit:"deposit"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.parse8601(this.safeString(e,"creationTime")),i=this.parse8601(this.safeString(e,"lastUpdate"));let n=this.parseTransactionType(this.safeStringLower(e,"type"));n==="withdraw"&&(n="withdrawal");const r=this.safeValue(e,"paymentDetail",{}),a=this.safeString(r,"txId");let o=this.safeString(r,"address"),d;if(o!==void 0){const w=o.split("?dt=");w.length>1&&(o=w[0],d=w[1])}const c=o,u=d,h=void 0,l=void 0,p=this.safeNumber(e,"fee"),m=this.parseTransactionStatus(this.safeString(e,"status")),g=this.safeString(e,"assetName"),y=this.safeCurrencyCode(g);let b=this.safeNumber(e,"amount");return p&&(b-=p),{id:this.safeString(e,"id"),txid:a,timestamp:s,datetime:this.iso8601(s),network:void 0,address:o,addressTo:c,addressFrom:h,tag:d,tagTo:u,tagFrom:l,type:n,amount:b,currency:y,status:m,updated:i,fee:{currency:y,cost:p},info:e}}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"baseAssetName"),a=this.safeString(n,"quoteAssetName"),o=this.safeString(n,"marketId"),d=this.safeCurrencyCode(r),c=this.safeCurrencyCode(a),u=d+"/"+c,h=this.safeValue(this.safeValue(this.options,"fees",{}),c,this.fees),l=this.parseNumber(this.parsePrecision(this.safeString(n,"priceDecimals"))),p=this.safeNumber(n,"minOrderAmount"),m=this.safeNumber(n,"maxOrderAmount");let g;c==="AUD"&&(g=l),s.push({id:o,symbol:u,base:d,quote:c,settle:void 0,baseId:r,quoteId:a,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,taker:h.taker,maker:h.maker,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(n,"amountDecimals"))),price:l},limits:{leverage:{min:void 0,max:void 0},amount:{min:p,max:m},price:{min:g,max:void 0},cost:{min:void 0,max:void 0}},info:n})}return s}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.parse8601(this.safeString(t,"timestamp"))}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"assetName"),r=this.safeCurrencyCode(n),a=this.account();a.used=this.safeString(i,"locked"),a.total=this.safeString(i,"balance"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountsMeBalances(e);return this.parseBalance(t)}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,0)),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={marketId:r.id,timeWindow:this.timeframes[t]};s!==void 0&&(a.from=this.iso8601(s)),i!==void 0&&(a.limit=i);const o=await this.publicGetMarketsMarketIdCandles(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={marketId:this.market(e).id},r=await this.publicGetMarketsMarketIdOrderbook(this.extend(n,s)),a=this.safeIntegerProduct(r,"snapshotId",.001),o=this.parseOrderBook(r,e,a);return o.nonce=this.safeInteger(r,"snapshotId"),o}parseTicker(e,t=void 0){const s=this.safeString(e,"marketId");t=this.safeMarket(s,t,"-");const i=t.symbol,n=this.parse8601(this.safeString(e,"timestamp")),r=this.safeString(e,"lastPrice"),a=this.safeString(e,"volume24h"),o=this.safeString(e,"volumeQte24h"),d=this.safeString(e,"price24h"),c=this.safeString(e,"pricePct24h");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high24h"),low:this.safeString(e,"low"),bid:this.safeString(e,"bestBid"),bidVolume:void 0,ask:this.safeString(e,"bestAsk"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:d,percentage:c,average:void 0,baseVolume:a,quoteVolume:o,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={marketId:s.id},n=await this.publicGetMarketsMarketIdTicker(this.extend(i,t));return this.parseTicker(n,s)}async fetchTicker2(e,t={}){await this.loadMarkets();const s=this.market(e),i={id:s.id},n=await this.publicGetMarketIdTick(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"timestamp")),i=this.safeString(e,"marketId");t=this.safeMarket(i,t,"-");const n=t.quote==="AUD"?t.quote:t.base;let r=this.safeString(e,"side");r==="Bid"?r="buy":r==="Ask"&&(r="sell");const a=this.safeString(e,"id"),o=this.safeString(e,"price"),d=this.safeString(e,"amount"),c=this.safeString(e,"orderId");let u;const h=this.safeString(e,"fee");h!==void 0&&(u={cost:h,currency:n});const l=this.safeStringLower(e,"liquidityType");return this.safeTrade({info:e,id:a,timestamp:s,datetime:this.iso8601(s),order:c,symbol:t.symbol,type:void 0,side:r,price:o,amount:d,cost:void 0,takerOrMaker:l,fee:u},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={marketId:n.id},a=await this.publicGetMarketsMarketIdTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={marketId:a.id,amount:this.amountToPrecision(e,i),side:s==="buy"?"Bid":"Ask"},d=t.toLowerCase(),c=this.safeValue(this.options,"orderTypes",{limit:"Limit",market:"Market",stop:"Stop","stop limit":"Stop Limit","take profit":"Take Profit"});o.type=this.safeString(c,d,t);let u=!1,h=!1;if(d==="limit"?u=!0:d==="stop limit"?(h=!0,u=!0):(d==="take profit"||d==="stop")&&(h=!0),u){if(n===void 0)throw new rk(this.id+" createOrder() requires a price argument for a "+t+"order");o.price=this.priceToPrecision(e,n)}if(h){const m=this.safeNumber(r,"triggerPrice");if(r=this.omit(r,"triggerPrice"),m===void 0)throw new rk(this.id+" createOrder() requires a triggerPrice parameter for a "+t+"order");o.triggerPrice=this.priceToPrecision(e,m)}const l=this.safeString(r,"clientOrderId");l!==void 0&&(o.clientOrderId=l),r=this.omit(r,"clientOrderId");const p=await this.privatePostOrders(this.extend(o,r));return this.parseOrder(p,a)}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();for(let n=0;n<e.length;n++)e[n]=parseInt(e[n]);const i={ids:e};return await this.privateDeleteBatchordersIds(this.extend(i,s))}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e};return await this.privateDeleteOrdersId(this.extend(i,s))}calculateFee(e,t,s,i,n,r="taker",a={}){const o=this.markets[e];let d,c;if(o.quote==="AUD"){d=o.quote;const l=this.numberToString(i),p=this.numberToString(n),m=ok.stringMul(l,p);c=this.costToPrecision(e,m)}else d=o.base,c=this.amountToPrecision(e,i);const u=o[r],h=ok.stringMul(this.numberToString(u),c);return{type:r,currency:d,rate:u,cost:parseFloat(this.feeToPrecision(e,h))}}parseOrderStatus(e){const t={Accepted:"open",Placed:"open","Partially Matched":"open","Fully Matched":"closed",Cancelled:"canceled","Partially Cancelled":"canceled",Failed:"rejected"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parse8601(this.safeString(e,"creationTime")),i=this.safeString(e,"marketId");t=this.safeMarket(i,t,"-");let n=this.safeString(e,"side");n==="Bid"?n="buy":n==="Ask"&&(n="sell");const r=this.safeStringLower(e,"type"),a=this.safeString(e,"price"),o=this.safeString(e,"amount"),d=this.safeString(e,"openAmount"),c=this.parseOrderStatus(this.safeString(e,"status")),u=this.safeString(e,"orderId"),h=this.safeString(e,"clientOrderId"),l=this.safeString(e,"timeInForce"),p=this.safeNumber(e,"triggerPrice"),m=this.safeValue(e,"postOnly");return this.safeOrder({info:e,id:u,clientOrderId:h,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,symbol:t.symbol,type:r,timeInForce:l,postOnly:m,side:n,price:a,stopPrice:p,cost:void 0,amount:o,filled:void 0,remaining:d,average:void 0,status:c,trades:void 0,fee:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetOrdersId(this.extend(i,s));return this.parseOrder(n)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={status:"all"};let r;e!==void 0&&(r=this.market(e),n.marketId=r.id),t!==void 0&&(n.after=t),s!==void 0&&(n.limit=s);const a=await this.privateGetOrders(this.extend(n,i));return this.parseOrders(a,r,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"open"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n=await this.fetchOrders(e,t,s,i);return this.filterBy(n,"status","closed")}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.marketId=r.id),t!==void 0&&(n.after=t),s!==void 0&&(n.limit=s);const a=await this.privateGetTrades(this.extend(n,i));return this.parseTrades(a,r,t,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets();const r=this.currency(e),a={currency_id:r.id,amount:this.currencyToPrecision(e,t)};e!=="AUD"&&(this.checkAddress(s),a.toAddress=s),i!==void 0&&(a.toAddress=s+"?dt="+i);const o=await this.privatePostWithdrawals(this.extend(a,n));return this.parseTransaction(o,r)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.version+"/"+this.implodeParams(e,i);const o=this.keysort(this.omit(i,this.extractParams(e)));if(t==="private"){this.checkRequiredCredentials();const c=this.nonce().toString(),u=this.base64ToBinary(this.encode(this.secret));let h=s+a+c;s==="GET"||s==="DELETE"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):(r=this.json(o),h+=r);const l=this.hmac(this.encode(h),u,"sha512","base64");n={Accept:"application/json","Accept-Charset":"UTF-8","Content-Type":"application/json","BM-AUTH-APIKEY":this.apiKey,"BM-AUTH-TIMESTAMP":c,"BM-AUTH-SIGNATURE":l}}else t==="public"&&Object.keys(o).length&&(a+="?"+this.urlencode(o));return{url:this.urls.api[t]+a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0){if("success"in a&&!a.success){const c=this.safeString(a,"errorCode"),u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions,c,u),new ak(u)}if(e>=400){const c=this.safeString(a,"code"),u=this.safeString(a,"message"),h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions,c,h),this.throwExactlyMatchedException(this.exceptions,u,h),new ak(h)}}}};const XL=me,{ExchangeError:dk,ArgumentsRequired:YL}=oe,{TICK_SIZE:QL}=pe,Qm=ke;var ZL=class extends XL{describe(){return this.deepExtend(super.describe(),{id:"btctradeua",name:"BTC Trade UA",countries:["UA"],rateLimit:3e3,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,signIn:!0},urls:{referral:"https://btc-trade.com.ua/registration/22689",logo:"https://user-images.githubusercontent.com/1294454/27941483-79fc7350-62d9-11e7-9f61-ac47f28fcd96.jpg",api:{rest:"https://btc-trade.com.ua/api"},www:"https://btc-trade.com.ua",doc:"https://docs.google.com/document/d/1ocYA0yMy_RXd561sfG3qEPZ80kyll36HUxvCRe5GbhE/edit"},api:{public:{get:["deals/{symbol}","trades/sell/{symbol}","trades/buy/{symbol}","japan_stat/high/{symbol}"]},private:{post:["auth","ask/{symbol}","balance","bid/{symbol}","buy/{symbol}","my_orders/{symbol}","order/status/{id}","remove/order/{id}","sell/{symbol}"]}},precisionMode:QL,markets:{"BCH/UAH":{id:"bch_uah",symbol:"BCH/UAH",base:"BCH",quote:"UAH",baseId:"bch",quoteId:"uah",type:"spot",spot:!0},"BTC/UAH":{id:"btc_uah",symbol:"BTC/UAH",base:"BTC",quote:"UAH",baseId:"btc",quoteId:"uah",precision:{price:this.parseNumber("0.1")},limits:{amount:{min:this.parseNumber("0.0000000001")}},type:"spot",spot:!0},"DASH/BTC":{id:"dash_btc",symbol:"DASH/BTC",base:"DASH",quote:"BTC",baseId:"dash",quoteId:"btc",type:"spot",spot:!0},"DASH/UAH":{id:"dash_uah",symbol:"DASH/UAH",base:"DASH",quote:"UAH",baseId:"dash",quoteId:"uah",type:"spot",spot:!0},"DOGE/BTC":{id:"doge_btc",symbol:"DOGE/BTC",base:"DOGE",quote:"BTC",baseId:"doge",quoteId:"btc",type:"spot",spot:!0},"DOGE/UAH":{id:"doge_uah",symbol:"DOGE/UAH",base:"DOGE",quote:"UAH",baseId:"doge",quoteId:"uah",type:"spot",spot:!0},"ETH/UAH":{id:"eth_uah",symbol:"ETH/UAH",base:"ETH",quote:"UAH",baseId:"eth",quoteId:"uah",type:"spot",spot:!0},"ITI/UAH":{id:"iti_uah",symbol:"ITI/UAH",base:"ITI",quote:"UAH",baseId:"iti",quoteId:"uah",type:"spot",spot:!0},"KRB/UAH":{id:"krb_uah",symbol:"KRB/UAH",base:"KRB",quote:"UAH",baseId:"krb",quoteId:"uah",type:"spot",spot:!0},"LTC/BTC":{id:"ltc_btc",symbol:"LTC/BTC",base:"LTC",quote:"BTC",baseId:"ltc",quoteId:"btc",type:"spot",spot:!0},"LTC/UAH":{id:"ltc_uah",symbol:"LTC/UAH",base:"LTC",quote:"UAH",baseId:"ltc",quoteId:"uah",type:"spot",spot:!0},"NVC/BTC":{id:"nvc_btc",symbol:"NVC/BTC",base:"NVC",quote:"BTC",baseId:"nvc",quoteId:"btc",type:"spot",spot:!0},"NVC/UAH":{id:"nvc_uah",symbol:"NVC/UAH",base:"NVC",quote:"UAH",baseId:"nvc",quoteId:"uah",type:"spot",spot:!0},"PPC/BTC":{id:"ppc_btc",symbol:"PPC/BTC",base:"PPC",quote:"BTC",baseId:"ppc",quoteId:"btc",type:"spot",spot:!0},"SIB/UAH":{id:"sib_uah",symbol:"SIB/UAH",base:"SIB",quote:"UAH",baseId:"sib",quoteId:"uah",type:"spot",spot:!0},"XMR/UAH":{id:"xmr_uah",symbol:"XMR/UAH",base:"XMR",quote:"UAH",baseId:"xmr",quoteId:"uah",type:"spot",spot:!0},"ZEC/UAH":{id:"zec_uah",symbol:"ZEC/UAH",base:"ZEC",quote:"UAH",baseId:"zec",quoteId:"uah",type:"spot",spot:!0}},fees:{trading:{maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")}}})}async signIn(e={}){return await this.privatePostAuth(e)}parseBalance(e){const t={info:e},s=this.safeValue(e,"accounts",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(n,"balance"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id},r=await this.publicGetTradesBuySymbol(this.extend(n,s)),a=await this.publicGetTradesSellSymbol(this.extend(n,s)),o={bids:[],asks:[]};return r&&"list"in r&&(o.bids=r.list),a&&"list"in a&&(o.asks=a.list),this.parseOrderBook(o,i.symbol,void 0,"bids","asks","price","currency_trade")}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.milliseconds(),n={symbol:s,timestamp:i,datetime:this.iso8601(i),high:void 0,low:void 0,bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:void 0,last:void 0,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:void 0,info:e},r=e.length;if(r>0){const a=Math.max(r-48,0);for(let d=a;d<e.length;d++){const c=e[d];n.open===void 0&&(n.open=this.safeString(c,1));const u=this.safeString(c,2);(n.high===void 0||u!==void 0&&Qm.stringLt(n.high,u))&&(n.high=u);const h=this.safeString(c,3);(n.low===void 0||h!==void 0&&Qm.stringLt(n.low,h))&&(n.low=h);const l=this.safeString(c,5);n.baseVolume===void 0?n.baseVolume=l:n.baseVolume=Qm.stringAdd(n.baseVolume,l)}const o=r-1;n.last=this.safeString(e[o],4),n.close=n.last}return this.safeTicker(n,t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetJapanStatHighSymbol(this.extend(i,t)),r=this.safeValue(n,"trades");return this.parseTicker(r,s)}convertMonthNameToString(e){const t={Jan:"01",Feb:"02",Mar:"03",Apr:"04",May:"05",Jun:"06",Jul:"07",Aug:"08",Sept:"09",Oct:"10",Nov:"11",Dec:"12"};return this.safeString(t,e)}parseExchangeSpecificDatetime(e){const t=e.split(" ");let s=t[0],i=t[1].replace(",","");i.length<2&&(i="0"+i);const n=t[2].replace(",","");if(s=s.replace(",",""),s=s.replace(".",""),s=this.convertMonthNameToString(s),!s)throw new dk(this.id+" parseTrade() unrecognized month name: "+e);const a=t[3].split(":");let o=this.safeString(a,0),d="00";const c=this.safeString(t,4);if(o==="noon")o="12";else{let m=parseInt(o);c!==void 0&&c[0]==="p"&&(m=12+m,m>23&&(m=0)),o=m.toString(),o.length<2&&(o="0"+o),d=this.safeString(a,1,"00"),d.length<2&&(d="0"+d)}const h=[n,s,i].join("-")+"T"+o+":"+d+":00",l=this.parse8601(h),p=parseInt(d);return p<11||p>2?l-72e5:l-108e5}parseTrade(e,t=void 0){const s=this.parseExchangeSpecificDatetime(this.safeString(e,"pub_date")),i=this.safeString(e,"id"),n="limit",r=this.safeString(e,"type"),a=this.safeString(e,"price"),o=this.safeString(e,"amnt_trade");return t=this.safeMarket(void 0,t),this.safeTrade({id:i,info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:n,side:r,order:void 0,takerOrMaker:void 0,price:a,amount:o,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.publicGetDealsSymbol(this.extend(r,i)),o=[];for(let d=0;d<a.length;d++)this.safeInteger(a[d],"id")%2&&o.push(a[d]);return this.parseTrades(o,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){if(t==="market")throw new dk(this.id+" createOrder() allows limit orders only");await this.loadMarkets();const a=this.market(e),o="privatePost"+this.capitalize(s)+"Id",d={count:i,currency1:a.quoteId,currency:a.baseId,price:n};return this[o](this.extend(d,r))}async cancelOrder(e,t=void 0,s={}){const i={id:e};return await this.privatePostRemoveOrderId(this.extend(i,s))}parseOrder(e,t=void 0){const s=this.milliseconds(),i=this.safeSymbol(void 0,t),n=this.safeString(e,"type"),r=this.safeString(e,"price"),a=this.safeString(e,"amnt_trade"),o=this.safeString(e,"amnt_trade");return this.safeOrder({id:this.safeString(e,"id"),clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,status:"open",symbol:i,type:void 0,timeInForce:void 0,postOnly:void 0,side:n,price:r,stopPrice:void 0,amount:a,filled:void 0,remaining:o,trades:void 0,info:e,cost:void 0,average:void 0,fee:void 0},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new YL(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.privatePostMyOrdersSymbol(this.extend(r,i)),o=this.safeValue(a,"your_open_orders");return this.parseOrders(o,n,t,s)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(o).length&&(a+=this.implodeParams(e,o));else{this.checkRequiredCredentials();const d=this.nonce();r=this.urlencode(this.extend({out_order_id:d,nonce:d},o));const c=r+this.secret;n={"public-key":this.apiKey,"api-sign":this.hash(this.encode(c),"sha256"),"Content-Type":"application/x-www-form-urlencoded"}}return{url:a,method:s,body:r,headers:n}}};const JL=me,{BadRequest:e8,ExchangeError:ck,InsufficientFunds:t8,InvalidOrder:uk}=oe,{TICK_SIZE:s8}=pe,Zm=ke;var i8=class extends JL{describe(){return this.deepExtend(super.describe(),{id:"btcturk",name:"BTCTurk",countries:["TR"],rateLimit:100,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},timeframes:{"1m":1,"15m":15,"30m":30,"1h":60,"4h":240,"1d":"1 day","1w":"1 week","1y":"1 year"},urls:{logo:"https://user-images.githubusercontent.com/51840849/87153926-efbef500-c2c0-11ea-9842-05b63612c4b9.jpg",api:{public:"https://api.btcturk.com/api/v2",private:"https://api.btcturk.com/api/v1",graph:"https://graph-api.btcturk.com/v1"},www:"https://www.btcturk.com",doc:"https://github.com/BTCTrader/broker-api-docs"},api:{public:{get:{orderbook:1,ticker:.1,trades:1,"server/exchangeinfo":1}},private:{get:{"users/balances":1,openOrders:1,allOrders:1,"users/transactions/trade":1},post:{order:1,cancelOrder:1},delete:{order:1}},graph:{get:{ohlcs:1,"klines/history":1}}},fees:{trading:{maker:this.parseNumber("0.0005"),taker:this.parseNumber("0.0009")}},exceptions:{exact:{FAILED_ORDER_WITH_OPEN_ORDERS:t8,FAILED_LIMIT_ORDER:uk,FAILED_MARKET_ORDER:uk}},precisionMode:s8})}async fetchMarkets(e={}){const t=await this.publicGetServerExchangeinfo(e),s=this.safeValue(t,"data"),i=this.safeValue(s,"symbols",[]),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"name"),d=this.safeString(a,"numerator"),c=this.safeString(a,"denominator"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),l=this.safeValue(a,"filters",[]);let p,m,g,y,b;for(let S=0;S<l.length;S++){const k=l[S];this.safeString(k,"filterType")==="PRICE_FILTER"&&(p=this.safeNumber(k,"minPrice"),m=this.safeNumber(k,"maxPrice"),g=this.safeNumber(k,"minAmount"),y=this.safeNumber(k,"maxAmount"),b=this.safeNumber(k,"minExchangeValue"))}const w=this.safeString(a,"status");n.push({id:o,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:w==="TRADING",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(a,"numeratorScale"))),price:this.parseNumber(this.parsePrecision(this.safeString(a,"denominatorScale")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:g,max:y},price:{min:p,max:m},cost:{min:b,max:void 0}},info:a})}return n}parseBalance(e){const t=this.safeValue(e,"data",[]),s={info:e,timestamp:void 0,datetime:void 0};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"asset"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(n,"balance"),o.free=this.safeString(n,"free"),o.used=this.safeString(n,"locked"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetUsersBalances(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pairSymbol:i.id},r=await this.publicGetOrderbook(this.extend(n,s)),a=this.safeValue(r,"data"),o=this.safeInteger(a,"timestamp");return this.parseOrderBook(a,i.symbol,o,"bids","asks",0,1)}parseTicker(e,t=void 0){const s=this.safeString(e,"pair");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeInteger(e,"timestamp"),r=this.safeString(e,"last");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:r,last:r,previousClose:void 0,change:this.safeString(e,"daily"),percentage:this.safeString(e,"dailyPercent"),average:this.safeString(e,"average"),baseVolume:this.safeString(e,"volume"),quoteVolume:void 0,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTicker(t),i=this.safeValue(s,"data");return this.parseTickers(i,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=await this.fetchTickers([e],t);return this.safeValue(s,e)}parseTrade(e,t=void 0){const s=this.safeInteger2(e,"date","timestamp"),i=this.safeString2(e,"tid","id"),n=this.safeString(e,"orderId"),r=this.safeString(e,"price"),a=Zm.stringAbs(this.safeString(e,"amount")),o=this.safeString(e,"pair"),d=this.safeSymbol(o,t),c=this.safeString2(e,"side","orderType");let u;const h=this.safeString(e,"fee");if(h!==void 0){const l=this.safeString(e,"denominatorSymbol");u={cost:Zm.stringAbs(h),currency:this.safeCurrencyCode(l)}}return this.safeTrade({info:e,id:i,order:n,timestamp:s,datetime:this.iso8601(s),symbol:d,type:void 0,side:c,takerOrMaker:void 0,price:r,amount:a,cost:void 0,fee:u},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pairSymbol:n.id};s!==void 0&&(r.last=s);const a=await this.publicGetTrades(this.extend(r,i)),o=this.safeValue(a,"data");return this.parseTrades(o,n,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"timestamp"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1h",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,resolution:this.safeValue(this.timeframes,t,t)},o=this.safeInteger(n,"until",this.milliseconds());if(a.to=parseInt(o/1e3),s!==void 0?a.from=parseInt(s/1e3):i===void 0&&(i=100),i!==void 0){if(t==="1y")throw new e8(this.id+' fetchOHLCV () does not accept a limit parameter when timeframe == "1y"');const u=this.parseTimeframe(t)*(i-1);if(s!==void 0){const h=parseInt(s/1e3)+u;a.to=Math.min(a.to,h)}else a.from=parseInt(o/1e3)-u}const d=await this.graphGetKlinesHistory(this.extend(a,n));return this.parseOHLCVs(d,r,t,s,i)}parseOHLCVs(e,t=void 0,s="1m",i=void 0,n=void 0){const r=[],a=this.safeValue(e,"t"),o=this.safeValue(e,"h"),d=this.safeValue(e,"o"),c=this.safeValue(e,"l"),u=this.safeValue(e,"c"),h=this.safeValue(e,"v");for(let m=0;m<a.length;m++){const g={timestamp:this.safeValue(a,m),high:this.safeValue(o,m),open:this.safeValue(d,m),low:this.safeValue(c,m),close:this.safeValue(u,m),volume:this.safeValue(h,m)};r.push(this.parseOHLCV(g,t))}const l=this.sortBy(r,0),p=i===void 0;return this.filterBySinceLimit(l,i,n,0,p)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={orderType:s,orderMethod:t,pairSymbol:a.id,quantity:this.amountToPrecision(e,i)};t!=="market"&&(o.price=this.priceToPrecision(e,n)),"clientOrderId"in r?o.newClientOrderId=r.clientOrderId:"newClientOrderId"in r||(o.newClientOrderId=this.uuid());const d=await this.privatePostOrder(this.extend(o,r)),c=this.safeValue(d,"data");return this.parseOrder(c,a)}async cancelOrder(e,t=void 0,s={}){const i={id:e};return await this.privateDeleteOrder(this.extend(i,s))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.pairSymbol=r.id);const a=await this.privateGetOpenOrders(this.extend(n,i)),o=this.safeValue(a,"data"),d=this.safeValue(o,"bids",[]),c=this.safeValue(o,"asks",[]);return this.parseOrders(this.arrayConcat(d,c),r,t,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pairSymbol:n.id};s!==void 0&&(r.last=s),t!==void 0&&(r.startTime=Math.floor(t/1e3));const a=await this.privateGetAllOrders(this.extend(r,i)),o=this.safeValue(a,"data");return this.parseOrders(o,n,t,s)}parseOrderStatus(e){const t={Untouched:"open",Partial:"open",Canceled:"canceled",Closed:"closed"};return this.safeString(t,e,e)}parseOrder(e,t){const s=this.safeString(e,"id"),i=this.safeString(e,"price"),n=this.safeString2(e,"amount","quantity"),r=Zm.stringAbs(n),a=this.safeString(e,"leftAmount"),o=this.safeString(e,"pairSymbol"),d=this.safeSymbol(o,t),c=this.safeString(e,"type"),u=this.safeString(e,"method"),h=this.safeString(e,"orderClientId"),l=this.safeInteger2(e,"updateTime","datetime"),p=this.safeString(e,"status"),m=this.parseOrderStatus(p);return this.safeOrder({info:e,id:s,price:i,amount:r,remaining:a,filled:void 0,cost:void 0,average:void 0,status:m,side:c,type:u,clientOrderId:h,timestamp:l,datetime:this.iso8601(l),symbol:d,fee:void 0},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));const r=await this.privateGetUsersTransactionsTrade(),a=this.safeValue(r,"data");return this.parseTrades(a,n,t,s)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){if(this.id==="btctrader")throw new ck(this.id+" is an abstract base API for BTCExchange, BTCTurk");let a=this.urls.api[t]+"/"+e;if(s==="GET"||s==="DELETE"?Object.keys(i).length&&(a+="?"+this.urlencode(i)):r=this.json(i),t==="private"){this.checkRequiredCredentials();const o=this.nonce().toString(),d=this.base64ToBinary(this.secret),c=this.apiKey+o;n={"X-PCK":this.apiKey,"X-Stamp":o,"X-Signature":this.hmac(this.encode(c),d,"sha256","base64"),"Content-Type":"application/json"}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){const c=this.safeString(a,"code","0"),u=this.safeString(a,"message"),h=u===void 0?r:u;if(this.throwExactlyMatchedException(this.exceptions.exact,u,this.id+" "+h),c!=="0"&&c!=="SUCCESS")throw new ck(this.id+" "+h)}};const n8=me,{AddressPending:r8,AuthenticationError:a8,ExchangeError:uc,NotSupported:fk,PermissionDenied:o8,ArgumentsRequired:hk}=oe,{TICK_SIZE:d8}=pe,Jm=ke;var c8=class extends n8{describe(){return this.deepExtend(super.describe(),{id:"buda",name:"Buda",countries:["AR","CL","CO","PE"],rateLimit:1e3,version:"v2",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:void 0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/47380619-8a029200-d706-11e8-91e0-8a391fe48de3.jpg",api:{rest:"https://www.buda.com/api"},www:"https://www.buda.com",doc:"https://api.buda.com",fees:"https://www.buda.com/comisiones"},status:{status:"error",updated:void 0,eta:void 0,url:void 0},api:{public:{get:["pairs","markets","currencies","markets/{market}","markets/{market}/ticker","markets/{market}/volume","markets/{market}/order_book","markets/{market}/trades","currencies/{currency}/fees/deposit","currencies/{currency}/fees/withdrawal","tv/history"],post:["markets/{market}/quotations"]},private:{get:["balances","balances/{currency}","currencies/{currency}/balances","orders","orders/{id}","markets/{market}/orders","deposits","currencies/{currency}/deposits","withdrawals","currencies/{currency}/withdrawals","currencies/{currency}/receive_addresses","currencies/{currency}/receive_addresses/{id}"],post:["markets/{market}/orders","currencies/{currency}/deposits","currencies/{currency}/withdrawals","currencies/{currency}/simulated_withdrawals","currencies/{currency}/receive_addresses"],put:["orders/{id}"]}},timeframes:{"1m":"1","5m":"5","30m":"30","1h":"60","2h":"120","1d":"D","1w":"W"},fees:{trading:{tierBased:!0,percentage:!0,taker:.008,maker:.004,tiers:{taker:[[0,.008],[2e3,.007],[2e4,.006],[1e5,.005],[5e5,.004],[25e5,.003],[125e5,.002]],maker:[[0,.004],[2e3,.0035],[2e4,.003],[1e5,.0025],[5e5,.002],[25e5,.0015],[125e5,.001]]}}},precisionMode:d8,exceptions:{not_authorized:a8,forbidden:o8,invalid_record:uc,not_found:uc,parameter_missing:uc,bad_parameter:uc}})}async fetchCurrencyInfo(e,t=void 0){if(!t){const s=await this.publicGetCurrencies();t=this.safeValue(s,"currencies")}for(let s=0;s<t.length;s++){const i=t[s];if(i.id===e)return i}}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=this.safeValue(t,"markets",[]),i=await this.publicGetCurrencies(),n=this.safeValue(i,"currencies"),r=[];for(let a=0;a<s.length;a++){const o=s[a],d=this.safeString(o,"base_currency"),c=this.safeString(o,"quote_currency"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),l=await this.fetchCurrencyInfo(d,n),p=await this.fetchCurrencyInfo(c,n),m=this.safeValue(o,"minimum_order_amount",[]),g=this.safeString(o,"taker_fee"),y=this.safeString(o,"maker_fee");r.push({id:this.safeString(o,"id"),symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,taker:this.parseNumber(Jm.stringDiv(g,"1000")),maker:this.parseNumber(Jm.stringDiv(y,"1000")),precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(l,"input_decimals"))),price:this.parseNumber(this.parsePrecision(this.safeString(p,"input_decimals")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(m,0),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:o})}return r}async fetchCurrencies(e={}){const s=(await this.publicGetCurrencies()).currencies,i={};for(let n=0;n<s.length;n++){const r=s[n];if(!this.safeValue(r,"managed",!1))continue;const o=this.safeString(r,"id"),d=this.safeCurrencyCode(o),c=this.parseNumber(this.parsePrecision(this.safeString(r,"input_decimals"))),u=this.safeValue(r,"deposit_minimum",[]),h=this.safeValue(r,"withdrawal_minimum",[]),l=this.safeNumber(u,0),p=this.safeNumber(h,0);i[d]={id:o,code:d,info:r,name:void 0,active:!0,deposit:void 0,withdraw:void 0,fee:void 0,precision:c,limits:{amount:{min:c,max:void 0},deposit:{min:l,max:void 0},withdraw:{min:p}}}}return i}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s={},i={},n={};e===void 0&&(e=Object.keys(this.currencies));for(let r=0;r<e.length;r++){const a=e[r],d={currency:this.currency(a).id},c=await this.publicGetCurrenciesCurrencyFeesWithdrawal(d),u=await this.publicGetCurrenciesCurrencyFeesDeposit(d);s[a]=this.parseTransactionFee(c.fee),i[a]=this.parseTransactionFee(u.fee),n[a]={withdraw:c,deposit:u}}return{withdraw:s,deposit:i,info:n}}parseTransactionFee(e,t=void 0){return t===void 0&&(t=e.name),t==="withdrawal"&&(t="withdraw"),{type:t,currency:e.base[1],rate:e.percent,cost:parseFloat(e.base[0])}}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id},n=await this.publicGetMarketsMarketTicker(this.extend(i,t)),r=this.safeValue(n,"ticker");return this.parseTicker(r,s)}parseTicker(e,t=void 0){const s=this.milliseconds(),i=this.safeString(e,"market_id"),n=this.safeSymbol(i,t,"-"),r=this.safeValue(e,"last_price",[]),a=this.safeString(r,0);let o=this.safeString(e,"price_variation_24h");o=Jm.stringMul(o,"100");const d=this.safeValue(e,"max_bid",[]),c=this.safeValue(e,"min_ask",[]),u=this.safeValue(e,"volume",[]);return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:void 0,low:void 0,bid:this.safeString(d,0),bidVolume:void 0,ask:this.safeString(c,0),askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:o,average:void 0,baseVolume:this.safeString(u,0),quoteVolume:void 0,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetMarketsMarketTrades(this.extend(r,i));return this.parseTrades(a.trades.entries,n,t,s)}parseTrade(e,t=void 0){let s,i,r,a,o,u;return t&&(u=t.symbol),Array.isArray(e)&&(s=this.safeInteger(e,0),r=this.safeString(e,1),a=this.safeString(e,2),i=this.safeString(e,3),o=this.safeString(e,4)),this.safeTrade({id:o,order:void 0,info:e,timestamp:s,datetime:this.iso8601(s),symbol:u,type:void 0,side:i,takerOrMaker:void 0,price:r,amount:a,cost:void 0,fee:void 0},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={market:i.id},r=await this.publicGetMarketsMarketOrderBook(this.extend(n,s)),a=this.safeValue(r,"order_book");return this.parseOrderBook(a,i.symbol)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);s===void 0&&(s=this.milliseconds()-864e5);const a={symbol:r.id,resolution:this.timeframes[t],from:s/1e3,to:this.seconds()},o=await this.publicGetTvHistory(this.extend(a,n));return this.parseTradingViewOHLCV(o,r,t,s,i)}parseBalance(e){const t={info:e},s=this.safeValue(e,"balances",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeString(n,"id"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(n.available_amount,0),o.total=this.safeString(n.amount,0),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalances(e);return this.parseBalance(t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:parseInt(e)},n=await this.privateGetOrdersId(this.extend(i,s)),r=this.safeValue(n,"order");return this.parseOrder(r)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));const r={market:n.id,per:s},a=await this.privateGetMarketsMarketOrders(this.extend(r,i)),o=this.safeValue(a,"orders");return this.parseOrders(o,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={state:"pending"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={state:"traded"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets(),s=s==="buy"?"Bid":"Ask";const o={market:this.market(e).id,price_type:t,type:s,amount:this.amountToPrecision(e,i)};t==="limit"&&(o.limit=this.priceToPrecision(e,n));const d=await this.privatePostMarketsMarketOrders(this.extend(o,r)),c=this.safeValue(d,"order");return this.parseOrder(c)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:parseInt(e),state:"canceling"},n=await this.privatePutOrdersId(this.extend(i,s)),r=this.safeValue(n,"order");return this.parseOrder(r)}parseOrderStatus(e){const t={traded:"closed",received:"open",canceling:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.parse8601(this.safeString(e,"created_at")),n=this.iso8601(i),r=this.safeString(e,"market_id"),a=this.safeSymbol(r,t,"-"),o=this.safeString(e,"price_type"),d=this.safeStringLower(e,"type"),c=this.parseOrderStatus(this.safeString(e,"state")),u=this.safeValue(e,"original_amount",[]),h=this.safeString(u,0),l=this.safeValue(e,"amount",[]),p=this.safeString(l,0),m=this.safeValue(e,"traded_amount",[]),g=this.safeString(m,0),y=this.safeValue(e,"total_exchanged",[]),b=this.safeString(y,0),w=this.safeValue(e,"limit",[]);let S=this.safeString(w,0);S===void 0&&w!==void 0&&(S=w);const k=this.safeValue(e,"paid_fee",[]),T=this.safeString(k,0);let I;if(T!==void 0){const _=this.safeString(k,1),N=this.safeCurrencyCode(_);I={cost:T,code:N,currency:N}}return this.safeOrder({info:e,id:s,clientOrderId:void 0,datetime:n,timestamp:i,lastTradeTimestamp:void 0,status:c,symbol:a,type:o,timeInForce:void 0,postOnly:void 0,side:d,price:S,stopPrice:void 0,average:void 0,cost:b,amount:h,filled:g,remaining:p,trades:void 0,fee:I},t)}isFiat(e){const t={ARS:!0,CLP:!0,COP:!0,PEN:!0};return this.safeValue(t,e,!1)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e);if(this.isFiat(e))throw new fk(this.id+" fetchDepositAddress() for fiat "+e+" is not supported");const i={currency:s.id},n=await this.privateGetCurrenciesCurrencyReceiveAddresses(this.extend(i,t)),r=this.safeValue(n,"receive_addresses"),a=[];for(let c=1;c<r.length;c++){const u=r[c];if(u.ready){const h=u.address;this.checkAddress(h),a.push(h)}}if(a.length<1)throw new r8(this.id+": there are no addresses ready for receiving "+e+", retry again later)");const d=a[0];return{currency:e,address:d,tag:void 0,network:void 0,info:r}}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e);if(this.isFiat(e))throw new fk(this.id+" createDepositAddress() of fiat for "+e+" is not supported");const i={currency:s.id},n=await this.privatePostCurrenciesCurrencyReceiveAddresses(this.extend(i,t)),r=this.safeString(n.receive_address,"address");return{currency:e,address:r,tag:void 0,info:n}}parseTransactionStatus(e){const t={rejected:"failed",confirmed:"ok",anulled:"canceled",retained:"canceled",pending_confirmation:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.parse8601(this.safeString(e,"created_at")),n=this.safeString(e,"currency"),r=this.safeCurrencyCode(n,t),a=parseFloat(e.amount[0]),o=parseFloat(e.fee[0]),d=e.fee[1],c=this.parseTransactionStatus(this.safeString(e,"state")),u="deposit_data"in e?"deposit":"withdrawal",h=this.safeValue(e,u+"_data",{}),l=this.safeValue(h,"target_address"),p=this.safeString(h,"tx_hash"),m=this.parse8601(this.safeString(h,"updated_at"));return{info:e,id:s,txid:p,timestamp:i,datetime:this.iso8601(i),network:void 0,address:l,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:u,amount:a,currency:r,status:c,updated:m,fee:{cost:o,rate:d}}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),e===void 0)throw new hk(this.id+" fetchDeposits() requires a currency code argument");const n=this.currency(e),r={currency:n.id,per:s},a=await this.privateGetCurrenciesCurrencyDeposits(this.extend(r,i)),o=this.safeValue(a,"deposits");return this.parseTransactions(o,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),e===void 0)throw new hk(this.id+" fetchWithdrawals() requires a currency code argument");const n=this.currency(e),r={currency:n.id,per:s},a=await this.privateGetCurrenciesCurrencyWithdrawals(this.extend(r,i)),o=this.safeValue(a,"withdrawals");return this.parseTransactions(o,n,t,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const a={currency:this.currency(e).id,amount:t,withdrawal_data:{target_address:s}},o=await this.privatePostCurrenciesCurrencyWithdrawals(this.extend(a,n)),d=this.safeValue(o,"withdrawal");return this.parseTransaction(d)}nonce(){return this.microseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));Object.keys(o).length&&(s==="GET"?a+="?"+this.urlencode(o):r=this.json(o));const d=this.urls.api.rest+"/"+this.version+"/"+a;if(t==="private"){this.checkRequiredCredentials();const c=this.nonce().toString(),u=[s,"/api/"+this.version+"/"+a];if(r){const p=this.stringToBase64(r);u.push(this.decode(p))}u.push(c);const h=u.join(" "),l=this.hmac(this.encode(h),this.encode(this.secret),"sha384");n={"X-SBTC-APIKEY":this.apiKey,"X-SBTC-SIGNATURE":l,"X-SBTC-NONCE":c,"Content-Type":"application/json"}}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&e>=400){const c=this.safeString(a,"code"),u=this.safeString(a,"message",r),h=this.id+" "+u;if(c!==void 0)throw this.throwExactlyMatchedException(this.exceptions,c,h),new uc(h)}}};const u8=me,{TICK_SIZE:f8}=pe,{AuthenticationError:Na,ExchangeError:Ps,ArgumentsRequired:Fs,PermissionDenied:Bo,InvalidOrder:Le,OrderNotFound:Of,InsufficientFunds:Ln,BadRequest:wt,RateLimitExceeded:fc,InvalidNonce:h8,NotSupported:wn}=oe,bi=ke;var A_=class extends u8{describe(){return this.deepExtend(super.describe(),{id:"bybit",name:"Bybit",countries:["VG"],version:"v2",userAgent:void 0,rateLimit:20,hostname:"bybit.com",pro:!0,certified:!0,has:{CORS:!0,spot:!0,margin:!0,swap:!0,future:!0,option:void 0,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!0,fetchBalance:!0,fetchBorrowInterest:!1,fetchBorrowRate:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchFundingRate:!0,fetchFundingRateHistory:!1,fetchIndexOHLCV:!0,fetchLedger:!0,fetchMarketLeverageTiers:!0,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenInterestHistory:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPositions:!0,fetchPremiumIndexOHLCV:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactions:void 0,fetchTransfers:!0,fetchWithdrawals:!0,setLeverage:!0,setMarginMode:!0,setPositionMode:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"1","3m":"3","5m":"5","15m":"15","30m":"30","1h":"60","2h":"120","4h":"240","6h":"360","12h":"720","1d":"D","1w":"W","1M":"M","1y":"Y"},urls:{test:{spot:"https://api-testnet.{hostname}",futures:"https://api-testnet.{hostname}",v2:"https://api-testnet.{hostname}",public:"https://api-testnet.{hostname}",private:"https://api-testnet.{hostname}"},logo:"https://user-images.githubusercontent.com/51840849/76547799-daff5b80-649e-11ea-87fb-3be9bac08954.jpg",api:{spot:"https://api.{hostname}",futures:"https://api.{hostname}",v2:"https://api.{hostname}",public:"https://api.{hostname}",private:"https://api.{hostname}"},www:"https://www.bybit.com",doc:["https://bybit-exchange.github.io/docs/inverse/","https://bybit-exchange.github.io/docs/linear/","https://github.com/bybit-exchange"],fees:"https://help.bybit.com/hc/en-us/articles/360039261154",referral:"https://www.bybit.com/register?affiliate_id=35953"},api:{public:{get:{"v2/public/orderBook/L2":1,"v2/public/kline/list":3,"v2/public/tickers":1,"v2/public/trading-records":1,"v2/public/symbols":1,"v2/public/mark-price-kline":3,"v2/public/index-price-kline":3,"v2/public/premium-index-kline":2,"v2/public/open-interest":1,"v2/public/big-deal":1,"v2/public/account-ratio":1,"v2/public/funding-rate":1,"v2/public/elite-ratio":1,"v2/public/funding/prev-funding-rate":1,"v2/public/risk-limit/list":1,"public/linear/kline":3,"public/linear/recent-trading-records":1,"public/linear/risk-limit":1,"public/linear/funding/prev-funding-rate":1,"public/linear/mark-price-kline":1,"public/linear/index-price-kline":1,"public/linear/premium-index-kline":1,"spot/v1/time":1,"spot/v1/symbols":1,"spot/quote/v1/depth":1,"spot/quote/v1/depth/merged":1,"spot/quote/v1/trades":1,"spot/quote/v1/kline":1,"spot/quote/v1/ticker/24hr":1,"spot/quote/v1/ticker/price":1,"spot/quote/v1/ticker/book_ticker":1,"spot/v3/public/symbols":1,"spot/v3/public/quote/depth":1,"spot/v3/public/quote/depth/merged":1,"spot/v3/public/quote/trades":1,"spot/v3/public/quote/kline":1,"spot/v3/public/quote/ticker/24hr":1,"spot/v3/public/quote/ticker/price":1,"spot/v3/public/quote/ticker/bookTicker":1,"spot/v3/public/server-time":1,"spot/v3/public/infos":1,"v2/public/time":1,"v3/public/time":1,"v2/public/announcement":1,"option/usdc/openapi/public/v1/order-book":1,"option/usdc/openapi/public/v1/symbols":1,"option/usdc/openapi/public/v1/tick":1,"option/usdc/openapi/public/v1/delivery-price":1,"option/usdc/openapi/public/v1/query-trade-latest":1,"option/usdc/openapi/public/v1/query-historical-volatility":1,"option/usdc/openapi/public/v1/all-tickers":1,"perpetual/usdc/openapi/public/v1/order-book":1,"perpetual/usdc/openapi/public/v1/symbols":1,"perpetual/usdc/openapi/public/v1/tick":1,"perpetual/usdc/openapi/public/v1/kline/list":1,"perpetual/usdc/openapi/public/v1/mark-price-kline":1,"perpetual/usdc/openapi/public/v1/index-price-kline":1,"perpetual/usdc/openapi/public/v1/premium-index-kline":1,"perpetual/usdc/openapi/public/v1/open-interest":1,"perpetual/usdc/openapi/public/v1/big-deal":1,"perpetual/usdc/openapi/public/v1/account-ratio":1,"perpetual/usdc/openapi/public/v1/prev-funding-rate":1,"perpetual/usdc/openapi/public/v1/risk-limit/list":1,"asset/v1/public/deposit/allowed-deposit-list":1,"contract/v3/public/copytrading/symbol/list":1,"derivatives/v3/public/order-book/L2":1,"derivatives/v3/public/kline":1,"derivatives/v3/public/tickers":1,"derivatives/v3/public/instruments-info":1,"derivatives/v3/public/mark-price-kline":1,"derivatives/v3/public/index-price-kline":1,"derivatives/v3/public/funding/history-funding-rate":1,"derivatives/v3/public/risk-limit/list":1,"derivatives/v3/public/delivery-price":1,"derivatives/v3/public/recent-trade":1,"derivatives/v3/public/open-interest":1}},private:{get:{"v2/private/order/list":5,"v2/private/order":5,"v2/private/stop-order/list":5,"v2/private/stop-order":1,"v2/private/position/list":25,"v2/private/position/fee-rate":40,"v2/private/execution/list":25,"v2/private/trade/closed-pnl/list":1,"v2/public/risk-limit/list":1,"v2/public/funding/prev-funding-rate":25,"v2/private/funding/prev-funding":25,"v2/private/funding/predicted-funding":25,"v2/private/account/api-key":5,"v2/private/account/lcp":1,"v2/private/wallet/balance":25,"v2/private/wallet/fund/records":25,"v2/private/wallet/withdraw/list":25,"v2/private/exchange-order/list":1,"private/linear/order/list":5,"private/linear/order/search":5,"private/linear/stop-order/list":5,"private/linear/stop-order/search":5,"private/linear/position/list":25,"private/linear/trade/execution/list":25,"private/linear/trade/closed-pnl/list":25,"public/linear/risk-limit":1,"private/linear/funding/predicted-funding":25,"private/linear/funding/prev-funding":25,"futures/private/order/list":5,"futures/private/order":5,"futures/private/stop-order/list":5,"futures/private/stop-order":5,"futures/private/position/list":25,"futures/private/execution/list":25,"futures/private/trade/closed-pnl/list":1,"spot/v1/account":2.5,"spot/v1/order":2.5,"spot/v1/open-orders":2.5,"spot/v1/history-orders":2.5,"spot/v1/myTrades":2.5,"spot/v1/cross-margin/order":10,"spot/v1/cross-margin/accounts/balance":10,"spot/v1/cross-margin/loan-info":10,"spot/v1/cross-margin/repay/history":10,"spot/v3/private/order":2.5,"spot/v3/private/open-orders":2.5,"spot/v3/private/history-orders":2.5,"spot/v3/private/my-trades":2.5,"spot/v3/private/account":2.5,"spot/v3/private/reference":2.5,"spot/v3/private/record":2.5,"spot/v3/private/cross-margin-orders":10,"spot/v3/private/cross-margin-account":10,"spot/v3/private/cross-margin-loan-info":10,"spot/v3/private/cross-margin-repay-history":10,"asset/v1/private/transfer/list":50,"asset/v3/private/transfer/inter-transfer/list/query":.84,"asset/v1/private/sub-member/transfer/list":50,"asset/v3/private/transfer/sub-member/list/query":.84,"asset/v3/private/transfer/sub-member-transfer/list/query":.84,"asset/v3/private/transfer/universal-transfer/list/query":.84,"asset/v1/private/sub-member/member-ids":50,"asset/v1/private/deposit/record/query":50,"asset/v1/private/withdraw/record/query":25,"asset/v1/private/coin-info/query":25,"asset/v3/private/coin-info/query":25,"asset/v1/private/asset-info/query":50,"asset/v1/private/deposit/address":100,"asset/v3/private/deposit/address/query":.17,"asset/v1/private/universal/transfer/list":50,"contract/v3/private/copytrading/order/list":1,"contract/v3/private/copytrading/position/list":1,"contract/v3/private/copytrading/wallet/balance":1,"contract/v3/private/position/limit-info":25,"contract/v3/private/order/unfilled-orders":1,"unified/v3/private/order/unfilled-orders":1,"unified/v3/private/order/list":1,"unified/v3/private/position/list":1,"unified/v3/private/execution/list":1,"unified/v3/private/delivery-record":1,"unified/v3/private/settlement-record":1,"unified/v3/private/account/wallet/balance":1,"unified/v3/private/account/transaction-log":1,"asset/v2/private/exchange/exchange-order-all":1,"unified/v3/private/account/borrow-history":1,"unified/v3/private/account/borrow-rate":1,"user/v3/private/frozen-sub-member":10,"user/v3/private/query-sub-members":5,"user/v3/private/query-api":5,"asset/v3/private/transfer/transfer-coin/list/query":.84,"asset/v3/private/transfer/account-coin/balance/query":.84,"asset/v3/private/transfer/asset-info/query":.84,"asset/v3/public/deposit/allowed-deposit-list/query":.17,"asset/v3/private/deposit/record/query":.17,"asset/v3/private/withdraw/record/query":.17},post:{"v2/private/order/create":30,"v2/private/order/cancel":30,"v2/private/order/cancelAll":300,"v2/private/order/replace":30,"v2/private/stop-order/create":30,"v2/private/stop-order/cancel":30,"v2/private/stop-order/cancelAll":300,"v2/private/stop-order/replace":30,"v2/private/position/change-position-margin":40,"v2/private/position/trading-stop":40,"v2/private/position/leverage/save":40,"v2/private/tpsl/switch-mode":40,"v2/private/position/switch-isolated":2.5,"v2/private/position/risk-limit":2.5,"v2/private/position/switch-mode":2.5,"private/linear/order/create":30,"private/linear/order/cancel":30,"private/linear/order/cancel-all":300,"private/linear/order/replace":30,"private/linear/stop-order/create":30,"private/linear/stop-order/cancel":30,"private/linear/stop-order/cancel-all":300,"private/linear/stop-order/replace":30,"private/linear/position/set-auto-add-margin":40,"private/linear/position/switch-isolated":40,"private/linear/position/switch-mode":40,"private/linear/tpsl/switch-mode":2.5,"private/linear/position/add-margin":40,"private/linear/position/set-leverage":40,"private/linear/position/trading-stop":40,"private/linear/position/set-risk":2.5,"futures/private/order/create":30,"futures/private/order/cancel":30,"futures/private/order/cancelAll":30,"futures/private/order/replace":30,"futures/private/stop-order/create":30,"futures/private/stop-order/cancel":30,"futures/private/stop-order/cancelAll":30,"futures/private/stop-order/replace":30,"futures/private/position/change-position-margin":40,"futures/private/position/trading-stop":40,"futures/private/position/leverage/save":40,"futures/private/position/switch-mode":40,"futures/private/tpsl/switch-mode":40,"futures/private/position/switch-isolated":40,"futures/private/position/risk-limit":2.5,"spot/v1/order":2.5,"spot/v1/cross-margin/loan":10,"spot/v1/cross-margin/repay":10,"spot/v3/private/order":2.5,"spot/v3/private/cancel-order":2.5,"spot/v3/private/cancel-orders":2.5,"spot/v3/private/cancel-orders-by-ids":2.5,"spot/v3/private/purchase":2.5,"spot/v3/private/redeem":2.5,"spot/v3/private/cross-margin-loan":10,"spot/v3/private/cross-margin-repay":10,"asset/v1/private/transfer":150,"asset/v3/private/transfer/inter-transfer":2.5,"asset/v1/private/sub-member/transfer":150,"asset/v1/private/withdraw":50,"asset/v3/private/withdraw/create":1,"asset/v1/private/withdraw/cancel":50,"asset/v3/private/withdraw/cancel":.84,"asset/v1/private/transferable-subs/save":3e3,"asset/v1/private/universal/transfer":1500,"asset/v3/private/transfer/sub-member-transfer":2.5,"asset/v3/private/transfer/transfer-sub-member-save":2.5,"asset/v3/private/transfer/universal-transfer":2.5,"user/v3/private/create-sub-member":10,"user/v3/private/create-sub-api":10,"user/v3/private/update-api":10,"user/v3/private/delete-api":10,"user/v3/private/update-sub-api":10,"user/v3/private/delete-sub-api":10,"option/usdc/openapi/private/v1/place-order":2.5,"option/usdc/openapi/private/v1/batch-place-order":2.5,"option/usdc/openapi/private/v1/replace-order":2.5,"option/usdc/openapi/private/v1/batch-replace-orders":2.5,"option/usdc/openapi/private/v1/cancel-order":2.5,"option/usdc/openapi/private/v1/batch-cancel-orders":2.5,"option/usdc/openapi/private/v1/cancel-all":2.5,"option/usdc/openapi/private/v1/query-active-orders":2.5,"option/usdc/openapi/private/v1/query-order-history":2.5,"option/usdc/openapi/private/v1/execution-list":2.5,"option/usdc/openapi/private/v1/query-transaction-log":2.5,"option/usdc/openapi/private/v1/query-wallet-balance":2.5,"option/usdc/openapi/private/v1/query-asset-info":2.5,"option/usdc/openapi/private/v1/query-margin-info":2.5,"option/usdc/openapi/private/v1/query-position":2.5,"option/usdc/openapi/private/v1/query-delivery-list":2.5,"option/usdc/openapi/private/v1/query-position-exp-date":2.5,"option/usdc/openapi/private/v1/mmp-modify":2.5,"option/usdc/openapi/private/v1/mmp-reset":2.5,"perpetual/usdc/openapi/private/v1/place-order":2.5,"perpetual/usdc/openapi/private/v1/replace-order":2.5,"perpetual/usdc/openapi/private/v1/cancel-order":2.5,"perpetual/usdc/openapi/private/v1/cancel-all":2.5,"perpetual/usdc/openapi/private/v1/position/leverage/save":2.5,"option/usdc/openapi/private/v1/session-settlement":2.5,"option/usdc/private/asset/account/setMarginMode":2.5,"perpetual/usdc/openapi/public/v1/risk-limit/list":2.5,"perpetual/usdc/openapi/private/v1/position/set-risk-limit":2.5,"perpetual/usdc/openapi/private/v1/predicted-funding":2.5,"contract/v3/private/copytrading/order/create":2.5,"contract/v3/private/copytrading/order/cancel":2.5,"contract/v3/private/copytrading/order/close":2.5,"contract/v3/private/copytrading/position/close":2.5,"contract/v3/private/copytrading/position/set-leverage":2.5,"contract/v3/private/copytrading/wallet/transfer":2.5,"contract/v3/private/copytrading/order/trading-stop":2.5,"unified/v3/private/order/create":2.5,"unified/v3/private/order/replace":2.5,"unified/v3/private/order/cancel":2.5,"unified/v3/private/order/create-batch":2.5,"unified/v3/private/order/replace-batch":2.5,"unified/v3/private/order/cancel-batch":2.5,"unified/v3/private/order/cancel-all":2.5,"unified/v3/private/position/set-leverage":2.5,"unified/v3/private/position/tpsl/switch-mode":2.5,"unified/v3/private/position/set-risk-limit":2.5,"unified/v3/private/position/trading-stop":2.5,"unified/v3/private/account/upgrade-unified-account":2.5},delete:{"spot/v1/order":2.5,"spot/v1/order/fast":2.5,"spot/order/batch-cancel":2.5,"spot/order/batch-fast-cancel":2.5,"spot/order/batch-cancel-by-ids":2.5}}},httpExceptions:{403:fc},exceptions:{exact:{"-10009":wt,"-1004":wt,"-1021":wt,"-1103":wt,"-1140":Le,"-1197":Le,"-2013":Le,"-2015":Na,"-6017":wt,"-6025":wt,"-6029":wt,5004:Ps,7001:wt,10001:wt,10002:h8,10003:Na,10004:Na,10005:Bo,10006:fc,10007:Na,10010:Bo,10016:Ps,10017:wt,10018:fc,10020:Bo,12201:wt,131001:Ln,20001:Of,20003:Le,20004:Le,20005:Le,20006:Le,20007:Le,20008:Le,20009:Le,20010:Le,20011:Le,20012:Le,20013:Le,20014:Le,20015:Le,20016:Le,20017:Le,20018:Le,20019:Le,20020:Le,20021:Le,20022:wt,20023:wt,20031:wt,20070:wt,20071:wt,20084:wt,30001:wt,30003:Le,30004:Le,30005:Le,30007:Le,30008:Le,30009:Ps,30010:Ln,30011:Bo,30012:Bo,30013:Bo,30014:Le,30015:Le,30016:Ps,30017:Le,30018:Le,30019:Le,30020:Le,30021:Le,30022:Le,30023:Le,30024:Le,30025:Le,30026:Le,30027:Le,30028:Le,30029:Le,30030:Le,30031:Ln,30032:Le,30033:fc,30034:Of,30035:fc,30036:Ps,30037:Le,30041:Ps,30042:Ln,30043:Le,30044:Le,30045:Le,30049:Ln,30050:Ps,30051:Ps,30052:Ps,30054:Ps,30057:Ps,30063:Ps,30067:Ln,30068:Ps,30074:Le,30075:Le,30078:Ps,33004:Na,34026:Ps,34036:wt,35015:wt,130006:Le,130021:Ln,130074:Le,3100116:wt,3100198:wt,3200300:Ln},broad:{"unknown orderInfo":Of,"invalid api_key":Na,oc_diff:Ln,new_oc:Ln,"openapi sign params error!":Na}},precisionMode:f8,options:{createMarketBuyOrderRequiresPrice:!0,defaultType:"swap",defaultSubType:"linear",defaultSettle:"USDT",code:"BTC",recvWindow:5*1e3,timeDifference:0,adjustForTimeDifference:!1,brokerId:"CCXT",accountsByType:{spot:"SPOT",margin:"SPOT",future:"CONTRACT",swap:"CONTRACT",option:"OPTION",investment:"INVESTMENT",unified:"UNIFIED",funding:"FUND"},accountsById:{SPOT:"spot",MARGIN:"spot",CONTRACT:"contract",OPTION:"option",INVESTMENT:"investment",UNIFIED:"unified"},networks:{ERC20:"ETH",TRC20:"TRX",BEP20:"BSC",OMNI:"OMNI",SPL:"SOL"},networksById:{ETH:"ERC20",TRX:"TRC20",BSC:"BEP20",OMNI:"OMNI",SPL:"SOL"},defaultNetwork:"ERC20",defaultNetworks:{USDT:"TRC20"}},fees:{trading:{feeSide:"get",tierBased:!0,percentage:!0,taker:75e-5,maker:1e-4},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}}})}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchTime(e={}){const t=await this.publicGetV3PublicTime(e);return this.safeInteger(t,"time")}async fetchCurrencies(e={}){if(!this.checkRequiredCredentials(!1))return;const t=await this.privateGetAssetV3PrivateCoinInfoQuery(e),s=this.safeValue(t,"result",[]),i=this.safeValue(s,"rows",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"coin"),d=this.safeCurrencyCode(o),c=this.safeString(a,"name"),u=this.safeValue(a,"chains",[]),h={};let l;for(let p=0;p<u.length;p++){const m=u[p],g=this.safeString(m,"chain"),y=this.networkIdToCode(g),b=this.parseNumber(this.parsePrecision(this.safeString(m,"minAccuracy")));l=l===void 0?b:Math.min(l,b);const w=this.safeInteger(m,"chainDeposit")===1,S=this.safeInteger(m,"chainWithdraw")===1;h[y]={info:m,id:g,network:y,active:void 0,deposit:w,withdraw:S,fee:this.safeNumber(m,"withdrawFee"),precision:b,limits:{withdraw:{min:this.safeNumber(m,"withdrawMin"),max:void 0},deposit:{min:this.safeNumber(m,"depositMin"),max:void 0}}}}n[d]={info:a,code:d,id:o,name:c,active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,precision:l,limits:{amount:{min:void 0,max:void 0}},networks:h}}return n}async fetchMarkets(e={}){this.options.adjustForTimeDifference&&await this.loadTimeDifference();let t;if([t,e]=this.handleMarketTypeAndParams("fetchMarkets",void 0,e),t==="spot")return await this.fetchSpotMarkets(e);let s=[this.fetchSwapAndFutureMarkets(e),this.fetchUSDCMarkets(e)];s=await Promise.all(s);const i=s[0],n=s[1];let r=i;return r=this.arrayConcat(r,n),r}async fetchSpotMarkets(e){const t=await this.publicGetSpotV3PublicSymbols(e),s=this.safeValue(t,"result",{}),i=this.safeValue(s,"list",[]),n=[],r=this.parseNumber("0.001"),a=this.parseNumber("0.001");for(let o=0;o<i.length;o++){const d=i[o],c=this.safeString(d,"name"),u=this.safeString(d,"baseCoin"),h=this.safeString(d,"quoteCoin"),l=this.safeCurrencyCode(u),p=this.safeCurrencyCode(h),m=l+"/"+p,g=this.safeInteger(d,"showStatus")===1,y=this.safeNumber(d,"quotePrecision");n.push({id:c,symbol:m,base:l,quote:p,settle:void 0,baseId:u,quoteId:h,settleId:void 0,type:"spot",spot:!0,margin:void 0,swap:!1,future:!1,option:!1,active:g,contract:!1,linear:void 0,inverse:void 0,taker:r,maker:a,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(d,"basePrecision"),price:this.safeNumber(d,"minPricePrecision",y)},limits:{leverage:{min:this.parseNumber("1"),max:void 0},amount:{min:this.safeNumber(d,"minTradeQty"),max:this.safeNumber(d,"maxTradeQty")},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(d,"minTradeAmt"),max:this.safeNumber(d,"maxTradeAmt")}},info:d})}return n}async fetchSwapAndFutureMarkets(e){const t=await this.publicGetV2PublicSymbols(e),s=this.safeValue(t,"result",[]),i=[],n=this.safeValue(this.options,"fetchMarkets",{}),r=this.safeValue(n,"linear",{USDT:!0});for(let a=0;a<s.length;a++){const o=s[a],d=this.safeString(o,"name"),c=this.safeString(o,"base_currency"),u=this.safeString(o,"quote_currency"),h=this.safeCurrencyCode(c),l=this.safeCurrencyCode(u),p=l in r;let m=h+"/"+l;const g=h+l;let y="swap";g!==d&&(y="future");const b=this.safeValue(o,"lot_size_filter",{}),w=this.safeValue(o,"price_filter",{}),S=this.safeValue(o,"leverage_filter",{}),k=this.safeString(o,"status");let T;k!==void 0&&(T=k==="Trading");const I=y==="swap",_=y==="future";let N,M;const x=p?u:c,v=this.safeCurrencyCode(x);if(m=m+":"+v,_){const q=this.safeString(o,"alias").slice(-4),R=q.slice(0,2),H=q.slice(2,4),P=this.yyyymmdd(this.milliseconds()).split("-");M=this.safeValue(P,0)+"-"+R+"-"+H+"T00:00:00.000Z",N=this.parse8601(M),m=m+"-"+this.yymmdd(N)}const O=!p,A=O?this.safeNumber(b,"min_trading_qty"):this.parseNumber("1");i.push({id:d,symbol:m,base:h,quote:l,settle:v,baseId:c,quoteId:u,settleId:x,type:y,spot:!1,margin:void 0,swap:I,future:_,option:!1,active:T,contract:!0,linear:p,inverse:O,taker:this.safeNumber(o,"taker_fee"),maker:this.safeNumber(o,"maker_fee"),contractSize:A,expiry:N,expiryDatetime:M,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(b,"qty_step"),price:this.safeNumber(w,"tick_size")},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(S,"max_leverage",1)},amount:{min:this.safeNumber(b,"min_trading_qty"),max:this.safeNumber(b,"max_trading_qty")},price:{min:this.safeNumber(w,"min_price"),max:this.safeNumber(w,"max_price")},cost:{min:void 0,max:void 0}},info:o})}return i}async fetchUSDCMarkets(e){const t=await this.publicGetOptionUsdcOpenapiPublicV1Symbols(e),s=await this.publicGetPerpetualUsdcOpenapiPublicV1Symbols(e),i=this.safeValue(t,"result",[]),n=this.safeValue(i,"dataList",[]),r=this.safeValue(s,"result",[]),a=this.arrayConcat(n,r),o=[],d=!0;for(let c=0;c<a.length;c++){const u=a[c],h=this.safeString(u,"symbol"),l=this.safeString(u,"baseCoin"),p=this.safeString(u,"quoteCoin");let m=this.safeString(u,"settleCoin");const g=this.safeCurrencyCode(l),y=this.safeCurrencyCode(p);let b=this.safeCurrencyCode(m),w=g+"/"+y,S="swap";m!==void 0&&(S="option");const k=S==="swap",T=S==="option",I=this.safeValue(u,"leverage_filter",{}),_=this.safeString(u,"status");let N;_!==void 0&&(N=_==="ONLINE");let M,x,v,O;if(b===void 0&&(m="USDC",b="USDC"),w=w+":"+b,T){M=this.safeInteger(u,"deliveryTime"),x=this.iso8601(M);const A=h.split("-");v=this.safeString(A,2);const V=this.safeString(A,3);w=w+"-"+this.yymmdd(M)+"-"+v+"-"+V,V==="P"?O="put":V==="C"&&(O="call")}o.push({id:h,symbol:w,base:g,quote:y,settle:b,baseId:l,quoteId:p,settleId:m,type:S,spot:!1,margin:void 0,swap:k,future:!1,option:T,active:N,contract:!0,linear:d,inverse:!d,taker:this.safeNumber2(u,"taker_fee","takerFeeRate"),maker:this.safeNumber2(u,"maker_fee","makerFeeRate"),contractSize:this.parseNumber("1"),expiry:M,expiryDatetime:x,strike:v,optionType:O,precision:{amount:this.safeNumber2(u,"minOrderSizeIncrement","qtyStep"),price:this.safeNumber(u,"tickSize")},limits:{leverage:{min:this.safeNumber(I,"minLeverage",1),max:this.safeNumber(I,"maxLeverage",1)},amount:{min:this.safeNumber2(u,"minOrderSize","minTradingQty"),max:this.safeNumber2(u,"maxOrderSize","maxTradingQty")},price:{min:this.safeNumber2(u,"minOrderPrice","minPrice"),max:this.safeNumber2(u,"maxOrderPrice","maxPrice")},cost:{min:void 0,max:void 0}},info:u})}return o}parseTicker(e,t=void 0){return"s"in e?this.parseSpotTicker(e,t):this.parseContractTicker(e,t)}parseSpotTicker(e,t=void 0){const s=this.safeString(e,"s"),i=this.safeSymbol(s,t),n=this.safeInteger(e,"t");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"h"),low:this.safeString(e,"l"),bid:this.safeString(e,"bp"),bidVolume:void 0,ask:this.safeString(e,"ap"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"o"),close:this.safeString(e,"lp"),last:void 0,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"v"),quoteVolume:this.safeString(e,"qv"),info:e},t)}parseContractTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeString2(e,"last_price","lastPrice"),r=this.safeString2(e,"prev_price_24h","openPrice");let a=this.safeString2(e,"price_24h_pcnt","change24h");a=bi.stringMul(a,"100");const o=this.safeStringN(e,["turnover_24h","turnover24h","quoteVolume"]),d=this.safeStringN(e,["volume_24h","volume24h","volume"]),c=this.safeStringN(e,["bid_price","bid","bestBidPrice"]),u=this.safeStringN(e,["ask_price","ask","bestAskPrice"]),h=this.safeStringN(e,["high_price_24h","high24h","highPrice"]),l=this.safeStringN(e,["low_price_24h","low24h","lowPrice"]);return this.safeTicker({symbol:i,timestamp:void 0,datetime:void 0,high:h,low:l,bid:c,bidVolume:this.safeString(e,"bidSize"),ask:u,askVolume:this.safeString(e,"askSize"),vwap:void 0,open:r,close:n,last:n,previousClose:void 0,change:void 0,percentage:a,average:void 0,baseVolume:d,quoteVolume:o,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);let i;const n=s.settle==="USDC";s.spot?i="publicGetSpotV3PublicQuoteTicker24hr":n?s.option?i="publicGetOptionUsdcOpenapiPublicV1Tick":i="publicGetPerpetualUsdcOpenapiPublicV1Tick":i="publicGetV2PublicTickers";const r={symbol:s.id},a=await this[i](this.extend(r,t)),o=this.safeValue(a,"result",[]);let d;return Array.isArray(o)?d=this.safeValue(o,0):d=o,this.parseTicker(d,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s,i,n;if(e!==void 0){const d=this.safeValue(e,0);i=this.market(d),s=i.type,n=i.settle==="USDC"}else if([s,t]=this.handleMarketTypeAndParams("fetchTickers",i,t),s!=="spot"){let d=this.safeString(this.options,"defaultSettle","USDT");d=this.safeString2(t,"settle","defaultSettle",n),t=this.omit(t,["settle","defaultSettle"]),n=d==="USDC"}let r;if(s==="spot")r="publicGetSpotV3PublicQuoteTicker24hr";else if(!n)r="publicGetV2PublicTickers";else throw new wn(this.id+" fetchTickers() is not supported for USDC markets");const a=await this[r](t);let o=this.safeValue(a,"result",[]);return Array.isArray(o)||(o=this.safeValue(o,"list",[])),this.parseTickers(o,e,t)}parseOHLCV(e,t=void 0){return"t"in e?this.parseSpotOHLCV(e,t):this.parseContractOHLCV(e,t)}parseSpotOHLCV(e,t=void 0){return[this.safeInteger(e,"t"),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}parseContractOHLCV(e,t=void 0){if(Array.isArray(e))return[this.safeNumber(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)];let s=this.safeTimestamp2(e,"open_time","openTime");return s===void 0&&(s=this.safeTimestamp(e,"start_at")),[s,this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber2(e,"volume","turnover")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.safeString(n,"price");n=this.omit(n,"price");const o={symbol:r.id},d=this.parseTimeframe(t),c=this.seconds();let u;i===void 0&&(i=200),s===void 0?u=c-i*d:u=parseInt(s/1e3),i!==void 0&&(o.limit=i);let h,l="interval",p="from";const m=r.settle==="USDC";if(r.spot)h="publicGetSpotV3PublicQuoteKline";else if(r.contract&&!m)if(r.linear){const b={mark:"publicGetPublicLinearMarkPriceKline",index:"publicGetPublicLinearIndexPriceKline",premiumIndex:"publicGetPublicLinearPremiumIndexKline"};h=this.safeValue(b,a,"publicGetPublicLinearKline")}else{const b={mark:"publicGetV2PublicMarkPriceKline",index:"publicGetV2PublicIndexPriceKline",premiumIndex:"publicGetV2PublicPremiumPriceKline"};h=this.safeValue(b,a,"publicGetV2PublicKlineList")}else{if(r.option)throw new wn(this.id+" fetchOHLCV() is not supported for USDC options markets");l="period",p="startTime";const b={mark:"publicGetPerpetualUsdcOpenapiPublicV1MarkPriceKline",index:"publicGetPerpetualUsdcOpenapiPublicV1IndexPriceKline",premiumIndex:"publicGetPerpetualUsdcOpenapiPublicV1PremiumPriceKline"};h=this.safeValue(b,a,"publicGetPerpetualUsdcOpenapiPublicV1KlineList")}o[l]=r.spot?t:this.timeframes[t],o[p]=u;const g=await this[h](this.extend(o,n));let y=this.safeValue(g,"result",{});return"list"in y&&(y=this.safeValue(y,"list",{})),this.parseOHLCVs(y,r,t,s,i)}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=s.settle==="USDC";let r;n?r="privatePostPerpetualUsdcOpenapiPrivateV1PredictedFunding":r=s.linear?"privateGetPrivateLinearFundingPredictedFunding":"privateGetV2PrivateFundingPredictedFunding";const a=await this[r](this.extend(i,t)),o=this.safeValue(a,"result",{}),d=this.safeNumber2(o,"predicted_funding_rate","predictedFundingRate"),c=this.safeTimestamp(a,"time_now");return{info:a,symbol:e,markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:c,datetime:this.iso8601(c),fundingRate:d,fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchIndexOHLCV(e,t="1m",s=void 0,i=void 0,n={}){const r={price:"index"};return await this.fetchOHLCV(e,t,s,i,this.extend(r,n))}async fetchMarkOHLCV(e,t="1m",s=void 0,i=void 0,n={}){const r={price:"mark"};return await this.fetchOHLCV(e,t,s,i,this.extend(r,n))}async fetchPremiumIndexOHLCV(e,t="1m",s=void 0,i=void 0,n={}){const r={price:"premiumIndex"};return await this.fetchOHLCV(e,t,s,i,this.extend(r,n))}parseTrade(e,t=void 0){return"isBuyerMaker"in e||"feeTokenId"in e?this.parseSpotTrade(e,t):this.parseContractTrade(e,t)}parseSpotTrade(e,t=void 0){const s=this.safeIntegerN(e,["time","creatTime"]);let i,n;const r=this.safeInteger(e,"isBuyerMaker");if(r!==void 0)i="taker",n=r===1?"buy":"sell";else{const c=this.safeInteger(e,"isBuyer");i=this.safeInteger(e,"isMaker")===1?"maker":"taker",n=c===1?"buy":"sell"}const a=this.safeString(e,"symbol");t=this.safeMarket(a,t);let o={};const d=this.safeString(e,"feeTokenId");if(d!==void 0){const c=this.safeCurrencyCode(d);o={cost:this.safeString(e,"execFee"),currency:c}}return this.safeTrade({id:this.safeString(e,"id"),info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:this.safeString(e,"orderId"),type:void 0,side:n,takerOrMaker:i,price:this.safeString2(e,"price","orderPrice"),amount:this.safeString2(e,"qty","orderQty"),cost:void 0,fee:o},t)}parseContractTrade(e,t=void 0){const s=this.safeString2(e,"id","exec_id"),i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const n=t.symbol;let r=this.safeString2(e,"qty","exec_qty");r===void 0&&(r=this.safeString(e,"orderQty"));let a=this.safeString2(e,"exec_price","price");a===void 0&&(a=this.safeString(e,"orderPrice"));const o=this.safeString(e,"exec_value");let d=this.parse8601(this.safeString(e,"time"));d===void 0&&(d=this.safeInteger2(e,"trade_time_ms","time"));let c=this.safeStringLower(e,"side");if(c===void 0){const m=this.safeValue(e,"isBuyer");m!==void 0&&(c=m?"buy":"sell")}const u=this.safeValue(e,"isMaker");let h;u!==void 0?h=u?"maker":"taker":h=this.safeString(e,"last_liquidity_ind")==="AddedLiquidity"?"maker":"taker";const l=this.safeString2(e,"exec_fee","commission");let p;if(l!==void 0){let m;t.spot?m=this.safeString(e,"commissionAsset"):m=t.inverse?t.base:t.quote,p={cost:l,currency:m,rate:this.safeString(e,"fee_rate")}}return this.safeTrade({id:s,info:e,timestamp:d,datetime:this.iso8601(d),symbol:n,order:this.safeString2(e,"order_id","orderId"),type:this.safeStringLower(e,"order_type"),side:c,takerOrMaker:h,price:a,amount:r,cost:o,fee:p},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);let r;const a={symbol:n.id},o=n.settle==="USDC";n.type==="spot"?r="publicGetSpotV3PublicQuoteTrades":o?(r="publicGetOptionUsdcOpenapiPublicV1QueryTradeLatest",a.category=n.option?"OPTION":"PERPETUAL"):r=n.linear?"publicGetPublicLinearRecentTradingRecords":"publicGetV2PublicTradingRecords",s!==void 0&&(a.limit=s);const d=await this[r](this.extend(a,i));let c=this.safeValue(d,"result",{});return Array.isArray(c)||(c=this.safeValue2(c,"dataList","list",[])),this.parseTrades(c,n,t,s)}parseOrderBook(e,t,s=void 0,i="bids",n="asks",r=0,a=1){if(this.market(t).spot)return super.parseOrderBook(e,t,s,i,n,r,a);const d=[],c=[];for(let u=0;u<e.length;u++){const h=e[u],l=this.safeString(h,"side");if(l==="Buy")d.push(this.parseBidAsk(h,r,a));else if(l==="Sell")c.push(this.parseBidAsk(h,r,a));else throw new Ps(this.id+" parseOrderBook() encountered an unrecognized bidask format: "+this.json(h))}return{symbol:t,bids:this.sortBy(d,0,!0),asks:this.sortBy(c,0),timestamp:s,datetime:this.iso8601(s),nonce:void 0}}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id},r=i.settle==="USDC";let a;i.spot?a="publicGetSpotV3PublicQuoteDepth":r?a=i.option?"publicGetOptionUsdcOpenapiPublicV1OrderBook":"publicGetPerpetualUsdcOpenapiPublicV1OrderBook":a="publicGetV2PublicOrderBookL2",t!==void 0&&(n.limit=t);const o=await this[a](this.extend(n,s)),d=this.safeValue(o,"result",[]);let c=this.safeTimestamp(o,"time_now");c===void 0&&(c=this.safeInteger(d,"time"));const u=i.spot?"bids":"Buy",h=i.spot?"asks":"Sell",l=i.spot?0:"price",p=i.spot?1:"size";return this.parseOrderBook(d,e,c,u,h,l,p)}parseBalance(e){const t={info:e},s=this.safeValue(e,"result",{}),i=this.safeValue(s,"balances");if(Array.isArray(i))for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"coin"),o=this.safeCurrencyCode(a),d=this.account();d.free=this.safeString(r,"availableBalance"),d.used=this.safeString(r,"locked"),d.total=this.safeString(r,"total"),t[o]=d}else if("walletBalance"in s){const n="USDC",r=this.account();r.free=this.safeString(s,"availableBalance"),r.total=this.safeString(s,"walletBalance"),t[n]=r}else{const n=Object.keys(s);for(let r=0;r<n.length;r++){const a=n[r],o=s[a],d=this.safeCurrencyCode(a),c=this.account();c.free=this.safeString(o,"available_balance"),c.total=this.safeString(o,"wallet_balance"),t[d]=c}}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t={};let s;[s,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e);let i;if(s==="spot")i="privateGetSpotV3PrivateAccount";else{let r=this.safeString(this.options,"defaultSettle");if(r=this.safeString2(e,"settle","defaultSettle",r),e=this.omit(e,["settle","defaultSettle"]),r==="USDC")i="privatePostOptionUsdcOpenapiPrivateV1QueryWalletBalance";else{i="privateGetV2PrivateWalletBalance";const o=this.safeString2(e,"coin","code");if(e=this.omit(e,["coin","code"]),o!==void 0){const d=this.currency(o);t.coin=d.id}}}const n=await this[i](this.extend(t,e));return this.parseBalance(n)}parseOrderStatus(e){const t={Created:"open",Rejected:"rejected",New:"open",Partiallyfilled:"open",PartiallyFilled:"open",Filled:"closed",Cancelled:"canceled",Pendingcancel:"canceling",CREATED:"open",REJECTED:"rejected",NEW:"open",PENDING_NEW:"open",PARTIALLYFILLED:"open",PARTIALLY_FILLED:"open",FILLED:"closed",CANCELED:"canceled",PENDINGCANCEL:"canceling",PENDING_CANCEL:"canceling",Active:"open",Untriggered:"open",Triggered:"closed",Deactivated:"canceled"};return this.safeString(t,e,e)}parseTimeInForce(e){const t={GoodTillCancel:"GTC",ImmediateOrCancel:"IOC",FillOrKill:"FOK",PostOnly:"PO"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){return"orderCategory"in e?this.parseSpotOrder(e,t):this.parseContractOrder(e,t)}parseContractOrder(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=t.symbol;let n=this.parse8601(this.safeStringN(e,["created_at","created_time","create_time","timestamp"]));n===void 0&&(n=this.safeNumber2(e,"time","transactTime"),n===void 0&&(n=this.safeIntegerProduct(e,"createdAt",.001)));const r=this.safeStringN(e,["order_id","stop_order_id","orderId"]),a=this.safeStringLowerN(e,["order_type","type","orderType"]),o=this.safeString2(e,"price","orderPrice"),d=this.safeString2(e,"average_price","avgPrice"),c=this.safeStringN(e,["qty","origQty","orderQty"]),u=this.safeString2(e,"cum_exec_value","cumExecValue"),h=this.safeStringN(e,["cum_exec_qty","executedQty","cumExecQty"]),l=this.safeString2(e,"leaves_qty","leavesQty");let p=this.safeTimestamp(e,"last_exec_time");p===0?p=void 0:p===void 0&&(p=this.parse8601(this.safeStringN(e,["updated_time","updated_at","update_time"])),p===void 0&&(p=this.safeNumber(e,"updateTime")));const m=this.safeStringN(e,["order_status","stop_order_status","status","orderStatus"]),g=this.parseOrderStatus(m),y=this.safeStringLower(e,"side");let b;if(this.safeValue(t,"contract")){const _=this.safeString2(e,"cum_exec_fee","cumExecFee");if(_!==void 0){const N=t.linear?t.quote:t.base;b={cost:_,currency:N}}}let S=this.safeString2(e,"order_link_id","orderLinkId");S!==void 0&&S.length<1&&(S=void 0);const k=this.parseTimeInForce(this.safeString2(e,"time_in_force","timeInForce")),T=this.safeStringN(e,["trigger_price","stop_px","stopPrice","triggerPrice"]),I=k==="PO";return this.safeOrder({info:e,id:r,clientOrderId:S,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:p,symbol:i,type:a,timeInForce:k,postOnly:I,side:y,price:o,triggerPrice:T,stopPrice:T,amount:c,cost:u,average:d,filled:h,remaining:l,status:g,fee:b,trades:void 0},t)}parseSpotOrder(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeInteger(e,"createTime"),n=this.safeStringLower(e,"orderType");let r=this.safeString(e,"orderPrice");r==="0"&&n==="market"&&(r=void 0);const a=this.safeString(e,"execQty"),o=this.safeStringLower(e,"side"),d=this.parseTimeInForce(this.safeString(e,"timeInForce")),c=this.safeString(e,"triggerPrice"),u=d==="PO";let h=this.safeString(e,"orderQty");return(h===void 0||h==="0")&&t.spot&&n==="market"&&o==="buy"&&(h=a),this.safeOrder({id:this.safeString(e,"orderId"),clientOrderId:this.safeString(e,"orderLinkId"),timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:this.safeInteger(e,"updateTime"),symbol:t.symbol,type:n,timeInForce:d,postOnly:u,side:o,price:r,triggerPrice:c,stopPrice:c,amount:h,cost:this.safeString(e,"cummulativeQuoteQty"),average:this.safeString(e,"avgPrice"),filled:a,remaining:void 0,status:this.parseOrderStatus(this.safeString(e,"status")),fee:void 0,trades:void 0,info:e},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));let n;if([n,s]=this.handleMarketTypeAndParams("fetchOrder",i,s),n!=="spot"&&t===void 0)throw new Fs(this.id+" fetchOrder() requires a symbol argument for "+n+" markets");if(n==="spot"){const u={orderId:e},h=await this.privateGetSpotV3PrivateOrder(this.extend(s,u)),l=this.safeValue(h,"result",{});return this.parseOrder(l,i)}const r=i.settle==="USDC",a=this.safeString(s,"stop_order_id"),o=this.safeValue(s,"stop",!1),d=this.safeStringLower(s,"orderType"),c=o||a!==void 0||d==="stop"||d==="conditional";if(a===void 0){let u;c?u="stop_order_id":u=r?"orderId":"order_id",e!==void 0&&(s[u]=e)}if(r||i.future||i.inverse)throw new wn(this.id+" fetchOrder() supports spot markets and linear non-USDC perpetual swap markets only");{const u=await this.fetchOrders(t,void 0,void 0,s),h=this.safeValue(u,0);if(h===void 0)throw new Of(this.id+" fetchOrder() order "+e+" not found");return h}}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);e=a.symbol;const o=a.settle==="USDC";return a.spot?await this.createSpotOrder(e,t,s,i,n,r):o?await this.createUsdcOrder(e,t,s,i,n,r):await this.createContractOrder(e,t,s,i,n,r)}async createSpotOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);if(t==="market"&&s==="buy"&&this.options.createMarketBuyOrderRequiresPrice){const g=this.safeNumber(r,"cost");if(r=this.omit(r,"cost"),n===void 0&&g===void 0)throw new Le(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)");{const y=this.numberToString(i),b=this.numberToString(n),w=bi.stringMul(y,b);i=g!==void 0?g:this.parseNumber(w)}}const o=t.toUpperCase(),d={symbol:a.id,side:this.capitalize(s),orderType:o,timeInForce:"GTC",orderQty:this.amountToPrecision(e,i)};if(o==="LIMIT"||o==="LIMIT_MAKER"){if(n===void 0)throw new Le(this.id+" createOrder requires a price argument for a "+t+" order");d.orderPrice=this.priceToPrecision(e,n)}this.isPostOnly(o==="MARKET",t==="LIMIT_MAKER",r)&&(d.orderType="LIMIT_MAKER");const u=this.safeString2(r,"clientOrderId","orderLinkId");u!==void 0&&(d.orderLinkId=u),r=this.omit(r,["clientOrderId","orderLinkId","postOnly"]);const h=this.safeString(this.options,"brokerId");h!==void 0&&(d.agentSource=h);const l=this.safeNumber2(r,"triggerPrice","stopPrice");l!==void 0&&(r.triggerPrice=this.priceToPrecision(e,l)),r=this.omit(r,"stopPrice");const p=await this.privatePostSpotV3PrivateOrder(this.extend(d,r)),m=this.safeValue(p,"result",{});return this.parseOrder(m)}async createUsdcOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);if(t==="market")throw new wn(this.id+"createOrder does not allow market orders for "+e+" markets");if(n===void 0&&t==="limit")throw new Fs(this.id+" createOrder requires a price argument for limit orders");const o=t.toLowerCase(),d={symbol:a.id,side:this.capitalize(s),orderType:this.capitalize(o),timeInForce:"GoodTillCancel",orderQty:this.amountToPrecision(e,i)},c=o==="market";o==="limit"!==void 0&&(d.orderPrice=this.priceToPrecision(e,n));const h=this.safeString(r,"time_in_force"),l=this.safeStringLower(r,"timeInForce");if(this.isPostOnly(c,h==="PostOnly",r)?d.time_in_force="PostOnly":l==="gtc"?d.time_in_force="GoodTillCancel":l==="fok"?d.time_in_force="FillOrKill":l==="ioc"&&(d.time_in_force="ImmediateOrCancel"),a.swap){const w=this.safeValue2(r,"stopPrice","triggerPrice"),S=this.safeValue(r,"stopLossPrice",w),k=S!==void 0,T=this.safeValue(r,"takeProfitPrice");if(k||T!==void 0){d.orderFilter="StopOrder",d.trigger_by="LastPrice";const N=k?S:T,M=this.priceToPrecision(e,N);d.triggerPrice=M;const x=this.numberToString(a.precision.price);d.basePrice=k?bi.stringSub(M,x):bi.stringAdd(M,x)}else d.orderFilter="Order"}const m=this.safeString(r,"clientOrderId");m!==void 0?d.orderLinkId=m:a.option&&(d.orderLinkId=this.uuid16()),r=this.omit(r,["stopPrice","timeInForce","triggerPrice","stopLossPrice","takeProfitPrice","postOnly","clientOrderId"]);const g=a.option?"privatePostOptionUsdcOpenapiPrivateV1PlaceOrder":"privatePostPerpetualUsdcOpenapiPrivateV1PlaceOrder",y=await this[g](this.extend(d,r)),b=this.safeValue(y,"result",{});return this.parseOrder(b)}async createContractOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);if(n===void 0&&t==="limit")throw new Fs(this.id+" createOrder requires a price argument for limit orders");i=this.amountToPrecision(e,i),i=a.linear?parseFloat(i):parseInt(i);const o=t.toLowerCase(),d={symbol:a.id,side:this.capitalize(s),order_type:this.capitalize(o),time_in_force:"GoodTillCancel",qty:i};if(a.future){const N=this.safeInteger(r,"position_idx",0);d.position_idx=N,r=this.omit(r,"position_idx")}a.linear&&(d.reduce_only=this.safeValue2(r,"reduce_only","reduceOnly",!1),d.close_on_trigger=!1);const c=o==="market";if(o==="limit"){if(n===void 0)throw new Ps(this.id+" createOrder() requires price argument for limit orders");d.price=parseFloat(this.priceToPrecision(e,n))}const h=this.safeString(r,"time_in_force"),l=this.safeStringLower(r,"timeInForce");this.isPostOnly(c,h==="PostOnly",r)?d.time_in_force="PostOnly":l==="gtc"?d.time_in_force="GoodTillCancel":l==="fok"?d.time_in_force="FillOrKill":l==="ioc"&&(d.time_in_force="ImmediateOrCancel");const m=this.safeValueN(r,["stopPrice","triggerPrice","stop_px"]),g=m!==void 0,y=this.safeValue(r,"stopLossPrice"),b=y!==void 0,w=this.safeValue(r,"takeProfitPrice"),S=w!==void 0;if(g){d.trigger_by="LastPrice";const N=this.priceToPrecision(e,m);d.stop_px=parseFloat(N);const M=this.safeValue2(r,"base_price","basePrice");if(M===void 0)throw new Fs(this.id+" createOrder() requires a base_price parameter for trigger orders, your triggerPrice > max(market price, base_price) or triggerPrice < min(market price, base_price)");d.base_price=parseFloat(this.priceToPrecision(e,M))}S&&(d.tp_trigger_by="LastPrice",d.take_profit=parseFloat(this.priceToPrecision(e,w))),b&&(d.sl_trigger_by="LastPrice",d.stop_loss=parseFloat(this.priceToPrecision(e,y)));const k=this.safeString(r,"clientOrderId");k!==void 0&&(d.order_link_id=k),r=this.omit(r,["stop_px","stopPrice","base_price","basePrice","timeInForce","triggerPrice","stopLossPrice","takeProfitPrice","postOnly","reduceOnly","clientOrderId"]);let T;a.future?T=g?"privatePostFuturesPrivateStopOrderCreate":"privatePostFuturesPrivateOrderCreate":a.linear?T=g?"privatePostPrivateLinearStopOrderCreate":"privatePostPrivateLinearOrderCreate":T=g?"privatePostV2PrivateStopOrderCreate":"privatePostV2PrivateOrderCreate";const I=await this[T](this.extend(d,r)),_=this.safeValue(I,"result",{});return this.parseOrder(_,a)}async editUsdcOrder(e,t,s,i,n=void 0,r=void 0,a={}){await this.loadMarkets();const o=this.market(t),d={symbol:o.id,orderId:e};n!==void 0&&(d.orderQty=this.amountToPrecision(t,n)),r!==void 0&&(d.orderPrice=this.priceToPrecision(t,r));const c=o.option?"privatePostOptionUsdcOpenApiPrivateV1ReplaceOrder":"privatePostPerpetualUsdcOpenApiPrivateV1ReplaceOrder";return{info:await this[c](this.extend(d,a)),id:e}}async editContractOrder(e,t,s,i,n=void 0,r=void 0,a={}){if(t===void 0)throw new Fs(this.id+" editOrder() requires an symbol argument");await this.loadMarkets();const o=this.market(t),d={symbol:o.id};n!==void 0&&(d.p_r_qty=this.amountToPrecision(t,n)),r!==void 0&&(d.p_r_price=this.priceToPrecision(t,r));let c=!1,u="order_id";const h=this.safeValueN(a,["stopPrice","triggerPrice"]);h!==void 0&&(c=!0,u="stop_order_id",d.p_r_trigger_price=this.priceToPrecision(t,h),a=this.omit(a,["stopPrice","triggerPrice"])),d[u]=e;let l;o.linear?l=c?"privatePostPrivateLinearStopOrderReplace":"privatePostPrivateLinearOrderReplace":o.future?l=c?"privatePostFuturesPrivateStopOrderReplace":"privatePostFuturesPrivateOrderReplace":l=c?"privatePostV2PrivateStopOrderReplace":"privatePostV2PrivateOrderReplace";const p=await this[l](this.extend(d,a)),m=this.safeValue(p,"result",{});return{info:p,id:this.safeString2(m,"order_id","stop_order_id"),order_id:this.safeString(m,"order_id"),stop_order_id:this.safeString(m,"stop_order_id")}}async editOrder(e,t,s,i,n=void 0,r=void 0,a={}){if(t===void 0)throw new Fs(this.id+" editOrder() requires an symbol argument");await this.loadMarkets();const o=this.market(t),d=o.settle==="USDC";if(o.spot)throw new wn(this.id+" editOrder() does not support spot markets");return d?await this.editUsdcOrder(e,t,s,i,n,r,a):await this.editContractOrder(e,t,s,i,n,r,a)}async cancelOrder(e,t=void 0,s={}){let i;const n=t!==void 0;n&&(i=this.market(t));let r;if([r,s]=this.handleMarketTypeAndParams("cancelOrder",i,s),!n&&r!=="spot")throw new Fs(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const a={};n&&(a.symbol=i.id);const o=n&&i.spot||!n&&r==="spot",d=this.safeStringLower(s,"orderType"),u=this.safeValue(s,"stop",!1)||d==="stop"||d==="conditional";s=this.omit(s,["orderType","stop"]);const h=n&&i.settle==="USDC";let l;o?(l="privatePostSpotV3PrivateCancelOrder",e!==void 0&&(a.orderId=e)):h?(e!==void 0&&(a.orderId=e),i.option?l="privatePostOptionUsdcOpenapiPrivateV1CancelOrder":(l="privatePostPerpetualUsdcOpenapiPrivateV1CancelOrder",a.orderFilter=u?"StopOrder":"Order")):i.linear?l=u?"privatePostPrivateLinearStopOrderCancel":"privatePostPrivateLinearOrderCancel":i.swap?l=u?"privatePostV2PrivateStopOrderCancel":"privatePostV2PrivateOrderCancel":l=u?"privatePostFuturesPrivateStopOrderCancel":"privatePostFuturesPrivateOrderCancel",n&&i.contract&&!h&&e!==void 0&&(u?a.stop_order_id=e:a.order_id=e);const p=await this[l](this.extend(a,s)),m=this.safeValue(p,"result",{});return this.parseOrder(m,i)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();let s,i;if(e!==void 0)s=this.market(e),i=s.settle==="USDC";else{let l=this.safeString(this.options,"defaultSettle");l=this.safeString2(t,"settle","defaultSettle",l),t=this.omit(t,["settle","defaultSettle"]),i=l==="USDC"}let n;if([n,t]=this.handleMarketTypeAndParams("cancelAllOrders",s,t),!i&&e===void 0)throw new Fs(this.id+" cancelAllOrders() requires a symbol argument for "+n+" markets");const r={};i||(r.symbol=s.id);const a=this.safeStringLower(t,"orderType"),d=this.safeValue(t,"stop",!1)||a==="stop"||a==="conditional";t=this.omit(t,["stop","orderType"]);let c;n==="spot"?c="privateDeleteSpotOrderBatchCancel":i?c=n==="option"?"privatePostOptionUsdcOpenapiPrivateV1CancelAll":"privatePostPerpetualUsdcOpenapiPrivateV1CancelAll":n==="future"?c=d?"privatePostFuturesPrivateStopOrderCancelAll":"privatePostFuturesPrivateOrderCancelAll":s.linear?c=d?"privatePostPrivateLinearStopOrderCancelAll":"privatePostPrivateLinearOrderCancelAll":c=d?"privatePostV2PrivateStopOrderCancelAll":"privatePostV2PrivateOrderCancelAll";const u=await this[c](this.extend(r,t)),h=this.safeValue(u,"result",[]);return Array.isArray(h)?this.parseOrders(h,s):u}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Fs(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e);if(n.spot||n.settle==="USDC")throw new wn(this.id+" fetchOrders() does not support "+n.type+" markets or USDC markets, use exchange.fetchOpenOrders () and exchange.fetchClosedOrders () instead");let r;const a=this.safeValue(i,"stop",!1),o=this.safeStringLower(i,"orderType"),d=this.safeString(i,"stop_order_id"),c=a||d!==void 0||o==="stop"||o==="conditional";i=this.omit(i,["orderType","stop","orderType"]),n.linear?r=c?"privateGetPrivateLinearStopOrderList":"privateGetPrivateLinearOrderList":n.future?r=c?"privateGetFuturesPrivateStopOrderList":"privateGetFuturesPrivateOrderList":r=c?"privateGetV2PrivateStopOrderList":"privateGetV2PrivateOrderList";const u={symbol:n.id};s!==void 0&&(u.limit=s);const h=await this[r](this.extend(u,i)),l=this.safeValue(h,"result",{}),p=this.safeValue(l,"data",[]);return this.parseOrders(p,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r;if(e!==void 0)n=this.market(e),r=n.settle==="USDC";else{let h=this.safeString(this.options,"defaultSettle");h=this.safeString2(i,"settle","defaultSettle",h),i=this.omit(i,["settle","defaultSettle"]),r=h==="USDC"}let a;if([a,i]=this.handleMarketTypeAndParams("fetchClosedOrders",n,i),(a==="swap"||a==="future")&&!r){if(e===void 0)throw new Fs(this.id+" fetchClosedOrders requires a symbol argument for "+e+" markets");const h=this.safeStringLower(i,"orderType"),p=this.safeValue(i,"stop",!1)||h==="stop"||h==="conditional";i=this.omit(i,["orderType","stop"]);let m;p?m=["Active","Triggered","Cancelled","Rejected","Deactivated"]:m=["Rejected","Filled","Cancelled"];const g=m.join(","),y=this.safeString2(i,"order_status","status",g);return i=this.omit(i,["order_status","status"]),i.order_status=y,await this.fetchOrders(e,t,s,i)}const o={};let d;a==="spot"?d="privateGetSpotV3PrivateHistoryOrders":(d="privatePostOptionUsdcOpenapiPrivateV1QueryOrderHistory",o.category=a==="swap"?"perpetual":"option");const c=await this[d](this.extend(o,i));let u=this.safeValue(c,"result",[]);return Array.isArray(u)||(u=this.safeValue2(u,"list","dataList",[])),this.parseOrders(u,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r;if(e!==void 0)n=this.market(e),r=n.settle==="USDC";else{let h=this.safeString(this.options,"defaultSettle");h=this.safeString2(i,"settle","defaultSettle",h),i=this.omit(i,["settle","defaultSettle"]),r=h==="USDC"}let a;[a,i]=this.handleMarketTypeAndParams("fetchOpenOrders",n,i);const o={};let d;if((a==="swap"||a==="future")&&!r){if(e===void 0)throw new Fs(this.id+" fetchOpenOrders requires a symbol argument for "+e+" markets");o.symbol=n.id;const h=this.safeStringLower(i,"orderType"),p=this.safeValue(i,"stop",!1)||h==="stop"||h==="conditional";i=this.omit(i,["stop","orderType"]),n.future?d=p?"privateGetFuturesPrivateStopOrder":"privateGetFuturesPrivateOrder":n.linear?d=p?"privateGetPrivateLinearStopOrderSearch":"privateGetPrivateLinearOrderSearch":d=p?"privateGetV2PrivateStopOrder":"privateGetV2PrivateOrder"}else a==="spot"?(e!==void 0&&(o.symbol=n.id),d="privateGetSpotV3PrivateOpenOrders"):(d="privatePostOptionUsdcOpenapiPrivateV1QueryActiveOrders",o.category=a==="swap"?"perpetual":"option");const c=await this[d](this.extend(o,i));let u=this.safeValue(c,"result",[]);if(a==="spot")u=this.safeValue(u,"list",[]);else if(!Array.isArray(u)){const h=this.safeValue(u,"dataList");if(h===void 0)return this.parseOrder(u,n);u=h}return this.parseOrders(u,n,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){const r={order_id:e};return await this.fetchMyTrades(t,s,i,this.extend(r,n))}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Fs(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n={};let r;const a=this.safeString(i,"order_id");if(a!==void 0&&(n.order_id=a,i=this.omit(i,"order_id")),r=this.market(e),r.settle==="USDC")throw new wn(this.id+" fetchMyTrades() is not supported for market "+e);n.symbol=r.id,t!==void 0&&(n.start_time=t),s!==void 0&&(n.limit=s);let d;r.spot?d="privateGetSpotV3PrivateMyTrades":r.future?d="privateGetFuturesPrivateExecutionList":d=r.linear?"privateGetPrivateLinearTradeExecutionList":"privateGetV2PrivateExecutionList";const c=await this[d](this.extend(n,i));let u=this.safeValue(c,"result",{});return Array.isArray(u)||(u=this.safeValueN(u,["trade_list","data","list"],[])),this.parseTrades(u,r,t,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"addressDeposit"),i=this.safeString(e,"tagDeposit"),n=this.safeString(t,"code"),r=this.safeString(e,"chain");return this.checkAddress(s),{currency:n,address:s,tag:i,network:r,info:e}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();let s=this.currency(e);const i={coin:s.id},n=await this.privateGetAssetV3PrivateDepositAddressQuery(this.extend(i,t)),r=this.safeValue(n,"result",[]),a=this.safeValue(r,"chains",[]),o=this.safeString(r,"coin");s=this.currency(o);const d=this.parseDepositAddresses(a,[e],!1,{currency:s.id});return this.indexBy(d,"network")}async fetchDepositAddress(e,t={}){const[s,i]=this.handleNetworkCodeAndParams(t),n=this.networkCodeToId(s),r=this.currency(e),a={coin:r.id};n!==void 0&&(a.chainType=n);const o=await this.privateGetAssetV3PrivateDepositAddressQuery(this.extend(a,i)),d=this.safeValue(o,"result",{}),c=this.safeValue(d,"chains",[]),u=this.indexBy(c,"chain"),h=this.selectNetworkIdFromAvailableNetworks(e,s,u),l=this.safeValue(u,h,{});return this.parseDepositAddress(l,r)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={wallet_fund_type:"Deposit"};let r;e!==void 0&&(r=this.currency(e),n.coin=r.id),t!==void 0&&(n.startTime=t),s!==void 0&&(n.limit=s);const a=await this.privateGetAssetV3PrivateDepositRecordQuery(this.extend(n,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"rows",[]);return this.parseTransactions(d,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.coin=r.id),t!==void 0&&(n.startTime=this.yyyymmdd(t)),s!==void 0&&(n.limit=s);const a=await this.privateGetAssetV3PrivateWithdrawRecordQuery(this.extend(n,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"rows",[]);return this.parseTransactions(d,r,t,s)}parseTransactionStatus(e){const t={ToBeConfirmed:"pending",UnderReview:"pending",Success:"ok",Expire:"expired",0:"unknown",1:"pending",2:"processing",3:"ok",4:"fail",SecurityCheck:"pending",Pending:"pending",success:"ok",CancelByUser:"canceled",Reject:"rejected",Fail:"failed",BlockchainConfirmed:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"coin"),i=this.safeCurrencyCode(s,t),n=this.safeInteger2(e,"createTime","successAt"),r=this.safeInteger(e,"updateTime"),a=this.parseTransactionStatus(this.safeString(e,"status")),o=this.safeNumber2(e,"depositFee","withdrawFee",0),d="depositFee"in e?"deposit":"withdrawal";let c;o!==void 0&&(c={cost:o,currency:i});const u=this.safeString(e,"toAddress");return{info:e,id:this.safeString2(e,"id","withdrawId"),txid:this.safeString(e,"txID"),timestamp:n,datetime:this.iso8601(n),network:this.networkIdToCode(this.safeString(e,"chain")),address:void 0,addressTo:u,addressFrom:void 0,tag:this.safeString(e,"tag"),tagTo:void 0,tagFrom:void 0,type:d,amount:this.safeNumber(e,"amount"),currency:i,status:a,updated:r,fee:c}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.coin=r.id),t!==void 0&&(n.start_date=this.yyyymmdd(t)),s!==void 0&&(n.limit=s);const a=await this.privateGetV2PrivateWalletFundRecords(this.extend(n,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"data",[]);return this.parseLedger(d,r,t,s)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"coin"),i=this.safeCurrencyCode(s,t),n=this.safeString(e,"amount"),r=this.safeString(e,"wallet_balance"),a=bi.stringLt(n,"0")?"out":"in";let o;if(r!==void 0&&n!==void 0){const l=a==="out"?n:bi.stringNeg(n);o=bi.stringAdd(r,l)}const d=this.parse8601(this.safeString(e,"exec_time")),c=this.parseLedgerEntryType(this.safeString(e,"type")),u=this.safeString(e,"id"),h=this.safeString(e,"tx_id");return{id:u,currency:i,account:this.safeString(e,"wallet_id"),referenceAccount:void 0,referenceId:h,status:void 0,amount:this.parseNumber(n),before:this.parseNumber(o),after:this.parseNumber(r),fee:void 0,direction:a,timestamp:d,datetime:this.iso8601(d),type:c,info:e}}parseLedgerEntryType(e){const t={Deposit:"transaction",Withdraw:"transaction",RealisedPNL:"trade",Commission:"fee",Refund:"cashback",Prize:"prize",ExchangeOrderWithdraw:"transaction",ExchangeOrderDeposit:"transaction"};return this.safeString(t,e,e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets(),this.checkAddress(s);const r=this.currency(e),a={coin:r.id,amount:this.numberToString(t),address:s};i!==void 0&&(a.tag=i);const[o,d]=this.handleNetworkCodeAndParams(n),c=this.networkCodeToId(o);c!==void 0&&(a.chain=c);const u=await this.privatePostAssetV3PrivateWithdrawCreate(this.extend(a,d)),h=this.safeValue(u,"result",{});return this.parseTransaction(h,r)}async fetchPositions(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={};let i,n,r,a;if(Array.isArray(e)){if(e.length!==1)throw new Fs(this.id+" fetchPositions() takes an array with exactly one symbol");const p=this.safeString(e,0);i=this.market(p),n=i.type,r=i.linear,a=i.settle==="USDC",s.symbol=i.id}else{[n,t]=this.handleMarketTypeAndParams("fetchPositions",void 0,t);const l=this.safeValue(this.options,"fetchPositions",{}),p=this.safeString(this.options,"defaultSubType","linear");let m=this.safeString(l,"subType",p);m=this.safeString(t,"subType",m),r=m==="linear";let g=this.safeString(this.options,"defaultSettle");g=this.safeString2(t,"settle","defaultSettle",g),a=g==="USDC"}t=this.omit(t,["settle","defaultSettle","subType"]);let o;a?(o="privatePostOptionUsdcOpenapiPrivateV1QueryPosition",s.category=n==="option"?"OPTION":"PERPETUAL"):n==="future"?o="privateGetFuturesPrivatePositionList":r?o="privateGetPrivateLinearPositionList":o="privateGetV2PrivatePositionList";let d=await this[o](this.extend(s,t));typeof d=="string"&&this.isJsonEncodedObject(d)&&(d=JSON.parse(d));let c=this.safeValue(d,"result",{});"dataList"in c&&(c=this.safeValue(c,"dataList",[]));let u;Array.isArray(c)?u=c:u=[c];const h=[];for(let l=0;l<u.length;l++){let p=u[l];"data"in p&&"is_valid"in p&&(p=this.safeValue(p,"data")),h.push(this.parsePosition(p,i))}return this.filterByArray(h,"symbol",e,!1)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeString(e,"size");let n=this.safeString(e,"side");n=n==="Buy"?"long":"short";const r=this.safeString2(e,"position_value","positionValue"),a=this.omitZero(this.safeString2(e,"unrealised_pnl","unrealisedPnl"));let o=this.safeString(e,"positionIM");const d=this.safeString(e,"positionMM");let c=this.parse8601(this.safeString(e,"updated_at"));c===void 0&&(c=this.safeInteger(e,"createdAt"));const u=this.safeValue(e,"is_isolated",!1),h=u?"isolated":"cross";let l=this.safeString(e,"position_margin");const p=this.omitZero(this.safeString2(e,"entry_price","entryPrice")),m=this.omitZero(this.safeString2(e,"liq_price","liqPrice")),g=this.safeString(e,"leverage");t.settle==="USDT"?o=bi.stringDiv(bi.stringMul(i,p),g):t.inverse&&(o=bi.stringDiv(i,bi.stringMul(p,g)),u||(l=this.safeString(e,"wallet_balance")));const y=bi.stringMul(bi.stringDiv(a,o),"100");return{info:e,id:void 0,symbol:t.symbol,timestamp:c,datetime:this.iso8601(c),initialMargin:this.parseNumber(o),initialMarginPercentage:this.parseNumber(bi.stringDiv(o,r)),maintenanceMargin:d,maintenanceMarginPercentage:void 0,entryPrice:this.parseNumber(p),notional:this.parseNumber(r),leverage:this.parseNumber(g),unrealizedPnl:this.parseNumber(a),contracts:this.parseNumber(i),contractSize:this.safeNumber(t,"contractSize"),marginRatio:void 0,liquidationPrice:this.parseNumber(m),markPrice:this.safeNumber(e,"markPrice"),collateral:this.parseNumber(l),marginMode:h,side:n,percentage:this.parseNumber(y)}}async setMarginMode(e,t=void 0,s={}){if(t===void 0)throw new Fs(this.id+" setMarginMode() requires a symbol argument");await this.loadMarkets();const i=this.market(t);if(i.settle==="USDC")throw new wn(this.id+" setMarginMode() does not support market "+t);if(e=e.toUpperCase(),e!=="ISOLATED"&&e!=="CROSS")throw new wt(this.id+" setMarginMode() marginMode must be either isolated or cross");const n=this.safeNumber(s,"leverage");let r,a;if(n===void 0){if(r=this.safeNumber2(s,"sell_leverage","sellLeverage"),a=this.safeNumber2(s,"buy_leverage","buyLeverage"),r===void 0||a===void 0)throw new Fs(this.id+" setMarginMode() requires a leverage parameter or sell_leverage and buy_leverage parameters");s=this.omit(s,["buy_leverage","sell_leverage","sellLeverage","buyLeverage"])}else s=this.omit(s,"leverage"),r=n,a=n;const o=e==="ISOLATED",d={symbol:i.id,is_isolated:o,buy_leverage:n,sell_leverage:n};let c;return i.future?c="privatePostFuturesPrivatePositionSwitchIsolated":i.inverse?c="privatePostV2PrivatePositionSwitchIsolated":c="privatePostPrivateLinearPositionSwitchIsolated",await this[c](this.extend(d,s))}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new Fs(this.id+" setLeverage() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=i.settle==="USDC";let r;n?r="privatePostPerpetualUsdcOpenapiPrivateV1PositionLeverageSave":i.future?r="privatePostFuturesPrivatePositionLeverageSave":i.linear?r="privatePostPrivateLinearPositionSetLeverage":r="privatePostV2PrivatePositionLeverageSave";const a={symbol:i.id};e=n?e.toString():parseInt(e);const o=i.swap&&i.linear;if(!n&&(o||i.future)){const c=this.safeNumber(s,"buy_leverage"),u=this.safeNumber(s,"sell_leverage");if(c!==void 0&&u!==void 0){if(c<1||c>100||u<1||u>100)throw new wt(this.id+" setLeverage() leverage should be between 1 and 100")}else a.buy_leverage=e,a.sell_leverage=e}else a.leverage=e;if(e<1||e>100)throw new wt(this.id+" setLeverage() leverage should be between 1 and 100");return await this[r](this.extend(a,s))}async setPositionMode(e,t=void 0,s={}){if(t===void 0)throw new Fs(this.id+" setPositionMode() requires a symbol argument");await this.loadMarkets();const i=this.market(t);if(i.settle==="USDC")throw new wn(this.id+" setPositionMode() does not support market "+t);if(i.inverse&&!i.future)throw new wt(this.id+" setPositionMode() must be either a linear swap or an inverse future");let n,r;i.future?(n="privatePostFuturesPrivatePositionSwitchMode",e?r="3":r="0"):(n="privatePostPrivateLinearPositionSwitchMode",e?r="BothSide":r="MergedSingle");const a={symbol:i.id,mode:r};return await this[n](this.extend(a,s))}async fetchOpenInterestHistory(e,t="1h",s=void 0,i=void 0,n={}){if(t==="1m")throw new wt(this.id+" fetchOpenInterestHistory() cannot use the 1m timeframe");await this.loadMarkets();let r=this.market(e);const a=r.linear?"linear":"inverse",o=this.safeString(n,"category",a),d={symbol:r.id,interval:t,category:o};s!==void 0&&(d.since=s),i!==void 0&&(d.limit=i);const c=await this.publicGetDerivativesV3PublicOpenInterest(this.extend(d,n)),u=this.safeValue(c,"result",{}),h=this.safeString(u,"symbol");r=this.safeMarket(h,r);const l=this.safeValue(u,"list",[]);return this.parseOpenInterests(l,r,s,i)}async fetchOpenInterest(e,t={}){await this.loadMarkets();let s=this.market(e);if(!s.contract)throw new wt(this.id+" fetchOpenInterest() supports contract markets only");const i=this.safeString(t,"interval","1h");if(i==="1m")throw new wt(this.id+" fetchOpenInterest() cannot use the 1m timeframe");const n=s.linear?"linear":"inverse",r=this.safeString(t,"category",n),a={symbol:s.id,interval:i,category:r},o=await this.publicGetDerivativesV3PublicOpenInterest(this.extend(a,t)),d=this.safeValue(o,"result",{}),c=this.safeString(d,"symbol");s=this.safeMarket(c,s);const u=this.safeValue(d,"list",[]);return this.parseOpenInterest(u[0],s)}parseOpenInterest(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeNumber(e,"openInterest");return{symbol:this.safeSymbol(t.id),baseVolume:i,quoteVolume:void 0,openInterestAmount:void 0,openInterestValue:i,timestamp:s,datetime:this.iso8601(s),info:e}}async fetchBorrowRate(e,t={}){await this.loadMarkets();const s=this.currency(e),i={coin:s.id},n=await this.privateGetSpotV3PrivateCrossMarginLoanInfo(this.extend(i,t)),r=this.safeValue(n,"result",{});return this.parseBorrowRate(r,s)}parseBorrowRate(e,t=void 0){const s=this.milliseconds(),i=this.safeString(e,"coin");return{currency:this.safeCurrencyCode(i,t),rate:this.safeNumber(e,"interestRate"),period:864e5,timestamp:s,datetime:this.iso8601(s),info:e}}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={},a=await this.privateGetSpotV3PrivateCrossMarginAccount(this.extend(r,n)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"loanAccountList",[]),c=this.parseBorrowInterests(d,void 0);return this.filterByCurrencySinceLimit(c,e,s,i)}parseBorrowInterest(e,t){return{symbol:void 0,marginMode:"cross",currency:this.safeCurrencyCode(this.safeString(e,"tokenId")),interest:this.safeNumber(e,"interest"),interestRate:void 0,amountBorrowed:this.safeNumber(e,"loan"),timestamp:void 0,datetime:void 0,info:e}}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.safeString(n,"transferId",this.uuid()),a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c=this.currency(e),u=this.currencyToPrecision(e,t);let h;[h,n]=this.handleOptionAndParams(n,"transfer","method","privatePostAssetV1PrivateTransfer");let l;h==="privatePostAssetV3PrivateTransferInterTransfer"?l={transferId:r,fromAccountType:o,toAccountType:d,coin:c.id,amount:u}:l={transfer_id:r,from_account_type:o,to_account_type:d,coin:c.id,amount:u};const p=await this[h](this.extend(l,n)),m=this.safeInteger2(p,"time","time_now"),g=this.safeValue(p,"result",{}),y=this.safeStringN(p,["retCode","retMsg","ret_code","ret_msg"]),b=this.parseTransferStatus(y);return this.extend(this.parseTransfer(g,c),{timestamp:m,datetime:this.iso8601(m),amount:this.parseNumber(u),fromAccount:s,toAccount:i,status:b})}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.safeCurrencyCode(e),r.coin=n.id),t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=s);const a=await this.privateGetAssetV3PrivateTransferInterTransferListQuery(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"list",[]);return this.parseTransfers(d,n,t,s)}async borrowMargin(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.currency(e),[r,a]=this.handleMarginModeAndParams("borrowMargin",i);if(r==="isolated")throw new wn(this.id+" borrowMargin () cannot use isolated margin");const o={coin:n.id,qty:this.currencyToPrecision(e,t)},d=await this.privatePostSpotV3PrivateCrossMarginLoan(this.extend(o,a)),c=this.safeValue(d,"result",{}),u=this.parseMarginLoan(c,n);return this.extend(u,{symbol:s,amount:t})}async repayMargin(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.currency(e),[r,a]=this.handleMarginModeAndParams("repayMargin",i);if(r==="isolated")throw new wn(this.id+" repayMargin () cannot use isolated margin");const o={coin:n.id,qty:this.currencyToPrecision(e,t)},d=await this.privatePostSpotV3PrivateCrossMarginRepay(this.extend(o,a)),c=this.safeValue(d,"result",{}),u=this.parseMarginLoan(c,n);return this.extend(u,{symbol:s,amount:t})}parseMarginLoan(e,t=void 0){return{id:this.safeString2(e,"transactId","repayId"),currency:this.safeString(t,"code"),amount:void 0,symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}parseTransferStatus(e){const t={0:"ok",OK:"ok",SUCCESS:"ok"};return this.safeString(t,e,e)}parseTransfer(e,t=void 0){const s=this.safeString(e,"coin"),i=this.safeTimestamp(e,"timestamp"),n=this.safeString2(e,"fromAccountType","from_account_type"),r=this.safeString2(e,"toAccountType","to_account_type"),a=this.safeValue(this.options,"accountsById",{}),o=this.safeString(a,n,n),d=this.safeString(a,r,r);return{info:e,id:this.safeString2(e,"transferId","transfer_id"),timestamp:i,datetime:this.iso8601(i),currency:this.safeCurrencyCode(s,t),amount:this.safeNumber(e,"amount"),fromAccount:o,toAccount:d,status:this.parseTransferStatus(this.safeString(e,"status"))}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.implodeHostname(this.urls.api[t])+"/"+e;if(t==="public")Object.keys(i).length&&(a+="?"+this.rawencode(i));else if(t==="private"){this.checkRequiredCredentials();const o=a.indexOf("openapi")>=0,d=a.indexOf("unified/v3")>=0,c=this.nonce().toString();if(o){Object.keys(i).length?r=this.json(i):r="{}";const u=c+this.apiKey+r,h=this.hmac(this.encode(u),this.encode(this.secret),"sha256","hex");n={"Content-Type":"application/json","X-BAPI-API-KEY":this.apiKey,"X-BAPI-TIMESTAMP":c,"X-BAPI-SIGN":h}}else if(d){n={"Content-Type":"application/json","X-BAPI-API-KEY":this.apiKey,"X-BAPI-SIGN-TYPE":"2","X-BAPI-TIMESTAMP":c,"X-BAPI-RECV-WINDOW":this.options.recvWindow.toString()};const u=i,h=this.rawencode(u),l=c.toString()+this.apiKey+this.options.recvWindow.toString();let p;if(s==="POST"){r=this.json(u),p=l+r;const g=this.safeString(this.options,"brokerId");g!==void 0&&(n.Referer=g)}else p=l+h,a+="?"+this.urlencode(u);const m=this.hmac(this.encode(p),this.encode(this.secret));n["X-BAPI-SIGN"]=m}else{const u=this.extend(i,{api_key:this.apiKey,recv_window:this.options.recvWindow,timestamp:c}),h=this.keysort(u),l=this.rawencode(h),p=this.hmac(this.encode(l),this.encode(this.secret));if(s==="POST"){const m=a.indexOf("spot")>=0,g=this.extend(u,{sign:p});if(m)r=this.urlencode(g),n={"Content-Type":"application/x-www-form-urlencoded"};else{r=this.json(g),n={"Content-Type":"application/json"};const y=this.safeString(this.options,"brokerId");y!==void 0&&(n.Referer=y)}}else a+="?"+this.urlencode(h)+"&sign="+p}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(!a)return;const c=this.safeString2(a,"ret_code","retCode");if(c!=="0"){if(c==="30084")return;const u=this.id+" "+r;throw this.throwBroadlyMatchedException(this.exceptions.broad,r,u),this.throwExactlyMatchedException(this.exceptions.exact,c,u),new Ps(u)}}async fetchMarketLeverageTiers(e,t={}){await this.loadMarkets();const s={};let i;if(i=this.market(e),i.spot||i.option)throw new wt(this.id+" fetchMarketLeverageTiers() symbol does not support market "+e);s.symbol=i.id;const n=i.settle==="USDC";let r;n?r="publicGetPerpetualUsdcOpenapiPublicV1RiskLimitList":i.linear?r="publicGetPublicLinearRiskLimit":r="publicGetV2PublicRiskLimitList";const a=await this[r](this.extend(s,t)),o=this.safeValue(a,"result");return this.parseMarketLeverageTiers(o,i)}parseMarketLeverageTiers(e,t){let s=0;const i=[];for(let n=0;n<e.length;n++){const r=e[n],a=this.safeNumber(r,"limit");i.push({tier:this.sum(n,1),currency:t.base,minNotional:s,maxNotional:a,maintenanceMarginRate:this.safeNumber2(r,"maintain_margin","maintainMargin"),maxLeverage:this.safeNumber2(r,"max_leverage","maxLeverage"),info:r}),s=a}return i}};const l8=me,{ExchangeError:p8,ArgumentsRequired:zi,BadRequest:lk,AuthenticationError:pk,DDoSProtection:m8,BadResponse:g8}=oe,{TICK_SIZE:y8}=pe,wi=ke;var b8=class extends l8{describe(){return this.deepExtend(super.describe(),{id:"bytetrade",name:"ByteTrade",countries:["HK"],rateLimit:100,requiresWeb3:!0,certified:!1,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:void 0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","1d":"1d","5d":"5d","1w":"1w","1M":"1M"},urls:{test:{market:"https://api-v2-test.byte-trade.com",public:"https://api-v2-test.byte-trade.com"},logo:"https://user-images.githubusercontent.com/1294454/67288762-2f04a600-f4e6-11e9-9fd6-c60641919491.jpg",api:{market:"https://api-v2.bttcdn.com",public:"https://api-v2.bttcdn.com"},www:"https://www.byte-trade.com",doc:"https://docs.byte-trade.com/#description"},api:{market:{get:{klines:1,depth:1,trades:1,tickers:1}},public:{get:{symbols:1,currencies:1,balance:1,"orders/open":1,"orders/closed":1,"orders/all":1,orders:1,"orders/trades":1,depositaddress:1,withdrawals:1,deposits:1,transfers:1},post:{"transaction/createorder":1,"transaction/cancelorder":1,"transaction/withdraw":1,"transaction/transfer":1}}},fees:{trading:{tierBased:!1,percentage:!0,taker:8e-4,maker:8e-4}},commonCurrencies:{1:"ByteTrade",44:"ByteHub",48:"Blocktonic",133:"TerraCredit"},precisionMode:y8,exceptions:{"vertify error":pk,"verify error":pk,"transaction already in network":lk,"invalid argument":lk},options:{orderExpiration:31536e6}})}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"code");let a;r in this.commonCurrencies?a=this.commonCurrencies[r]:a=this.safeString(n,"name");const o=this.safeString(n,"fullname"),d=this.safeValue(n,"active"),c=this.safeValue(n,"limits"),u=this.safeValue(c,"deposit");let h=this.safeString(u,"max");wi.stringEquals(h,"-1")&&(h=void 0);const l=this.safeValue(c,"withdraw");let p=this.safeString(l,"max");wi.stringEquals(p,"-1")&&(p=void 0),s[a]={id:r,code:a,name:o,active:d,deposit:void 0,withdraw:void 0,precision:this.parseNumber(this.parsePrecision(this.safeString(n,"basePrecision"))),fee:void 0,limits:{amount:{min:void 0,max:void 0},deposit:{min:this.safeNumber(u,"min"),max:this.parseNumber(h)},withdraw:{min:this.safeNumber(l,"min"),max:this.parseNumber(p)}},info:n}}return s}async fetchMarkets(e={}){const t=await this.publicGetSymbols(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"symbol");let a=this.safeString(n,"baseName",""),o=this.safeString(n,"quoteName","");const d=this.safeString(n,"base"),c=this.safeString(n,"quote"),u=a.split("@"+d)[0];let h=o.split("@"+c)[0];c==="126"&&(h="ZAR");const l=u+"/"+h;d in this.commonCurrencies&&(a=this.commonCurrencies[d]),c in this.commonCurrencies&&(o=this.commonCurrencies[c]);const p=this.safeValue(n,"limits",{}),m=this.safeValue(p,"amount",{}),g=this.safeValue(p,"price",{}),y=this.safeValue(n,"precision",{});let b=this.safeString(m,"max");wi.stringEquals(b,"-1")&&(b=void 0);let w=this.safeString(g,"max");wi.stringEquals(w,"-1")&&(w=void 0);const S={id:r,symbol:a+"/"+o,normalSymbol:l,base:a,quote:o,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:this.safeValue(n,"active"),contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(n,"taker"),maker:this.safeNumber(n,"maker"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(y,"amount"))),price:this.parseNumber(this.parsePrecision(this.safeString(y,"price")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(m,"min"),max:this.parseNumber(b)},price:{min:this.safeNumber(g,"min"),max:this.parseNumber(w)},cost:{min:void 0,max:void 0}},info:n};s.push(S)}return s}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"code"),r=this.safeCurrencyCode(n,void 0),a=this.account();a.free=this.safeString(i,"free"),a.used=this.safeString(i,"used"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){if(!("userid"in e)&&this.apiKey===void 0)throw new zi(this.id+" fetchBalance() requires this.apiKey or userid argument");await this.loadMarkets();const t={userid:this.apiKey},s=await this.publicGetBalance(this.extend(t,e));return this.parseBalance(s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit=t);const r=await this.marketGetDepth(this.extend(n,s)),a=this.safeInteger(r,"timestamp");return this.parseOrderBook(r,i.symbol,a)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const n=t.symbol;return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:this.safeString(e,"weightedAvgPrice"),open:this.safeString(e,"open"),close:this.safeString(e,"close"),last:this.safeString(e,"last"),previousClose:void 0,change:this.safeString(e,"change"),percentage:this.safeString(e,"percentage"),average:void 0,baseVolume:this.safeString(e,"baseVolume"),quoteVolume:this.safeString(e,"quoteVolume"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.marketGetTickers(this.extend(i,t));if(Array.isArray(n)){const r=this.safeValue(n,0);if(r===void 0)throw new g8(this.id+" fetchTicker() returned an empty response");return this.parseTicker(r,s)}return this.parseTicker(n,s)}async fetchBidsAsks(e=void 0,t={}){await this.loadMarkets();const s=await this.marketGetDepth(t);return this.parseTickers(s,e)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.marketGetTickers(t);return this.parseTickers(s,e)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,timeframe:this.timeframes[t]};s!==void 0&&(a.since=s),i!==void 0&&(a.limit=i);const o=await this.marketGetKlines(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}parseTrade(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"price"),n=this.safeString(e,"amount"),r=this.safeString(e,"cost"),a=this.safeString(e,"id"),o=this.safeString(e,"type"),d=this.safeString(e,"takerOrMaker"),c=this.safeString(e,"side"),u=this.iso8601(s),h=this.safeString(e,"order"),l=this.safeString(e,"symbol");t=this.safeMarket(l,t);const p=this.safeValue(e,"fee"),m=this.safeString(p,"cost"),g=this.safeString(p,"rate"),y=this.safeString(p,"code"),w={currency:this.safeCurrencyCode(y),cost:m,rate:g};return this.safeTrade({info:e,timestamp:s,datetime:u,symbol:t.symbol,id:a,order:h,type:o,takerOrMaker:d,side:c,price:i,amount:n,cost:r,fee:w},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};t!==void 0&&(r.since=t),s!==void 0&&(r.limit=s);const a=await this.marketGetTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetSymbols(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"name"),a=this.safeSymbol(r);s[a]={info:n,symbol:a,maker:this.safeNumber(n,"maker"),taker:this.safeNumber(n,"taker"),percentage:!0}}return s}parseOrder(e,t=void 0){const s=this.safeString(e,"status"),i=this.safeString(e,"base"),n=this.safeString(e,"quote"),r=this.safeCurrencyCode(i),a=this.safeCurrencyCode(n),o=r+"/"+a,d=this.safeInteger(e,"timestamp"),c=this.safeString(e,"datetime"),u=this.safeInteger(e,"lastTradeTimestamp"),h=this.safeString(e,"price"),l=this.safeString(e,"amount"),p=this.safeString(e,"filled"),m=this.safeString(e,"remaining"),g=this.safeString(e,"cost"),y=this.safeString(e,"average"),b=this.safeString(e,"id"),w=this.safeString(e,"type"),S=this.safeString(e,"side"),k=this.safeValue(e,"fee"),T=this.safeNumber(k,"cost"),I=this.safeNumber(k,"rate"),_=this.safeString(k,"code"),M={currency:this.safeCurrencyCode(_),cost:T,rate:I};return this.safeOrder({info:e,id:b,clientOrderId:void 0,timestamp:d,datetime:c,lastTradeTimestamp:u,symbol:o,type:w,timeInForce:void 0,postOnly:void 0,side:S,price:h,stopPrice:void 0,amount:l,cost:g,average:y,filled:p,remaining:m,status:s,fee:M,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){if(this.checkRequiredDependencies(),this.apiKey===void 0)throw new zi("createOrder() requires this.apiKey or userid in params");await this.loadMarkets();const a=this.market(e);let o,d;s==="sell"?o=1:o=2,t==="limit"?d=1:(d=2,n=0);const c=a.normalSymbol,u=a.baseId,h=this.currency(a.base),l=this.amountToPrecision(e,i),p=new wi(l);p.reduce(),p.decimals-=this.precisionFromString(this.numberToString(h.precision));const m=p.toString(),g=this.numberToString(m),y=a.quoteId,b=this.currency(a.quote),w=this.priceToPrecision(e,n),S=new wi(w);S.reduce(),S.decimals-=this.precisionFromString(this.numberToString(b.precision));const k=S.toString(),T=this.numberToString(k),I=this.milliseconds(),_=this.safeInteger(this.options,"orderExpiration",31536e6),N=this.milliseconds()+_;let M=this.iso8601(I);M=M.split(".")[0];let x=this.iso8601(N);x=x.split(".")[0];const v="Sagittarius",O=this.safeString(r,"dappId",v),A=this.safeString(this.options,"fee","300000000000000"),V=this.safeString(r,"totalFeeRate","8"),q=this.safeString(r,"chainFeeRate","1"),R=this.safeString(r,"fee",A),H="18446744073709551616",F=[this.numberToBE(1,32),this.numberToLE(Math.floor(I/1e3),4),this.numberToLE(1,1),this.numberToLE(Math.floor(N/1e3),4),this.numberToLE(1,1),this.numberToLE(32,1),this.numberToLE(0,8),this.numberToLE(R,8),this.numberToLE(this.apiKey.length,1),this.stringToBinary(this.encode(this.apiKey)),this.numberToLE(o,1),this.numberToLE(d,1),this.numberToLE(c.length,1),this.stringToBinary(this.encode(c)),this.numberToLE(wi.stringDiv(g,H,0),8),this.numberToLE(wi.stringMod(g,H),8),this.numberToLE(wi.stringDiv(T,H,0),8),this.numberToLE(wi.stringMod(T,H),8),this.numberToLE(0,2),this.numberToLE(Math.floor(I/1e3),4),this.numberToLE(Math.floor(N/1e3),4),this.numberToLE(1,1),this.numberToLE(parseInt(q),2),this.numberToLE(1,1),this.numberToLE(parseInt(V),2),this.numberToLE(parseInt(y),4),this.numberToLE(parseInt(u),4),this.numberToLE(0,1),this.numberToLE(1,1),this.numberToLE(O.length,1),this.stringToBinary(this.encode(O)),this.numberToLE(0,1)],P=[this.numberToLE(Math.floor(I/1e3),4),this.numberToLE(1,1),this.numberToLE(Math.floor(N/1e3),4),this.numberToLE(1,1),this.numberToLE(32,1),this.numberToLE(0,8),this.numberToLE(R,8),this.numberToLE(this.apiKey.length,1),this.stringToBinary(this.encode(this.apiKey)),this.numberToLE(o,1),this.numberToLE(d,1),this.numberToLE(c.length,1),this.stringToBinary(this.encode(c)),this.numberToLE(wi.stringDiv(g,H,0),8),this.numberToLE(wi.stringMod(g,H),8),this.numberToLE(wi.stringDiv(T,H,0),8),this.numberToLE(wi.stringMod(T,H),8),this.numberToLE(0,2),this.numberToLE(Math.floor(I/1e3),4),this.numberToLE(Math.floor(N/1e3),4),this.numberToLE(1,1),this.numberToLE(parseInt(q),2),this.numberToLE(1,1),this.numberToLE(parseInt(V),2),this.numberToLE(parseInt(y),4),this.numberToLE(parseInt(u),4),this.numberToLE(0,1),this.numberToLE(1,1),this.numberToLE(O.length,1),this.stringToBinary(this.encode(O)),this.numberToLE(0,1)],E=this.binaryConcatArray(P),X=this.hash(E,"sha256","hex").slice(0,40),Q=[this.numberToLE(X.length,1),this.stringToBinary(this.encode(X)),this.numberToBE(0,4)],Se=this.binaryConcatArray(Q),xe=this.hash(Se,"sha256","hex").slice(0,40),Ae=this.binaryConcatArray(F),Re=this.hash(Ae,"sha256","hex"),He=this.ecdsa(Re,this.secret,"secp256k1",void 0,!0),D=this.binaryToBase16(this.numberToLE(this.sum(He.v,31),1))+He.r+He.s,$={now:M,expiration:x,fee:R,creator:this.apiKey,side:o,order_type:d,market_name:c,amount:m,price:k,use_btt_as_fee:!1,money_id:parseInt(y),stock_id:parseInt(u),custom_no_btt_fee_rate:parseInt(V),custom_btt_fee_rate:parseInt(q)},G={timestamp:M,expiration:x,operations:[[32,$]],validate_type:0,dapp:O,signatures:[D]},U={trObj:this.json(G)},W=await this.publicPostTransactionCreateorder(U),J=this.milliseconds(),ne=this.safeString(W,"code")==="0"?"open":"failed";return{info:W,id:xe,timestamp:J,datetime:this.iso8601(J),lastTradeTimestamp:void 0,status:ne,symbol:void 0,type:void 0,side:void 0,price:void 0,amount:void 0,filled:void 0,remaining:void 0,cost:void 0,trades:void 0,fee:void 0,clientOrderId:void 0,average:void 0}}async fetchOrder(e,t=void 0,s={}){if(!("userid"in s)&&this.apiKey===void 0)throw new zi("fetchOrder() requires this.apiKey or userid argument");await this.loadMarkets();const i={userid:this.apiKey};let n;t!==void 0&&(n=this.markets[t],i.symbol=n.id),i.id=e;const r=await this.publicGetOrders(this.extend(i,s));return this.parseOrder(r,n)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(!("userid"in i)&&this.apiKey===void 0)throw new zi("fetchOpenOrders() requires this.apiKey or userid argument");await this.loadMarkets();const n={userid:this.apiKey};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),s!==void 0&&(n.limit=s),t!==void 0&&(n.since=t);const a=await this.publicGetOrdersOpen(this.extend(n,i));return this.parseOrders(a,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(!("userid"in i)&&this.apiKey===void 0)throw new zi("fetchClosedOrders() requires this.apiKey or userid argument");await this.loadMarkets();let n;const r={userid:this.apiKey};e!==void 0&&(n=this.market(e),r.symbol=n.id),s!==void 0&&(r.limit=s),t!==void 0&&(r.since=t);const a=await this.publicGetOrdersClosed(this.extend(r,i));return this.parseOrders(a,n,t,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(!("userid"in i)&&this.apiKey===void 0)throw new zi("fetchOrders() requires this.apiKey or userid argument");await this.loadMarkets();let n;const r={userid:this.apiKey};e!==void 0&&(n=this.market(e),r.symbol=n.id),s!==void 0&&(r.limit=s),t!==void 0&&(r.since=t);const a=await this.publicGetOrdersAll(this.extend(r,i));return this.parseOrders(a,n,t,s)}async cancelOrder(e,t=void 0,s={}){if(this.apiKey===void 0)throw new zi("cancelOrder() requires hasAlreadyAuthenticatedSuccessfully");if(t===void 0)throw new zi(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=i.baseId,r=i.quoteId,a=i.normalSymbol,o="300000000000000",d=this.milliseconds(),c=0;let u=this.iso8601(d);u=u.split(".")[0];let h=this.iso8601(c);h=h.split(".")[0];const l="Sagittarius",p=this.safeString(s,"dappId",l),m=[this.numberToBE(1,32),this.numberToLE(Math.floor(d/1e3),4),this.numberToLE(1,1),this.numberToLE(c,4),this.numberToLE(1,1),this.numberToLE(33,1),this.numberToLE(0,8),this.numberToLE(o,8),this.numberToLE(this.apiKey.length,1),this.stringToBinary(this.encode(this.apiKey)),this.numberToLE(a.length,1),this.stringToBinary(this.encode(a)),this.base16ToBinary(e),this.numberToLE(parseInt(r),4),this.numberToLE(parseInt(n),4),this.numberToLE(0,1),this.numberToLE(1,1),this.numberToLE(p.length,1),this.stringToBinary(this.encode(p)),this.numberToLE(0,1)],g=this.binaryConcatArray(m),y=this.hash(g,"sha256","hex"),b=this.ecdsa(y,this.secret,"secp256k1",void 0,!0),S=this.binaryToBase16(this.numberToLE(this.sum(b.v,31),1))+b.r+b.s,k={fee:o,creator:this.apiKey,order_id:e,market_name:a,money_id:parseInt(r),stock_id:parseInt(n)},T={timestamp:u,expiration:h,operations:[[33,k]],validate_type:0,dapp:p,signatures:[S]},I={trObj:this.json(T)},_=await this.publicPostTransactionCancelorder(I),N=this.milliseconds(),x=this.safeString(_,"code")==="0"?"canceled":"failed";return{info:_,id:void 0,timestamp:N,datetime:this.iso8601(N),lastTradeTimestamp:void 0,status:x,symbol:void 0,type:void 0,side:void 0,price:void 0,amount:void 0,filled:void 0,remaining:void 0,cost:void 0,trades:void 0,fee:void 0,clientOrderId:void 0,average:void 0}}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(!("userid"in i)&&this.apiKey===void 0)throw new zi("fetchMyTrades() requires this.apiKey or userid argument");await this.loadMarkets();const n=this.market(e),r={userid:this.apiKey};e!==void 0&&(r.symbol=n.id),s!==void 0&&(r.limit=s),t!==void 0&&(r.since=t);const a=await this.publicGetOrdersTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),!("userid"in i)&&this.apiKey===void 0)throw new zi("fetchDeposits() requires this.apiKey or userid argument");let n;const r={userid:this.apiKey};e!==void 0&&(n=this.currency(e),r.currency=n.id),t!==void 0&&(r.since=t),s!==void 0&&(r.limit=s);const a=await this.publicGetDeposits(this.extend(r,i));return this.parseTransactions(a,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),!("userid"in i)&&this.apiKey===void 0)throw new zi("fetchWithdrawals() requires this.apiKey or userid argument");let n;const r={userid:this.apiKey};e!==void 0&&(n=this.currency(e),r.currency=n.id),t!==void 0&&(r.since=t),s!==void 0&&(r.limit=s);const a=await this.publicGetWithdrawals(this.extend(r,i));return this.parseTransactions(a,n,t,s)}parseTransactionStatus(e){const t={DEPOSIT_FAILED:"failed",FEE_SEND_FAILED:"failed",FEE_FAILED:"failed",PAY_SEND_FAILED:"failed",PAY_FAILED:"failed",BTT_FAILED:"failed",WITHDDRAW_FAILED:"failed",USER_FAILED:"failed",FEE_EXECUED:"pending",PAY_EXECUED:"pending",WITHDDRAW_EXECUTED:"pending",USER_EXECUED:"pending",BTT_SUCCED:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"address");let n=this.safeString(e,"tag");n!==void 0&&n.length<1&&(n=void 0);const r=this.safeValue(e,"txid"),a=this.safeString(e,"code"),o=this.safeCurrencyCode(a,t),d=this.safeInteger(e,"timestamp"),c=this.safeString(e,"datetime"),u=this.safeString(e,"type"),h=this.parseTransactionStatus(this.safeString(e,"status")),l=this.safeNumber(e,"amount"),p=this.safeValue(e,"fee"),m=this.safeNumber(p,"cost"),g=this.safeString(p,"code"),y=this.safeCurrencyCode(g,t);return{info:e,id:s,txid:r,timestamp:d,datetime:c,address:i,tag:n,type:u,amount:l,currency:o,status:h,updated:void 0,fee:{cost:m,currency:y}}}async fetchDepositAddress(e,t={}){if(await this.loadMarkets(),!("userid"in t)&&this.apiKey===void 0)throw new zi("fetchDepositAddress() requires this.apiKey or userid argument");const s=this.currency(e),i={userid:this.apiKey,code:s.id},n=await this.publicGetDepositaddress(i),r=this.safeValue(n,0),a=this.safeString(r,"address"),o=this.safeString(r,"tag"),d=this.safeStringUpper(r,"chainType");return this.checkAddress(a),{currency:e,address:a,tag:o,network:d,info:n}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t];return a+="/"+e,Object.keys(i).length&&(a+="?"+this.urlencode(i)),{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(e===503)throw new m8(this.id+" "+e.toString()+" "+t+" "+r);if(a!==void 0&&"code"in a&&this.safeString(a,"code")==="1"){const u=this.safeString(a,"msg"),h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions,u,h),new p8(h)}}};const w8=me,{ExchangeError:mk,ArgumentsRequired:e0,AuthenticationError:S8,NullResponse:gk,InvalidOrder:t0,InsufficientFunds:k8,InvalidNonce:v8,OrderNotFound:T8,RateLimitExceeded:O8,DDoSProtection:I8,BadSymbol:yk}=oe,{TICK_SIZE:x8}=pe,s0=ke;var B_=class extends w8{describe(){return this.deepExtend(super.describe(),{id:"cex",name:"CEX.IO",countries:["GB","EU","CY","RU"],rateLimit:1500,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,cancelOrders:!1,createDepositAddress:!1,createOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,editOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDeposits:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!1,fetchWithdrawalWhitelist:!1,reduceMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,transfer:!1,withdraw:!1},timeframes:{"1m":"1m","1h":"1h","1d":"1d"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766442-8ddc33b0-5ed8-11e7-8b98-f786aef0f3c9.jpg",api:{rest:"https://cex.io/api"},www:"https://cex.io",doc:"https://cex.io/cex-api",fees:["https://cex.io/fee-schedule","https://cex.io/limits-commissions"],referral:"https://cex.io/r/0/up105393824/0/"},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},api:{public:{get:["currency_profile","currency_limits/","last_price/{pair}/","last_prices/{currencies}/","ohlcv/hd/{yyyymmdd}/{pair}","order_book/{pair}/","ticker/{pair}/","tickers/{currencies}/","trade_history/{pair}/"],post:["convert/{pair}","price_stats/{pair}"]},private:{post:["active_orders_status/","archived_orders/{pair}/","balance/","cancel_order/","cancel_orders/{pair}/","cancel_replace_order/{pair}/","close_position/{pair}/","get_address/","get_crypto_address","get_myfee/","get_order/","get_order_tx/","open_orders/{pair}/","open_orders/","open_position/{pair}/","open_positions/{pair}/","place_order/{pair}/","raw_tx_history"]}},fees:{trading:{maker:this.parseNumber("0.0016"),taker:this.parseNumber("0.0025")},funding:{withdraw:{},deposit:{BTC:0,ETH:0,BCH:0,DASH:0,BTG:0,ZEC:0,XRP:0,XLM:0}}},precisionMode:x8,exceptions:{exact:{},broad:{"Insufficient funds":k8,"Nonce must be incremented":v8,"Invalid Order":t0,"Order not found":T8,"limit exceeded":O8,"Invalid API key":S8,"There was an error while placing your order":t0,"Sorry, too many clients already":I8,"Invalid Symbols Pair":yk,"Wrong currency pair":yk}},options:{fetchOHLCVWarning:!0,createMarketBuyOrderRequiresPrice:!0,order:{status:{c:"canceled",d:"closed",cd:"canceled",a:"open"}},defaultNetwork:"ERC20",defaultNetworks:{USDT:"TRC20"},networks:{ERC20:"Ethereum",BTC:"BTC",BEP20:"Binance Smart Chain",BSC:"Binance Smart Chain",TRC20:"Tron"},networksById:{Ethereum:"ERC20",BTC:"BTC","Binance Smart Chain":"BEP20",Tron:"TRC20"}}})}async fetchCurrenciesFromCache(e={}){const t=this.safeValue(this.options,"fetchCurrencies",{}),s=this.safeInteger(t,"timestamp"),i=this.safeInteger(t,"expires",1e3),n=this.milliseconds();if(s===void 0||n-s>i){const r=await this.publicGetCurrencyProfile(e);this.options.fetchCurrencies=this.extend(t,{response:r,timestamp:n})}return this.safeValue(this.options.fetchCurrencies,"response")}async fetchCurrencies(e={}){const t=await this.fetchCurrenciesFromCache(e);this.options.currencies={timestamp:this.milliseconds(),response:t};const s=this.safeValue(t,"data",[]),i=this.safeValue(s,"symbols",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"code"),d=this.safeCurrencyCode(o),c=!0;n[d]={id:o,code:d,name:o,active:c,deposit:void 0,withdraw:void 0,precision:this.parseNumber(this.safeString(a,"precision")),fee:void 0,limits:{amount:{min:this.safeNumber(a,"minimumCurrencyAmount"),max:void 0},withdraw:{min:this.safeNumber(a,"minimalWithdrawalAmount"),max:void 0}},info:a}}return n}async fetchMarkets(e={}){const t=await this.fetchCurrenciesFromCache(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"symbols",[]),n=this.indexBy(i,"code"),r=this.safeValue(s,"pairs",[]),a=await this.publicGetCurrencyLimits(e),o=[],d=this.safeValue(a.data,"pairs");for(let c=0;c<d.length;c++){const u=d[c],h=this.safeString(u,"symbol1"),l=this.safeString(u,"symbol2"),p=this.safeCurrencyCode(h),m=this.safeCurrencyCode(l),g=this.safeValue(n,h,{}),y=this.safeValue(n,l,{});let b=this.safeString(y,"precision","8");for(let T=0;T<r.length;T++){const I=r[T];I.symbol1===h&&I.symbol2===l&&(b=this.safeString(I,"pricePrecision",b))}const w=this.safeString(g,"precision","8"),S=this.safeString(g,"scale","0"),k=s0.stringSub(w,S);o.push({id:h+"/"+l,symbol:p+"/"+m,base:p,quote:m,settle:void 0,baseId:h,quoteId:l,settleId:void 0,type:"spot",spot:!0,margin:void 0,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(k)),price:this.parseNumber(this.parsePrecision(b))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(u,"minLotSize"),max:this.safeNumber(u,"maxLotSize")},price:{min:this.safeNumber(u,"minPrice"),max:this.safeNumber(u,"maxPrice")},cost:{min:this.safeNumber(u,"minLotSizeS2"),max:void 0}},info:u})}return o}parseBalance(e){const t={info:e},s=["username","timestamp"],i=this.omit(e,s),n=Object.keys(i);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeValue(i,a,{}),d=this.account();d.free=this.safeString(o,"available"),d.used=this.safeString(o,"orders","0");const c=this.safeCurrencyCode(a);t[c]=d}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id};t!==void 0&&(n.depth=t);const r=await this.publicGetOrderBookPair(this.extend(n,s)),a=this.safeTimestamp(r,"timestamp");return this.parseOrderBook(r,i.symbol,a)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);if(s===void 0)s=this.milliseconds()-864e5;else if(this.options.fetchOHLCVWarning)throw new mk(this.id+" fetchOHLCV warning: CEX can return historical candles for a certain date only, this might produce an empty or null reply. Set exchange.options['fetchOHLCVWarning'] = false or add ({ 'options': { 'fetchOHLCVWarning': false }}) to constructor params to suppress this warning message.");const a={pair:r.id,yyyymmdd:this.yyyymmdd(s,"")};try{const o=await this.publicGetOhlcvHdYyyymmddPair(this.extend(a,n)),d="data"+this.timeframes[t],c=this.safeString(o,d),u=JSON.parse(c);return this.parseOHLCVs(u,r,t,s,i)}catch(o){if(o instanceof gk)return[]}}parseTicker(e,t=void 0){const s=this.safeTimestamp(e,"timestamp"),i=this.safeString(e,"volume"),n=this.safeString(e,"high"),r=this.safeString(e,"low"),a=this.safeString(e,"bid"),o=this.safeString(e,"ask"),d=this.safeString(e,"last"),c=this.safeSymbol(void 0,t);return this.safeTicker({symbol:c,timestamp:s,datetime:this.iso8601(s),high:n,low:r,bid:a,bidVolume:void 0,ask:o,askVolume:void 0,vwap:void 0,open:void 0,close:d,last:d,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:i,quoteVolume:void 0,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const i={currencies:Object.keys(this.currencies).join("/")},n=await this.publicGetTickersCurrencies(this.extend(i,t)),r=this.safeValue(n,"data",[]),a={};for(let o=0;o<r.length;o++){const d=r[o],c=this.safeString(d,"pair"),u=this.safeMarket(c,void 0,":"),h=u.symbol;a[h]=this.parseTicker(d,u)}return this.filterByArray(a,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetTickerPair(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"date"),i=this.safeString(e,"tid"),n=void 0,r=this.safeString(e,"type"),a=this.safeString(e,"price"),o=this.safeString(e,"amount");return t=this.safeMarket(void 0,t),this.safeTrade({info:e,id:i,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:n,side:r,order:void 0,takerOrMaker:void 0,price:a,amount:o,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id},a=await this.publicGetTradeHistoryPair(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostGetMyfee(e),s=this.safeValue(t,"data",{}),i={};for(let n=0;n<this.symbols.length;n++){const r=this.symbols[n],a=this.market(r),o=this.safeValue(s,a.id,{}),d=this.safeString(o,"buyMaker"),c=this.safeString(o,"buy"),u=this.parseNumber(s0.stringDiv(d,"100")),h=this.parseNumber(s0.stringDiv(c,"100"));i[r]={info:o,symbol:r,maker:u,taker:h,percentage:!0}}return i}async createOrder(e,t,s,i,n=void 0,r={}){if(t==="market"&&s==="buy"&&this.options.createMarketBuyOrderRequiresPrice){if(n===void 0)throw new t0(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)");i=i*n}await this.loadMarkets();const a=this.market(e),o={pair:a.id,type:s,amount:i};t==="limit"?o.price=n:o.order_type=t;const d=await this.privatePostPlaceOrderPair(this.extend(o,r)),c=this.safeNumber(d,"amount"),u=this.safeNumber(d,"pending"),h=this.safeValue(d,"time"),p=this.safeValue(d,"complete")?"closed":"open";let m;return c!==void 0&&u!==void 0&&(m=Math.max(c-u,0)),{id:this.safeString(d,"id"),info:d,clientOrderId:void 0,timestamp:h,datetime:this.iso8601(h),lastTradeTimestamp:void 0,type:t,side:this.safeString(d,"type"),symbol:a.symbol,status:p,price:this.safeNumber(d,"price"),amount:c,cost:void 0,average:void 0,remaining:u,filled:m,fee:void 0,trades:void 0}}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e};return await this.privatePostCancelOrder(this.extend(i,s))}parseOrder(e,t=void 0){let s=this.safeValue(e,"time");typeof s=="string"&&s.indexOf("T")>=0?s=this.parse8601(s):s=parseInt(s);let i;if(t===void 0){const m=this.safeString(e,"symbol1"),g=this.safeString(e,"symbol2"),y=this.safeCurrencyCode(m),b=this.safeCurrencyCode(g);i=y+"/"+b,i in this.markets&&(t=this.market(i))}const n=this.parseOrderStatus(this.safeString(e,"status")),r=this.safeNumber(e,"price");let a=this.safeNumber(e,"amount");a!==void 0&&(a=Math.abs(a));const o=this.safeNumber2(e,"pending","remains"),d=a-o;let c,u;if(t!==void 0){i=t.symbol;const m=this.safeNumber(e,"ta:"+t.quote),g=this.safeNumber(e,"tta:"+t.quote);u=this.sum(m,g);const y="fa:"+t.base,b="tfa:"+t.base,w="fa:"+t.quote,S="tfa:"+t.quote;let k=this.safeNumber(e,"tradingFeeMaker");if(k||(k=this.safeNumber(e,"tradingFeeTaker",k)),k&&(k/=100),y in e||b in e){const T=this.safeNumber2(e,y,b);c={currency:t.base,rate:k,cost:T}}else if(w in e||S in e){const T=this.safeNumber2(e,w,S);c={currency:t.quote,rate:k,cost:T}}}u||(u=r*d);const h=e.type;let l;const p=e.id;if("vtx"in e){l=[];for(let m=0;m<e.vtx.length;m++){const g=e.vtx[m],y=this.safeString(g,"type");if(y==="cancel")continue;const b=this.safeNumber(g,"price");if(b===void 0||y==="costsNothing")continue;const w=this.parse8601(this.safeString(g,"time")),S=this.safeNumber(g,"amount"),k=this.safeNumber(g,"fee_amount");let T=S<0?-S:S,I;y==="sell"?(I=T,T=this.sum(k,I)/b):I=T*b,l.push({id:this.safeString(g,"id"),timestamp:w,datetime:this.iso8601(w),order:p,symbol:i,price:b,amount:T,cost:I,side:y,fee:{cost:k,currency:t.quote},info:g,type:void 0,takerOrMaker:void 0})}}return{id:p,clientOrderId:void 0,datetime:this.iso8601(s),timestamp:s,lastTradeTimestamp:void 0,status:n,symbol:i,type:r===void 0?"market":"limit",timeInForce:void 0,postOnly:void 0,side:h,price:r,stopPrice:void 0,cost:u,amount:a,filled:d,remaining:o,trades:l,fee:c,info:e,average:void 0}}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r="privatePostOpenOrders",a;e!==void 0&&(a=this.market(e),n.pair=a.id,r+="Pair");const o=await this[r](this.extend(n,i));for(let d=0;d<o.length;d++)o[d]=this.extend(o[d],{status:"open"});return this.parseOrders(o,a,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n="privatePostArchivedOrdersPair";if(e===void 0)throw new e0(this.id+" fetchClosedOrders() requires a symbol argument");const r=this.market(e),a={pair:r.id},o=await this[n](this.extend(a,i));return this.parseOrders(o,r,t,s)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e.toString()},n=await this.privatePostGetOrderTx(this.extend(i,s)),r=this.safeValue(n,"data",{});return this.parseOrder(r)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={limit:s,pair:n.id,dateFrom:t},a=await this.privatePostArchivedOrdersPair(this.extend(r,i)),o=[];for(let d=0;d<a.length;d++){const c=a[d],u=this.parseOrderStatus(this.safeString(c,"status")),h=this.safeString(c,"symbol1"),l=this.safeString(c,"symbol2"),p=this.safeCurrencyCode(h),m=this.safeCurrencyCode(l),g=p+"/"+m,y=this.safeString(c,"type"),b=this.safeNumber(c,"a:"+h+":cds"),w=this.safeNumber(c,"a:"+l+":cds"),S=this.safeNumber(c,"f:"+l+":cds"),k=this.safeNumber(c,"amount"),T=this.safeNumber(c,"price"),I=this.safeNumber(c,"remains"),_=k-I;let N,M,x,v;if(!T)v="market",N=b,M=w,x=N/M;else{const q=this.safeNumber(c,"ta:"+l,0),R=this.safeNumber(c,"tta:"+l,0),H=this.safeNumber(c,"fa:"+l,0),F=this.safeNumber(c,"tfa:"+l,0);y==="sell"?M=this.sum(this.sum(q,R),this.sum(H,F)):M=this.sum(q,R)-this.sum(H,F),v="limit",N=k,x=M/_}const O=this.safeString(c,"time"),A=this.safeString(c,"lastTxTime"),V=this.parse8601(O);o.push({id:this.safeString(c,"id"),timestamp:V,datetime:this.iso8601(V),lastUpdated:this.parse8601(A),status:u,symbol:g,side:y,price:T,amount:N,average:x,type:v,filled:_,cost:M,remaining:I,fee:{cost:S,currency:m},info:c})}return o}parseOrderStatus(e){return this.safeString(this.options.order.status,e,e)}async editOrder(e,t,s,i,n=void 0,r=void 0,a={}){if(n===void 0)throw new e0(this.id+" editOrder() requires a amount argument");if(r===void 0)throw new e0(this.id+" editOrder() requires a price argument");await this.loadMarkets();const o=this.market(t),d={pair:o.id,type:i,amount:n,price:r,order_id:e},c=await this.privatePostCancelReplaceOrderPair(this.extend(d,a));return this.parseOrder(c,o)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},[n,r]=this.handleNetworkCodeAndParams(t),a=await this.privatePostGetCryptoAddress(this.extend(i,r)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"addresses",[]),c=this.indexBy(d,"blockchain"),u=this.selectNetworkIdFromAvailableNetworks(e,n,c),h=this.safeValue(c,u,{}),l=this.safeString2(h,"address","destination");return this.checkAddress(l),{currency:e,address:l,tag:this.safeString2(h,"destinationTag","memo"),network:this.networkIdToCode(u),info:o}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials();const d=this.nonce().toString(),c=d+this.uid+this.apiKey,u=this.hmac(this.encode(c),this.encode(this.secret));r=this.json(this.extend({key:this.apiKey,signature:u.toUpperCase(),nonce:d},o)),n={"Content-Type":"application/json"}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(Array.isArray(a))return a;if(r!=="true"){if(a===void 0)throw new gk(this.id+" returned "+this.json(a));if(!("e"in a&&"ok"in a&&a.ok==="ok")&&"error"in a){const c=this.safeString(a,"error"),u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u),new mk(u)}}}};const _8=me,{ExchangeError:Rn,ArgumentsRequired:bk,AuthenticationError:Ki,RateLimitExceeded:C8,InvalidNonce:M8}=oe,{TICK_SIZE:P8}=pe,hc=ke;var A8=class extends _8{describe(){return this.deepExtend(super.describe(),{id:"coinbase",name:"Coinbase",countries:["US"],rateLimit:400,version:"v2",userAgent:this.userAgents.chrome,headers:{"CB-VERSION":"2018-05-30"},has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:void 0,createDepositAddress:!0,createOrder:void 0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:void 0,fetchCurrencies:!0,fetchDepositAddress:void 0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchL2OrderBook:!1,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyBuys:!0,fetchMySells:!0,fetchMyTrades:void 0,fetchOHLCV:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:void 0,fetchOrder:void 0,fetchOrderBook:!1,fetchOrders:void 0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:void 0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactions:void 0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:void 0},urls:{logo:"https://user-images.githubusercontent.com/1294454/40811661-b6eceae2-653a-11e8-829e-10bfadb078cf.jpg",api:{rest:"https://api.coinbase.com"},www:"https://www.coinbase.com",doc:"https://developers.coinbase.com/api/v2",fees:"https://support.coinbase.com/customer/portal/articles/2109597-buy-sell-bank-transfer-fees",referral:"https://www.coinbase.com/join/58cbe25a355148797479dbd2"},requiredCredentials:{apiKey:!0,secret:!0},api:{public:{get:["currencies","time","exchange-rates","users/{user_id}","prices/{symbol}/buy","prices/{symbol}/sell","prices/{symbol}/spot"]},private:{get:["accounts","accounts/{account_id}","accounts/{account_id}/addresses","accounts/{account_id}/addresses/{address_id}","accounts/{account_id}/addresses/{address_id}/transactions","accounts/{account_id}/transactions","accounts/{account_id}/transactions/{transaction_id}","accounts/{account_id}/buys","accounts/{account_id}/buys/{buy_id}","accounts/{account_id}/sells","accounts/{account_id}/sells/{sell_id}","accounts/{account_id}/deposits","accounts/{account_id}/deposits/{deposit_id}","accounts/{account_id}/withdrawals","accounts/{account_id}/withdrawals/{withdrawal_id}","payment-methods","payment-methods/{payment_method_id}","user","user/auth"],post:["accounts","accounts/{account_id}/primary","accounts/{account_id}/addresses","accounts/{account_id}/transactions","accounts/{account_id}/transactions/{transaction_id}/complete","accounts/{account_id}/transactions/{transaction_id}/resend","accounts/{account_id}/buys","accounts/{account_id}/buys/{buy_id}/commit","accounts/{account_id}/sells","accounts/{account_id}/sells/{sell_id}/commit","accounts/{account_id}/deposits","accounts/{account_id}/deposits/{deposit_id}/commit","accounts/{account_id}/withdrawals","accounts/{account_id}/withdrawals/{withdrawal_id}/commit"],put:["accounts/{account_id}","user"],delete:["accounts/{id}","accounts/{account_id}/transactions/{transaction_id}"]}},precisionMode:P8,exceptions:{exact:{two_factor_required:Ki,param_required:Rn,validation_error:Rn,invalid_request:Rn,personal_details_required:Ki,identity_verification_required:Ki,jumio_verification_required:Ki,jumio_face_match_verification_required:Ki,unverified_email:Ki,authentication_error:Ki,invalid_authentication_method:Ki,invalid_token:Ki,revoked_token:Ki,expired_token:Ki,invalid_scope:Ki,not_found:Rn,rate_limit_exceeded:C8,internal_server_error:Rn},broad:{"request timestamp expired":M8}},commonCurrencies:{CGLD:"CELO"},options:{fetchCurrencies:{expires:5e3},accounts:["wallet","fiat"]}})}async fetchTime(e={}){const t=await this.publicGetTime(e),s=this.safeValue(t,"data",{});return this.safeTimestamp(s,"epoch")}async fetchAccounts(e={}){await this.loadMarkets();const t={limit:100},s=await this.privateGetAccounts(this.extend(t,e)),i=this.safeValue(s,"data",[]);return this.parseAccounts(i,e)}parseAccount(e){const t=this.safeValue(e,"currency",{}),s=this.safeString(t,"code"),i=this.safeCurrencyCode(s);return{id:this.safeString(e,"id"),type:this.safeString(e,"type"),code:i,info:e}}async createDepositAddress(e,t={}){let s=this.safeString(t,"account_id");if(t=this.omit(t,"account_id"),s===void 0){await this.loadAccounts();for(let d=0;d<this.accounts.length;d++){const c=this.accounts[d];if(c.code===e&&c.type==="wallet"){s=c.id;break}}}if(s===void 0)throw new Rn(this.id+" createDepositAddress() could not find the account with matching currency code, specify an `account_id` extra param");const i={account_id:s},n=await this.privatePostAccountsAccountIdAddresses(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeString(r,"destination_tag"),o=this.safeString(r,"address");return{currency:e,tag:a,address:o,info:n}}async fetchMySells(e=void 0,t=void 0,s=void 0,i={}){const n=this.prepareAccountRequest(s,i);await this.loadMarkets();const r=this.omit(i,["account_id","accountId"]),a=await this.privateGetAccountsAccountIdSells(this.extend(n,r));return this.parseTrades(a.data,void 0,t,s)}async fetchMyBuys(e=void 0,t=void 0,s=void 0,i={}){const n=this.prepareAccountRequest(s,i);await this.loadMarkets();const r=this.omit(i,["account_id","accountId"]),a=await this.privateGetAccountsAccountIdBuys(this.extend(n,r));return this.parseTrades(a.data,void 0,t,s)}async fetchTransactionsWithMethod(e,t=void 0,s=void 0,i=void 0,n={}){const r=await this.prepareAccountRequestWithCurrencyCode(t,i,n);await this.loadMarkets();const a=this.omit(n,["account_id","accountId"]),o=await this[e](this.extend(r,a));return this.parseTransactions(o.data,void 0,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsWithMethod("privateGetAccountsAccountIdWithdrawals",e,t,s,i)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsWithMethod("privateGetAccountsAccountIdDeposits",e,t,s,i)}parseTransactionStatus(e){const t={created:"pending",completed:"ok",canceled:"canceled"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeValue(e,"subtotal",{}),i=this.safeValue(e,"fee",{}),n=this.safeString(e,"id"),r=this.parse8601(this.safeValue(e,"created_at")),a=this.parse8601(this.safeValue(e,"updated_at")),o=this.safeString(e,"resource"),d=this.safeNumber(s,"amount"),c=this.safeString(s,"currency"),u=this.safeCurrencyCode(c),h=this.safeNumber(i,"amount"),l=this.safeString(i,"currency"),p=this.safeCurrencyCode(l),m={cost:h,currency:p};let g=this.parseTransactionStatus(this.safeString(e,"status"));return g===void 0&&(g=this.safeValue(e,"committed")?"ok":"pending"),{info:e,id:n,txid:n,timestamp:r,datetime:this.iso8601(r),network:void 0,address:void 0,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:o,amount:d,currency:u,status:g,updated:a,fee:m}}parseTrade(e,t=void 0){let s;const i=this.safeValue(e,"total",{}),n=this.safeValue(e,"amount",{}),r=this.safeValue(e,"subtotal",{}),a=this.safeValue(e,"fee",{}),o=this.safeString(e,"id"),d=this.parse8601(this.safeValue(e,"created_at"));if(t===void 0){const T=this.safeString(n,"currency"),I=this.safeString(i,"currency");if(T!==void 0&&I!==void 0){const _=this.safeCurrencyCode(T),N=this.safeCurrencyCode(I);s=_+"/"+N}}const c=void 0,u=this.safeString(e,"resource"),h=void 0,l=this.safeString(r,"amount"),p=this.safeString(n,"amount"),m=this.parseNumber(l),g=this.parseNumber(p),y=this.parseNumber(hc.stringDiv(l,p)),b=this.safeNumber(a,"amount"),w=this.safeString(a,"currency"),S=this.safeCurrencyCode(w),k={cost:b,currency:S};return{info:e,id:o,order:c,timestamp:d,datetime:this.iso8601(d),symbol:s,type:h,side:u,takerOrMaker:void 0,price:y,amount:g,cost:m,fee:k}}async fetchMarkets(e={}){const t=await this.fetchCurrenciesFromCache(e),s=this.safeValue(t,"currencies",{}),i=this.safeValue(t,"exchangeRates",{}),n=this.safeValue(s,"data",[]),r=this.indexBy(n,"id"),a=this.safeValue(this.safeValue(i,"data",{}),"rates",{}),o=Object.keys(a),d=[];for(let c=0;c<o.length;c++){const u=o[c],h=this.safeCurrencyCode(u);if((u in r?"fiat":"crypto")==="crypto")for(let p=0;p<n.length;p++){const m=n[p],g=this.safeString(m,"id"),y=this.safeCurrencyCode(g);d.push({id:u+"-"+g,symbol:h+"/"+y,base:h,quote:y,settle:void 0,baseId:u,quoteId:g,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:void 0,price:void 0},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(m,"min_size"),max:void 0}},info:m})}}return d}async fetchCurrenciesFromCache(e={}){const t=this.safeValue(this.options,"fetchCurrencies",{}),s=this.safeInteger(t,"timestamp"),i=this.safeInteger(t,"expires",1e3),n=this.milliseconds();if(s===void 0||n-s>i){const r=await this.publicGetCurrencies(e),a=await this.publicGetExchangeRates(e);this.options.fetchCurrencies=this.extend(t,{currencies:r,exchangeRates:a,timestamp:n})}return this.safeValue(this.options,"fetchCurrencies",{})}async fetchCurrencies(e={}){const t=await this.fetchCurrenciesFromCache(e),s=this.safeValue(t,"currencies",{}),i=this.safeValue(t,"exchangeRates",{}),n=this.safeValue(s,"data",[]),r=this.indexBy(n,"id"),a=this.safeValue(this.safeValue(i,"data",{}),"rates",{}),o=Object.keys(a),d={};for(let c=0;c<o.length;c++){const u=o[c],h=u in r?"fiat":"crypto",l=this.safeValue(r,u,{}),p=this.safeString(l,"id",u),m=this.safeString(l,"name"),g=this.safeCurrencyCode(p);d[g]={id:p,code:g,info:l,type:h,name:m,active:!0,deposit:void 0,withdraw:void 0,fee:void 0,precision:void 0,limits:{amount:{min:this.safeNumber(l,"min_size"),max:void 0},withdraw:{min:void 0,max:void 0}}}}return d}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={},i=await this.publicGetExchangeRates(this.extend(s,t)),n=this.safeValue(i,"data",{}),r=this.safeValue(n,"rates",{}),a=this.safeString(n,"currency"),o={},d=Object.keys(r),c="-";for(let u=0;u<d.length;u++){const h=d[u],l=h+c+a,p=this.safeMarket(l,void 0,c),m=p.symbol;o[m]=this.parseTicker(r[h],p)}return this.filterByArray(o,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=this.extend({symbol:s.id},t),n=await this.publicGetPricesSymbolSpot(i),r=await this.publicGetPricesSymbolBuy(i),a=await this.publicGetPricesSymbolSell(i);return this.parseTicker([n,r,a],s)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t);let i,n,r;const a=this.milliseconds();if(typeof e!="string"){const[o,d,c]=e,u=this.safeValue(o,"data",{}),h=this.safeValue(c,"data",{}),l=this.safeValue(d,"data",{});r=this.safeString(u,"amount"),n=this.safeString(h,"amount"),i=this.safeString(l,"amount")}return this.safeTicker({symbol:s,timestamp:a,datetime:this.iso8601(a),bid:n,ask:i,last:r,high:void 0,low:void 0,bidVolume:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:void 0,info:e},t)}parseBalance(e,t={}){const s=this.safeValue(e,"data",[]),i=this.safeValue(t,"type",this.options.accounts),n={info:e};for(let r=0;r<s.length;r++){const a=s[r],o=this.safeString(a,"type");if(this.inArray(o,i)){const d=this.safeValue(a,"balance");if(d!==void 0){const c=this.safeString(d,"currency"),u=this.safeCurrencyCode(c),h=this.safeString(d,"amount"),l=h;let p=this.safeValue(n,u);p===void 0?(p=this.account(),p.free=l,p.total=h):(p.free=hc.stringAdd(p.free,h),p.total=hc.stringAdd(p.total,h)),n[u]=p}}}return this.safeBalance(n)}async fetchBalance(e={}){await this.loadMarkets();const t={limit:100},s=await this.privateGetAccounts(this.extend(t,e));return this.parseBalance(s,e)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r=await this.prepareAccountRequestWithCurrencyCode(e,s,i),a=this.omit(i,["account_id","accountId"]),o=await this.privateGetAccountsAccountIdTransactions(this.extend(r,a));return this.parseLedger(o.data,n,t,s)}parseLedgerEntryStatus(e){const t={completed:"ok"};return this.safeString(t,e,e)}parseLedgerEntryType(e){const t={buy:"trade",sell:"trade",fiat_deposit:"transaction",fiat_withdrawal:"transaction",exchange_deposit:"transaction",exchange_withdrawal:"transaction",send:"transaction",pro_deposit:"transaction",pro_withdrawal:"transaction"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeValue(e,"amount",{});let i=this.safeString(s,"amount"),n;hc.stringLt(i,"0")?(n="out",i=hc.stringNeg(i)):n="in";const r=this.safeString(s,"currency"),a=this.safeCurrencyCode(r,t);let o;const d=this.safeValue(e,"network",{}),c=this.safeValue(d,"transaction_fee");if(c!==void 0){const y=this.safeString(c,"currency"),b=this.safeCurrencyCode(y,t);o={cost:this.safeNumber(c,"amount"),currency:b}}const u=this.parse8601(this.safeValue(e,"created_at")),h=this.safeString(e,"id"),l=this.parseLedgerEntryType(this.safeString(e,"type")),p=this.parseLedgerEntryStatus(this.safeString(e,"status")),m=this.safeString(e,"resource_path");let g;if(m!==void 0){const y=m.split("/");y.length>3&&(g=y[3])}return{info:e,id:h,timestamp:u,datetime:this.iso8601(u),direction:n,account:g,referenceId:void 0,referenceAccount:void 0,type:l,currency:a,amount:this.parseNumber(i),before:void 0,after:void 0,status:p,fee:o}}async findAccountId(e){await this.loadMarkets(),await this.loadAccounts();for(let t=0;t<this.accounts.length;t++){const s=this.accounts[t];if(s.code===e)return s.id}}prepareAccountRequest(e=void 0,t={}){const s=this.safeString2(t,"account_id","accountId");if(s===void 0)throw new bk(this.id+" prepareAccountRequest() method requires an account_id (or accountId) parameter");const i={account_id:s};return e!==void 0&&(i.limit=e),i}async prepareAccountRequestWithCurrencyCode(e=void 0,t=void 0,s={}){let i=this.safeString2(s,"account_id","accountId");if(i===void 0){if(e===void 0)throw new bk(this.id+" prepareAccountRequestWithCurrencyCode() method requires an account_id (or accountId) parameter OR a currency code argument");if(i=await this.findAccountId(e),i===void 0)throw new Rn(this.id+" prepareAccountRequestWithCurrencyCode() could not find account id for "+e)}const n={account_id:i};return t!==void 0&&(n.limit=t),n}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));s==="GET"&&Object.keys(o).length&&(a+="?"+this.urlencode(o));const d=this.urls.api.rest+a;if(t==="private"){const c=this.safeString(this.headers,"Authorization");if(c!==void 0)n={Authorization:c,"Content-Type":"application/json"};else if(this.token)n={Authorization:"Bearer "+this.token,"Content-Type":"application/json"};else{this.checkRequiredCredentials();const u=this.nonce().toString();let h="";s!=="GET"&&Object.keys(o).length&&(r=this.json(o),h=r);const l=u+s+a+h,p=this.hmac(this.encode(l),this.encode(this.secret));n={"CB-ACCESS-KEY":this.apiKey,"CB-ACCESS-SIGN":p,"CB-ACCESS-TIMESTAMP":u,"Content-Type":"application/json"}}}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.id+" "+r;let u=this.safeString(a,"error");if(u!==void 0){const p=this.safeString(a,"error_description");throw this.throwExactlyMatchedException(this.exceptions.exact,u,c),this.throwBroadlyMatchedException(this.exceptions.broad,p,c),new Rn(c)}const h=this.safeValue(a,"errors");if(h!==void 0&&Array.isArray(h)&&h.length>0){u=this.safeString(h[0],"id");const m=this.safeString(h[0],"message");if(u!==void 0)throw this.throwExactlyMatchedException(this.exceptions.exact,u,c),this.throwBroadlyMatchedException(this.exceptions.broad,m,c),new Rn(c)}if(this.safeValue(a,"data")===void 0)throw new Rn(this.id+" failed due to a malformed response "+this.json(a))}};const B8=me,{InsufficientFunds:N8,ArgumentsRequired:wk,ExchangeError:Ea,InvalidOrder:lc,InvalidAddress:E8,AuthenticationError:If,NotSupported:V8,OrderNotFound:i0,OnMaintenance:Sk,PermissionDenied:q8,RateLimitExceeded:L8}=oe,{TICK_SIZE:R8}=pe,n0=ke;var vb=class extends B8{describe(){return this.deepExtend(super.describe(),{id:"coinbasepro",name:"Coinbase Pro",countries:["US"],rateLimit:100,userAgent:this.userAgents.chrome,pro:!0,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:void 0,fetchDeposits:!0,fetchLedger:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPositionMode:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:!0,fetchWithdrawals:!0,withdraw:!0},timeframes:{"1m":60,"5m":300,"15m":900,"1h":3600,"6h":21600,"1d":86400},hostname:"pro.coinbase.com",urls:{test:{public:"https://api-public.sandbox.pro.coinbase.com",private:"https://api-public.sandbox.pro.coinbase.com"},logo:"https://user-images.githubusercontent.com/1294454/41764625-63b7ffde-760a-11e8-996d-a6328fa9347a.jpg",api:{public:"https://api.{hostname}",private:"https://api.{hostname}"},www:"https://pro.coinbase.com/",doc:"https://docs.pro.coinbase.com",fees:["https://docs.pro.coinbase.com/#fees","https://support.pro.coinbase.com/customer/en/portal/articles/2945310-fees"]},requiredCredentials:{apiKey:!0,secret:!0,password:!0},api:{public:{get:["currencies","products","products/{id}","products/{id}/book","products/{id}/candles","products/{id}/stats","products/{id}/ticker","products/{id}/trades","time","products/spark-lines"]},private:{get:["accounts","accounts/{id}","accounts/{id}/holds","accounts/{id}/ledger","accounts/{id}/transfers","coinbase-accounts","fills","funding","fees","margin/profile_information","margin/buying_power","margin/withdrawal_power","margin/withdrawal_power_all","margin/exit_plan","margin/liquidation_history","margin/position_refresh_amounts","margin/status","oracle","orders","orders/{id}","orders/client:{client_oid}","otc/orders","payment-methods","position","profiles","profiles/{id}","reports/{report_id}","transfers","transfers/{transfer_id}","users/self/exchange-limits","users/self/hold-balances","users/self/trailing-volume","withdrawals/fee-estimate","conversions/{conversion_id}"],post:["conversions","deposits/coinbase-account","deposits/payment-method","coinbase-accounts/{id}/addresses","funding/repay","orders","position/close","profiles/margin-transfer","profiles/transfer","reports","withdrawals/coinbase","withdrawals/coinbase-account","withdrawals/crypto","withdrawals/payment-method"],delete:["orders","orders/client:{client_oid}","orders/{id}"]}},commonCurrencies:{CGLD:"CELO"},precisionMode:R8,fees:{trading:{tierBased:!0,percentage:!0,maker:.4/100,taker:.6/100},funding:{tierBased:!1,percentage:!1,withdraw:{BCH:0,BTC:0,LTC:0,ETH:0,EUR:.15,USD:25},deposit:{BCH:0,BTC:0,LTC:0,ETH:0,EUR:.15,USD:10}}},exceptions:{exact:{"Insufficient funds":N8,NotFound:i0,"Invalid API Key":If,"invalid signature":If,"Invalid Passphrase":If,"Invalid order id":lc,"Private rate limit exceeded":L8,"Trading pair not available":q8,"Product not found":lc},broad:{"Order already done":i0,"order not found":i0,"price too small":lc,"price too precise":lc,"under maintenance":Sk,"size is too small":lc,"Cancel only mode":Sk}}})}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"id"),a=this.safeString(n,"name"),o=this.safeCurrencyCode(r),d=this.safeValue(n,"details",{}),u=this.safeString(n,"status")==="online";s[o]={id:r,code:o,info:n,type:this.safeString(d,"type"),name:a,active:u,deposit:void 0,withdraw:void 0,fee:void 0,precision:this.safeNumber(n,"max_precision"),limits:{amount:{min:this.safeNumber(d,"min_size"),max:void 0},withdraw:{min:this.safeNumber(d,"min_withdrawal_amount"),max:void 0}}}}return s}async fetchMarkets(e={}){const t=await this.publicGetProducts(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"id"),[a,o]=r.split("-"),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o),u=this.safeString(n,"status");s.push(this.extend(this.fees.trading,{id:r,symbol:d+"/"+c,base:d,quote:c,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:this.safeValue(n,"margin_enabled"),swap:!1,future:!1,option:!1,active:u==="online",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(n,"base_increment"),price:this.safeNumber(n,"quote_increment")},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(n,"min_market_funds"),max:void 0}},info:n}))}return s}async fetchAccounts(e={}){await this.loadMarkets();const t=await this.privateGetAccounts(e);return this.parseAccounts(t,e)}parseAccount(e){const t=this.safeString(e,"currency");return{id:this.safeString(e,"id"),type:void 0,code:this.safeCurrencyCode(t),info:e}}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"available"),a.used=this.safeString(i,"hold"),a.total=this.safeString(i,"balance"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccounts(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={id:this.marketId(e),level:2},n=await this.publicGetProductsIdBook(this.extend(i,s)),r=this.parseOrderBook(n,e);return r.nonce=this.safeInteger(n,"sequence"),r}parseTicker(e,t=void 0){let s,i,n,r,a,o,d,c;const u=t===void 0?void 0:t.symbol;return Array.isArray(e)?(r=this.safeString(e,4),s=this.milliseconds()):(s=this.parse8601(this.safeValue(e,"time")),i=this.safeString(e,"bid"),n=this.safeString(e,"ask"),a=this.safeString(e,"high"),o=this.safeString(e,"low"),d=this.safeString(e,"open"),r=this.safeString2(e,"price","last"),c=this.safeString(e,"volume")),this.safeTicker({symbol:u,timestamp:s,datetime:this.iso8601(s),high:a,low:o,bid:i,bidVolume:void 0,ask:n,askVolume:void 0,vwap:void 0,open:d,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:c,quoteVolume:void 0,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={},i=await this.publicGetProductsSparkLines(this.extend(s,t)),n={},r=Object.keys(i),a="-";for(let o=0;o<r.length;o++){const d=r[o],c=this.safeValue(i,d,[]),u=this.safeValue(c,0,[]),h=this.safeMarket(d,void 0,a),l=h.symbol;n[l]=this.parseTicker(u,h)}return this.filterByArray(n,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={id:s.id},n=this.safeString(this.options,"fetchTickerMethod","publicGetProductsIdTicker"),r=await this[n](this.extend(i,t));return this.parseTicker(r,s)}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString2(e,"time","created_at")),i=this.safeString(e,"product_id");t=this.safeMarket(i,t,"-");let n,r,a;const o=this.safeStringLower(t,"quoteId");if(o!==void 0){const b=o+"_value";a=this.safeString(e,b);const w=this.safeString(e,"liquidity");w!==void 0&&(r=w==="T"?"taker":"maker",n=this.safeString(t,r))}const c={cost:this.safeString2(e,"fill_fees","fee"),currency:t.quote,rate:n},u=this.safeString(e,"trade_id");let h=e.side==="buy"?"sell":"buy";const l=this.safeString(e,"order_id"),p=this.safeString(e,"maker_order_id"),m=this.safeString(e,"taker_order_id");(l!==void 0||p!==void 0&&m!==void 0)&&(h=e.side==="buy"?"buy":"sell");const g=this.safeString(e,"price"),y=this.safeString(e,"size");return this.safeTrade({id:u,order:l,info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:void 0,takerOrMaker:r,side:h,price:g,amount:y,fee:c,cost:a},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new wk(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={product_id:n.id};s!==void 0&&(r.limit=s);const a=await this.privateGetFills(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={id:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetProductsIdTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetFees(e),s=this.safeNumber(t,"maker_fee_rate"),i=this.safeNumber(t,"taker_fee_rate"),n={};for(let r=0;r<this.symbols.length;r++){const a=this.symbols[r];n[a]={info:t,symbol:a,maker:s,taker:i,percentage:!0,tierBased:!0}}return n}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,3),this.safeNumber(e,2),this.safeNumber(e,1),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.timeframes[t],o={id:r.id,granularity:a};s!==void 0&&(o.start=this.iso8601(s),i===void 0?i=300:i=Math.min(300,i),o.end=this.iso8601(this.sum((i-1)*a*1e3,s)));const d=await this.publicGetProductsIdCandles(this.extend(o,n));return this.parseOHLCVs(d,r,t,s,i)}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeTimestamp(t,"epoch")}parseOrderStatus(e){const t={pending:"open",active:"open",open:"open",done:"closed",canceled:"canceled",canceling:"open"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parse8601(this.safeString(e,"created_at")),i=this.safeString(e,"product_id");t=this.safeMarket(i,t,"-");let n=this.parseOrderStatus(this.safeString(e,"status"));const r=this.safeString(e,"done_reason");n==="closed"&&r==="canceled"&&(n="canceled");const a=this.safeString(e,"price"),o=this.safeString(e,"filled_size"),d=this.safeString(e,"size",o),c=this.safeString(e,"executed_value"),u=this.safeNumber(e,"fill_fees");let h;u!==void 0&&(h={cost:u,currency:t.quote,rate:void 0});const l=this.safeString(e,"id"),p=this.safeString(e,"type"),m=this.safeString(e,"side"),g=this.safeString(e,"time_in_force"),y=this.safeValue(e,"post_only"),b=this.safeNumber(e,"stop_price"),w=this.safeString(e,"client_oid");return this.safeOrder({id:l,clientOrderId:w,info:e,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,status:n,symbol:t.symbol,type:p,timeInForce:g,postOnly:y,side:m,price:a,stopPrice:b,cost:c,amount:d,filled:o,remaining:void 0,fee:h,average:void 0,trades:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={},n=this.safeString2(s,"clientOrderId","client_oid");let r;n===void 0?(r="privateGetOrdersId",i.id=e):(r="privateGetOrdersClientClientOid",i.client_oid=n,s=this.omit(s,["clientOrderId","client_oid"]));const a=await this[r](this.extend(i,s));return this.parseOrder(a)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;t!==void 0&&(r=this.market(t));const a={order_id:e},o=await this.privateGetFills(this.extend(a,n));return this.parseTrades(o,r,s,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"all"};return await this.fetchOpenOrders(e,t,s,this.extend(n,i))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.product_id=r.id),s!==void 0&&(n.limit=s);const a=await this.privateGetOrders(this.extend(n,i));return this.parseOrders(a,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"done"};return await this.fetchOpenOrders(e,t,s,this.extend(n,i))}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={type:t,side:s,product_id:a.id},d=this.safeString2(r,"clientOrderId","client_oid");d!==void 0&&(o.client_oid=d);const c=this.safeNumber2(r,"stopPrice","stop_price");c!==void 0&&(o.stop_price=this.priceToPrecision(e,c));const u=this.safeString2(r,"timeInForce","time_in_force");if(u!==void 0&&(o.time_in_force=u),this.safeValue2(r,"postOnly","post_only",!1)&&(o.post_only=!0),r=this.omit(r,["timeInForce","time_in_force","stopPrice","stop_price","clientOrderId","client_oid","postOnly","post_only"]),t==="limit")o.price=this.priceToPrecision(e,n),o.size=this.amountToPrecision(e,i);else if(t==="market"){let p=this.safeNumber2(r,"cost","funds");p===void 0?n!==void 0&&(p=i*n):r=this.omit(r,["cost","funds"]),p!==void 0?o.funds=this.costToPrecision(e,p):o.size=this.amountToPrecision(e,i)}const l=await this.privatePostOrders(this.extend(o,r));return this.parseOrder(l,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={},n=this.safeString2(s,"clientOrderId","client_oid");let r;n===void 0?(r="privateDeleteOrdersId",i.id=e):(r="privateDeleteOrdersClientClientOid",i.client_oid=n,s=this.omit(s,["clientOrderId","client_oid"]));let a;return t!==void 0&&(a=this.market(t),i.product_id=a.symbol),await this[r](this.extend(i,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;return e!==void 0&&(i=this.market(e),s.product_id=i.symbol),await this.privateDeleteOrders(this.extend(s,t))}async fetchPaymentMethods(e={}){return await this.privateGetPaymentMethods(e)}async deposit(e,t,s,i={}){await this.loadMarkets();const r={currency:this.currency(e).id,amount:t};let a="privatePostDeposits";if("payment_method_id"in i)a+="PaymentMethod";else if("coinbase_account_id"in i)a+="CoinbaseAccount";else throw new V8(this.id+" deposit() requires one of `coinbase_account_id` or `payment_method_id` extra params");const o=await this[a](this.extend(r,i));if(!o)throw new Ea(this.id+" deposit() error: "+this.json(o));return{info:o,id:o.id}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,amount:t};let o="privatePostWithdrawals";"payment_method_id"in n?o+="PaymentMethod":"coinbase_account_id"in n?o+="CoinbaseAccount":(o+="Crypto",a.crypto_address=s,i!==void 0&&(a.destination_tag=i));const d=await this[o](this.extend(a,n));if(!d)throw new Ea(this.id+" withdraw() error: "+this.json(d));return this.parseTransaction(d,r)}parseLedgerEntryType(e){const t={transfer:"transfer",match:"trade",fee:"fee",rebate:"rebate",conversion:"trade"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"id");let i=this.safeString(e,"amount"),n;const r=this.safeString(e,"balance"),a=n0.stringSub(r,i);n0.stringLt(i,"0")?(n="out",i=n0.stringAbs(i)):n="in";const o=this.parseNumber(i),d=this.parseNumber(r),c=this.parseNumber(a),u=this.parse8601(this.safeValue(e,"created_at")),h=this.parseLedgerEntryType(this.safeString(e,"type")),l=this.safeCurrencyCode(void 0,t),p=this.safeValue(e,"details",{});let m,g,y;return h==="transfer"?(m=this.safeString(p,"from"),g=this.safeString(p,"to"),y=this.safeString(p,"profile_transfer_id")):y=this.safeString(p,"order_id"),{id:s,currency:l,account:m,referenceAccount:g,referenceId:y,status:"ok",amount:o,before:c,after:d,fee:void 0,direction:n,timestamp:u,datetime:this.iso8601(u),type:h,info:e}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new wk(this.id+" fetchLedger() requires a code param");await this.loadMarkets(),await this.loadAccounts();const n=this.currency(e),r=this.indexBy(this.accounts,"code"),a=this.safeValue(r,e);if(a===void 0)throw new Ea(this.id+" fetchLedger() could not find account id for "+e);const o={id:a.id};t!==void 0&&(o.start_date=this.iso8601(t)),s!==void 0&&(o.limit=s);const d=await this.privateGetAccountsIdLedger(this.extend(o,i));for(let c=0;c<d.length;c++)d[c].currency=e;return this.parseLedger(d,n,t,s)}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.loadAccounts();let n,r=this.safeString(i,"id");if(r===void 0&&e!==void 0){n=this.currency(e);const d=this.indexBy(this.accounts,"code"),c=this.safeValue(d,e);if(c===void 0)throw new Ea(this.id+" fetchTransactions() could not find account id for "+e);r=c.id}const a={};r!==void 0&&(a.id=r),s!==void 0&&(a.limit=s);let o;if(r===void 0){o=await this.privateGetTransfers(this.extend(a,i));for(let d=0;d<o.length;d++){const c=this.safeString(o[d],"account_id"),u=this.safeValue(this.accountsById,c),h=this.safeString(u,"code");o[d].currency=h}}else{o=await this.privateGetAccountsIdTransfers(this.extend(a,i));for(let d=0;d<o.length;d++)o[d].currency=e}return this.parseTransactions(o,n,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactions(e,t,s,this.extend({type:"deposit"},i))}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactions(e,t,s,this.extend({type:"withdraw"},i))}parseTransactionStatus(e){if(this.safeValue(e,"canceled_at"))return"canceled";const s=this.safeValue(e,"processed_at"),i=this.safeValue(e,"completed_at");return i?"ok":s&&!i?"failed":"pending"}parseTransaction(e,t=void 0){const s=this.safeValue(e,"details",{}),i=this.safeString(e,"id"),n=this.safeString(s,"crypto_transaction_hash"),r=this.parse8601(this.safeString(e,"created_at")),a=this.parse8601(this.safeString(e,"processed_at")),o=this.safeString(e,"currency"),d=this.safeCurrencyCode(o,t),c=this.parseTransactionStatus(e);let u=this.safeNumber(e,"amount"),h=this.safeString(e,"type"),l=this.safeString(s,"crypto_address");const p=this.safeString(s,"destination_tag");l=this.safeString(e,"crypto_address",l);let m;if(h==="withdraw"){h="withdrawal",l=this.safeString(s,"sent_to_address",l);const g=this.safeNumber(s,"fee");g!==void 0&&(u!==void 0&&(u-=g),m={cost:g,currency:d})}return{info:e,id:i,txid:n,timestamp:r,datetime:this.iso8601(r),network:void 0,address:l,addressTo:void 0,addressFrom:void 0,tag:p,tagTo:void 0,tagFrom:void 0,type:h,amount:u,currency:d,status:c,updated:a,fee:m}}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e);let i=this.safeValue(this.options,"coinbaseAccounts");i===void 0&&(i=await this.privateGetCoinbaseAccounts(),this.options.coinbaseAccounts=i,this.options.coinbaseAccountsByCurrencyId=this.indexBy(i,"currency"));const n=s.id,r=this.safeValue(this.options.coinbaseAccountsByCurrencyId,n);if(r===void 0)throw new E8(this.id+" createDepositAddress() could not find currency code "+e+" with id = "+n+" in this.options['coinbaseAccountsByCurrencyId']");const a={id:r.id},o=await this.privatePostCoinbaseAccountsIdAddresses(this.extend(a,t)),d=this.safeString(o,"address"),c=this.safeString(o,"destination_tag");return{currency:e,address:this.checkAddress(d),tag:c,info:o}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));s==="GET"&&Object.keys(o).length&&(a+="?"+this.urlencode(o));const d=this.implodeHostname(this.urls.api[t])+a;if(t==="private"){this.checkRequiredCredentials();const c=this.nonce().toString();let u="";s!=="GET"&&Object.keys(o).length&&(r=this.json(o),u=r);const h=c+s+a+u;let l;try{l=this.base64ToBinary(this.secret)}catch{throw new If(this.id+" sign() invalid base64 secret")}const p=this.hmac(this.encode(h),l,"sha256","base64");n={"CB-ACCESS-KEY":this.apiKey,"CB-ACCESS-SIGN":p,"CB-ACCESS-TIMESTAMP":c,"CB-ACCESS-PASSPHRASE":this.password,"Content-Type":"application/json"}}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(e===400||e===404){if(r[0]==="{"){const c=this.safeString(a,"message"),u=this.id+" "+c;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u),new Ea(u)}throw new Ea(this.id+" "+r)}}async request(e,t="public",s="GET",i={},n=void 0,r=void 0,a={},o={}){const d=await this.fetch2(e,t,s,i,n,r,a,o);if(typeof d!="string"&&"message"in d)throw new Ea(this.id+" "+this.json(d));return d}};const F8=vb;var D8=class extends F8{describe(){return this.deepExtend(super.describe(),{id:"coinbaseprime",name:"Coinbase Prime",pro:!0,hostname:"exchange.coinbase.com",urls:{test:{public:"https://public.sandbox.exchange.coinbase.com",private:"https://public.sandbox.exchange.coinbase.com"},logo:"https://user-images.githubusercontent.com/1294454/44539184-29f26e00-a70c-11e8-868f-e907fc236a7c.jpg",api:{public:"https://api.{hostname}",private:"https://api.{hostname}"},www:"https://exchange.coinbase.com",doc:"https://docs.exchange.coinbase.com"}})}};const H8=me,{BadSymbol:G8,ExchangeError:U8,AuthenticationError:kk}=oe,{TICK_SIZE:$8}=pe;var j8=class extends H8{describe(){return this.deepExtend(super.describe(),{id:"coincheck",name:"coincheck",countries:["JP","ID"],rateLimit:1500,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},urls:{logo:"https://user-images.githubusercontent.com/51840849/87182088-1d6d6380-c2ec-11ea-9c64-8ab9f9b289f5.jpg",api:{rest:"https://coincheck.com/api"},www:"https://coincheck.com",doc:"https://coincheck.com/documents/exchange/api",fees:["https://coincheck.com/exchange/fee","https://coincheck.com/info/fee"]},api:{public:{get:["exchange/orders/rate","order_books","rate/{pair}","ticker","trades"]},private:{get:["accounts","accounts/balance","accounts/leverage_balance","bank_accounts","deposit_money","exchange/orders/opens","exchange/orders/transactions","exchange/orders/transactions_pagination","exchange/leverage/positions","lending/borrows/matches","send_money","withdraws"],post:["bank_accounts","deposit_money/{id}/fast","exchange/orders","exchange/transfers/to_leverage","exchange/transfers/from_leverage","lending/borrows","lending/borrows/{id}/repay","send_money","withdraws"],delete:["bank_accounts/{id}","exchange/orders/{id}","withdraws/{id}"]}},markets:{"BTC/JPY":{id:"btc_jpy",symbol:"BTC/JPY",base:"BTC",quote:"JPY",baseId:"btc",quoteId:"jpy",type:"spot",spot:!0},"ETC/JPY":{id:"etc_jpy",symbol:"ETC/JPY",base:"ETC",quote:"JPY",baseId:"etc",quoteId:"jpy",type:"spot",spot:!0},"FCT/JPY":{id:"fct_jpy",symbol:"FCT/JPY",base:"FCT",quote:"JPY",baseId:"fct",quoteId:"jpy",type:"spot",spot:!0},"MONA/JPY":{id:"mona_jpy",symbol:"MONA/JPY",base:"MONA",quote:"JPY",baseId:"mona",quoteId:"jpy",type:"spot",spot:!0},"ETC/BTC":{id:"etc_btc",symbol:"ETC/BTC",base:"ETC",quote:"BTC",baseId:"etc",quoteId:"btc",type:"spot",spot:!0}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0"),taker:this.parseNumber("0")}},precisionMode:$8,exceptions:{exact:{"disabled API Key":kk,"invalid authentication":kk},broad:{}}})}parseBalance(e){const t={info:e},s=Object.keys(this.currencies);for(let i=0;i<s.length;i++){const n=s[i],a=this.currency(n).id;if(a in e){const o=this.account(),d=a+"_reserved";o.free=this.safeString(e,a),o.used=this.safeString(e,d),t[n]=o}}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountsBalance(e);return this.parseBalance(t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));const r=await this.privateGetExchangeOrdersOpens(i),a=this.safeValue(r,"orders",[]),o=this.parseOrders(a,n,t,s),d=[];for(let c=0;c<o.length;c++)d.push(this.extend(o[c],{status:"open"}));return d}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"order_type"),n=this.parse8601(this.safeString(e,"created_at")),r=this.safeString(e,"pending_amount"),a=this.safeString(e,"pending_amount"),o=this.safeString(e,"rate"),d=void 0,c=this.safeString(e,"pair"),u=this.safeSymbol(c,t,"_");return this.safeOrder({id:s,clientOrderId:void 0,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,amount:r,remaining:a,filled:void 0,side:i,type:void 0,timeInForce:void 0,postOnly:void 0,status:d,symbol:u,price:o,stopPrice:void 0,cost:void 0,fee:void 0,info:e,average:void 0,trades:void 0},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id},r=await this.publicGetOrderBooks(this.extend(n,s));return this.parseOrderBook(r,i.symbol)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeTimestamp(e,"timestamp"),n=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){if(e!=="BTC/JPY")throw new G8(this.id+" fetchTicker() supports BTC/JPY only");await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetTicker(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"created_at")),i=this.safeString(e,"id"),n=this.safeString(e,"rate"),r=this.safeString(e,"pair");t=this.safeMarket(r,t,"_");const a=t.baseId,o=t.quoteId,d=t.symbol;let c,u,h,l,p,m;if("liquidity"in e){this.safeString(e,"liquidity")==="T"?c="taker":this.safeString(e,"liquidity")==="M"&&(c="maker");const g=this.safeValue(e,"funds",{});u=this.safeString(g,a),h=this.safeString(g,o),p={currency:this.safeString(e,"fee_currency"),cost:this.safeString(e,"fee")},l=this.safeString(e,"side"),m=this.safeString(e,"order_id")}else u=this.safeString(e,"amount"),l=this.safeString(e,"order_type");return this.safeTrade({id:i,info:e,datetime:this.iso8601(s),timestamp:s,symbol:d,type:void 0,side:l,order:m,takerOrMaker:c,price:n,amount:u,cost:h,fee:p},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={};s!==void 0&&(r.limit=s);const a=await this.privateGetExchangeOrdersTransactionsPagination(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetTrades(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetAccounts(e),s=this.safeValue(t,"exchange_fees",{}),i={};for(let n=0;n<this.symbols.length;n++){const r=this.symbols[n],a=this.market(r),o=this.safeValue(s,a.id,{});i[r]={info:o,symbol:r,maker:this.safeNumber(o,"maker_fee"),taker:this.safeNumber(o,"taker_fee"),percentage:!0,tierBased:!1}}return i}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const o={pair:this.market(e).id};if(t==="market"){const u=t+"_"+s;o.order_type=u;const h=s==="buy"?u+"_":"";o[h+"amount"]=i}else o.order_type=s,o.rate=n,o.amount=i;const d=await this.privatePostExchangeOrders(this.extend(o,r)),c=this.safeString(d,"id");return{info:d,id:c}}async cancelOrder(e,t=void 0,s={}){const i={id:e};return await this.privateDeleteExchangeOrdersId(this.extend(i,s))}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.currency=n.id),s!==void 0&&(r.limit=s);const a=await this.privateGetDepositMoney(this.extend(r,i)),o=this.safeValue(a,"deposits",[]);return this.parseTransactions(o,n,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r={};s!==void 0&&(r.limit=s);const a=await this.privateGetWithdraws(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s,{type:"withdrawal"})}parseTransactionStatus(e){const t={pending:"pending",processing:"pending",finished:"ok",canceled:"canceled",confirmed:"pending",received:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.parse8601(this.safeString(e,"created_at")),n=this.safeString(e,"address"),r=this.safeNumber(e,"amount"),a=this.safeString(e,"currency"),o=this.safeCurrencyCode(a,t),d=this.parseTransactionStatus(this.safeString(e,"status")),c=this.parse8601(this.safeString(e,"confirmed_at"));let u;const h=this.safeNumber(e,"fee");return h!==void 0&&(u={cost:h,currency:o}),{info:e,id:s,txid:void 0,timestamp:i,datetime:this.iso8601(i),network:void 0,address:n,addressTo:n,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:void 0,amount:r,currency:o,status:d,updated:c,internal:void 0,fee:u}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials();const d=this.nonce().toString();let c="";s==="GET"?Object.keys(o).length&&(a+="?"+this.urlencode(this.keysort(o))):Object.keys(o).length&&(r=this.urlencode(this.keysort(o)),c=r);const u=d+a+c;n={"Content-Type":"application/x-www-form-urlencoded","ACCESS-KEY":this.apiKey,"ACCESS-NONCE":d,"ACCESS-SIGNATURE":this.hmac(this.encode(u),this.encode(this.secret))}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;if(!this.safeValue(a,"success",!0)){const u=this.safeString(a,"error"),h=this.id+" "+this.json(a);throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwBroadlyMatchedException(this.exceptions.broad,r,h),new U8(this.id+" "+this.json(a))}}};const W8=me,{ExchangeError:r0,ArgumentsRequired:vs,BadRequest:Ur,BadSymbol:a0,RateLimitExceeded:z8,InsufficientFunds:K8,OrderNotFound:X8,InvalidOrder:No,AuthenticationError:o0,PermissionDenied:Y8,ExchangeNotAvailable:Q8,RequestTimeout:Z8}=oe,{TICK_SIZE:J8}=pe,vk=ke;var N_=class extends W8{describe(){return this.deepExtend(super.describe(),{id:"coinex",name:"CoinEx",version:"v1",countries:["CN"],rateLimit:2.5,pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!1,option:!1,addMargin:!0,borrowMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,createReduceOnlyOrder:!0,fetchBalance:!0,fetchBorrowInterest:!0,fetchBorrowRate:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddressByNetwork:!1,fetchDepositAddresses:!1,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!0,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!0,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,"fetchTransactionFee:":!1,fetchTransactoinFees:!1,fetchTransfer:!1,fetchTransfers:!0,fetchWithdrawal:!1,fetchWithdrawals:!0,reduceMargin:!0,repayMargin:!0,setLeverage:!0,setMarginMode:!0,setPositionMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","2h":"2hour","4h":"4hour","6h":"6hour","12h":"12hour","1d":"1day","3d":"3day","1w":"1week"},urls:{logo:"https://user-images.githubusercontent.com/51840849/87182089-1e05fa00-c2ec-11ea-8da9-cc73b45abbbc.jpg",api:{public:"https://api.coinex.com",private:"https://api.coinex.com",perpetualPublic:"https://api.coinex.com/perpetual",perpetualPrivate:"https://api.coinex.com/perpetual"},www:"https://www.coinex.com",doc:"https://github.com/coinexcom/coinex_exchange_api/wiki",fees:"https://www.coinex.com/fees",referral:"https://www.coinex.com/register?refer_code=yw5fz"},api:{public:{get:{"amm/market":1,"common/currency/rate":1,"common/asset/config":1,"common/maintain/info":1,"common/temp-maintain/info":1,"margin/market":1,"market/info":1,"market/list":1,"market/ticker":1,"market/ticker/all":1,"market/depth":1,"market/deals":1,"market/kline":1,"market/detail":1}},private:{get:{"account/amm/balance":40,"account/investment/balance":40,"account/balance/history":40,"account/market/fee":40,"balance/coin/deposit":40,"balance/coin/withdraw":40,"balance/info":40,"balance/deposit/address/{coin_type}":40,"contract/transfer/history":40,"credit/info":40,"credit/balance":40,"investment/transfer/history":40,"margin/account":1,"margin/config":1,"margin/loan/history":40,"margin/transfer/history":40,"order/deals":40,"order/finished":40,"order/pending":4,"order/status":4,"order/status/batch":4,"order/user/deals":40,"order/stop/finished":40,"order/stop/pending":4,"order/user/trade/fee":1,"order/market/trade/info":1,"sub_account/balance":1,"sub_account/transfer/history":40,"sub_account/auth/api/{user_auth_id}":40},post:{"balance/coin/withdraw":40,"contract/balance/transfer":40,"margin/flat":40,"margin/loan":40,"margin/transfer":40,"order/limit/batch":13.334,"order/ioc":6.667,"order/limit":6.667,"order/market":6.667,"order/modify":6.667,"order/stop/limit":6.667,"order/stop/market":6.667,"order/stop/modify":6.667,"sub_account/transfer":40,"sub_account/register":1,"sub_account/unfrozen":40,"sub_account/frozen":40,"sub_account/auth/api":40},put:{"balance/deposit/address/{coin_type}":40,"sub_account/auth/api/{user_auth_id}":40,"v1/account/settings":40},delete:{"balance/coin/withdraw":40,"order/pending/batch":13.334,"order/pending":6.667,"order/stop/pending":13.334,"order/stop/pending/{id}":13.334,"sub_account/auth/api/{user_auth_id}":40}},perpetualPublic:{get:{ping:1,time:1,"market/list":1,"market/limit_config":1,"market/ticker":1,"market/ticker/all":1,"market/depth":1,"market/deals":1,"market/funding_history":1,"market/user_deals":1,"market/kline":1}},perpetualPrivate:{get:{"asset/query":40,"order/pending":4,"order/finished":40,"order/stop_finished":40,"order/stop_pending":4,"order/status":4,"order/stop_status":4,"position/pending":40,"position/funding":40},post:{"market/adjust_leverage":1,"market/position_expect":1,"order/put_limit":10,"order/put_market":10,"order/put_stop_limit":10,"order/put_stop_market":10,"order/modify":10,"order/modify_stop":10,"order/cancel":10,"order/cancel_all":20,"order/cancel_batch":20,"order/cancel_stop":10,"order/cancel_stop_all":20,"order/close_limit":10,"order/close_market":10,"position/adjust_margin":10,"position/stop_loss":10,"position/take_profit":10,"position/market_close":10}}},fees:{trading:{maker:.001,taker:.001},funding:{withdraw:{BCH:0,BTC:.001,LTC:.001,ETH:.001,ZEC:1e-4,DASH:1e-4}}},limits:{amount:{min:.001,max:void 0}},precision:{amount:this.parseNumber("0.00000001"),price:this.parseNumber("0.00000001")},options:{createMarketBuyOrderRequiresPrice:!0,defaultType:"spot",defaultSubType:"linear",defaultMarginMode:"isolated",fetchDepositAddress:{fillResponseFromRequest:!0},accountsById:{spot:"0"}},commonCurrencies:{ACM:"Actinium"},precisionMode:J8})}async fetchCurrencies(e={}){const t=await this.publicGetCommonAssetConfig(e),s=this.safeValue(t,"data",[]),i=Object.keys(s),n={};for(let r=0;r<i.length;r++){const a=i[r],o=s[a],d=this.safeString(o,"asset"),c=this.safeString(o,"chain"),u=this.safeCurrencyCode(d);this.safeValue(n,u)===void 0&&(n[u]={id:d,numericId:void 0,code:u,info:o,name:void 0,active:!0,deposit:this.safeValue(o,"can_deposit"),withdraw:this.safeValue(o,"can_withdraw"),fee:this.safeNumber(o,"withdraw_tx_fee"),precision:this.parseNumber(this.parsePrecision(this.safeString(o,"withdrawal_precision"))),limits:{amount:{min:void 0,max:void 0},deposit:{min:this.safeNumber(o,"deposit_least_amount"),max:void 0},withdraw:{min:this.safeNumber(o,"withdraw_least_amount"),max:void 0}}});const h=this.safeValue(n[u],"networks",{}),l={info:o,id:c,network:c,name:void 0,limits:{amount:{min:void 0,max:void 0},deposit:{min:this.safeNumber(o,"deposit_least_amount"),max:void 0},withdraw:{min:this.safeNumber(o,"withdraw_least_amount"),max:void 0}},active:!0,deposit:this.safeValue(o,"can_deposit"),withdraw:this.safeValue(o,"can_withdraw"),fee:this.safeNumber(o,"withdraw_tx_fee"),precision:this.parseNumber(this.parsePrecision(this.safeString(o,"withdrawal_precision")))};h[c]=l,n[u].networks=h}return n}async fetchMarkets(e={}){let t=[];const[s,i]=this.handleMarketTypeAndParams("fetchMarkets",void 0,e);if(s==="spot"||s==="margin")t=await this.fetchSpotMarkets(i);else if(s==="swap")t=await this.fetchContractMarkets(i);else throw new r0(this.id+" does not support the '"+s+"' market type, set exchange.options['defaultType'] to 'spot', 'margin' or 'swap'");return t}async fetchSpotMarkets(e){const t=await this.publicGetMarketInfo(e),s=this.safeValue(t,"data",{}),i=[],n=Object.keys(s);for(let r=0;r<n.length;r++){const a=n[r],o=s[a],d=this.safeString(o,"name"),c=this.safeString(o,"trading_name"),u=c,h=this.safeString(o,"pricing_name"),l=this.safeCurrencyCode(u),p=this.safeCurrencyCode(h);let m=l+"/"+p;c===d&&(m=d),i.push({id:d,symbol:m,base:l,quote:p,settle:void 0,baseId:u,quoteId:h,settleId:void 0,type:"spot",spot:!0,margin:void 0,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(o,"taker_fee_rate"),maker:this.safeNumber(o,"maker_fee_rate"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(o,"trading_decimal"))),price:this.parseNumber(this.parsePrecision(this.safeString(o,"pricing_decimal")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(o,"min_amount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:o})}return i}async fetchContractMarkets(e){const t=await this.perpetualPublicGetMarketList(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.fees,o=this.safeValue(r,"leverages",[]),d=this.safeInteger(r,"type"),c=d===1,u=d===2,h=this.safeString(r,"name"),l=this.safeString(r,"stock"),p=this.safeString(r,"money"),m=this.safeCurrencyCode(l),g=this.safeCurrencyCode(p),y=d===1?"USDT":l,b=this.safeCurrencyCode(y),w=m+"/"+g+":"+b;i.push({id:h,symbol:w,base:m,quote:g,settle:b,baseId:l,quoteId:p,settleId:y,type:"swap",spot:!1,margin:!1,swap:!0,future:!1,option:!1,active:this.safeValue(r,"available"),contract:!0,linear:c,inverse:u,taker:a.trading.taker,maker:a.trading.maker,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"stock_prec"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"money_prec")))},limits:{leverage:{min:this.safeString(o,0),max:this.safeString(o,o.length-1)},amount:{min:this.safeString(r,"amount_min"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}parseTicker(e,t=void 0){const s=this.safeInteger(e,"date"),i=this.safeSymbol(void 0,t);e=this.safeValue(e,"ticker",{});const n=this.safeString(e,"last");return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString2(e,"vol","volume"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id},n=s.swap?"perpetualPublicGetMarketTicker":"publicGetMarketTicker",r=await this[n](this.extend(i,t));return this.parseTicker(r.data,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s;if(e!==void 0){const l=this.safeValue(e,0);s=this.market(l)}const[i,n]=this.handleMarketTypeAndParams("fetchTickers",s,t),a=await this[i==="swap"?"perpetualPublicGetMarketTickerAll":"publicGetMarketTickerAll"](n),o=this.safeValue(a,"data"),d=this.safeInteger(o,"date"),c=this.safeValue(o,"ticker",{}),u=Object.keys(c),h={};for(let l=0;l<u.length;l++){const p=u[l],m=this.safeMarket(p),g=m.symbol,y=this.parseTicker({date:d,ticker:c[p]},m);y.symbol=g,h[g]=y}return this.filterByArray(h,"symbol",e)}async fetchTime(e={}){const t=await this.perpetualPublicGetTime(e);return this.safeNumber(t,"data")}async fetchOrderBook(e,t=20,s={}){if(e===void 0)throw new vs(this.id+" fetchOrderBook() requires a symbol argument");await this.loadMarkets();const i=this.market(e);t===void 0&&(t=20);const n={market:this.marketId(e),merge:"0",limit:t.toString()},r=i.swap?"perpetualPublicGetMarketDepth":"publicGetMarketDepth",a=await this[r](this.extend(n,s)),o=this.safeValue(a,"data",{}),d=this.safeInteger(o,"time");return this.parseOrderBook(o,e,d)}parseTrade(e,t=void 0){let s=this.safeTimestamp2(e,"create_time","time");s===void 0&&(s=this.safeInteger(e,"date_ms"));const i=this.safeString(e,"id"),n=this.safeString(e,"order_id"),r=this.safeString(e,"price"),a=this.safeString(e,"amount"),o=this.safeString(e,"market");t=this.safeMarket(o,t);const d=this.safeSymbol(o,t),c=this.safeString(e,"deal_money");let u;const h=this.safeString2(e,"fee","deal_fee");if(h!==void 0){const m=this.safeString(e,"fee_asset"),g=this.safeCurrencyCode(m);u={cost:h,currency:g}}let l=this.safeString(e,"role");l==="1"?l="maker":l==="2"&&(l="taker");let p;return t.type==="swap"?(p=this.safeInteger(e,"side"),p===1?p="sell":p===2&&(p="buy"),p===void 0&&(p=this.safeString(e,"type"))):p=this.safeString(e,"type"),this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:d,id:i,order:n,type:void 0,side:p,takerOrMaker:l,price:r,amount:a,cost:c,fee:u},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market:n.id};s!==void 0&&(r.limit=s);const a=n.swap?"perpetualPublicGetMarketDeals":"publicGetMarketDeals",o=await this[a](this.extend(r,i));return this.parseTrades(o.data,n,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const i={market:this.market(e).id},n=await this.publicGetMarketDetail(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTradingFee(r)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetMarketInfo(e),s=this.safeValue(t,"data",{}),i={};for(let n=0;n<this.symbols.length;n++){const r=this.symbols[n],a=this.market(r),o=this.safeValue(s,a.id,{});i[r]=this.parseTradingFee(o,a)}return i}parseTradingFee(e,t=void 0){const s=this.safeValue(e,"name"),i=this.safeSymbol(s,t);return{info:e,symbol:i,maker:this.safeNumber(e,"maker_fee_rate"),taker:this.safeNumber(e,"taker_fee_rate"),percentage:!0,tierBased:!0}}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={market:r.id,type:this.timeframes[t]};i!==void 0&&(a.limit=i);const o=r.swap?"perpetualPublicGetMarketKline":"publicGetMarketKline",d=await this[o](this.extend(a,n)),c=this.safeValue(d,"data",[]);return this.parseOHLCVs(c,r,t,s,i)}async fetchMarginBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"symbol");let s=this.safeString(e,"market"),i;if(t!==void 0)i=this.market(t),s=i.id;else if(s===void 0)throw new vs(this.id+" fetchMarginBalance() fetching a margin account requires a market parameter or a symbol parameter");e=this.omit(e,["symbol","market"]);const n={market:s},r=await this.privateGetMarginAccount(this.extend(n,e)),a={info:r},o=this.safeValue(r,"data",{}),d=this.safeValue(o,"can_transfer",{}),c=this.safeValue(o,"balance",{}),u=this.account(),h=this.safeString(o,"sell_asset_type"),l=this.safeCurrencyCode(h);u.free=this.safeString(d,"sell_type"),u.total=this.safeString(c,"sell_type"),a[l]=u;const p=this.account(),m=this.safeString(o,"buy_asset_type"),g=this.safeCurrencyCode(m);return p.free=this.safeString(d,"buy_type"),p.total=this.safeString(c,"buy_type"),a[g]=p,this.safeBalance(a)}async fetchSpotBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalanceInfo(e),s={info:t},i=this.safeValue(t,"data",{}),n=Object.keys(i);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeCurrencyCode(a),d=this.safeValue(i,a,{}),c=this.account();c.free=this.safeString(d,"available"),c.used=this.safeString(d,"frozen"),s[o]=c}return this.safeBalance(s)}async fetchSwapBalance(e={}){await this.loadMarkets();const t=await this.perpetualPrivateGetAssetQuery(e),s={info:t},i=this.safeValue(t,"data",{}),n=Object.keys(i);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeCurrencyCode(a),d=this.safeValue(i,a,{}),c=this.account();c.free=this.safeString(d,"available"),c.used=this.safeString(d,"frozen"),c.total=this.safeString(d,"balance_total"),s[o]=c}return this.safeBalance(s)}async fetchBalance(e={}){const t=this.safeString(e,"type","main");return e=this.omit(e,"type"),t==="margin"?await this.fetchMarginBalance(e):t==="swap"?await this.fetchSwapBalance(e):await this.fetchSpotBalance(e)}parseOrderStatus(e){const t={not_deal:"open",part_deal:"open",done:"closed",cancel:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeTimestamp(e,"create_time"),i=this.safeString(e,"price"),n=this.safeString(e,"deal_money"),r=this.safeString(e,"amount"),a=this.safeString(e,"deal_amount"),o=this.safeString(e,"avg_price"),d=this.safeString(e,"left"),c=this.safeString(e,"market");t=this.safeMarket(c,t);const u=this.safeString(e,"fee_asset");let h=this.safeCurrencyCode(u);h===void 0&&(h=t.quote);const l=this.parseOrderStatus(this.safeString(e,"status"));let p=this.safeInteger(e,"side");p===1?p="sell":p===2?p="buy":p=this.safeString(e,"type");let m=this.safeString(e,"order_type");return m===void 0&&(m=this.safeInteger(e,"type"),m===1?m="limit":m===2&&(m="market")),this.safeOrder({id:this.safeString2(e,"id","order_id"),clientOrderId:void 0,datetime:this.iso8601(s),timestamp:s,lastTradeTimestamp:this.safeTimestamp(e,"update_time"),status:l,symbol:t.symbol,type:m,timeInForce:void 0,postOnly:void 0,reduceOnly:void 0,side:p,price:i,stopPrice:this.safeString(e,"stop_price"),cost:n,average:o,amount:r,filled:a,remaining:d,trades:void 0,fee:{currency:h,cost:this.safeString(e,"deal_fee")},info:e},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=a.swap,d=this.safeValue2(r,"stopPrice","triggerPrice"),c=this.safeValue(r,"stopLossPrice"),u=this.safeValue(r,"takeProfitPrice"),h=this.safeString(r,"option"),l=t==="market",p=this.isPostOnly(l,h==="MAKER_ONLY",r),m=this.safeInteger2(r,"position_id","positionId");let g=this.safeString(r,"timeInForce");const y=this.safeValue(r,"reduceOnly");if(y!==void 0&&a.type!=="swap")throw new No(this.id+" createOrder() does not support reduceOnly for "+a.type+" orders, reduceOnly orders are supported for swap markets only");let b;const w={market:a.id};if(o)if(c||u){if(w.stop_type=this.safeInteger(r,"stop_type",1),m===void 0)throw new vs(this.id+" createOrder() requires a position_id parameter for stop loss and take profit orders");w.position_id=m,c?(b="perpetualPrivatePostPositionStopLoss",w.stop_loss_price=this.priceToPrecision(e,c)):u&&(b="perpetualPrivatePostPositionTakeProfit",w.take_profit_price=this.priceToPrecision(e,u))}else b="perpetualPrivatePostOrderPut"+this.capitalize(t),s=s==="buy"?2:1,d!==void 0&&(w.stop_price=this.priceToPrecision(e,d),w.stop_type=this.safeInteger(r,"stop_type",1),w.amount=this.amountToPrecision(e,i),w.side=s,t==="limit"?(b="perpetualPrivatePostOrderPutStopLimit",w.price=this.priceToPrecision(e,n)):t==="market"&&(b="perpetualPrivatePostOrderPutStopMarket"),w.amount=this.amountToPrecision(e,i)),(t!=="market"||d!==void 0)&&(p?w.option=1:g!==void 0&&(g==="IOC"?g=2:g==="FOK"?g=3:g=1,w.effect_type=g)),t==="limit"&&d===void 0?(y?(b="perpetualPrivatePostOrderCloseLimit",w.position_id=m):w.side=s,w.price=this.priceToPrecision(e,n),w.amount=this.amountToPrecision(e,i)):t==="market"&&d===void 0&&(y?(b="perpetualPrivatePostOrderCloseMarket",w.position_id=m):(w.side=s,w.amount=this.amountToPrecision(e,i)));else{if(b="privatePostOrder"+this.capitalize(t),w.type=s,t==="market"&&s==="buy")if(this.options.createMarketBuyOrderRequiresPrice){if(n===void 0)throw new No(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)");{const _=this.amountToPrecision(e,i),N=this.priceToPrecision(e,n),M=vk.stringMul(_,N),x=this.parseNumber(M);w.amount=this.costToPrecision(e,x)}}else w.amount=this.costToPrecision(e,i);else w.amount=this.amountToPrecision(e,i);if((t==="limit"||t==="ioc")&&(w.price=this.priceToPrecision(e,n)),d!==void 0&&(w.stop_price=this.priceToPrecision(e,d),t==="limit"?b="privatePostOrderStopLimit":t==="market"&&(b="privatePostOrderStopMarket")),(t!=="market"||d!==void 0)&&(g!==void 0||p)){if((p||g!=="IOC")&&t==="limit"&&d!==void 0)throw new No(this.id+" createOrder() only supports the IOC option for stop-limit orders");p?w.option="MAKER_ONLY":g!==void 0&&(w.option=g)}}const S=this.safeInteger(r,"account_id");if(this.safeString(this.options,"defaultType")==="margin"){if(S===void 0)throw new Ur(this.id+" createOrder() requires an account_id parameter for margin orders");w.account_id=S}r=this.omit(r,["reduceOnly","positionId","timeInForce","postOnly","stopPrice","triggerPrice","stopLossPrice","takeProfitPrice"]);const T=await this[b](this.extend(w,r)),I=this.safeValue(T,"data");return this.parseOrder(I,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(t),n=this.safeValue(s,"stop"),r=i.swap,a={market:i.id},o=r?"order_id":"id";a[o]=e;let d=r?"perpetualPrivatePostOrderCancel":"privateDeleteOrderPending";n&&(r?d="perpetualPrivatePostOrderCancelStop":d="privateDeleteOrderStopPendingId");const c=this.safeInteger(s,"account_id");if(this.safeString(this.options,"defaultType")==="margin"){if(c===void 0)throw new Ur(this.id+" cancelOrder() requires an account_id parameter for margin orders");a.account_id=c}const h=this.omit(s,["stop","account_id"]),l=await this[d](this.extend(a,h)),p=this.safeValue(l,"data");return this.parseOrder(p,i)}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new vs(this.id+" cancellAllOrders() requires a symbol argument");await this.loadMarkets();const s=this.market(e),i=s.id,n=this.safeInteger(t,"account_id",0),r={market:i},a=s.swap,o=this.safeValue(t,"stop");let d;return a?(d="perpetualPrivatePostOrderCancelAll",o&&(d="perpetualPrivatePostOrderCancelStopAll")):(d="privateDeleteOrderPending",o&&(d="privateDeleteOrderStopPending"),r.account_id=n),t=this.omit(t,["stop","account_id"]),await this[d](this.extend(r,t))}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new vs(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=i.swap,r=this.safeValue(s,"stop"),a={market:i.id},o=n?"order_id":"id";a[o]=e;let d;n?d=r?"perpetualPrivateGetOrderStopStatus":"perpetualPrivateGetOrderStatus":d="privateGetOrderStatus",s=this.omit(s,"stop");const c=await this[d](this.extend(a,s)),u=this.safeValue(c,"data");return this.parseOrder(u,i)}async fetchOrdersByStatus(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets(),i=i===void 0?100:i;const r={limit:i},a=this.safeValue(n,"stop"),o=this.safeInteger(n,"side");n=this.omit(n,"stop");let d;t!==void 0&&(d=this.market(t),r.market=d.id);const[c,u]=this.handleMarketTypeAndParams("fetchOrdersByStatus",d,n);let h;if(c==="swap"){if(t===void 0)throw new vs(this.id+" fetchOrdersByStatus() requires a symbol argument for swap markets");h="perpetualPrivateGetOrder"+this.capitalize(e),a&&(h="perpetualPrivateGetOrderStopPending"),o!==void 0?r.side=o:r.side=0,r.offset=0}else h="privateGetOrder"+this.capitalize(e),a&&(h="privateGetOrderStop"+this.capitalize(e)),r.page=1;const l=this.safeInteger(n,"account_id");if(this.safeString(this.options,"defaultType")==="margin"){if(l===void 0)throw new Ur(this.id+" fetchOpenOrders() and fetchClosedOrders() require an account_id parameter for margin orders");r.account_id=l}n=this.omit(u,"account_id");const m=await this[h](this.extend(r,n)),g=c==="swap"?"records":"data",y=this.safeValue(m,"data"),b=this.safeValue(y,g,[]);return this.parseOrders(b,d,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("pending",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("finished",e,t,s,i)}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={coin_type:s.id};if("network"in t){const a=this.safeString(t,"network");t=this.omit(t,"network"),i.smart_contract_name=a}const n=await this.privatePutBalanceDepositAddressCoinType(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseDepositAddress(r,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={coin_type:s.id},n=this.safeValue(s,"networks",{}),r=this.safeString(t,"network");t=this.omit(t,"network");const o=Object.keys(n).length;if(n!==void 0&&o>1){if(r===void 0)throw new vs(this.id+" fetchDepositAddress() "+e+" requires a network parameter");if(!(r in n))throw new r0(this.id+" fetchDepositAddress() "+r+" network not supported for "+e)}r!==void 0&&(i.smart_contract_name=r);const d=await this.privateGetBalanceDepositAddressCoinType(this.extend(i,t)),c=this.safeValue(d,"data",{}),u=this.parseDepositAddress(c,s),h=this.safeValue(this.options,"fetchDepositAddress",{});return this.safeValue(h,"fillResponseFromRequest",!0)&&(u.network=this.safeNetworkCode(r,s)),u}safeNetwork(e,t=void 0){const s=this.safeValue(t,"networks",{}),i=Object.keys(s);return e===void 0&&i.length===1?s[i[0]]:{id:e,network:e===void 0?void 0:e.toUpperCase()}}safeNetworkCode(e,t=void 0){return this.safeNetwork(e,t).network}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"coin_address");return{info:e,currency:this.safeCurrencyCode(void 0,t),address:s,tag:void 0,network:void 0}}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;s===void 0&&(s=100);const r={limit:s,offset:0};e!==void 0&&(n=this.market(e),r.market=n.id);let a;if([a,i]=this.handleMarketTypeAndParams("fetchMyTrades",n,i),a!=="spot"&&e===void 0)throw new vs(this.id+" fetchMyTrades() requires a symbol argument for non-spot markets");const o=a==="swap";let d;if(o){d="perpetualPublicGetMarketUserDeals";const g=this.safeInteger(i,"side");if(g===void 0)throw new vs(this.id+" fetchMyTrades() requires a side parameter for swap markets");t!==void 0&&(r.start_time=t),r.side=g,i=this.omit(i,"side")}else d="privateGetOrderUserDeals",r.page=1;const c=this.safeInteger(i,"account_id");if(this.safeString(this.options,"defaultType")==="margin"){if(c===void 0)throw new Ur(this.id+" fetchMyTrades() requires an account_id parameter for margin trades");r.account_id=c,i=this.omit(i,"account_id")}const h=await this[d](this.extend(r,i)),l=o?"records":"data",p=this.safeValue(h,"data"),m=this.safeValue(p,l,[]);return this.parseTrades(m,n,t,s)}async fetchPositions(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={};let i;if(e!==void 0){let o;if(Array.isArray(e)){if(e.length>1)throw new Ur(this.id+" fetchPositions() symbols argument cannot contain more than 1 symbol");o=e[0]}else o=e;i=this.market(o),s.market=i.id}const n=await this.perpetualPrivateGetPositionPending(this.extend(s,t)),r=this.safeValue(n,"data",[]),a=[];for(let o=0;o<r.length;o++)a.push(this.parsePosition(r[o],i));return this.filterByArray(a,"symbol",e,!1)}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id},n=await this.perpetualPrivateGetPositionPending(this.extend(i,t)),r=this.safeValue(n,"data",[]);return this.parsePosition(r[0],s)}parsePosition(e,t=void 0){const s=this.safeString(e,"market");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeInteger(e,"position_id"),a=this.safeInteger(e,"type")===1?"isolated":"cross",o=this.safeString(e,"liq_price"),d=this.safeString(e,"open_price"),c=this.safeString(e,"profit_unreal"),u=this.safeString(e,"amount"),l=this.safeInteger(e,"side")===1?"short":"long",p=this.safeTimestamp(e,"update_time"),m=this.safeString(e,"mainten_margin_amount"),g=this.safeString(e,"mainten_margin"),y=this.safeString(e,"margin_amount"),b=this.safeNumber(e,"leverage");return{info:e,id:n,symbol:i,notional:void 0,marginMode:a,liquidationPrice:o,entryPrice:d,unrealizedPnl:c,percentage:void 0,contracts:void 0,contractSize:u,markPrice:void 0,side:l,hedged:void 0,timestamp:p,datetime:this.iso8601(p),maintenanceMargin:m,maintenanceMarginPercentage:g,collateral:y,initialMargin:void 0,initialMarginPercentage:void 0,leverage:b,marginRatio:void 0}}async setMarginMode(e,t=void 0,s={}){if(t===void 0)throw new vs(this.id+" setMarginMode() requires a symbol argument");if(e=e.toLowerCase(),e!=="isolated"&&e!=="cross")throw new Ur(this.id+" setMarginMode() marginMode argument should be isolated or cross");await this.loadMarkets();const i=this.market(t);if(i.type!=="swap")throw new a0(this.id+" setMarginMode() supports swap contracts only");let n;e==="isolated"?n=1:e==="cross"&&(n=2);const r=this.safeInteger(s,"leverage"),a=this.safeInteger(i.limits.leverage,"max",100),o=this.safeInteger(s,"position_type",n);if(r===void 0)throw new vs(this.id+" setMarginMode() requires a leverage parameter");if(o===void 0)throw new vs(this.id+" setMarginMode() requires a position_type parameter that will transfer margin to the specified trading pair");if(r<3||r>a)throw new Ur(this.id+" setMarginMode() leverage should be between 3 and "+a.toString()+" for "+t);const d={market:i.id,leverage:r.toString(),position_type:o};return await this.perpetualPrivatePostMarketAdjustLeverage(this.extend(d,s))}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new vs(this.id+" setLeverage() requires a symbol argument");await this.loadMarkets();const i=this.safeString2(this.options,"defaultMarginMode","marginMode");let n;i==="isolated"?n=1:i==="cross"&&(n=2);const r=this.safeInteger(s,"position_type",n);if(r===void 0)throw new vs(this.id+" setLeverage() requires a position_type parameter that will transfer margin to the specified trading pair");const a=this.market(t),o=this.safeInteger(a.limits.leverage,"max",100);if(a.type!=="swap")throw new a0(this.id+" setLeverage() supports swap contracts only");if(e<3||e>o)throw new Ur(this.id+" setLeverage() leverage should be between 3 and "+o.toString()+" for "+t);const d={market:a.id,leverage:e.toString(),position_type:r};return await this.perpetualPrivatePostMarketAdjustLeverage(this.extend(d,s))}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const s=await this.perpetualPublicGetMarketLimitConfig(t),i=this.safeValue(s,"data",{});return this.parseLeverageTiers(i,e,void 0)}parseLeverageTiers(e,t=void 0,s=void 0){const i={},n=Object.keys(e);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeMarket(a),d=this.safeString(o,"symbol");let c=0;t!==void 0&&(c=t.length),d!==void 0&&(c===0||this.inArray(t,d))&&(i[d]=this.parseMarketLeverageTiers(e[a],o))}return i}parseMarketLeverageTiers(e,t=void 0){const s=[];let i=0;for(let n=0;n<e.length;n++){const r=e[n],a=this.safeNumber(r,0);s.push({tier:n+1,currency:t.linear?t.base:t.quote,minNotional:i,maxNotional:a,maintenanceMarginRate:this.safeNumber(r,2),maxLeverage:this.safeInteger(r,1),info:r}),i=a}return s}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets();const n=this.market(e),r={market:n.id,amount:this.amountToPrecision(e,t),type:s},a=await this.perpetualPrivatePostPositionAdjustMargin(this.extend(r,i)),o=this.safeString(a,"message"),d=s===1?"add":"reduce";return this.extend(this.parseMarginModification(a,n),{amount:this.parseNumber(t),type:d,status:o})}parseMarginModification(e,t=void 0){return{info:e,type:void 0,amount:void 0,code:t.quote,symbol:this.safeSymbol(void 0,t),status:void 0}}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,1,s)}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,2,s)}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new vs(this.id+" fetchFundingHistory() requires a symbol argument");s=s===void 0?100:s,await this.loadMarkets();const r={market:this.market(e).id,limit:s};t!==void 0&&(r.start_time=t);const a=await this.perpetualPrivateGetPositionFunding(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"records",[]),c=[];for(let u=0;u<d.length;u++){const h=d[u],l=this.safeTimestamp(h,"time"),p=this.safeString(h,"asset"),m=this.safeCurrencyCode(p);c.push({info:h,symbol:e,code:m,timestamp:l,datetime:this.iso8601(l),id:this.safeNumber(h,"position_id"),amount:this.safeNumber(h,"funding")})}return c}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new a0(this.id+" fetchFundingRate() supports swap contracts only");const i={market:s.id},n=await this.perpetualPublicGetMarketTicker(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"ticker",{});return this.parseFundingRate(a,s)}parseFundingRate(e,t=void 0){return{info:e,symbol:this.safeSymbol(void 0,t),markPrice:this.safeString(e,"sign_price"),indexPrice:this.safeString(e,"index_price"),interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeString(e,"funding_rate_next"),fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:this.safeString(e,"funding_rate_predict"),nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:this.safeString(e,"funding_rate_last"),previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e);i&&(s=s+":"+i);const a={coin_type:r.id,coin_address:s,actual_amount:parseFloat(t),transfer_method:"onchain"},o=await this.privatePostBalanceCoinWithdraw(this.extend(a,n)),d=this.safeValue(o,"data",{});return this.parseTransaction(d,r)}parseTransactionStatus(e){const t={audit:"pending",pass:"pending",processing:"pending",confirming:"pending",not_pass:"failed",cancel:"canceled",finish:"ok",fail:"failed"};return this.safeString(t,e,e)}async fetchFundingRateHistory(e=void 0,t=void 0,s=100,i={}){if(e===void 0)throw new vs(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={market:n.id,limit:s,offset:0};t!==void 0&&(r.start_time=t);const a=await this.perpetualPublicGetMarketFundingHistory(this.extend(r,i)),o=this.safeValue(a,"data"),d=this.safeValue(o,"records",[]),c=[];for(let h=0;h<d.length;h++){const l=d[h],p=this.safeString(l,"market"),m=this.safeSymbol(p),g=this.safeTimestamp(l,"time");c.push({info:l,symbol:m,fundingRate:this.safeString(l,"funding_rate"),timestamp:g,datetime:this.iso8601(g)})}const u=this.sortBy(c,"timestamp");return this.filterBySymbolSinceLimit(u,n.symbol,t,s)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"coin_withdraw_id","coin_deposit_id"),i=this.safeString(e,"coin_address");let n=this.safeString(e,"remark");n!==void 0&&n.length<1&&(n=void 0);let r=this.safeValue(e,"tx_id");r!==void 0&&r.length<1&&(r=void 0);const a=this.safeString(e,"coin_type"),o=this.safeCurrencyCode(a,t),d=this.safeTimestamp(e,"create_time"),c="coin_withdraw_id"in e?"withdraw":"deposit",u=this.parseTransactionStatus(this.safeString(e,"status"));let h=this.safeNumber(e,"amount"),l=this.safeNumber(e,"tx_fee");c==="deposit"&&(l=0);const p={cost:l,currency:o};return h!==void 0&&(h=h-l),{info:e,id:s,txid:r,timestamp:d,datetime:this.iso8601(d),network:void 0,address:i,addressTo:void 0,addressFrom:void 0,tag:n,tagTo:void 0,tagFrom:void 0,type:c,amount:h,currency:o,status:u,updated:void 0,fee:p}}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.currencyToPrecision(e,t),o={amount:a,coin_type:r.id};let d="privatePostContractBalanceTransfer";if(s==="spot"&&i==="swap")o.transfer_side="in";else if(s==="swap"&&i==="spot")o.transfer_side="out";else{const u=this.safeValue(this.options,"accountsById",{}),h=this.safeString(u,s,s),l=this.safeString(u,i,i);o.from_account=parseInt(h),o.to_account=parseInt(l),d="privatePostMarginTransfer"}const c=await this[d](this.extend(o,n));return this.extend(this.parseTransfer(c,r),{amount:this.parseNumber(a),fromAccount:s,toAccount:i})}parseTransferStatus(e){const t={0:"ok",SUCCESS:"ok"};return this.safeString(t,e,e)}parseTransfer(e,t=void 0){const s=this.safeTimestamp(e,"created_at"),i=this.safeString(e,"transfer_type");let n,r;i==="transfer_out"?(n="swap",r="spot"):i==="transfer_in"?(n="spot",r="swap"):i==="IN"?(n="spot",r="margin"):i==="OUT"&&(n="margin",r="spot");const a=this.safeString(e,"asset"),o=this.safeCurrencyCode(a,t);return{id:this.safeInteger(e,"id"),timestamp:s,datetime:this.iso8601(s),currency:o,amount:this.safeNumber(e,"amount"),fromAccount:n,toAccount:r,status:this.parseTransferStatus(this.safeString2(e,"code","status"))}}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={page:1,limit:s},a=this.safeInteger(i,"page");a!==void 0&&(r.page=a),e!==void 0&&(n=this.safeCurrencyCode(e),r.asset=n.id),t!==void 0&&(r.start_time=t),i=this.omit(i,"page");const d=this.safeString(this.options,"defaultType")==="margin"?"privateGetMarginTransferHistory":"privateGetContractTransferHistory",c=await this[d](this.extend(r,i)),u=this.safeValue(c,"data",{}),h=this.safeValue(u,"records",[]);return this.parseTransfers(h,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new vs(this.id+" fetchWithdrawals() requires a currency code argument");await this.loadMarkets();const n=this.currency(e),r={coin_type:n.id};s!==void 0&&(r.Limit=s);const a=await this.privateGetBalanceCoinWithdraw(this.extend(r,i));let o=this.safeValue(a,"data");return Array.isArray(o)||(o=this.safeValue(o,"data",[])),this.parseTransactions(o,n,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new vs(this.id+" fetchDeposits() requires a currency code argument");await this.loadMarkets();const n=this.currency(e),r={coin_type:n.id};s!==void 0&&(r.Limit=s);const a=await this.privateGetBalanceCoinDeposit(this.extend(r,i));let o=this.safeValue(a,"data");return Array.isArray(o)||(o=this.safeValue(o,"data",[])),this.parseTransactions(o,n,t,s)}parseBorrowRate(e,t=void 0){const s=this.milliseconds(),i=this.safeValue(e,t,{});return{currency:this.safeCurrencyCode(t),rate:this.safeNumber(i,"day_rate"),period:864e5,timestamp:s,datetime:this.iso8601(s),info:e}}async fetchBorrowRate(e,t={}){await this.loadMarkets();let s;if(e in this.markets)s=this.market(e);else{const a=this.safeString(this.options,"defaultSettle","USDT");s=this.market(e+"/"+a)}const i={market:s.id},n=await this.privateGetMarginConfig(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseBorrowRate(r,s.base)}async fetchBorrowRates(e={}){await this.loadMarkets();const t=await this.privateGetMarginConfig(e),s=this.milliseconds(),i=this.safeValue(t,"data",{}),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"market"),d=this.safeMarket(o),c=this.safeValue(a,d.base);n.push({currency:d.base,rate:this.safeNumber(c,"day_rate"),period:864e5,timestamp:s,datetime:this.iso8601(s),info:a})}return n}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a;t!==void 0&&(a=this.market(t),r.market=a.id),i!==void 0&&(r.limit=i);const o=await this.privateGetMarginLoanHistory(this.extend(r,n)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"data",[]),u=this.parseBorrowInterests(c,a);return this.filterByCurrencySinceLimit(u,e,s,i)}parseBorrowInterest(e,t=void 0){const s=this.safeString(e,"market_type");t=this.safeMarket(s,t);const i=this.safeString(t,"symbol"),n=this.safeTimestamp(e,"expire_time"),r=this.safeString(e,"unflat_amount"),a=this.safeString(e,"loan_amount");let o=vk.stringSub(r,a);return r==="0"&&(o=void 0),{account:void 0,symbol:i,marginMode:"isolated",marginType:void 0,currency:this.safeCurrencyCode(this.safeString(e,"coin_type")),interest:this.parseNumber(o),interestRate:this.safeNumber(e,"day_rate"),amountBorrowed:this.parseNumber(a),timestamp:n,datetime:this.iso8601(n),info:e}}async borrowMargin(e,t,s=void 0,i={}){if(s===void 0)throw new vs(this.id+" borrowMargin() requires a symbol argument");await this.loadMarkets();const n=this.market(s),r=this.currency(e),a={market:n.id,coin_type:r.id,amount:this.currencyToPrecision(e,t)},o=await this.privatePostMarginLoan(this.extend(a,i)),d=this.safeValue(o,"data",{}),c=this.parseMarginLoan(d,r);return this.extend(c,{amount:t,symbol:s})}async repayMargin(e,t,s=void 0,i={}){if(s===void 0)throw new vs(this.id+" repayMargin() requires a symbol argument");await this.loadMarkets();const n=this.market(s),r=this.currency(e),a={market:n.id,coin_type:r.id,amount:this.currencyToPrecision(e,t)},o=this.safeInteger(i,"loan_id");o!==void 0&&(a.loan_id=o);const d=await this.privatePostMarginFlat(this.extend(a,i)),c=this.parseMarginLoan(d,r);return this.extend(c,{amount:t,symbol:s})}parseMarginLoan(e,t=void 0){return{id:this.safeInteger(e,"loan_id"),currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){e=this.implodeParams(e,i);let a=this.urls.api[t]+"/"+this.version+"/"+e,o=this.omit(i,this.extractParams(e));const d=this.nonce().toString();if(t==="perpetualPrivate"||a==="https://api.coinex.com/perpetual/v1/market/user_deals"){this.checkRequiredCredentials(),o=this.extend({access_id:this.apiKey,timestamp:d},o),o=this.keysort(o);const c=this.rawencode(o);n={Authorization:this.hash(this.encode(c+"&secret_key="+this.secret),"sha256").toLowerCase(),AccessId:this.apiKey},s==="GET"||s==="PUT"?a+="?"+c:(n["Content-Type"]="application/x-www-form-urlencoded",r=c)}else if(t==="public"||t==="perpetualPublic")Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials(),o=this.extend({access_id:this.apiKey,tonce:d},o),o=this.keysort(o);const c=this.rawencode(o);n={Authorization:this.hash(this.encode(c+"&secret_key="+this.secret)).toUpperCase(),"Content-Type":"application/json"},s==="GET"||s==="DELETE"||s==="PUT"?a+="?"+c:r=this.json(o)}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"code"),u=this.safeValue(a,"data"),h=this.safeString(a,"message");if(c!=="0"||h!=="Success"&&h!=="Succeeded"&&h!=="Ok"&&!u){const l={23:Y8,24:o0,25:o0,34:o0,35:Q8,36:Z8,213:z8,107:K8,600:X8,601:No,602:No,606:No},p=this.safeValue(l,c,r0);throw new p(a.message)}}};const eR=me,{ExchangeError:tR,AuthenticationError:sR,RateLimitExceeded:iR,ArgumentsRequired:nR}=oe,{TICK_SIZE:rR}=pe,Tk=ke;var aR=class extends eR{describe(){return this.deepExtend(super.describe(),{id:"coinfalcon",name:"CoinFalcon",countries:["GB"],rateLimit:1e3,version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradinFee:!1,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/41822275-ed982188-77f5-11e8-92bb-496bcd14ca52.jpg",api:{rest:"https://coinfalcon.com"},www:"https://coinfalcon.com",doc:"https://docs.coinfalcon.com",fees:"https://coinfalcon.com/fees",referral:"https://coinfalcon.com/?ref=CFJSVGTUPASB"},api:{public:{get:["markets","markets/{market}","markets/{market}/orders","markets/{market}/trades"]},private:{get:["user/accounts","user/orders","user/orders/{id}","user/orders/{id}/trades","user/trades","user/fees","account/withdrawals/{id}","account/withdrawals","account/deposit/{id}","account/deposits","account/deposit_address"],post:["user/orders","account/withdraw"],delete:["user/orders/{id}","account/withdrawals/{id}"]}},fees:{trading:{tierBased:!0,maker:0,taker:.002}},precision:{amount:this.parseNumber("0.00000001"),price:this.parseNumber("0.00000001")},precisionMode:rR})}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],[a,o]=r.name.split("-"),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o);i.push({id:r.name,symbol:d+"/"+c,base:d,quote:c,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"size_precision"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"price_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"minPrice"),max:void 0},price:{min:this.safeNumber(r,"minVolume"),max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}parseTicker(e,t=void 0){const s=this.safeString(e,"name");t=this.safeMarket(s,t,"-");const i=this.milliseconds(),n=this.safeString(e,"last_price");return this.safeTicker({symbol:t.symbol,timestamp:i,datetime:this.iso8601(i),high:void 0,low:void 0,bid:this.safeString(e,"highest_bid"),bidVolume:void 0,ask:this.safeString(e,"lowest_ask"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:this.safeString(e,"change_in_24h"),percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:this.safeString(e,"volume"),info:e},t)}async fetchTicker(e,t={}){return await this.loadMarkets(),(await this.fetchTickers([e],t))[e]}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetMarkets(t),i=this.safeValue(s,"data",[]),n={};for(let r=0;r<i.length;r++){const a=this.parseTicker(i[r]),o=a.symbol;n[o]=a}return this.filterByArray(n,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={market:i.id,level:"3"},r=await this.publicGetMarketsMarketOrders(this.extend(n,s)),a=this.safeValue(r,"data",{});return this.parseOrderBook(a,i.symbol,void 0,"bids","asks","price","size")}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"created_at")),i=this.safeString(e,"price"),n=this.safeString(e,"size"),r=t.symbol,a=this.safeString(e,"id"),o=this.safeString(e,"side"),d=this.safeString(e,"order_id");let c;const u=this.safeString(e,"fee");if(u!==void 0){const h=this.safeString(e,"fee_currency_code");c={cost:u,currency:this.safeCurrencyCode(h)}}return this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:r,id:a,order:d,type:void 0,side:o,takerOrMaker:void 0,price:i,amount:n,cost:void 0,fee:c},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new nR(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={market:n.id};t!==void 0&&(r.start_time=this.iso8601(t)),s!==void 0&&(r.limit=s);const a=await this.privateGetUserTrades(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market:n.id};t!==void 0&&(r.since=this.iso8601(t));const a=await this.publicGetMarketsMarketTrades(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetUserFees(e),s=this.safeValue(t,"data",{}),i=this.safeString(s,"maker_fee"),n=this.safeString(s,"taker_fee"),r=this.parseNumber(Tk.stringDiv(i,"100")),a=this.parseNumber(Tk.stringDiv(n,"100")),o={};for(let d=0;d<this.symbols.length;d++){const c=this.symbols[d];o[c]={info:t,symbol:c,maker:r,taker:a,percentage:!0,tierBased:!0}}return o}parseBalance(e){const t={info:e},s=this.safeValue(e,"data",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeString(n,"currency_code"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(n,"available_balance"),o.used=this.safeString(n,"hold_balance"),o.total=this.safeString(n,"balance"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetUserAccounts(e);return this.parseBalance(t)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"tag");return this.checkAddress(s),{currency:this.safeCurrencyCode(void 0,t),address:s,tag:i,network:void 0,info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.safeCurrency(e),i={currency:this.safeStringLower(s,"id")},n=await this.privateGetAccountDepositAddress(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseDepositAddress(r,s)}parseOrderStatus(e){const t={fulfilled:"closed",canceled:"canceled",pending:"open",open:"open",partially_filled:"open"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeSymbol(s,t,"-"),n=this.parse8601(this.safeString(e,"created_at")),r=this.safeString(e,"price"),a=this.safeString(e,"size"),o=this.safeString(e,"size_filled"),d=this.parseOrderStatus(this.safeString(e,"status"));let c=this.safeString(e,"operation_type");c!==void 0&&(c=c.split("_"),c=c[0]);const u=this.safeString(e,"order_type"),h=this.safeValue(e,"post_only");return this.safeOrder({id:this.safeString(e,"id"),clientOrderId:void 0,datetime:this.iso8601(n),timestamp:n,status:d,symbol:i,type:c,timeInForce:void 0,postOnly:h,side:u,price:r,stopPrice:void 0,cost:void 0,amount:a,filled:o,remaining:void 0,trades:void 0,fee:void 0,info:e,lastTradeTimestamp:void 0,average:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={market:a.id,size:this.amountToPrecision(e,i),order_type:s};t==="limit"&&(n=this.priceToPrecision(e,n),o.price=n.toString()),o.operation_type=t+"_order";const d=await this.privatePostUserOrders(this.extend(o,r)),c=this.safeValue(d,"data",{});return this.parseOrder(c,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateDeleteUserOrdersId(this.extend(i,s)),r=this.market(t),a=this.safeValue(n,"data",{});return this.parseOrder(a,r)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetUserOrdersId(this.extend(i,s)),r=this.safeValue(n,"data",{});return this.parseOrder(r)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.market=r.id),t!==void 0&&(n.since_time=this.iso8601(t));const a=await this.privateGetUserOrders(this.extend(n,i)),o=this.safeValue(a,"data",[]),d=this.filterByArray(o,"status",["pending","open","partially_filled"],!1);return this.parseOrders(d,r,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=this.safeStringLower(r,"id")),t!==void 0&&(n.since_time=this.iso8601(t));const a=await this.privateGetAccountDeposits(this.extend(n,i)),o=this.safeValue(a,"data",[]);return o.reverse(),this.parseTransactions(o,r,void 0,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=this.safeStringLower(r,"id")),t!==void 0&&(n.since_time=this.iso8601(t));const a=await this.privateGetAccountWithdrawals(this.extend(n,i)),o=this.safeValue(a,"data",[]);return o.reverse(),this.parseTransactions(o,r,void 0,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency:this.safeStringLower(r,"id"),address:s,amount:t};i!==void 0&&(a.tag=i);const o=await this.privatePostAccountWithdraw(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseTransaction(d,r)}parseTransactionStatus(e){const t={completed:"ok",denied:"failed",approval_pending:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"address"),n=this.safeString(e,"tag"),r=this.safeString(e,"txid"),a=this.safeString(e,"currency_code"),o=this.safeCurrencyCode(a,t);let d=this.safeString(e,"type");d==="withdraw"&&(d="withdrawal");const c=this.parseTransactionStatus(this.safeString(e,"status")),u=this.safeString(e,"amount"),h=this.parseNumber(u),l=this.safeString(e,"fee");let p=0;return l!==void 0&&(p=this.parseNumber(l)),{info:e,id:s,txid:r,timestamp:void 0,datetime:void 0,network:void 0,address:i,addressTo:void 0,addressFrom:void 0,tag:n,tagTo:void 0,tagFrom:void 0,type:d,amount:h,currency:o,status:c,updated:void 0,fee:{currency:o,cost:p}}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/api/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials(),s==="GET"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):r=this.json(o);const c=this.seconds().toString();let u=[c,s,a].join("|");r&&(u+="|"+r);const h=this.hmac(this.encode(u),this.encode(this.secret));n={"CF-API-KEY":this.apiKey,"CF-API-TIMESTAMP":c,"CF-API-SIGNATURE":h,"Content-Type":"application/json"}}return{url:this.urls.api.rest+a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(e<400)return;const c=this.safeValue({401:sR,429:iR},e,tR);throw new c(r)}};const oR=me,{ExchangeError:xf,ArgumentsRequired:dR,InvalidOrder:d0,OrderNotFound:cR,RateLimitExceeded:uR,InsufficientFunds:fR,AuthenticationError:hR}=oe,{TICK_SIZE:lR}=pe,Ok=ke;var pR=class extends oR{describe(){return this.deepExtend(super.describe(),{id:"coinmate",name:"CoinMate",countries:["GB","CZ","EU"],rateLimit:1e3,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactions:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/51840849/87460806-1c9f3f00-c616-11ea-8c46-a77018a8f3f4.jpg",api:{rest:"https://coinmate.io/api"},www:"https://coinmate.io",fees:"https://coinmate.io/fees",doc:["https://coinmate.docs.apiary.io","https://coinmate.io/developers"],referral:"https://coinmate.io?referral=YTFkM1RsOWFObVpmY1ZjMGREQmpTRnBsWjJJNVp3PT0"},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},api:{public:{get:["orderBook","ticker","transactions","tradingPairs"]},private:{post:["balances","bitcoinCashWithdrawal","bitcoinCashDepositAddresses","bitcoinDepositAddresses","bitcoinWithdrawal","bitcoinWithdrawalFees","buyInstant","buyLimit","cancelOrder","cancelOrderWithInfo","createVoucher","dashDepositAddresses","dashWithdrawal","ethereumWithdrawal","ethereumDepositAddresses","litecoinWithdrawal","litecoinDepositAddresses","openOrders","order","orderHistory","orderById","pusherAuth","redeemVoucher","replaceByBuyLimit","replaceByBuyInstant","replaceBySellLimit","replaceBySellInstant","rippleDepositAddresses","rippleWithdrawal","sellInstant","sellLimit","transactionHistory","traderFees","tradeHistory","transfer","transferHistory","unconfirmedBitcoinDeposits","unconfirmedBitcoinCashDeposits","unconfirmedDashDeposits","unconfirmedEthereumDeposits","unconfirmedLitecoinDeposits","unconfirmedRippleDeposits"]}},fees:{trading:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.0012"),taker:this.parseNumber("0.0025"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.0035")],[this.parseNumber("10000"),this.parseNumber("0.0023")],[this.parseNumber("100000"),this.parseNumber("0.0021")],[this.parseNumber("250000"),this.parseNumber("0.0020")],[this.parseNumber("500000"),this.parseNumber("0.0015")],[this.parseNumber("1000000"),this.parseNumber("0.0013")],[this.parseNumber("3000000"),this.parseNumber("0.0010")],[this.parseNumber("15000000"),this.parseNumber("0.0005")]],maker:[[this.parseNumber("0"),this.parseNumber("0.003")],[this.parseNumber("10000"),this.parseNumber("0.0011")],[this.parseNumber("100000"),this.parseNumber("0.0010")],[this.parseNumber("250000"),this.parseNumber("0.0008")],[this.parseNumber("500000"),this.parseNumber("0.0005")],[this.parseNumber("1000000"),this.parseNumber("0.0003")],[this.parseNumber("3000000"),this.parseNumber("0.0002")],[this.parseNumber("15000000"),this.parseNumber("0")]]}}},options:{withdraw:{fillResponsefromRequest:!0,methods:{BTC:"privatePostBitcoinWithdrawal",LTC:"privatePostLitecoinWithdrawal",BCH:"privatePostBitcoinCashWithdrawal",ETH:"privatePostEthereumWithdrawal",XRP:"privatePostRippleWithdrawal",DASH:"privatePostDashWithdrawal",DAI:"privatePostDaiWithdrawal"}}},exceptions:{exact:{"No order with given ID":cR},broad:{"Not enough account balance available":fR,"Incorrect order ID":d0,"Minimum Order Size ":d0,"max allowed precision":d0,"TOO MANY REQUESTS":uR,"Access denied.":hR}},precisionMode:lR})}async fetchMarkets(e={}){const t=await this.publicGetTradingPairs(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"name"),o=this.safeString(r,"firstCurrency"),d=this.safeString(r,"secondCurrency"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d),h=c+"/"+u;i.push({id:a,symbol:h,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"lotDecimals"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"priceDecimals")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"minAmount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}parseBalance(e){const t=this.safeValue(e,"data",{}),s={info:e},i=Object.keys(t);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeCurrencyCode(r),o=this.safeValue(t,r),d=this.account();d.free=this.safeString(o,"available"),d.used=this.safeString(o,"reserved"),d.total=this.safeString(o,"balance"),s[a]=d}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalances(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={currencyPair:i.id,groupByPriceLimit:"False"},a=(await this.publicGetOrderBook(this.extend(n,s))).data,o=this.safeTimestamp(a,"timestamp");return this.parseOrderBook(a,i.symbol,o,"bids","asks","price","amount")}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={currencyPair:s.id},n=await this.publicGetTicker(this.extend(i,t)),r=this.safeValue(n,"data"),a=this.safeTimestamp(r,"timestamp"),o=this.safeNumber(r,"last");return{symbol:s.symbol,timestamp:a,datetime:this.iso8601(a),high:this.safeNumber(r,"high"),low:this.safeNumber(r,"low"),bid:this.safeNumber(r,"bid"),bidVolume:void 0,ask:this.safeNumber(r,"ask"),vwap:void 0,askVolume:void 0,open:void 0,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeNumber(r,"amount"),quoteVolume:void 0,info:r}}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={limit:1e3};if(s!==void 0&&(n.limit=s),t!==void 0&&(n.timestampFrom=t),e!==void 0){const o=this.currency(e);n.currency=o.id}const a=(await this.privatePostTransferHistory(this.extend(n,i))).data;return this.parseTransactions(a,void 0,t,s)}parseTransactionStatus(e){const t={COMPLETED:"ok",WAITING:"pending",SENT:"pending",CREATED:"pending",OK:"ok",NEW:"pending",CANCELED:"canceled"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeNumber(e,"amount"),n=this.safeNumber(e,"fee"),r=this.safeString(e,"txid"),a=this.safeString(e,"destination"),o=this.safeString(e,"destinationTag"),d=this.safeString(e,"amountCurrency"),c=this.safeCurrencyCode(d,t),u=this.safeStringLower(e,"transferType"),h=this.parseTransactionStatus(this.safeString(e,"transferStatus")),l=this.safeString2(e,"transactionId","id"),p=this.safeString(e,"walletType");return{id:l,timestamp:s,datetime:this.iso8601(s),currency:c,amount:i,type:u,txid:r,network:p,address:a,addressTo:void 0,addressFrom:void 0,tag:o,tagTo:void 0,tagFrom:void 0,status:h,fee:{cost:n,currency:c},info:e}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"withdraw",{}),o=this.safeValue(a,"methods",{}),d=this.safeString(o,e);if(d===void 0){const m=Object.keys(o);throw new xf(this.id+" withdraw() only allows withdrawing the following currencies: "+m.join(", "))}const c={amount:this.currencyToPrecision(e,t),address:s};i!==void 0&&(c.destinationTag=i);const u=await this[d](this.extend(c,n)),h=this.safeValue(u,"data"),l=this.parseTransaction(h,r);return this.safeValue(a,"fillResponseFromRequest",!0)&&(l.amount=t,l.currency=e,l.address=s,l.tag=i,l.type="withdrawal",l.status="pending"),l}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),s===void 0&&(s=1e3);const n={limit:s};if(e!==void 0){const o=this.market(e);n.currencyPair=o.id}t!==void 0&&(n.timestampFrom=t);const r=await this.privatePostTradeHistory(this.extend(n,i)),a=this.safeValue(r,"data",[]);return this.parseTrades(a,void 0,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"currencyPair");t=this.safeMarket(s,t,"_");const i=this.safeString(e,"price"),n=this.safeString(e,"amount"),r=this.safeStringLower2(e,"type","tradeType"),a=this.safeStringLower(e,"orderType"),o=this.safeString(e,"orderId"),d=this.safeString(e,"transactionId"),c=this.safeInteger2(e,"timestamp","createdTimestamp");let u;const h=this.safeString(e,"fee");h!==void 0&&(u={cost:h,currency:t.quote});let l=this.safeString(e,"feeType");return l=l==="MAKER"?"maker":"taker",this.safeTrade({id:d,info:e,timestamp:c,datetime:this.iso8601(c),symbol:t.symbol,type:a,side:r,order:o,takerOrMaker:l,price:i,amount:n,cost:void 0,fee:u},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={currencyPair:n.id,minutesIntoHistory:10},a=await this.publicGetTransactions(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={currencyPair:s.id},n=await this.privatePostTraderFees(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeString(r,"maker"),o=this.safeString(r,"taker"),d=this.parseNumber(Ok.stringDiv(a,"100")),c=this.parseNumber(Ok.stringDiv(o,"100"));return{info:r,symbol:s.symbol,maker:d,taker:c,percentage:!0,tierBased:!0}}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n=await this.privatePostOpenOrders(this.extend({},i)),r={status:"open"};return this.parseOrders(n.data,void 0,t,s,r)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new dR(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={currencyPair:n.id};s!==void 0&&(r.limit=s);const a=await this.privatePostOrderHistory(this.extend(r,i));return this.parseOrders(a.data,n,t,s)}parseOrderStatus(e){const t={FILLED:"closed",CANCELLED:"canceled",PARTIALLY_FILLED:"open",OPEN:"open"};return this.safeString(t,e,e)}parseOrderType(e){const t={LIMIT:"limit",MARKET:"market"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeInteger(e,"timestamp"),n=this.safeStringLower(e,"type"),r=this.safeString(e,"price"),a=this.safeString(e,"originalAmount"),o=this.safeString2(e,"remainingAmount","amount"),d=this.parseOrderStatus(this.safeString(e,"status")),c=this.parseOrderType(this.safeString(e,"orderTradeType")),u=this.safeString(e,"avgPrice"),h=this.safeString(e,"currencyPair"),l=this.safeSymbol(h,t,"_"),p=this.safeString(e,"clientOrderId"),m=this.safeNumber(e,"stopPrice");return this.safeOrder({id:s,clientOrderId:p,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,symbol:l,type:c,timeInForce:void 0,postOnly:void 0,side:n,price:r,stopPrice:m,amount:a,cost:void 0,average:u,filled:void 0,remaining:o,status:d,trades:void 0,info:e,fee:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();let a="privatePost"+this.capitalize(s);const d={currencyPair:this.market(e).id};t==="market"?(s==="buy"?d.total=this.amountToPrecision(e,i):d.amount=this.amountToPrecision(e,i),a+="Instant"):(d.amount=this.amountToPrecision(e,i),d.price=this.priceToPrecision(e,n),a+=this.capitalize(t));const c=await this[a](this.extend(d,r)),u=this.safeString(c,"data");return{info:c,id:u}}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e};let n;t&&(n=this.market(t));const r=await this.privatePostOrderById(this.extend(i,s)),a=this.safeValue(r,"data");return this.parseOrder(a,n)}async cancelOrder(e,t=void 0,s={}){const i={orderId:e};return{info:await this.privatePostCancelOrderWithInfo(this.extend(i,s))}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+e;if(t==="public")Object.keys(i).length&&(a+="?"+this.urlencode(i));else{this.checkRequiredCredentials();const o=this.nonce().toString(),d=o+this.uid+this.apiKey,c=this.hmac(this.encode(d),this.encode(this.secret));r=this.urlencode(this.extend({clientId:this.uid,nonce:o,publicKey:this.apiKey,signature:c.toUpperCase()},i)),n={"Content-Type":"application/x-www-form-urlencoded"}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&"error"in a&&a.error){const c=this.safeString(a,"errorMessage"),u=this.id+" "+c;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u),new xf(this.id+" "+this.json(a))}if(e>400){if(r){const c=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,r,c),this.throwBroadlyMatchedException(this.exceptions.broad,r,c),new xf(c)}throw new xf(this.id+" "+r)}}};const mR=me,{BadSymbol:gR,BadRequest:yR,ExchangeError:_f,ArgumentsRequired:Cf,OrderNotFound:bR,OnMaintenance:wR}=oe,{TICK_SIZE:SR}=pe,c0=ke;var kR=class extends mR{describe(){return this.deepExtend(super.describe(),{id:"coinone",name:"CoinOne",countries:["KR"],rateLimit:667,version:"v2",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:void 0,fetchDepositAddresses:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/38003300-adc12fba-323f-11e8-8525-725f53c4a659.jpg",api:{rest:"https://api.coinone.co.kr"},www:"https://coinone.co.kr",doc:"https://doc.coinone.co.kr"},requiredCredentials:{apiKey:!0,secret:!0},api:{public:{get:["orderbook/","trades/","ticker/"]},private:{post:["account/deposit_address/","account/btc_deposit_address/","account/balance/","account/daily_balance/","account/user_info/","account/virtual_account/","order/cancel_all/","order/cancel/","order/limit_buy/","order/limit_sell/","order/complete_orders/","order/limit_orders/","order/order_info/","transaction/auth_number/","transaction/history/","transaction/krw/history/","transaction/btc/","transaction/coin/"]}},fees:{trading:{tierBased:!1,percentage:!0,taker:.002,maker:.002}},precision:{price:this.parseNumber("0.0001"),amount:this.parseNumber("0.0001"),cost:this.parseNumber("0.00000001")},precisionMode:SR,exceptions:{405:wR,104:bR,108:gR,107:yR},commonCurrencies:{SOC:"Soda Coin"}})}async fetchMarkets(e={}){const t={currency:"all"},s=await this.publicGetTicker(t),i=[],n="krw",r=this.safeCurrencyCode(n),a=Object.keys(s);for(let o=0;o<a.length;o++){const d=a[o],c=this.safeValue(s,d,{});if(this.safeValue(c,"currency")===void 0)continue;const h=this.safeCurrencyCode(d);i.push({id:d,symbol:h+"/"+r,base:h,quote:r,settle:void 0,baseId:d,quoteId:n,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:void 0,price:void 0},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:c})}return i}parseBalance(e){const t={info:e},s=this.omit(e,["errorCode","result","normalWallets"]),i=Object.keys(s);for(let n=0;n<i.length;n++){const r=i[n],a=s[r],o=this.safeCurrencyCode(r),d=this.account();d.free=this.safeString(a,"avail"),d.total=this.safeString(a,"balance"),t[o]=d}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostAccountBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={currency:i.id,format:"json"},r=await this.publicGetOrderbook(this.extend(n,s)),a=this.safeTimestamp(r,"timestamp");return this.parseOrderBook(r,i.symbol,a,"bid","ask","price","qty")}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={currency:"all",format:"json"},i=await this.publicGetTicker(this.extend(s,t)),n={},r=Object.keys(i),a=this.safeTimestamp(i,"timestamp");for(let o=0;o<r.length;o++){const d=r[o],c=this.safeMarket(d),u=c.symbol,h=i[d];n[u]=this.parseTicker(h,c),n[u].timestamp=a}return this.filterByArray(n,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={currency:s.id,format:"json"},n=await this.publicGetTicker(this.extend(i,t));return this.parseTicker(n,s)}parseTicker(e,t=void 0){const s=this.safeTimestamp(e,"timestamp"),i=this.safeString(e,"first"),n=this.safeString(e,"last"),r=this.safeString(e,"yesterday_last"),a=this.safeSymbol(void 0,t);return this.safeTicker({symbol:a,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:i,close:n,last:n,previousClose:r,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:void 0,info:e},t)}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"timestamp");t=this.safeMarket(void 0,t);const i=this.safeString(e,"is_ask");let n=this.safeString(e,"type");i!==void 0?i==="1"?n="sell":i==="0"&&(n="buy"):n==="ask"?n="sell":n==="bid"&&(n="buy");const r=this.safeString(e,"price"),a=this.safeString(e,"qty"),o=this.safeString(e,"orderId");let d=this.safeString(e,"fee"),c;if(d!==void 0){d=c0.stringAbs(d);let u=this.safeString(e,"feeRate");u=c0.stringAbs(u);const h=n==="sell"?t.quote:t.base;c={cost:d,currency:h,rate:u}}return this.safeTrade({id:this.safeString(e,"id"),info:e,timestamp:s,datetime:this.iso8601(s),order:o,symbol:t.symbol,type:void 0,side:n,takerOrMaker:void 0,price:r,amount:a,cost:void 0,fee:c},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={currency:n.id,format:"json"},a=await this.publicGetTrades(this.extend(r,i)),o=this.safeValue(a,"completeOrders",[]);return this.parseTrades(o,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){if(t!=="limit")throw new _f(this.id+" createOrder() allows limit orders only");await this.loadMarkets();const a=this.market(e),o={price:n,currency:a.id,qty:i},d="privatePostOrder"+this.capitalize(t)+this.capitalize(s),c=await this[d](this.extend(o,r));return this.parseOrder(c,a)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Cf(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={order_id:e,currency:i.id},r=await this.privatePostOrderOrderInfo(this.extend(n,s)),a=this.safeValue(r,"info",{});return a.status=this.safeString(a,"status"),this.parseOrder(a,i)}parseOrderStatus(e){const t={live:"open",partially_filled:"open",filled:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"orderId"),i=this.safeString(e,"price"),n=this.safeTimestamp(e,"timestamp");let r=this.safeString(e,"type");r==="ask"?r="sell":r==="bid"&&(r="buy");const a=this.safeString(e,"remainQty"),o=this.safeString(e,"qty");let d=this.safeString(e,"status");d==="live"&&a!==void 0&&o!==void 0&&c0.stringLt(a,o)&&(d="canceled"),d=this.parseOrderStatus(d);const c=t.symbol,u=t.base,h=t.quote;let l;const p=this.safeString(e,"fee");if(p!==void 0){const m=r==="sell"?h:u;l={cost:p,rate:this.safeString(e,"feeRate"),currency:m}}return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,symbol:c,type:"limit",timeInForce:void 0,postOnly:void 0,side:r,price:i,stopPrice:void 0,cost:void 0,average:void 0,amount:o,filled:void 0,remaining:a,status:d,fee:l,trades:void 0},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new _f(this.id+" fetchOpenOrders() allows fetching closed orders with a specific symbol");await this.loadMarkets();const n=this.market(e),r={currency:n.id},a=await this.privatePostOrderLimitOrders(this.extend(r,i)),o=this.safeValue(a,"limitOrders",[]);return this.parseOrders(o,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Cf(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={currency:n.id},a=await this.privatePostOrderCompleteOrders(this.extend(r,i)),o=this.safeValue(a,"completeOrders",[]);return this.parseTrades(o,n,t,s)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Cf(this.id+" cancelOrder() requires a symbol argument. To cancel the order, pass a symbol argument and {'price': 12345, 'qty': 1.2345, 'is_ask': 0} in the params argument of cancelOrder.");const i=this.safeNumber(s,"price"),n=this.safeNumber(s,"qty"),r=this.safeInteger(s,"is_ask");if(i===void 0||n===void 0||r===void 0)throw new Cf(this.id+" cancelOrder() requires {'price': 12345, 'qty': 1.2345, 'is_ask': 0} in the params argument.");await this.loadMarkets();const a={order_id:e,price:i,qty:n,is_ask:r,currency:this.marketId(t)};return await this.privatePostOrderCancel(this.extend(a,s))}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s=await this.privatePostAccountDepositAddress(t),i=this.safeValue(s,"walletAddress",{}),n=Object.keys(i),r={};for(let a=0;a<n.length;a++){const o=n[a],d=i[o];if(!d||d==="-1")continue;const c=o.split("_"),u=this.safeValue(c,0),h=this.safeValue(c,1),l=this.safeCurrencyCode(u);let p=this.safeValue(r,l);p===void 0&&(p={currency:l,address:void 0,tag:void 0,info:d});const m=this.safeString(p,"address",d);this.checkAddress(m),p.address=m,p.info=m,(h==="tag"||h==="memo")&&(p.tag=d,p.info=[m,d]),r[l]=p}return r}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.implodeParams(e,i),o=this.omit(i,this.extractParams(e));let d=this.urls.api.rest+"/";if(t==="public")d+=a,Object.keys(o).length&&(d+="?"+this.urlencode(o));else{this.checkRequiredCredentials(),d+=this.version+"/"+a;const c=this.nonce().toString(),u=this.json(this.extend({access_token:this.apiKey,nonce:c},i)),h=this.stringToBase64(u);r=this.decode(h);const l=this.secret.toUpperCase(),p=this.hmac(h,this.encode(l),"sha512");n={"Content-Type":"application/json","X-COINONE-PAYLOAD":h,"X-COINONE-SIGNATURE":p}}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0)if("result"in a){if(a.result!=="success"){const u=this.safeString(a,"errorCode"),h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions,u,h),new _f(h)}}else throw new _f(this.id+" "+r)}};const vR=me,{ExchangeError:TR,ArgumentsRequired:OR}=oe,{TICK_SIZE:IR}=pe;var xR=class extends vR{describe(){return this.deepExtend(super.describe(),{id:"coinspot",name:"CoinSpot",countries:["AU"],rateLimit:1e3,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchOpenInterestHistory:!1,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/28208429-3cacdf9a-6896-11e7-854e-4c79a772a30f.jpg",api:{public:"https://www.coinspot.com.au/pubapi",private:"https://www.coinspot.com.au/api"},www:"https://www.coinspot.com.au",doc:"https://www.coinspot.com.au/api",referral:"https://www.coinspot.com.au/register?code=PJURCU"},api:{public:{get:["latest"]},private:{post:["orders","orders/history","my/coin/deposit","my/coin/send","quote/buy","quote/sell","my/balances","my/orders","my/buy","my/sell","my/buy/cancel","my/sell/cancel","ro/my/balances","ro/my/balances/{cointype}","ro/my/deposits","ro/my/withdrawals","ro/my/transactions","ro/my/transactions/{cointype}","ro/my/transactions/open","ro/my/transactions/{cointype}/open","ro/my/sendreceive","ro/my/affiliatepayments","ro/my/referralpayments"]}},markets:{"ADA/AUD":{id:"ada",symbol:"ADA/AUD",base:"ADA",quote:"AUD",baseId:"ada",quoteId:"aud",type:"spot",spot:!0},"BTC/AUD":{id:"btc",symbol:"BTC/AUD",base:"BTC",quote:"AUD",baseId:"btc",quoteId:"aud",type:"spot",spot:!0},"BTC/USDT":{id:"btc",symbol:"BTC/USDT",base:"BTC",quote:"USDT",baseId:"btc",quoteId:"usdt",type:"spot",spot:!0},"ETH/AUD":{id:"eth",symbol:"ETH/AUD",base:"ETH",quote:"AUD",baseId:"eth",quoteId:"aud",type:"spot",spot:!0},"XRP/AUD":{id:"xrp",symbol:"XRP/AUD",base:"XRP",quote:"AUD",baseId:"xrp",quoteId:"aud",type:"spot",spot:!0},"LTC/AUD":{id:"ltc",symbol:"LTC/AUD",base:"LTC",quote:"AUD",baseId:"ltc",quoteId:"aud",type:"spot",spot:!0},"DOGE/AUD":{id:"doge",symbol:"DOGE/AUD",base:"DOGE",quote:"AUD",baseId:"doge",quoteId:"aud",type:"spot",spot:!0},"RFOX/AUD":{id:"rfox",symbol:"RFOX/AUD",base:"RFOX",quote:"AUD",baseId:"rfox",quoteId:"aud",type:"spot",spot:!0},"POWR/AUD":{id:"powr",symbol:"POWR/AUD",base:"POWR",quote:"AUD",baseId:"powr",quoteId:"aud",type:"spot",spot:!0},"NEO/AUD":{id:"neo",symbol:"NEO/AUD",base:"NEO",quote:"AUD",baseId:"neo",quoteId:"aud",type:"spot",spot:!0},"TRX/AUD":{id:"trx",symbol:"TRX/AUD",base:"TRX",quote:"AUD",baseId:"trx",quoteId:"aud",type:"spot",spot:!0},"EOS/AUD":{id:"eos",symbol:"EOS/AUD",base:"EOS",quote:"AUD",baseId:"eos",quoteId:"aud",type:"spot",spot:!0},"XLM/AUD":{id:"xlm",symbol:"XLM/AUD",base:"XLM",quote:"AUD",baseId:"xlm",quoteId:"aud",type:"spot",spot:!0},"RHOC/AUD":{id:"rhoc",symbol:"RHOC/AUD",base:"RHOC",quote:"AUD",baseId:"rhoc",quoteId:"aud",type:"spot",spot:!0},"GAS/AUD":{id:"gas",symbol:"GAS/AUD",base:"GAS",quote:"AUD",baseId:"gas",quoteId:"aud",type:"spot",spot:!0}},commonCurrencies:{DRK:"DASH"},options:{fetchBalance:"private_post_my_balances"},precisionMode:IR})}parseBalance(e){const t={info:e},s=this.safeValue2(e,"balance","balances");if(Array.isArray(s))for(let i=0;i<s.length;i++){const n=s[i],r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=n[o],c=this.safeCurrencyCode(o),u=this.account();u.total=this.safeString(d,"balance"),t[c]=u}}else{const i=Object.keys(s);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(s,r),t[a]=o}}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(this.options,"fetchBalance","private_post_my_balances"),s=await this[t](e);return this.parseBalance(s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={cointype:i.id},r=await this.privatePostOrders(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"buyorders","sellorders","rate","amount")}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:void 0,datetime:void 0,high:void 0,low:void 0,bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:i,last:i,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=await this.publicGetLatest(t);let n=s.id;n=n.toLowerCase();const r=this.safeValue(i,"prices"),a=this.safeValue(r,n);return this.parseTicker(a,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetLatest(t),i={},n=this.safeValue(s,"prices"),r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeMarket(o);if(d.spot){const c=d.symbol,u=n[o];i[c]=this.parseTicker(u,d)}}return this.filterByArray(i,"symbol",e)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={cointype:n.id},a=await this.privatePostOrdersHistory(this.extend(r,i)),o=this.safeValue(a,"orders",[]);return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"rate"),i=this.safeString(e,"amount"),n=this.safeNumber(e,"total"),r=this.safeInteger(e,"solddate"),a=this.safeString(e,"market"),o=this.safeSymbol(a,t,"/");return this.safeTrade({info:e,id:void 0,symbol:o,timestamp:r,datetime:this.iso8601(r),order:void 0,type:void 0,side:void 0,takerOrMaker:void 0,price:s,amount:i,cost:n,fee:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a="privatePostMy"+this.capitalize(s);if(t==="market")throw new TR(this.id+" createOrder() allows limit orders only");const d={cointype:this.market(e).id,amount:i,rate:n};return await this[a](this.extend(d,r))}async cancelOrder(e,t=void 0,s={}){const i=this.safeString(s,"side");if(i!=="buy"&&i!=="sell")throw new OR(this.id+' cancelOrder() requires a side parameter, "buy" or "sell"');s=this.omit(s,"side");const n="privatePostMy"+this.capitalize(i)+"Cancel",r={id:e};return await this[n](this.extend(r,s))}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.urls.api[t]+"/"+e;if(t==="private"){this.checkRequiredCredentials();const o=this.nonce();r=this.json(this.extend({nonce:o},i)),n={"Content-Type":"application/json",key:this.apiKey,sign:this.hmac(this.encode(r),this.encode(this.secret),"sha512")}}return{url:a,method:s,body:r,headers:n}}};const _R=me,{ExchangeError:u0,BadRequest:pc,InvalidNonce:CR,RequestTimeout:MR,ExchangeNotAvailable:Ik,InsufficientFunds:PR,OrderNotFound:AR,InvalidOrder:f0,DDoSProtection:BR,AuthenticationError:Mf,BadSymbol:h0,AccountSuspended:xk,ArgumentsRequired:NR}=oe,{TICK_SIZE:ER}=pe;var VR=class extends _R{describe(){return this.deepExtend(super.describe(),{id:"crex24",name:"CREX24",countries:["EE"],rateLimit:500,version:"v2",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!0,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFees:!0,fetchTransactions:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","1d":"1d","1w":"1w","1M":"1mo"},urls:{logo:"https://user-images.githubusercontent.com/1294454/47813922-6f12cc00-dd5d-11e8-97c6-70f957712d47.jpg",api:{rest:"https://api.crex24.com"},www:"https://crex24.com",referral:"https://crex24.com/?refid=slxsjsjtil8xexl9hksr",doc:"https://docs.crex24.com/trade-api/v2",fees:"https://crex24.com/fees"},api:{public:{get:["currencies","instruments","tickers","recentTrades","orderBook","ohlcv","tradingFeeSchedules","withdrawalFees","currencyTransport","currenciesWithdrawalFees"]},trading:{get:["orderStatus","orderTrades","activeOrders","orderHistory","tradeHistory","tradingFee","tradeFee"],post:["placeOrder","modifyOrder","cancelOrdersById","cancelOrdersByInstrument","cancelAllOrders"]},account:{get:["balance","depositAddress","moneyTransfers","moneyTransferStatus","previewWithdrawal"],post:["withdraw"]}},precisionMode:ER,fees:{trading:{tierBased:!0,percentage:!0,taker:.001,maker:-1e-4},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}},commonCurrencies:{ACM:"Actinium",BCC:"BCH",BIT:"BitMoney",BULL:"BuySell",CLC:"CaluraCoin",CREDIT:"TerraCredit",DMS:"Documentchain",EGG:"NestEGG Coin",EPS:"Epanus",FUND:"FUNDChains",GHOST:"GHOSTPRISM",GM:"GM Holding",GMT:"GMT Token",GTC:"GastroCoin",IQ:"IQ.Cash",ONE:"One Hundred Coin",PUT:"PutinCoin",SBTC:"SBTCT",SPH:"SapphireCoin",SUPER:"SuperCoin",UNI:"Universe",YOYO:"YOYOW"},options:{networks:{ETH:"ERC20",TRX:"TRC20",BSC:"BEP20"},fetchOrdersMethod:"tradingGetOrderHistory",fetchClosedOrdersMethod:"tradingGetOrderHistory",fetchTickersMethod:"publicGetTicker24hr",defaultTimeInForce:"GTC",hasAlreadyAuthenticatedSuccessfully:!1,warnOnFetchOpenOrdersWithoutSymbol:!0,parseOrderToPrecision:!1,newOrderRespType:"RESULT",fetchTradingFees:{method:"fetchPrivateTradingFees"}},exceptions:{exact:{"Parameter 'filter' contains invalid value.":pc,"Mandatory parameter 'instrument' is missing.":pc,"The value of parameter 'till' must be greater than or equal to the value of parameter 'from'.":pc,"Failed to verify request signature.":Mf,"Nonce error. Make sure that the value passed in the 'X-CREX24-API-NONCE' header is greater in each consecutive request than in the previous one for the corresponding API-Key provided in 'X-CREX24-API-KEY' header.":CR,"Market orders are not supported by the instrument currently.":f0,"Parameter 'instrument' contains invalid value.":h0,"Trading has been disabled for the account until the verification is passed. To initiate the verification process, please log into your account at crex24.com and proceed to 'My account' -> 'Verification'.":xk},broad:{"try again later":Ik,"API Key":Mf,"Insufficient funds":PR,"has been delisted.":h0,"is currently suspended.":h0,"Mandatory parameter":pc,"can not trade":xk}}})}nonce(){return this.milliseconds()}async fetchMarkets(e={}){const t=await this.publicGetInstruments(e),s=await this.publicGetTradingFeeSchedules(e),i=[];for(let n=0;n<t.length;n++){const r=t[n],a=this.safeString(r,"symbol"),o=this.safeString(r,"baseCurrency"),d=this.safeString(r,"quoteCurrency"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d);let h,l;const p=this.safeString(r,"feeSchedule");for(let g=0;g<s.length;g++)if(this.safeString(s[g],"name")===p){const b=this.safeValue(s[g],"feeRates",[]);for(let w=0;w<b.length;w++)if(this.safeNumber(b[w],"volumeThreshold")===0){h=this.safeNumber(b[w],"maker"),l=this.safeNumber(b[w],"taker");break}break}const m=this.safeString(r,"state");i.push({id:a,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:m==="active",contract:!1,linear:void 0,inverse:void 0,taker:l,maker:h,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(r,"volumeIncrement"),price:this.safeNumber(r,"tickSize")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"minVolume"),max:this.safeNumber(r,"maxVolume")},price:{min:this.safeNumber(r,"minPrice"),max:this.safeNumber(r,"maxPrice")},cost:{min:this.safeNumber(r,"minQuoteVolume"),max:this.safeNumber(r,"maxQuoteVolume")}},info:r})}return i}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"symbol"),a=this.safeCurrencyCode(r),o=this.parseNumber(this.parsePrecision(this.safeString(n,"withdrawalPrecision"))),d=this.safeValue(n,"BaseAddress"),c=this.safeValue(n,"depositsAllowed"),u=this.safeValue(n,"withdrawalsAllowed"),h=this.safeValue(n,"isDelisted"),l=c&&u&&!h,m=this.safeValue(n,"isFiat")?"fiat":"crypto";s[a]={id:r,code:a,address:d,info:n,type:m,name:this.safeString(n,"name"),active:l,deposit:c,withdraw:u,fee:this.safeNumber(n,"flatWithdrawalFee"),precision:o,limits:{amount:{min:o,max:void 0},deposit:{min:this.safeNumber(n,"minDeposit"),max:void 0},withdraw:{min:this.safeNumber(n,"minWithdrawal"),max:this.safeNumber(n,"maxWithdrawal")}}}}return s}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s={};e!==void 0&&(s.filter=e.join(","));const i=await this.publicGetCurrenciesWithdrawalFees(this.extend(s,t));return this.parseTransactionFees(i,e)}parseTransactionFees(e,t=void 0){const s={};for(let i=0;i<e.length;i++){const n=e[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r);t!==void 0&&!this.inArray(a,t)||(s[a]=this.parseTransactionFee(n))}return s}parseTransactionFee(e){const t={withdraw:{},deposit:{},info:e},s=this.safeValue(e,"fees");for(let i=0;i<s.length;i++){const n=s[i],r=this.safeString(n,"feeCurrency"),a=this.safeNumber(n,"amount");t.withdraw[r]=a}return t}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"available"),a.used=this.safeString(i,"reserved"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t={},s=await this.accountGetBalance(this.extend(t,e));return this.parseBalance(s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={instrument:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetOrderBook(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"buyLevels","sellLevels","price","volume")}parseTicker(e,t=void 0){const s=this.parse8601(this.safeString(e,"timestamp")),i=this.safeString(e,"instrument"),n=this.safeSymbol(i,t,"-"),r=this.safeString(e,"last");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:this.safeString(e,"percentChange"),average:void 0,baseVolume:this.safeString(e,"baseVolume"),quoteVolume:this.safeString(e,"quoteVolume"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={instrument:s.id},n=await this.publicGetTickers(this.extend(i,t));if(n.length<1)throw new u0(this.id+" fetchTicker() could not load quotes for symbol "+e);return this.parseTicker(n[0],s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};if(e!==void 0){const n=this.marketIds(e);s.instrument=n.join(",")}const i=await this.publicGetTickers(this.extend(s,t));return this.parseTickers(i,e)}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"timestamp")),i=this.safeString(e,"price"),n=this.safeString(e,"volume"),r=this.safeString(e,"id"),a=this.safeString(e,"side"),o=this.safeString(e,"orderId"),d=this.safeString(e,"instrument"),c=this.safeSymbol(d,t,"-");let u;const h=this.safeString(e,"feeCurrency"),l=this.safeCurrencyCode(h),p=this.safeString(e,"fee");p!==void 0&&(u={cost:p,currency:l});const m=void 0;return this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:c,id:r,order:o,type:void 0,takerOrMaker:m,side:a,price:i,cost:void 0,amount:n,fee:u},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={instrument:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetRecentTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTradingFees(e={}){let t=this.safeString(e,"method");if(e=this.omit(e,"method"),t===void 0){const s=this.safeValue(this.options,"fetchTradingFees",{});t=this.safeString(s,"method","fetchPrivateTradingFees")}return await this[t](e)}async fetchPublicTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetTradingFeeSchedules(e),s=this.indexBy(t,"name"),i=this.safeValue(s,"OriginalSchedule",{}),n=this.safeValue(i,"feeRates",[]),r=this.safeValue(n,0,{}),a=this.safeNumber(r,"maker"),o=this.safeNumber(r,"taker"),d={};for(let c=0;c<this.symbols.length;c++){const u=this.symbols[c];d[u]={info:t,symbol:u,maker:a,taker:o,percentage:!0,tierBased:!0}}return d}async fetchPrivateTradingFees(e={}){await this.loadMarkets();const t=await this.tradingGetTradingFee(e),s=this.safeValue(t,"feeRates",[]),i=this.indexBy(s,"schedule"),n=this.safeValue(i,"OriginalSchedule",{}),r=this.safeNumber(n,"maker"),a=this.safeNumber(n,"taker"),o={};for(let d=0;d<this.symbols.length;d++){const c=this.symbols[d];o[c]={info:t,symbol:c,maker:r,taker:a,percentage:!0,tierBased:!0}}return o}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"timestamp")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={granularity:this.timeframes[t],instrument:r.id};i!==void 0&&(a.limit=i);const o=await this.publicGetOhlcv(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}parseOrderStatus(e){const t={submitting:"open",unfilledActive:"open",partiallyFilledActive:"open",filled:"closed",partiallyFilledCancelled:"canceled",unfilledCancelled:"canceled"};return e in t?t[e]:e}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString(e,"status")),i=this.safeString(e,"instrument"),n=this.safeSymbol(i,t,"-"),r=this.parse8601(this.safeString(e,"timestamp")),a=this.safeString(e,"price"),o=this.safeString(e,"volume"),d=this.safeString(e,"remainingVolume"),c=this.parse8601(this.safeString(e,"lastUpdate")),u=this.safeString(e,"id",e),h=this.safeString(e,"type"),l=this.safeString(e,"side"),p=this.safeString(e,"timeInForce"),m=this.safeNumber(e,"stopPrice");return this.safeOrder({info:e,id:u,clientOrderId:void 0,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:c,symbol:n,type:h,timeInForce:p,side:l,price:a,stopPrice:m,amount:o,cost:void 0,average:void 0,filled:void 0,remaining:d,status:s,fee:void 0,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={instrument:a.id,volume:this.amountToPrecision(e,i),type:t,side:s};let d=!1,c=!1;if(t==="limit"?d=!0:t==="stopLimit"&&(d=!0,c=!0),d){if(n===void 0)throw new f0(this.id+" createOrder() requires a price argument for a "+t+" order");o.price=this.priceToPrecision(e,n)}if(c){const h=this.safeValue2(r,"triggerPrice","stopPrice");if(h===void 0)throw new f0(this.id+" createOrder() requires a stopPrice extra param for a "+t+" order");o.stopPrice=this.priceToPrecision(e,h),r=this.omit(r,["triggerPrice","stopPrice"])}const u=await this.tradingPostPlaceOrder(this.extend(o,r));return this.parseOrder(u,a)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.tradingGetOrderStatus(this.extend(i,s));if(n.length<1)throw new AR(this.id+" fetchOrder() could not fetch order id "+e);return this.parseOrder(n[0])}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};if(t!==void 0&&(n.from=this.ymdhms(t,"T")),s!==void 0&&(n.limit=s),e!==void 0){const o=this.market(e);n.instrument=o.id}const r=this.safeString(this.options,"fetchOrdersMethod","tradingGetOrderHistory"),a=await this[r](this.extend(n,i));return this.parseOrders(a)}async fetchOrdersByIds(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={id:e.join(",")},r=await this.tradingGetOrderStatus(this.extend(n,i));return this.parseOrders(r,void 0,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.instrument=n.id);const a=await this.tradingGetActiveOrders(this.extend(r,i));return this.parseOrders(a,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.instrument=n.id),t!==void 0&&(r.from=this.ymdhms(t,"T")),s!==void 0&&(r.limit=s);const a=this.safeString(this.options,"fetchClosedOrdersMethod","tradingGetOrderHistory"),o=await this[a](this.extend(r,i));return this.parseOrders(o,n,t,s)}async cancelOrder(e,t=void 0,s={}){const i=await this.cancelOrders([e],t,s);return this.safeValue(i,0)}async cancelOrders(e,t=void 0,s={}){if(!Array.isArray(e))throw new NR(this.id+" cancelOrders() ids argument should be an array");await this.loadMarkets();const i={ids:[]};for(let r=0;r<e.length;r++){const a=parseInt(e[r]);i.ids.push(a)}const n=await this.tradingPostCancelOrdersById(this.extend(i,s));return this.parseOrders(n)}async cancelAllOrders(e=void 0,t={}){let s,i;if(e===void 0)s=await this.tradingPostCancelAllOrders(t);else{await this.loadMarkets(),i=this.market(e);const n={instruments:[i.id]};s=await this.tradingPostCancelOrdersByInstrument(this.extend(n,t))}return this.parseOrders(s,i,void 0,void 0,t)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={id:e},a=await this.tradingGetOrderTrades(this.extend(r,n));return this.parseTrades(a,void 0,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.instrument=n.id),t!==void 0&&(r.from=this.ymdhms(t,"T")),s!==void 0&&(r.limit=s);const a=await this.tradingGetTradeHistory(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.currency=n.id),t!==void 0&&(r.from=this.ymdhms(t,"T"));const a=await this.accountGetMoneyTransfers(this.extend(r,i));return this.parseTransactions(a,n,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){const n={type:"deposit"};return this.fetchTransactions(e,t,s,this.extend(n,i))}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const n={type:"withdrawal"};return this.fetchTransactions(e,t,s,this.extend(n,i))}parseTransactionStatus(e){const t={pending:"pending",success:"ok",failed:"failed"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"address"),n=this.safeString(e,"paymentId"),r=this.safeValue(e,"txId"),a=this.safeString(e,"currency"),o=this.safeCurrencyCode(a,t),d=this.safeString(e,"type"),c=this.parse8601(this.safeString(e,"createdAt")),u=this.parse8601(this.safeString(e,"processedAt")),h=this.parseTransactionStatus(this.safeString(e,"status")),l=this.safeNumber(e,"amount"),m={cost:this.safeNumber(e,"fee"),currency:o};return{info:e,id:s,txid:r,timestamp:c,datetime:this.iso8601(c),network:void 0,address:i,addressTo:void 0,addressFrom:void 0,tag:n,tagTo:void 0,tagFrom:void 0,type:d,amount:l,currency:o,status:h,updated:u,fee:m}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.accountGetDepositAddress(this.extend(i,t)),r=this.safeString(n,"address"),a=this.safeString(n,"paymentId");return{currency:e,address:this.checkAddress(r),tag:a,network:void 0,info:n}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,address:s,amount:parseFloat(this.currencyToPrecision(e,t)),feeCurrency:r.id};i!==void 0&&(a.paymentId=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeString(o,d,d),d!==void 0&&(a.transport=d,n=this.omit(n,"network"));const c=await this.accountPostWithdraw(this.extend(a,n));return this.parseTransaction(c)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.version+"/"+t+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));s==="GET"&&Object.keys(o).length&&(a+="?"+this.urlencode(o));const d=this.urls.api.rest+a;if(t==="trading"||t==="account"){this.checkRequiredCredentials();const c=this.nonce().toString(),u=this.base64ToBinary(this.secret);let h=a+c;n={"X-CREX24-API-KEY":this.apiKey,"X-CREX24-API-NONCE":c},s==="POST"&&(n["Content-Type"]="application/json",r=this.json(i),h+=r),n["X-CREX24-API-SIGN"]=this.hmac(this.encode(h),u,"sha512","base64")}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(!this.isJsonEncodedObject(r)||e>=200&&e<300)return;const c=this.safeString(a,"errorDescription"),u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u),e===400?new pc(u):e===401?new Mf(u):e===403?new Mf(u):e===429?new BR(u):e===500?new u0(u):e===503?new Ik(u):e===504?new MR(u):new u0(u)}};const qR=me,{AuthenticationError:LR,ArgumentsRequired:Pf,ExchangeError:l0,InsufficientFunds:RR,DDoSProtection:FR,InvalidNonce:DR,PermissionDenied:p0,BadRequest:xt,BadSymbol:HR,NotSupported:_k,AccountNotEnabled:GR,OnMaintenance:UR}=oe,{TICK_SIZE:$R}=pe,Ck=ke;var E_=class extends qR{describe(){return this.deepExtend(super.describe(),{id:"cryptocom",name:"Crypto.com",countries:["MT"],version:"v2",rateLimit:10,pro:!0,has:{CORS:!1,spot:!0,margin:!0,swap:void 0,future:void 0,option:void 0,borrowMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,fetchBalance:!0,fetchBidsAsks:!1,fetchBorrowInterest:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!0,fetchClosedOrders:"emulated",fetchCurrencies:!1,fetchDepositAddress:!0,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRates:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPositionMode:!1,fetchPositions:!1,fetchStatus:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfers:!0,fetchWithdrawals:!0,repayMargin:!0,setLeverage:!1,setMarginMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","6h":"6h","12h":"12h","1d":"1D","1w":"7D","2w":"14D","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/147792121-38ed5e36-c229-48d6-b49a-48d05fc19ed4.jpeg",test:{spot:"https://uat-api.3ona.co/v2",derivatives:"https://uat-api.3ona.co/v2"},api:{spot:"https://api.crypto.com/v2",derivatives:"https://deriv-api.crypto.com/v1"},www:"https://crypto.com/",referral:"https://crypto.com/exch/5835vstech",doc:["https://exchange-docs.crypto.com/spot/index.html","https://exchange-docs.crypto.com/derivatives/index.html"],fees:"https://crypto.com/exchange/document/fees-limits"},api:{spot:{public:{get:{"public/auth":1,"public/get-instruments":1,"public/get-book":1,"public/get-candlestick":1,"public/get-ticker":1,"public/get-trades":1,"public/margin/get-transfer-currencies":1,"public/margin/get-load-currenices":1,"public/respond-heartbeat":1}},private:{post:{"private/set-cancel-on-disconnect":10/3,"private/get-cancel-on-disconnect":10/3,"private/create-withdrawal":10/3,"private/get-withdrawal-history":10/3,"private/get-currency-networks":10/3,"private/get-deposit-history":10/3,"private/get-deposit-address":10/3,"private/get-account-summary":10/3,"private/create-order":2/3,"private/cancel-order":2/3,"private/cancel-all-orders":2/3,"private/create-order-list":10/3,"private/get-order-history":10/3,"private/get-open-orders":10/3,"private/get-order-detail":1/3,"private/get-trades":100,"private/margin/get-user-config":10/3,"private/margin/get-account-summary":10/3,"private/margin/transfer":10/3,"private/margin/borrow":10/3,"private/margin/repay":10/3,"private/margin/get-transfer-history":10/3,"private/margin/get-borrow-history":10/3,"private/margin/get-interest-history":10/3,"private/margin/get-repay-history":10/3,"private/margin/get-liquidation-history":10/3,"private/margin/get-liquidation-orders":10/3,"private/margin/create-order":2/3,"private/margin/cancel-order":2/3,"private/margin/cancel-all-orders":2/3,"private/margin/get-order-history":10/3,"private/margin/get-open-orders":10/3,"private/margin/get-order-detail":1/3,"private/margin/get-trades":100,"private/deriv/transfer":10/3,"private/deriv/get-transfer-history":10/3,"private/get-accounts":10/3,"private/get-subaccount-balances":10/3,"private/create-subaccount-transfer":10/3,"private/otc/get-otc-user":10/3,"private/otc/get-instruments":10/3,"private/otc/request-quote":100,"private/otc/accept-quote":100,"private/otc/get-quote-history":10/3,"private/otc/get-trade-history":10/3}}},derivatives:{public:{get:{"public/auth":10/3,"public/get-instruments":10/3,"public/get-book":1,"public/get-candlestick":1,"public/get-trades":1,"public/get-tickers":1,"public/get-valuations":1,"public/get-expired-settlement-price":10/3,"public/get-insurance":1}},private:{post:{"private/set-cancel-on-disconnect":10/3,"private/get-cancel-on-disconnect":10/3,"private/user-balance":10/3,"private/user-balance-history":10/3,"private/get-positions":10/3,"private/create-order":2/3,"private/cancel-order":2/3,"private/cancel-all-orders":2/3,"private/close-position":10/3,"private/convert-collateral":10/3,"private/get-order-history":100,"private/get-open-orders":10/3,"private/get-order-detail":1/3,"private/get-trades":100,"private/change-account-leverage":10/3,"private/get-transactions":10/3}}}},fees:{trading:{maker:this.parseNumber("0.004"),taker:this.parseNumber("0.004"),tiers:{maker:[[this.parseNumber("0"),this.parseNumber("0.004")],[this.parseNumber("25000"),this.parseNumber("0.0035")],[this.parseNumber("50000"),this.parseNumber("0.0015")],[this.parseNumber("100000"),this.parseNumber("0.001")],[this.parseNumber("250000"),this.parseNumber("0.0009")],[this.parseNumber("1000000"),this.parseNumber("0.0008")],[this.parseNumber("20000000"),this.parseNumber("0.0007")],[this.parseNumber("100000000"),this.parseNumber("0.0006")],[this.parseNumber("200000000"),this.parseNumber("0.0004")]],taker:[[this.parseNumber("0"),this.parseNumber("0.004")],[this.parseNumber("25000"),this.parseNumber("0.0035")],[this.parseNumber("50000"),this.parseNumber("0.0025")],[this.parseNumber("100000"),this.parseNumber("0.0016")],[this.parseNumber("250000"),this.parseNumber("0.00015")],[this.parseNumber("1000000"),this.parseNumber("0.00014")],[this.parseNumber("20000000"),this.parseNumber("0.00013")],[this.parseNumber("100000000"),this.parseNumber("0.00012")],[this.parseNumber("200000000"),this.parseNumber("0.0001")]]}}},options:{defaultType:"spot",accountsById:{funding:"SPOT",spot:"SPOT",margin:"MARGIN",derivatives:"DERIVATIVES",swap:"DERIVATIVES",future:"DERIVATIVES"}},commonCurrencies:{USD_STABLE_COIN:"USDC"},precisionMode:$R,exceptions:{exact:{10001:l0,10002:p0,10003:p0,10004:xt,10005:p0,10006:FR,10007:DR,10008:xt,10009:xt,20001:xt,20002:RR,20005:GR,30003:HR,30004:xt,30005:xt,30006:xt,30007:xt,30008:xt,30009:xt,30010:xt,30013:xt,30014:xt,30016:xt,30017:xt,30023:xt,30024:xt,30025:xt,40001:xt,40002:xt,40003:xt,40004:xt,40005:xt,40006:xt,40007:xt,40101:LR,50001:xt,9010001:UR}}})}async fetchMarkets(e={}){let t=[this.fetchSpotMarkets(e),this.fetchDerivativesMarkets(e)];t=await Promise.all(t);const s=t[0],i=t[1];return this.arrayConcat(s,i)}async fetchSpotMarkets(e={}){const t=await this.spotPublicGetPublicGetInstruments(e),s=this.safeValue(t,"result",{}),i=this.safeValue(s,"instruments",[]),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"instrument_name"),d=this.safeString(a,"base_currency"),c=this.safeString(a,"quote_currency"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),l=this.safeString(a,"min_price"),p=this.safeString(a,"min_quantity");let m=this.parseNumber("1");this.safeValue(a,"margin_trading_enabled_5x")&&(m=this.parseNumber("5")),this.safeValue(a,"margin_trading_enabled_10x")&&(m=this.parseNumber("10")),n.push({id:o,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:this.safeValue(a,"margin_trading_enabled"),swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(a,"quantity_tick_size"),price:this.safeNumber(a,"price_tick_size")},limits:{leverage:{min:this.parseNumber("1"),max:m},amount:{min:this.parseNumber(p),max:this.safeNumber(a,"max_quantity")},price:{min:this.parseNumber(l),max:this.safeNumber(a,"max_price")},cost:{min:this.parseNumber(Ck.stringMul(p,l)),max:void 0}},info:a})}return n}async fetchDerivativesMarkets(e={}){const t=[],s=await this.derivativesPublicGetPublicGetInstruments(),i=this.safeValue(s,"result",{}),n=this.safeValue(i,"data",[]);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeString(a,"inst_type"),d=o==="PERPETUAL_SWAP",c=o==="FUTURE";if(o==="CCY_PAIR")continue;const u=this.safeString(a,"base_ccy"),h=this.safeString(a,"quote_ccy"),l=this.safeCurrencyCode(u),p=this.safeCurrencyCode(h);let m=l+"/"+p+":"+p,g=this.safeInteger(a,"expiry_timestamp_ms");g===0&&(g=void 0);let y="swap";c&&(y="future",m=m+"-"+this.yymmdd(g));const b=this.safeNumber(a,"contract_size");t.push({id:this.safeString(a,"symbol"),symbol:m,base:l,quote:p,settle:p,baseId:u,quoteId:h,settleId:h,type:y,spot:!1,margin:!1,swap:d,future:c,option:!1,active:this.safeValue(a,"tradable"),contract:!0,linear:!0,inverse:!1,contractSize:b,expiry:g,expiryDatetime:this.iso8601(g),strike:void 0,optionType:void 0,precision:{price:this.parseNumber(this.parsePrecision(this.safeString(a,"quote_decimals"))),amount:this.parseNumber(this.parsePrecision(this.safeString(a,"quantity_decimals")))},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(a,"max_leverage")},amount:{min:this.parseNumber(b),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:a})}return t}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s;if(e!==void 0){const c=this.safeValue(e,0);s=this.market(c)}const[i,n]=this.handleMarketTypeAndParams("fetchTickers",s,t),r=this.getSupportedMapping(i,{spot:"spotPublicGetPublicGetTicker",future:"derivativesPublicGetPublicGetTickers",swap:"derivativesPublicGetPublicGetTickers"}),a=await this[r](n),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"data",[]);return this.parseTickers(d,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={instrument_name:s.id},[n,r]=this.handleMarketTypeAndParams("fetchTicker",s,t);if(n!=="spot")throw new _k(this.id+" fetchTicker() only supports spot markets");const a=await this.spotPublicGetPublicGetTicker(this.extend(i,r)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"data",{}),c=this.safeValue(d,0,{});return this.parseTicker(c,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Pf(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={instrument_name:n.id};t!==void 0&&(r.start_ts=t),s!==void 0&&(r.page_size=s);const[a,o]=this.handleMarketTypeAndParams("fetchOrders",n,i);let d=this.getSupportedMapping(a,{spot:"spotPrivatePostPrivateGetOrderHistory",margin:"spotPrivatePostPrivateMarginGetOrderHistory",future:"derivativesPrivatePostPrivateGetOrderHistory",swap:"derivativesPrivatePostPrivateGetOrderHistory"});const[c,u]=this.customHandleMarginModeAndParams("fetchOrders",o);c!==void 0&&(d="spotPrivatePostPrivateMarginGetOrderHistory");const h=await this[d](this.extend(r,u)),l=this.safeValue(h,"result",{}),p=this.safeValue2(l,"order_list","data",[]);return this.parseOrders(p,n,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={instrument_name:n.id};t!==void 0&&(r.start_ts=t),s!==void 0&&(r.page_size=s);const[a,o]=this.handleMarketTypeAndParams("fetchTrades",n,i),d=this.getSupportedMapping(a,{spot:"spotPublicGetPublicGetTrades",future:"derivativesPublicGetPublicGetTrades",swap:"derivativesPublicGetPublicGetTrades"}),c=await this[d](this.extend(r,o)),u=this.safeValue(c,"result",{}),h=this.safeValue(u,"data",[]);return this.parseTrades(h,n,t,s)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={instrument_name:r.id,timeframe:this.timeframes[t]},[o,d]=this.handleMarketTypeAndParams("fetchOHLCV",r,n),c=this.getSupportedMapping(o,{spot:"spotPublicGetPublicGetCandlestick",future:"derivativesPublicGetPublicGetCandlestick",swap:"derivativesPublicGetPublicGetCandlestick"}),u=await this[c](this.extend(a,d)),h=this.safeValue(u,"result",{}),l=this.safeValue(h,"data",[]);return this.parseOHLCVs(l,r,t,s,i)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={instrument_name:i.id};t&&(n.depth=t);const[r,a]=this.handleMarketTypeAndParams("fetchOrderBook",i,s),o=this.getSupportedMapping(r,{spot:"spotPublicGetPublicGetBook",future:"derivativesPublicGetPublicGetBook",swap:"derivativesPublicGetPublicGetBook"}),d=await this[o](this.extend(n,a)),c=this.safeValue(d,"result"),u=this.safeValue(c,"data"),h=this.safeValue(u,0),l=this.safeInteger(h,"t");return this.parseOrderBook(h,e,l)}parseSwapBalance(e){const t=this.safeValue(e,"result",{}),s=this.safeValue(t,"data",[]),i={info:e};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"instrument_name"),o=this.safeCurrencyCode(a),d=this.account();d.total=this.safeString(r,"total_cash_balance"),d.free=this.safeString(r,"total_available_balance"),i[o]=d}return this.safeBalance(i)}parseSpotBalance(e){const t=this.safeValue(e,"result",{}),s=this.safeValue(t,"accounts",[]),i={info:e};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.account();d.total=this.safeString(r,"balance"),d.free=this.safeString(r,"available"),d.used=this.safeString(r,"order"),i[o]=d}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("fetchBalance",void 0,e);let i=this.getSupportedMapping(t,{spot:"spotPrivatePostPrivateGetAccountSummary",margin:"spotPrivatePostPrivateMarginGetAccountSummary",future:"derivativesPrivatePostPrivateUserBalance",swap:"derivativesPrivatePostPrivateUserBalance"});const[n,r]=this.customHandleMarginModeAndParams("fetchBalance",s);n!==void 0&&(i="spotPrivatePostPrivateMarginGetAccountSummary");const a=await this[i](r),o=this.getSupportedMapping(t,{spot:"parseSpotBalance",margin:"parseSpotBalance",future:"parseSwapBalance",swap:"parseSwapBalance"});return this[o](a)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));const n={},[r,a]=this.handleMarketTypeAndParams("fetchOrder",i,s),[o,d]=this.customHandleMarginModeAndParams("fetchOrder",a);r==="spot"||r==="margin"||o!==void 0?n.order_id=e.toString():n.order_id=parseInt(e);let c=this.getSupportedMapping(r,{spot:"spotPrivatePostPrivateGetOrderDetail",margin:"spotPrivatePostPrivateMarginGetOrderDetail",future:"derivativesPrivatePostPrivateGetOrderDetail",swap:"derivativesPrivatePostPrivateGetOrderDetail"});o!==void 0&&(c="spotPrivatePostPrivateMarginGetOrderDetail");const u=await this[c](this.extend(n,d)),h=this.safeValue(u,"result",{}),l=this.safeValue(h,"order_info",h);return this.parseOrder(l,i)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=t.toUpperCase(),d={instrument_name:a.id,side:s.toUpperCase(),type:o,quantity:this.amountToPrecision(e,i)};(o==="LIMIT"||o==="STOP_LIMIT")&&(d.price=this.priceToPrecision(e,n)),this.safeValue(r,"postOnly",!1)&&(d.exec_inst="POST_ONLY",r=this.omit(r,["postOnly"]));const[u,h]=this.handleMarketTypeAndParams("createOrder",a,r);let l=this.getSupportedMapping(u,{spot:"spotPrivatePostPrivateCreateOrder",margin:"spotPrivatePostPrivateMarginCreateOrder",future:"derivativesPrivatePostPrivateCreateOrder",swap:"derivativesPrivatePostPrivateCreateOrder"});const[p,m]=this.customHandleMarginModeAndParams("createOrder",h);p!==void 0&&(l="spotPrivatePostPrivateMarginCreateOrder");const g=await this[l](this.extend(d,m)),y=this.safeValue(g,"result",{});return this.parseOrder(y,a)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();let s;e!==void 0&&(s=this.market(e));const i={},[n,r]=this.handleMarketTypeAndParams("cancelAllOrders",s,t),[a,o]=this.customHandleMarginModeAndParams("cancelAllOrders",r);if(n==="spot"||n==="margin"||a!==void 0){if(e===void 0)throw new Pf(this.id+" cancelAllOrders() requires a symbol argument for "+n+" orders");i.instrument_name=s.id}let d=this.getSupportedMapping(n,{spot:"spotPrivatePostPrivateCancelAllOrders",margin:"spotPrivatePostPrivateMarginCancelAllOrders",future:"derivativesPrivatePostPrivateCancelAllOrders",swap:"derivativesPrivatePostPrivateCancelAllOrders"});return a!==void 0&&(d="spotPrivatePostPrivateMarginCancelAllOrders"),await this[d](this.extend(i,o))}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));const n={},[r,a]=this.handleMarketTypeAndParams("cancelOrder",i,s),[o,d]=this.customHandleMarginModeAndParams("cancelOrder",a);if(r==="spot"||r==="margin"||o!==void 0){if(t===void 0)throw new Pf(this.id+" cancelOrder() requires a symbol argument for "+r+" orders");n.instrument_name=i.id,n.order_id=e.toString()}else n.order_id=parseInt(e);let c=this.getSupportedMapping(r,{spot:"spotPrivatePostPrivateCancelOrder",margin:"spotPrivatePostPrivateMarginCancelOrder",future:"derivativesPrivatePostPrivateCancelOrder",swap:"derivativesPrivatePostPrivateCancelOrder"});o!==void 0&&(c="spotPrivatePostPrivateMarginCancelOrder");const u=await this[c](this.extend(n,d)),h=this.safeValue(u,"result",u);return this.parseOrder(h)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.instrument_name=n.id),s!==void 0&&(r.page_size=s);const[a,o]=this.handleMarketTypeAndParams("fetchOpenOrders",n,i);let d=this.getSupportedMapping(a,{spot:"spotPrivatePostPrivateGetOpenOrders",margin:"spotPrivatePostPrivateMarginGetOpenOrders",future:"derivativesPrivatePostPrivateGetOpenOrders",swap:"derivativesPrivatePostPrivateGetOpenOrders"});const[c,u]=this.customHandleMarginModeAndParams("fetchOpenOrders",o);c!==void 0&&(d="spotPrivatePostPrivateMarginGetOpenOrders");const h=await this[d](this.extend(r,u)),l=this.safeValue(h,"result",{}),p=this.safeValue2(l,"order_list","data",[]);return this.parseOrders(p,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.market(e),n.instrument_name=r.id),t!==void 0){n.start_ts=t;const m=this.sum(t,24*60*60*1e3);n.end_ts=m}s!==void 0&&(n.page_size=s);const[a,o]=this.handleMarketTypeAndParams("fetchMyTrades",r,i);let d=this.getSupportedMapping(a,{spot:"spotPrivatePostPrivateGetTrades",margin:"spotPrivatePostPrivateMarginGetTrades",future:"derivativesPrivatePostPrivateGetTrades",swap:"derivativesPrivatePostPrivateGetTrades"});const[c,u]=this.customHandleMarginModeAndParams("fetchMyTrades",o);c!==void 0&&(d="spotPrivatePostPrivateMarginGetTrades");const h=await this[d](this.extend(n,u)),l=this.safeValue(h,"result",{}),p=this.safeValue2(l,"trade_list","data",[]);return this.parseTrades(p,r,t,s)}parseAddress(e){let t,s,i;return e.indexOf("?")>0?([t,i]=e.split("?"),s=i.split("=")[1]):t=e,[t,s]}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,amount:t,address:s};i!==void 0&&(a.address_tag=i);const o=await this.spotPrivatePostPrivateCreateWithdrawal(this.extend(a,n)),d=this.safeValue(o,"result");return this.parseTransaction(d,r)}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.spotPrivatePostPrivateGetDepositAddress(this.extend(i,t)),r=this.safeValue(n,"result",{}),a=this.safeValue(r,"deposit_address_list",[]);if(a.length===0)throw new l0(this.id+" fetchDepositAddressesByNetwork() generating address...");const o={};for(let d=0;d<a.length;d++){const c=this.safeValue(a,d),u=this.safeString(c,"address"),h=this.safeString(c,"currency"),l=this.safeCurrencyCode(h),[p,m]=this.parseAddress(u);this.checkAddress(p);const g=this.safeString(c,"network"),y=this.safeNetwork(g);o[y]={info:c,currency:l,address:p,tag:m,network:y}}return o}async fetchDepositAddress(e,t={}){const s=this.safeStringUpper(t,"network");t=this.omit(t,["network"]);const i=await this.fetchDepositAddressesByNetwork(e,t);if(s in i)return i[s];{const n=Object.keys(i);return i[n[0]]}}safeNetwork(e){const t={BTC:"BTC",ETH:"ETH",SOL:"SOL",BNB:"BNB",CRONOS:"CRONOS",MATIC:"MATIC",OP:"OP"};return this.safeString(t,e,e)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.currency=n.id),t!==void 0&&(r.start_ts=t),s!==void 0&&(r.page_size=s);const a=await this.spotPrivatePostPrivateGetDepositHistory(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"deposit_list",[]);return this.parseTransactions(d,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.currency=n.id),t!==void 0&&(r.start_ts=t),s!==void 0&&(r.page_size=s);const a=await this.spotPrivatePostPrivateGetWithdrawalHistory(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"withdrawal_list",[]);return this.parseTransactions(d,n,t,s)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e);s=s.toLowerCase(),i=i.toLowerCase();const a=this.safeValue(this.options,"accountsById",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c={currency:r.id,amount:parseFloat(t),from:o,to:d};let u="spotPrivatePostPrivateDerivTransfer";(s==="margin"||i==="margin")&&(u="spotPrivatePostPrivateMarginTransfer");const h=await this[u](this.extend(c,n));return this.parseTransfer(h,r)}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){if(!("direction"in i))throw new Pf(this.id+' fetchTransfers() requires a direction param to be either "IN" or "OUT"');await this.loadMarkets();let n;const r={direction:"OUT"};e!==void 0&&(n=this.currency(e),r.currency=n.id),t!==void 0&&(r.start_ts=t),s!==void 0&&(r.page_size=s);let a="spotPrivatePostPrivateDerivGetTransferHistory";const[o,d]=this.customHandleMarginModeAndParams("fetchTransfers",i);o!==void 0&&(a="spotPrivatePostPrivateMarginGetTransferHistory");const c=await this[a](this.extend(r,d)),u=[];return u.push({response:c}),this.parseTransfers(u,n,t,s,i)}parseTransferStatus(e){const t={COMPLETED:"ok",PROCESSING:"pending"};return this.safeString(t,e,e)}parseTransfer(e,t=void 0){const s=this.safeValue(e,"response",{}),i=this.safeValue(s,"result",{}),n=this.safeValue(i,"transfer_list",[]);let r,a,o,d,c;for(let l=0;l<n.length;l++){const p=n[l];r=this.safeInteger(p,"time"),a=this.safeNumber(p,"amount");const m=this.safeString(p,"currency");o=this.safeCurrencyCode(m),d=this.safeString(p,"information");const g=this.safeString(p,"status");c=this.parseTransferStatus(g)}let u,h;if(d!==void 0){const l=d.split(" "),p=this.safeStringLower(l,0),m=this.safeString(s,"method");p==="from"?(u=this.safeStringLower(l,1),m==="private/margin/get-transfer-history"?h="margin":h="derivative"):p==="to"&&(h=this.safeStringLower(l,1),m==="private/margin/get-transfer-history"?u="margin":u="derivative")}return{info:n,id:this.safeString(s,"id"),timestamp:r,datetime:this.iso8601(r),currency:o,amount:a,fromAccount:u,toAccount:h,status:c}}parseTicker(e,t=void 0){const s=this.safeInteger(e,"t"),i=this.safeString(e,"i");t=this.safeMarket(i,t,"_");const n=t.symbol,r=this.safeString(e,"a"),a=this.safeString(e,"c");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"h"),low:this.safeString(e,"l"),bid:this.safeString(e,"b"),bidVolume:void 0,ask:this.safeString(e,"k"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:a,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"v"),quoteVolume:void 0,info:e},t)}parseTrade(e,t=void 0){const s=this.safeInteger2(e,"t","create_time"),i=this.safeString2(e,"i","instrument_name");t=this.safeMarket(i,t,"_");const n=t.symbol,r=this.safeString2(e,"p","traded_price"),a=this.safeString2(e,"q","traded_quantity");let o=this.safeString2(e,"s","side");o!==void 0&&(o=o.toLowerCase());const d=this.safeString2(e,"d","trade_id"),c=this.safeStringLower2(e,"liquidity_indicator","taker_side"),u=this.safeString(e,"order_id");let h,l=this.safeString2(e,"fee","fees");if(l!==void 0){this.safeValue(t,"contract",!1)&&(l=Ck.stringNeg(l));let m;t.spot?m=this.safeString(e,"fee_currency"):t.linear&&(m=t.quote),h={currency:m,cost:l}}return this.safeTrade({info:e,id:d,timestamp:s,datetime:this.iso8601(s),symbol:n,side:o,price:r,amount:a,cost:void 0,order:u,takerOrMaker:c,type:void 0,fee:h},t)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"t"),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}parseOrderStatus(e){const t={ACTIVE:"open",CANCELED:"canceled",FILLED:"closed",REJECTED:"rejected",EXPIRED:"expired"};return this.safeString(t,e,e)}parseTimeInForce(e){const t={GOOD_TILL_CANCEL:"GTC",IMMEDIATE_OR_CANCEL:"IOC",FILL_OR_KILL:"FOK"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"create_time"),i=this.safeInteger(e,"update_time"),n=this.safeString(e,"instrument_name"),r=this.safeSymbol(n,t),a=this.safeString(e,"quantity"),o=this.safeString(e,"cumulative_quantity"),d=this.parseOrderStatus(this.safeString(e,"status")),c=this.safeString(e,"order_id"),u=this.safeString(e,"client_oid"),h=this.safeString2(e,"price","limit_price"),l=this.safeString(e,"avg_price"),p=this.safeStringLower2(e,"type","order_type"),m=this.safeStringLower(e,"side"),g=this.parseTimeInForce(this.safeString(e,"time_in_force")),y=this.safeString(e,"exec_inst");let b;y!==void 0&&(b=y==="POST_ONLY");const w=this.safeString(e,"cumulative_value"),S=this.safeString(e,"cumulative_fee");let k;if(S!==void 0){const T=this.safeString(e,"fee_instrument_name");k={cost:S,currency:this.safeCurrencyCode(T)}}return this.safeOrder({info:e,id:c,clientOrderId:u,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:i,status:d,symbol:r,type:p,timeInForce:g,postOnly:b,side:m,price:h,amount:a,filled:o,remaining:void 0,cost:w,fee:k,average:l,trades:[]},t)}parseDepositStatus(e){const t={0:"pending",1:"ok",2:"failed",3:"pending"};return this.safeString(t,e,e)}parseWithdrawalStatus(e){const t={0:"pending",1:"pending",2:"failed",3:"pending",4:"failed",5:"ok",6:"canceled"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){let s;const i=this.safeString(e,"status");let n;"client_wid"in e?(s="withdrawal",n=this.parseWithdrawalStatus(i)):(s="deposit",n=this.parseDepositStatus(i));const r=this.safeString(e,"id"),a=this.safeString(e,"address"),[o,d]=this.parseAddress(a),c=this.safeString(e,"currency"),u=this.safeCurrencyCode(c,t),h=this.safeInteger(e,"create_time"),l=this.safeNumber(e,"amount"),p=this.safeString(e,"txid"),m=this.safeNumber(e,"fee");let g;m!==void 0&&(g={currency:u,cost:m});const y=this.safeInteger(e,"update_time");return{info:e,id:r,txid:p,timestamp:h,datetime:this.iso8601(h),network:void 0,address:o,addressTo:o,addressFrom:void 0,tag:d,tagTo:d,tagFrom:void 0,type:s,amount:l,currency:u,status:n,updated:y,internal:void 0,fee:g}}async repayMargin(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.currency(e),r={currency:n.id,amount:this.currencyToPrecision(e,t)},a=await this.spotPrivatePostPrivateMarginRepay(this.extend(r,i)),o=this.parseMarginLoan(a,n);return this.extend(o,{amount:t})}async borrowMargin(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.currency(e),r={currency:n.id,amount:this.currencyToPrecision(e,t)},a=await this.spotPrivatePostPrivateMarginBorrow(this.extend(r,i)),o=this.parseMarginLoan(a,n);return this.extend(o,{amount:t})}parseMarginLoan(e,t=void 0){return{id:this.safeInteger(e,"id"),currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a,o;t!==void 0&&(a=this.market(t)),e!==void 0&&(o=this.currency(e),r.currency=o.id),s!==void 0&&(r.start_ts=s),i!==void 0&&(r.page_size=i);const d=await this.spotPrivatePostPrivateMarginGetInterestHistory(this.extend(r,n)),c=this.safeValue(d,"result",{}),u=this.safeValue(c,"list",[]);let h;for(let l=0;l<u.length;l++)h=this.parseBorrowInterests(u,a);return this.filterByCurrencySinceLimit(h,e,s,i)}parseBorrowInterest(e,t=void 0){const s=this.safeInteger(e,"time");let i;return t!==void 0&&(i=t.symbol),{symbol:i,marginMode:void 0,currency:this.safeCurrencyCode(this.safeString(e,"currency")),interest:this.safeNumber(e,"interest"),interestRate:this.safeNumber(e,"interest_rate"),amountBorrowed:void 0,timestamp:s,datetime:this.iso8601(s),info:e}}async fetchBorrowRates(e={}){await this.loadMarkets();const t=await this.spotPrivatePostPrivateMarginGetUserConfig(e),s=this.safeValue(t,"result",{}),i=this.safeValue(s,"currency_configs",[]);return this.parseBorrowRates(i,"currency")}parseBorrowRates(e,t){const s=this.milliseconds(),i=[];for(let n=0;n<e.length;n++){const r=e[n];i.push({currency:this.safeCurrencyCode(this.safeString(r,"currency")),rate:this.safeNumber(r,"hourly_rate"),period:36e5,timestamp:s,datetime:this.iso8601(s),info:r})}return i}customHandleMarginModeAndParams(e,t={}){const s=this.safeString(this.options,"defaultType"),i=this.safeValue(t,"margin",!1);t=this.omit(t,"margin");let n;if([n,t]=this.handleMarginModeAndParams(e,t),n!==void 0){if(n!=="cross")throw new _k(this.id+" only cross margin is supported")}else(s==="margin"||i===!0)&&(n="cross");return[n,t]}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const[a,o]=t;let d=this.urls.api[a]+"/"+e;const c=this.omit(i,this.extractParams(e));if(o==="public")Object.keys(c).length&&(d+="?"+this.urlencode(c));else{this.checkRequiredCredentials();const u=this.nonce().toString(),h=this.extend({},i),l=this.keysort(h),p=Object.keys(l);let m="";for(let w=0;w<p.length;w++)m=m+p[w].toString()+h[p[w]].toString();const g=e+u+this.apiKey+m+u,y=this.hmac(this.encode(g),this.encode(this.secret)),b=p.length;if(r=this.json({id:u,method:e,params:i,api_key:this.apiKey,sig:y,nonce:u}),b===0){const w="{}",S="[]";r=r.replace(S,w)}n={"Content-Type":"application/json"}}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){const c=this.safeString(a,"code");if(c!=="0"){const u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),new l0(this.id+" "+r)}}};const jR=me,{BadSymbol:WR,ExchangeError:Af,ArgumentsRequired:m0,ExchangeNotAvailable:g0,InsufficientFunds:zR,OrderNotFound:Mk,InvalidOrder:$r,DDoSProtection:KR,InvalidNonce:XR,AuthenticationError:mc,BadRequest:y0}=oe,{TICK_SIZE:YR}=pe,rr=ke;var V_=class extends jR{describe(){return this.deepExtend(super.describe(),{id:"currencycom",name:"Currency.com",countries:["BY"],rateLimit:100,certified:!1,pro:!0,version:"v2",has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!1,option:!1,addMargin:void 0,cancelAllOrders:void 0,cancelOrder:!0,cancelOrders:void 0,createDepositAddress:void 0,createLimitOrder:!0,createMarketOrder:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:"emulated",fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowRate:void 0,fetchBorrowRateHistory:void 0,fetchBorrowRates:void 0,fetchBorrowRatesPerSymbol:void 0,fetchCanceledOrders:void 0,fetchClosedOrder:void 0,fetchClosedOrders:void 0,fetchCurrencies:!0,fetchDeposit:void 0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchL2OrderBook:!0,fetchLedger:!0,fetchLedgerEntry:!1,fetchLeverage:!0,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrder:void 0,fetchOpenOrders:!0,fetchOrder:void 0,fetchOrderBook:!0,fetchOrderBooks:void 0,fetchOrders:void 0,fetchOrderTrades:void 0,fetchPosition:void 0,fetchPositionMode:!1,fetchPositions:!0,fetchPositionsRisk:void 0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTradingLimits:void 0,fetchTransactionFee:void 0,fetchTransactionFees:void 0,fetchTransactions:!0,fetchTransfers:void 0,fetchWithdrawal:void 0,fetchWithdrawals:!0,reduceMargin:void 0,setLeverage:void 0,setMarginMode:void 0,setPositionMode:void 0,signIn:void 0,transfer:void 0,withdraw:void 0},timeframes:{"1m":"1m","5m":"5m","10m":"10m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","1d":"1d","1w":"1w"},hostname:"backend.currency.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/83718672-36745c00-a63e-11ea-81a9-677b1f789a4d.jpg",api:{public:"https://api-adapter.{hostname}/api",private:"https://api-adapter.{hostname}/api",marketcap:"https://marketcap.{hostname}/api"},test:{public:"https://demo-api-adapter.{hostname}/api",private:"https://demo-api-adapter.{hostname}/api"},www:"https://www.currency.com",referral:"https://currency.com/trading/signup?c=362jaimv&pid=referral",doc:["https://currency.com/api"],fees:"https://currency.com/fees-charges"},api:{public:{get:{"v1/time":1,"v1/exchangeInfo":1,"v1/depth":1,"v1/aggTrades":1,"v1/klines":1,"v1/ticker/24hr":1,"v2/time":1,"v2/exchangeInfo":1,"v2/depth":1,"v2/aggTrades":1,"v2/klines":1,"v2/ticker/24hr":1}},marketcap:{get:{"v1/assets":1,"v1/candles":1,"v1/orderbook":1,"v1/summary":1,"v1/ticker":1,"v1/token/assets":1,"v1/token/orderbook":1,"v1/token/summary":1,"v1/token/ticker":1,"v1/token/trades":1,"v1/token_crypto/OHLC":1,"v1/token_crypto/assets":1,"v1/token_crypto/orderbook":1,"v1/token_crypto/summary":1,"v1/token_crypto/ticker":1,"v1/token_crypto/trades":1,"v1/trades":1}},private:{get:{"v1/account":1,"v1/currencies":1,"v1/deposits":1,"v1/depositAddress":1,"v1/ledger":1,"v1/leverageSettings":1,"v1/myTrades":1,"v1/openOrders":1,"v1/tradingPositions":1,"v1/tradingPositionsHistory":1,"v1/transactions":1,"v1/withdrawals":1,"v2/account":1,"v2/currencies":1,"v2/deposits":1,"v2/depositAddress":1,"v2/ledger":1,"v2/leverageSettings":1,"v2/myTrades":1,"v2/openOrders":1,"v2/tradingPositions":1,"v2/tradingPositionsHistory":1,"v2/transactions":1,"v2/withdrawals":1},post:{"v1/order":1,"v1/updateTradingPosition":1,"v1/updateTradingOrder":1,"v1/closeTradingPosition":1,"v2/order":1,"v2/updateTradingPosition":1,"v2/updateTradingOrder":1,"v2/closeTradingPosition":1},delete:{"v1/order":1,"v2/order":1}}},fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,taker:this.parseNumber("0.002"),maker:this.parseNumber("0.002")}},precisionMode:YR,options:{defaultTimeInForce:"GTC",warnOnFetchOpenOrdersWithoutSymbol:!0,recvWindow:5*1e3,timeDifference:0,adjustForTimeDifference:!1,parseOrderToPrecision:!1,newOrderRespType:{market:"FULL",limit:"RESULT",stop:"RESULT"},leverage_markets_suffix:"_LEVERAGE",collateralCurrencies:["USD","EUR","USDT"]},exceptions:{broad:{"FIELD_VALIDATION_ERROR Cancel is available only for LIMIT order":$r,"API key does not exist":mc,"Order would trigger immediately.":$r,"Account has insufficient balance for requested action.":zR,"Rest API trading is not enabled.":g0,"Combination of parameters invalid":y0,"Invalid limit price":y0,"Only leverage symbol allowed here:":WR,"market data service is not available":g0,"your time is ahead of server":XR},exact:{"-1000":g0,"-1013":$r,"-1022":mc,"-1030":$r,"-1100":$r,"-1104":Af,"-1025":mc,"-1128":y0,"-2010":Af,"-2011":Mk,"-2013":Mk,"-2014":mc,"-2015":mc}},commonCurrencies:{ACN:"Accenture",AMC:"AMC Entertainment Holdings",BNS:"Bank of Nova Scotia",CAR:"Avis Budget Group Inc",CLR:"Continental Resources",EDU:"New Oriental Education & Technology Group Inc",ETN:"Eaton",FOX:"Fox Corporation",GM:"General Motors Co",IQ:"iQIYI",OSK:"Oshkosh",PLAY:"Dave & Buster's Entertainment"}})}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchTime(e={}){const t=await this.publicGetV2Time(e);return this.safeInteger(t,"serverTime")}async fetchCurrencies(e={}){if(!this.checkRequiredCredentials(!1))return;const t=await this.privateGetV2Currencies(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"displaySymbol"),a=this.safeCurrencyCode(r),o=this.safeNumber(n,"commissionFixed");s[a]={id:r,code:a,address:this.safeString(n,"baseAddress"),type:this.safeStringLower(n,"type"),name:this.safeString(n,"name"),active:void 0,deposit:void 0,withdraw:void 0,fee:o,precision:this.parseNumber(this.parsePrecision(this.safeString(n,"precision"))),limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.safeNumber(n,"minWithdrawal"),max:this.safeNumber(n,"maxWithdrawal")},deposit:{min:this.safeNumber(n,"minDeposit"),max:void 0}},info:n}}return s}async fetchMarkets(e={}){const t=await this.publicGetV2ExchangeInfo(e);this.options.adjustForTimeDifference&&await this.loadTimeDifference();const s=this.safeValue(t,"symbols",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeString(r,"baseAsset"),d=this.safeString(r,"quoteAsset"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d);let h=c+"/"+u;const l=this.safeString(r,"marketType"),p=l==="SPOT",m=!1,g=l==="LEVERAGE",y=g;g&&(h=h.replace(this.options.leverage_markets_suffix,""),h+=":"+u);const b=this.safeString(r,"status")==="TRADING",w=this.safeString2(r,"exchangeFee","tradingFee");let S=this.safeString(r,"makerFee",w),k=this.safeString(r,"takerFee",w);S=rr.stringDiv(S,"100"),k=rr.stringDiv(k,"100");const T=this.safeValue(r,"filters",[]),I=this.indexBy(T,"filterType");let _,N,M=this.safeNumber(r,"tickSize");if("PRICE_FILTER"in I){const q=this.safeValue(I,"PRICE_FILTER",{});M=this.safeNumber(q,"tickSize"),_=this.safeNumber(q,"minPrice");const R=this.safeString(q,"maxPrice");R!==void 0&&rr.stringGt(R,"0")&&(N=R)}let x=this.parseNumber(this.parsePrecision(this.safeString(r,"baseAssetPrecision"))),v={min:void 0,max:void 0};if("LOT_SIZE"in I){const q=this.safeValue(I,"LOT_SIZE",{});x=this.safeNumber(q,"stepSize"),v={min:this.safeNumber(q,"minQty"),max:this.safeNumber(q,"maxQty")}}let O={min:void 0,max:void 0};if("MARKET_LOT_SIZE"in I){const q=this.safeValue(I,"MARKET_LOT_SIZE",{});O={min:this.safeNumber(q,"minQty"),max:this.safeNumber(q,"maxQty")}}let A;if("MIN_NOTIONAL"in I){const q=this.safeValue(I,"MIN_NOTIONAL",{});A=this.safeNumber(q,"minNotional")}const V=g||m;i.push({id:a,symbol:h,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:l,spot:p,margin:y,swap:g,future:m,option:!1,active:b,contract:V,linear:V?!0:void 0,inverse:void 0,taker:this.parseNumber(k),maker:this.parseNumber(S),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:x,price:M},limits:{leverage:{min:void 0,max:void 0},amount:v,market:O,price:{min:_,max:this.parseNumber(N)},cost:{min:A,max:void 0}},info:r})}return i}async fetchAccounts(e={}){const t=await this.privateGetV2Account(e),s=this.safeValue(t,"balances",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeInteger(r,"accountId"),o=this.safeString(r,"asset"),d=this.safeCurrencyCode(o);i.push({id:a,type:void 0,currency:d,info:r})}return i}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetV2Account(e),s=this.safeNumber(t,"makerCommission"),i=this.safeNumber(t,"takerCommission"),n={};for(let r=0;r<this.symbols.length;r++){const a=this.symbols[r];n[a]={info:t,symbol:a,maker:s,taker:i,percentage:!0,tierBased:!1}}return n}parseBalance(e,t=void 0){const s={info:e},i=this.safeValue(e,"balances",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"asset"),o=this.safeCurrencyCode(a),d=this.account();d.free=this.safeString(r,"free"),d.used=this.safeString(r,"locked"),s[o]=d}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetV2Account(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={symbol:this.market(e).id};t!==void 0&&(n.limit=t);const r=await this.publicGetV2Depth(this.extend(n,s)),a=this.parseOrderBook(r,e);return a.nonce=this.safeInteger(r,"lastUpdateId"),a}parseTicker(e,t=void 0){const s=this.safeInteger2(e,"closeTime","timestamp"),i=this.safeString2(e,"symbol","symbolName");t=this.safeMarket(i,t,"/");const n=this.safeString(e,"lastPrice");return this.safeTicker({symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"highPrice"),low:this.safeString(e,"lowPrice"),bid:this.safeString2(e,"bidPrice","bid"),bidVolume:this.safeString(e,"bidQty"),ask:this.safeString2(e,"askPrice","ofr"),askVolume:this.safeString(e,"ofrQty"),vwap:this.safeString(e,"weightedAvgPrice"),open:this.safeString(e,"openPrice"),close:n,last:n,previousClose:this.safeString(e,"prevClosePrice"),change:this.safeString(e,"priceChange"),percentage:this.safeString(e,"priceChangePercent"),average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:this.safeString(e,"quoteVolume"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetV2Ticker24hr(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetV2Ticker24hr(t);return this.parseTickers(s,e)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,interval:this.timeframes[t]};s!==void 0&&(a.startTime=s),i!==void 0&&(a.limit=i);const o=await this.publicGetV2Klines(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}parseTrade(e,t=void 0){const s=this.safeInteger2(e,"T","time"),i=this.safeString2(e,"p","price"),n=this.safeString2(e,"q","qty"),r=this.safeString2(e,"a","id");let a;const o=this.safeString(e,"orderId");let d;"m"in e?(a=e.m?"sell":"buy",d="taker"):"isBuyer"in e&&(a=e.isBuyer?"buy":"sell",d=e.isMaker?"maker":"taker");let c;"commission"in e&&(c={cost:this.safeString(e,"commission"),currency:this.safeCurrencyCode(this.safeString(e,"commissionAsset"))});const u=this.safeString(e,"symbol"),h=this.safeSymbol(u,t);return this.safeTrade({id:r,order:o,timestamp:s,datetime:this.iso8601(s),symbol:h,type:void 0,takerOrMaker:d,side:a,price:i,amount:n,cost:void 0,fee:c,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s),t!==void 0&&(r.startTime=t);const a=await this.publicGetV2AggTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t,"/"),n=this.safeString(e,"orderId"),r=this.safeString(e,"price"),a=this.safeString(e,"origQty"),o=this.safeString(e,"executedQty"),d=rr.stringAbs(o),c=this.parseOrderStatus(this.safeString(e,"status")),u=this.parseOrderTimeInForce(this.safeString(e,"timeInForce")),h=this.parseOrderType(this.safeString(e,"type")),l=this.parseOrderSide(this.safeString(e,"side")),p=this.safeInteger2(e,"time","transactTime"),m=this.safeValue(e,"fills");return this.safeOrder({info:e,id:n,timestamp:p,datetime:this.iso8601(p),lastTradeTimestamp:void 0,symbol:i,type:h,timeInForce:u,side:l,price:r,stopPrice:void 0,amount:a,cost:void 0,average:void 0,filled:d,remaining:void 0,status:c,fee:void 0,trades:m},t)}parseOrderStatus(e){const t={NEW:"open",PARTIALLY_FILLED:"open",FILLED:"closed",CANCELED:"canceled",PENDING_CANCEL:"canceling",REJECTED:"rejected",EXPIRED:"expired"};return this.safeString(t,e,e)}parseOrderType(e){const t={MARKET:"market",LIMIT:"limit",STOP:"stop"};return this.safeString(t,e,e)}parseOrderTimeInForce(e){const t={GTC:"GTC",FOK:"FOK",IOC:"IOC"};return this.safeString(t,e,e)}parseOrderSide(e){const t={BUY:"buy",SELL:"sell"};return this.safeString(t,e,e)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o;if(a.margin&&(o=this.safeString(this.options,"accountId"),o=this.safeString(r,"accountId",o),o===void 0))throw new m0(this.id+" createOrder() requires an accountId parameter or an exchange.options['accountId'] option for "+a.type+" markets");const d=this.safeValue(this.options.newOrderRespType,t,"RESULT"),c={symbol:a.id,quantity:this.amountToPrecision(e,i),type:t.toUpperCase(),side:s.toUpperCase(),newOrderRespType:d};if(t==="limit")c.price=this.priceToPrecision(e,n),c.timeInForce=this.options.defaultTimeInForce;else if(t==="stop")c.type="STOP",c.price=this.priceToPrecision(e,n);else if(t==="market"){const h=this.safeValue2(r,"triggerPrice","stopPrice");r=this.omit(r,["triggerPrice","stopPrice"]),h!==void 0&&(c.type="STOP",c.price=this.priceToPrecision(e,h))}const u=await this.privatePostV2Order(this.extend(c,r));return this.parseOrder(u,a)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};if(e!==void 0)n=this.market(e),r.symbol=n.id;else if(this.options.warnOnFetchOpenOrdersWithoutSymbol){const d=this.symbols.length,c=parseInt(d/2);throw new Af(this.id+" fetchOpenOrders() WARNING: fetching open orders without specifying a symbol is rate-limited to one call per "+c.toString()+" seconds. Do not call this method frequently to avoid ban. Set "+this.id+'.options["warnOnFetchOpenOrdersWithoutSymbol"] = false to suppress this warning message.')}const a=await this.privateGetV2OpenOrders(this.extend(r,i));return this.parseOrders(a,n,t,s,i)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new m0(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=this.safeValue(s,"origClientOrderId"),r={symbol:i.id};n===void 0?r.orderId=e:r.origClientOrderId=n;const a=await this.privateDeleteV2Order(this.extend(r,s));return this.parseOrder(a,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new m0(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s);const a=await this.privateGetV2MyTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByMethod("privateGetV2Deposits",e,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByMethod("privateGetV2Withdrawals",e,t,s,i)}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByMethod("privateGetV2Transactions",e,t,s,i)}async fetchTransactionsByMethod(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a;t!==void 0&&(a=this.currency(t)),s!==void 0&&(r.startTime=s),i!==void 0&&(r.limit=i);const o=await this[e](this.extend(r,n));return this.parseTransactions(o,a,s,i,n)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"blockchainTransactionHash"),n=this.safeNumber(e,"amount"),r=this.safeInteger(e,"timestamp"),a=this.safeString(e,"currency"),o=this.safeCurrencyCode(a,t),d=this.parseTransactionStatus(this.safeString(e,"state")),c=this.parseTransactionType(this.safeString(e,"type")),u=this.safeString(e,"commission");let h;return u!==void 0&&(h={currency:o,cost:u}),{id:s,txid:i,timestamp:r,datetime:this.iso8601(r),network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,type:c,amount:n,currency:o,status:d,updated:void 0,comment:void 0,fee:h,info:e}}parseTransactionStatus(e){const t={APPROVAL:"pending",PROCESSED:"ok"};return this.safeString(t,e,e)}parseTransactionType(e){const t={deposit:"deposit",withdrawal:"withdrawal"};return this.safeString(t,e,e)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e)),t!==void 0&&(n.startTime=t),s!==void 0&&(n.limit=s);const a=await this.privateGetV2Ledger(this.extend(n,i));return this.parseLedger(a,r,t,s)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"amount"),n=rr.stringAbs(i),r=this.safeInteger(e,"timestamp"),a=this.safeString(e,"currency"),o=this.safeCurrencyCode(a,t),d=this.safeString(e,"commission");let c;d!==void 0&&(c={currency:o,cost:d});const u=rr.stringLt(i,"0")?"out":"in";return{id:s,timestamp:r,datetime:this.iso8601(r),direction:u,account:void 0,referenceId:this.safeString(e,"blockchainTransactionHash"),referenceAccount:void 0,type:this.parseLedgerEntryType(this.safeString(e,"type")),currency:o,amount:n,before:void 0,after:this.safeString(e,"balance"),status:this.parseLedgerEntryStatus(this.safeString(e,"status")),fee:c,info:e}}parseLedgerEntryStatus(e){const t={APPROVAL:"pending",PROCESSED:"ok",CANCELLED:"canceled"};return this.safeString(t,e,e)}parseLedgerEntryType(e){const t={deposit:"transaction",withdrawal:"transaction",exchange_commission:"fee"};return this.safeString(t,e,e)}async fetchLeverage(e,t={}){await this.loadMarkets();const i={symbol:this.market(e).id},n=await this.privateGetV2LeverageSettings(this.extend(i,t));return this.safeNumber(n,"value")}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={coin:s.id},n=await this.privateGetV2DepositAddress(this.extend(i,t));return this.parseDepositAddress(n,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address");return this.checkAddress(s),t=this.safeCurrency(void 0,t),{currency:t.code,address:s,tag:void 0,network:void 0,info:e}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/"+e;if(e==="historicalTrades"&&(n={"X-MBX-APIKEY":this.apiKey}),t==="private"){this.checkRequiredCredentials();let o=this.urlencode(this.extend({timestamp:this.nonce(),recvWindow:this.options.recvWindow},i));const d=this.hmac(this.encode(o),this.encode(this.secret));o+="&signature="+d,n={"X-MBX-APIKEY":this.apiKey},s==="GET"||s==="DELETE"?a+="?"+o:(r=o,n["Content-Type"]="application/x-www-form-urlencoded")}else Object.keys(i).length&&(a+="?"+this.urlencode(i));return a=this.implodeHostname(a),{url:a,method:s,body:r,headers:n}}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetV2TradingPositions(t),i=this.safeValue(s,"positions",[]);return this.parsePositions(i,e)}parsePosition(e,t=void 0){t=this.safeMarket(this.safeString(e,"symbol"),t);const s=t.symbol,i=this.safeNumber(e,"createdTimestamp"),n=this.safeString(e,"openQuantity"),r=rr.stringGt(n,"0")?"long":"short",a=rr.stringAbs(n),o=this.safeNumber(e,"openPrice"),d=this.safeNumber(e,"upl"),c=this.safeString(e,"margin"),u=rr.stringDiv("1",c);return{symbol:s,timestamp:i,datetime:this.iso8601(i),contracts:this.parseNumber(a),contractSize:void 0,entryPrice:o,collateral:void 0,side:r,unrealizedProfit:d,leverage:u,percentage:void 0,marginMode:void 0,notional:void 0,markPrice:void 0,liquidationPrice:void 0,initialMargin:void 0,initialMarginPercentage:void 0,maintenanceMargin:this.parseNumber(c),maintenanceMarginPercentage:void 0,marginRatio:void 0,info:e,id:void 0}}handleErrors(e,t,s,i,n,r,a,o,d){if(e===418||e===429)throw new KR(this.id+" "+e.toString()+" "+t+" "+r);if(e>=400){if(r.indexOf("Price * QTY is zero or less")>=0)throw new $r(this.id+" order cost = amount * price is zero or less "+r);if(r.indexOf("LOT_SIZE")>=0)throw new $r(this.id+" order amount should be evenly divisible by lot size "+r);if(r.indexOf("PRICE_FILTER")>=0)throw new $r(this.id+" order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid float value in general, use this.priceToPrecision (symbol, amount) "+r)}if(a===void 0)return;const c=this.safeString(a,"code");if(c!==void 0&&c!=="0"){const u=this.id+" "+this.json(a);this.throwExactlyMatchedException(this.exceptions.exact,c,u);const h=this.safeString(a,"msg");throw this.throwBroadlyMatchedException(this.exceptions.broad,h,u),new Af(u)}}};const QR=me,{ExchangeError:ZR,InsufficientFunds:JR,BadRequest:Pk,BadSymbol:eF,InvalidOrder:gc,AuthenticationError:Ak,ArgumentsRequired:Bk,OrderNotFound:tF,ExchangeNotAvailable:sF}=oe,{TICK_SIZE:iF}=pe;var nF=class extends QR{describe(){return this.deepExtend(super.describe(),{id:"delta",name:"Delta Exchange",countries:["VC"],rateLimit:300,version:"v2",has:{CORS:void 0,spot:!0,margin:void 0,swap:void 0,future:void 0,option:void 0,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,editOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:void 0,fetchDepositAddress:!0,fetchDeposits:void 0,fetchLedger:!0,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrderBook:!0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTransfer:void 0,fetchTransfers:void 0,fetchWithdrawal:void 0,fetchWithdrawals:void 0,transfer:!1,withdraw:!1},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","1d":"1d","7d":"7d","1w":"1w","2w":"2w","1M":"30d"},urls:{logo:"https://user-images.githubusercontent.com/1294454/99450025-3be60a00-2931-11eb-9302-f4fd8d8589aa.jpg",test:{public:"https://testnet-api.delta.exchange",private:"https://testnet-api.delta.exchange"},api:{public:"https://api.delta.exchange",private:"https://api.delta.exchange"},www:"https://www.delta.exchange",doc:["https://docs.delta.exchange"],fees:"https://www.delta.exchange/fees",referral:"https://www.delta.exchange/app/signup/?code=IULYNB"},api:{public:{get:["assets","settings","indices","products","tickers","tickers/{symbol}","l2orderbook/{symbol}","trades/{symbol}","history/candles","history/sparklines"]},private:{get:["orders","orders/leverage","positions","positions/margined","orders/history","fills","fills/history/download/csv","wallet/balances","wallet/transactions","wallet/transactions/download","deposits/address"],post:["orders","orders/batch","orders/leverage","positions/change_margin"],put:["orders","orders/batch"],delete:["orders","orders/all","orders/batch"]}},fees:{trading:{tierBased:!0,percentage:!0,taker:.15/100,maker:.1/100,tiers:{taker:[[0,.15/100],[100,.13/100],[250,.13/100],[1e3,.1/100],[5e3,.09/100],[1e4,.075/100],[2e4,.065/100]],maker:[[0,.1/100],[100,.1/100],[250,.09/100],[1e3,.075/100],[5e3,.06/100],[1e4,.05/100],[2e4,.05/100]]}}},precisionMode:iF,requiredCredentials:{apiKey:!0,secret:!1},exceptions:{exact:{insufficient_margin:JR,order_size_exceed_available:gc,risk_limits_breached:Pk,invalid_contract:eF,immediate_liquidation:gc,out_of_bankruptcy:gc,self_matching_disrupted_post_only:gc,immediate_execution_post_only:gc,bad_schema:Pk,invalid_api_key:Ak,invalid_signature:Ak,open_order_not_found:tF,unavailable:sF},broad:{}}})}async fetchTime(e={}){const t=await this.publicGetSettings(e),s=this.safeValue(t,"result",{});return this.safeIntegerProduct(s,"server_time",.001)}async fetchStatus(e={}){const t=await this.publicGetSettings(e),s=this.safeValue(t,"result",{}),n=this.safeString(s,"under_maintenance")==="true"?"maintenance":"ok",r=this.safeIntegerProduct(s,"server_time",.001,this.milliseconds());return{status:n,updated:r,eta:void 0,url:void 0,info:t}}async fetchCurrencies(e={}){const t=await this.publicGetAssets(e),s=this.safeValue(t,"result",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeInteger(r,"id"),d=this.safeCurrencyCode(a),c=this.safeString(r,"deposit_status"),u=this.safeString(r,"withdrawal_status"),h=c==="enabled",l=u==="enabled",p=h&&l;i[d]={id:a,numericId:o,code:d,name:this.safeString(r,"name"),info:r,active:p,deposit:h,withdraw:l,fee:this.safeNumber(r,"base_withdrawal_fee"),precision:this.parseNumber(this.parsePrecision(this.safeString(r,"precision"))),limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.safeNumber(r,"min_withdrawal_amount"),max:void 0}}}}return i}async loadMarkets(e=!1,t={}){const s=await super.loadMarkets(e,t);return(this.safeValue(this.options,"currenciesByNumericId")===void 0||e)&&(this.options.currenciesByNumericId=this.indexBy(this.currencies,"numericId")),(this.safeValue(this.options,"marketsByNumericId")===void 0||e)&&(this.options.marketsByNumericId=this.indexBy(this.markets,"numericId")),s}async fetchMarkets(e={}){const t=await this.publicGetProducts(e),s=this.safeValue(t,"result",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n];let a=this.safeString(r,"contract_type");const o=this.safeValue(r,"quoting_asset",{}),d=this.safeValue(r,"underlying_asset",{}),c=this.safeValue(r,"settling_asset"),u=this.safeValue(r,"product_specs",{}),h=this.safeString(d,"symbol"),l=this.safeString(o,"symbol"),p=this.safeString(c,"symbol"),m=this.safeString(r,"symbol"),g=this.safeInteger(r,"id"),y=this.safeCurrencyCode(h),b=this.safeCurrencyCode(l),w=this.safeCurrencyCode(p),S=a==="call_options",k=a==="put_options",T=a==="move_options",I=a==="spot",_=a==="perpetual_futures",N=a==="futures",M=S||k||T,x=this.safeString(r,"strike_price"),v=this.safeString(r,"settlement_time"),O=this.parse8601(v),A=this.safeNumber(r,"contract_value");let V;I?V=this.parseNumber(this.parsePrecision(this.safeString(u,"underlying_precision"))):V=this.parseNumber("1");const q=w===y;let R,H=y+"/"+b;if(_||N||M)if(H=H+":"+w,N||M)if(H=H+"-"+this.yymmdd(O),M){a="option";let P="C";R="call",k?(P="P",R="put"):T&&(P="M",R="move"),H=H+":"+x+":"+P}else a="future";else a="swap";else H=m;const F=this.safeString(r,"state");i.push({id:m,numericId:g,symbol:H,base:y,quote:b,settle:w,baseId:h,quoteId:l,settleId:p,type:a,spot:I,margin:I?void 0:!1,swap:_,future:N,option:M,active:F==="live",contract:!I,linear:I?void 0:q,inverse:I?void 0:!q,taker:this.safeNumber(r,"taker_commission_rate"),maker:this.safeNumber(r,"maker_commission_rate"),contractSize:A,expiry:O,expiryDatetime:v,strike:this.parseNumber(x),optionType:R,precision:{amount:V,price:this.safeNumber(r,"tick_size")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.parseNumber("1"),max:this.safeNumber(r,"position_size_limit")},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(r,"min_size"),max:void 0}},info:r})}return i}parseTicker(e,t=void 0){const s=this.safeIntegerProduct(e,"timestamp",.001),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.safeString(e,"close"),a=this.safeString(e,"open"),o=this.safeString(e,"volume"),d=this.safeString(e,"turnover");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:a,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:o,quoteVolume:d,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetTickersSymbol(this.extend(i,t)),r=this.safeValue(n,"result",{});return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTickers(t),i=this.safeValue(s,"result",[]),n={};for(let r=0;r<i.length;r++){const a=this.parseTicker(i[r]),o=a.symbol;n[o]=a}return this.filterByArray(n,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.depth=t);const r=await this.publicGetL2orderbookSymbol(this.extend(n,s)),a=this.safeValue(r,"result",{});return this.parseOrderBook(a,i.symbol,void 0,"buy","sell","price","size")}parseTrade(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"order_id");let n=this.parse8601(this.safeString(e,"created_at"));n=this.safeIntegerProduct(e,"timestamp",.001,n);const r=this.safeString(e,"price"),a=this.safeString(e,"size"),o=this.safeValue(e,"product",{}),d=this.safeString(o,"symbol"),c=this.safeSymbol(d,t),u=this.safeString(e,"seller_role");let h=this.safeString(e,"side");h===void 0&&(u==="taker"?h="sell":u==="maker"&&(h="buy"));const l=this.safeString(e,"role"),p=this.safeValue(e,"meta_data",{});let m=this.safeString(p,"order_type");m!==void 0&&(m=m.replace("_order",""));const g=this.safeString(e,"commission");let y;if(g!==void 0){const b=this.safeValue(o,"settling_asset",{}),w=this.safeString(b,"symbol"),S=this.safeCurrencyCode(w);y={cost:g,currency:S}}return this.safeTrade({id:s,order:i,timestamp:n,datetime:this.iso8601(n),symbol:c,type:m,side:h,price:r,amount:a,cost:void 0,takerOrMaker:l,fee:y,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.publicGetTradesSymbol(this.extend(r,i)),o=this.safeValue(a,"result",[]);return this.parseTrades(o,n,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"time"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,resolution:this.timeframes[t]},o=this.parseTimeframe(t);if(i=i||2e3,s===void 0){const u=this.seconds();a.end=u,a.start=u-i*o}else{const u=parseInt(s/1e3);a.start=u,a.end=this.sum(u,i*o)}const d=await this.publicGetHistoryCandles(this.extend(a,n)),c=this.safeValue(d,"result",[]);return this.parseOHLCVs(c,r,t,s,i)}parseBalance(e){const t=this.safeValue(e,"result",[]),s={info:e},i=this.safeValue(this.options,"currenciesByNumericId",{});for(let n=0;n<t.length;n++){const r=t[n],a=this.safeString(r,"asset_id"),o=this.safeValue(i,a),d=o===void 0?a:o.code,c=this.account();c.total=this.safeString(r,"balance"),c.free=this.safeString(r,"available_balance"),s[d]=c}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetWalletBalances(e);return this.parseBalance(t)}async fetchPosition(e,t={}){await this.loadMarkets();const i={product_id:this.market(e).numericId},n=await this.privateGetPositions(this.extend(i,t));return this.safeValue(n,"result",{})}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetPositionsMargined(t);return this.safeValue(s,"result",[])}parseOrderStatus(e){const t={open:"open",pending:"open",closed:"closed",cancelled:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"client_order_id"),n=this.parse8601(this.safeString(e,"created_at")),r=this.safeString(e,"product_id"),a=this.safeValue(this.options,"marketsByNumericId",{});t=this.safeValue(a,r,t);const o=t===void 0?r:t.symbol,d=this.parseOrderStatus(this.safeString(e,"state")),c=this.safeString(e,"side");let u=this.safeString(e,"order_type");u=u.replace("_order","");const h=this.safeString(e,"limit_price"),l=this.safeString(e,"size"),p=this.safeString(e,"unfilled_size"),m=this.safeString(e,"average_fill_price");let g;const y=this.safeString(e,"paid_commission");if(y!==void 0){let b;if(t!==void 0){const w=this.safeValue(t.info,"settling_asset",{}),S=this.safeString(w,"symbol");b=this.safeCurrencyCode(S)}g={cost:y,currency:b}}return this.safeOrder({info:e,id:s,clientOrderId:i,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,symbol:o,type:u,side:c,price:h,amount:l,cost:void 0,average:m,filled:void 0,remaining:p,status:d,fee:g,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=t+"_order",o=this.market(e),d={product_id:o.numericId,size:this.amountToPrecision(o.symbol,i),side:s,order_type:a};t==="limit"&&(d.limit_price=this.priceToPrecision(o.symbol,n));const c=this.safeString2(r,"clientOrderId","client_order_id");r=this.omit(r,["clientOrderId","client_order_id"]),c!==void 0&&(d.client_order_id=c);const u=await this.privatePostOrders(this.extend(d,r)),h=this.safeValue(u,"result",{});return this.parseOrder(h,o)}async editOrder(e,t,s,i,n,r=void 0,a={}){await this.loadMarkets();const o=this.market(t),d={id:parseInt(e),product_id:o.numericId};n!==void 0&&(d.size=parseInt(this.amountToPrecision(t,n))),r!==void 0&&(d.limit_price=this.priceToPrecision(t,r));const c=await this.privatePutOrders(this.extend(d,a)),u=this.safeValue(c,"result");return this.parseOrder(u,o)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Bk(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={id:parseInt(e),product_id:i.numericId},r=await this.privateDeleteOrders(this.extend(n,s)),a=this.safeValue(r,"result");return this.parseOrder(a,i)}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new Bk(this.id+" cancelAllOrders() requires a symbol argument");await this.loadMarkets();const i={product_id:this.market(e).numericId};return this.privateDeleteOrdersAll(this.extend(i,t))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersWithMethod("privateGetOrders",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersWithMethod("privateGetOrdersHistory",e,t,s,i)}async fetchOrdersWithMethod(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a;t!==void 0&&(a=this.market(t),r.product_ids=a.numericId),s!==void 0&&(r.start_time=s.toString()+"000"),i!==void 0&&(r.page_size=i);const o=await this[e](this.extend(r,n)),d=this.safeValue(o,"result",[]);return this.parseOrders(d,a,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.product_ids=r.numericId),t!==void 0&&(n.start_time=t.toString()+"000"),s!==void 0&&(n.page_size=s);const a=await this.privateGetFills(this.extend(n,i)),o=this.safeValue(a,"result",[]);return this.parseTrades(o,r,t,s)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.asset_id=r.numericId),s!==void 0&&(n.page_size=s);const a=await this.privateGetWalletTransactions(this.extend(n,i)),o=this.safeValue(a,"result",[]);return this.parseLedger(o,r,t,s)}parseLedgerEntryType(e){const t={pnl:"pnl",deposit:"transaction",withdrawal:"transaction",commission:"fee",conversion:"trade",referral_bonus:"referral",commission_rebate:"rebate"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"uuid");let i;const n=void 0,r=this.safeValue(e,"meta_data",{}),a=this.safeString(r,"transaction_id"),o=void 0;let d=this.safeString(e,"transaction_type");d==="deposit"||d==="commission_rebate"||d==="referral_bonus"||d==="pnl"||d==="withdrawal_cancellation"||d==="promo_credit"?i="in":(d==="withdrawal"||d==="commission"||d==="conversion"||d==="perpetual_futures_funding")&&(i="out"),d=this.parseLedgerEntryType(d);const c=this.safeInteger(e,"asset_id"),u=this.safeValue(this.options,"currenciesByNumericId");t=this.safeValue(u,c,t);const h=t===void 0?void 0:t.code,l=this.safeNumber(e,"amount"),p=this.parse8601(this.safeString(e,"created_at")),m=this.safeNumber(e,"balance"),g=Math.max(0,m-l);return{info:e,id:s,direction:i,account:n,referenceId:a,referenceAccount:o,type:d,currency:h,amount:l,before:g,after:m,status:"ok",timestamp:p,datetime:this.iso8601(p),fee:void 0}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={asset_symbol:this.currency(e).id},n=await this.privateGetDepositsAddress(this.extend(i,t)),r=this.safeValue(n,"result",{}),a=this.safeString(r,"address");return this.checkAddress(a),{currency:e,address:a,tag:void 0,network:void 0,info:n}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a="/"+this.version+"/"+this.implodeParams(e,i);let o=this.urls.api[t]+a;const d=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(d).length&&(o+="?"+this.urlencode(d));else if(t==="private"){this.checkRequiredCredentials();const c=this.seconds().toString();n={"api-key":this.apiKey,timestamp:c};let u=s+c+a;if(s==="GET"||s==="DELETE"){if(Object.keys(d).length){const l="?"+this.urlencode(d);u+=l,o+=l}}else r=this.json(d),u+=r,n["Content-Type"]="application/json";const h=this.hmac(this.encode(u),this.encode(this.secret));n.signature=h}return{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeValue(a,"error",{}),u=this.safeString(c,"code");if(u!==void 0){const h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwBroadlyMatchedException(this.exceptions.broad,u,h),new ZR(h)}}};const rF=me,{TICK_SIZE:aF}=pe,{AuthenticationError:ri,ExchangeError:ss,ArgumentsRequired:yc,PermissionDenied:Xi,InvalidOrder:mt,OrderNotFound:b0,DDoSProtection:bc,NotSupported:oF,ExchangeNotAvailable:dF,InsufficientFunds:cF,BadRequest:xs,InvalidAddress:w0,OnMaintenance:Nk}=oe,Yi=ke;var q_=class extends rF{describe(){return this.deepExtend(super.describe(),{id:"deribit",name:"Deribit",countries:["NL"],version:"v2",userAgent:void 0,rateLimit:50,pro:!0,has:{CORS:!0,spot:!1,margin:!1,swap:!0,future:!0,option:!0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!1,createDepositAddress:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchDeposit:!1,fetchDepositAddress:!0,fetchDeposits:!0,fetchHistoricalVolatility:!0,fetchIndexOHLCV:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:void 0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:void 0,fetchTransfer:!1,fetchTransfers:!0,fetchWithdrawal:!1,fetchWithdrawals:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"1","3m":"3","5m":"5","10m":"10","15m":"15","30m":"30","1h":"60","2h":"120","3h":"180","6h":"360","12h":"720","1d":"1D"},urls:{test:{rest:"https://test.deribit.com"},logo:"https://user-images.githubusercontent.com/1294454/41933112-9e2dd65a-798b-11e8-8440-5bab2959fcb8.jpg",api:{rest:"https://www.deribit.com"},www:"https://www.deribit.com",doc:["https://docs.deribit.com/v2","https://github.com/deribit"],fees:"https://www.deribit.com/pages/information/fees",referral:{url:"https://www.deribit.com/reg-1189.4038",discount:.1}},api:{public:{get:{auth:1,exchange_token:1,fork_token:1,set_heartbeat:1,disable_heartbeat:1,get_time:1,hello:1,status:1,test:1,subscribe:1,unsubscribe:1,unsubscribe_all:1,get_announcements:1,get_book_summary_by_currency:1,get_book_summary_by_instrument:1,get_contract_size:1,get_currencies:1,get_delivery_prices:1,get_funding_chart_data:1,get_funding_rate_history:1,get_funding_rate_value:1,get_historical_volatility:1,get_index:1,get_index_price:1,get_index_price_names:1,get_instrument:1,get_instruments:1,get_last_settlements_by_currency:1,get_last_settlements_by_instrument:1,get_last_trades_by_currency:1,get_last_trades_by_currency_and_time:1,get_last_trades_by_instrument:1,get_last_trades_by_instrument_and_time:1,get_mark_price_history:1,get_order_book:1,get_trade_volumes:1,get_tradingview_chart_data:1,get_volatility_index_data:1,ticker:1}},private:{get:{logout:1,enable_cancel_on_disconnect:1,disable_cancel_on_disconnect:1,get_cancel_on_disconnect:1,subscribe:1,unsubscribe:1,unsubscribe_all:1,change_api_key_name:1,change_scope_in_api_key:1,change_subaccount_name:1,create_api_key:1,create_subaccount:1,disable_api_key:1,disable_tfa_for_subaccount:1,enable_affiliate_program:1,enable_api_key:1,get_access_log:1,get_account_summary:1,get_affiliate_program_info:1,get_email_language:1,get_new_announcements:1,get_portfolio_margins:1,get_position:1,get_positions:1,get_subaccounts:1,get_subaccounts_details:1,get_transaction_log:1,list_api_keys:1,remove_api_key:1,remove_subaccount:1,reset_api_key:1,set_announcement_as_read:1,set_api_key_as_default:1,set_email_for_subaccount:1,set_email_language:1,set_password_for_subaccount:1,toggle_notifications_from_subaccount:1,toggle_subaccount_login:1,execute_block_trade:4,get_block_trade:1,get_last_block_trades_by_currency:1,invalidate_block_trade_signature:1,verify_block_trade:4,buy:4,sell:4,edit:4,edit_by_label:4,cancel:4,cancel_all:4,cancel_all_by_currency:4,cancel_all_by_instrument:4,cancel_by_label:4,close_position:4,get_margins:1,get_mmp_config:1,get_open_orders_by_currency:1,get_open_orders_by_instrument:1,get_order_history_by_currency:1,get_order_history_by_instrument:1,get_order_margin_by_ids:1,get_order_state:1,get_stop_order_history:1,get_trigger_order_history:1,get_user_trades_by_currency:1,get_user_trades_by_currency_and_time:1,get_user_trades_by_instrument:1,get_user_trades_by_instrument_and_time:1,get_user_trades_by_order:1,reset_mmp:1,set_mmp_config:1,get_settlement_history_by_instrument:1,get_settlement_history_by_currency:1,cancel_transfer_by_id:1,cancel_withdrawal:1,create_deposit_address:1,get_current_deposit_address:1,get_deposits:1,get_transfers:1,get_withdrawals:1,submit_transfer_to_subaccount:1,submit_transfer_to_user:1,withdraw:1}}},exceptions:{9999:Xi,1e4:ri,10001:ss,10002:mt,10003:mt,10004:b0,10005:mt,10006:mt,10007:mt,10008:mt,10009:cF,10010:b0,10011:mt,10012:mt,10013:Xi,10014:Xi,10015:Xi,10016:Xi,10017:Xi,10018:Xi,10019:Xi,10020:ss,10021:mt,10022:mt,10023:mt,10024:mt,10025:mt,10026:mt,10027:mt,10028:bc,10029:b0,10030:ss,10031:ss,10032:mt,10033:oF,10034:mt,10035:mt,10036:mt,10040:dF,10041:Nk,10043:mt,10044:mt,10045:mt,10046:mt,10047:bc,10048:ss,11008:mt,11029:xs,11030:ss,11031:ss,11035:bc,11036:mt,11037:xs,11038:mt,11039:mt,11041:mt,11042:Xi,11043:xs,11044:mt,11045:xs,11046:xs,11047:xs,11048:ss,11049:xs,11050:xs,11051:Nk,11052:ss,11053:ss,11090:w0,11091:w0,11092:w0,11093:bc,11094:ss,11095:ss,11096:ss,12e3:ri,12001:bc,12002:ss,12998:ri,12003:ri,12004:ri,12005:ri,12100:ss,12999:ri,13e3:ri,13001:ri,13002:Xi,13003:ri,13004:ri,13005:ri,13006:ri,13007:ri,13008:ss,13009:ri,13010:xs,13011:xs,13012:Xi,13013:xs,13014:xs,13015:xs,13016:xs,13017:ss,13018:ss,13019:ss,13020:ss,13021:Xi,13025:ss,"-32602":xs,"-32601":xs,"-32700":xs,"-32000":xs,11054:mt},precisionMode:aF,options:{code:"BTC",fetchBalance:{code:"BTC"},fetchPositions:{code:"BTC"},transfer:{method:"privateGetSubmitTransferToSubaccount"}}})}async fetchTime(e={}){const t=await this.publicGetGetTime(e);return this.safeInteger(t,"result")}codeFromOptions(e,t={}){const s=this.safeValue(this.options,"code","BTC"),i=this.safeValue(this.options,e,{}),n=this.safeValue(i,"code",s);return this.safeValue(t,"code",n)}async fetchStatus(e={}){const t=await this.publicGetStatus(e),s=this.safeValue(t,"result"),i=this.safeString(s,"locked"),n=this.safeIntegerProduct(t,"usIn",.001,this.milliseconds());return{status:i==="false"?"ok":"maintenance",updated:n,eta:void 0,url:void 0,info:t}}async fetchAccounts(e={}){await this.loadMarkets();const t=await this.privateGetGetSubaccounts(e),s=this.safeValue(t,"result",[]);return this.parseAccounts(s)}parseAccount(e,t=void 0){return{info:e,id:this.safeString(e,"id"),type:this.safeString(e,"type"),code:this.safeCurrencyCode(void 0,t)}}async fetchMarkets(e={}){const t=await this.publicGetGetCurrencies(e),s=this.safeValue(t,"result",[]),i=[];for(let n=0;n<s.length;n++){const a={currency:this.safeString(s[n],"currency")},o=await this.publicGetGetInstruments(this.extend(a,e)),d=this.safeValue(o,"result",[]);for(let c=0;c<d.length;c++){const u=d[c],h=this.safeString(u,"instrument_name"),l=this.safeString(u,"base_currency"),p=this.safeString(u,"counter_currency"),m=this.safeString(u,"settlement_currency"),g=this.safeCurrencyCode(l),y=this.safeCurrencyCode(p),b=this.safeCurrencyCode(m),w=this.safeString(u,"kind"),k=this.safeValue(u,"settlement_period")==="perpetual",T=!k&&w.indexOf("future")>=0,I=w.indexOf("option")>=0,_=w.indexOf("combo")>=0,N=this.safeInteger(u,"expiration_timestamp");let M,x,v=h,O="swap";if(T?O="future":I&&(O="option"),!_&&(v=g+"/"+y+":"+b,(I||T)&&(v=v+"-"+this.yymmdd(N,""),I))){M=this.safeNumber(u,"strike"),x=this.safeString(u,"option_type");const q=x==="call"?"C":"P";v=v+"-"+this.numberToString(M)+"-"+q}const A=this.safeNumber(u,"min_trade_amount"),V=this.safeNumber(u,"tick_size");i.push({id:h,symbol:v,base:g,quote:y,settle:b,baseId:l,quoteId:p,settleId:m,type:O,spot:!1,margin:!1,swap:k,future:T,option:I,active:this.safeValue(u,"is_active"),contract:!0,linear:b===y,inverse:b!==y,taker:this.safeNumber(u,"taker_commission"),maker:this.safeNumber(u,"maker_commission"),contractSize:this.safeNumber(u,"contract_size"),expiry:N,expiryDatetime:this.iso8601(N),strike:M,optionType:x,precision:{amount:A,price:V},limits:{leverage:{min:void 0,max:void 0},amount:{min:A,max:void 0},price:{min:V,max:void 0},cost:{min:void 0,max:void 0}},info:u})}}return i}parseBalance(e){const t={info:e},s=this.safeString(e,"currency"),i=this.safeCurrencyCode(s),n=this.account();return n.free=this.safeString(e,"available_funds"),n.used=this.safeString(e,"maintenance_margin"),n.total=this.safeString(e,"equity"),t[i]=n,this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=this.codeFromOptions("fetchBalance",e),i={currency:this.currency(t).id},n=await this.privateGetGetAccountSummary(this.extend(i,e)),r=this.safeValue(n,"result",{});return this.parseBalance(r)}async createDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.privateGetCreateDepositAddress(this.extend(i,t)),r=this.safeValue(n,"result",{}),a=this.safeString(r,"address");return this.checkAddress(a),{currency:e,address:a,tag:void 0,info:n}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.privateGetGetCurrentDepositAddress(this.extend(i,t)),r=this.safeValue(n,"result",{}),a=this.safeString(r,"address");return this.checkAddress(a),{currency:e,address:a,tag:void 0,network:void 0,info:n}}parseTicker(e,t=void 0){const s=this.safeInteger2(e,"timestamp","creation_timestamp"),i=this.safeString(e,"instrument_name"),n=this.safeSymbol(i,t),r=this.safeString2(e,"last_price","last"),a=this.safeValue(e,"stats",e);return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString2(a,"high","max_price"),low:this.safeString2(a,"low","min_price"),bid:this.safeString2(e,"best_bid_price","bid_price"),bidVolume:this.safeString(e,"best_bid_amount"),ask:this.safeString2(e,"best_ask_price","ask_price"),askVolume:this.safeString(e,"best_ask_amount"),vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:this.safeString(a,"volume"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={instrument_name:s.id},n=await this.publicGetTicker(this.extend(i,t)),r=this.safeValue(n,"result");return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.codeFromOptions("fetchTickers",t),n={currency:this.currency(s).id},r=await this.publicGetGetBookSummaryByCurrency(this.extend(n,t)),a=this.safeValue(r,"result",[]),o={};for(let d=0;d<a.length;d++){const c=this.parseTicker(a[d]),u=c.symbol;o[u]=c}return this.filterByArray(o,"symbol",e)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={instrument_name:r.id,resolution:this.timeframes[t]},o=this.parseTimeframe(t),d=this.milliseconds();s===void 0?(i===void 0&&(i=1e3),a.start_timestamp=d-(i-1)*o*1e3,a.end_timestamp=d):(a.start_timestamp=s,i===void 0?a.end_timestamp=d:a.end_timestamp=this.sum(s,i*o*1e3));const c=await this.publicGetGetTradingviewChartData(this.extend(a,n)),u=this.safeValue(c,"result",{}),h=this.convertTradingViewToOHLCV(u,"ticks","open","high","low","close","volume",!0);return this.parseOHLCVs(h,r,t,s,i)}parseTrade(e,t=void 0){const s=this.safeString(e,"trade_id"),i=this.safeString(e,"instrument_name"),n=this.safeSymbol(i,t),r=this.safeInteger(e,"timestamp"),a=this.safeString(e,"direction"),o=this.safeString(e,"price"),d=this.safeString(e,"amount");let c=Yi.stringMul(d,o);t.inverse&&(c=Yi.stringDiv(d,o));const u=this.safeString(e,"liquidity");let h;u!==void 0&&(h=u==="M"?"maker":"taker");const l=this.safeString(e,"fee");let p;if(l!==void 0){const m=this.safeString(e,"fee_currency"),g=this.safeCurrencyCode(m);p={cost:l,currency:g}}return this.safeTrade({id:s,info:e,timestamp:r,datetime:this.iso8601(r),symbol:n,order:this.safeString(e,"order_id"),type:this.safeString(e,"order_type"),side:a,takerOrMaker:h,price:o,amount:d,cost:c,fee:p},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={instrument_name:n.id,include_old:!0},a=t===void 0?"publicGetGetLastTradesByInstrument":"publicGetGetLastTradesByInstrumentAndTime";t!==void 0&&(r.start_timestamp=t),s!==void 0&&(r.count=s);const o=await this[a](this.extend(r,i)),d=this.safeValue(o,"result",{}),c=this.safeValue(d,"trades",[]);return this.parseTrades(c,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=this.codeFromOptions("fetchTradingFees",e),i={currency:this.currency(t).id,extended:!0},n=await this.privateGetGetAccountSummary(this.extend(i,e)),r=this.safeValue(n,"result",{}),a=this.safeValue(r,"fees",[]);let o={},d={},c={};for(let h=0;h<a.length;h++){const l=a[h],p=this.safeString(l,"instrument_type");p==="future"?d={info:l,maker:this.safeNumber(l,"maker_fee"),taker:this.safeNumber(l,"taker_fee")}:p==="perpetual"?o={info:l,maker:this.safeNumber(l,"maker_fee"),taker:this.safeNumber(l,"taker_fee")}:p==="option"&&(c={info:l,maker:this.safeNumber(l,"maker_fee"),taker:this.safeNumber(l,"taker_fee")})}const u={};for(let h=0;h<this.symbols.length;h++){const l=this.symbols[h],p=this.market(l);let m={info:p,symbol:l,percentage:!0,tierBased:!0,maker:p.maker,taker:p.taker};p.swap?m=this.extend(m,o):p.future?m=this.extend(m,d):p.option&&(m=this.extend(m,c)),u[l]=m}return u}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={instrument_name:i.id};t!==void 0&&(n.depth=t);const r=await this.publicGetGetOrderBook(this.extend(n,s)),a=this.safeValue(r,"result",{}),o=this.safeInteger(a,"timestamp"),d=this.safeInteger(a,"change_id"),c=this.parseOrderBook(a,i.symbol,o);return c.nonce=d,c}parseOrderStatus(e){const t={open:"open",cancelled:"canceled",filled:"closed",rejected:"rejected",untriggered:"open"};return this.safeString(t,e,e)}parseTimeInForce(e){const t={good_til_cancelled:"GTC",fill_or_kill:"FOK",immediate_or_cancel:"IOC"};return this.safeString(t,e,e)}parseOrderType(e){const t={stop_limit:"limit",take_limit:"limit",stop_market:"market",take_market:"market"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"instrument_name");t=this.safeMarket(s,t);const i=this.safeInteger(e,"creation_timestamp"),n=this.safeInteger(e,"last_update_timestamp"),r=this.safeString(e,"order_id"),a=this.safeString(e,"price"),o=this.safeString(e,"average_price"),d=this.safeString(e,"filled_amount"),c=this.safeString(e,"amount");let u=Yi.stringMul(d,o);t.inverse&&this.parseNumber(o)!==0&&(u=Yi.stringDiv(c,o));let h;d!==void 0&&Yi.stringGt(d,"0")&&(h=n);const l=this.parseOrderStatus(this.safeString(e,"order_state")),p=this.safeStringLower(e,"direction");let m=this.safeString(e,"commission"),g;m!==void 0&&(m=Yi.stringAbs(m),g={cost:m,currency:t.base});const y=this.safeString(e,"order_type"),b=this.parseOrderType(y),w=this.safeValue(e,"trades"),S=this.parseTimeInForce(this.safeString(e,"time_in_force")),k=this.safeValue(e,"stop_price"),T=this.safeValue(e,"post_only");return this.safeOrder({info:e,id:r,clientOrderId:void 0,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:h,symbol:t.symbol,type:b,timeInForce:S,postOnly:T,side:p,price:a,stopPrice:k,amount:c,cost:u,average:o,filled:d,remaining:void 0,status:l,fee:g,trades:w},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privateGetGetOrderState(this.extend(i,s)),r=this.safeValue(n,"result");return this.parseOrder(r)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);a.inverse?i=this.amountToPrecision(e,i):i=this.currencyToPrecision(e,i);const o={instrument_name:a.id,amount:i,type:t},d=this.safeStringUpper(r,"timeInForce"),c=this.safeValue2(r,"reduceOnly","reduce_only"),u=this.safeValue(r,"stopLossPrice"),h=this.safeValue(r,"takeProfitPrice"),l=t==="stop_limit",p=t==="stop_market",m=t==="take_limit",g=t==="take_market",y=l||p||u!==void 0,b=m||g||h!==void 0;if(y&&b)throw new mt(this.id+" createOrder () only allows one of stopLossPrice or takeProfitPrice to be specified");const w=y||b,S=t==="limit"||l||m,k=t==="market"||p||g,T=this.safeValue(r,"post_only"),I=this.isPostOnly(k,T,r);if(S?(o.type="limit",o.price=this.priceToPrecision(e,n)):o.type="market",w){const O=u!==void 0?u:h;o.trigger_price=this.priceToPrecision(e,O),o.trigger="last_price",y?k?o.type="stop_market":o.type="stop_limit":k?o.type="take_market":o.type="take_limit"}c&&(o.reduce_only=!0),I&&(o.post_only=!0,o.reject_post_only=!0),d!==void 0&&(d==="GTC"&&(o.time_in_force="good_til_cancelled"),d==="IOC"&&(o.time_in_force="immediate_or_cancel"),d==="FOK"&&(o.time_in_force="fill_or_kill"));const _="privateGet"+this.capitalize(s);r=this.omit(r,["timeInForce","stopLossPrice","takeProfitPrice","postOnly","reduceOnly"]);const N=await this[_](this.extend(o,r)),M=this.safeValue(N,"result",{}),x=this.safeValue(M,"order"),v=this.safeValue(M,"trades",[]);return x.trades=v,this.parseOrder(x,a)}async editOrder(e,t,s,i,n=void 0,r=void 0,a={}){if(n===void 0)throw new yc(this.id+" editOrder() requires an amount argument");if(r===void 0)throw new yc(this.id+" editOrder() requires a price argument");await this.loadMarkets();const o={order_id:e,amount:this.amountToPrecision(t,n),price:this.priceToPrecision(t,r)},d=await this.privateGetEdit(this.extend(o,a)),c=this.safeValue(d,"result",{}),u=this.safeValue(c,"order"),h=this.safeValue(c,"trades",[]);return u.trades=h,this.parseOrder(u)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privateGetCancel(this.extend(i,s)),r=this.safeValue(n,"result",{});return this.parseOrder(r)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;if(e===void 0)i="privateGetCancelAll";else{i="privateGetCancelAllByInstrument";const r=this.market(e);s.instrument_name=r.id}return await this[i](this.extend(s,t))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r,a;if(e===void 0){const c=this.codeFromOptions("fetchOpenOrders",i),u=this.currency(c);n.currency=u.id,a="privateGetGetOpenOrdersByCurrency"}else r=this.market(e),n.instrument_name=r.id,a="privateGetGetOpenOrdersByInstrument";const o=await this[a](this.extend(n,i)),d=this.safeValue(o,"result",[]);return this.parseOrders(d,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r,a;if(e===void 0){const c=this.codeFromOptions("fetchClosedOrders",i),u=this.currency(c);n.currency=u.id,a="privateGetGetOrderHistoryByCurrency"}else r=this.market(e),n.instrument_name=r.id,a="privateGetGetOrderHistoryByInstrument";const o=await this[a](this.extend(n,i)),d=this.safeValue(o,"result",[]);return this.parseOrders(d,r,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={order_id:e},a=await this.privateGetGetUserTradesByOrder(this.extend(r,n)),o=this.safeValue(a,"result",{});return this.parseTrades(o,void 0,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={include_old:!0};let r,a;if(e===void 0){const u=this.codeFromOptions("fetchMyTrades",i),h=this.currency(u);n.currency=h.id,t===void 0?a="privateGetGetUserTradesByCurrency":(a="privateGetGetUserTradesByCurrencyAndTime",n.start_timestamp=t)}else r=this.market(e),n.instrument_name=r.id,t===void 0?a="privateGetGetUserTradesByInstrument":(a="privateGetGetUserTradesByInstrumentAndTime",n.start_timestamp=t);s!==void 0&&(n.count=s);const o=await this[a](this.extend(n,i)),d=this.safeValue(o,"result",{}),c=this.safeValue(d,"trades",[]);return this.parseTrades(c,r,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new yc(this.id+" fetchDeposits() requires a currency code argument");await this.loadMarkets();const n=this.currency(e),r={currency:n.id};s!==void 0&&(r.count=s);const a=await this.privateGetGetDeposits(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"data",[]);return this.parseTransactions(d,n,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new yc(this.id+" fetchWithdrawals() requires a currency code argument");await this.loadMarkets();const n=this.currency(e),r={currency:n.id};s!==void 0&&(r.count=s);const a=await this.privateGetGetWithdrawals(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"data",[]);return this.parseTransactions(d,n,t,s,i)}parseTransactionStatus(e){const t={completed:"ok",unconfirmed:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"currency"),i=this.safeCurrencyCode(s,t),n=this.safeInteger2(e,"created_timestamp","received_timestamp"),r=this.safeInteger(e,"updated_timestamp"),a=this.parseTransactionStatus(this.safeString(e,"state")),o=this.safeString(e,"address"),d=this.safeNumber(e,"fee");let c="deposit",u;return d!==void 0&&(c="withdrawal",u={cost:d,currency:i}),{info:e,id:this.safeString(e,"id"),txid:this.safeString(e,"transaction_id"),timestamp:n,datetime:this.iso8601(n),address:o,addressTo:o,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:c,amount:this.safeNumber(e,"amount"),currency:i,status:a,updated:r,fee:u}}parsePosition(e,t=void 0){const s=this.safeString(e,"instrument_name");t=this.safeMarket(s,t);let i=this.safeString(e,"direction");i=i==="buy"?"long":"short";const n=this.safeString(e,"floating_profit_loss"),r=this.safeString(e,"initial_margin"),a=this.safeString(e,"size_currency"),o=this.safeString(e,"maintenance_margin"),d=Yi.stringMul(Yi.stringDiv(n,r),"100"),c=this.milliseconds();return{info:e,id:void 0,symbol:this.safeString(t,"symbol"),timestamp:c,datetime:this.iso8601(c),initialMargin:this.parseNumber(r),initialMarginPercentage:this.parseNumber(Yi.stringMul(Yi.stringDiv(r,a),"100")),maintenanceMargin:this.parseNumber(o),maintenanceMarginPercentage:this.parseNumber(Yi.stringMul(Yi.stringDiv(o,a),"100")),entryPrice:this.safeNumber(e,"average_price"),notional:this.parseNumber(a),leverage:this.safeInteger(e,"leverage"),unrealizedPnl:this.parseNumber(n),contracts:void 0,contractSize:this.safeNumber(t,"contractSize"),marginRatio:void 0,liquidationPrice:this.safeNumber(e,"estimated_liquidation_price"),markPrice:this.safeNumber(e,"mark_price"),collateral:void 0,marginMode:void 0,side:i,percentage:this.parseNumber(d)}}async fetchPosition(e,t={}){await this.loadMarkets();const i={instrument_name:this.market(e).id},n=await this.privateGetGetPosition(this.extend(i,t)),r=this.safeValue(n,"result");return this.parsePosition(r)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();let s;if(e===void 0)s=this.codeFromOptions("fetchPositions",t);else if(typeof e=="string")s=e,e=void 0;else if(Array.isArray(e)){if(e.length!==1)throw new xs(this.id+" fetchPositions() symbols argument cannot contain more than 1 symbol");s=this.market(e[0]).base}const n={currency:this.currency(s).id},r=await this.privateGetGetPositions(this.extend(n,t)),a=this.safeValue(r,"result");return this.parsePositions(a,e)}async fetchHistoricalVolatility(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.publicGetGetHistoricalVolatility(this.extend(i,t)),r=this.safeValue(n,"result",{}),a=[];for(let o=0;o<r.length;o++){const d=this.safeInteger(r[o],0),c=this.safeNumber(r[o],1);a.push({info:n,timestamp:d,datetime:this.iso8601(d),volatility:c})}return a}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new yc(this.id+" fetchTransfers() requires a currency code argument");await this.loadMarkets();const n=this.currency(e),r={currency:n.id};s!==void 0&&(r.count=s);const a=await this.privateGetGetTransfers(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"data",[]);return this.parseTransfers(d,n,t,s,i)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a={amount:t,currency:r.id,destination:i};let o=this.safeString(n,"method");if(n=this.omit(n,"method"),o===void 0){const u=this.safeValue(this.options,"transfer",{});o=this.safeString(u,"method","privateGetSubmitTransferToSubaccount")}const d=await this[o](this.extend(a,n)),c=this.safeValue(d,"result",{});return this.parseTransfer(c,r)}parseTransfer(e,t=void 0){const s=this.safeTimestamp(e,"created_timestamp"),i=this.safeString(e,"state"),n=this.safeString(e,"other_side"),r=this.safeString(e,"direction"),a=this.safeString(e,"currency");return{info:e,id:this.safeString(e,"id"),status:this.parseTransferStatus(i),amount:this.safeNumber(e,"amount"),code:this.safeCurrencyCode(a,t),fromAccount:r!=="payment"?n:void 0,toAccount:r==="payment"?n:void 0,timestamp:s,datetime:this.iso8601(s)}}parseTransferStatus(e){const t={prepared:"pending",confirmed:"ok",cancelled:"cancelled",waiting_for_admin:"pending"};return this.safeString(t,e,e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,address:s,amount:t};this.twofa!==void 0&&(a.tfa=this.oath());const o=await this.privateGetWithdraw(this.extend(a,n));return this.parseTransaction(o,r)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/api/"+this.version+"/"+t+"/"+e;if(t==="public"&&Object.keys(i).length&&(a+="?"+this.urlencode(i)),t==="private"){this.checkRequiredCredentials();const d=this.nonce().toString(),c=this.milliseconds().toString(),u="";Object.keys(i).length&&(a+="?"+this.urlencode(i));const h=s+`
`+a+`
`+u+`
`,l=c+`
`+d+`
`+h,p=this.hmac(this.encode(l),this.encode(this.secret),"sha256");n={Authorization:"deri-hmac-sha256 id="+this.apiKey+",ts="+c+",sig="+p+",nonce="+d}}return{url:this.urls.api.rest+a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(!a)return;const c=this.safeValue(a,"error");if(c!==void 0){const u=this.safeString(c,"code"),h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions,u,h),new ss(h)}}};const uF=me,{AccountSuspended:fF,BadRequest:Ks,BadResponse:hF,NetworkError:lF,NotSupported:pF,DDoSProtection:Ek,AuthenticationError:Vk,PermissionDenied:Qi,ExchangeError:Bf,InsufficientFunds:qk,InvalidOrder:Eo,InvalidNonce:mF,OrderNotFound:S0,InvalidAddress:k0,RateLimitExceeded:gF,BadSymbol:wc}=oe,{TICK_SIZE:yF}=pe,Lk=ke;var bF=class extends uF{describe(){return this.deepExtend(super.describe(),{id:"digifinex",name:"DigiFinex",countries:["SG"],version:"v3",rateLimit:900,has:{CORS:void 0,spot:!0,margin:!0,swap:void 0,future:!1,option:!1,cancelOrder:!0,cancelOrders:!0,createOrder:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowInterest:!0,fetchBorrowRate:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchLedger:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransfers:!0,fetchWithdrawals:!0,setLeverage:!0,setMarginMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"1","5m":"5","15m":"15","30m":"30","1h":"60","4h":"240","12h":"720","1d":"1D","1w":"1W"},urls:{logo:"https://user-images.githubusercontent.com/51840849/87443315-01283a00-c5fe-11ea-8628-c2a0feaf07ac.jpg",api:{rest:"https://openapi.digifinex.com"},www:"https://www.digifinex.com",doc:["https://docs.digifinex.com"],fees:"https://digifinex.zendesk.com/hc/en-us/articles/360000328422-Fee-Structure-on-DigiFinex",referral:"https://www.digifinex.com/en-ww/from/DhOzBg?channelCode=ljaUPp"},api:{public:{spot:{get:["{market}/symbols","kline","margin/currencies","margin/symbols","markets","order_book","ping","spot/symbols","time","trades","trades/symbols","ticker","currencies"]},swap:{get:["public/api_weight","public/candles","public/candles_history","public/depth","public/funding_rate","public/funding_rate_history","public/instrument","public/instruments","public/ticker","public/tickers","public/time","public/trades"]}},private:{spot:{get:["{market}/financelog","{market}/mytrades","{market}/order","{market}/order/detail","{market}/order/current","{market}/order/history","margin/assets","margin/financelog","margin/mytrades","margin/order","margin/order/current","margin/order/history","margin/positions","otc/financelog","spot/assets","spot/financelog","spot/mytrades","spot/order","spot/order/current","spot/order/history","deposit/address","deposit/history","withdraw/history"],post:["{market}/order/cancel","{market}/order/new","{market}/order/batch_new","margin/order/cancel","margin/order/new","margin/position/close","spot/order/cancel","spot/order/new","transfer","withdraw/new","withdraw/cancel"]},swap:{get:["account/balance","account/positions","account/finance_record","account/trading_fee_rate","account/transfer_record","trade/history_orders","trade/history_trades","trade/open_orders","trade/order_info"],post:["account/leverage","trade/batch_cancel_order","trade/batch_order","trade/cancel_order","trade/order_place"]}}},fees:{trading:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},precisionMode:yF,exceptions:{exact:{10001:[Ks,"Wrong request method, please check it's a GET ot POST request"],10002:[Vk,"Invalid ApiKey"],10003:[Vk,"Sign doesn't match"],10004:[Ks,"Illegal request parameters"],10005:[Ek,"Request frequency exceeds the limit"],10006:[Qi,"Unauthorized to execute this request"],10007:[Qi,"IP address Unauthorized"],10008:[mF,"Timestamp for this request is invalid, timestamp must within 1 minute"],10009:[lF,"Unexist endpoint, please check endpoint URL"],10011:[fF,"ApiKey expired. Please go to client side to re-create an ApiKey"],20001:[Qi,"Trade is not open for this trading pair"],20002:[Qi,"Trade of this trading pair is suspended"],20003:[Eo,"Invalid price or amount"],20007:[Eo,"Price precision error"],20008:[Eo,"Amount precision error"],20009:[Eo,"Amount is less than the minimum requirement"],20010:[Eo,"Cash Amount is less than the minimum requirement"],20011:[qk,"Insufficient balance"],20012:[Ks,"Invalid trade type, valid value: buy/sell)"],20013:[Eo,"No order info found"],20014:[Ks,"Invalid date, Valid format: 2018-07-25)"],20015:[Ks,"Date exceeds the limit"],20018:[Qi,"Your trading rights have been banned by the system"],20019:[wc,'Wrong trading pair symbol. Correct format:"usdt_btc". Quote asset is in the front'],20020:[Ek,"You have violated the API operation trading rules and temporarily forbid trading. At present, we have certain restrictions on the user's transaction rate and withdrawal rate."],5e4:[Bf,"Exception error"],20021:[Ks,"Invalid currency"],20022:[Ks,"The ending timestamp must be larger than the starting timestamp"],20023:[Ks,"Invalid transfer type"],20024:[Ks,"Invalid amount"],20025:[Ks,"This currency is not transferable at the moment"],20026:[qk,"Transfer amount exceed your balance"],20027:[Qi,"Abnormal account status"],20028:[Qi,"Blacklist for transfer"],20029:[Qi,"Transfer amount exceed your daily limit"],20030:[Ks,"You have no position on this trading pair"],20032:[Qi,"Withdrawal limited"],20033:[Ks,"Wrong Withdrawal ID"],20034:[Qi,"Withdrawal service of this crypto has been closed"],20035:[Qi,"Withdrawal limit"],20036:[Bf,"Withdrawal cancellation failed"],20037:[k0,"The withdrawal address, Tag or chain type is not included in the withdrawal management list"],20038:[k0,"The withdrawal address is not on the white list"],20039:[Bf,"Can't be canceled in current status"],20040:[gF,"Withdraw too frequently; limitation: 3 times a minute, 100 times a day"],20041:[Qi,"Beyond the daily withdrawal limit"],20042:[wc,"Current trading pair does not support API trading"],400002:[Ks,"Invalid Parameter"]},broad:{}},options:{defaultType:"spot",types:["spot","margin","otc"],accountsByType:{spot:"1",margin:"2",OTC:"3"}},commonCurrencies:{BHT:"Black House Test",EPS:"Epanus",FREE:"FreeRossDAO",MBN:"Mobilian Coin",TEL:"TEL666"}})}safeNetwork(e){if(e!==void 0)return e.toUpperCase()}async fetchCurrencies(e={}){const t=await this.publicSpotGetCurrencies(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.safeInteger(r,"deposit_status",1),c=this.safeInteger(r,"withdraw_status",1),u=d>0,h=c>0,l=u&&h,p=this.safeNumber(r,"min_withdraw_fee"),m=this.safeNumber(r,"min_withdraw_amount"),g=this.safeNumber(r,"min_deposit_amount"),y=this.safeString(r,"chain"),b={id:y,network:this.safeNetwork(y),name:void 0,active:l,fee:p,precision:this.parseNumber("0.00000001"),deposit:u,withdraw:h,limits:{amount:{min:void 0,max:void 0},withdraw:{min:m,max:void 0},deposit:{min:g,max:void 0}},info:r};o in i?(Array.isArray(i[o].info)?i[o].info.push(r):i[o].info=[i[o].info,r],h&&(i[o].withdraw=!0,i[o].limits.withdraw.min=Math.min(i[o].limits.withdraw.min,m)),u&&(i[o].deposit=!0,i[o].limits.deposit.min=Math.min(i[o].limits.deposit.min,g)),l&&(i[o].active=!0)):i[o]={id:a,code:o,info:r,type:void 0,name:void 0,active:l,deposit:u,withdraw:h,fee:p,precision:this.parseNumber("0.00000001"),limits:{amount:{min:void 0,max:void 0},withdraw:{min:m,max:void 0},deposit:{min:g,max:void 0}},networks:{}},i[o].networks[y]=b}return i}async fetchMarkets(e={}){const t=this.safeValue(this.options,"fetchMarkets",{}),s=this.safeString(t,"method","fetch_markets_v2");return await this[s](e)}async fetchMarketsV2(e={}){const t=this.safeString(this.options,"defaultType"),[s,i]=this.handleMarginModeAndParams("fetchMarketsV2",e);let r=[this[s!==void 0?"publicSpotGetMarginSymbols":"publicSpotGetTradesSymbols"](i),this.publicSwapGetPublicInstruments(e)];r=await Promise.all(r);const a=r[0],o=r[1],d=this.safeValue(a,"symbol_list",[]),c=this.safeValue(o,"data",[]),u=this.arrayConcat(d,c),h=[];for(let l=0;l<u.length;l++){const p=u[l],m=this.safeString2(p,"symbol","instrument_id"),g=this.safeString2(p,"base_asset","base_currency"),y=this.safeString2(p,"quote_asset","quote_currency"),b=this.safeString(p,"clear_currency"),w=this.safeCurrencyCode(g),S=this.safeCurrencyCode(y),k=this.safeCurrencyCode(b);let T=this.safeInteger(p,"is_allow",1),I=t==="margin"?"margin":"spot";const _=k===void 0,N=!_,M=s!==void 0?!0:void 0;let x=w+"/"+S,v,O;N&&(I="swap",x=w+"/"+S+":"+k,v=this.safeValue(p,"is_inverse"),O=!v,this.safeValue(p,"isTrading")&&(T=!0)),h.push({id:m,symbol:x,base:w,quote:S,settle:k,baseId:g,quoteId:y,settleId:b,type:I,spot:_,margin:M,swap:N,future:!1,option:!1,active:!!T,contract:N,linear:O,inverse:v,contractSize:this.safeNumber(p,"contract_value"),expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(p,"amount_precision"))),price:this.parseNumber(this.parsePrecision(this.safeString(p,"price_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber2(p,"minimum_amount","min_order_amount"),max:void 0},price:{min:this.safeNumber(p,"tick_size"),max:void 0},cost:{min:this.safeNumber(p,"minimum_value"),max:void 0}},info:p})}return h}async fetchMarketsV1(e={}){const t=await this.publicSpotGetMarkets(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"market"),[o,d]=a.split("_"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d);i.push({id:a,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:void 0,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{price:this.parseNumber(this.parsePrecision(this.safeString(r,"price_precision"))),amount:this.parseNumber(this.parsePrecision(this.safeString(r,"volume_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"min_volume"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(r,"min_amount"),max:void 0}},info:r})}return i}parseBalance(e){const t=this.safeValue(e,"list",[]),s={info:e};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.used=this.safeString(n,"frozen"),o.free=this.safeString(n,"free"),o.total=this.safeString(n,"total"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){const t=this.safeString(this.options,"defaultType","spot"),s=this.safeString(e,"type",t);e=this.omit(e,"type");const i="privateSpotGet"+this.capitalize(s)+"Assets",n=await this[i](e);return this.parseBalance(n)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit=t);const r=await this.publicSpotGetOrderBook(this.extend(n,s)),a=this.safeTimestamp(r,"date");return this.parseOrderBook(r,i.symbol,a)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeString(e,0);let i;s!==void 0&&(i=this.market(s));let n;[n,t]=this.handleMarketTypeAndParams("fetchTickers",i,t);let r="publicSpotGetTicker";const a={};n==="swap"&&(r="publicSwapGetPublicTickers");const o=await this[r](this.extend(a,t)),d={},c=this.safeValue2(o,"ticker","data",[]),u=this.safeInteger(o,"date");for(let h=0;h<c.length;h++){const l=this.extend({date:u},c[h]),p=this.parseTicker(l),m=p.symbol;d[m]=p}return this.filterByArray(d,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);let i="publicSpotGetTicker";const n={};s.swap?(i="publicSwapGetPublicTicker",n.instrument_id=s.id):n.symbol=s.id;const r=await this[i](this.extend(n,t)),a=this.safeInteger(r,"date"),o=this.safeValue(r,"ticker",[]),d=this.safeValue(r,"data",{}),c=this.safeValue(o,0,{});let u;return s.swap?u=d:u=this.extend({date:a},c),this.parseTicker(u,s)}parseTicker(e,t=void 0){const s=this.safeStringUpper2(e,"symbol","instrument_id"),i=this.safeSymbol(s,t);t=this.safeMarket(s);let n=this.safeTimestamp(e,"date");t.swap&&(n=this.safeInteger(e,"timestamp"));const r=this.safeString(e,"last");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString2(e,"high","high_24h"),low:this.safeString2(e,"low","low_24h"),bid:this.safeString2(e,"buy","best_bid"),bidVolume:this.safeString(e,"best_bid_size"),ask:this.safeString2(e,"sell","best_ask"),askVolume:this.safeString(e,"best_ask_size"),vwap:void 0,open:this.safeString(e,"open_24h"),close:r,last:r,previousClose:void 0,change:void 0,percentage:this.safeString2(e,"change","price_change_percent"),average:void 0,baseVolume:this.safeString(e,"base_vol"),quoteVolume:this.safeString2(e,"vol","volume_24h"),info:e},t)}parseTrade(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"order_id"),n=this.safeTimestamp2(e,"date","timestamp");let r=this.safeString2(e,"type","side");const a=r.split("_");r=this.safeString(a,0);const o=this.safeString(a,1),d=this.safeString(e,"price"),c=this.safeString(e,"amount"),u=this.safeString(e,"symbol"),h=this.safeSymbol(u,t,"_"),l=this.safeValue(e,"is_maker"),p=this.safeString(e,"fee");let m;if(p!==void 0){const g=this.safeString(e,"fee_currency"),y=this.safeCurrencyCode(g);m={cost:p,currency:y}}return this.safeTrade({id:s,info:e,timestamp:n,datetime:this.iso8601(n),symbol:h,type:o,order:i,side:r,price:d,amount:c,cost:void 0,takerOrMaker:l,fee:m},t)}async fetchTime(e={}){const t=await this.publicSpotGetTime(e);return this.safeTimestamp(t,"server_time")}async fetchStatus(e={}){const t=await this.publicSpotGetPing(e);return{status:this.safeInteger(t,"code")===0?"ok":"maintenance",updated:void 0,eta:void 0,url:void 0,info:t}}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s);const a=await this.publicSpotGetTrades(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,5),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,1)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,period:this.timeframes[t]};if(s!==void 0){const c=parseInt(s/1e3);if(a.start_time=c,i!==void 0){const u=this.parseTimeframe(t);a.end_time=this.sum(c,i*u)}}else if(i!==void 0){const c=this.seconds(),u=this.parseTimeframe(t);a.startTime=this.sum(c,-i*u)}const o=await this.publicSpotGetKline(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseOHLCVs(d,r,t,s,i)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);e=a.symbol;let o,d;[o,r]=this.handleMarketTypeAndParams("createOrder",a,r);let c=this.getSupportedMapping(o,{spot:"privateSpotPostSpotOrderNew",margin:"privateSpotPostMarginOrderNew",swap:"privateSwapPostTradeOrderPlace"});[d,r]=this.handleMarginModeAndParams("createOrder",r),d!==void 0&&(c="privateSpotPostMarginOrderNew",o="margin");const u={},h=o==="swap",l=t==="market",p=t==="limit",m=h?"instrument_id":"symbol";u[m]=a.id;let g=this.isPostOnly(l,!1,r);if(h){const S=this.safeValue(r,"reduceOnly",!1),k=this.safeString(r,"timeInForce");let T;if(s==="buy"){const I=S?4:1;u.type=I}else{const I=S?3:2;u.type=I}p&&(T=0),k==="FOK"?T=l?15:9:k==="IOC"?T=l?13:4:k==="GTC"||l?T=14:k==="PO"&&(g=!0),n!==void 0&&(u.price=this.priceToPrecision(e,n)),u.order_type=T,u.size=i,r=this.omit(r,["reduceOnly","timeInForce"])}else{g=g===!0?1:2,u.market=o;let S="";t==="market"?S="_market":u.price=this.priceToPrecision(e,n),u.type=s+S,u.amount=this.amountToPrecision(e,i)}g&&(u.postOnly=g);const y=this.omit(r,["postOnly","post_only"]),b=await this[c](this.extend(u,y)),w=this.parseOrder(b,a);return this.extend(w,{symbol:e,type:t,side:s,amount:i,price:n})}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));let n;[n,s]=this.handleMarketTypeAndParams("cancelOrder",i,s);let r=this.getSupportedMapping(n,{spot:"privateSpotPostSpotOrderCancel",margin:"privateSpotPostMarginOrderCancel",swap:"privateSwapPostTradeCancelOrder"});const[a,o]=this.handleMarginModeAndParams("cancelOrder",s);a!==void 0&&(r="privateSpotPostMarginOrderCancel",n="margin"),e=e.toString();const d={order_id:e};n==="swap"?(this.checkRequiredSymbol("cancelOrder",t),d.instrument_id=i.id):d.market=n;const c=await this[r](this.extend(d,o));if((n==="spot"||n==="margin")&&this.safeValue(c,"success",[]).length!==1)throw new S0(this.id+" cancelOrder() "+e+" not found");return c}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeString(this.options,"defaultType","spot"),n=this.safeString(s,"type",i);s=this.omit(s,"type");const r={market:n,order_id:e.join(",")},a=await this.privateSpotPostCancelOrder(this.extend(r,s));if(this.safeValue(a,"success",[]).length<1)throw new S0(this.id+" cancelOrders() error");return a}parseOrderStatus(e){const t={0:"open",1:"open",2:"closed",3:"canceled",4:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){let s,i,n,r,a=this.safeString(e,"type");const o=this.safeString2(e,"symbol","instrument_id"),d=this.safeSymbol(o,t,"_");if(t=this.market(d),t.type==="swap"){const c=this.safeInteger(e,"order_type");c===9||c===10||c===11||c===12||c===15?n="FOK":c===1||c===2||c===3||c===4||c===13?n="IOC":(c===6||c===7||c===8||c===14)&&(n="GTC"),c===0||c===1||c===4||c===5||c===9||c===10?r="limit":r="market",a==="1"?a="open long":a==="2"?a="open short":a==="3"?a="close long":a==="4"&&(a="close short"),s=this.safeInteger(e,"insert_time"),i=this.safeInteger(e,"time_stamp")}else if(s=this.safeTimestamp(e,"created_date"),i=this.safeTimestamp(e,"finished_date"),a!==void 0){const c=a.split("_");c.length>1?(a=c[0],r=c[1]):r="limit"}return this.safeOrder({info:e,id:this.safeString2(e,"order_id","data"),clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:i,symbol:d,type:r,timeInForce:n,postOnly:void 0,side:a,price:this.safeNumber(e,"price"),stopPrice:void 0,amount:this.safeNumber2(e,"amount","size"),filled:this.safeNumber2(e,"executed_amount","filled_qty"),remaining:void 0,cost:void 0,average:this.safeNumber2(e,"avg_price","price_avg"),status:this.parseOrderStatus(this.safeString2(e,"status","state")),fee:{cost:this.safeNumber(e,"fee")},trades:void 0},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));let r;[r,i]=this.handleMarketTypeAndParams("fetchOpenOrders",n,i);let a=this.getSupportedMapping(r,{spot:"privateSpotGetSpotOrderCurrent",margin:"privateSpotGetMarginOrderCurrent",swap:"privateSwapGetTradeOpenOrders"});const[o,d]=this.handleMarginModeAndParams("fetchOpenOrders",i);o!==void 0&&(a="privateSpotGetMarginOrderCurrent",r="margin");const c={},u=r==="swap";if(u?(t!==void 0&&(c.start_timestamp=t),s!==void 0&&(c.limit=s)):c.market=r,n!==void 0){const p=u?"instrument_id":"symbol";c[p]=n.id}const h=await this[a](this.extend(c,d)),l=this.safeValue(h,"data",[]);return this.parseOrders(l,n,t,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));let r;[r,i]=this.handleMarketTypeAndParams("fetchOrders",n,i);let a=this.getSupportedMapping(r,{spot:"privateSpotGetSpotOrderHistory",margin:"privateSpotGetMarginOrderHistory",swap:"privateSwapGetTradeHistoryOrders"});const[o,d]=this.handleMarginModeAndParams("fetchOrders",i);o!==void 0&&(a="privateSpotGetMarginOrderHistory",r="margin");const c={};if(r==="swap"?t!==void 0&&(c.start_timestamp=t):(c.market=r,t!==void 0&&(c.start_time=parseInt(t/1e3))),n!==void 0){const l=r==="swap"?"instrument_id":"symbol";c[l]=n.id}s!==void 0&&(c.limit=s);const u=await this[a](this.extend(c,d)),h=this.safeValue(u,"data",[]);return this.parseOrders(h,n,t,s)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));let n;[n,s]=this.handleMarketTypeAndParams("fetchOrder",i,s);let r=this.getSupportedMapping(n,{spot:"privateSpotGetSpotOrder",margin:"privateSpotGetMarginOrder",swap:"privateSwapGetTradeOrderInfo"});const[a,o]=this.handleMarginModeAndParams("fetchOrder",s);a!==void 0&&(r="privateSpotGetMarginOrder",n="margin");const d={order_id:e};n==="swap"?i!==void 0&&(d.instrument_id=i.id):d.market=n;const c=await this[r](this.extend(d,o)),u=this.safeValue(c,"data"),h=n==="swap"?u:this.safeValue(u,0);if(h===void 0)throw new S0(this.id+" fetchOrder() order "+e.toString()+" not found");return this.parseOrder(h,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeString(this.options,"defaultType","spot"),r=this.safeString(i,"type",n);i=this.omit(i,"type"),await this.loadMarkets();let a;const o={market:r};e!==void 0&&(a=this.market(e),o.symbol=a.id),t!==void 0&&(o.start_time=parseInt(t/1e3)),s!==void 0&&(o.limit=s);const d=await this.privateSpotGetMarketMytrades(this.extend(o,i)),c=this.safeValue(d,"list",[]);return this.parseTrades(c,a,t,s)}parseLedgerEntryType(e){const t={};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"num"),i=void 0,n=this.parseLedgerEntryType(this.safeString(e,"type")),r=this.safeCurrencyCode(this.safeString(e,"currency_mark"),t),a=this.safeTimestamp(e,"time"),o=void 0,d=this.safeNumber(e,"balance");return{info:e,id:s,direction:void 0,account:i,referenceId:void 0,referenceAccount:void 0,type:n,currency:r,amount:void 0,before:o,after:d,status:"ok",timestamp:a,datetime:this.iso8601(a),fee:void 0}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeString(this.options,"defaultType","spot"),r=this.safeString(i,"type",n);i=this.omit(i,"type"),await this.loadMarkets();const a={market:r};let o;e!==void 0&&(o=this.currency(e),a.currency_mark=o.id),t!==void 0&&(a.start_time=parseInt(t/1e3)),s!==void 0&&(a.limit=s);const d=await this.privateSpotGetMarketFinancelog(this.extend(a,i)),c=this.safeValue(d,"data",{}),u=this.safeValue(c,"finance",[]);return this.parseLedger(u,o,t,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"addressTag"),n=this.safeStringUpper(e,"currency"),r=this.safeCurrencyCode(n);return{info:e,currency:r,address:s,tag:i,network:void 0}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.privateSpotGetDepositAddress(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.parseDepositAddresses(r),o=this.safeValue(a,e);if(o===void 0)throw new k0(this.id+" fetchDepositAddress() did not return an address for "+e+" - create the deposit address in the user settings on the exchange website first.");return o}async fetchTransactionsByType(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;const a={};t!==void 0&&(r=this.currency(t),a.currency=r.id),i!==void 0&&(a.size=Math.min(500,i));const d=await this[e==="deposit"?"privateSpotGetDepositHistory":"privateSpotGetWithdrawHistory"](this.extend(a,n)),c=this.safeValue(d,"data",[]);return this.parseTransactions(c,r,s,i,{type:e})}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByType("deposit",e,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByType("withdrawal",e,t,s,i)}parseTransactionStatus(e){const t={1:"pending",2:"pending",3:"ok",4:"failed"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"id","withdraw_id"),i=this.safeString(e,"address"),n=this.safeString(e,"memo"),r=this.safeString(e,"hash"),a=this.safeStringUpper(e,"currency"),o=this.safeCurrencyCode(a,t),d=this.parse8601(this.safeString(e,"created_date")),c=this.parse8601(this.safeString(e,"finished_date")),u=this.parseTransactionStatus(this.safeString(e,"state")),h=this.safeNumber(e,"amount"),l=this.safeNumber(e,"fee");let p;l!==void 0&&(p={currency:o,cost:l});const m=this.safeString(e,"chain");return{info:e,id:s,txid:r,timestamp:d,datetime:this.iso8601(d),network:m,address:i,addressTo:i,addressFrom:void 0,tag:n,tagTo:n,tagFrom:void 0,type:void 0,amount:h,currency:o,status:u,updated:c,fee:p}}parseTransferStatus(e){const t={0:"ok"};return this.safeString(t,e,e)}parseTransfer(e,t=void 0){let s,i;const n=this.safeInteger(e,"type");n===1?(s="spot",i="swap"):n===2&&(s="swap",i="spot");const r=this.safeInteger(e,"timestamp");return{info:e,id:this.safeString(e,"transfer_id"),timestamp:r,datetime:this.iso8601(r),currency:this.safeCurrencyCode(this.safeString(e,"currency"),t),amount:this.safeNumber(e,"amount"),fromAccount:s,toAccount:i,status:this.parseTransferStatus(this.safeString(e,"code"))}}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c={currency_mark:r.id,num:parseFloat(this.currencyToPrecision(e,t)),from:o,to:d},u=await this.privateSpotPostTransfer(this.extend(c,n)),h=this.parseTransfer(u,r);return this.extend(h,{amount:t,currency:e,fromAccount:s,toAccount:i})}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={address:s,amount:parseFloat(t),currency:r.id};i!==void 0&&(a.memo=i);const o=await this.privateSpotPostWithdrawNew(this.extend(a,n));return this.parseTransaction(o,r)}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a;t!==void 0&&(a=this.market(t),r.symbol=a.id);const o=await this.privateSpotGetMarginPositions(this.extend(r,n)),d=this.safeValue(o,"positions"),c=this.parseBorrowInterests(d,a);return this.filterByCurrencySinceLimit(c,e,s,i)}parseBorrowInterest(e,t){const s=this.safeString(e,"symbol"),i=this.safeString(e,"amount"),n=this.safeString(e,"leverage_ratio"),r=Lk.stringDiv(i,n),a=Lk.stringSub(i,r),o=t===void 0?void 0:t.base;return{account:this.safeSymbol(s,t),currency:o,interest:void 0,interestRate:.001,amountBorrowed:this.parseNumber(a),timestamp:void 0,datetime:void 0,info:e}}async fetchBorrowRate(e,t={}){await this.loadMarkets();const s={},i=await this.privateSpotGetMarginAssets(this.extend(s,t)),n=this.safeValue(i,"list",[]);let r=[];for(let o=0;o<n.length;o++){const d=n[o];this.safeString(d,"currency")===e&&(r=d)}const a=this.safeString(r,"currency");return this.parseBorrowRate(r,a)}async fetchBorrowRates(e={}){await this.loadMarkets();const t=await this.privateSpotGetMarginAssets(e),s=this.safeValue(t,"list");return this.parseBorrowRates(s,"currency")}parseBorrowRate(e,t=void 0){const s=this.milliseconds(),i=this.safeString(e,"currency");return{currency:this.safeCurrencyCode(i,t),rate:.001,period:864e5,timestamp:s,datetime:this.iso8601(s),info:e}}parseBorrowRates(e,t){const s={};for(let i=0;i<e.length;i++){const n=e[i],r=this.safeString(n,t),a=this.safeCurrencyCode(r),o=this.parseBorrowRate(n,r);s[a]=o}return s}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new wc(this.id+" fetchFundingRate() supports swap contracts only");const i={instrument_id:s.id},n=await this.publicSwapGetPublicFundingRate(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseFundingRate(r,s)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"instrument_id"),i=this.safeInteger(e,"funding_time"),n=this.safeInteger(e,"next_funding_time");return{info:e,symbol:this.safeSymbol(s,t),markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeString(e,"funding_rate"),fundingTimestamp:i,fundingDatetime:this.iso8601(i),nextFundingRate:this.safeString(e,"next_funding_rate"),nextFundingTimestamp:n,nextFundingDatetime:this.iso8601(n),previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){this.checkRequiredSymbol("fetchFundingRateHistory",e),await this.loadMarkets();const n=this.market(e);if(!n.swap)throw new wc(this.id+" fetchFundingRateHistory() supports swap contracts only");const r={instrument_id:n.id};t!==void 0&&(r.start_timestamp=t),s!==void 0&&(r.limit=s);const a=await this.publicSwapGetPublicFundingRateHistory(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"funding_rates",[]),c=[];for(let h=0;h<d.length;h++){const l=d[h],p=this.safeString(o,"instrument_id"),m=this.safeSymbol(p),g=this.safeInteger(l,"time");c.push({info:l,symbol:m,fundingRate:this.safeString(l,"rate"),timestamp:g,datetime:this.iso8601(g)})}const u=this.sortBy(c,"timestamp");return this.filterBySymbolSinceLimit(u,e,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new Ks(this.id+" fetchTradingFee() supports swap markets only");const i={instrument_id:s.id},n=await this.privateSwapGetAccountTradingFeeRate(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTradingFee(r,s)}parseTradingFee(e,t=void 0){const s=this.safeString(e,"instrument_id"),i=this.safeSymbol(s,t);return{info:e,symbol:i,maker:this.safeNumber(e,"maker_fee_rate"),taker:this.safeNumber(e,"taker_fee_rate")}}async fetchPositions(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={};let i,n;if(e!==void 0){let l;if(Array.isArray(e)){if(e.length>1)throw new Ks(this.id+" fetchPositions() symbols argument cannot contain more than 1 symbol");l=e[0]}else l=e;i=this.market(l)}[n,t]=this.handleMarketTypeAndParams("fetchPositions",i,t);const[r,a]=this.handleMarginModeAndParams("fetchPositions",t);if(r!==void 0&&(n="margin"),i!==void 0){const l=n==="swap"?"instrument_id":"symbol";s[l]=i.id}const o=this.getSupportedMapping(n,{spot:"privateSpotGetMarginPositions",margin:"privateSpotGetMarginPositions",swap:"privateSwapGetAccountPositions"}),d=await this[o](this.extend(s,a)),c=n==="swap"?"data":"positions",u=this.safeValue(d,c,[]),h=[];for(let l=0;l<u.length;l++)h.push(this.parsePosition(u[l],i));return this.filterByArray(h,"symbol",e,!1)}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e),i={};let n;[n,t]=this.handleMarketTypeAndParams("fetchPosition",s,t);const[r,a]=this.handleMarginModeAndParams("fetchPosition",t);r!==void 0&&(n="margin");const o=this.getSupportedMapping(n,{spot:"privateSpotGetMarginPositions",margin:"privateSpotGetMarginPositions",swap:"privateSwapGetAccountPositions"}),d=n==="swap"?"instrument_id":"symbol";i[d]=s.id;const c=await this[o](this.extend(i,a)),u=n==="swap"?"data":"positions",h=this.safeValue(c,u,[]),l=this.parsePosition(h[0],s);return n==="swap"?l:this.extend(l,{collateral:this.safeNumber(c,"margin"),marginRatio:this.safeNumber(c,"margin_rate")})}parsePosition(e,t=void 0){const s=this.safeString2(e,"instrument_id","symbol");t=this.safeMarket(s,t);const i=t.symbol;let n=this.safeString(e,"margin_mode");n!==void 0?n=n==="crossed"?"cross":"isolated":n="crossed";const r=this.safeInteger(e,"timestamp");let a=this.safeString(e,"side");return a==="go_long"?a="long":a==="go_short"&&(a="short"),{info:e,id:void 0,symbol:i,notional:this.safeNumber(e,"amount"),marginMode:n,liquidationPrice:this.safeNumber(e,"liquidation_price"),entryPrice:this.safeNumber2(e,"avg_cost","entry_price"),unrealizedPnl:this.safeNumber(e,"unrealized_pnl"),contracts:this.safeNumber(e,"avail_position"),contractSize:this.safeNumber(t,"contractSize"),markPrice:this.safeNumber(e,"last"),side:a,hedged:void 0,timestamp:r,datetime:this.iso8601(r),maintenanceMargin:this.safeNumber(e,"margin"),maintenanceMarginPercentage:this.safeNumber(e,"maint_margin_ratio"),collateral:void 0,initialMargin:void 0,initialMarginPercentage:void 0,leverage:this.safeNumber2(e,"leverage","leverage_ratio"),marginRatio:this.safeNumber(e,"margin_ratio"),percentage:void 0}}async setLeverage(e,t=void 0,s={}){await this.loadMarkets(),this.checkRequiredSymbol("setLeverage",t);const i=this.market(t);if(i.type!=="swap")throw new wc(this.id+" setLeverage() supports swap contracts only");if(e<1||e>100)throw new Ks(this.id+" leverage should be between 1 and 100");const n={instrument_id:i.id,leverage:e},r=this.safeString2(this.options,"marginMode","defaultMarginMode");let a=this.safeStringLower2(s,"marginMode","defaultMarginMode",r);if(a!==void 0&&(a=a==="cross"?"crossed":"isolated",n.margin_mode=a,s=this.omit(s,["marginMode","defaultMarginMode"])),a==="isolated"){const o=this.safeString(s,"side");o!==void 0?(n.side=o,s=this.omit(s,"side")):this.checkRequiredArgument("setLeverage",o,"side",["long","short"])}return await this.privateSwapPostAccountLeverage(this.extend(n,s))}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.safeCurrencyCode(e),r.currency=n.id),t!==void 0&&(r.start_timestamp=t),s!==void 0&&(r.limit=s);const a=await this.privateSwapGetAccountTransferRecord(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransfers(o,n,t,s)}handleMarginModeAndParams(e,t={},s=void 0){const i=this.safeString(this.options,"defaultType"),n=this.safeValue(t,"margin",!1);let r;if([r,t]=super.handleMarginModeAndParams(e,t,s),r!==void 0){if(r!=="cross")throw new pF(this.id+" only cross margin is supported")}else(i==="margin"||n===!0)&&(r="cross");return[r,t]}sign(e,t=[],s="GET",i={},n=void 0,r=void 0){const a=t[0]==="private",d=t[1]==="spot"?"/v3":"/swap/v2",c="/"+this.implodeParams(e,i),u=d+c;let h=this.urls.api.rest+u;const l=this.omit(i,this.extractParams(e));let p=this.urlencode(this.keysort(l));if(a){let m,g;if(d==="/swap/v2"){if(g=this.milliseconds().toString(),m=g+s+u,s==="GET")p&&(m+="?"+p);else if(s==="POST"){const b=JSON.stringify(i);p=b,m+=b}}else g=this.nonce().toString(),m=p;const y=this.hmac(this.encode(m),this.encode(this.secret));s==="GET"?p&&(h+="?"+p):s==="POST"&&(n={"Content-Type":"application/x-www-form-urlencoded"},p&&(r=p)),n={"ACCESS-KEY":this.apiKey,"ACCESS-SIGN":y,"ACCESS-TIMESTAMP":g}}else p&&(h+="?"+p);return{url:h,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(!a)return;const c=this.safeString(a,"code");if(c==="0"||c==="200")return;const u=this.id+" "+r;if(c===void 0)throw new hF(u);const h=[Bf,u],[l,p]=this.safeValue(this.exceptions.exact,c,h);throw new l(p)}};const wF=me,{ArgumentsRequired:Rk,ExchangeError:Nf,OrderNotFound:Fk,AuthenticationError:Dk,InsufficientFunds:Hk,InvalidOrder:Sc,InvalidNonce:SF,OnMaintenance:kF,RateLimitExceeded:Gk,BadRequest:Ef,PermissionDenied:Uk}=oe,{TICK_SIZE:vF}=pe,ar=ke;var L_=class extends wF{describe(){return this.deepExtend(super.describe(),{id:"exmo",name:"EXMO",countries:["LT"],rateLimit:350,version:"v1.1",has:{CORS:void 0,spot:!0,margin:!0,swap:!1,future:!1,option:!1,addMargin:!0,cancelOrder:!0,cancelOrders:!1,createDepositAddress:!1,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!1,fetchBalance:!0,fetchCanceledOrders:!0,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:"emulated",fetchOrderBook:!0,fetchOrderBooks:!0,fetchOrderTrades:!0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFees:!0,fetchTransactions:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,reduceMargin:!0,setMargin:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1","5m":"5","15m":"15","30m":"30","45m":"45","1h":"60","2h":"120","3h":"180","4h":"240","1d":"D","1w":"W","1M":"M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766491-1b0ea956-5eda-11e7-9225-40d67b481b8d.jpg",api:{public:"https://api.exmo.com",private:"https://api.exmo.com",web:"https://exmo.me"},www:"https://exmo.me",referral:"https://exmo.me/?ref=131685",doc:["https://exmo.me/en/api_doc?ref=131685"],fees:"https://exmo.com/en/docs/fees"},api:{web:{get:["ctrl/feesAndLimits","en/docs/fees"]},public:{get:["currency","currency/list/extended","order_book","pair_settings","ticker","trades","candles_history","required_amount","payments/providers/crypto/list"]},private:{post:["user_info","order_create","order_cancel","stop_market_order_create","stop_market_order_cancel","user_open_orders","user_trades","user_cancelled_orders","order_trades","deposit_address","withdraw_crypt","withdraw_get_txid","excode_create","excode_load","code_check","wallet_history","wallet_operations","margin/user/order/create","margin/user/order/update","margin/user/order/cancel","margin/user/position/close","margin/user/position/margin_add","margin/user/position/margin_remove","margin/currency/list","margin/pair/list","margin/settings","margin/funding/list","margin/user/info","margin/user/order/list","margin/user/order/history","margin/user/order/trades","margin/user/order/max_quantity","margin/user/position/list","margin/user/position/margin_remove_info","margin/user/position/margin_add_info","margin/user/wallet/list","margin/user/wallet/history","margin/user/trade/list","margin/trades","margin/liquidation/feed"]}},fees:{trading:{feeSide:"get",tierBased:!0,percentage:!0,maker:this.parseNumber("0.004"),taker:this.parseNumber("0.004")},transaction:{tierBased:!1,percentage:!1}},options:{networks:{ETH:"ERC20",TRX:"TRC20"},fetchTradingFees:{method:"fetchPrivateTradingFees"},margin:{fillResponseFromRequest:!0}},commonCurrencies:{GMT:"GMT Token"},precisionMode:vF,exceptions:{exact:{40005:Dk,40009:SF,40015:Nf,40016:kF,40017:Dk,40032:Uk,40033:Uk,40034:Gk,50052:Hk,50054:Hk,50304:Fk,50173:Fk,50277:Sc,50319:Sc,50321:Sc,50381:Sc},broad:{"range period is too long":Ef,"invalid syntax":Ef,"API rate limit exceeded":Gk}}})}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets();const n=this.market(e),r={position_id:n.id,quantity:t};let a;s==="add"?a="privatePostMarginUserPositionMarginAdd":s==="reduce"&&(a="privatePostMarginUserPositionMarginReduce");const o=await this[a](this.extend(r,i)),d=this.parseMarginModification(o,n),c=this.safeValue(this.options,"margin",{});return this.safeValue(c,"fillResponseFromRequest",!0)&&(d.type=s,d.amount=t),d}parseMarginModification(e,t=void 0){return{info:e,type:void 0,amount:void 0,code:this.safeValue(t,"quote"),symbol:this.safeSymbol(void 0,t),total:void 0,status:"ok"}}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"reduce",s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"add",s)}async fetchTradingFees(e={}){let t=this.safeString(e,"method");if(e=this.omit(e,"method"),t===void 0){const s=this.safeValue(this.options,"fetchTradingFees",{});t=this.safeString(s,"method","fetchPrivateTradingFees")}return await this[t](e)}async fetchPrivateTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostMarginPairList(e),s=this.safeValue(t,"pairs",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"name"),o=this.safeSymbol(a,void 0,"_"),d=this.safeString(r,"trade_maker_fee"),c=this.safeString(r,"trade_taker_fee"),u=this.parseNumber(ar.stringDiv(d,"100")),h=this.parseNumber(ar.stringDiv(c,"100"));i[o]={info:r,symbol:o,maker:u,taker:h,percentage:!0,tierBased:!0}}return i}async fetchPublicTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetPairSettings(e),s={};for(let i=0;i<this.symbols.length;i++){const n=this.symbols[i],r=this.market(n),a=this.safeValue(t,r.id,{}),o=this.safeString(a,"commission_maker_percent"),d=this.safeString(a,"commission_taker_percent"),c=this.parseNumber(ar.stringDiv(o,"100")),u=this.parseNumber(ar.stringDiv(d,"100"));s[n]={info:a,symbol:n,maker:c,taker:u,percentage:!0,tierBased:!0}}return s}parseFixedFloatValue(e){if(e===void 0||e==="-")return;if(e==="")return 0;const t=e.indexOf("%")>=0,i=e.split(" ")[0].replace("%",""),n=parseFloat(i);if(n>0&&t)throw new Nf(this.id+" parseFixedFloatValue() detected an unsupported non-zero percentage-based fee "+e);return n}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetPaymentsProvidersCryptoList(t),i={},n=Object.keys(s);for(let r=0;r<n.length;r++){const a=n[r];if(e!==void 0&&!this.inArray(a,e))continue;i[a]={deposit:void 0,withdraw:void 0};const o=this.currency(a),d=this.safeString(o,"id"),c=this.safeValue(s,d,[]);for(let u=0;u<c.length;u++){const h=c[u],l=this.safeString(h,"type"),p=this.safeString(h,"commission_desc"),m=this.parseFixedFloatValue(p);i[a][l]=m}i[a].info=c}return this.options.transactionFees=i,i}async fetchCurrencies(e={}){const t=await this.publicGetCurrencyListExtended(e),s=await this.publicGetPaymentsProvidersCryptoList(e),i={};for(let n=0;n<t.length;n++){const r=t[n],a=this.safeString(r,"name"),o=this.safeString(r,"description"),d=this.safeValue(s,a);let c=!1,u="crypto";const h={deposit:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}};let l,p,m;if(d===void 0)c=!0,u="fiat";else for(let y=0;y<d.length;y++){const b=d[y],w=this.safeString(b,"type"),S=this.safeNumber(b,"min");let k=this.safeNumber(b,"max");k===0&&(k=void 0);const T=this.safeValue(b,"enabled");if(w==="deposit"?T&&!p?p=!0:T||(p=!1):w==="withdraw"&&(T&&!m?m=!0:T||(m=!1)),T&&(c=!0,(h[w].min===void 0||S<h[w].min)&&(h[w].min=S,h[w].max=k,w==="withdraw"))){const I=this.safeString(b,"commission_desc");l=this.parseFixedFloatValue(I)}}const g=this.safeCurrencyCode(a);i[g]={id:a,code:g,name:o,type:u,active:c,deposit:p,withdraw:m,fee:l,precision:this.parseNumber("0.00000001"),limits:h,info:d}}return i}async fetchMarkets(e={}){const t=await this.publicGetPairSettings(e),s=Object.keys(t),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=t[r],o=r.replace("_","/"),[d,c]=o.split("/"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),l=this.safeString(a,"commission_taker_percent"),p=this.safeString(a,"commission_maker_percent");i.push({id:r,symbol:o,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!0,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,taker:this.parseNumber(ar.stringDiv(l,"100")),maker:this.parseNumber(ar.stringDiv(p,"100")),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber("0.00000001"),price:this.parseNumber(this.parsePrecision(this.safeString(a,"price_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(a,"min_quantity"),max:this.safeNumber(a,"max_quantity")},price:{min:this.safeNumber(a,"min_price"),max:this.safeNumber(a,"max_price")},cost:{min:this.safeNumber(a,"min_amount"),max:this.safeNumber(a,"max_amount")}},info:a})}return i}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,resolution:this.timeframes[t]},o=this.safeValue(this.options,"fetchOHLCV"),d=this.safeInteger(o,"maxLimit",3e3),c=this.parseTimeframe(t),u=this.milliseconds();if(s===void 0)i===void 0&&(i=1e3),i>d&&(i=d),a.from=parseInt(u/1e3)-i*c-1,a.to=parseInt(u/1e3);else if(a.from=parseInt(s/1e3)-1,i===void 0)a.to=parseInt(u/1e3);else{if(i>d)throw new Ef(this.id+" fetchOHLCV() will serve "+d.toString()+" candles at most");const p=this.sum(s,i*c*1e3);a.to=parseInt(p/1e3)}const h=await this.publicGetCandlesHistory(this.extend(a,n)),l=this.safeValue(h,"candles",[]);return this.parseOHLCVs(l,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"t"),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}parseBalance(e){const t={info:e},s=this.safeValue(e,"balances",{}),i=this.safeValue(e,"reserved",{}),n=Object.keys(s);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeCurrencyCode(a),d=this.account();a in s&&(d.free=this.safeString(s,a)),a in i&&(d.used=this.safeString(i,a)),t[o]=d}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostUserInfo(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetOrderBook(this.extend(n,s)),a=this.safeValue(r,i.id);return this.parseOrderBook(a,i.symbol,void 0,"bid","ask")}async fetchOrderBooks(e=void 0,t=void 0,s={}){await this.loadMarkets();let i;if(e===void 0){if(i=this.ids.join(","),i.length>2048){const d=this.ids.length;throw new Nf(this.id+" fetchOrderBooks() has "+d.toString()+" symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchOrderBooks")}}else i=this.marketIds(e),i=i.join(",");const n={pair:i};t!==void 0&&(n.limit=t);const r=await this.publicGetOrderBook(this.extend(n,s)),a={},o=Object.keys(r);for(let d=0;d<o.length;d++){const c=o[d],u=this.safeSymbol(c);a[u]=this.parseOrderBook(r[c],u,void 0,"bid","ask")}return a}parseTicker(e,t=void 0){const s=this.safeTimestamp(e,"updated");t=this.safeMarket(void 0,t);const i=this.safeString(e,"last_trade");return this.safeTicker({symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy_price"),bidVolume:void 0,ask:this.safeString(e,"sell_price"),askVolume:void 0,vwap:void 0,open:void 0,close:i,last:i,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeString(e,"avg"),baseVolume:this.safeString(e,"vol"),quoteVolume:this.safeString(e,"vol_curr"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTicker(t),i={},n=Object.keys(s);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeMarket(a,void 0,"_"),d=o.symbol,c=this.safeValue(s,a);i[d]=this.parseTicker(c,o)}return this.filterByArray(i,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=await this.publicGetTicker(t),i=this.market(e);return this.parseTicker(s[i.id],i)}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"date"),i=this.safeString(e,"trade_id"),n=this.safeString(e,"order_id"),r=this.safeString(e,"price"),a=this.safeString(e,"quantity"),o=this.safeString(e,"amount"),d=this.safeString(e,"type"),c=void 0,u=this.safeString(e,"pair");t=this.safeMarket(u,t,"_");const h=t.symbol,l=this.safeString(e,"exec_type");let p;const m=this.safeString(e,"commission_amount");if(m!==void 0){const g=this.safeString(e,"commission_currency"),y=this.safeCurrencyCode(g);let b=this.safeString(e,"commission_percent");b!==void 0&&(b=ar.stringDiv(b,"1000",18)),p={cost:m,currency:y,rate:b}}return this.safeTrade({id:i,info:e,timestamp:s,datetime:this.iso8601(s),symbol:h,order:n,type:c,side:d,takerOrMaker:l,price:r,amount:a,cost:o,fee:p},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id},a=await this.publicGetTrades(this.extend(r,i)),o=this.safeValue(a,n.id,[]);return this.parseTrades(o,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Rk(this.id+" fetchMyTrades() requires a symbol argument (a single symbol or an array)");await this.loadMarkets();let n,r;if(Array.isArray(e)){if(e.length<1)throw new Rk(this.id+" fetchMyTrades() requires a non-empty symbol array");n=this.marketIds(e).join(",")}else r=this.market(e),n=r.id;const a={pair:n};s!==void 0&&(a.limit=s);const o=await this.privatePostUserTrades(this.extend(a,i));let d=[];const c=Object.keys(o);for(let u=0;u<c.length;u++){const h=c[u],l=this.safeMarket(h,void 0,"_"),p=o[h],m=this.parseTrades(p,l,t,s);d=this.arrayConcat(d,m)}return this.filterBySinceLimit(d,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),d=(t==="market"?t+"_":"")+s;let c=n;t==="market"&&n===void 0&&(c=0);const u={pair:a.id,quantity:this.amountToPrecision(a.symbol,i),type:d,price:this.priceToPrecision(a.symbol,c)};let h="privatePostOrderCreate",l=this.safeValue2(r,"client_id","clientOrderId");if(l!==void 0){if(l=this.safeInteger2(r,"client_id","clientOrderId"),l===void 0)throw new Ef(this.id+" createOrder() client order id must be an integer / numeric literal");u.client_id=l,r=this.omit(r,["client_id","clientOrderId"])}if(t==="stop"||t==="stop_limit"||t==="trailing_stop"){const b=this.safeNumber2(r,"stop_price","stopPrice");if(b===void 0)throw new Sc(this.id+" createOrder() requires a stopPrice extra param for a "+t+" order");r=this.omit(r,["stopPrice","stop_price"]),u.stop_price=this.priceToPrecision(e,b),h="privatePostMarginUserOrderCreate"}const p=await this[h](this.extend(u,r)),m=this.safeString(p,"order_id"),g=this.milliseconds(),y="open";return{id:m,info:p,timestamp:g,datetime:this.iso8601(g),lastTradeTimestamp:void 0,status:y,symbol:a.symbol,type:t,side:s,price:n,cost:void 0,amount:i,remaining:i,filled:0,fee:void 0,trades:void 0,clientOrderId:l,average:void 0}}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e};return await this.privatePostOrderCancel(this.extend(i,s))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e.toString()},n=await this.privatePostOrderTrades(this.extend(i,s)),r=this.parseOrder(n);return this.extend(r,{id:e.toString()})}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){let r;t!==void 0&&(r=this.market(t));const a={order_id:e.toString()},o=await this.privatePostOrderTrades(this.extend(a,n)),d=this.safeValue(o,"trades");return this.parseTrades(d,r,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),e!==void 0&&(e=this.market(e).symbol);const n=await this.privatePostUserOpenOrders(i),r=Object.keys(n);let a=[];for(let o=0;o<r.length;o++){const d=r[o],c=this.safeMarket(d),u=this.parseOrders(n[d],c);a=this.arrayConcat(a,u)}return this.filterBySymbolSinceLimit(a,e,t,s)}parseOrder(e,t=void 0){let s=this.safeString(e,"order_id"),i=this.safeTimestamp(e,"created"),n;const r=this.safeString(e,"type");let a;"pair"in e?a=e.pair:"in_currency"in e&&"out_currency"in e&&(r==="buy"?a=e.in_currency+"_"+e.out_currency:a=e.out_currency+"_"+e.in_currency),t=this.safeMarket(a,t);let o=this.safeNumber(e,"quantity");if(o===void 0){const I=r==="buy"?"in_amount":"out_amount";o=this.safeNumber(e,I)}let d=this.safeNumber(e,"price"),c=this.safeNumber(e,"amount"),u=0;const h=[],l=this.safeValue(e,"trades",[]);let p,m,g;const y=l.length;if(y>0){p=0;for(let I=0;I<y;I++){const _=this.parseTrade(l[I],t);s===void 0&&(s=_.order),i===void 0&&(i=_.timestamp),i>_.timestamp&&(i=_.timestamp),u=this.sum(u,_.amount),p=this.sum(p,_.fee.cost),h.push(_)}m=h[y-1].timestamp}let b=this.safeString(e,"status"),w;o!==void 0&&(w=o-u,u>=o?b="closed":b="open"),t===void 0&&(t=this.getMarketFromTrades(h));let S;t!==void 0&&(n=t.symbol,S=t.quote),c===void 0?d!==void 0&&(c=d*u):u>0&&(g===void 0&&(g=c/u),d===void 0&&(d=c/u));const k={cost:p,currency:S},T=this.safeInteger(e,"client_id");return{id:s,clientOrderId:T,datetime:this.iso8601(i),timestamp:i,lastTradeTimestamp:m,status:b,symbol:n,type:"limit",timeInForce:void 0,postOnly:void 0,side:r,price:d,stopPrice:void 0,cost:c,amount:o,filled:u,remaining:w,average:g,trades:h,fee:k,info:e}}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.offset=s),s!==void 0&&(n.limit=s);let r;e!==void 0&&(r=this.market(e));const a=await this.privatePostUserCancelledOrders(this.extend(n,i));return this.parseOrders(a,r,t,s,i)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=await this.privatePostDepositAddress(t),i=this.safeString(s,e);let n,r;if(i){const a=i.split(",");n=a[0],a.length>1&&(r=a[1])}return this.checkAddress(n),{currency:e,address:n,tag:r,network:void 0,info:s}}getMarketFromTrades(e){const t=this.indexBy(e,"pair"),s=Object.keys(t);if(s.length===1)return this.markets[s[0]]}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets();const r=this.currency(e),a={amount:t,currency:r.id,address:s};i!==void 0&&(a.invoice=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeString(o,d,d),d!==void 0&&(a.transport=d,n=this.omit(n,"network"));const c=await this.privatePostWithdrawCrypt(this.extend(a,n));return this.parseTransaction(c,r)}parseTransactionStatus(e){const t={transferred:"ok",paid:"ok",pending:"pending",processing:"pending",verifying:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"order_id","task_id"),i=this.safeTimestamp2(e,"dt","created"),n=this.safeTimestamp(e,"updated");let r=this.safeString(e,"amount");r!==void 0&&(r=ar.stringAbs(r));const a=this.parseTransactionStatus(this.safeStringLower(e,"status"));let o=this.safeString(e,"txid");if(o===void 0){const b=this.safeValue(e,"extra",{}),w=this.safeString(b,"txid");w!==""&&(o=w)}const d=this.safeString(e,"type"),c=this.safeString2(e,"curr","currency"),u=this.safeCurrencyCode(c,t);let h;const l=void 0;let p;const m=this.safeString(e,"account");if(d==="deposit")p=m;else if(d==="withdrawal"&&(h=m,h!==void 0)){const b=h.split(":");b.length===2&&(h=this.safeString(b,1),h=h.replace(" ",""))}let g;if(!this.fees.transaction.percentage){const b=d==="withdrawal"?"withdraw":"deposit";let w=this.safeString(e,"commission");w===void 0&&(w=this.safeString(this.options.transactionFees[u],b)),this.safeString(e,"provider")==="cashback"&&(w="0"),w!==void 0&&(d==="withdrawal"&&(r=ar.stringSub(r,w)),g={cost:this.parseNumber(w),currency:u,rate:void 0})}const y=this.safeString(e,"provider");return{info:e,id:s,timestamp:i,datetime:this.iso8601(i),currency:u,amount:r,network:y,address:h,addressTo:h,addressFrom:void 0,tag:l,tagTo:l,tagFrom:void 0,status:a,type:d,updated:n,comment:p,txid:o,fee:g}}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.date=parseInt(t/1e3));let r;e!==void 0&&(r=this.currency(e));const a=await this.privatePostWalletHistory(this.extend(n,i));return this.parseTransactions(a.history,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={type:"withdraw"};s!==void 0&&(r.limit=s),e!==void 0&&(n=this.currency(e),r.currency=n.id);const a=await this.privatePostWalletOperations(this.extend(r,i)),o=this.safeValue(a,"items",[]);return this.parseTransactions(o,n,t,s)}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();let i;const n={order_id:e,type:"withdraw"};t!==void 0&&(i=this.currency(t),n.currency=i.id);const r=await this.privatePostWalletOperations(this.extend(n,s)),a=this.safeValue(r,"items",[]),o=this.safeValue(a,0,{});return this.parseTransaction(o,i)}async fetchDeposit(e=void 0,t=void 0,s={}){await this.loadMarkets();let i;const n={order_id:e,type:"deposit"};t!==void 0&&(i=this.currency(t),n.currency=i.id);const r=await this.privatePostWalletOperations(this.extend(n,s)),a=this.safeValue(r,"items",[]),o=this.safeValue(a,0,{});return this.parseTransaction(o,i)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={type:"deposit"};s!==void 0&&(r.limit=s),e!==void 0&&(n=this.currency(e),r.currency=n.id);const a=await this.privatePostWalletOperations(this.extend(r,i)),o=this.safeValue(a,"items",[]);return this.parseTransactions(o,n,t,s)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/";if(t!=="web"&&(a+=this.version+"/"),a+=e,t==="public"||t==="web")Object.keys(i).length&&(a+="?"+this.urlencode(i));else if(t==="private"){this.checkRequiredCredentials();const o=this.nonce();r=this.urlencode(this.extend({nonce:o},i)),n={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:this.hmac(this.encode(r),this.encode(this.secret),"sha512")}}return{url:a,method:s,body:r,headers:n}}nonce(){return this.milliseconds()}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&("result"in a||"errmsg"in a)){let c=this.safeValue(a,"result",!1);if(typeof c=="string"&&(c==="true"||c==="1"?c=!0:c=!1),!c){let u;const h=this.safeString2(a,"error","errmsg"),l=h.split(":");if(l.length>1){const g=l[0].split(" ");u=g.length>1?g[1]:g[0]}const m=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,m),this.throwBroadlyMatchedException(this.exceptions.broad,h,m),new Nf(m)}}}};const TF=me,{ExchangeError:Vf,AuthenticationError:Va,InsufficientFunds:OF,BadSymbol:IF,OrderNotFound:xF}=oe,{TICK_SIZE:_F}=pe;var Hl=class extends TF{describe(){return this.deepExtend(super.describe(),{id:"ndax",name:"NDAX",countries:["CA"],rateLimit:1e3,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,createReduceOnlyOrder:!1,editOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!1,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,signIn:!0,transfer:!1,withdraw:!0},timeframes:{"1m":"60","5m":"300","15m":"900","30m":"1800","1h":"3600","2h":"7200","4h":"14400","6h":"21600","12h":"43200","1d":"86400","1w":"604800","1M":"2419200","4M":"9676800"},urls:{logo:"https://user-images.githubusercontent.com/1294454/108623144-67a3ef00-744e-11eb-8140-75c6b851e945.jpg",test:{public:"https://ndaxmarginstaging.cdnhop.net:8443/AP",private:"https://ndaxmarginstaging.cdnhop.net:8443/AP"},api:{public:"https://api.ndax.io:8443/AP",private:"https://api.ndax.io:8443/AP"},www:"https://ndax.io",doc:["https://apidoc.ndax.io/"],fees:"https://ndax.io/fees",referral:"https://one.ndax.io/bfQiSL"},api:{public:{get:{Activate2FA:1,Authenticate2FA:1,AuthenticateUser:1,GetL2Snapshot:1,GetLevel1:1,GetValidate2FARequiredEndpoints:1,LogOut:1,GetTickerHistory:1,GetProduct:1,GetProducts:1,GetInstrument:1,GetInstruments:1,Ping:1,trades:1,GetLastTrades:1,SubscribeLevel1:1,SubscribeLevel2:1,SubscribeTicker:1,SubscribeTrades:1,SubscribeBlockTrades:1,UnsubscribeBlockTrades:1,UnsubscribeLevel1:1,UnsubscribeLevel2:1,UnsubscribeTicker:1,UnsubscribeTrades:1,Authenticate:1}},private:{get:{GetUserAccountInfos:1,GetUserAccounts:1,GetUserAffiliateCount:1,GetUserAffiliateTag:1,GetUserConfig:1,GetAllUnredactedUserConfigsForUser:1,GetUnredactedUserConfigByKey:1,GetUserDevices:1,GetUserReportTickets:1,GetUserReportWriterResultRecords:1,GetAccountInfo:1,GetAccountPositions:1,GetAllAccountConfigs:1,GetTreasuryProductsForAccount:1,GetAccountTrades:1,GetAccountTransactions:1,GetOpenTradeReports:1,GetAllOpenTradeReports:1,GetTradesHistory:1,GetOpenOrders:1,GetOpenQuotes:1,GetOrderFee:1,GetOrderHistory:1,GetOrdersHistory:1,GetOrderStatus:1,GetOmsFeeTiers:1,GetAccountDepositTransactions:1,GetAccountWithdrawTransactions:1,GetAllDepositRequestInfoTemplates:1,GetDepositInfo:1,GetDepositRequestInfoTemplate:1,GetDeposits:1,GetDepositTicket:1,GetDepositTickets:1,GetOMSWithdrawFees:1,GetWithdrawFee:1,GetWithdraws:1,GetWithdrawTemplate:1,GetWithdrawTemplateTypes:1,GetWithdrawTicket:1,GetWithdrawTickets:1},post:{AddUserAffiliateTag:1,CancelUserReport:1,RegisterNewDevice:1,SubscribeAccountEvents:1,UpdateUserAffiliateTag:1,GenerateTradeActivityReport:1,GenerateTransactionActivityReport:1,GenerateTreasuryActivityReport:1,ScheduleTradeActivityReport:1,ScheduleTransactionActivityReport:1,ScheduleTreasuryActivityReport:1,CancelAllOrders:1,CancelOrder:1,CancelQuote:1,CancelReplaceOrder:1,CreateQuote:1,ModifyOrder:1,SendOrder:1,SubmitBlockTrade:1,UpdateQuote:1,CancelWithdraw:1,CreateDepositTicket:1,CreateWithdrawTicket:1,SubmitDepositTicketComment:1,SubmitWithdrawTicketComment:1,GetOrderHistoryByOrderId:1}}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.0025")}},requiredCredentials:{apiKey:!0,secret:!0,uid:!0,login:!0,password:!0},precisionMode:_F,exceptions:{exact:{Not_Enough_Funds:OF,"Server Error":Vf,"Resource Not Found":xF},broad:{"Invalid InstrumentId":IF,"This endpoint requires 2FACode along with the payload":Va}},options:{omsId:1,orderTypes:{Market:1,Limit:2,StopMarket:3,StopLimit:4,TrailingStopMarket:5,TrailingStopLimit:6,BlockTrade:7}}})}async signIn(e={}){if(this.checkRequiredCredentials(),this.login===void 0||this.password===void 0)throw new Va(this.id+" signIn() requires exchange.login, exchange.password");let t={grant_type:"client_credentials"};const s=await this.publicGetAuthenticate(this.extend(t,e));let i=this.safeString(s,"SessionToken");if(i!==void 0)return this.options.sessionToken=i,s;const n=this.safeString(s,"Pending2FaToken");if(n!==void 0){if(this.twofa===void 0)throw new Va(this.id+" signIn() requires exchange.twofa credentials");this.options.pending2faToken=n,t={Code:this.oath()};const r=await this.publicGetAuthenticate2FA(this.extend(t,e));return i=this.safeString(r,"SessionToken"),this.options.sessionToken=i,r}return s}async fetchCurrencies(e={}){const s={omsId:this.safeInteger(this.options,"omsId",1)},i=await this.publicGetGetProducts(this.extend(s,e)),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"ProductId"),d=this.safeString(a,"ProductFullName"),c=this.safeString(a,"ProductType"),u=this.safeCurrencyCode(this.safeString(a,"Product")),l=!this.safeValue(a,"IsDisabled");n[u]={id:o,name:d,code:u,type:c,precision:this.safeNumber(a,"TickSize"),info:a,active:l,deposit:void 0,withdraw:void 0,fee:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}}}return n}async fetchMarkets(e={}){const s={omsId:this.safeInteger(this.options,"omsId",1)},i=await this.publicGetGetInstruments(this.extend(s,e)),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"InstrumentId"),d=this.safeString(a,"Product1"),c=this.safeString(a,"Product2"),u=this.safeCurrencyCode(this.safeString(a,"Product1Symbol")),h=this.safeCurrencyCode(this.safeString(a,"Product2Symbol")),l=this.safeString(a,"SessionStatus"),p=this.safeValue(a,"IsDisable"),m=l==="Running";n.push({id:o,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:m&&!p,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(a,"QuantityIncrement"),price:this.safeNumber(a,"PriceIncrement")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(a,"MinimumQuantity"),max:void 0},price:{min:this.safeNumber(a,"MinimumPrice"),max:void 0},cost:{min:void 0,max:void 0}},info:a})}return n}parseOrderBook(e,t,s=void 0,i="bids",n="asks",r=6,a=8){let o;const d={symbol:t,bids:[],asks:[],timestamp:void 0,datetime:void 0,nonce:void 0};for(let c=0;c<e.length;c++){const u=e[c];if(s===void 0)s=this.safeInteger(u,2);else{const m=this.safeInteger(u,2);s=Math.max(s,m)}if(o===void 0)o=this.safeInteger(u,0);else{const m=this.safeInteger(u,0);o=Math.max(o,m)}const h=this.parseBidAsk(u,r,a),p=this.safeInteger(u,9)?n:i;d[p].push(h)}return d.bids=this.sortBy(d.bids,0,!0),d.asks=this.sortBy(d.asks,0),d.timestamp=s,d.datetime=this.iso8601(s),d.nonce=o,d}async fetchOrderBook(e,t=void 0,s={}){const i=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const n=this.market(e);t=t===void 0?100:t;const r={omsId:i,InstrumentId:n.id,Depth:t},a=await this.publicGetGetL2Snapshot(this.extend(r,s));return this.parseOrderBook(a,e)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"TimeStamp"),i=this.safeString(e,"InstrumentId");t=this.safeMarket(i,t);const n=this.safeSymbol(i,t),r=this.safeString(e,"LastTradedPx"),a=this.safeString(e,"Rolling24HrPxChangePercent"),o=this.safeString(e,"Rolling24HrPxChange"),d=this.safeString(e,"SessionOpen"),c=this.safeString(e,"Rolling24HrVolume"),u=this.safeString(e,"Rolling24HrNotional");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"SessionHigh"),low:this.safeString(e,"SessionLow"),bid:this.safeString(e,"BestBid"),bidVolume:void 0,ask:this.safeString(e,"BestOffer"),askVolume:void 0,vwap:void 0,open:d,close:r,last:r,previousClose:void 0,change:o,percentage:a,average:void 0,baseVolume:c,quoteVolume:u,info:e},t)}async fetchTicker(e,t={}){const s=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const i=this.market(e),n={omsId:s,InstrumentId:i.id},r=await this.publicGetGetLevel1(this.extend(n,t));return this.parseTicker(r,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,3),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){const r=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const a=this.market(e),o={omsId:r,InstrumentId:a.id,Interval:this.timeframes[t]},d=this.parseTimeframe(t),c=this.milliseconds();s===void 0?i!==void 0&&(o.FromDate=this.ymdhms(c-d*i*1e3),o.ToDate=this.ymdhms(c)):(o.FromDate=this.ymdhms(s),i===void 0?o.ToDate=this.ymdhms(c):o.ToDate=this.ymdhms(this.sum(s,d*i*1e3)));const u=await this.publicGetGetTickerHistory(this.extend(o,n));return this.parseOHLCVs(u,a,t,s,i)}parseTrade(e,t=void 0){let s,i,n,r,a,o,d,c,u,h,l;if(Array.isArray(e))s=this.safeString(e,3),i=this.safeString(e,2),r=this.safeInteger(e,6),a=this.safeString(e,0),o=this.safeString(e,1),d=this.safeValue(e,8)?"sell":"buy",c=this.safeString(e,4);else{r=this.safeInteger2(e,"TradeTimeMS","ReceiveTime"),a=this.safeString(e,"TradeId"),c=this.safeString2(e,"OrderId","OrigOrderId"),o=this.safeString2(e,"InstrumentId","Instrument"),s=this.safeString(e,"Price"),i=this.safeString(e,"Quantity"),n=this.safeString2(e,"Value","GrossValueExecuted"),u=this.safeStringLower(e,"MakerTaker"),d=this.safeStringLower(e,"Side"),l=this.safeStringLower(e,"OrderType");const m=this.safeString(e,"Fee");if(m!==void 0){const g=this.safeString(e,"FeeProductId"),y=this.safeCurrencyCode(g);h={cost:m,currency:y}}}const p=this.safeSymbol(o,t);return this.safeTrade({info:e,id:a,symbol:p,timestamp:r,datetime:this.iso8601(r),order:c,type:l,side:d,takerOrMaker:u,price:s,amount:i,cost:n,fee:h},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){const n=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const r=this.market(e),a={omsId:n,InstrumentId:r.id};s!==void 0&&(a.Count=s);const o=await this.publicGetGetLastTrades(this.extend(a,i));return this.parseTrades(o,r,t,s)}async fetchAccounts(e={}){if(!this.login)throw new Va(this.id+" fetchAccounts() requires exchange.login email credential");const t=this.safeInteger(this.options,"omsId",1);this.checkRequiredCredentials();const s={omsId:t,UserId:this.uid,UserName:this.login},i=await this.privateGetGetUserAccounts(this.extend(s,e)),n=[];for(let r=0;r<i.length;r++){const a=this.safeString(i,r);n.push({id:a,type:void 0,currency:void 0,info:a})}return n}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"ProductId");if(n in this.currencies_by_id){const r=this.safeCurrencyCode(n),a=this.account();a.total=this.safeString(i,"Amount"),a.used=this.safeString(i,"Hold"),t[r]=a}}return this.safeBalance(t)}async fetchBalance(e={}){const t=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const s=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),i=this.safeInteger2(e,"accountId","AccountId",s);e=this.omit(e,["accountId","AccountId"]);const n={omsId:t,AccountId:i},r=await this.privateGetGetAccountPositions(this.extend(n,e));return this.parseBalance(r)}parseLedgerEntryType(e){const t={Trade:"trade",Deposit:"transaction",Withdraw:"transaction",Transfer:"transfer",OrderHold:"trade",WithdrawHold:"transaction",DepositHold:"transaction",MarginHold:"trade",ManualHold:"trade",ManualEntry:"trade",MarginAcquisition:"trade",MarginRelinquish:"trade",MarginQuoteHold:"trade"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"TransactionId"),i=this.safeString(e,"AccountId"),n=this.safeString(e,"ReferenceId"),r=this.safeString(e,"Counterparty"),a=this.parseLedgerEntryType(this.safeString(e,"ReferenceType")),o=this.safeString(e,"ProductId"),d=this.safeCurrencyCode(o,t),c=this.safeNumber(e,"CR"),u=this.safeNumber(e,"DR");let h,l;c>0?(h=c,l="in"):u>0&&(h=u,l="out");const p=this.safeInteger(e,"TimeStamp");let m;const g=this.safeNumber(e,"Balance");return l==="out"?m=this.sum(g,h):l==="in"&&(m=Math.max(0,g-h)),{info:e,id:s,direction:l,account:i,referenceId:n,referenceAccount:r,type:a,currency:d,amount:h,before:m,after:g,status:"ok",timestamp:p,datetime:this.iso8601(p),fee:void 0}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const r=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),a=this.safeInteger2(i,"accountId","AccountId",r);i=this.omit(i,["accountId","AccountId"]);const o={omsId:n,AccountId:a};s!==void 0&&(o.Depth=s);const d=await this.privateGetGetAccountTransactions(this.extend(o,i));let c;return e!==void 0&&(c=this.currency(e)),this.parseLedger(d,c,t,s)}parseOrderStatus(e){const t={Accepted:"open",Rejected:"rejected",Working:"open",Canceled:"canceled",Expired:"expired",FullyExecuted:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"ReceiveTime"),i=this.safeString(e,"Instrument");return this.safeOrder({id:this.safeString2(e,"ReplacementOrderId","OrderId"),clientOrderId:this.safeString2(e,"ReplacementClOrdId","ClientOrderId"),info:e,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:this.safeInteger(e,"LastUpdatedTime"),status:this.parseOrderStatus(this.safeString(e,"OrderState")),symbol:this.safeSymbol(i,t),type:this.safeStringLower(e,"OrderType"),timeInForce:void 0,postOnly:void 0,side:this.safeStringLower(e,"Side"),price:this.safeString(e,"Price"),stopPrice:this.parseNumber(this.omitZero(this.safeString(e,"StopPrice"))),cost:this.safeString(e,"GrossValueExecuted"),amount:this.safeString(e,"OrigQuantity"),filled:this.safeString(e,"QuantityExecuted"),average:this.safeString(e,"AvgPrice"),remaining:void 0,fee:void 0,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){const a=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const o=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),d=this.safeInteger2(r,"accountId","AccountId",o),c=this.safeInteger2(r,"ClientOrderId","clientOrderId");r=this.omit(r,["accountId","AccountId","clientOrderId","ClientOrderId"]);const u=this.market(e),h=s==="buy"?0:1,l={InstrumentId:parseInt(u.id),omsId:a,AccountId:d,TimeInForce:1,Side:h,Quantity:parseFloat(this.amountToPrecision(e,i)),OrderType:this.safeInteger(this.options.orderTypes,this.capitalize(t))};n!==void 0&&(l.LimitPrice=parseFloat(this.priceToPrecision(e,n))),c!==void 0&&(l.ClientOrderId=c);const p=await this.privatePostSendOrder(this.extend(l,r));return this.parseOrder(p,u)}async editOrder(e,t,s,i,n,r=void 0,a={}){const o=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const d=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),c=this.safeInteger2(a,"accountId","AccountId",d),u=this.safeInteger2(a,"ClientOrderId","clientOrderId");a=this.omit(a,["accountId","AccountId","clientOrderId","ClientOrderId"]);const h=this.market(t),l=i==="buy"?0:1,p={OrderIdToReplace:parseInt(e),InstrumentId:parseInt(h.id),omsId:o,AccountId:c,TimeInForce:1,Side:l,Quantity:parseFloat(this.amountToPrecision(t,n)),OrderType:this.safeInteger(this.options.orderTypes,this.capitalize(s))};r!==void 0&&(p.LimitPrice=parseFloat(this.priceToPrecision(t,r))),u!==void 0&&(p.ClientOrderId=u);const m=await this.privatePostCancelReplaceOrder(this.extend(p,a));return this.parseOrder(m,h)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const r=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),a=this.safeInteger2(i,"accountId","AccountId",r);i=this.omit(i,["accountId","AccountId"]);const o={omsId:n,AccountId:a};let d;e!==void 0&&(d=this.market(e),o.InstrumentId=d.id),t!==void 0&&(o.StartTimeStamp=parseInt(t/1e3)),s!==void 0&&(o.Depth=s);const c=await this.privateGetGetTradesHistory(this.extend(o,i));return this.parseTrades(c,d,t,s)}async cancelAllOrders(e=void 0,t={}){const s=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const i=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),n=this.safeInteger2(t,"accountId","AccountId",i);t=this.omit(t,["accountId","AccountId"]);const r={omsId:s,AccountId:n};if(e!==void 0){const o=this.market(e);r.IntrumentId=o.id}return await this.privatePostCancelAllOrders(this.extend(r,t))}async cancelOrder(e,t=void 0,s={}){const i=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();let n;t!==void 0&&(n=this.market(t));const r={omsId:i},a=this.safeInteger2(s,"clientOrderId","ClOrderId");a!==void 0?r.ClOrderId=a:r.OrderId=parseInt(e),s=this.omit(s,["clientOrderId","ClOrderId"]);const o=await this.privatePostCancelOrder(this.extend(r,s)),d=this.parseOrder(o,n);return this.extend(d,{id:e,clientOrderId:a})}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const r=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),a=this.safeInteger2(i,"accountId","AccountId",r);i=this.omit(i,["accountId","AccountId"]);let o;e!==void 0&&(o=this.market(e));const d={omsId:n,AccountId:a},c=await this.privateGetGetOpenOrders(this.extend(d,i));return this.parseOrders(c,o,t,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const r=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),a=this.safeInteger2(i,"accountId","AccountId",r);i=this.omit(i,["accountId","AccountId"]);const o={omsId:n,AccountId:a};let d;e!==void 0&&(d=this.market(e),o.InstrumentId=d.id),t!==void 0&&(o.StartTimeStamp=parseInt(t/1e3)),s!==void 0&&(o.Depth=s);const c=await this.privateGetGetOrdersHistory(this.extend(o,i));return this.parseOrders(c,d,t,s)}async fetchOrder(e,t=void 0,s={}){const i=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const n=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),r=this.safeInteger2(s,"accountId","AccountId",n);s=this.omit(s,["accountId","AccountId"]);let a;t!==void 0&&(a=this.market(t));const o={omsId:i,AccountId:r,OrderId:parseInt(e)},d=await this.privateGetGetOrderStatus(this.extend(o,s));return this.parseOrder(d,a)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){const r=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();let a;t!==void 0&&(a=this.market(t));const o={OMSId:parseInt(r),OrderId:parseInt(e)},d=await this.privatePostGetOrderHistoryByOrderId(this.extend(o,n)),c=this.groupBy(d,"ChangeReason"),u=this.safeValue(c,"Trade",[]);return this.parseTrades(u,a,s,i)}async fetchDepositAddress(e,t={}){const s=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const i=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),n=this.safeInteger2(t,"accountId","AccountId",i);t=this.omit(t,["accountId","AccountId"]);const r=this.currency(e),a={omsId:s,AccountId:n,ProductId:r.id,GenerateNewKey:!1},o=await this.privateGetGetDepositInfo(this.extend(a,t));return this.parseDepositAddress(o,r)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"DepositInfo"),i=JSON.parse(s),n=i.length,a=this.safeString(i,n-1).split("?memo="),o=this.safeString(a,0),d=this.safeString(a,1);let c;return t!==void 0&&(c=t.code),this.checkAddress(o),{currency:c,address:o,tag:d,network:void 0,info:e}}async createDepositAddress(e,t={}){const s={GenerateNewKey:!0};return await this.fetchDepositAddress(e,this.extend(s,t))}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const r=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),a=this.safeInteger2(i,"accountId","AccountId",r);i=this.omit(i,["accountId","AccountId"]);let o;e!==void 0&&(o=this.currency(e));const d={omsId:n,AccountId:a},c=await this.privateGetGetDeposits(this.extend(d,i));return this.parseTransactions(c,o,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const r=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),a=this.safeInteger2(i,"accountId","AccountId",r);i=this.omit(i,["accountId","AccountId"]);let o;e!==void 0&&(o=this.currency(e));const d={omsId:n,AccountId:a},c=await this.privateGetGetWithdraws(this.extend(d,i));return this.parseTransactions(c,o,t,s)}parseTransactionStatusByType(e,t=void 0){const s={deposit:{New:"pending",AdminProcessing:"pending",Accepted:"pending",Rejected:"rejected",SystemProcessing:"pending",FullyProcessed:"ok",Failed:"failed",Pending:"pending",Confirmed:"pending",AmlProcessing:"pending",AmlAccepted:"pending",AmlRejected:"rejected",AmlFailed:"failed",LimitsAccepted:"pending",LimitsRejected:"rejected"},withdrawal:{New:"pending",AdminProcessing:"pending",Accepted:"pending",Rejected:"rejected",SystemProcessing:"pending",FullyProcessed:"ok",Failed:"failed",Pending:"pending",Pending2Fa:"pending",AutoAccepted:"pending",Delayed:"pending",UserCanceled:"canceled",AdminCanceled:"canceled",AmlProcessing:"pending",AmlAccepted:"pending",AmlRejected:"rejected",AmlFailed:"failed",LimitsAccepted:"pending",LimitsRejected:"rejected",Submitted:"pending",Confirmed:"pending",ManuallyConfirmed:"pending",Confirmed2Fa:"pending"}},i=this.safeValue(s,t,{});return this.safeString(i,e,e)}parseTransaction(e,t=void 0){let s,i;const n=this.safeString(e,"ProductId"),r=this.safeCurrencyCode(n,t);let a,o;"DepositId"in e?(s=this.safeString(e,"DepositId"),o="deposit"):"WithdrawId"in e&&(s=this.safeString(e,"WithdrawId"),o="withdrawal");const d=this.safeString(e,"TemplateForm");let c,u=this.safeInteger(e,"LastUpdateTimeStamp");if(d!==void 0){const y=JSON.parse(d);c=this.safeString(y,"ExternalAddress"),i=this.safeString(y,"TxId"),a=this.safeInteger(y,"TimeSubmitted"),u=this.safeInteger(y,"LastUpdated",u)}const h=c,l=this.parseTransactionStatusByType(this.safeString(e,"TicketStatus"),o),p=this.safeNumber(e,"Amount"),m=this.safeNumber(e,"FeeAmount");let g;return m!==void 0&&(g={currency:r,cost:m}),{info:e,id:s,txid:i,timestamp:a,datetime:this.iso8601(a),address:c,addressTo:h,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:o,amount:p,currency:r,status:l,updated:u,fee:g}}async withdraw(e,t,s,i=void 0,n={}){if([i,n]=this.handleWithdrawTagAndParams(i,n),this.safeString(this.options,"sessionToken")===void 0)throw new Va(this.id+" call signIn() method to obtain a session token");if(this.twofa===void 0)throw new Va(this.id+" withdraw() requires exchange.twofa credentials");this.checkAddress(s);const a=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const o=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),d=this.safeInteger2(n,"accountId","AccountId",o);n=this.omit(n,["accountId","AccountId"]);const c=this.currency(e),u={omsId:a,AccountId:d,ProductId:c.id},h=await this.privateGetGetWithdrawTemplateTypes(u),l=this.safeValue(h,"TemplateTypes",[]),p=this.safeValue(l,0);if(p===void 0)throw new Vf(this.id+" withdraw() could not find a withdraw template type for "+c.code);const m=this.safeString(p,"TemplateName"),g={omsId:a,AccountId:d,ProductId:c.id,TemplateType:m,AccountProviderId:p.AccountProviderId},y=await this.privateGetGetWithdrawTemplate(g),b=this.safeString(y,"Template");if(b===void 0)throw new Vf(this.id+" withdraw() could not find a withdraw template for "+c.code);const w=JSON.parse(b);w.ExternalAddress=s,i!==void 0&&"Memo"in w&&(w.Memo=i);const S={omsId:a,AccountId:d,ProductId:c.id,TemplateForm:this.json(w),TemplateType:m},k={TfaType:"Google",TFaCode:this.oath(),Payload:this.json(S)},T=await this.privatePostCreateWithdrawTicket(this.deepExtend(k,n));return this.parseTransaction(T,c)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/"+this.implodeParams(e,i),o=this.omit(i,this.extractParams(e));if(t==="public"){if(e==="Authenticate"){const d=this.login+":"+this.password,c=this.stringToBase64(d);n={Authorization:"Basic "+this.decode(c)}}else if(e==="Authenticate2FA"){const d=this.safeString(this.options,"pending2faToken");d!==void 0&&(n={Pending2FaToken:d},o=this.omit(o,"pending2faToken"))}Object.keys(o).length&&(a+="?"+this.urlencode(o))}else if(t==="private"){this.checkRequiredCredentials();const d=this.safeString(this.options,"sessionToken");if(d===void 0){const c=this.nonce().toString(),u=c+this.uid+this.apiKey,h=this.hmac(this.encode(u),this.encode(this.secret));n={Nonce:c,APIKey:this.apiKey,Signature:h,UserId:this.uid}}else n={APToken:d};s==="POST"?(n["Content-Type"]="application/json",r=this.json(o)):Object.keys(o).length&&(a+="?"+this.urlencode(o))}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(e===404)throw new Va(this.id+" "+r);if(a===void 0)return;const c=this.safeString(a,"errormsg");if(c!==void 0&&c!==""){const u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,r,u),new Vf(u)}}};const CF=Hl;var MF=class extends CF{describe(){return this.deepExtend(super.describe(),{id:"flowbtc",name:"flowBTC",countries:["BR"],rateLimit:1e3,urls:{logo:"https://user-images.githubusercontent.com/51840849/87443317-01c0d080-c5fe-11ea-95c2-9ebe1a8fafd9.jpg",api:{public:"https://api.flowbtc.com.br:8443/ap/",private:"https://api.flowbtc.com.br:8443/ap/"},www:"https://www.flowbtc.com.br",doc:"https://www.flowbtc.com.br/api.html"},fees:{trading:{tierBased:!1,percentage:!0,maker:.0025,taker:.005}}})}};const PF=me,je=ke,{TICK_SIZE:AF}=pe,{ExchangeError:ot,BadRequest:Si,ArgumentsRequired:or,AuthenticationError:Vo,PermissionDenied:$k,AccountSuspended:jk,InsufficientFunds:kc,RateLimitExceeded:BF,ExchangeNotAvailable:qf,BadSymbol:vc,InvalidOrder:is,OrderNotFound:Lf,NotSupported:NF,AccountNotEnabled:EF,OrderImmediatelyFillable:Wk}=oe;var Tb=class extends PF{describe(){return this.deepExtend(super.describe(),{id:"gate",name:"Gate.io",countries:["KR"],rateLimit:10/3,version:"v4",certified:!0,pro:!0,urls:{logo:"https://user-images.githubusercontent.com/1294454/31784029-0313c702-b509-11e7-9ccc-bc0da6a0e435.jpg",doc:"https://www.gate.io/docs/apiv4/en/index.html",www:"https://gate.io/",api:{public:{wallet:"https://api.gateio.ws/api/v4",futures:"https://api.gateio.ws/api/v4",margin:"https://api.gateio.ws/api/v4",delivery:"https://api.gateio.ws/api/v4",spot:"https://api.gateio.ws/api/v4",options:"https://api.gateio.ws/api/v4",sub_accounts:"https://api.gateio.ws/api/v4"},private:{withdrawals:"https://api.gateio.ws/api/v4",wallet:"https://api.gateio.ws/api/v4",futures:"https://api.gateio.ws/api/v4",margin:"https://api.gateio.ws/api/v4",delivery:"https://api.gateio.ws/api/v4",spot:"https://api.gateio.ws/api/v4",options:"https://api.gateio.ws/api/v4",subAccounts:"https://api.gateio.ws/api/v4"}},test:{public:{futures:"https://fx-api-testnet.gateio.ws/api/v4",delivery:"https://fx-api-testnet.gateio.ws/api/v4"},private:{futures:"https://fx-api-testnet.gateio.ws/api/v4",delivery:"https://fx-api-testnet.gateio.ws/api/v4"}},referral:{url:"https://www.gate.io/ref/2436035",discount:.2}},has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!0,option:void 0,borrowMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createMarketOrder:!1,createOrder:!0,createPostOnlyOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!1,createStopOrder:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!0,fetchLeverage:!1,fetchLeverageTiers:!0,fetchMarginMode:!1,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchNetworkDepositAddress:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransactionFees:!0,fetchWithdrawals:!0,repayMargin:!0,setLeverage:!0,setMarginMode:!1,transfer:!0,withdraw:!0},api:{public:{wallet:{get:{currency_chains:1.5}},spot:{get:{currencies:1,"currencies/{currency}":1,currency_pairs:1,"currency_pairs/{currency_pair}":1,tickers:1,order_book:1,trades:1,candlesticks:1}},margin:{get:{currency_pairs:1,"currency_pairs/{currency_pair}":1,"cross/currencies":1,"cross/currencies/{currency}":1,funding_book:1}},futures:{get:{"{settle}/contracts":1.5,"{settle}/contracts/{contract}":1.5,"{settle}/order_book":1.5,"{settle}/trades":1.5,"{settle}/candlesticks":1.5,"{settle}/tickers":1.5,"{settle}/funding_rate":1.5,"{settle}/insurance":1.5,"{settle}/contract_stats":1.5,"{settle}/liq_orders":1.5}},delivery:{get:{"{settle}/contracts":1.5,"{settle}/contracts/{contract}":1.5,"{settle}/order_book":1.5,"{settle}/trades":1.5,"{settle}/candlesticks":1.5,"{settle}/tickers":1.5,"{settle}/insurance":1.5}},options:{get:{underlyings:1.5,expirations:1.5,contracts:1.5,"contracts/{contract}":1.5,settlements:1.5,"settlements/{contract}":1.5,order_book:1.5,tickers:1.5,"underlying/tickers/{underlying}":1.5,candlesticks:1.5,"underlying/candlesticks":1.5,trades:1.5}}},private:{withdrawals:{post:{withdrawals:3e3},delete:{"withdrawals/{withdrawal_id}":300}},wallet:{get:{deposit_address:300,withdrawals:300,deposits:300,sub_account_transfers:300,withdraw_status:300,sub_account_balances:300,fee:300,total_balance:300},post:{transfers:300,sub_account_transfers:300}},subAccounts:{get:{sub_accounts:1,"sub_accounts/{user_id}":1,"sub_accounts/{user_id}/keys":1,"sub_accounts/{user_id}/keys/{key}":1},post:{sub_accounts:1,"sub_accounts/{user_id}/keys":1,"sub_accounts/{user_id}/lock":1,"sub_accounts/{user_id}/unlock":1},put:{"sub_accounts/{user_id}/keys/{key}":1},delete:{"sub_accounts/{user_id}/keys/{key}":1}},spot:{get:{accounts:1,open_orders:1,orders:1,"orders/{order_id}":1,my_trades:1,price_orders:1,"price_orders/{order_id}":1},post:{batch_orders:1,orders:1,cancel_batch_orders:1,price_orders:1},delete:{orders:1,"orders/{order_id}":1,price_orders:1,"price_orders/{order_id}":1}},margin:{get:{accounts:1.5,account_book:1.5,funding_accounts:1.5,loans:1.5,"loans/{loan_id}":1.5,"loans/{loan_id}/repayment":1.5,loan_records:1.5,"loan_records/{load_record_id}":1.5,auto_repay:1.5,transferable:1.5,"cross/accounts":1.5,"cross/account_book":1.5,"cross/loans":1.5,"cross/loans/{loan_id}":1.5,"cross/loans/repayments":1.5,"cross/transferable":1.5,"loan_records/{loan_record_id}":1.5,borrowable:1.5,"cross/repayments":1.5,"cross/borrowable":1.5},post:{loans:1.5,merged_loans:1.5,"loans/{loan_id}/repayment":1.5,auto_repay:1.5,"cross/loans":1.5,"cross/loans/repayments":1.5,"cross/repayments":1.5},patch:{"loans/{loan_id}":1.5,"loan_records/{loan_record_id}":1.5},delete:{"loans/{loan_id}":1.5}},futures:{get:{"{settle}/accounts":1.5,"{settle}/account_book":1.5,"{settle}/positions":1.5,"{settle}/positions/{contract}":1.5,"{settle}/orders":1.5,"{settle}/orders/{order_id}":1.5,"{settle}/my_trades":1.5,"{settle}/position_close":1.5,"{settle}/liquidates":1.5,"{settle}/price_orders":1.5,"{settle}/price_orders/{order_id}":1.5,"{settle}/dual_comp/positions/{contract}":1.5},post:{"{settle}/positions/{contract}/margin":1.5,"{settle}/positions/{contract}/leverage":1.5,"{settle}/positions/{contract}/risk_limit":1.5,"{settle}/dual_mode":1.5,"{settle}/dual_comp/positions/{contract}":1.5,"{settle}/dual_comp/positions/{contract}/margin":1.5,"{settle}/dual_comp/positions/{contract}/leverage":1.5,"{settle}/dual_comp/positions/{contract}/risk_limit":1.5,"{settle}/orders":1.5,"{settle}/price_orders":1.5},delete:{"{settle}/orders":1.5,"{settle}/orders/{order_id}":1.5,"{settle}/price_orders":1.5,"{settle}/price_orders/{order_id}":1.5}},delivery:{get:{"{settle}/accounts":1.5,"{settle}/account_book":1.5,"{settle}/positions":1.5,"{settle}/positions/{contract}":1.5,"{settle}/orders":1.5,"{settle}/orders/{order_id}":1.5,"{settle}/my_trades":1.5,"{settle}/position_close":1.5,"{settle}/liquidates":1.5,"{settle}/price_orders":1.5,"{settle}/price_orders/{order_id}":1.5,"{settle}/settlements":1.5},post:{"{settle}/positions/{contract}/margin":1.5,"{settle}/positions/{contract}/leverage":1.5,"{settle}/positions/{contract}/risk_limit":1.5,"{settle}/orders":1.5,"{settle}/price_orders":1.5},delete:{"{settle}/orders":1.5,"{settle}/orders/{order_id}":1.5,"{settle}/price_orders":1.5,"{settle}/price_orders/{order_id}":1.5}},options:{get:{accounts:1.5,account_book:1.5,positions:1.5,"positions/{contract}":1.5,position_close:1.5,orders:1.5,"orders/{order_id}":1.5,my_trades:1.5},post:{orders:1.5},delete:{orders:1.5,"orders/{order_id}":1.5}}}},timeframes:{"10s":"10s","1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","8h":"8h","1d":"1d","7d":"7d","1w":"7d"},commonCurrencies:{"88MPH":"MPH",AXIS:"Axis DeFi",BIFI:"Bitcoin File",BOX:"DefiBox",BTCBEAR:"BEAR",BTCBULL:"BULL",BYN:"BeyondFi",EGG:"Goose Finance",GTC:"Game.com",GTC_HT:"Game.com HT",GTC_BSC:"Game.com BSC",HIT:"HitChain",MM:"Million",MPH:"Morpher",POINT:"GatePoint",RAI:"Rai Reflex Index",SBTC:"Super Bitcoin",TNC:"Trinity Network Credit",TON:"TONToken",VAI:"VAIOT"},requiredCredentials:{apiKey:!0,secret:!0},headers:{"X-Gate-Channel-Id":"ccxt"},options:{createOrder:{expiration:86400},networks:{TRC20:"TRX",ERC20:"ETH",BEP20:"BSC"},timeInForce:{GTC:"gtc",IOC:"ioc",PO:"poc",POC:"poc"},accountsByType:{funding:"spot",spot:"spot",margin:"margin",cross_margin:"cross_margin",cross:"cross_margin",isolated:"margin",swap:"futures",future:"delivery",futures:"futures",delivery:"delivery"},defaultType:"spot",swap:{fetchMarkets:{settlementCurrencies:["usdt","btc"]}},future:{fetchMarkets:{settlementCurrencies:["usdt","btc"]}}},precisionMode:AF,fees:{trading:{tierBased:!0,feeSide:"get",percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002"),tiers:{maker:[[this.parseNumber("0"),this.parseNumber("0.002")],[this.parseNumber("1.5"),this.parseNumber("0.00185")],[this.parseNumber("3"),this.parseNumber("0.00175")],[this.parseNumber("6"),this.parseNumber("0.00165")],[this.parseNumber("12.5"),this.parseNumber("0.00155")],[this.parseNumber("25"),this.parseNumber("0.00145")],[this.parseNumber("75"),this.parseNumber("0.00135")],[this.parseNumber("200"),this.parseNumber("0.00125")],[this.parseNumber("500"),this.parseNumber("0.00115")],[this.parseNumber("1250"),this.parseNumber("0.00105")],[this.parseNumber("2500"),this.parseNumber("0.00095")],[this.parseNumber("3000"),this.parseNumber("0.00085")],[this.parseNumber("6000"),this.parseNumber("0.00075")],[this.parseNumber("11000"),this.parseNumber("0.00065")],[this.parseNumber("20000"),this.parseNumber("0.00055")],[this.parseNumber("40000"),this.parseNumber("0.00055")],[this.parseNumber("75000"),this.parseNumber("0.00055")]],taker:[[this.parseNumber("0"),this.parseNumber("0.002")],[this.parseNumber("1.5"),this.parseNumber("0.00195")],[this.parseNumber("3"),this.parseNumber("0.00185")],[this.parseNumber("6"),this.parseNumber("0.00175")],[this.parseNumber("12.5"),this.parseNumber("0.00165")],[this.parseNumber("25"),this.parseNumber("0.00155")],[this.parseNumber("75"),this.parseNumber("0.00145")],[this.parseNumber("200"),this.parseNumber("0.00135")],[this.parseNumber("500"),this.parseNumber("0.00125")],[this.parseNumber("1250"),this.parseNumber("0.00115")],[this.parseNumber("2500"),this.parseNumber("0.00105")],[this.parseNumber("3000"),this.parseNumber("0.00095")],[this.parseNumber("6000"),this.parseNumber("0.00085")],[this.parseNumber("11000"),this.parseNumber("0.00075")],[this.parseNumber("20000"),this.parseNumber("0.00065")],[this.parseNumber("40000"),this.parseNumber("0.00065")],[this.parseNumber("75000"),this.parseNumber("0.00065")]]}},swap:{tierBased:!0,feeSide:"base",percentage:!0,maker:this.parseNumber("0.0"),taker:this.parseNumber("0.0005"),tiers:{maker:[[this.parseNumber("0"),this.parseNumber("0.0000")],[this.parseNumber("1.5"),this.parseNumber("-0.00005")],[this.parseNumber("3"),this.parseNumber("-0.00005")],[this.parseNumber("6"),this.parseNumber("-0.00005")],[this.parseNumber("12.5"),this.parseNumber("-0.00005")],[this.parseNumber("25"),this.parseNumber("-0.00005")],[this.parseNumber("75"),this.parseNumber("-0.00005")],[this.parseNumber("200"),this.parseNumber("-0.00005")],[this.parseNumber("500"),this.parseNumber("-0.00005")],[this.parseNumber("1250"),this.parseNumber("-0.00005")],[this.parseNumber("2500"),this.parseNumber("-0.00005")],[this.parseNumber("3000"),this.parseNumber("-0.00008")],[this.parseNumber("6000"),this.parseNumber("-0.01000")],[this.parseNumber("11000"),this.parseNumber("-0.01002")],[this.parseNumber("20000"),this.parseNumber("-0.01005")],[this.parseNumber("40000"),this.parseNumber("-0.02000")],[this.parseNumber("75000"),this.parseNumber("-0.02005")]],taker:[[this.parseNumber("0"),this.parseNumber("0.00050")],[this.parseNumber("1.5"),this.parseNumber("0.00048")],[this.parseNumber("3"),this.parseNumber("0.00046")],[this.parseNumber("6"),this.parseNumber("0.00044")],[this.parseNumber("12.5"),this.parseNumber("0.00042")],[this.parseNumber("25"),this.parseNumber("0.00040")],[this.parseNumber("75"),this.parseNumber("0.00038")],[this.parseNumber("200"),this.parseNumber("0.00036")],[this.parseNumber("500"),this.parseNumber("0.00034")],[this.parseNumber("1250"),this.parseNumber("0.00032")],[this.parseNumber("2500"),this.parseNumber("0.00030")],[this.parseNumber("3000"),this.parseNumber("0.00030")],[this.parseNumber("6000"),this.parseNumber("0.00030")],[this.parseNumber("11000"),this.parseNumber("0.00030")],[this.parseNumber("20000"),this.parseNumber("0.00030")],[this.parseNumber("40000"),this.parseNumber("0.00030")],[this.parseNumber("75000"),this.parseNumber("0.00030")]]}}},exceptions:{exact:{INVALID_PARAM_VALUE:Si,INVALID_PROTOCOL:Si,INVALID_ARGUMENT:Si,INVALID_REQUEST_BODY:Si,MISSING_REQUIRED_PARAM:or,BAD_REQUEST:Si,INVALID_CONTENT_TYPE:Si,NOT_ACCEPTABLE:Si,METHOD_NOT_ALLOWED:Si,NOT_FOUND:ot,INVALID_CREDENTIALS:Vo,INVALID_KEY:Vo,IP_FORBIDDEN:Vo,READ_ONLY:$k,INVALID_SIGNATURE:Vo,MISSING_REQUIRED_HEADER:Vo,REQUEST_EXPIRED:Vo,ACCOUNT_LOCKED:jk,FORBIDDEN:$k,SUB_ACCOUNT_NOT_FOUND:ot,SUB_ACCOUNT_LOCKED:jk,MARGIN_BALANCE_EXCEPTION:ot,MARGIN_TRANSFER_FAILED:ot,TOO_MUCH_FUTURES_AVAILABLE:ot,FUTURES_BALANCE_NOT_ENOUGH:kc,ACCOUNT_EXCEPTION:ot,SUB_ACCOUNT_TRANSFER_FAILED:ot,ADDRESS_NOT_USED:ot,TOO_FAST:BF,WITHDRAWAL_OVER_LIMIT:ot,API_WITHDRAW_DISABLED:qf,INVALID_WITHDRAW_ID:ot,INVALID_WITHDRAW_CANCEL_STATUS:ot,INVALID_PRECISION:is,INVALID_CURRENCY:vc,INVALID_CURRENCY_PAIR:vc,POC_FILL_IMMEDIATELY:Wk,ORDER_NOT_FOUND:Lf,CLIENT_ID_NOT_FOUND:Lf,ORDER_CLOSED:is,ORDER_CANCELLED:is,QUANTITY_NOT_ENOUGH:is,BALANCE_NOT_ENOUGH:kc,MARGIN_NOT_SUPPORTED:is,MARGIN_BALANCE_NOT_ENOUGH:kc,AMOUNT_TOO_LITTLE:is,AMOUNT_TOO_MUCH:is,REPEATED_CREATION:is,LOAN_NOT_FOUND:Lf,LOAN_RECORD_NOT_FOUND:Lf,NO_MATCHED_LOAN:ot,NOT_MERGEABLE:ot,NO_CHANGE:ot,REPAY_TOO_MUCH:ot,TOO_MANY_CURRENCY_PAIRS:is,TOO_MANY_ORDERS:is,MIXED_ACCOUNT_TYPE:is,AUTO_BORROW_TOO_MUCH:ot,TRADE_RESTRICTED:kc,USER_NOT_FOUND:EF,CONTRACT_NO_COUNTER:ot,CONTRACT_NOT_FOUND:vc,RISK_LIMIT_EXCEEDED:ot,INSUFFICIENT_AVAILABLE:kc,LIQUIDATE_IMMEDIATELY:is,LEVERAGE_TOO_HIGH:is,LEVERAGE_TOO_LOW:is,ORDER_NOT_OWNED:ot,ORDER_FINISHED:ot,POSITION_CROSS_MARGIN:ot,POSITION_IN_LIQUIDATION:ot,POSITION_IN_CLOSE:ot,POSITION_EMPTY:is,REMOVE_TOO_MUCH:ot,RISK_LIMIT_NOT_MULTIPLE:ot,RISK_LIMIT_TOO_HIGH:ot,RISK_LIMIT_TOO_lOW:ot,PRICE_TOO_DEVIATED:is,SIZE_TOO_LARGE:is,SIZE_TOO_SMALL:is,PRICE_OVER_LIQUIDATION:is,PRICE_OVER_BANKRUPT:is,ORDER_POC_IMMEDIATE:Wk,INCREASE_POSITION:is,CONTRACT_IN_DELISTING:ot,INTERNAL:qf,SERVER_ERROR:qf,TOO_BUSY:qf,CROSS_ACCOUNT_NOT_FOUND:ot,RISK_LIMIT_TOO_LOW:Si}},broad:{}})}async fetchMarkets(e={}){let t=[];const[s,i]=this.handleMarketTypeAndParams("fetchMarkets",void 0,e);if((s==="spot"||s==="margin")&&(t=await this.fetchSpotMarkets(i)),(s==="swap"||s==="future")&&(t=await this.fetchContractMarkets(i)),s==="option"&&(t=await this.fetchOptionMarkets(i)),t.length===0)throw new ot(this.id+" does not support '"+s+"' type, set exchange.options['defaultType'] to 'spot', 'margin', 'swap', 'future' or 'option'");return t}async fetchSpotMarkets(e){const t=await this.publicMarginGetCurrencyPairs(e),s=await this.publicSpotGetCurrencyPairs(e),i=this.indexBy(t,"id"),n=[];for(let r=0;r<s.length;r++){const a=s[r],o=this.safeString(a,"id"),d=this.safeValue(i,o),c=this.deepExtend(d,a),[u,h]=o.split("_"),l=this.safeCurrencyCode(u),p=this.safeCurrencyCode(h),m=this.safeString(c,"fee"),g=this.safeString(c,"maker_fee_rate",m),y=this.parseNumber(this.parsePrecision(this.safeString(c,"amount_precision"))),b=this.safeString(c,"trade_status"),S=this.safeNumber(c,"leverage")!==void 0;n.push({id:o,symbol:l+"/"+p,base:l,quote:p,settle:void 0,baseId:u,quoteId:h,settleId:void 0,type:"spot",spot:!0,margin:S,swap:!1,future:!1,option:!1,active:b==="tradable",contract:!1,linear:void 0,inverse:void 0,taker:this.parseNumber(je.stringDiv(m,"100")),maker:this.parseNumber(je.stringDiv(g,"100")),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:y,price:this.parseNumber(this.parsePrecision(this.safeString(c,"precision")))},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(c,"leverage",1)},amount:{min:this.safeNumber(a,"min_base_amount",y),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(c,"min_quote_amount"),max:S?this.safeNumber(c,"max_quote_amount"):void 0}},info:c})}return n}async fetchContractMarkets(e){const t=[],s=this.getSettlementCurrencies("swap","fetchMarkets"),i=this.getSettlementCurrencies("future","fetchMarkets");for(let n=0;n<s.length;n++){const r=s[n],a=e;a.settle=r;const o=await this.publicFuturesGetSettleContracts(a);for(let d=0;d<o.length;d++){const c=this.parseContractMarket(o[d],r);t.push(c)}}for(let n=0;n<i.length;n++){const r=i[n],a=e;a.settle=r;const o=await this.publicDeliveryGetSettleContracts(a);for(let d=0;d<o.length;d++){const c=this.parseContractMarket(o[d],r);t.push(c)}}return t}parseContractMarket(e,t){const s=this.safeString(e,"name"),i=s.split("_"),n=this.safeString(i,0),r=this.safeString(i,1),a=this.safeString(i,2),o=this.safeCurrencyCode(n),d=this.safeCurrencyCode(r),c=this.safeCurrencyCode(t),u=this.safeTimestamp(e,"expire_time");let h="",l="swap";a!==void 0?(h=o+"/"+d+":"+c+"-"+this.yymmdd(u,""),l="future"):h=o+"/"+d+":"+c;const p=this.safeString(e,"order_price_deviate"),m=this.safeString(e,"mark_price"),g=je.stringSub("1",p),y=je.stringAdd("1",p),b=je.stringMul(g,m),w=je.stringMul(y,m),S=this.safeString(e,"taker_fee_rate"),k=this.safeString(e,"maker_fee_rate",S),T=d===c;return{id:s,symbol:h,base:o,quote:d,settle:c,baseId:n,quoteId:r,settleId:t,type:l,spot:!1,margin:!1,swap:l==="swap",future:l==="future",option:l==="option",active:!0,contract:!0,linear:T,inverse:!T,taker:this.parseNumber(je.stringDiv(S,"100")),maker:this.parseNumber(je.stringDiv(k,"100")),contractSize:this.safeNumber(e,"quanto_multiplier"),expiry:u,expiryDatetime:this.iso8601(u),strike:void 0,optionType:void 0,precision:{amount:this.parseNumber("1"),price:this.safeNumber(e,"order_price_round")},limits:{leverage:{min:this.safeNumber(e,"leverage_min"),max:this.safeNumber(e,"leverage_max")},amount:{min:this.safeNumber(e,"order_size_min"),max:this.safeNumber(e,"order_size_max")},price:{min:this.parseNumber(b),max:this.parseNumber(w)},cost:{min:void 0,max:void 0}},info:e}}async fetchOptionMarkets(e={}){const t=[],s=await this.fetchOptionUnderlyings();for(let i=0;i<s.length;i++){const n=s[i],r=e;r.underlying=n;const a=await this.publicOptionsGetContracts(r);for(let o=0;o<a.length;o++){const d=a[o],c=this.safeString(d,"name"),u=n.split("_"),h=this.safeString(u,0),l=this.safeString(u,1),p=this.safeCurrencyCode(h),m=this.safeCurrencyCode(l);let g=p+"/"+m;const y=this.safeTimestamp(d,"expiration_time"),b=this.safeString(d,"strike_price"),w=this.safeValue(d,"is_call"),S=w?"C":"P",k=w?"call":"put";g=g+":"+m+"-"+this.yymmdd(y)+"-"+b+"-"+S;const T=this.safeString(d,"order_price_deviate"),I=this.safeString(d,"mark_price"),_=je.stringSub("1",T),N=je.stringAdd("1",T),M=je.stringMul(_,I),x=je.stringMul(N,I),v=this.safeString(d,"taker_fee_rate"),O=this.safeString(d,"maker_fee_rate",v);t.push({id:c,symbol:g,base:p,quote:m,settle:m,baseId:h,quoteId:l,settleId:l,type:"option",spot:!1,margin:!1,swap:!1,future:!1,option:!0,active:!0,contract:!0,linear:!0,inverse:!1,taker:this.parseNumber(je.stringDiv(v,"100")),maker:this.parseNumber(je.stringDiv(O,"100")),contractSize:this.parseNumber("1"),expiry:y,expiryDatetime:this.iso8601(y),strike:b,optionType:k,precision:{amount:this.parseNumber("1"),price:this.safeNumber(d,"order_price_round")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(d,"order_size_min"),max:this.safeNumber(d,"order_size_max")},price:{min:this.parseNumber(M),max:this.parseNumber(x)},cost:{min:void 0,max:void 0}},info:d})}}return t}async fetchOptionUnderlyings(){const e=await this.publicOptionsGetUnderlyings(),t=[];for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"name");n!==void 0&&t.push(n)}return t}prepareRequest(e=void 0,t=void 0,s={}){const i={};if(e!==void 0)e.contract?(i.contract=e.id,i.settle=e.settleId):i.currency_pair=e.id;else{const n=t==="swap";if(n||t==="future"){const a=n?"usdt":"btc",o=this.safeStringLower(s,"settle",a);s=this.omit(s,"settle"),i.settle=o}}return[i,s]}spotOrderPrepareRequest(e=void 0,t=!1,s={}){const[i,n]=this.getMarginMode(t,s),r={};if(!t){if(e===void 0)throw new or(this.id+" spotOrderPrepareRequest() requires a market argument for non-stop orders");r.account=i,r.currency_pair=e.id}return[r,n]}multiOrderSpotPrepareRequest(e=void 0,t=!1,s={}){const[i,n]=this.getMarginMode(t,s),r={account:i};return e!==void 0&&(t?r.market=e.id:r.currency_pair=e.id),[r,n]}getMarginMode(e,t){const s=this.safeStringLower2(this.options,"defaultMarginMode","marginMode","spot");let i=this.safeStringLower2(t,"marginMode","account",s);if(t=this.omit(t,["marginMode","account"]),i==="cross"?i="cross_margin":i==="isolated"?i="margin":i===""&&(i="spot"),e&&(i==="spot"&&(i="normal"),i==="cross_margin"))throw new Si(this.id+" getMarginMode() does not support stop orders for cross margin");return[i,t]}getSettlementCurrencies(e,t){const s=this.safeValue(this.options,e,{}),i=this.safeValue(s,t,{}),n=e==="swap"?["usdt"]:["btc"];return this.safeValue(i,"settlementCurrencies",n)}async fetchCurrencies(e={}){if(this.safeValue(this.urls,"apiBackup")!==void 0)return;const s=await this.publicSpotGetCurrencies(e),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeStringLower(r,"currency"),d=this.safeCurrencyCode(a),c=this.safeValue(r,"delisted"),u=this.safeValue(r,"withdraw_disabled",!1),h=this.safeValue(r,"deposit_disabled",!1),l=this.safeValue(r,"trade_disabled",!1),p=!u,m=!h,b=!c&&!l&&p&&m;i[d]={id:a,lowerCaseId:o,name:void 0,code:d,precision:this.parseNumber("1e-6"),info:r,active:b,deposit:m,withdraw:p,fee:void 0,fees:[],limits:this.limits}}return i}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new vc(this.id+" fetchFundingRate() supports swap contracts only");const[i,n]=this.prepareRequest(s,void 0,t),r=await this.publicFuturesGetSettleContractsContract(this.extend(i,n));return this.parseFundingRate(r)}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const[s,i]=this.prepareRequest(void 0,"swap",t),n=await this.publicFuturesGetSettleContracts(this.extend(s,i)),r=this.parseFundingRates(n);return this.filterByArray(r,"symbol",e)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"name"),i=this.safeSymbol(s,t),n=this.safeNumber(e,"mark_price"),r=this.safeNumber(e,"index_price"),a=this.safeNumber(e,"interest_rate"),o=this.safeNumber(e,"funding_rate"),d=this.safeTimestamp(e,"funding_next_apply"),c=this.safeNumber(e,"funding_rate_indicative");return{info:e,symbol:i,markPrice:n,indexPrice:r,interestRate:a,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:o,fundingTimestamp:d,fundingDatetime:this.iso8601(d),nextFundingRate:c,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchNetworkDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.privateWalletGetDepositAddress(this.extend(i,t)),r=this.safeValue(n,"multichain_addresses"),a=this.safeString(n,"currency");e=this.safeCurrencyCode(a);const o={};for(let d=0;d<r.length;d++){const c=r[d];if(this.safeInteger(c,"obtain_failed"))continue;const h=this.safeString(c,"chain"),l=this.safeString(c,"address"),p=this.safeString(c,"payment_id");o[h]={info:c,code:e,currency:e,address:l,tag:p}}return o}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.privateWalletGetDepositAddress(this.extend(i,t)),r=this.safeString(n,"currency");e=this.safeCurrencyCode(r);const a=this.safeString(n,"address");let o,d;if(a!==void 0)if(a.indexOf(" ")>=0){const c=a.split(" ");d=c[0],o=c[1]}else d=a;return this.checkAddress(d),{info:n,code:e,currency:e,address:d,tag:o,network:void 0}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={currency_pair:s.id},n=await this.privateWalletGetFee(this.extend(i,t));return this.parseTradingFee(n,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateWalletGetFee(e);return this.parseTradingFees(t)}parseTradingFees(e){const t={};for(let s=0;s<this.symbols.length;s++){const i=this.symbols[s],n=this.market(i);t[i]=this.parseTradingFee(e,n)}return t}parseTradingFee(e,t=void 0){const s=this.safeValue(t,"contract"),i=s?"futures_taker_fee":"taker_fee",n=s?"futures_maker_fee":"maker_fee";return{info:e,symbol:this.safeString(t,"symbol"),maker:this.safeNumber(e,n),taker:this.safeNumber(e,i)}}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.privateWalletGetWithdrawStatus(t),i={};let n={};for(let r=0;r<s.length;r++){n={};const a=s[r],o=this.safeString(a,"currency"),d=this.safeCurrencyCode(o);if(e!==void 0&&!this.inArray(d,e))continue;const c=this.safeValue(a,"withdraw_fix_on_chains");if(c===void 0)n=this.safeNumber(a,"withdraw_fix");else{const u=Object.keys(c);for(let h=0;h<u.length;h++){const l=u[h];n[l]=this.parseNumber(c[l])}}i[d]={withdraw:n,deposit:void 0,info:a}}return i}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e),e=n.symbol);const[r,a]=this.handleMarketTypeAndParams("fetchFundingHistory",n,i),[o,d]=this.prepareRequest(n,r,a);o.type="fund",t!==void 0&&(o.from=t/1e3),s!==void 0&&(o.limit=s);const c=this.getSupportedMapping(r,{swap:"privateFuturesGetSettleAccountBook",future:"privateDeliveryGetSettleAccountBook"}),u=await this[c](this.extend(o,d));return this.parseFundingHistories(u,e,t,s)}parseFundingHistories(e,t,s,i){const n=[];for(let a=0;a<e.length;a++){const o=e[a],d=this.parseFundingHistory(o);n.push(d)}const r=this.sortBy(n,"timestamp");return this.filterBySymbolSinceLimit(r,t,s,i)}parseFundingHistory(e,t=void 0){const s=this.safeTimestamp(e,"time"),i=this.safeString(e,"text");return t=this.safeMarket(i,t),{info:e,symbol:this.safeString(t,"symbol"),code:this.safeString(t,"settle"),timestamp:s,datetime:this.iso8601(s),id:void 0,amount:this.safeNumber(e,"change")}}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),[n,r]=this.prepareRequest(i,void 0,s),a=this.getSupportedMapping(i.type,{spot:"publicSpotGetOrderBook",margin:"publicSpotGetOrderBook",swap:"publicFuturesGetSettleOrderBook",future:"publicDeliveryGetSettleOrderBook"});t!==void 0&&(n.limit=t),n.with_id=!0;const o=await this[a](this.extend(n,r));let d=this.safeInteger(o,"current");i.spot||(d=d*1e3);const c=i.spot?0:"p",u=i.spot?1:"s",h=this.safeInteger(o,"id"),l=this.parseOrderBook(o,e,d,"bids","asks",c,u);return l.nonce=h,l}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),[i,n]=this.prepareRequest(s,void 0,t),r=this.getSupportedMapping(s.type,{spot:"publicSpotGetTickers",margin:"publicSpotGetTickers",swap:"publicFuturesGetSettleTickers",future:"publicDeliveryGetSettleTickers"}),a=await this[r](this.extend(i,n)),o=this.safeValue(a,0);return this.parseTicker(o,s)}parseTicker(e,t=void 0){const s=this.safeString2(e,"currency_pair","contract"),i=this.safeSymbol(s,t),n=this.safeString(e,"last"),r=this.safeString(e,"lowest_ask"),a=this.safeString(e,"highest_bid"),o=this.safeString(e,"high_24h"),d=this.safeString(e,"low_24h");let c=this.safeString2(e,"base_volume","volume_24h_base");c==="nan"&&(c="0");let u=this.safeString2(e,"quote_volume","volume_24h_quote");u==="nan"&&(u="0");const h=this.safeString(e,"change_percentage");return this.safeTicker({symbol:i,timestamp:void 0,datetime:void 0,high:o,low:d,bid:a,bidVolume:void 0,ask:r,askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:h,average:void 0,baseVolume:c,quoteVolume:u,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeString(e,0);let i;s!==void 0&&(i=this.market(s));const[n,r]=this.handleMarketTypeAndParams("fetchTickers",i,t),[a,o]=this.prepareRequest(void 0,n,r),d=this.getSupportedMapping(n,{spot:"publicSpotGetTickers",margin:"publicSpotGetTickers",swap:"publicFuturesGetSettleTickers",future:"publicDeliveryGetSettleTickers"}),c=await this[d](this.extend(a,o));return this.parseTickers(c,e)}parseBalanceHelper(e){const t=this.account();return t.used=this.safeString2(e,"freeze","locked"),t.free=this.safeString(e,"available"),t.total=this.safeString(e,"total"),"borrowed"in e&&(t.debt=this.safeString(e,"borrowed")),t}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"symbol");e=this.omit(e,"symbol");const[s,i]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),[n,r]=this.prepareRequest(void 0,s,i),[a,o]=this.getMarginMode(!1,r);if(t!==void 0){const m=this.market(t);n.currency_pair=m.id}const d=this.getSupportedMapping(s,{spot:this.getSupportedMapping(a,{spot:"privateSpotGetAccounts",margin:"privateMarginGetAccounts",cross_margin:"privateMarginGetCrossAccounts"}),funding:"privateMarginGetFundingAccounts",swap:"privateFuturesGetSettleAccounts",future:"privateDeliveryGetSettleAccounts"});let c=await this[d](this.extend(n,o));(s==="swap"||s==="future")&&(c=[c]);const h={info:c},l=a==="margin";let p=c;if("balances"in p){const m=[],g=this.safeValue(p,"balances",[]),y=Object.keys(g);for(let b=0;b<y.length;b++){const w=y[b],S=g[w];S.currency=w,m.push(S)}p=m}for(let m=0;m<p.length;m++){const g=p[m];if(l){const y=this.safeString(g,"currency_pair"),b=this.safeSymbol(y,void 0,"_"),w=this.safeValue(g,"base",{}),S=this.safeValue(g,"quote",{}),k=this.safeCurrencyCode(this.safeString(w,"currency")),T=this.safeCurrencyCode(this.safeString(S,"currency")),I={};I[k]=this.parseBalanceHelper(w),I[T]=this.parseBalanceHelper(S),h[b]=this.safeBalance(I)}else{const y=this.safeCurrencyCode(this.safeString(g,"currency"));h[y]=this.parseBalanceHelper(g)}}return l?h:this.safeBalance(h)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.safeString(n,"price");let o={};[o,n]=this.prepareRequest(r,void 0,n),o.interval=this.timeframes[t];let d="publicSpotGetCandlesticks",c=1e3;r.contract&&(c=1999,i=i===void 0?c:Math.min(i,c),r.future?d="publicDeliveryGetSettleCandlesticks":r.swap&&(d="publicFuturesGetSettleCandlesticks"),(a==="mark"||a==="index")&&(o.contract=a+"_"+r.id,n=this.omit(n,"price"))),i=i===void 0?c:Math.min(i,c);let u=this.safeInteger(n,"until");if(u!==void 0&&(u=parseInt(u/1e3),n=this.omit(n,"until")),s!==void 0){const l=this.parseTimeframe(t);o.from=parseInt(s/1e3);const p=this.sum(o.from,i*l-1),m=this.seconds(),g=Math.min(p,m);u!==void 0?o.to=Math.min(g,u):o.to=g}else u!==void 0&&(o.to=u),o.limit=i;const h=await this[d](this.extend(o,n));return this.parseOHLCVs(h,r,t,s,i)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new or(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const n=this.market(e);if(!n.swap)throw new vc(this.id+" fetchFundingRateHistory() supports swap contracts only");const[r,a]=this.prepareRequest(n,void 0,i);s!==void 0&&(r.limit=s);const d=await this["publicFuturesGetSettleFundingRate"](this.extend(r,a)),c=[];for(let h=0;h<d.length;h++){const l=d[h],p=this.safeTimestamp(l,"t");c.push({info:l,symbol:e,fundingRate:this.safeNumber(l,"r"),timestamp:p,datetime:this.iso8601(p)})}const u=this.sortBy(c,"timestamp");return this.filterBySymbolSinceLimit(u,n.symbol,t,s)}parseOHLCV(e,t=void 0){return Array.isArray(e)?[this.safeTimestamp(e,0),this.safeNumber(e,5),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,6)]:[this.safeTimestamp(e,"t"),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),[r,a]=this.prepareRequest(n,void 0,i),o=this.getSupportedMapping(n.type,{spot:"publicSpotGetTrades",margin:"publicSpotGetTrades",swap:"publicFuturesGetSettleTrades",future:"publicDeliveryGetSettleTrades"});s!==void 0&&(r.limit=s),t!==void 0&&n.contract&&(r.from=parseInt(t/1e3));const d=await this[o](this.extend(r,a));return this.parseTrades(d,n,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){if(await this.loadMarkets(),t===void 0)throw new or(this.id+" fetchOrderTrades requires a symbol argument");return await this.fetchMyTrades(t,s,i,{order_id:e})}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r,a={};const o=e!==void 0?this.market(e):void 0,d=this.safeInteger2(i,"until","till");i=this.omit(i,["until","till"]),[n,i]=this.handleMarketTypeAndParams("fetchMyTrades",o,i),n==="swap"||n==="future"?[a,i]=this.prepareRequest(o,n,i):(o!==void 0&&(a.currency_pair=o.id),[r,i]=this.getMarginMode(!1,i),a.account=r),s!==void 0&&(a.limit=s),t!==void 0&&(a.from=parseInt(t/1e3)),d!==void 0&&(a.to=parseInt(d/1e3));const u=this.getSupportedMapping(n,{spot:"privateSpotGetMyTrades",margin:"privateSpotGetMyTrades",swap:"privateFuturesGetSettleMyTrades",future:"privateDeliveryGetSettleMyTrades"}),h=await this[u](this.extend(a,i));return this.parseTrades(h,o,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"id");let i=this.safeTimestamp2(e,"time","create_time");i=this.safeInteger(e,"create_time_ms",i);const n=this.safeString2(e,"currency_pair","contract");t=this.safeMarket(n,t);let r=this.safeString2(e,"amount","size");const a=this.safeString(e,"price"),o=je.stringLt(r,"0")?"sell":"buy";r=je.stringAbs(r);const d=this.safeString2(e,"side","type",o),c=this.safeString(e,"order_id"),u=this.safeString(e,"fee"),h=this.safeString(e,"gt_fee"),l=this.safeString(e,"point_fee"),p=[];if(u!==void 0){const g=this.safeString(e,"fee_currency");let y=this.safeCurrencyCode(g);y===void 0&&(y=this.safeString(t,"settle")),p.push({cost:u,currency:y})}h!==void 0&&p.push({cost:h,currency:"GT"}),l!==void 0&&p.push({cost:l,currency:"GatePoint"});const m=this.safeString(e,"role");return this.safeTrade({info:e,id:s,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,order:c,type:void 0,side:d,takerOrMaker:m,price:a,amount:r,cost:void 0,fee:void 0,fees:p},t)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.limit=s),t!==void 0){const o=parseInt(t/1e3);n.from=o,n.to=this.sum(o,30*24*60*60)}const a=await this.privateWalletGetDeposits(this.extend(n,i));return this.parseTransactions(a,r)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.limit=s),t!==void 0){const o=parseInt(t/1e3);n.from=o,n.to=this.sum(o,30*24*60*60)}const a=await this.privateWalletGetWithdrawals(this.extend(n,i));return this.parseTransactions(a,r)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,address:s,amount:this.currencyToPrecision(e,t)};i!==void 0&&(a.memo=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeStringLower(o,d,d),d!==void 0&&(a.chain=d,n=this.omit(n,"network"));const c=await this.privateWithdrawalsPostWithdrawals(this.extend(a,n));return this.parseTransaction(c,r)}parseTransactionStatus(e){const t={PEND:"pending",REQUEST:"pending",DMOVE:"pending",CANCEL:"failed",DONE:"ok",BCODE:"ok"};return this.safeString(t,e,e)}parseTransactionType(e){const t={d:"deposit",w:"withdrawal"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id");let i,n=this.safeString(e,"amount");s[0]==="b"?(i=je.stringGt(n,"0")?"deposit":"withdrawal",n=je.stringAbs(n)):s!==void 0&&(i=this.parseTransactionType(s[0]));const r=this.safeString(e,"currency"),a=this.safeCurrencyCode(r),o=this.safeString(e,"txid"),d=this.safeString(e,"status"),c=this.parseTransactionStatus(d),u=this.safeString(e,"address"),h=this.safeNumber(e,"fee"),l=this.safeString(e,"memo"),p=this.safeTimestamp(e,"timestamp");return{info:e,id:s,txid:o,currency:a,amount:this.parseNumber(n),network:void 0,address:u,addressTo:void 0,addressFrom:void 0,tag:l,tagTo:void 0,tagFrom:void 0,status:c,type:i,timestamp:p,datetime:this.iso8601(p),updated:void 0,fee:h}}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=a.contract,d=this.safeValue(r,"trigger"),c=this.safeValue2(r,"triggerPrice","stopPrice"),u=this.safeValue(r,"stopLossPrice",c),h=this.safeValue(r,"takeProfitPrice"),l=u!==void 0,p=h!==void 0,m=l||p;if(l&&p)throw new ot(this.id+" createOrder() stopLossPrice and takeProfitPrice cannot both be defined");let g="Orders";const y=this.safeValue(r,"reduceOnly"),b=this.safeStringLower2(r,"time_in_force","tif"),w=this.isPostOnly(t==="market",b==="poc",r);let S=this.handleTimeInForce(r);r=this.omit(r,["stopPrice","triggerPrice","stopLossPrice","takeProfitPrice","reduceOnly","timeInForce","postOnly"]),w&&(S="poc");const k=t==="limit",T=t==="market";if(k&&n===void 0)throw new or(this.id+" createOrder () requires a price argument for "+t+" orders");if(o){const M=this.amountToPrecision(e,i),x=s==="sell"?je.stringNeg(M):M;if(i=parseInt(x),T){if(S==="poc"||S==="gtc")throw new ot(this.id+' createOrder () timeInForce for market orders must be "IOC"');S="ioc",n=0}}else if(!k)throw new is(this.id+" createOrder () does not support "+t+" orders for "+a.type+" markets");let I;if(!m&&d===void 0){if(o)I={contract:a.id,size:i,price:this.priceToPrecision(e,n),settle:a.settleId},y!==void 0&&(I.reduce_only=y),S!==void 0&&(I.tif=S);else{let x;[x,r]=this.getMarginMode(!1,r),I={currency_pair:a.id,type:t,account:x,side:s,amount:this.amountToPrecision(e,i),price:this.priceToPrecision(e,n)},S!==void 0&&(I.time_in_force=S)}let M=this.safeString2(r,"text","clientOrderId");if(M!==void 0){if(M.length>28)throw new Si(this.id+" createOrder () clientOrderId or text param must be up to 28 characters");r=this.omit(r,["text","clientOrderId"]),M[0]!=="t"&&(M="t-"+M),I.text=M}}else{if(o){if(I={initial:{contract:a.id,size:i,price:this.priceToPrecision(e,n)},settle:a.settleId},d===void 0){let M,x;l?(M=s==="buy"?1:2,x=this.priceToPrecision(e,u)):p&&(M=s==="buy"?2:1,x=this.priceToPrecision(e,h)),I.trigger={price_type:0,price:this.priceToPrecision(e,x),rule:M}}y!==void 0&&(I.initial.reduce_only=y),S!==void 0&&(I.initial.tif=S)}else{const M=this.safeValue(this.options,"createOrder",{});let x;if([x,r]=this.getMarginMode(!0,r),I={put:{type:t,side:s,price:this.priceToPrecision(e,n),amount:this.amountToPrecision(e,i),account:x,time_in_force:"gtc"},market:a.id},d===void 0){const v=this.safeInteger(M,"expiration"),O=this.safeInteger(r,"expiration",v);let A,V;l?(A=s==="buy"?">=":"<=",V=this.priceToPrecision(e,u)):p&&(A=s==="buy"?"<=":">=",V=this.priceToPrecision(e,h)),I.trigger={price:this.priceToPrecision(e,V),rule:A,expiration:O}}S!==void 0&&(I.put.time_in_force=S)}g="PriceOrders"}const _=this.getSupportedMapping(a.type,{spot:"privateSpotPost"+g,margin:"privateSpotPost"+g,swap:"privateFuturesPostSettle"+g,future:"privateDeliveryPostSettle"+g}),N=await this[_](this.deepExtend(I,r));return this.parseOrder(N,a)}parseOrderStatus(e){const t={_new:"open",filled:"closed",cancelled:"canceled",liquidated:"closed",ioc:"canceled",failed:"canceled",expired:"canceled",finished:"closed",succeeded:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeValue2(e,"put","initial"),i=this.safeValue(e,"trigger");let n=this.safeString(s,"contract"),r=this.safeString(s,"type"),a=this.safeStringUpper2(s,"time_in_force","tif"),o=this.safeString2(s,"amount","size"),d=this.safeString(s,"side"),c=this.safeString(s,"price");n=this.safeString(e,"contract",n),r=this.safeString(e,"type",r),a=this.safeStringUpper2(e,"time_in_force","tif",a),a==="POC"&&(a="PO");const u=a==="PO";o=this.safeString2(e,"amount","size",o),d=this.safeString(e,"side",d),c=this.safeString(e,"price",c);let h=this.safeString(e,"left"),l=je.stringSub(o,h),p=this.safeString(e,"filled_total"),m,g;s&&(h=o,l="0",p="0"),n?(r=je.stringEquals(c,"0")&&a==="IOC"?"market":"limit",d=je.stringGt(o,"0")?"buy":"sell",m=this.safeString(e,"finish_as","open"),g=this.safeNumber(e,"fill_price")):m=this.safeString(e,"status");let y=this.safeInteger(e,"create_time_ms");y===void 0&&(y=this.safeTimestamp2(e,"create_time","ctime"));let b=this.safeInteger(e,"update_time_ms");b===void 0&&(b=this.safeTimestamp2(e,"update_time","finish_time"));const w=this.safeString2(e,"currency_pair","market",n),S=[],k=this.safeString(e,"gt_fee");k&&S.push({currency:"GT",cost:k});const T=this.safeString(e,"fee");T&&S.push({currency:this.safeCurrencyCode(this.safeString(e,"fee_currency")),cost:T});const I=this.safeString(e,"rebated_fee");I&&S.push({currency:this.safeCurrencyCode(this.safeString(e,"rebated_fee_currency")),cost:je.stringNeg(I)});const N=S.length>1,M=this.parseOrderStatus(m);return this.safeOrder({id:this.safeString(e,"id"),clientOrderId:this.safeString(e,"text"),timestamp:y,datetime:this.iso8601(y),lastTradeTimestamp:b,status:M,symbol:this.safeSymbol(w),type:r,timeInForce:a,postOnly:u,reduceOnly:this.safeValue(e,"is_reduce_only"),side:d,price:this.parseNumber(c),stopPrice:this.safeNumber(i,"price"),average:g,amount:this.parseNumber(je.stringAbs(o)),cost:je.stringAbs(p),filled:this.parseNumber(je.stringAbs(l)),remaining:this.parseNumber(je.stringAbs(h)),fee:N?void 0:this.safeValue(S,0),fees:N?S:[],trades:void 0,info:e},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue2(s,"is_stop_order","stop",!1);s=this.omit(s,["is_stop_order","stop"]);let n=this.safeString2(s,"text","clientOrderId"),r=e;n!==void 0&&(s=this.omit(s,["text","clientOrderId"]),n[0]!=="t"&&(n="t-"+n),r=n);const a=t===void 0?void 0:this.market(t),[o,d]=this.handleMarketTypeAndParams("fetchOrder",a,s),c=o==="swap"||o==="future",[u,h]=c?this.prepareRequest(a,o,d):this.spotOrderPrepareRequest(a,i,d);u.order_id=r;const l=i?"PriceOrders":"Orders",p=this.getSupportedMapping(o,{spot:"privateSpotGet"+l+"OrderId",margin:"privateSpotGet"+l+"OrderId",swap:"privateFuturesGetSettle"+l+"OrderId",future:"privateDeliveryGetSettle"+l+"OrderId"}),m=await this[p](this.extend(u,h));return this.parseOrder(m,a)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("open",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("finished",e,t,s,i)}async fetchOrdersByStatus(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;t!==void 0&&(r=this.market(t),t=r.symbol);const a=this.safeValue(n,"stop");n=this.omit(n,"stop");const[o,d]=this.handleMarketTypeAndParams("fetchOrdersByStatus",r,n),c=o==="spot"||o==="margin",[u,h]=c?this.multiOrderSpotPrepareRequest(r,a,d):this.prepareRequest(r,o,d);e==="closed"&&(e="finished"),u.status=e,i!==void 0&&(u.limit=i),s!==void 0&&c&&(u.from=parseInt(s/1e3));let l=a?"PriceOrders":"Orders";const p=c&&e==="open"&&!a;p&&(l="OpenOrders");const m=this.getSupportedMapping(o,{spot:"privateSpotGet"+l,margin:"privateSpotGet"+l,swap:"privateFuturesGetSettle"+l,future:"privateDeliveryGetSettle"+l}),g=await this[m](this.extend(u,h));let y=g;if(p){y=[];for(let w=0;w<g.length;w++){const S=this.safeValue(g[w],"orders");y=this.arrayConcat(y,S)}}const b=this.parseOrders(y,r,s,i);return this.filterBySymbolSinceLimit(b,t,s,i)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=t===void 0?void 0:this.market(t),n=this.safeValue2(s,"is_stop_order","stop",!1);s=this.omit(s,["is_stop_order","stop"]);const[r,a]=this.handleMarketTypeAndParams("cancelOrder",i,s),[o,d]=r==="spot"||r==="margin"?this.spotOrderPrepareRequest(i,n,a):this.prepareRequest(i,r,a);o.order_id=e;const c=n?"Price":"",u=this.getSupportedMapping(r,{spot:"privateSpotDelete"+c+"OrdersOrderId",margin:"privateSpotDelete"+c+"OrdersOrderId",swap:"privateFuturesDeleteSettle"+c+"OrdersOrderId",future:"privateDeliveryDeleteSettle"+c+"OrdersOrderId"}),h=await this[u](this.extend(o,d));return this.parseOrder(h,i)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s=e===void 0?void 0:this.market(e),i=this.safeValue(t,"stop");t=this.omit(t,"stop");const[n,r]=this.handleMarketTypeAndParams("cancelAllOrders",s,t),[a,o]=n==="spot"?this.multiOrderSpotPrepareRequest(s,i,r):this.prepareRequest(s,n,r),d=i?"PriceOrders":"Orders",c=this.getSupportedMapping(n,{spot:"privateSpotDelete"+d,margin:"privateSpotDelete"+d,swap:"privateFuturesDeleteSettle"+d,future:"privateDeliveryDeleteSettle"+d}),u=await this[c](this.extend(a,o));return this.parseOrders(u,s)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.convertTypeToAccount(s),o=this.convertTypeToAccount(i),d=this.currencyToPrecision(e,t),c={currency:r.id,amount:d};if(a in this.options.accountsByType?c.from=a:(c.from="margin",c.currency_pair=a),o in this.options.accountsByType?c.to=o:(c.to="margin",c.currency_pair=o),a==="margin"||o==="margin"){const l=this.safeString2(n,"symbol","currency_pair");if(l===void 0)throw new or(this.id+' transfer requires params["symbol"] for isolated margin transfers');const p=this.market(l);c.currency_pair=p.id,n=this.omit(n,"symbol")}(o==="futures"||o==="delivery"||a==="futures"||a==="delivery")&&(c.settle=r.lowerCaseId);const u=await this.privateWalletPostTransfers(this.extend(c,n)),h=this.parseTransfer(u,r);return this.extend(h,{fromAccount:s,toAccount:i,amount:this.parseNumber(d)})}parseTransfer(e,t=void 0){const s=this.milliseconds();return{id:void 0,timestamp:s,datetime:this.iso8601(s),currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0,info:e}}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new or(this.id+" setLeverage() requires a symbol argument");if(e<0||e>100)throw new Si(this.id+" setLeverage() leverage should be between 1 and 100");await this.loadMarkets();const i=this.market(t),n=this.getSupportedMapping(i.type,{swap:"privateFuturesPostSettlePositionsContractLeverage",future:"privateDeliveryPostSettlePositionsContractLeverage"}),[r,a]=this.prepareRequest(i,void 0,s),o=this.safeString2(this.options,"marginMode","defaultMarginMode"),d=this.safeString(a,"cross_leverage_limit");let c=this.safeString(a,"marginMode",o);return d!==void 0&&(c="cross",e=d),c==="cross"||c==="cross_margin"?(r.cross_leverage_limit=e.toString(),r.leverage="0"):r.leverage=e.toString(),await this[n](this.extend(r,a))}parsePosition(e,t=void 0){const s=this.safeString(e,"contract");t=this.safeMarket(s,t);const i=this.safeString(e,"size");let n;je.stringGt(i,"0")?n="long":je.stringLt(i,"0")&&(n="short");const r=this.safeString(e,"maintenance_rate"),a=this.safeString(e,"value"),o=this.safeString(e,"leverage");let d;o==="0"?d="cross":d="isolated";const c=this.safeString(e,"unrealised_pnl"),u="0.00075",h=je.stringMul(u,a),l=je.stringAdd(je.stringDiv(a,o),h),p=je.stringMul(je.stringDiv(c,l),"100");return{info:e,id:void 0,symbol:this.safeString(t,"symbol"),timestamp:void 0,datetime:void 0,initialMargin:this.parseNumber(l),initialMarginPercentage:this.parseNumber(je.stringDiv(l,a)),maintenanceMargin:this.parseNumber(je.stringMul(r,a)),maintenanceMarginPercentage:this.parseNumber(r),entryPrice:this.safeNumber(e,"entry_price"),notional:this.parseNumber(a),leverage:this.safeNumber(e,"leverage"),unrealizedPnl:this.parseNumber(c),contracts:this.parseNumber(je.stringAbs(i)),contractSize:this.safeValue(t,"contractSize"),marginRatio:void 0,liquidationPrice:this.safeNumber(e,"liq_price"),markPrice:this.safeNumber(e,"mark_price"),collateral:this.safeNumber(e,"margin"),marginMode:d,side:n,percentage:this.parseNumber(p)}}async fetchPositions(e=void 0,t={}){await this.loadMarkets();let s;if(e!==void 0&&(e=this.marketSymbols(e),e.length>0)){s=this.market(e[0]);for(let u=1;u<e.length;u++)if(this.market(e[u]).type!==s.type)throw new Si(this.id+" fetchPositions() does not support multiple types of positions at the same time")}const[i,n]=this.handleMarketTypeAndParams("fetchPositions",s,t);if(i!=="swap"&&i!=="future")throw new or(this.id+' fetchPositions requires a type parameter, "swap" or "future"');const[r,a]=this.prepareRequest(void 0,i,n),o=this.getSupportedMapping(i,{swap:"privateFuturesGetSettlePositions",future:"privateDeliveryGetSettlePositions"}),d=await this[o](this.extend(r,a));return this.parsePositions(d,e)}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const[s,i]=this.handleMarketTypeAndParams("fetchLeverageTiers",void 0,t),[n,r]=this.prepareRequest(void 0,s,i);if(s!=="future"&&s!=="swap")throw new Si(this.id+" fetchLeverageTiers only supports swap and future");const a=this.getSupportedMapping(s,{swap:"publicFuturesGetSettleContracts",future:"publicDeliveryGetSettleContracts"}),o=await this[a](this.extend(n,r));return this.parseLeverageTiers(o,e,"name")}parseMarketLeverageTiers(e,t=void 0){const s=this.safeString(e,"maintenance_rate"),i=this.safeString(e,"leverage_max"),n=this.safeString(e,"risk_limit_step"),r=this.safeString(e,"risk_limit_max"),a=je.stringDiv("1",i);let o=s,d=a,c="0";const u=[];for(;je.stringLt(c,r);){const h=je.stringAdd(c,n);u.push({tier:this.parseNumber(je.stringDiv(h,n)),currency:this.safeString(t,"settle"),minNotional:this.parseNumber(c),maxNotional:this.parseNumber(h),maintenanceMarginRate:this.parseNumber(o),maxLeverage:this.parseNumber(je.stringDiv("1",d)),info:e}),o=je.stringAdd(o,s),d=je.stringAdd(d,a),c=h}return u}async repayMargin(e,t,s=void 0,i={}){const n=this.safeString(i,"marginMode");i=this.omit(i,"marginMode"),this.checkRequiredMarginArgument("repayMargin",s,n),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,amount:this.currencyToPrecision(e,t)};let o;if(s===void 0)o="privateMarginPostCrossRepayments";else{o="privateMarginPostLoansLoanIdRepayment";const c=this.market(s);a.currency_pair=c.id,a.mode="partial";const u=this.safeString2(i,"loan_id","id");if(u===void 0)throw new or(this.id+" repayMargin() requires loan_id param for isolated margin");a.loan_id=u}i=this.omit(i,["marginMode","loan_id","id"]);let d=await this[o](this.extend(a,i));return n==="cross"&&(d=d[0]),this.parseMarginLoan(d,r)}async borrowMargin(e,t,s=void 0,i={}){const n=this.safeString(i,"marginMode");i=this.omit(i,"marginMode"),this.checkRequiredMarginArgument("borrowMargin",s,n),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,amount:this.currencyToPrecision(e,t)};let o;if(s===void 0)o="privateMarginPostCrossLoans";else{const c=this.market(s);a.currency_pair=c.id,a.side="borrow",a.rate=this.safeString(i,"rate","0.0001"),a.auto_renew=!0,o="privateMarginPostLoans"}i=this.omit(i,["marginMode","rate"]);const d=await this[o](this.extend(a,i));return this.parseMarginLoan(d,r)}parseMarginLoan(e,t=void 0){const s=this.safeString2(this.options,"defaultMarginMode","marginMode","cross");let i=this.safeInteger(e,"create_time");s==="isolated"&&(i=this.safeTimestamp(e,"create_time"));const n=this.safeString(e,"currency"),r=this.safeString(e,"currency_pair");return{id:this.safeInteger(e,"id"),currency:this.safeCurrencyCode(n,t),amount:this.safeNumber(e,"amount"),symbol:this.safeSymbol(r,void 0),timestamp:i,datetime:this.iso8601(i),info:e}}sign(e,t=[],s="GET",i={},n=void 0,r=void 0){const a=t[0],o=t[1];let d=this.omit(i,this.extractParams(e));e=this.implodeParams(e,i);const c=e===""?"":"/"+e;let u="/"+o+c;(o==="subAccounts"||o==="withdrawals")&&(u=c);let h=this.urls.api[a][o];if(h===void 0)throw new NF(this.id+" does not have a testnet for the "+o+" market type.");if(h+=u,a==="public")Object.keys(d).length&&(h+="?"+this.urlencode(d));else{this.checkRequiredCredentials();let l="",p=!1;if(o==="futures"&&s==="POST"){const I=e.split("/"),_=this.safeString(I,1,"");p=_.indexOf("dual")>=0||_.indexOf("positions")>=0}if(s==="GET"||s==="DELETE"||p)Object.keys(d).length&&(l=this.urlencode(d),h+="?"+l);else{const I=this.safeValue(d,"query",{});Object.keys(I).length&&(l=this.urlencode(I),h+="?"+l),d=this.omit(d,"query"),r=this.json(d)}const m=r===void 0?"":r,g=this.hash(this.encode(m),"sha512"),b=this.seconds().toString(),w="/api/"+this.version+u,k=[s.toUpperCase(),w,l,g,b].join(`
`),T=this.hmac(this.encode(k),this.encode(this.secret),"sha512");n={KEY:this.apiKey,Timestamp:b,SIGN:T,"Content-Type":"application/json"}}return{url:h,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"label");if(c!==void 0){const u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),new ot(u)}}};const VF=Tb;var qF=class extends VF{describe(){return this.deepExtend(super.describe(),{id:"gateio",alias:!0})}};const LF=me,{ExchangeError:Tc,ArgumentsRequired:v0,BadRequest:Ai,OrderNotFound:zk,InvalidOrder:qo,InvalidNonce:RF,InsufficientFunds:Kk,AuthenticationError:qa,PermissionDenied:FF,NotSupported:Rf,OnMaintenance:T0,RateLimitExceeded:Xk,ExchangeNotAvailable:Yk}=oe,{TICK_SIZE:DF}=pe,Qk=ke;var HF=class extends LF{describe(){return this.deepExtend(super.describe(),{id:"gemini",name:"Gemini",countries:["US"],rateLimit:100,version:"v1",pro:!1,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createDepositAddress:!0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:void 0,fetchDepositAddress:void 0,fetchDepositAddressesByNetwork:!0,fetchDeposits:void 0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:void 0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:!0,fetchWithdrawals:void 0,postOnly:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27816857-ce7be644-6096-11e7-82d6-3c257263229c.jpg",api:{public:"https://api.gemini.com",private:"https://api.gemini.com",web:"https://docs.gemini.com"},www:"https://gemini.com/",doc:["https://docs.gemini.com/rest-api","https://docs.sandbox.gemini.com"],test:{public:"https://api.sandbox.gemini.com",private:"https://api.sandbox.gemini.com",web:"https://docs.gemini.com"},fees:["https://gemini.com/api-fee-schedule","https://gemini.com/trading-fees","https://gemini.com/transfer-fees"]},api:{web:{get:["rest-api"]},public:{get:{"v1/symbols":5,"v1/symbols/details/{symbol}":5,"v1/pubticker/{symbol}":5,"v2/ticker/{symbol}":5,"v2/candles/{symbol}/{timeframe}":5,"v1/trades/{symbol}":5,"v1/auction/{symbol}":5,"v1/auction/{symbol}/history":5,"v1/pricefeed":5,"v1/book/{symbol}":5,"v1/earn/rates":5}},private:{post:{"v1/order/new":1,"v1/order/cancel":1,"v1/wrap/{symbol}":1,"v1/order/cancel/session":1,"v1/order/cancel/all":1,"v1/order/status":1,"v1/orders":1,"v1/mytrades":1,"v1/notionalvolume":1,"v1/tradevolume":1,"v1/clearing/new":1,"v1/clearing/status":1,"v1/clearing/cancel":1,"v1/clearing/confirm":1,"v1/balances":1,"v1/notionalbalances/{currency}":1,"v1/transfers":1,"v1/addresses/{network}":1,"v1/deposit/{network}/newAddress":1,"v1/deposit/{currency}/newAddress":1,"v1/withdraw/{currency}":1,"v1/account/transfer/{currency}":1,"v1/payments/addbank":1,"v1/payments/methods":1,"v1/payments/sen/withdraw":1,"v1/balances/earn":1,"v1/earn/interest":1,"v1/approvedAddresses/{network}/request":1,"v1/approvedAddresses/account/{network}":1,"v1/approvedAddresses/{network}/remove":1,"v1/account":1,"v1/account/create":1,"v1/account/list":1,"v1/heartbeat":1}}},precisionMode:DF,fees:{trading:{taker:.004,maker:.002}},httpExceptions:{400:Ai,403:FF,404:zk,406:Kk,429:Xk,500:Tc,502:Yk,503:T0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1hr","6h":"6hr","1d":"1day"},exceptions:{exact:{AuctionNotOpen:Ai,ClientOrderIdTooLong:Ai,ClientOrderIdMustBeString:Ai,ConflictingOptions:Ai,EndpointMismatch:Ai,EndpointNotFound:Ai,IneligibleTiming:Ai,InsufficientFunds:Kk,InvalidJson:Ai,InvalidNonce:RF,InvalidOrderType:qo,InvalidPrice:qo,InvalidQuantity:qo,InvalidSide:qo,InvalidSignature:qa,InvalidSymbol:Ai,InvalidTimestampInPayload:Ai,Maintenance:T0,MarketNotOpen:qo,MissingApikeyHeader:qa,MissingOrderField:qo,MissingRole:qa,MissingPayloadHeader:qa,MissingSignatureHeader:qa,NoSSL:qa,OptionsMustBeArray:Ai,OrderNotFound:zk,RateLimit:Xk,System:Tc,UnsupportedOption:Ai},broad:{"The Gemini Exchange is currently undergoing maintenance.":T0,"We are investigating technical issues with the Gemini Exchange.":Yk}},options:{fetchMarketsMethod:"fetch_markets_from_web",fetchTickerMethod:"fetchTickerV1",networkIds:{bitcoin:"BTC",ethereum:"ERC20",bitcoincash:"BCH",litecoin:"LTC",zcash:"ZEC",filecoin:"FIL",dogecoin:"DOGE",tezos:"XTZ"},networks:{BTC:"bitcoin",ERC20:"ethereum",BCH:"bitcoincash",LTC:"litecoin",ZEC:"zcash",FIL:"filecoin",DOGE:"dogecoin",XTZ:"tezos"}}})}async fetchMarkets(e={}){const t=this.safeValue(this.options,"fetchMarketsMethod","fetch_markets_from_api");return await this[t](e)}async fetchMarketsFromWeb(e={}){const s=(await this.webGetRestApi(e)).split('<h1 id="symbols-and-minimums">Symbols and minimums</h1>'),i=s.length,n=this.id+" fetchMarketsFromWeb() the "+this.name+" API doc HTML markup has changed, breaking the parser of order limits and precision info for "+this.name+" markets.";if(i!==2)throw new Rf(n);const r=s[1].split("tbody>");if(r.length<2)throw new Rf(n);const o=r[1].split(`
<tr>
`),d=o.length;if(d<2)throw new Rf(n);const c=[];for(let u=1;u<d;u++){const h=o[u],l=h.split(`</td>
`);if(l.length<5)throw new Rf(n);const m=l[0].replace("<td>",""),y=l[1].replace("<td>","").split(" "),b=this.safeNumber(y,0),S=l[2].replace("<td>","").split(" "),k=m.length-0,T=k-3,_=l[3].replace("<td>","").split(" "),N=this.safeStringLower(_,1,m.slice(T,k)),M=this.safeStringLower(S,1,m.replace(N,"")),x=this.safeCurrencyCode(M),v=this.safeCurrencyCode(N);c.push({id:m,symbol:x+"/"+v,base:x,quote:v,settle:void 0,baseId:M,quoteId:N,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(S,0),price:this.safeNumber(_,0)},limits:{leverage:{min:void 0,max:void 0},amount:{min:b,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:h})}return c}async fetchMarketsFromAPI(e={}){const t=await this.publicGetV1Symbols(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=n,a=n.length-0,o=n.slice(0,a-3),d=n.slice(a-3,a),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d);s.push({id:n,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{price:void 0,amount:void 0},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit_bids=t,n.limit_asks=t);const r=await this.publicGetV1BookSymbol(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"bids","asks","price","amount")}async fetchTickerV1(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetV1PubtickerSymbol(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickerV2(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetV2TickerSymbol(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickerV1AndV2(e,t={}){const s=await this.fetchTickerV1(e,t),i=await this.fetchTickerV2(e,t);return this.deepExtend(s,{open:i.open,high:i.high,low:i.low,change:i.change,percentage:i.percentage,average:i.average,info:i.info})}async fetchTicker(e,t={}){const s=this.safeValue(this.options,"fetchTickerMethod","fetchTickerV1");return await this[s](e,t)}parseTicker(e,t=void 0){const s=this.safeValue(e,"volume",{}),i=this.safeInteger(s,"timestamp");let n;const r=this.safeStringLower(e,"pair");t=this.safeMarket(r,t);let a,o,d,c;r!==void 0&&t===void 0&&(r.length-0===7?(a=r.slice(0,4),o=r.slice(4,7)):(a=r.slice(0,3),o=r.slice(3,6)),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o),n=d+"/"+c),n===void 0&&t!==void 0&&(n=t.symbol,a=this.safeStringUpper(t,"baseId"),o=this.safeStringUpper(t,"quoteId"));const u=this.safeString(e,"price"),h=this.safeString2(e,"last","close",u),l=this.safeString(e,"percentChange24h"),p=this.safeString(e,"open"),m=this.safeString(s,a),g=this.safeString(s,o);return this.safeTicker({symbol:n,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:p,close:h,last:h,previousClose:void 0,change:void 0,percentage:l,average:void 0,baseVolume:m,quoteVolume:g,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetV1Pricefeed(t);return this.parseTickers(s,e)}parseTrade(e,t=void 0){const s=this.safeInteger(e,"timestampms"),i=this.safeString(e,"tid"),n=this.safeString(e,"order_id"),r=this.safeString(e,"fee_currency"),a=this.safeCurrencyCode(r),o={cost:this.safeString(e,"fee_amount"),currency:a},d=this.safeString(e,"price"),c=this.safeString(e,"amount"),u=this.safeStringLower(e,"type"),h=this.safeSymbol(void 0,t);return this.safeTrade({id:i,order:n,info:e,timestamp:s,datetime:this.iso8601(s),symbol:h,type:void 0,side:u,takerOrMaker:void 0,price:d,cost:void 0,amount:c,fee:o},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit_trades=s),t!==void 0&&(r.timestamp=t);const a=await this.publicGetV1TradesSymbol(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"available"),a.total=this.safeString(i,"amount"),t[r]=a}return this.safeBalance(t)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostV1Notionalvolume(e),s=this.safeString(t,"api_maker_fee_bps"),i=this.safeString(t,"api_taker_fee_bps"),n=Qk.stringDiv(s,"10000"),r=Qk.stringDiv(i,"10000"),a=this.parseNumber(n),o=this.parseNumber(r),d={};for(let c=0;c<this.symbols.length;c++){const u=this.symbols[c];d[u]={info:t,symbol:u,maker:a,taker:o,percentage:!0,tierBased:!0}}return d}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostV1Balances(e);return this.parseBalance(t)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"timestampms"),i=this.safeString(e,"original_amount"),n=this.safeString(e,"remaining_amount"),r=this.safeString(e,"executed_amount");let a="closed";e.is_live&&(a="open"),e.is_cancelled&&(a="canceled");const o=this.safeString(e,"price"),d=this.safeString(e,"avg_execution_price");let c=this.safeString(e,"type");c==="exchange limit"?c="limit":c==="market buy"||c==="market sell"?c="market":c=e.type;const u=void 0,h=this.safeString(e,"symbol"),l=this.safeSymbol(h,t),p=this.safeString(e,"order_id"),m=this.safeStringLower(e,"side"),g=this.safeString(e,"client_order_id"),y=this.safeValue(e,"options",[]),b=this.safeString(y,0);let w="GTC",S=!1;return b!==void 0&&(b==="immediate-or-cancel"?w="IOC":b==="fill-or-kill"?w="FOK":b==="maker-or-cancel"&&(w="PO",S=!0)),this.safeOrder({id:p,clientOrderId:g,info:e,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,status:a,symbol:l,type:c,timeInForce:w,postOnly:S,side:m,price:o,stopPrice:void 0,average:d,cost:void 0,amount:i,filled:r,remaining:n,fee:u,trades:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privatePostV1OrderStatus(this.extend(i,s));return this.parseOrder(n)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=await this.privatePostV1Orders(i);let r;return e!==void 0&&(r=this.market(e)),this.parseOrders(n,r,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){if(await this.loadMarkets(),t!=="limit")throw new Tc(this.id+" createOrder() allows limit orders only");let a=this.safeString2(r,"clientOrderId","client_order_id");r=this.omit(r,["clientOrderId","client_order_id"]),a===void 0&&(a=this.milliseconds().toString());const o=this.market(e),d=this.amountToPrecision(e,i),c=this.priceToPrecision(e,n),u={client_order_id:a.toString(),symbol:o.id,amount:d,price:c,side:s,type:"exchange limit"};t=this.safeString(r,"type",t),r=this.omit(r,"type");const h=this.safeString2(r,"stop_price","stopPrice");if(r=this.omit(r,["stop_price","stopPrice","type"]),t==="stopLimit")throw new v0(this.id+" createOrder() requires a stopPrice parameter or a stop_price parameter for "+t+" orders");if(h!==void 0)u.stop_price=this.priceToPrecision(e,h),u.type="exchange stop limit";else{const p=this.safeString(r,"timeInForce");r=this.omit(r,"timeInForce"),p!==void 0&&(p==="IOC"||p==="immediate-or-cancel"?u.options=["immediate-or-cancel"]:p==="FOK"||p==="fill-or-kill"?u.options=["fill-or-kill"]:p==="PO"&&(u.options=["maker-or-cancel"]));const m=this.safeValue(r,"postOnly",!1);r=this.omit(r,"postOnly"),m&&(u.options=["maker-or-cancel"]);const g=this.safeString(r,"options");g!==void 0&&(u.options=[g])}const l=await this.privatePostV1OrderNew(this.extend(u,r));return this.parseOrder(l)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privatePostV1OrderCancel(this.extend(i,s));return this.parseOrder(n)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new v0(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit_trades=s),t!==void 0&&(r.timestamp=parseInt(t/1e3));const a=await this.privatePostV1Mytrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,amount:t,address:s},o=await this.privatePostV1WithdrawCurrency(this.extend(a,n));if(this.safeString(o,"result")==="error")throw new Tc(this.id+" withdraw() failed: "+this.json(o));return this.parseTransaction(o,r)}nonce(){return this.milliseconds()}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};s!==void 0&&(n.limit_transfers=s),t!==void 0&&(n.timestamp=t);const r=await this.privatePostV1Transfers(this.extend(n,i));return this.parseTransactions(r)}parseTransaction(e,t=void 0){const s=this.safeInteger(e,"timestampms"),i=this.safeString(e,"currency"),n=this.safeCurrencyCode(i,t),r=this.safeString(e,"destination"),a=this.safeStringLower(e,"type"),o=this.safeString(e,"status");let d;const c=this.safeNumber(e,"feeAmount");return c!==void 0&&(d={cost:c,currency:n}),{info:e,id:this.safeString2(e,"eid","withdrawalId"),txid:this.safeString(e,"txHash"),timestamp:s,datetime:this.iso8601(s),network:void 0,address:r,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:a,amount:this.safeNumber(e,"amount"),currency:n,status:this.parseTransactionStatus(o),updated:void 0,fee:d}}parseTransactionStatus(e){const t={Advanced:"ok",Complete:"ok"};return this.safeString(t,e,e)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address");return{currency:this.safeCurrencyCode(void 0,t),network:void 0,address:s,tag:void 0,info:e}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const s=this.safeString(t,"network");if(s===void 0)throw new v0(this.id+" fetchDepositAddressesByNetwork() requires a network parameter");t=this.omit(t,"network");const i=this.safeValue(this.options,"networks",{}),n=this.safeString(i,s,s),r=this.safeValue(this.options,"networkIds",{}),a=this.safeString(r,n,s),o={network:n},d=await this.privatePostV1AddressesNetwork(this.extend(o,t)),c=this.parseDepositAddresses(d,[e],!1,{network:a,currency:e});return this.groupBy(c,"network")}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="private"){if(this.checkRequiredCredentials(),this.apiKey.indexOf("account")<0)throw new qa(this.id+" sign() requires an account-key, master-keys are not-supported");const c=this.nonce(),u=this.extend({request:a,nonce:c},o);let h=this.json(u);h=this.stringToBase64(h);const l=this.hmac(h,this.encode(this.secret),"sha384");n={"Content-Type":"text/plain","X-GEMINI-APIKEY":this.apiKey,"X-GEMINI-PAYLOAD":this.decode(h),"X-GEMINI-SIGNATURE":l}}else Object.keys(o).length&&(a+="?"+this.urlencode(o));return a=this.urls.api[t]+a,(s==="POST"||s==="DELETE")&&(r=this.json(o)),{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0){if(typeof r=="string"){const u=this.id+" "+r;this.throwBroadlyMatchedException(this.exceptions.broad,r,u)}return}if(this.safeString(a,"result")==="error"){const u=this.safeString(a,"reason"),h=this.safeString(a,"message"),l=this.id+" "+h;throw this.throwExactlyMatchedException(this.exceptions.exact,u,l),this.throwExactlyMatchedException(this.exceptions.exact,h,l),this.throwBroadlyMatchedException(this.exceptions.broad,h,l),new Tc(l)}}async createDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.privatePostV1DepositCurrencyNewAddress(this.extend(i,t)),r=this.safeString(n,"address");return this.checkAddress(r),{currency:e,address:r,tag:void 0,info:n}}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={timeframe:this.timeframes[t],symbol:r.id},o=await this.publicGetV2CandlesSymbolTimeframe(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}};const GF=me,{TICK_SIZE:UF}=pe,$F=ke,{BadSymbol:O0,BadRequest:ki,OnMaintenance:jF,AccountSuspended:I0,PermissionDenied:x0,ExchangeError:Tt,RateLimitExceeded:WF,ExchangeNotAvailable:Zk,OrderNotFound:zF,InsufficientFunds:KF,InvalidOrder:Ff,AuthenticationError:_0,ArgumentsRequired:Df,NotSupported:XF}=oe;var YF=class extends GF{describe(){return this.deepExtend(super.describe(),{id:"hitbtc3",name:"HitBTC",countries:["HK"],rateLimit:3.333,version:"3",pro:!0,has:{CORS:!1,spot:!0,margin:!0,swap:!0,future:!1,option:void 0,addMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!0,fetchBalance:!0,fetchBorrowRate:void 0,fetchBorrowRateHistories:void 0,fetchBorrowRateHistory:void 0,fetchBorrowRates:void 0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:void 0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchIndexOHLCV:!0,fetchLeverage:!0,fetchLeverageTiers:void 0,fetchMarketLeverageTiers:void 0,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrder:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!0,fetchOrders:!1,fetchOrderTrades:!0,fetchPosition:!0,fetchPositions:!0,fetchPremiumIndexOHLCV:!0,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransactions:!0,fetchWithdrawals:!0,reduceMargin:!0,setLeverage:!0,setMarginMode:!1,setPositionMode:!1,transfer:!0,withdraw:!0},precisionMode:UF,urls:{logo:"https://user-images.githubusercontent.com/1294454/27766555-8eaec20e-5edc-11e7-9c5b-6dc69fc42f5e.jpg",test:{public:"https://api.demo.hitbtc.com",private:"https://api.demo.hitbtc.com"},api:{public:"https://api.hitbtc.com/api/3",private:"https://api.hitbtc.com/api/3"},www:"https://hitbtc.com",referral:"https://hitbtc.com/?ref_id=5a5d39a65d466",doc:["https://api.hitbtc.com","https://github.com/hitbtc-com/hitbtc-api/blob/master/APIv2.md"],fees:["https://hitbtc.com/fees-and-limits","https://support.hitbtc.com/hc/en-us/articles/115005148605-Fees-and-limits"]},api:{public:{get:{"public/currency":10,"public/symbol":10,"public/ticker":10,"public/price/rate":10,"public/trades":10,"public/orderbook":10,"public/candles":10,"public/futures/info":10,"public/futures/history/funding":10,"public/futures/candles/index_price":10,"public/futures/candles/mark_price":10,"public/futures/candles/premium_index":10,"public/futures/candles/open_interest":10}},private:{get:{"spot/balance":15,"spot/order":15,"spot/order/{client_order_id}":15,"spot/fee":15,"spot/fee/{symbol}":15,"spot/history/order":15,"spot/history/trade":15,"margin/account":15,"margin/account/isolated/{symbol}":15,"margin/order":15,"margin/order/{client_order_id}":15,"margin/history/clearing":15,"margin/history/order":15,"margin/history/positions":15,"margin/history/trade":15,"futures/balance":15,"futures/account":15,"futures/account/isolated/{symbol}":15,"futures/order":15,"futures/order/{client_order_id}":15,"futures/fee":15,"futures/fee/{symbol}":15,"futures/history/clearing":15,"futures/history/order":15,"futures/history/positions":15,"futures/history/trade":15,"wallet/balance":15,"wallet/crypto/address":15,"wallet/crypto/address/recent-deposit":15,"wallet/crypto/address/recent-withdraw":15,"wallet/crypto/address/check-mine":15,"wallet/transactions":15,"wallet/crypto/check-offchain-available":15,"wallet/crypto/fee/estimate":15,"sub-account":15,"sub-account/acl":15,"sub-account/balance/{subAccID}":15,"sub-account/crypto/address/{subAccID}/{currency}":15},post:{"spot/order":1,"margin/order":1,"futures/order":1,"wallet/convert":15,"wallet/crypto/address":15,"wallet/crypto/withdraw":15,"wallet/transfer":15,"sub-account/freeze":15,"sub-account/activate":15,"sub-account/transfer":15,"sub-account/acl":15},patch:{"spot/order/{client_order_id}":1,"margin/order/{client_order_id}":1,"futures/order/{client_order_id}":1},delete:{"spot/order":1,"spot/order/{client_order_id}":1,"margin/position":1,"margin/position/isolated/{symbol}":1,"margin/order":1,"margin/order/{client_order_id}":1,"futures/position":1,"futures/position/isolated/{symbol}":1,"futures/order":1,"futures/order/{client_order_id}":1,"wallet/crypto/withdraw/{id}":1},put:{"margin/account/isolated/{symbol}":1,"futures/account/isolated/{symbol}":1,"wallet/crypto/withdraw/{id}":1}}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0009"),maker:this.parseNumber("0.0009"),tiers:{maker:[[this.parseNumber("0"),this.parseNumber("0.0009")],[this.parseNumber("10"),this.parseNumber("0.0007")],[this.parseNumber("100"),this.parseNumber("0.0006")],[this.parseNumber("500"),this.parseNumber("0.0005")],[this.parseNumber("1000"),this.parseNumber("0.0003")],[this.parseNumber("5000"),this.parseNumber("0.0002")],[this.parseNumber("10000"),this.parseNumber("0.0001")],[this.parseNumber("20000"),this.parseNumber("0")],[this.parseNumber("50000"),this.parseNumber("-0.0001")],[this.parseNumber("100000"),this.parseNumber("-0.0001")]],taker:[[this.parseNumber("0"),this.parseNumber("0.0009")],[this.parseNumber("10"),this.parseNumber("0.0008")],[this.parseNumber("100"),this.parseNumber("0.0007")],[this.parseNumber("500"),this.parseNumber("0.0007")],[this.parseNumber("1000"),this.parseNumber("0.0006")],[this.parseNumber("5000"),this.parseNumber("0.0006")],[this.parseNumber("10000"),this.parseNumber("0.0005")],[this.parseNumber("20000"),this.parseNumber("0.0004")],[this.parseNumber("50000"),this.parseNumber("0.0003")],[this.parseNumber("100000"),this.parseNumber("0.0002")]]}}},timeframes:{"1m":"M1","3m":"M3","5m":"M5","15m":"M15","30m":"M30","1h":"H1","4h":"H4","1d":"D1","1w":"D7","1M":"1M"},exceptions:{exact:{429:WF,500:Tt,503:Zk,504:Zk,600:x0,800:Tt,1002:_0,1003:x0,1004:_0,1005:_0,2001:O0,2002:ki,2003:ki,2010:ki,2011:ki,2012:ki,2020:ki,2022:ki,10001:ki,10021:I0,10022:ki,20001:KF,20002:zF,20003:Tt,20004:Tt,20005:Tt,20006:Tt,20007:Tt,20008:Ff,20009:Ff,20010:jF,20011:Tt,20012:Tt,20014:Tt,20016:Tt,20031:Tt,20032:Tt,20033:Tt,20034:Tt,20040:Tt,20041:Tt,20042:Tt,20043:Tt,20044:x0,20045:Ff,20080:Tt,21001:Tt,21003:I0,21004:I0},broad:{}},options:{networks:{ETH:"USDT20",ERC20:"USDT20",TRX:"USDTRX",TRC20:"USDTRX",OMNI:"USDT"},accountsByType:{spot:"spot",funding:"wallet",future:"derivatives"}},commonCurrencies:{AUTO:"Cube",BCC:"BCC",BDP:"BidiPass",BET:"DAO.Casino",BIT:"BitRewards",BOX:"BOX Token",CPT:"Cryptaur",GET:"Themis",GMT:"GMT Token",HSR:"HC",IQ:"IQ.Cash",LNC:"LinkerCoin",PLA:"PlayChip",PNT:"Penta",SBTC:"Super Bitcoin",STEPN:"GMT",STX:"STOX",TV:"Tokenville",USD:"USDT",XMT:"MTL",XPNT:"PNT"}})}nonce(){return this.milliseconds()}async fetchMarkets(e={}){const t=await this.publicGetPublicSymbol(e),s=[],i=Object.keys(t);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeValue(t,r),o=this.safeString(a,"type"),d=this.safeInteger(a,"expiry"),c=o==="futures",u=o==="spot",h=this.safeValue(a,"margin_trading",!1),l=u&&h,p=d!==void 0,m=c&&!p,g=!1,y=this.safeString2(a,"base_currency","underlying"),b=this.safeString(a,"quote_currency"),w=this.safeString(a,"fee_currency"),S=this.safeCurrencyCode(y),k=this.safeCurrencyCode(b),T=this.safeCurrencyCode(w);let I,_,N=S+"/"+k,M="spot",x,v,O;c&&(x=this.parseNumber("1"),I=w,_=this.safeCurrencyCode(I),v=k!==void 0&&k===_,O=!v,N=N+":"+_,p?(N=N+"-"+d,M="future"):M="swap");const A=this.safeString(a,"quantity_increment"),V=this.safeString(a,"tick_size"),q=this.parseNumber(A),R=this.parseNumber(V);s.push({id:r,symbol:N,base:S,quote:k,settle:_,baseId:y,quoteId:b,settleId:I,type:M,spot:u,margin:l,swap:m,future:p,option:g,active:!0,contract:c,linear:v,inverse:O,taker:this.safeNumber(a,"take_rate"),maker:this.safeNumber(a,"make_rate"),contractSize:x,expiry:d,expiryDatetime:void 0,strike:void 0,optionType:void 0,feeCurrency:T,precision:{amount:q,price:R},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(a,"max_initial_leverage",1)},amount:{min:q,max:void 0},price:{min:R,max:void 0},cost:{min:this.parseNumber($F.stringMul(A,V)),max:void 0}},info:a})}return s}async fetchCurrencies(e={}){const t=await this.publicGetPublicCurrency(e),s={},i=Object.keys(t);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeCurrencyCode(r),o=t[r],d=this.safeString(o,"full_name"),c=this.safeNumber(o,"precision_transfer"),u=this.safeValue(o,"payin_enabled",!1),h=this.safeValue(o,"payout_enabled",!1),l=this.safeValue(o,"transfer_enabled",!1),p=u&&h&&l,m=this.safeValue(o,"networks",[]),g={};let y,b,w;for(let T=0;T<m.length;T++){const I=m[T],_=this.safeString2(I,"protocol","network"),N=this.safeNetwork(_);y=this.safeNumber(I,"payout_fee");const M=this.safeNumber(I,"precision_payout"),x=this.safeValue(o,"payin_enabled",!1),v=this.safeValue(o,"payout_enabled",!1),O=x&&v;x&&!b?b=!0:x||(b=!1),v&&!w?w=!0:v||(w=!1),g[N]={info:I,id:_,network:N,fee:y,active:O,deposit:x,withdraw:v,precision:M,limits:{withdraw:{min:void 0,max:void 0}}}}const k=Object.keys(g).length;s[a]={info:o,code:a,id:r,precision:c,name:d,active:p,deposit:b,withdraw:w,networks:g,fee:k<=1?y:void 0,limits:{amount:{min:void 0,max:void 0}}}}return s}safeNetwork(e){if(e!==void 0)return e.toUpperCase()}async createDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=this.safeStringUpper(t,"network");if(n!==void 0&&e==="USDT"){const o=this.safeValue(this.options,"networks"),d=this.safeString(o,n);d!==void 0&&(i.currency=d),t=this.omit(t,"network")}const r=await this.privatePostWalletCryptoAddress(this.extend(i,t)),a=this.safeString(r,"currency");return{currency:this.safeCurrencyCode(a),address:this.safeString(r,"address"),tag:this.safeString(r,"payment_id"),network:void 0,info:r}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=this.safeStringUpper(t,"network");if(n!==void 0&&e==="USDT"){const h=this.safeValue(this.options,"networks"),l=this.safeString(h,n);l!==void 0&&(i.currency=l),t=this.omit(t,"network")}const r=await this.privateGetWalletCryptoAddress(this.extend(i,t)),a=this.safeValue(r,0),o=this.safeString(a,"address"),d=this.safeString(a,"currency"),c=this.safeString(a,"payment_id"),u=this.safeCurrencyCode(d);return{info:r,address:o,tag:c,code:u,currency:u,network:void 0}}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"available"),a.used=this.safeString(i,"reserved"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){const t=this.safeStringLower(e,"type","spot");e=this.omit(e,["type"]);const s=this.safeValue(this.options,"accountsByType",{}),i=this.safeString(s,t,t);let n;if(i==="wallet")n=await this.privateGetWalletBalance(e);else if(i==="spot")n=await this.privateGetSpotBalance(e);else if(i==="derivatives")n=await this.privateGetFuturesBalance(e);else{const r=Object.keys(s);throw new ki(this.id+" fetchBalance() type parameter must be one of "+r.join(", "))}return this.parseBalance(n)}async fetchTicker(e,t={}){const s=await this.fetchTickers([e],t);return this.safeValue(s,e)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={};if(e!==void 0){const o=this.marketIds(e).join(",");s.symbols=o}const i=await this.publicGetPublicTicker(this.extend(s,t)),n={},r=Object.keys(i);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeMarket(o),c=d.symbol,u=i[o];n[c]=this.parseTicker(u,d)}return this.filterByArray(n,"symbol",e)}parseTicker(e,t=void 0){const s=this.parse8601(e.timestamp),i=this.safeSymbol(void 0,t),n=this.safeString(e,"volume"),r=this.safeString(e,"volume_quote"),a=this.safeString(e,"open"),o=this.safeString(e,"last");return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:a,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:n,quoteVolume:r,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbols=n.id),s!==void 0&&(r.limit=s),t!==void 0&&(r.from=t);const a=await this.publicGetPublicTrades(this.extend(r,i)),o=Object.keys(a);let d=[];for(let c=0;c<o.length;c++){const u=o[c],h=this.market(u),l=a[u],p=this.parseTrades(l,h);d=this.arrayConcat(d,p)}return d}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),s!==void 0&&(r.limit=s),t!==void 0&&(r.from=t);let a;[a,i]=this.handleMarketTypeAndParams("fetchMyTrades",n,i);let o=this.getSupportedMapping(a,{spot:"privateGetSpotHistoryTrade",swap:"privateGetFuturesHistoryTrade",margin:"privateGetMarginHistoryTrade"});const[d,c]=this.handleMarginModeAndParams("fetchMyTrades",i);d!==void 0&&(o="privateGetMarginHistoryTrade");const u=await this[o](this.extend(r,c));return this.parseTrades(u,n,t,s)}parseTrade(e,t=void 0){const s=this.parse8601(e.timestamp),i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const n=t.symbol;let r;const a=this.safeString(e,"fee"),o=this.safeValue(e,"taker");let d;if(o!==void 0&&(d=o?"taker":"maker"),a!==void 0){const m=this.safeValue(t,"info",{}),g=this.safeString(m,"fee_currency"),y=this.safeCurrencyCode(g);r={cost:a,currency:y}}const c=this.safeString(e,"clientOrderId"),u=this.safeString(e,"price"),h=this.safeString2(e,"quantity","qty"),l=this.safeString(e,"side"),p=this.safeString(e,"id");return this.safeTrade({info:e,id:p,order:c,timestamp:s,datetime:this.iso8601(s),symbol:n,type:void 0,side:l,takerOrMaker:d,price:u,amount:h,cost:void 0,fee:r},t)}async fetchTransactionsHelper(e,t,s,i,n){await this.loadMarkets();const r={types:e};let a;t!==void 0&&(a=this.currency(t),r.currencies=a.id),s!==void 0&&(r.from=this.iso8601(s)),i!==void 0&&(r.limit=i);const o=await this.privateGetWalletTransactions(this.extend(r,n));return this.parseTransactions(o,a,s,i,n)}parseTransactionStatus(e){const t={PENDING:"pending",FAILED:"failed",SUCCESS:"ok"};return this.safeString(t,e,e)}parseTransactionType(e){const t={DEPOSIT:"deposit",WITHDRAW:"withdrawal"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.parse8601(this.safeString(e,"created_at")),n=this.parse8601(this.safeString(e,"updated_at")),r=this.parseTransactionType(this.safeString(e,"type")),a=this.parseTransactionStatus(this.safeString(e,"status")),o=this.safeValue(e,"native",{}),d=this.safeString(o,"currency"),c=this.safeCurrencyCode(d),u=this.safeString(o,"hash"),h=this.safeString(o,"address"),l=h,p=this.safeString(o,"payment_id"),m=p,g=this.safeValue(o,"senders"),y=this.safeString(g,0),b=this.safeNumber(o,"amount");let w;const S=this.safeNumber(o,"fee");return S!==void 0&&(w={currency:c,cost:S}),{info:e,id:s,txid:u,code:c,currency:c,amount:b,network:void 0,address:h,addressFrom:y,addressTo:l,tag:p,tagFrom:void 0,tagTo:m,timestamp:i,datetime:this.iso8601(i),updated:n,status:a,type:r,fee:w}}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsHelper("DEPOSIT,WITHDRAW",e,t,s,i)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsHelper("DEPOSIT",e,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsHelper("WITHDRAW",e,t,s,i)}async fetchOrderBooks(e=void 0,t=void 0,s={}){await this.loadMarkets();const i={};if(e!==void 0){const o=this.marketIds(e);i.symbols=o.join(",")}t!==void 0&&(i.depth=t);const n=await this.publicGetPublicOrderbook(this.extend(i,s)),r={},a=Object.keys(n);for(let o=0;o<a.length;o++){const d=a[o],c=n[d],u=this.safeSymbol(d),h=this.parse8601(this.safeString(c,"timestamp"));r[u]=this.parseOrderBook(n[d],u,h,"bid","ask")}return r}async fetchOrderBook(e,t=void 0,s={}){return(await this.fetchOrderBooks([e],t,s))[e]}parseTradingFee(e,t=void 0){const s=this.safeNumber(e,"take_rate"),i=this.safeNumber(e,"make_rate"),n=this.safeString(e,"symbol"),r=this.safeSymbol(n,t);return{info:e,symbol:r,taker:s,maker:i}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=this.getSupportedMapping(s.type,{spot:"privateGetSpotFeeSymbol",swap:"privateGetFuturesFeeSymbol"}),r=await this[n](this.extend(i,t));return this.parseTradingFee(r,s)}async fetchTradingFees(e=void 0,t={}){await this.loadMarkets();const[s,i]=this.handleMarketTypeAndParams("fetchTradingFees",void 0,t),n=this.getSupportedMapping(s,{spot:"privateGetSpotFee",swap:"privateGetFuturesFee"}),r=await this[n](i),a={};for(let o=0;o<r.length;o++){const d=this.parseTradingFee(r[o]),c=d.symbol;a[c]=d}return a}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbols:r.id,period:this.timeframes[t]};s!==void 0&&(a.from=this.iso8601(s)),i!==void 0&&(a.limit=i);const o=this.safeString(n,"price");n=this.omit(n,"price");let d="publicGetPublicCandles";o==="mark"?d="publicGetPublicFuturesCandlesMarkPrice":o==="index"?d="publicGetPublicFuturesCandlesIndexPrice":o==="premiumIndex"&&(d="publicGetPublicFuturesCandlesPremiumIndex");const c=await this[d](this.extend(a,n)),u=this.safeValue(c,r.id);return this.parseOHLCVs(u,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"timestamp")),this.safeNumber(e,"open"),this.safeNumber(e,"max"),this.safeNumber(e,"min"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),t!==void 0&&(r.from=this.iso8601(t)),s!==void 0&&(r.limit=s);let a;[a,i]=this.handleMarketTypeAndParams("fetchClosedOrders",n,i);let o=this.getSupportedMapping(a,{spot:"privateGetSpotHistoryOrder",swap:"privateGetFuturesHistoryOrder",margin:"privateGetMarginHistoryOrder"});const[d,c]=this.handleMarginModeAndParams("fetchClosedOrders",i);d!==void 0&&(o="privateGetMarginHistoryOrder");const u=await this[o](this.extend(r,c)),h=this.parseOrders(u,n,t,s);return this.filterByArray(h,"status",["closed","canceled"],!1)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));let n;[n,s]=this.handleMarketTypeAndParams("fetchOrder",i,s);let r=this.getSupportedMapping(n,{spot:"privateGetSpotHistoryOrder",swap:"privateGetFuturesHistoryOrder",margin:"privateGetMarginHistoryOrder"});const[a,o]=this.handleMarginModeAndParams("fetchOrder",s);a!==void 0&&(r="privateGetMarginHistoryOrder");const d={client_order_id:e},c=await this[r](this.extend(d,o)),u=this.safeValue(c,0);return this.parseOrder(u,i)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;t!==void 0&&(r=this.market(t));const a={order_id:e};let o;[o,n]=this.handleMarketTypeAndParams("fetchOrderTrades",r,n);let d=this.getSupportedMapping(o,{spot:"privateGetSpotHistoryTrade",swap:"privateGetFuturesHistoryTrade",margin:"privateGetMarginHistoryTrade"});const[c,u]=this.handleMarginModeAndParams("fetchOrderTrades",n);c!==void 0&&(d="privateGetMarginHistoryTrade");const h=await this[d](this.extend(a,u));return this.parseTrades(h,r,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id);let a;[a,i]=this.handleMarketTypeAndParams("fetchOpenOrders",n,i);let o=this.getSupportedMapping(a,{spot:"privateGetSpotOrder",swap:"privateGetFuturesOrder",margin:"privateGetMarginOrder"});const[d,c]=this.handleMarginModeAndParams("fetchOpenOrders",i);d!==void 0&&(o="privateGetMarginOrder");const u=await this[o](this.extend(r,c));return this.parseOrders(u,n,t,s)}async fetchOpenOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));let n;[n,s]=this.handleMarketTypeAndParams("fetchOpenOrder",i,s);let r=this.getSupportedMapping(n,{spot:"privateGetSpotOrderClientOrderId",swap:"privateGetFuturesOrderClientOrderId",margin:"privateGetMarginOrderClientOrderId"});const[a,o]=this.handleMarginModeAndParams("fetchOpenOrder",s);a!==void 0&&(r="privateGetMarginOrderClientOrderId");const d={client_order_id:e},c=await this[r](this.extend(d,o));return this.parseOrder(c,i)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();let s;const i={};e!==void 0&&(s=this.market(e),i.symbol=s.id);let n;[n,t]=this.handleMarketTypeAndParams("cancelAllOrders",s,t);let r=this.getSupportedMapping(n,{spot:"privateDeleteSpotOrder",swap:"privateDeleteFuturesOrder",margin:"privateDeleteMarginOrder"});const[a,o]=this.handleMarginModeAndParams("cancelAllOrders",t);a!==void 0&&(r="privateDeleteMarginOrder");const d=await this[r](this.extend(i,o));return this.parseOrders(d,s)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();let i;const n={client_order_id:e};t!==void 0&&(i=this.market(t));let r;[r,s]=this.handleMarketTypeAndParams("cancelOrder",i,s);let a=this.getSupportedMapping(r,{spot:"privateDeleteSpotOrderClientOrderId",swap:"privateDeleteFuturesOrderClientOrderId",margin:"privateDeleteMarginOrderClientOrderId"});const[o,d]=this.handleMarginModeAndParams("cancelOrder",s);o!==void 0&&(a="privateDeleteMarginOrderClientOrderId");const c=await this[a](this.extend(n,d));return this.parseOrder(c,i)}async editOrder(e,t,s,i,n,r=void 0,a={}){await this.loadMarkets();let o;const d={client_order_id:e,quantity:this.amountToPrecision(t,n)};if(s==="limit"||s==="stopLimit"){if(r===void 0)throw new Tt(this.id+" editOrder() limit order requires price");d.price=this.priceToPrecision(t,r)}t!==void 0&&(o=this.market(t));let c;[c,a]=this.handleMarketTypeAndParams("editOrder",o,a);let u=this.getSupportedMapping(c,{spot:"privatePatchSpotOrderClientOrderId",swap:"privatePatchFuturesOrderClientOrderId",margin:"privatePatchMarginOrderClientOrderId"});const[h,l]=this.handleMarginModeAndParams("editOrder",a);h!==void 0&&(u="privatePatchMarginOrderClientOrderId");const p=await this[u](this.extend(d,l));return this.parseOrder(p,o)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={type:t,side:s,quantity:this.amountToPrecision(e,i),symbol:a.id},d=this.safeValue(r,"reduceOnly");if(d!==void 0&&a.type!=="swap"&&a.type!=="margin")throw new Ff(this.id+" createOrder() does not support reduce_only for "+a.type+" orders, reduce_only orders are supported for swap and margin markets only");d===!0&&(o.reduce_only=d);const c=this.safeString2(r,"timeInForce","time_in_force"),u=this.safeString(r,"expire_time"),h=this.safeNumber2(r,"stopPrice","stop_price");if(t==="limit"||t==="stopLimit"||t==="takeProfitLimit"){if(n===void 0)throw new Tt(this.id+" createOrder() requires a price argument for limit orders");o.price=this.priceToPrecision(e,n)}if(c==="GTD"){if(u===void 0)throw new Tt(this.id+" createOrder() requires an expire_time parameter for a GTD order");o.expire_time=u}if(t==="stopLimit"||t==="stopMarket"||t==="takeProfitLimit"||t==="takeProfitMarket"){if(h===void 0)throw new Tt(this.id+" createOrder() requires a stopPrice parameter for stop-loss and take-profit orders");o.stop_price=this.priceToPrecision(e,h)}let l;[l,r]=this.handleMarketTypeAndParams("createOrder",a,r);let p=this.getSupportedMapping(l,{spot:"privatePostSpotOrder",swap:"privatePostFuturesOrder",margin:"privatePostMarginOrder"});const[m,g]=this.handleMarginModeAndParams("createOrder",r);m!==void 0&&(p="privatePostMarginOrder");const y=await this[p](this.extend(o,g));return this.parseOrder(y,a)}parseOrderStatus(e){const t={new:"open",suspended:"open",partiallyFilled:"open",filled:"closed",canceled:"canceled",expired:"failed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"client_order_id"),i=this.safeString(e,"side"),n=this.safeString(e,"type"),r=this.safeString(e,"quantity"),a=this.safeString(e,"price"),o=this.safeString(e,"price_average"),d=this.safeString(e,"created_at"),c=this.parse8601(d),u=this.safeString(e,"updated_at");let h;u!==d&&(h=this.parse8601(u));const l=this.safeString(e,"quantity_cumulative"),p=this.parseOrderStatus(this.safeString(e,"status")),m=this.safeString(e,"symbol");t=this.safeMarket(m,t);const g=t.symbol,y=this.safeValue(e,"post_only"),b=this.safeString(e,"time_in_force"),w=this.safeValue(e,"trades");return this.safeOrder({info:e,id:s,clientOrderId:s,timestamp:c,datetime:this.iso8601(c),lastTradeTimestamp:h,symbol:g,price:a,amount:r,type:n,side:i,timeInForce:b,postOnly:y,reduceOnly:this.safeValue(e,"reduce_only"),filled:l,remaining:void 0,cost:void 0,status:p,average:o,trades:w,fee:void 0},t)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.currencyToPrecision(e,t),o=this.safeValue(this.options,"accountsByType",{});s=s.toLowerCase(),i=i.toLowerCase();const d=this.safeString(o,s,s),c=this.safeString(o,i,i);if(d===c)throw new ki(this.id+" transfer() fromAccount and toAccount arguments cannot be the same account");const u={currency:r.id,amount:a,source:d,destination:c},h=await this.privatePostWalletTransfer(this.extend(u,n)),l=this.parseTransfer(h,r);return this.extend(l,{fromAccount:s,toAccount:i,amount:this.parseNumber(a)})}parseTransfer(e,t=void 0){const s=this.milliseconds();return{id:this.safeString(e,0),timestamp:s,datetime:this.iso8601(s),currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0,info:e}}async convertCurrencyNetwork(e,t,s,i,n){if(await this.loadMarkets(),e!=="USDT")throw new Tt(this.id+" convertCurrencyNetwork() only supports USDT currently");const r=this.safeValue(this.options,"networks",{});if(s=s.toUpperCase(),i=i.toUpperCase(),s=this.safeString(r,s),i=this.safeString(r,i),s===i)throw new ki(this.id+" convertCurrencyNetwork() fromNetwork cannot be the same as toNetwork");if(s===void 0||i===void 0){const d=Object.keys(r);throw new Df(this.id+" convertCurrencyNetwork() requires a fromNetwork parameter and a toNetwork parameter, supported networks are "+d.join(", "))}const a={from_currency:s,to_currency:i,amount:this.currencyToPrecision(e,t)};return{info:await this.privatePostWalletConvert(this.extend(a,n))}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets(),this.checkAddress(s);const r=this.currency(e),a={currency:r.id,amount:t,address:s};i!==void 0&&(a.payment_id=i);const o=this.safeValue(this.options,"networks",{}),d=this.safeStringUpper(n,"network");if(d!==void 0&&e==="USDT"){const u=this.safeString(o,d);u!==void 0&&(a.currency=u),n=this.omit(n,"network")}const c=await this.privatePostWalletCryptoWithdraw(this.extend(a,n));return this.parseTransaction(c,r)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),e=n.symbol,r.symbols=n.id),t!==void 0&&(r.from=t),s!==void 0&&(r.limit=s);const a=await this.publicGetPublicFuturesHistoryFunding(this.extend(r,i)),o=Object.keys(a),d=[];for(let u=0;u<o.length;u++){const h=o[u],l=this.safeMarket(h),p=a[h];for(let m=0;m<p.length;m++){const g=p[m],y=this.safeSymbol(l.symbol),b=this.safeNumber(g,"funding_rate"),w=this.safeString(g,"timestamp");d.push({info:g,symbol:y,fundingRate:b,timestamp:this.parse8601(w),datetime:w})}}const c=this.sortBy(d,"timestamp");return this.filterBySymbolSinceLimit(c,e,t,s)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s={};let i;[i,t]=this.handleMarketTypeAndParams("fetchPositions",void 0,t);let n=this.getSupportedMapping(i,{swap:"privateGetFuturesAccount",margin:"privateGetMarginAccount"});const[r,a]=this.handleMarginModeAndParams("fetchPositions",t);r!==void 0&&(n="privateGetMarginAccount");const o=await this[n](this.extend(s,a)),d=[];for(let c=0;c<o.length;c++)d.push(this.parsePosition(o[c]));return d}async fetchPosition(e,t={}){await this.loadMarkets();let s;[s,t]=this.handleMarketTypeAndParams("fetchPosition",void 0,t);let i=this.getSupportedMapping(s,{swap:"privateGetFuturesAccountIsolatedSymbol",margin:"privateGetMarginAccountIsolatedSymbol"});const[n,r]=this.handleMarginModeAndParams("fetchPosition",t);n!==void 0&&(i="privateGetMarginAccountIsolatedSymbol");const a=this.market(e),o={symbol:a.id},d=await this[i](this.extend(o,r));return this.parsePosition(d,a)}parsePosition(e,t=void 0){const s=this.safeString(e,"type"),i=this.safeNumber(e,"leverage"),n=this.safeString(e,"updated_at"),r=this.safeValue(e,"positions",[]);let a,o,d;for(let p=0;p<r.length;p++){const m=r[p];a=this.safeNumber(m,"price_liquidation"),o=this.safeNumber(m,"price_entry"),d=this.safeNumber(m,"quantity")}const c=this.safeValue(e,"currencies",[]);let u;for(let p=0;p<c.length;p++){const m=c[p];u=this.safeNumber(m,"margin_balance")}const h=this.safeString(e,"symbol");t=this.safeMarket(h,t);const l=t.symbol;return{info:e,id:void 0,symbol:l,notional:void 0,marginMode:s,marginType:s,liquidationPrice:a,entryPrice:o,unrealizedPnl:void 0,percentage:void 0,contracts:d,contractSize:void 0,markPrice:void 0,side:void 0,hedged:void 0,timestamp:this.parse8601(n),datetime:n,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,collateral:u,initialMargin:void 0,initialMarginPercentage:void 0,leverage:i,marginRatio:void 0}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new O0(this.id+" fetchFundingRate() supports swap contracts only");const i={};e!==void 0&&(e=s.symbol,i.symbols=s.id);const n=await this.publicGetPublicFuturesInfo(this.extend(i,t)),r=this.safeValue(n,s.id,{});return this.parseFundingRate(r,s)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"next_funding_time"),i=this.safeString(e,"timestamp");return{info:e,symbol:this.safeSymbol(void 0,t),markPrice:this.safeNumber(e,"mark_price"),indexPrice:this.safeNumber(e,"index_price"),interestRate:this.safeNumber(e,"interest_rate"),estimatedSettlePrice:void 0,timestamp:this.parse8601(i),datetime:i,fundingRate:this.safeNumber(e,"funding_rate"),fundingTimestamp:this.parse8601(s),fundingDatetime:s,nextFundingRate:this.safeNumber(e,"indicative_funding_rate"),nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets();const n=this.market(e),r=this.safeString(i,"leverage");if(n.type==="swap"&&r===void 0)throw new Df(this.id+" modifyMarginHelper() requires a leverage parameter for swap markets");t=this.amountToPrecision(e,t);const a={symbol:n.id,margin_balance:t};r!==void 0&&(a.leverage=r);let o;[o,i]=this.handleMarketTypeAndParams("modifyMarginHelper",void 0,i);let d=this.getSupportedMapping(o,{swap:"privatePutFuturesAccountIsolatedSymbol",margin:"privatePutMarginAccountIsolatedSymbol"});const[c,u]=this.handleMarginModeAndParams("modifyMarginHelper",i);c!==void 0&&(d="privatePutMarginAccountIsolatedSymbol");const h=await this[d](this.extend(a,u));return this.extend(this.parseMarginModification(h,n),{amount:this.parseNumber(t),type:s})}parseMarginModification(e,t=void 0){const s=this.safeValue(e,"currencies",[]),i=this.safeValue(s,0);return{info:e,type:void 0,amount:void 0,code:this.safeString(i,"code"),symbol:t.symbol,status:void 0}}async reduceMargin(e,t,s={}){if(t!==0)throw new ki(this.id+" reduceMargin() on hitbtc3 requires the amount to be 0 and that will remove the entire margin amount");return await this.modifyMarginHelper(e,t,"reduce",s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"add",s)}async fetchLeverage(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let n=this.getSupportedMapping(s.type,{spot:"privateGetMarginAccountIsolatedSymbol",margin:"privateGetMarginAccountIsolatedSymbol",swap:"privateGetFuturesAccountIsolatedSymbol"});const[r,a]=this.handleMarginModeAndParams("modifyMarginHelper",t);r!==void 0&&(n="privateGetMarginAccountIsolatedSymbol");const o=await this[n](this.extend(i,a));return this.safeNumber(o,"leverage")}async setLeverage(e,t=void 0,s={}){if(await this.loadMarkets(),t===void 0)throw new Df(this.id+" setLeverage() requires a symbol argument");if(s.margin_balance===void 0)throw new Df(this.id+" setLeverage() requires a margin_balance parameter that will transfer margin to the specified trading pair");const i=this.market(t),n=this.safeNumber(s,"margin_balance"),r=this.safeInteger(i.limits.leverage,"max",50);if(i.type!=="swap")throw new O0(this.id+" setLeverage() supports swap contracts only");if(e<1||e>r)throw new ki(this.id+" setLeverage() leverage should be between 1 and "+r.toString()+" for "+t);const a={symbol:i.id,leverage:e.toString(),margin_balance:this.amountToPrecision(t,n)};return await this.privatePutFuturesAccountIsolatedSymbol(this.extend(a,s))}handleMarginModeAndParams(e,t={},s=void 0){const i=this.safeString(this.options,"defaultType"),n=this.safeValue(t,"margin",!1);let r;if([r,t]=super.handleMarginModeAndParams(e,t,s),r!==void 0){if(r!=="isolated")throw new XF(this.id+" only isolated margin is supported")}else(i==="margin"||n===!0)&&(r="isolated");return[r,t]}handleErrors(e,t,s,i,n,r,a,o,d){const c=this.safeValue(a,"error"),u=this.safeString(c,"code");if(u!==void 0){const h=this.id+" "+r,l=this.safeString2(c,"message","description");throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwBroadlyMatchedException(this.exceptions.broad,l,h),new Tt(h)}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.omit(i,this.extractParams(e)),o=this.implodeParams(e,i);let d=this.urls.api[t]+"/"+o,c;const h=Object.keys(a).length;if(n={"Content-Type":"application/json"},s==="GET"?h&&(c="?"+this.urlencode(a),d=d+c):r=this.json(i),t==="private"){this.checkRequiredCredentials();const l=this.nonce().toString(),p=[s,"/api/3/"+o];s==="GET"?c!==void 0&&p.push(c):p.push(r),p.push(l);const m=p.join(""),g=this.hmac(this.encode(m),this.encode(this.secret),"sha256","hex"),y=this.apiKey+":"+g+":"+l,b=this.decode(this.stringToBase64(y));n.Authorization="HS256 "+b}return{url:d,method:s,body:r,headers:n}}};const QF=me,{BadRequest:Oc,AuthenticationError:Jk,NetworkError:ev,ArgumentsRequired:tv,OrderImmediatelyFillable:ZF,OrderNotFound:sv,InsufficientFunds:JF}=oe,{TICK_SIZE:eD}=pe,iv=ke;var R_=class extends QF{describe(){return this.deepExtend(super.describe(),{id:"hollaex",name:"HollaEx",countries:["KR"],rateLimit:250,version:"v2",pro:!0,has:{CORS:void 0,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,createLimitBuyOrder:!0,createLimitSellOrder:!0,createMarketBuyOrder:!0,createMarketSellOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:"emulated",fetchDepositAddresses:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:void 0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","1h":"1h","4h":"4h","1d":"1d","1w":"1w"},urls:{logo:"https://user-images.githubusercontent.com/1294454/75841031-ca375180-5ddd-11ea-8417-b975674c23cb.jpg",test:{rest:"https://api.sandbox.hollaex.com"},api:{rest:"https://api.hollaex.com"},www:"https://hollaex.com",doc:"https://apidocs.hollaex.com",referral:"https://pro.hollaex.com/signup?affiliation_code=QSWA6G"},precisionMode:eD,requiredCredentials:{apiKey:!0,secret:!0},api:{public:{get:{health:1,constants:1,kit:1,tiers:1,ticker:1,tickers:1,orderbook:1,orderbooks:1,trades:1,chart:1,charts:1,"udf/config":1,"udf/history":1,"udf/symbols":1}},private:{get:{user:1,"user/balance":1,"user/deposits":1,"user/withdrawals":1,"user/withdrawal/fee":1,"user/trades":1,orders:1,order:1},post:{"user/withdrawal":1,order:1},delete:{"order/all":1,order:1}}},fees:{trading:{tierBased:!0,percentage:!0,taker:.001,maker:.001}},exceptions:{broad:{"Invalid token":Jk,"Order not found":sv,"Insufficient balance":JF,"Error 1001 - Order rejected. Order could not be submitted as this order was set to a post only order.":ZF},exact:{400:Oc,403:Jk,404:Oc,405:Oc,410:Oc,429:Oc,500:ev,503:ev}},options:{"api-expires":parseInt(this.timeout/1e3),networks:{BTC:"btc",ETH:"eth",ERC20:"eth",TRX:"trx",TRC20:"trx",XRP:"xrp",XLM:"xlm"}}})}async fetchMarkets(e={}){const t=await this.publicGetConstants(e),s=this.safeValue(t,"pairs",{}),i=Object.keys(s),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=s[a],d=this.safeString(o,"pair_base"),c=this.safeString(o,"pair_2"),u=this.commonCurrencyCode(d.toUpperCase()),h=this.commonCurrencyCode(c.toUpperCase());n.push({id:this.safeString(o,"name"),symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:this.safeValue(o,"active"),contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(o,"increment_size"),price:this.safeNumber(o,"increment_price")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(o,"min_size"),max:this.safeNumber(o,"max_size")},price:{min:this.safeNumber(o,"min_price"),max:this.safeNumber(o,"max_price")},cost:{min:void 0,max:void 0}},info:o})}return n}async fetchCurrencies(e={}){const t=await this.publicGetConstants(e),s=this.safeValue(t,"coins",{}),i=Object.keys(s),n={};for(let r=0;r<i.length;r++){const a=i[r],o=s[a],d=this.safeString(o,"symbol"),c=this.safeInteger(o,"id"),u=this.safeCurrencyCode(d),h=this.safeString(o,"fullname"),l=this.safeValue(o,"allow_deposit"),p=this.safeValue(o,"allow_withdrawal"),g=this.safeValue(o,"active")&&l&&p,y=this.safeNumber(o,"withdrawal_fee"),b=this.safeValue(o,"withdrawal_limits",[]);n[u]={id:d,numericId:c,code:u,info:o,name:h,active:g,deposit:l,withdraw:p,fee:y,precision:this.safeNumber(o,"increment_unit"),limits:{amount:{min:this.safeNumber(o,"min"),max:this.safeNumber(o,"max")},withdraw:{min:void 0,max:this.safeValue(b,0)}}}}return n}async fetchOrderBooks(e=void 0,t=void 0,s={}){await this.loadMarkets();const i=await this.publicGetOrderbooks(s),n={},r=Object.keys(i);for(let a=0;a<r.length;a++){const o=r[a],d=i[o],c=this.safeSymbol(o,void 0,"-"),u=this.parse8601(this.safeString(d,"timestamp"));n[c]=this.parseOrderBook(i[o],c,u)}return n}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id},r=await this.publicGetOrderbooks(this.extend(n,s)),a=this.safeValue(r,i.id),o=this.parse8601(this.safeString(a,"timestamp"));return this.parseOrderBook(a,i.symbol,o)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetTicker(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTickers(this.extend(t));return this.parseTickers(s,e)}parseTickers(e,t=void 0,s={}){const i={},n=Object.keys(e);for(let r=0;r<n.length;r++){const a=n[r],o=e[a],d=this.safeString(o,"symbol",a),c=this.safeMarket(d,void 0,"-"),u=c.symbol;i[u]=this.extend(this.parseTicker(o,c),s)}return this.filterByArray(i,"symbol",t)}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,"-");const i=t.symbol,n=this.parse8601(this.safeString2(e,"time","timestamp")),r=this.safeString(e,"close");return this.safeTicker({symbol:i,info:e,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:r,last:this.safeString(e,"last",r),previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.publicGetTrades(this.extend(r,i)),o=this.safeValue(a,n.id,[]);return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,"-");const i=t.symbol,n=this.safeString(e,"timestamp"),r=this.parse8601(n),a=this.safeString(e,"side"),o=this.safeString(e,"order_id"),d=this.safeString(e,"price"),c=this.safeString(e,"size"),u=this.safeString(e,"fee");let h;return u!==void 0&&(h={cost:u,currency:t.quote}),this.safeTrade({info:e,id:void 0,timestamp:r,datetime:n,symbol:i,order:o,type:void 0,side:a,takerOrMaker:void 0,price:d,amount:c,cost:void 0,fee:h},t)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetTiers(e),s=this.safeValue(t,"1",{}),i=this.safeValue(s,"fees",{}),n=this.safeValue(i,"maker",{}),r=this.safeValue(i,"taker",{}),a={};for(let o=0;o<this.symbols.length;o++){const d=this.symbols[o],c=this.market(d),u=this.safeString(n,c.id),h=this.safeString(r,c.id);a[d]={info:i,symbol:d,maker:this.parseNumber(iv.stringDiv(u,"100")),taker:this.parseNumber(iv.stringDiv(h,"100")),percentage:!0,tierBased:!0}}return a}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,resolution:this.timeframes[t]},o=this.parseTimeframe(t);if(s===void 0){i===void 0&&(i=1e3);const c=this.seconds(),u=c-o*i;a.to=c,a.from=u}else if(i===void 0)a.from=parseInt(s/1e3),a.to=this.seconds();else{const c=parseInt(s/1e3);a.from=c,a.to=this.sum(c,o*i)}const d=await this.publicGetChart(this.extend(a,n));return this.parseOHLCVs(d,r,t,s,i)}parseOHLCV(e,t=void 0,s="1h",i=void 0,n=void 0){return[this.parse8601(this.safeString(e,"time")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}parseBalance(e){const t=this.parse8601(this.safeString(e,"updated_at")),s={info:e,timestamp:t,datetime:this.iso8601(t)},i=Object.keys(this.currencies_by_id);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(e,r+"_available"),o.total=this.safeString(e,r+"_balance"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetUserBalance(e);return this.parseBalance(t)}async fetchOpenOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privateGetOrder(this.extend(i,s));return this.parseOrder(n)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={open:!0};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={open:!1};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},r=await this.privateGetOrder(this.extend(i,s));if(r===void 0)throw new sv(this.id+" fetchOrder() could not find order id "+e);return this.parseOrder(r)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),t!==void 0&&(r.start_date=this.iso8601(t)),s!==void 0&&(r.limit=s);const a=await this.privateGetOrders(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseOrders(o,n,t,s)}parseOrderStatus(e){const t={new:"open",pfilled:"open",filled:"closed",canceled:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t,"-"),n=this.safeString(e,"id"),r=this.parse8601(this.safeString(e,"created_at")),a=this.safeString(e,"type"),o=this.safeString(e,"side"),d=this.safeString(e,"price"),c=this.safeString(e,"stop"),u=this.safeString(e,"size"),h=this.safeString(e,"filled"),l=this.parseOrderStatus(this.safeString(e,"status")),p=this.safeValue(e,"meta",{}),m=this.safeValue(p,"post_only",!1);return this.safeOrder({id:n,clientOrderId:void 0,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,status:l,symbol:i,type:a,timeInForce:void 0,postOnly:m,side:o,price:d,stopPrice:c,amount:u,filled:h,remaining:void 0,cost:void 0,trades:void 0,fee:void 0,info:e,average:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=parseFloat(this.amountToPrecision(e,i)),d={symbol:a.id,side:s,size:this.normalizeNumberIfNeeded(o),type:t},c=this.safeNumberN(r,["triggerPrice","stopPrice","stop"]),u=this.safeValue(r,"meta",{}),h=this.safeValue(u,"post_only",!1),l=t==="market",p=this.isPostOnly(l,h,r);if(!l){const g=parseFloat(this.priceToPrecision(e,n));d.price=this.normalizeNumberIfNeeded(g)}c!==void 0&&(d.stop=this.normalizeNumberIfNeeded(parseFloat(this.priceToPrecision(e,c)))),p&&(d.meta={post_only:!0}),r=this.omit(r,["postOnly","timeInForce","stopPrice","triggerPrice","stop"]);const m=await this.privatePostOrder(this.extend(d,r));return this.parseOrder(m,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privateDeleteOrder(this.extend(i,s));return this.parseOrder(n)}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new tv(this.id+" cancelAllOrders() requires a 'symbol' argument");await this.loadMarkets();const s={};let i;i=this.market(e),s.symbol=i.id;const n=await this.privateDeleteOrderAll(this.extend(s,t));return this.parseOrders(n,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),s!==void 0&&(n.limit=s),t!==void 0&&(n.start_date=this.iso8601(t));const a=await this.privateGetUserTrades(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,r,t,s)}parseDepositAddress(e,t=void 0){let s=this.safeString(e,"address"),i;if(s!==void 0){const a=s.split(":");s=this.safeString(a,0),i=this.safeString(a,1)}this.checkAddress(s);const n=this.safeString(e,"currency");t=this.safeCurrency(n,t);const r=this.safeString(e,"network");return{currency:t.code,address:s,tag:i,network:r,info:e}}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s=this.safeString(t,"network");t=this.omit(t,"network");const i=await this.privateGetUser(t),n=this.safeValue(i,"wallet",[]),r=s===void 0?n:this.filterBy(n,"network",s);return this.parseDepositAddresses(r,e)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.limit=s),t!==void 0&&(n.start_date=this.iso8601(t));const a=await this.privateGetUserDeposits(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,r,t,s)}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const i={transaction_id:e};let n;t!==void 0&&(n=this.currency(t),i.currency=n.id);const r=await this.privateGetUserWithdrawals(this.extend(i,s)),a=this.safeValue(r,"data",[]),o=this.safeValue(a,0,{});return this.parseTransaction(o,n)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.limit=s),t!==void 0&&(n.start_date=this.iso8601(t));const a=await this.privateGetUserWithdrawals(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,r,t,s)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"transaction_id"),n=this.parse8601(this.safeString(e,"created_at")),r=this.parse8601(this.safeString(e,"updated_at")),a=this.safeString(e,"type"),o=this.safeNumber(e,"amount");let d=this.safeString(e,"address"),c;const u=void 0;let h,l;const p=void 0;if(d!==void 0){const I=d.split(":");d=this.safeString(I,0),h=this.safeString(I,1),c=d,l=h}const m=this.safeString(e,"currency");t=this.safeCurrency(m,t);let g=this.safeValue(e,"status");const y=this.safeValue(e,"dismissed"),b=this.safeValue(e,"rejected");g?g="ok":y?g="canceled":b?g="failed":g="pending";const w=this.safeString(e,"fee_coin"),S=this.safeCurrencyCode(w,t),k=this.safeNumber(e,"fee");let T;return k!==void 0&&(T={currency:S,cost:k}),{info:e,id:s,txid:i,timestamp:n,datetime:this.iso8601(n),network:void 0,addressFrom:u,address:d,addressTo:c,tagFrom:p,tag:h,tagTo:l,type:a,amount:o,currency:t.code,status:g,updated:r,fee:T}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e);i!==void 0&&(s+=":"+i);const a=this.safeString(n,"network");if(a===void 0)throw new tv(this.id+" withdraw() requires a network parameter");n=this.omit(n,"network");const o=this.safeValue(this.options,"networks",{}),d=this.safeStringLower2(o,a,e,a),c={currency:r.id,amount:t,address:s,network:d},u=await this.privatePostUserWithdrawal(this.extend(c,n));return this.parseTransaction(u,r)}normalizeNumberIfNeeded(e){return e%1===0&&(e=parseInt(e)),e}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.omit(i,this.extractParams(e));e="/"+this.version+"/"+this.implodeParams(e,i),(s==="GET"||s==="DELETE")&&Object.keys(a).length&&(e+="?"+this.urlencode(a));const o=this.urls.api.rest+e;if(t==="private"){this.checkRequiredCredentials();const d=this.safeInteger2(this.options,"api-expires","expires",parseInt(this.timeout/1e3)),u=this.sum(this.seconds(),d).toString();let h=s+e+u;n={"api-key":this.apiKey,"api-expires":u},s==="POST"&&(n["Content-type"]="application/json",Object.keys(a).length&&(r=this.json(a),h+=r));const l=this.hmac(this.encode(h),this.encode(this.secret));n["api-signature"]=l}return{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&e>=400&&e<=503){const c=this.id+" "+r,u=this.safeString(a,"message");this.throwBroadlyMatchedException(this.exceptions.broad,u,c);const h=e.toString();this.throwExactlyMatchedException(this.exceptions.exact,h,c)}}};const tD=me,{AccountNotEnabled:nv,ArgumentsRequired:Ds,AuthenticationError:C0,ExchangeError:rv,PermissionDenied:sD,ExchangeNotAvailable:av,OnMaintenance:M0,InvalidOrder:Ts,OrderNotFound:Hf,InsufficientFunds:Gf,BadSymbol:jr,BadRequest:vi,RateLimitExceeded:iD,RequestTimeout:nD,NetworkError:rD,InvalidAddress:Uf,NotSupported:Ti}=oe,{TICK_SIZE:aD,TRUNCATE:oD}=pe,ai=ke;var Ob=class extends tD{describe(){return this.deepExtend(super.describe(),{id:"huobi",name:"Huobi",countries:["CN"],rateLimit:100,userAgent:this.userAgents.chrome100,certified:!0,version:"v1",accounts:void 0,accountsById:void 0,hostname:"api.huobi.pro",pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!0,option:void 0,addMargin:void 0,borrowMargin:!0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createDepositAddress:void 0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowInterest:!0,fetchBorrowRate:void 0,fetchBorrowRateHistories:void 0,fetchBorrowRateHistory:void 0,fetchBorrowRates:!0,fetchBorrowRatesPerSymbol:!0,fetchCanceledOrders:void 0,fetchClosedOrder:void 0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:void 0,fetchDepositAddress:!0,fetchDepositAddresses:void 0,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!0,fetchL3OrderBook:void 0,fetchLedger:!0,fetchLedgerEntry:void 0,fetchLeverage:!1,fetchLeverageTiers:!0,fetchMarketLeverageTiers:!0,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenInterestHistory:!0,fetchOpenOrder:void 0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:void 0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!0,fetchSettlementHistory:!0,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTradingLimits:!0,fetchTransactionFee:void 0,fetchTransactionFees:void 0,fetchTransactions:void 0,fetchTransfers:void 0,fetchWithdrawAddressesByNetwork:!0,fetchWithdrawal:void 0,fetchWithdrawals:!0,fetchWithdrawalWhitelist:void 0,reduceMargin:void 0,repayMargin:!0,setLeverage:!0,setMarginMode:!1,setPositionMode:!1,signIn:void 0,transfer:!0,withdraw:!0},timeframes:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"60min","4h":"4hour","1d":"1day","1w":"1week","1M":"1mon","1y":"1year"},urls:{logo:"https://user-images.githubusercontent.com/1294454/76137448-22748a80-604e-11ea-8069-6e389271911d.jpg",hostnames:{contract:"api.hbdm.com",spot:"api.huobi.pro",status:{spot:"status.huobigroup.com",future:{inverse:"status-dm.huobigroup.com",linear:"status-linear-swap.huobigroup.com"},swap:{inverse:"status-swap.huobigroup.com",linear:"status-linear-swap.huobigroup.com"}}},api:{status:"https://{hostname}",contract:"https://{hostname}",spot:"https://{hostname}",public:"https://{hostname}",private:"https://{hostname}",v2Public:"https://{hostname}",v2Private:"https://{hostname}"},www:"https://www.huobi.com",referral:{url:"https://www.huobi.com/en-us/v/register/double-invite/?inviter_id=11343840&invite_code=6rmm2223",discount:.15},doc:["https://huobiapi.github.io/docs/spot/v1/cn/","https://huobiapi.github.io/docs/dm/v1/cn/","https://huobiapi.github.io/docs/coin_margined_swap/v1/cn/","https://huobiapi.github.io/docs/usdt_swap/v1/cn/","https://huobiapi.github.io/docs/option/v1/cn/"],fees:"https://www.huobi.com/about/fee/"},api:{v2Public:{get:{"reference/currencies":1,"market-status":1}},v2Private:{get:{"account/ledger":1,"account/withdraw/quota":1,"account/withdraw/address":1,"account/deposit/address":1,"account/repayment":5,"reference/transact-fee-rate":1,"account/asset-valuation":.2,"point/account":5,"sub-user/user-list":1,"sub-user/user-state":1,"sub-user/account-list":1,"sub-user/deposit-address":1,"sub-user/query-deposit":1,"user/api-key":1,"user/uid":1,"algo-orders/opening":1,"algo-orders/history":1,"algo-orders/specific":1,"c2c/offers":1,"c2c/offer":1,"c2c/transactions":1,"c2c/repayment":1,"c2c/account":1,"etp/reference":1,"etp/transactions":5,"etp/transaction":5,"etp/rebalance":1,"etp/limit":1},post:{"account/transfer":1,"account/repayment":5,"point/transfer":5,"sub-user/management":1,"sub-user/creation":1,"sub-user/tradable-market":1,"sub-user/transferability":1,"sub-user/api-key-generation":1,"sub-user/api-key-modification":1,"sub-user/api-key-deletion":1,"sub-user/deduct-mode":1,"algo-orders":1,"algo-orders/cancel-all-after":1,"algo-orders/cancellation":1,"c2c/offer":1,"c2c/cancellation":1,"c2c/cancel-all":1,"c2c/repayment":1,"c2c/transfer":1,"etp/creation":5,"etp/redemption":5,"etp/{transactId}/cancel":10,"etp/batch-cancel":50}},public:{get:{"common/symbols":1,"common/currencys":1,"common/timestamp":1,"common/exchange":1,"settings/currencys":1}},private:{get:{"account/accounts":.2,"account/accounts/{id}/balance":.2,"account/accounts/{sub-uid}":1,"account/history":4,"cross-margin/loan-info":1,"margin/loan-info":1,"fee/fee-rate/get":1,"order/openOrders":.4,"order/orders":.4,"order/orders/{id}":.4,"order/orders/{id}/matchresults":.4,"order/orders/getClientOrder":.4,"order/history":1,"order/matchresults":1,"query/deposit-withdraw":1,"margin/loan-orders":.2,"margin/accounts/balance":.2,"cross-margin/loan-orders":1,"cross-margin/accounts/balance":1,"points/actions":1,"points/orders":1,"subuser/aggregate-balance":10,"stable-coin/exchange_rate":1,"stable-coin/quote":1},post:{"account/transfer":1,"futures/transfer":1,"order/batch-orders":.4,"order/orders/place":.2,"order/orders/submitCancelClientOrder":.2,"order/orders/batchCancelOpenOrders":.4,"order/orders/{id}/submitcancel":.2,"order/orders/batchcancel":.4,"dw/withdraw/api/create":1,"dw/withdraw-virtual/{id}/cancel":1,"dw/transfer-in/margin":10,"dw/transfer-out/margin":10,"margin/orders":10,"margin/orders/{id}/repay":10,"cross-margin/transfer-in":1,"cross-margin/transfer-out":1,"cross-margin/orders":1,"cross-margin/orders/{id}/repay":1,"stable-coin/exchange":1,"subuser/transfer":10}},status:{public:{spot:{get:{"api/v2/summary.json":1}},future:{inverse:{get:{"api/v2/summary.json":1}},linear:{get:{"api/v2/summary.json":1}}},swap:{inverse:{get:{"api/v2/summary.json":1}},linear:{get:{"api/v2/summary.json":1}}}}},spot:{public:{get:{"v2/market-status":1,"v1/common/symbols":1,"v1/common/currencys":1,"v2/settings/common/currencies":1,"v2/reference/currencies":1,"v1/common/timestamp":1,"v1/common/exchange":1,"v1/settings/common/chains":1,"v1/settings/common/currencys":1,"v1/settings/common/symbols":1,"v2/settings/common/symbols":1,"v1/settings/common/market-symbols":1,"market/history/candles":1,"market/history/kline":1,"market/detail/merged":1,"market/tickers":1,"market/detail":1,"market/depth":1,"market/trade":1,"market/history/trade":1,"market/detail/":1,"market/etp":1,"v2/etp/reference":1,"v2/etp/rebalance":1}},private:{get:{"v1/account/accounts":.2,"v1/account/accounts/{account-id}/balance":.2,"v2/account/valuation":1,"v2/account/asset-valuation":.2,"v1/account/history":4,"v2/account/ledger":1,"v2/point/account":5,"v2/account/deposit/address":1,"v2/account/withdraw/quota":1,"v2/account/withdraw/address":1,"v2/reference/currencies":1,"v1/query/deposit-withdraw":1,"v1/query/withdraw/client-order-id":1,"v2/user/api-key":1,"v2/user/uid":1,"v2/sub-user/user-list":1,"v2/sub-user/user-state":1,"v2/sub-user/account-list":1,"v2/sub-user/deposit-address":1,"v2/sub-user/query-deposit":1,"v1/subuser/aggregate-balance":10,"v1/account/accounts/{sub-uid}":1,"v1/order/openOrders":.4,"v1/order/orders/{order-id}":.4,"v1/order/orders/getClientOrder":.4,"v1/order/orders/{order-id}/matchresult":.4,"v1/order/orders/{order-id}/matchresults":.4,"v1/order/orders":.4,"v1/order/history":1,"v1/order/matchresults":1,"v2/reference/transact-fee-rate":1,"v2/algo-orders/opening":1,"v2/algo-orders/history":1,"v2/algo-orders/specific":1,"v1/margin/loan-info":1,"v1/margin/loan-orders":.2,"v1/margin/accounts/balance":.2,"v1/cross-margin/loan-info":1,"v1/cross-margin/loan-orders":1,"v1/cross-margin/accounts/balance":1,"v2/account/repayment":5,"v1/stable-coin/quote":1,"v1/stable_coin/exchange_rate":1,"v2/etp/transactions":5,"v2/etp/transaction":5,"v2/etp/limit":1},post:{"v1/account/transfer":1,"v1/futures/transfer":1,"v2/point/transfer":5,"v2/account/transfer":1,"v1/dw/withdraw/api/create":1,"v1/dw/withdraw-virtual/{withdraw-id}/cancel":1,"v2/sub-user/deduct-mode":1,"v2/sub-user/creation":1,"v2/sub-user/management":1,"v2/sub-user/tradable-market":1,"v2/sub-user/transferability":1,"v2/sub-user/api-key-generation":1,"v2/sub-user/api-key-modification":1,"v2/sub-user/api-key-deletion":1,"v1/subuser/transfer":10,"v1/order/orders/place":.2,"v1/order/batch-orders":.4,"v1/order/orders/{order-id}/submitcancel":.2,"v1/order/orders/submitCancelClientOrder":.2,"v1/order/orders/batchCancelOpenOrders":.4,"v1/order/orders/batchcancel":.4,"v2/algo-orders/cancel-all-after":1,"v2/algo-orders":1,"v2/algo-orders/cancellation":1,"v2/account/repayment":5,"v1/dw/transfer-in/margin":10,"v1/dw/transfer-out/margin":10,"v1/margin/orders":10,"v1/margin/orders/{order-id}/repay":10,"v1/cross-margin/transfer-in":1,"v1/cross-margin/transfer-out":1,"v1/cross-margin/orders":1,"v1/cross-margin/orders/{order-id}/repay":1,"v1/stable-coin/exchange":1,"v2/etp/creation":5,"v2/etp/redemption":5,"v2/etp/{transactId}/cancel":10,"v2/etp/batch-cancel":50}}},contract:{public:{get:{"api/v1/timestamp":1,"heartbeat/":1,"api/v1/contract_contract_info":1,"api/v1/contract_index":1,"api/v1/contract_price_limit":1,"api/v1/contract_open_interest":1,"api/v1/contract_delivery_price":1,"market/depth":1,"market/bbo":1,"market/history/kline":1,"index/market/history/mark_price_kline":1,"market/detail/merged":1,"market/detail/batch_merged":1,"v2/market/detail/batch_merged":1,"market/trade":1,"market/history/trade":1,"api/v1/contract_risk_info":1,"api/v1/contract_insurance_fund":1,"api/v1/contract_adjustfactor":1,"api/v1/contract_his_open_interest":1,"api/v1/contract_ladder_margin":1,"api/v1/contract_api_state":1,"api/v1/contract_elite_account_ratio":1,"api/v1/contract_elite_position_ratio":1,"api/v1/contract_liquidation_orders":1,"api/v1/contract_settlement_records":1,"index/market/history/index":1,"index/market/history/basis":1,"api/v1/contract_estimated_settlement_price":1,"api/v3/contract_liquidation_orders":1,"swap-api/v1/swap_contract_info":1,"swap-api/v1/swap_index":1,"swap-api/v1/swap_price_limit":1,"swap-api/v1/swap_open_interest":1,"swap-ex/market/depth":1,"swap-ex/market/bbo":1,"swap-ex/market/history/kline":1,"index/market/history/swap_mark_price_kline":1,"swap-ex/market/detail/merged":1,"v2/swap-ex/market/detail/batch_merged":1,"index/market/history/swap_premium_index_kline":1,"swap-ex/market/detail/batch_merged":1,"swap-ex/market/trade":1,"swap-ex/market/history/trade":1,"swap-api/v1/swap_risk_info":1,"swap-api/v1/swap_insurance_fund":1,"swap-api/v1/swap_adjustfactor":1,"swap-api/v1/swap_his_open_interest":1,"swap-api/v1/swap_ladder_margin":1,"swap-api/v1/swap_api_state":1,"swap-api/v1/swap_elite_account_ratio":1,"swap-api/v1/swap_elite_position_ratio":1,"swap-api/v1/swap_estimated_settlement_price":1,"swap-api/v1/swap_liquidation_orders":1,"swap-api/v1/swap_settlement_records":1,"swap-api/v1/swap_funding_rate":1,"swap-api/v1/swap_batch_funding_rate":1,"swap-api/v1/swap_historical_funding_rate":1,"swap-api/v3/swap_liquidation_orders":1,"index/market/history/swap_estimated_rate_kline":1,"index/market/history/swap_basis":1,"linear-swap-api/v1/swap_contract_info":1,"linear-swap-api/v1/swap_index":1,"linear-swap-api/v1/swap_price_limit":1,"linear-swap-api/v1/swap_open_interest":1,"linear-swap-ex/market/depth":1,"linear-swap-ex/market/bbo":1,"linear-swap-ex/market/history/kline":1,"index/market/history/linear_swap_mark_price_kline":1,"linear-swap-ex/market/detail/merged":1,"linear-swap-ex/market/detail/batch_merged":1,"v2/linear-swap-ex/market/detail/batch_merged":1,"linear-swap-ex/market/trade":1,"linear-swap-ex/market/history/trade":1,"linear-swap-api/v1/swap_risk_info":1,"swap-api/v1/linear-swap-api/v1/swap_insurance_fund":1,"linear-swap-api/v1/swap_adjustfactor":1,"linear-swap-api/v1/swap_cross_adjustfactor":1,"linear-swap-api/v1/swap_his_open_interest":1,"linear-swap-api/v1/swap_ladder_margin":1,"linear-swap-api/v1/swap_cross_ladder_margin":1,"linear-swap-api/v1/swap_api_state":1,"linear-swap-api/v1/swap_cross_transfer_state":1,"linear-swap-api/v1/swap_cross_trade_state":1,"linear-swap-api/v1/swap_elite_account_ratio":1,"linear-swap-api/v1/swap_elite_position_ratio":1,"linear-swap-api/v1/swap_liquidation_orders":1,"linear-swap-api/v1/swap_settlement_records":1,"linear-swap-api/v1/swap_funding_rate":1,"linear-swap-api/v1/swap_batch_funding_rate":1,"linear-swap-api/v1/swap_historical_funding_rate":1,"linear-swap-api/v3/swap_liquidation_orders":1,"index/market/history/linear_swap_premium_index_kline":1,"index/market/history/linear_swap_estimated_rate_kline":1,"index/market/history/linear_swap_basis":1,"linear-swap-api/v1/swap_estimated_settlement_price":1}},private:{get:{"api/v1/contract_api_trading_status":1,"swap-api/v1/swap_api_trading_status":1,"linear-swap-api/v1/swap_api_trading_status":1},post:{"api/v1/contract_balance_valuation":1,"api/v1/contract_account_info":1,"api/v1/contract_position_info":1,"api/v1/contract_sub_auth":1,"api/v1/contract_sub_account_list":1,"api/v1/contract_sub_account_info_list":1,"api/v1/contract_sub_account_info":1,"api/v1/contract_sub_position_info":1,"api/v1/contract_financial_record":1,"api/v1/contract_financial_record_exact":1,"api/v1/contract_user_settlement_records":1,"api/v1/contract_order_limit":1,"api/v1/contract_fee":1,"api/v1/contract_transfer_limit":1,"api/v1/contract_position_limit":1,"api/v1/contract_account_position_info":1,"api/v1/contract_master_sub_transfer":1,"api/v1/contract_master_sub_transfer_record":1,"api/v1/contract_available_level_rate":1,"api/v3/contract_financial_record":1,"api/v3/contract_financial_record_exact":1,"api/v1/contract_order":1,"v1/contract_batchorder":1,"api/v1/contract_cancel":1,"api/v1/contract_cancelall":1,"api/v1/contract_switch_lever_rate":1,"api/v1/lightning_close_position":1,"api/v1/contract_order_info":1,"api/v1/contract_order_detail":1,"api/v1/contract_openorders":1,"api/v1/contract_hisorders":1,"api/v1/contract_hisorders_exact":1,"api/v1/contract_matchresults":1,"api/v1/contract_matchresults_exact":1,"api/v3/contract_hisorders":1,"api/v3/contract_hisorders_exact":1,"api/v3/contract_matchresults":1,"api/v3/contract_matchresults_exact":1,"api/v1/contract_trigger_order":1,"api/v1/contract_trigger_cancel":1,"api/v1/contract_trigger_cancelall":1,"api/v1/contract_trigger_openorders":1,"api/v1/contract_trigger_hisorders":1,"api/v1/contract_tpsl_order":1,"api/v1/contract_tpsl_cancel":1,"api/v1/contract_tpsl_cancelall":1,"api/v1/contract_tpsl_openorders":1,"api/v1/contract_tpsl_hisorders":1,"api/v1/contract_relation_tpsl_order":1,"api/v1/contract_track_order":1,"api/v1/contract_track_cancel":1,"api/v1/contract_track_cancelall":1,"api/v1/contract_track_openorders":1,"api/v1/contract_track_hisorders":1,"swap-api/v1/swap_balance_valuation":1,"swap-api/v1/swap_account_info":1,"swap-api/v1/swap_position_info":1,"swap-api/v1/swap_account_position_info":1,"swap-api/v1/swap_sub_auth":1,"swap-api/v1/swap_sub_account_list":1,"swap-api/v1/swap_sub_account_info_list":1,"swap-api/v1/swap_sub_account_info":1,"swap-api/v1/swap_sub_position_info":1,"swap-api/v1/swap_financial_record":1,"swap-api/v1/swap_financial_record_exact":1,"swap-api/v1/swap_user_settlement_records":1,"swap-api/v1/swap_available_level_rate":1,"swap-api/v1/swap_order_limit":1,"swap-api/v1/swap_fee":1,"swap-api/v1/swap_transfer_limit":1,"swap-api/v1/swap_position_limit":1,"swap-api/v1/swap_master_sub_transfer":1,"swap-api/v1/swap_master_sub_transfer_record":1,"swap-api/v3/swap_financial_record":1,"swap-api/v3/swap_financial_record_exact":1,"swap-api/v1/swap_order":1,"swap-api/v1/swap_batchorder":1,"swap-api/v1/swap_cancel":1,"swap-api/v1/swap_cancelall":1,"swap-api/v1/swap_lightning_close_position":1,"swap-api/v1/swap_switch_lever_rate":1,"swap-api/v1/swap_order_info":1,"swap-api/v1/swap_order_detail":1,"swap-api/v1/swap_openorders":1,"swap-api/v1/swap_hisorders":1,"swap-api/v1/swap_hisorders_exact":1,"swap-api/v1/swap_matchresults":1,"swap-api/v1/swap_matchresults_exact":1,"swap-api/v3/swap_matchresults":1,"swap-api/v3/swap_matchresults_exact":1,"swap-api/v3/swap_hisorders":1,"swap-api/v3/swap_hisorders_exact":1,"swap-api/v1/swap_trigger_order":1,"swap-api/v1/swap_trigger_cancel":1,"swap-api/v1/swap_trigger_cancelall":1,"swap-api/v1/swap_trigger_openorders":1,"swap-api/v1/swap_trigger_hisorders":1,"swap-api/v1/swap_tpsl_order":1,"swap-api/v1/swap_tpsl_cancel":1,"swap-api/v1/swap_tpsl_cancelall":1,"swap-api/v1/swap_tpsl_openorders":1,"swap-api/v1/swap_tpsl_hisorders":1,"swap-api/v1/swap_relation_tpsl_order":1,"swap-api/v1/swap_track_order":1,"swap-api/v1/swap_track_cancel":1,"swap-api/v1/swap_track_cancelall":1,"swap-api/v1/swap_track_openorders":1,"swap-api/v1/swap_track_hisorders":1,"linear-swap-api/v1/swap_lever_position_limit":1,"linear-swap-api/v1/swap_cross_lever_position_limit":1,"linear-swap-api/v1/swap_balance_valuation":1,"linear-swap-api/v1/swap_account_info":1,"linear-swap-api/v1/swap_cross_account_info":1,"linear-swap-api/v1/swap_position_info":1,"linear-swap-api/v1/swap_cross_position_info":1,"linear-swap-api/v1/swap_account_position_info":1,"linear-swap-api/v1/swap_cross_account_position_info":1,"linear-swap-api/v1/swap_sub_auth":1,"linear-swap-api/v1/swap_sub_account_list":1,"linear-swap-api/v1/swap_cross_sub_account_list":1,"linear-swap-api/v1/swap_sub_account_info_list":1,"linear-swap-api/v1/swap_cross_sub_account_info_list":1,"linear-swap-api/v1/swap_sub_account_info":1,"linear-swap-api/v1/swap_cross_sub_account_info":1,"linear-swap-api/v1/swap_sub_position_info":1,"linear-swap-api/v1/swap_cross_sub_position_info":1,"linear-swap-api/v1/swap_financial_record":1,"linear-swap-api/v1/swap_financial_record_exact":1,"linear-swap-api/v1/swap_user_settlement_records":1,"linear-swap-api/v1/swap_cross_user_settlement_records":1,"linear-swap-api/v1/swap_available_level_rate":1,"linear-swap-api/v1/swap_cross_available_level_rate":1,"linear-swap-api/v1/swap_order_limit":1,"linear-swap-api/v1/swap_fee":1,"linear-swap-api/v1/swap_transfer_limit":1,"linear-swap-api/v1/swap_cross_transfer_limit":1,"linear-swap-api/v1/swap_position_limit":1,"linear-swap-api/v1/swap_cross_position_limit":1,"linear-swap-api/v1/swap_master_sub_transfer":1,"linear-swap-api/v1/swap_master_sub_transfer_record":1,"linear-swap-api/v1/swap_transfer_inner":1,"linear-swap-api/v3/swap_financial_record":1,"linear-swap-api/v3/swap_financial_record_exact":1,"linear-swap-api/v1/swap_order":1,"linear-swap-api/v1/swap_cross_order":1,"linear-swap-api/v1/swap_batchorder":1,"linear-swap-api/v1/swap_cross_batchorder":1,"linear-swap-api/v1/swap_cancel":1,"linear-swap-api/v1/swap_cross_cancel":1,"linear-swap-api/v1/swap_cancelall":1,"linear-swap-api/v1/swap_cross_cancelall":1,"linear-swap-api/v1/swap_switch_lever_rate":1,"linear-swap-api/v1/swap_cross_switch_lever_rate":1,"linear-swap-api/v1/swap_lightning_close_position":1,"linear-swap-api/v1/swap_cross_lightning_close_position":1,"linear-swap-api/v1/swap_order_info":1,"linear-swap-api/v1/swap_cross_order_info":1,"linear-swap-api/v1/swap_order_detail":1,"linear-swap-api/v1/swap_cross_order_detail":1,"linear-swap-api/v1/swap_openorders":1,"linear-swap-api/v1/swap_cross_openorders":1,"linear-swap-api/v1/swap_hisorders":1,"linear-swap-api/v1/swap_cross_hisorders":1,"linear-swap-api/v1/swap_hisorders_exact":1,"linear-swap-api/v1/swap_cross_hisorders_exact":1,"linear-swap-api/v1/swap_matchresults":1,"linear-swap-api/v1/swap_cross_matchresults":1,"linear-swap-api/v1/swap_matchresults_exact":1,"linear-swap-api/v1/swap_cross_matchresults_exact":1,"linear-swap-api/v1/swap_switch_position_mode":1,"linear-swap-api/v1/swap_cross_switch_position_mode":1,"linear-swap-api/v3/swap_matchresults":1,"linear-swap-api/v3/swap_cross_matchresults":1,"linear-swap-api/v3/swap_matchresults_exact":1,"linear-swap-api/v3/swap_cross_matchresults_exact":1,"linear-swap-api/v3/swap_hisorders":1,"linear-swap-api/v3/swap_cross_hisorders":1,"linear-swap-api/v3/swap_hisorders_exact":1,"linear-swap-api/v3/swap_cross_hisorders_exact":1,"linear-swap-api/v1/swap_trigger_order":1,"linear-swap-api/v1/swap_cross_trigger_order":1,"linear-swap-api/v1/swap_trigger_cancel":1,"linear-swap-api/v1/swap_cross_trigger_cancel":1,"linear-swap-api/v1/swap_trigger_cancelall":1,"linear-swap-api/v1/swap_cross_trigger_cancelall":1,"linear-swap-api/v1/swap_trigger_openorders":1,"linear-swap-api/v1/swap_cross_trigger_openorders":1,"linear-swap-api/v1/swap_trigger_hisorders":1,"linear-swap-api/v1/swap_cross_trigger_hisorders":1,"linear-swap-api/v1/swap_tpsl_order":1,"linear-swap-api/v1/swap_cross_tpsl_order":1,"linear-swap-api/v1/swap_tpsl_cancel":1,"linear-swap-api/v1/swap_cross_tpsl_cancel":1,"linear-swap-api/v1/swap_tpsl_cancelall":1,"linear-swap-api/v1/swap_cross_tpsl_cancelall":1,"linear-swap-api/v1/swap_tpsl_openorders":1,"linear-swap-api/v1/swap_cross_tpsl_openorders":1,"linear-swap-api/v1/swap_tpsl_hisorders":1,"linear-swap-api/v1/swap_cross_tpsl_hisorders":1,"linear-swap-api/v1/swap_relation_tpsl_order":1,"linear-swap-api/v1/swap_cross_relation_tpsl_order":1,"linear-swap-api/v1/swap_track_order":1,"linear-swap-api/v1/swap_cross_track_order":1,"linear-swap-api/v1/swap_track_cancel":1,"linear-swap-api/v1/swap_cross_track_cancel":1,"linear-swap-api/v1/swap_track_cancelall":1,"linear-swap-api/v1/swap_cross_track_cancelall":1,"linear-swap-api/v1/swap_track_openorders":1,"linear-swap-api/v1/swap_cross_track_openorders":1,"linear-swap-api/v1/swap_track_hisorders":1,"linear-swap-api/v1/swap_cross_track_hisorders":1}}}},fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},exceptions:{broad:{"contract is restricted of closing positions on API.  Please contact customer service":M0,maintain:M0},exact:{403:C0,1010:nv,1013:jr,1017:Hf,1034:Ts,1036:Ts,1039:Ts,1041:Ts,1047:Gf,1048:Gf,1051:Ts,1066:jr,1067:Ts,1094:Ts,1220:nv,1461:Ts,"bad-request":vi,"validation-format-error":vi,"validation-constraints-required":vi,"base-date-limit-error":vi,"api-not-support-temp-addr":sD,timeout:nD,"gateway-internal-error":av,"account-frozen-balance-insufficient-error":Gf,"invalid-amount":Ts,"order-limitorder-amount-min-error":Ts,"order-limitorder-amount-max-error":Ts,"order-marketorder-amount-min-error":Ts,"order-limitorder-price-min-error":Ts,"order-limitorder-price-max-error":Ts,"order-value-min-error":Ts,"order-invalid-price":Ts,"order-holding-limit-failed":Ts,"order-orderprice-precision-error":Ts,"order-etp-nav-price-max-error":Ts,"order-orderstate-error":Hf,"order-queryorder-invalid":Hf,"order-update-error":av,"api-signature-check-failed":C0,"api-signature-not-valid":C0,"base-record-invalid":Hf,"base-symbol-trade-disabled":jr,"base-symbol-error":jr,"system-maintenance":M0,"base-request-exceed-frequency-limit":iD,"invalid symbol":jr,"symbol trade not open now":jr,"require-symbol":jr,"invalid-address":vi,"base-currency-chain-error":vi,"dw-insufficient-balance":Gf}},precisionMode:aD,options:{fetchMarkets:{types:{spot:!0,future:{linear:!0,inverse:!0},swap:{linear:!0,inverse:!0}}},defaultType:"spot",defaultSubType:"linear",defaultNetwork:"ERC20",networks:{ETH:"erc20",TRX:"trc20",HRC20:"hrc20",HECO:"hrc20",HT:"hrc20",ALGO:"algo",OMNI:""},fetchOrdersByStatesMethod:"spot_private_get_v1_order_orders",createMarketBuyOrderRequiresPrice:!0,language:"en-US",broker:{id:"AA03022abc"},accountsByType:{spot:"pro",funding:"pro",future:"futures"},accountsById:{spot:"spot",margin:"margin",otc:"otc",point:"point","super-margin":"super-margin",investment:"investment",borrow:"borrow","grid-trading":"grid-trading","deposit-earning":"deposit-earning","otc-options":"otc-options"},marginAccounts:{cross:"super-margin",isolated:"margin"},typesByAccount:{pro:"spot",futures:"future"},spot:{stopOrderTypes:{"stop-limit":!0,"buy-stop-limit":!0,"sell-stop-limit":!0,"stop-limit-fok":!0,"buy-stop-limit-fok":!0,"sell-stop-limit-fok":!0},limitOrderTypes:{limit:!0,"buy-limit":!0,"sell-limit":!0,ioc:!0,"buy-ioc":!0,"sell-ioc":!0,"limit-maker":!0,"buy-limit-maker":!0,"sell-limit-maker":!0,"stop-limit":!0,"buy-stop-limit":!0,"sell-stop-limit":!0,"limit-fok":!0,"buy-limit-fok":!0,"sell-limit-fok":!0,"stop-limit-fok":!0,"buy-stop-limit-fok":!0,"sell-stop-limit-fok":!0}}},commonCurrencies:{GET:"Themis",GTC:"Game.com",HIT:"HitChain",HOT:"Hydro Protocol",PNT:"Penta",SBTC:"Super Bitcoin",SOUL:"Soulsaver",BIFI:"Bitcoin File"}})}async fetchStatus(e={}){await this.loadMarkets();let t;[t,e]=this.handleMarketTypeAndParams("fetchMyTrades",void 0,e);let s="statusPublicSpotGetApiV2SummaryJson";if(t!=="spot"){const o=this.safeString(e,"subType",this.options.defaultSubType);t==="swap"?o==="linear"?s="statusPublicSwapLinearGetApiV2SummaryJson":o==="inverse"&&(s="statusPublicSwapInverseGetApiV2SummaryJson"):t==="future"?o==="linear"?s="statusPublicFutureLinearGetApiV2SummaryJson":o==="inverse"&&(s="statusPublicFutureInverseGetApiV2SummaryJson"):t==="contract"&&(s="contractPublicGetHeartbeat")}const i=await this[s]();let n,r,a;if(s==="contractPublicGetHeartbeat")n=this.safeString(i,"status")==="ok"?"ok":"maintenance",r=this.safeString(i,"ts");else{const o=this.safeValue(i,"status",{});n=this.safeString(o,"indicator")==="none"?"ok":"maintenance";const c=this.safeValue(i,"page",{}),u=this.safeString(c,"updated_at");r=this.parse8601(u),a=this.safeString(c,"url")}return{status:n,updated:r,eta:void 0,url:a,info:i}}async fetchTime(e={}){const t=this.safeValue(this.options,"fetchTime",{}),s=this.safeString(this.options,"defaultType","spot");let i=this.safeString(t,"type",s);i=this.safeString(e,"type",i);let n="spotPublicGetV1CommonTimestamp";(i==="future"||i==="swap")&&(n="contractPublicGetApiV1Timestamp");const r=await this[n](e);return this.safeInteger2(r,"data","ts")}parseTradingFee(e,t=void 0){const s=this.safeString(e,"symbol");return{info:e,symbol:this.safeSymbol(s,t),maker:this.safeNumber(e,"actualMakerRate"),taker:this.safeNumber(e,"actualTakerRate")}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbols:s.id},n=await this.spotPrivateGetV2ReferenceTransactFeeRate(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0,{});return this.parseTradingFee(a,s)}async fetchTradingLimits(e=void 0,t={}){await this.loadMarkets(),e===void 0&&(e=this.symbols);const s={};for(let i=0;i<e.length;i++){const n=e[i];s[n]=await this.fetchTradingLimitsById(this.marketId(n),t)}return s}async fetchTradingLimitsById(e,t={}){const s={symbol:e},i=await this.spotPublicGetV1CommonExchange(this.extend(s,t));return this.parseTradingLimits(this.safeValue(i,"data",{}))}parseTradingLimits(e,t=void 0,s={}){return{info:e,limits:{amount:{min:this.safeNumber(e,"limit-order-must-greater-than"),max:this.safeNumber(e,"limit-order-must-less-than")}}}}costToPrecision(e,t){return this.decimalToPrecision(t,oD,this.markets[e].precision.cost,this.precisionMode)}async fetchMarkets(e={}){const t=this.safeValue(this.options,"fetchMarkets",{}),s=this.safeValue(t,"types",{});let i=[],n=[];const r=Object.keys(s);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeValue(s,o);if(d===!0)n.push(this.fetchMarketsByTypeAndSubType(o,void 0,e));else{const c=Object.keys(d);for(let u=0;u<c.length;u++){const h=c[u];this.safeValue(d,h)&&n.push(this.fetchMarketsByTypeAndSubType(o,h,e))}}}n=await Promise.all(n);for(let a=0;a<n.length;a++)i=this.arrayConcat(i,n[a]);return i}async fetchMarketsByTypeAndSubType(e,t,s={}){let i="spotPublicGetV1CommonSymbols";const n=this.omit(s,["type","subType"]),r=e==="spot",a=e!=="spot",o=e==="future",d=e==="swap";let c,u;const h={};a&&(c=t==="linear",u=t==="inverse",c?(i="contractPublicGetLinearSwapApiV1SwapContractInfo",o&&(h.business_type="futures")):u&&(o?i="contractPublicGetApiV1ContractContractInfo":d&&(i="contractPublicGetSwapApiV1SwapContractInfo")));const l=await this[i](this.extend(h,n)),p=this.safeValue(l,"data",[]);if(p.length<1)throw new rD(this.id+" fetchMarkets() returned an empty response: "+this.json(p));const g=[];for(let y=0;y<p.length;y++){const b=p[y];let w,S,k,T,I,_;if(a){if(T=this.safeString(b,"contract_code"),I=T.toLowerCase(),d){const xe=T.split("-");w=this.safeString(b,"symbol"),_=w.toLowerCase(),S=this.safeStringLower(xe,1),k=u?w:S}else if(o)if(w=this.safeString(b,"symbol"),_=w.toLowerCase(),u)S="USD",k=w;else{const Ae=this.safeString(b,"pair").split("-");S=this.safeString(Ae,1),k=S}}else w=this.safeString(b,"base-currency"),_=w.toLowerCase(),S=this.safeString(b,"quote-currency"),T=w+S,I=T.toLowerCase();const N=this.safeCurrencyCode(w),M=this.safeCurrencyCode(S),x=this.safeCurrencyCode(k);let v=N+"/"+M,O;a&&(u?v+=":"+N:c&&(v+=":"+M),o&&(O=this.safeInteger(b,"delivery_time"),v+="-"+this.yymmdd(O)));const A=this.safeNumber(b,"contract_size");let V=this.safeNumber(b,"min-order-value");const q=this.safeNumber(b,"max-order-amt");let R=this.safeNumber(b,"min-order-amt");a&&(c?R=A:u&&(V=A));let H,F,P;r?(H=this.parseNumber(this.parsePrecision(this.safeString(b,"price-precision"))),F=this.parseNumber(this.parsePrecision(this.safeString(b,"amount-precision"))),P=this.parseNumber(this.parsePrecision(this.safeString(b,"value-precision")))):(H=this.safeNumber(b,"price_tick"),F=this.parseNumber("1"));let E,j;r&&(E=N==="OMG"?this.parseNumber("0"):this.parseNumber("0.002"),j=N==="OMG"?this.parseNumber("0"):this.parseNumber("0.002"));let X;r?X=this.safeString(b,"state")==="online":a&&(X=this.safeInteger(b,"contract_status")===1);const Q=this.safeString(b,"leverage-ratio","1"),Se=this.safeString(b,"super-margin-leverage-ratio","1"),he=ai.stringGt(Q,"1")||ai.stringGt(Se,"1");g.push({id:T,lowercaseId:I,symbol:v,base:N,quote:M,settle:x,baseId:w,lowercaseBaseId:_,quoteId:S,settleId:k,type:e,spot:r,margin:r&&he,swap:d,future:o,option:!1,active:X,contract:a,linear:c,inverse:u,taker:j,maker:E,contractSize:A,expiry:O,expiryDatetime:this.iso8601(O),strike:void 0,optionType:void 0,precision:{amount:F,price:H,cost:P},limits:{leverage:{min:this.parseNumber("1"),max:this.parseNumber(Q),superMax:this.parseNumber(Se)},amount:{min:R,max:q},price:{min:void 0,max:void 0},cost:{min:V,max:void 0}},info:b})}return g}parseTicker(e,t=void 0){const s=this.safeString2(e,"symbol","contract_code"),i=this.safeSymbol(s,t),n=this.safeInteger(e,"ts");let r,a,o,d;"bid"in e&&(Array.isArray(e.bid)?(r=this.safeString(e.bid,0),a=this.safeString(e.bid,1)):(r=this.safeString(e,"bid"),a=this.safeString(e,"bidSize"))),"ask"in e&&(Array.isArray(e.ask)?(o=this.safeString(e.ask,0),d=this.safeString(e.ask,1)):(o=this.safeString(e,"ask"),d=this.safeString(e,"askSize")));const c=this.safeString(e,"open"),u=this.safeString(e,"close"),h=this.safeString(e,"amount"),l=this.safeString(e,"vol");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:r,bidVolume:a,ask:o,askVolume:d,vwap:void 0,open:c,close:u,last:u,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:h,quoteVolume:l,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={};let n="symbol",r="spotPublicGetMarketDetailMerged";s.linear?(r="contractPublicGetLinearSwapExMarketDetailMerged",n="contract_code"):s.inverse&&(s.future?r="contractPublicGetMarketDetailMerged":s.swap&&(r="contractPublicGetSwapExMarketDetailMerged",n="contract_code")),i[n]=s.id;const a=await this[r](this.extend(i,t)),o=this.safeValue(a,"tick",{}),d=this.parseTicker(o,s),c=this.safeInteger(a,"ts");return d.timestamp=c,d.datetime=this.iso8601(c),d}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeString(e,0);let i;s!==void 0&&(i=this.market(s));let n,r,a="spotPublicGetMarketTickers";[n,t]=this.handleMarketTypeAndParams("fetchTickers",i,t),[r,t]=this.handleSubTypeAndParams("fetchTickers",i,t);const o={},d=n==="future",c=n==="swap",u=r==="linear";(d||c)&&(u?(a="contractPublicGetLinearSwapExMarketDetailBatchMerged",d&&(o.business_type="futures")):r==="inverse"&&(d?a="contractPublicGetMarketDetailBatchMerged":c&&(a="contractPublicGetSwapExMarketDetailBatchMerged"))),t=this.omit(t,["type","subType"]);const l=await this[a](this.extend(o,t)),p=this.safeValue2(l,"data","ticks",[]),m=this.safeInteger(l,"ts"),g={};for(let y=0;y<p.length;y++){const b=this.parseTicker(p[y]);if(d&&u)for(let S=0;S<this.symbols.length;S++){const k=this.symbols[S],T=this.market(k),I=this.safeString(T.info,"contract_type");if(I==="this_week"&&b.symbol===T.baseId+"-"+T.quoteId+"-CW"){b.symbol=T.symbol;break}else if(I==="next_week"&&b.symbol===T.baseId+"-"+T.quoteId+"-NW"){b.symbol=T.symbol;break}else if(I==="this_quarter"&&b.symbol===T.baseId+"-"+T.quoteId+"-CQ"){b.symbol=T.symbol;break}else if(I==="next_quarter"&&b.symbol===T.baseId+"-"+T.quoteId+"-NQ"){b.symbol=T.symbol;break}}const w=b.symbol;b.timestamp=m,b.datetime=this.iso8601(m),g[w]=b}return this.filterByArray(g,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={type:"step0"};let r="symbol",a="spotPublicGetMarketDepth";if(i.linear)a="contractPublicGetLinearSwapExMarketDepth",r="contract_code";else if(i.inverse)i.future?a="contractPublicGetMarketDepth":i.swap&&(a="contractPublicGetSwapExMarketDepth",r="contract_code");else if(t!==void 0){if(t!==5&&t!==10&&t!==20&&t!==150)throw new vi(this.id+" fetchOrderBook() limit argument must be undefined, 5, 10, 20, or 150, default is 150");t!==150&&(n.depth=t)}n[r]=i.id;const o=await this[a](this.extend(n,s));if("tick"in o){if(!o.tick)throw new jr(this.id+" fetchOrderBook() returned empty response: "+this.json(o));const d=this.safeValue(o,"tick"),c=this.safeInteger(d,"ts",this.safeInteger(o,"ts")),u=this.parseOrderBook(d,e,c);return u.nonce=this.safeInteger(d,"version"),u}throw new rv(this.id+" fetchOrderBook() returned unrecognized response: "+this.json(o))}parseTrade(e,t=void 0){const s=this.safeString2(e,"contract_code","symbol");t=this.safeMarket(s,t);const i=t.symbol;let n=this.safeInteger2(e,"ts","created-at");n=this.safeInteger2(e,"created_at","create_date",n);const r=this.safeString2(e,"order-id","order_id");let a=this.safeString(e,"direction"),o=this.safeString(e,"type");if(o!==void 0){const S=o.split("-");a=S[0],o=S[1]}const d=this.safeStringLower(e,"role"),c=this.safeString2(e,"price","trade_price");let u=this.safeString2(e,"filled-amount","amount");u=this.safeString(e,"trade_volume",u);const h=this.safeString(e,"trade_turnover");let l,p=this.safeString2(e,"filled-fees","trade_fee");const m=this.safeString2(e,"fee-currency","fee_asset");let g=this.safeCurrencyCode(m);const y=this.safeString(e,"filled-points");if(y!==void 0&&(p===void 0||ai.stringEquals(p,"0"))){const S=this.safeString(e,"fee-deduct-currency");S!==void 0&&(p=y,g=this.safeCurrencyCode(S))}p!==void 0&&(l={cost:p,currency:g});const b=this.safeString2(e,"trade-id","tradeId"),w=this.safeString2(e,"trade_id","id",b);return this.safeTrade({id:w,info:e,order:r,timestamp:n,datetime:this.iso8601(n),symbol:i,type:o,side:a,takerOrMaker:d,price:c,amount:u,cost:h,fee:l},t)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){let r;t!==void 0&&(r=this.market(t));let a;[a,n]=this.handleMarketTypeAndParams("fetchOrderTrades",r,n);const o=this.getSupportedMapping(a,{spot:"fetchSpotOrderTrades"});return await this[o](e,t,s,i,n)}async fetchSpotOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={"order-id":e},a=await this.spotPrivateGetV1OrderOrdersOrderIdMatchresults(this.extend(r,n));return this.parseTrades(a.data,void 0,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));let r;[r,i]=this.handleMarketTypeAndParams("fetchMyTrades",n,i);const a={};let o;if(r==="spot")e!==void 0&&(n=this.market(e),a.symbol=n.id),s!==void 0&&(a.size=s),t!==void 0&&(a["start-time"]=t),o="spotPrivateGetV1OrderMatchresults";else{if(e===void 0)throw new Ds(this.id+" fetchMyTrades() requires a symbol for "+r+" orders");if(a.contract=n.id,a.trade_type=0,t!==void 0&&(a.start_time=t),s!==void 0&&(a.page_size=s),n.linear){let u;[u,i]=this.handleMarginModeAndParams("fetchMyTrades",i),u=u===void 0?"cross":u,u==="isolated"?o="contractPrivatePostLinearSwapApiV3SwapMatchresultsExact":u==="cross"&&(o="contractPrivatePostLinearSwapApiV3SwapCrossMatchresultsExact")}else if(n.inverse)if(r==="future")o="contractPrivatePostApiV3ContractMatchresultsExact",a.symbol=n.settleId;else if(r==="swap")o="contractPrivatePostSwapApiV3SwapMatchresultsExact";else throw new Ti(this.id+" fetchMyTrades() does not support "+r+" markets")}const d=await this[o](this.extend(a,i));let c=this.safeValue(d,"data");return Array.isArray(c)||(c=this.safeValue(c,"trades")),this.parseTrades(c,n,t,s)}async fetchTrades(e,t=void 0,s=1e3,i={}){await this.loadMarkets();const n=this.market(e),r={};let a="symbol",o="spotPublicGetMarketHistoryTrade";n.future?n.inverse?o="contractPublicGetMarketHistoryTrade":n.linear&&(o="contractPublicGetLinearSwapExMarketHistoryTrade",a="contract_code"):n.swap&&(n.inverse?o="contractPublicGetSwapExMarketHistoryTrade":n.linear&&(o="contractPublicGetLinearSwapExMarketHistoryTrade"),a="contract_code"),r[a]=n.id,s!==void 0&&(r.size=s);const d=await this[o](this.extend(r,i)),c=this.safeValue(d,"data",[]);let u=[];for(let h=0;h<c.length;h++){const l=this.safeValue(c[h],"data",[]);for(let p=0;p<l.length;p++){const m=this.parseTrade(l[p],n);u.push(m)}}return u=this.sortBy(u,"timestamp"),this.filterBySymbolSinceLimit(u,n.symbol,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"id"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"amount")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={period:this.timeframes[t]};let o="symbol";const d=this.safeString(n,"price");n=this.omit(n,"price");let c="spotPublicGetMarketHistoryCandles";if(r.spot)s!==void 0&&(a.from=parseInt(s/1e3)),i!==void 0&&(a.size=i);else if(r.future){if(r.inverse)if(d==="mark")c="contractPublicGetIndexMarketHistoryMarkPriceKline";else if(d==="index")c="contractPublicGetIndexMarketHistoryIndex";else{if(d==="premiumIndex")throw new vi(this.id+" "+r.type+" has no api endpoint for "+d+" kline data");c="contractPublicGetMarketHistoryKline"}else if(r.linear){if(d==="mark")c="contractPublicGetIndexMarketHistoryLinearSwapMarkPriceKline";else{if(d==="index")throw new vi(this.id+" "+r.type+" has no api endpoint for "+d+" kline data");d==="premiumIndex"?c="contractPublicGetIndexMarketHistoryLinearSwapPremiumIndexKline":c="contractPublicGetLinearSwapExMarketHistoryKline"}o="contract_code"}}else if(r.swap){if(r.inverse)if(d==="mark")c="contractPublicGetIndexMarketHistorySwapMarkPriceKline";else{if(d==="index")throw new vi(this.id+" "+r.type+" has no api endpoint for "+d+" kline data");d==="premiumIndex"?c="contractPublicGetIndexMarketHistorySwapPremiumIndexKline":c="contractPublicGetSwapExMarketHistoryKline"}else if(r.linear)if(d==="mark")c="contractPublicGetIndexMarketHistoryLinearSwapMarkPriceKline";else{if(d==="index")throw new vi(this.id+" "+r.type+" has no api endpoint for "+d+" kline data");d==="premiumIndex"?c="contractPublicGetIndexMarketHistoryLinearSwapPremiumIndexKline":c="contractPublicGetLinearSwapExMarketHistoryKline"}o="contract_code"}if(r.contract&&(i===void 0&&(i=2e3),a.size=i,d===void 0)){const l=this.parseTimeframe(t);if(s===void 0){const p=this.seconds();a.from=p-l*(i-1),a.to=p}else{const p=parseInt(s/1e3);a.from=p,a.to=this.sum(p,l*(i-1))}}a[o]=r.id;const u=await this[c](this.extend(a,n)),h=this.safeValue(u,"data",[]);return this.parseOHLCVs(h,r,t,s,i)}async fetchAccounts(e={}){await this.loadMarkets();const t=await this.spotPrivateGetV1AccountAccounts(e),s=this.safeValue(t,"data");return this.parseAccounts(s)}parseAccount(e){const t=this.safeString(e,"type"),s=this.safeValue(this.options,"accountsById",{}),i=this.safeValue(s,t,t);return{info:e,id:this.safeString(e,"id"),type:i,code:void 0}}async fetchAccountIdByType(e,t={}){const s=await this.loadAccounts(),i=this.safeValue(t,"account-id");if(i!==void 0)return i;const n=this.indexBy(s,"type"),r=this.safeValue(s,0,{}),a=this.safeValue(n,e,r);return this.safeString(a,"id")}async fetchCurrencies(e={}){const t=await this.spotPublicGetV2ReferenceCurrencies(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.safeValue(r,"chains",[]),c={},h=this.safeString(r,"instStatus")==="normal";let l,p,m,g,y,b;for(let k=0;k<d.length;k++){const T=d[k],I=this.safeString(T,"chain");let _=this.safeString(T,"baseChainProtocol");const N="h"+a;_===void 0&&(N===I?_="ERC20":_=this.safeString(T,"displayName"));const M=this.safeNetwork(_);m=this.safeNumber(T,"minWithdrawAmt"),g=this.safeNumber(T,"maxWithdrawAmt");const x=this.safeString(T,"withdrawStatus"),v=this.safeString(T,"depositStatus"),O=x==="allowed",A=v==="allowed",V=O&&A,q=this.parsePrecision(this.safeString(T,"withdrawPrecision"));q!==void 0&&(p=p===void 0?q:ai.stringMin(q,p)),O&&!b?b=!0:O||(b=!1),A&&!y?y=!0:A||(y=!1),l=this.safeNumber(T,"transactFeeWithdraw"),c[M]={info:T,id:I,network:M,limits:{withdraw:{min:m,max:g}},active:V,deposit:A,withdraw:O,fee:l,precision:this.parseNumber(q)}}const S=Object.keys(c).length;i[o]={info:r,code:o,id:a,active:h,deposit:y,withdraw:b,fee:S<=1?l:void 0,name:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:S<=1?m:void 0,max:S<=1?g:void 0}},precision:this.parseNumber(p),networks:c}}return i}async fetchBalance(e={}){await this.loadMarkets();let t;[t,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e);const s=this.safeValue(this.options,"fetchBalance",{}),i={};let n;const r=t==="margin",a=t==="spot",o=t==="future",d=t==="swap",c=this.safeString2(this.options,"defaultSubType","subType","linear");let u=this.safeString2(s,"defaultSubType","subType",c);u=this.safeString2(e,"defaultSubType","subType",u);const h=u==="inverse",l=u==="linear";let p;[p,e]=this.handleMarginModeAndParams("fetchBalance",e),e=this.omit(e,["defaultSubType","subType"]);const m=p==="isolated",g=p==="cross";if(a)if(m)n="spotPrivateGetV1MarginAccountsBalance";else if(g)n="spotPrivateGetV1CrossMarginAccountsBalance";else{await this.loadAccounts();const k=await this.fetchAccountIdByType(t,e);i["account-id"]=k,n="spotPrivateGetV1AccountAccountsAccountIdBalance"}else r?m?n="spotPrivateGetV1MarginAccountsBalance":n="spotPrivateGetV1CrossMarginAccountsBalance":l?m?n="contractPrivatePostLinearSwapApiV1SwapAccountInfo":n="contractPrivatePostLinearSwapApiV1SwapCrossAccountInfo":h&&(o?n="contractPrivatePostApiV1ContractAccountInfo":d&&(n="contractPrivatePostSwapApiV1SwapAccountInfo"));const y=await this[n](this.extend(i,e)),b={info:y},w=this.safeValue(y,"data");if(a||r)if(m)for(let k=0;k<w.length;k++){const T=w[k],I=this.safeSymbol(this.safeString(T,"symbol")),_=this.safeValue(T,"list"),N={};for(let M=0;M<_.length;M++){const x=_[M],v=this.safeString(x,"currency"),O=this.safeCurrencyCode(v);N[O]=this.parseMarginBalanceHelper(x,O,N)}b[I]=this.safeBalance(N)}else{const k=this.safeValue(w,"list",[]);for(let T=0;T<k.length;T++){const I=k[T],_=this.safeString(I,"currency"),N=this.safeCurrencyCode(_);b[N]=this.parseMarginBalanceHelper(I,N,b)}}else if(l){const k=this.safeValue(w,0,{});if(g){const T=this.account();T.free=this.safeString(k,"margin_balance","margin_available"),T.used=this.safeString(k,"margin_frozen");const I=this.safeString2(k,"margin_asset","symbol"),_=this.safeCurrencyCode(I);b[_]=T}else if(m){for(let T=0;T<w.length;T++){const I=w[T],_=this.safeString2(I,"contract_code","margin_account"),N=this.safeMarket(_),M=this.safeString(I,"margin_asset"),x=this.safeCurrency(M),v=this.safeString(N,"settle",x.code);if(v!==void 0){const O=this.account();O.free=this.safeString(I,"margin_balance"),O.used=this.safeString(I,"margin_frozen");const A={};A[v]=O;const V=N.symbol;b[V]=this.safeBalance(A)}}return b}}else if(h)for(let k=0;k<w.length;k++){const T=w[k],I=this.safeString(T,"symbol"),_=this.safeCurrencyCode(I),N=this.account();N.free=this.safeString(T,"margin_available"),N.used=this.safeString(T,"margin_frozen"),b[_]=N}return m&&(a||r)?b:this.safeBalance(b)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));let n;[n,s]=this.handleMarketTypeAndParams("fetchOrder",i,s);const r={};let a;if(n==="spot"){const c=this.safeString(s,"clientOrderId");a="spotPrivateGetV1OrderOrdersOrderId",c!==void 0?a="spotPrivateGetV1OrderOrdersGetClientOrder":r["order-id"]=e}else{if(t===void 0)throw new Ds(this.id+" fetchOrder() requires a symbol for "+n+" orders");if(r.contract_code=i.id,i.linear){let u;[u,s]=this.handleMarginModeAndParams("fetchOrder",s),u=u===void 0?"cross":u,u==="isolated"?a="contractPrivatePostLinearSwapApiV1SwapOrderInfo":u==="cross"&&(a="contractPrivatePostLinearSwapApiV1SwapCrossOrderInfo")}else if(i.inverse)if(n==="future")a="contractPrivatePostApiV1ContractOrderInfo",r.symbol=i.settleId;else if(n==="swap")a="contractPrivatePostSwapApiV1SwapOrderInfo";else throw new Ti(this.id+" fetchOrder() does not support "+n+" markets");const c=this.safeString2(s,"client_order_id","clientOrderId");c===void 0?r.order_id=e:(r.client_order_id=c,s=this.omit(s,["client_order_id","clientOrderId"]))}const o=await this[a](this.extend(r,s));let d=this.safeValue(o,"data");return Array.isArray(d)&&(d=this.safeValue(d,0)),this.parseOrder(d)}parseMarginBalanceHelper(e,t,s){let i;return t in s?i=s[t]:i=this.account(),e.type==="trade"&&(i.free=this.safeString(e,"balance")),e.type==="frozen"&&(i.used=this.safeString(e,"balance")),i}async fetchSpotOrdersByStates(e,t=void 0,s=void 0,i=void 0,n={}){const r=this.safeString(this.options,"fetchOrdersByStatesMethod","spot_private_get_v1_order_orders");if(r==="spot_private_get_v1_order_orders"&&t===void 0)throw new Ds(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();let a;const o={states:e};t!==void 0&&(a=this.market(t),o.symbol=a.id),s!==void 0&&(o["start-time"]=s,o["end-time"]=this.sum(s,48*60*60*1e3)),i!==void 0&&(o.size=i);const d=await this[r](this.extend(o,n)),c=this.safeValue(d,"data",[]);return this.parseOrders(c,a,s,i)}async fetchSpotOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchSpotOrdersByStates("pre-submitted,submitted,partial-filled,filled,partial-canceled,canceled",e,t,s,i)}async fetchClosedSpotOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchSpotOrdersByStates("filled,partial-canceled,canceled",e,t,s,i)}async fetchContractOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Ds(this.id+" fetchContractOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e);let r;[r,i]=this.handleMarketTypeAndParams("fetchOrders",n,i);const a={contract:n.id,trade_type:0,type:1,status:"0"};t!==void 0&&(a.start_time=t);let o;if(n.linear){let u;[u,i]=this.handleMarginModeAndParams("fetchContractOrders",i),u=u===void 0?"cross":u,o=this.getSupportedMapping(u,{isolated:"contractPrivatePostLinearSwapApiV3SwapHisorders",cross:"contractPrivatePostLinearSwapApiV3SwapCrossHisorders"})}else n.inverse&&(o=this.getSupportedMapping(r,{future:"contractPrivatePostApiV3ContractHisorders",swap:"contractPrivatePostSwapApiV3SwapHisorders"}),r==="future"&&(a.symbol=n.settleId));s!==void 0&&(a.page_size=s);const d=await this[o](this.extend(a,i)),c=this.safeValue(d,"data",[]);return this.parseOrders(c,n,t,s)}async fetchClosedContractOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"5,6,7"};return await this.fetchContractOrders(e,t,s,this.extend(n,i))}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));let r;[r,i]=this.handleMarketTypeAndParams("fetchOrders",n,i);const a=this.getSupportedMapping(r,{spot:"fetchSpotOrders",swap:"fetchContractOrders",future:"fetchContractOrders"});if(a===void 0)throw new Ti(this.id+" fetchOrders() does not support "+r+" markets yet");if((r==="swap"||r==="future")&&e===void 0)throw new Ds(this.id+" fetchOrders() requires a symbol argument for "+r+" orders");return await this[a](e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));let r;[r,i]=this.handleMarketTypeAndParams("fetchClosedOrders",n,i);const a=this.getSupportedMapping(r,{spot:"fetchClosedSpotOrders",swap:"fetchClosedContractOrders",future:"fetchClosedContractOrders"});if(a===void 0)throw new Ti(this.id+" fetchClosedOrders() does not support "+r+" markets yet");return await this[a](e,t,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));let r;[r,i]=this.handleMarketTypeAndParams("fetchOpenOrders",n,i);const a={};let o;if(r==="spot"){o="spotPrivateGetV1OrderOpenOrders",e!==void 0&&(n=this.market(e),a.symbol=n.id);let u=this.safeString(i,"account-id");if(u===void 0){await this.loadAccounts();for(let h=0;h<this.accounts.length;h++){const l=this.accounts[h];if(l.type==="spot"&&(u=this.safeString(l,"id"),u!==void 0))break}}a["account-id"]=u,s!==void 0&&(a.size=s),i=this.omit(i,"account-id")}else{if(e===void 0)throw new Ds(this.id+" fetchOpenOrders() requires a symbol for "+r+" orders");const u=this.market(e);if(a.contract_code=u.id,u.linear){let h;[h,i]=this.handleMarginModeAndParams("fetchOpenOrders",i),h=h===void 0?"cross":h,h==="isolated"?o="contractPrivatePostLinearSwapApiV1SwapOpenorders":h==="cross"&&(o="contractPrivatePostLinearSwapApiV1SwapCrossOpenorders")}else u.inverse&&(u.future?(o="contractPrivatePostApiV1ContractOpenorders",a.symbol=u.settleId):u.swap&&(o="contractPrivatePostSwapApiV1SwapOpenorders"));s!==void 0&&(a.page_size=s)}const d=await this[o](this.extend(a,i));let c=this.safeValue(d,"data");return Array.isArray(c)||(c=this.safeValue(c,"orders",[])),this.parseOrders(c,n,t,s)}parseOrderStatus(e){const t={"partial-filled":"open","partial-canceled":"canceled",filled:"closed",canceled:"canceled",submitted:"open",created:"open",1:"open",2:"open",3:"open",4:"open",5:"canceled",6:"closed",7:"canceled",11:"canceling"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString2(e,"id","order_id_str");let i=this.safeString(e,"direction"),n=this.safeString(e,"order_price_type");if("type"in e){const w=e.type.split("-");i=w[0],n=w[1]}const r=this.parseOrderStatus(this.safeString2(e,"state","status")),a=this.safeString2(e,"contract_code","symbol");t=this.safeMarket(a,t);const o=this.safeIntegerN(e,["created_at","created-at","create_date"]),d=this.safeString2(e,"client_order_id","client-order-id");let c,u;n!==void 0&&n.indexOf("market")>=0?i==="sell"?c=this.safeString(e,"field-cash-amount"):c=this.safeString(e,"amount"):(u=this.safeString2(e,"volume","amount"),c=this.safeStringN(e,["filled-cash-amount","field-cash-amount","trade_turnover"]));const h=this.safeStringN(e,["filled-amount","field-amount","trade_volume"]),l=this.safeString(e,"price");let p=this.safeString2(e,"filled-fees","field-fees");p=this.safeString(e,"fee",p);let m;if(p!==void 0){let w;const S=this.safeString(e,"fee_asset");S!==void 0?w=this.safeCurrencyCode(S):w=i==="sell"?t.quote:t.base,m={cost:p,currency:w}}const g=this.safeString(e,"stop-price"),y=this.safeString(e,"trade_avg_price"),b=this.safeValue(e,"trades");return this.safeOrder({info:e,id:s,clientOrderId:d,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:void 0,symbol:t.symbol,type:n,timeInForce:void 0,postOnly:void 0,side:i,price:l,stopPrice:g,average:y,cost:c,amount:u,filled:h,remaining:void 0,status:r,fee:m,trades:b},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),[o,d]=this.handleMarketTypeAndParams("createOrder",a,r),c=this.getSupportedMapping(o,{spot:"createSpotOrder",swap:"createContractOrder",future:"createContractOrder"});if(c===void 0)throw new Ti(this.id+" createOrder() does not support "+o+" markets yet");return await this[c](e,t,s,i,n,d)}async createSpotOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets(),await this.loadAccounts();const a=this.market(e),d={"account-id":await this.fetchAccountIdByType(a.type),symbol:a.id};let c=t.replace("buy-","");c=c.replace("sell-","");const u=this.safeValue(this.options,a.type,{}),h=this.safeString2(r,"stopPrice","stop-price");if(h===void 0){const b=this.safeValue(u,"stopOrderTypes",{});if(c in b)throw new Ds(this.id+" createOrder() requires a stopPrice or a stop-price parameter for a stop order")}else{const b=this.safeString(r,"operator");if(b===void 0)throw new Ds(this.id+' createOrder() requires an operator parameter "gte" or "lte" for a stop order');if(r=this.omit(r,["stopPrice","stop-price"]),d["stop-price"]=this.priceToPrecision(e,h),d.operator=b,c==="limit"||c==="limit-fok")c="stop-"+c;else if(c!=="stop-limit"&&c!=="stop-limit-fok")throw new Ti(this.id+" createOrder() does not support "+t+" orders")}this.safeValue(r,"postOnly",!1)&&(c="limit-maker"),d.type=s+"-"+c;const p=this.safeString2(r,"clientOrderId","client-order-id");if(p===void 0){const b=this.safeValue(this.options,"broker",{}),w=this.safeString(b,"id");d["client-order-id"]=w+this.uuid()}else d["client-order-id"]=p;if(r=this.omit(r,["clientOrderId","client-order-id","postOnly"]),c==="market"&&s==="buy")if(this.options.createMarketBuyOrderRequiresPrice){if(n===void 0)throw new Ts(this.id+" market buy order requires price argument to calculate cost (total amount of quote currency to spend for buying, amount * price). To switch off this warning exception and specify cost in the amount argument, set .options['createMarketBuyOrderRequiresPrice'] = false. Make sure you know what you're doing.");{const b=this.numberToString(i),w=this.numberToString(n);d.amount=this.costToPrecision(e,ai.stringMul(b,w))}}else d.amount=this.costToPrecision(e,i);else d.amount=this.amountToPrecision(e,i);const m=this.safeValue(u,"limitOrderTypes",{});c in m&&(d.price=this.priceToPrecision(e,n));const g=await this.spotPrivatePostV1OrderOrdersPlace(this.extend(d,r)),y=this.safeString(g,"data");return{info:g,id:y,timestamp:void 0,datetime:void 0,lastTradeTimestamp:void 0,status:void 0,symbol:void 0,type:void 0,side:void 0,price:void 0,amount:void 0,filled:void 0,remaining:void 0,cost:void 0,trades:void 0,fee:void 0,clientOrderId:void 0,average:void 0}}async createContractOrder(e,t,s,i,n=void 0,r={}){const a=this.safeString(r,"offset");if(this.safeString(r,"stopPrice")!==void 0)throw new Ti(this.id+" createOrder() supports tp_trigger_price + tp_order_price for take profit orders and/or sl_trigger_price + sl_order price for stop loss orders, stop orders are supported only with open long orders and open short orders");const d=this.market(e),c={contract_code:d.id,volume:this.amountToPrecision(e,i),direction:s,lever_rate:1},u=this.safeString(r,"sl_order_price"),h=this.safeString(r,"sl_trigger_price"),l=this.safeString(r,"tp_order_price"),p=this.safeString(r,"tp_trigger_price"),m=a==="open";let g=!1;if(h!==void 0&&(c.sl_trigger_price=this.priceToPrecision(e,h),g=!0,n!==void 0&&(c.sl_order_price=this.priceToPrecision(e,n))),u!==void 0&&(c.sl_order_price=this.priceToPrecision(e,u),g=!0),p!==void 0&&(c.tp_trigger_price=this.priceToPrecision(e,p),g=!0,n!==void 0&&(c.tp_order_price=this.priceToPrecision(e,n))),l!==void 0&&(c.tp_order_price=this.priceToPrecision(e,l),g=!0),g&&!m)throw new Ti(this.id+" createOrder() supports tp_trigger_price + tp_order_price for take profit orders and/or sl_trigger_price + sl_order price for stop loss orders, stop orders are supported only with open long orders and open short orders");r=this.omit(r,["sl_order_price","sl_trigger_price","tp_order_price","tp_trigger_price"]),this.safeValue(r,"postOnly",!1)&&(t="post_only"),(t==="limit"||t==="ioc"||t==="fok"||t==="post_only")&&(c.price=this.priceToPrecision(e,n)),c.order_price_type=t;const b=this.safeValue(this.options,"broker",{}),w=this.safeString(b,"id");c.channel_code=w;const S=this.safeString2(r,"client_order_id","clientOrderId");S!==void 0&&(c.client_order_id=S,r=this.omit(r,["client_order_id","clientOrderId"]));let k;if(d.linear){let _;[_,r]=this.handleMarginModeAndParams("createOrder",r),_=_===void 0?"cross":_,_==="isolated"?k="contractPrivatePostLinearSwapApiV1SwapOrder":_==="cross"&&(k="contractPrivatePostLinearSwapApiV1SwapCrossOrder")}else d.inverse&&(d.swap?k="contractPrivatePostSwapApiV1SwapOrder":d.future&&(k="contractPrivatePostApiV1ContractOrder"));const T=await this[k](this.extend(c,r)),I=this.safeValue(T,"data",{});return this.parseOrder(I,d)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));let n;[n,s]=this.handleMarketTypeAndParams("cancelOrder",i,s);const r={};let a;if(n==="spot"){const d=this.safeString2(s,"client-order-id","clientOrderId");a="spotPrivatePostV1OrderOrdersOrderIdSubmitcancel",d===void 0?r["order-id"]=e:(r["client-order-id"]=d,a="spotPrivatePostV1OrderOrdersSubmitCancelClientOrder",s=this.omit(s,["client-order-id","clientOrderId"]))}else{if(t===void 0)throw new Ds(this.id+" cancelOrder() requires a symbol for "+n+" orders");if(r.contract_code=i.id,i.linear){let c;[c,s]=this.handleMarginModeAndParams("cancelOrder",s),c=c===void 0?"cross":c,c==="isolated"?a="contractPrivatePostLinearSwapApiV1SwapCancel":c==="cross"&&(a="contractPrivatePostLinearSwapApiV1SwapCrossCancel")}else if(i.inverse)i.future?(a="contractPrivatePostApiV1ContractCancel",r.symbol=i.settleId):i.swap&&(a="contractPrivatePostSwapApiV1SwapCancel");else throw new Ti(this.id+" cancelOrder() does not support "+n+" markets");const d=this.safeString2(s,"client_order_id","clientOrderId");d===void 0?r.order_id=e:(r.client_order_id=d,s=this.omit(s,["client_order_id","clientOrderId"]))}const o=await this[a](this.extend(r,s));return this.extend(this.parseOrder(o,i),{id:e,status:"canceled"})}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));let n;[n,s]=this.handleMarketTypeAndParams("cancelOrders",i,s);const r={};let a;if(n==="spot"){let d=this.safeValue2(s,"client-order-id","clientOrderId");d=this.safeValue2(s,"client-order-ids","clientOrderIds",d),d===void 0?typeof d=="string"?r["order-ids"]=e:r["order-ids"]=e.join(","):(typeof d=="string"?r["client-order-ids"]=d:r["client-order-ids"]=d.join(","),s=this.omit(s,["client-order-id","client-order-ids","clientOrderId","clientOrderIds"])),a="spotPrivatePostV1OrderOrdersBatchcancel"}else{if(t===void 0)throw new Ds(this.id+" cancelOrders() requires a symbol for "+n+" orders");const d=this.market(t);if(r.contract_code=d.id,d.linear){let u;[u,s]=this.handleMarginModeAndParams("cancelOrders",s),u=u===void 0?"cross":u,u==="isolated"?a="contractPrivatePostLinearSwapApiV1SwapCancel":u==="cross"&&(a="contractPrivatePostLinearSwapApiV1SwapCrossCancel")}else if(d.inverse)if(d.future)a="contractPrivatePostApiV1ContractCancel",r.symbol=d.settleId;else if(d.swap)a="contractPrivatePostSwapApiV1SwapCancel";else throw new Ti(this.id+" cancelOrders() does not support "+n+" markets");let c=this.safeString2(s,"client_order_id","clientOrderId");c=this.safeString2(s,"client_order_ids","clientOrderIds",c),c===void 0?r.order_id=e.join(","):(r.client_order_id=c,s=this.omit(s,["client_order_id","client_order_ids","clientOrderId","clientOrderIds"]))}return await this[a](this.extend(r,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();let s;e!==void 0&&(s=this.market(e));let i;[i,t]=this.handleMarketTypeAndParams("cancelAllOrders",s,t);const n={};let r;if(i==="spot")e!==void 0&&(s=this.market(e),n.symbol=s.id),r="spotPrivatePostV1OrderOrdersBatchCancelOpenOrders";else{if(e===void 0)throw new Ds(this.id+" cancelAllOrders() requires a symbol for "+i+" orders");const o=this.market(e);if(n.contract_code=o.id,o.linear){let d;[d,t]=this.handleMarginModeAndParams("cancelAllOrders",t),d=d===void 0?"cross":d,d==="isolated"?r="contractPrivatePostLinearSwapApiV1SwapCancelallall":d==="cross"&&(r="contractPrivatePostLinearSwapApiV1SwapCrossCancelall")}else if(o.inverse)if(i==="future")r="contractPrivatePostApiV1ContractCancelall",n.symbol=o.settleId;else if(i==="swap")r="contractPrivatePostSwapApiV1SwapCancelall";else throw new Ti(this.id+" cancelAllOrders() does not support "+i+" markets")}return await this[r](this.extend(n,t))}safeNetwork(e){const t=e.length-1;e[t]==="1"&&(e=e.slice(0,t));const i={};return this.safeString(i,e,e)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"addressTag"),n=this.safeString(e,"currency");t=this.safeCurrency(n,t);const r=this.safeCurrencyCode(n,t),a=this.safeString(e,"chain"),o=this.safeValue(t,"networks",{}),d=this.indexBy(o,"id"),c=this.safeValue(d,a,a),u=this.safeStringUpper(c,"network"),h=this.safeString(e,"note");return this.checkAddress(s),{currency:r,address:s,tag:i,network:u,note:h,info:e}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.spotPrivateGetV2AccountDepositAddress(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.parseDepositAddresses(r,[e],!1);return this.indexBy(a,"network")}async fetchDepositAddress(e,t={}){const s=this.safeStringUpper(t,"network"),i=this.safeValue(this.options,"networks",{}),n=this.safeStringUpper(i,s,s);t=this.omit(t,"network");const r=await this.fetchDepositAddressesByNetwork(e,t);let a;if(n===void 0){if(a=this.safeValue(r,e),a===void 0){const o=this.safeString(i,e,e);if(a=this.safeValue(r,o),a===void 0){const d=this.safeString(this.options,"defaultNetwork","ERC20");if(a=this.safeValue(r,d),a===void 0){const c=Object.values(r);if(a=this.safeValue(c,0),a===void 0)throw new Uf(this.id+" fetchDepositAddress() cannot find deposit address for "+e)}}}return a}if(a=this.safeValue(r,n),a===void 0)throw new Uf(this.id+" fetchDepositAddress() cannot find "+n+" deposit address for "+e);return a}async fetchWithdrawAddressesByNetwork(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.spotPrivateGetV2AccountWithdrawAddress(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.parseDepositAddresses(r,[e],!1);return this.indexBy(a,"network")}async fetchWithdrawAddress(e,t={}){const s=this.safeStringUpper(t,"network"),i=this.safeValue(this.options,"networks",{}),n=this.safeStringUpper(i,s,s);t=this.omit(t,"network");const r=await this.fetchWithdrawAddressesByNetwork(e,t);let a;if(n===void 0){if(a=this.safeValue(r,e),a===void 0){const o=this.safeString(i,e,e);if(a=this.safeValue(r,o),a===void 0){const d=this.safeString(this.options,"defaultNetwork","ERC20");if(a=this.safeValue(r,d),a===void 0){const c=Object.values(r);if(a=this.safeValue(c,0),a===void 0)throw new Uf(this.id+" fetchWithdrawAddress() cannot find withdraw address for "+e)}}}return a}if(a=this.safeValue(r,n),a===void 0)throw new Uf(this.id+" fetchWithdrawAddress() cannot find "+n+" withdraw address for "+e);return a}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){(s===void 0||s>100)&&(s=100),await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r={type:"deposit",from:0};n!==void 0&&(r.currency=n.id),s!==void 0&&(r.size=s);const a=await this.spotPrivateGetV1QueryDepositWithdraw(this.extend(r,i));return this.parseTransactions(a.data,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){(s===void 0||s>100)&&(s=100),await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r={type:"withdraw",from:0};n!==void 0&&(r.currency=n.id),s!==void 0&&(r.size=s);const a=await this.spotPrivateGetV1QueryDepositWithdraw(this.extend(r,i));return this.parseTransactions(a.data,n,t,s)}parseTransaction(e,t=void 0){const s=this.safeInteger(e,"created-at"),i=this.safeCurrencyCode(this.safeString(e,"currency"));let n=this.safeString(e,"type");n==="withdraw"&&(n="withdrawal");let r=this.safeString(e,"fee");return r!==void 0&&(r=ai.stringAbs(r)),{info:e,id:this.safeString2(e,"id","data"),txid:this.safeString(e,"tx-hash"),timestamp:s,datetime:this.iso8601(s),network:this.safeStringUpper(e,"chain"),address:this.safeString(e,"address"),addressTo:void 0,addressFrom:void 0,tag:this.safeString(e,"address-tag"),tagTo:void 0,tagFrom:void 0,type:n,amount:this.safeNumber(e,"amount"),currency:i,status:this.parseTransactionStatus(this.safeString(e,"state")),updated:this.safeInteger(e,"updated-at"),fee:{currency:i,cost:this.parseNumber(r),rate:void 0}}}parseTransactionStatus(e){const t={unknown:"failed",confirming:"pending",confirmed:"ok",safe:"ok",orphan:"failed",submitted:"pending",canceled:"canceled",reexamine:"pending",reject:"failed",pass:"pending","wallet-reject":"failed","confirm-error":"failed",repealed:"failed","wallet-transfer":"pending","pre-transfer":"pending"};return this.safeString(t,e,e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets(),this.checkAddress(s);const r=this.currency(e),a={address:s,amount:t,currency:r.id.toLowerCase()};i!==void 0&&(a["addr-tag"]=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeStringLower(o,d,d),d!==void 0&&(d==="erc20"?a.chain=r.id+d:a.chain=d+r.id,n=this.omit(n,"network"));const c=await this.spotPrivatePostV1DwWithdrawApiCreate(this.extend(a,n));return this.parseTransaction(c,r)}parseTransfer(e,t=void 0){const s=this.safeString(e,"data"),i=this.safeCurrencyCode(void 0,t);return{info:e,id:s,timestamp:void 0,datetime:void 0,currency:i,amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0}}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e);let a=this.safeString(n,"type");if(a===void 0){const u=this.safeValue(this.options,"accountsByType",{});s=s.toLowerCase(),i=i.toLowerCase();const h=this.safeString(u,s,s),l=this.safeString(u,i,i);a=h+"-to-"+l}const o={currency:r.id,amount:parseFloat(this.currencyToPrecision(e,t)),type:a},d=await this.spotPrivatePostFuturesTransfer(this.extend(o,n)),c=this.parseTransfer(d,r);return this.extend(c,{amount:t,currency:e,fromAccount:s,toAccount:i})}async fetchBorrowRatesPerSymbol(e={}){await this.loadMarkets();const t=await this.spotPrivateGetV1MarginLoanInfo(e),s=this.milliseconds(),i=this.safeValue(t,"data",[]),n={info:t};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeValue(a,"currencies",[]),d={};for(let h=0;h<o.length;h++){const l=o[h],p=this.safeString(l,"currency"),m=this.safeCurrencyCode(p,"currency");d[m]={currency:m,rate:this.safeNumber(l,"actual-rate"),span:864e5,timestamp:s,datetime:this.iso8601(s)}}const u=this.markets_by_id[this.safeString(a,"symbol")].symbol;n[u]=d}return n}async fetchBorrowRates(e={}){await this.loadMarkets();const t=await this.spotPrivateGetV1MarginLoanInfo(e),s=this.milliseconds(),i=this.safeValue(t,"data",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeValue(a,"currencies",[]);for(let d=0;d<o.length;d++){const c=o[d],u=this.safeString(c,"currency"),h=this.safeCurrencyCode(u,"currency");n[h]={currency:h,rate:this.safeNumber(c,"actual-rate"),span:864e5,timestamp:s,datetime:this.iso8601(s),info:void 0}}}return n}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Ds(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={contract_code:n.id};let a;if(n.inverse)a="contractPublicGetSwapApiV1SwapHistoricalFundingRate";else if(n.linear)a="contractPublicGetLinearSwapApiV1SwapHistoricalFundingRate";else throw new Ti(this.id+" fetchFundingRateHistory() supports inverse and linear swaps only");const o=await this[a](this.extend(r,i)),d=this.safeValue(o,"data"),c=this.safeValue(d,"data",[]),u=[];for(let l=0;l<c.length;l++){const p=c[l],m=this.safeString(p,"contract_code"),g=this.safeSymbol(m),y=this.safeInteger(p,"funding_time");u.push({info:p,symbol:g,fundingRate:this.safeNumber(p,"funding_rate"),timestamp:y,datetime:this.iso8601(y)})}const h=this.sortBy(u,"timestamp");return this.filterBySymbolSinceLimit(h,n.symbol,t,s)}parseFundingRate(e,t=void 0){const s=this.safeNumber(e,"estimated_rate"),i=this.safeInteger(e,"funding_time"),n=this.safeInteger(e,"next_funding_time"),r=this.safeString(e,"contract_code"),a=this.safeSymbol(r,t);return{info:e,symbol:a,markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeNumber(e,"funding_rate"),fundingTimestamp:i,fundingDatetime:this.iso8601(i),nextFundingRate:s,nextFundingTimestamp:n,nextFundingDatetime:this.iso8601(n),previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);let i;if(s.inverse)i="contractPublicGetSwapApiV1SwapFundingRate";else if(s.linear)i="contractPublicGetLinearSwapApiV1SwapFundingRate";else throw new Ti(this.id+" fetchFundingRate() supports inverse and linear swaps only");const n={contract_code:s.id},r=await this[i](this.extend(n,t)),a=this.safeValue(r,"data",{});return this.parseFundingRate(a,s)}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeValue(this.options,"fetchFundingRates",{}),i=this.safeString(this.options,"defaultSubType","inverse");let n=this.safeString(s,"subType",i);n=this.safeString(t,"subType",n);const r={},a=this.getSupportedMapping(n,{linear:"contractPublicGetLinearSwapApiV1SwapBatchFundingRate",inverse:"contractPublicGetSwapApiV1SwapBatchFundingRate"});t=this.omit(t,"subType");const o=await this[a](this.extend(r,t)),d=this.safeValue(o,"data",[]),c=this.parseFundingRates(d);return this.filterByArray(c,"symbol",e)}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;[r,n]=this.handleMarginModeAndParams("fetchBorrowInterest",n),r=r===void 0?"cross":r;const a={};s!==void 0&&(a["start-date"]=this.yyyymmdd(s)),i!==void 0&&(a.size=i);let o,d;if(r==="isolated")d="privateGetMarginLoanOrders",t!==void 0&&(o=this.market(t),a.symbol=o.id);else if(d="privateGetCrossMarginLoanOrders",e!==void 0){const l=this.currency(e);a.currency=l.id}const c=await this[d](this.extend(a,n)),u=this.safeValue(c,"data"),h=this.parseBorrowInterests(u,o);return this.filterByCurrencySinceLimit(h,e,s,i)}parseBorrowInterest(e,t=void 0){const s=this.safeString(e,"symbol"),i=s===void 0?"cross":"isolated";t=this.safeMarket(s);const n=this.safeString(t,"symbol"),r=this.safeNumber(e,"accrued-at");return{account:i==="isolated"?n:"cross",symbol:n,marginMode:i,currency:this.safeCurrencyCode(this.safeString(e,"currency")),interest:this.safeNumber(e,"interest-amount"),interestRate:this.safeNumber(e,"interest-rate"),amountBorrowed:this.safeNumber(e,"loan-amount"),timestamp:r,datetime:this.iso8601(r),info:e}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/";const o=this.omit(i,this.extractParams(e));if(typeof t=="string"){if(t==="public"||t==="private"?a+=this.version:(t==="v2Public"||t==="v2Private")&&(a+="v2"),a+="/"+this.implodeParams(e,i),t==="private"||t==="v2Private"){this.checkRequiredCredentials();const d=this.ymdhms(this.milliseconds(),"T");let c={SignatureMethod:"HmacSHA256",SignatureVersion:"2",AccessKeyId:this.apiKey,Timestamp:d};s!=="POST"&&(c=this.extend(c,o)),c=this.keysort(c);let u=this.urlencode(c);const h=[s,this.hostname,a,u].join(`
`),l=this.hmac(this.encode(h),this.encode(this.secret),"sha256","base64");u+="&"+this.urlencode({Signature:l}),a+="?"+u,s==="POST"?(r=this.json(o),n={"Content-Type":"application/json"}):n={"Content-Type":"application/x-www-form-urlencoded"}}else Object.keys(o).length&&(a+="?"+this.urlencode(o));a=this.implodeParams(this.urls.api[t],{hostname:this.hostname})+a}else{const d=this.safeString(t,0),c=this.safeString(t,1),u=this.safeString(t,2),h=this.safeString(t,3);let l,p=this.safeValue(this.urls.hostnames,d);if(typeof p!="string"&&(p=this.safeValue(p,u),typeof l!="string"&&h!==void 0&&(p=this.safeValue(p,h))),l=p,a+=this.implodeParams(e,i),c==="public")Object.keys(o).length&&(a+="?"+this.urlencode(o));else if(c==="private"){this.checkRequiredCredentials();const m=this.ymdhms(this.milliseconds(),"T");let g={SignatureMethod:"HmacSHA256",SignatureVersion:"2",AccessKeyId:this.apiKey,Timestamp:m};s!=="POST"&&(g=this.extend(g,o)),g=this.keysort(g);let y=this.urlencode(g);const b=[s,l,a,y].join(`
`),w=this.hmac(this.encode(b),this.encode(this.secret),"sha256","base64");y+="&"+this.urlencode({Signature:w}),a+="?"+y,s==="POST"?(r=this.json(o),r.length===2&&(r="{}"),n={"Content-Type":"application/json"}):n={"Content-Type":"application/x-www-form-urlencoded"}}a=this.implodeParams(this.urls.api[d],{hostname:l})+a}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&"status"in a&&this.safeString(a,"status")==="error"){const u=this.safeString2(a,"err-code","err_code"),h=this.id+" "+r;this.throwBroadlyMatchedException(this.exceptions.broad,r,h),this.throwExactlyMatchedException(this.exceptions.exact,u,h);const l=this.safeString2(a,"err-msg","err_msg");throw this.throwExactlyMatchedException(this.exceptions.exact,l,h),new rv(h)}}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),[r,a]=this.handleMarketTypeAndParams("fetchFundingHistory",n,i);let o;const d={type:"30,31"};if(t!==void 0&&(d.start_date=t),n.linear){o="contractPrivatePostLinearSwapApiV3SwapFinancialRecordExact";let h;[h,i]=this.handleMarginModeAndParams("fetchFundingHistory",i),h=h===void 0?"cross":h,h==="isolated"?d.mar_acct=n.id:d.mar_acct=n.quoteId}else r==="swap"?(o="contractPrivatePostSwapApiV3SwapFinancialRecordExact",d.contract=n.id):(o="contractPrivatePostApiV3ContractFinancialRecordExact",d.symbol=n.id);const c=await this[o](this.extend(d,a)),u=this.safeValue(c,"data",[]);return this.parseIncomes(u,n,t,s)}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new Ds(this.id+" setLeverage() requires a symbol argument");await this.loadMarkets();const i=this.market(t),[n,r]=this.handleMarketTypeAndParams("setLeverage",i,s);let a;if(i.linear){let c;[c,s]=this.handleMarginModeAndParams("setLeverage",s),c=c===void 0?"cross":c,a=this.getSupportedMapping(c,{isolated:"contractPrivatePostLinearSwapApiV1SwapSwitchLeverRate",cross:"contractPrivatePostLinearSwapApiV1SwapCrossSwitchLeverRate"})}else a=this.getSupportedMapping(n,{future:"contractPrivatePostApiV1ContractSwitchLeverRate",swap:"contractPrivatePostSwapApiV1SwapSwitchLeverRate"});const o={lever_rate:e};return n==="future"&&i.inverse?o.symbol=i.settleId:o.contract_code=i.id,await this[a](this.extend(o,r))}parseIncome(e,t=void 0){const s=this.safeString(e,"contract_code"),i=this.safeSymbol(s,t),n=this.safeNumber(e,"amount"),r=this.safeInteger(e,"ts"),a=this.safeString(e,"id"),o=this.safeString2(e,"symbol","asset"),d=this.safeCurrencyCode(o);return{info:e,symbol:i,code:d,timestamp:r,datetime:this.iso8601(r),id:a,amount:n}}parseIncomes(e,t=void 0,s=void 0,i=void 0){const n=[];for(let a=0;a<e.length;a++){const o=e[a],d=this.parseIncome(o,t);n.push(d)}const r=this.sortBy(n,"timestamp");return this.filterBySinceLimit(r,s,i,"timestamp")}parsePosition(e,t=void 0){t=this.safeMarket(this.safeString(e,"contract_code"));const s=t.symbol,i=this.safeString(e,"volume"),n=this.safeValue(t,"contractSize"),r=this.numberToString(n),a=this.safeNumber(e,"cost_open"),o=this.safeString(e,"position_margin"),c=this.safeString(e,"direction")==="buy"?"long":"short",u=this.safeNumber(e,"profit_unreal");let h=this.safeString(e,"margin_mode");const l=this.safeString(e,"lever_rate"),p=ai.stringMul(this.safeString(e,"profit_rate"),"100"),m=this.safeString(e,"last_price"),g=ai.stringMul(i,r);let y;t.linear?y=ai.stringMul(g,m):(y=ai.stringDiv(g,m),h="cross");const b=ai.stringDiv(o,y),w=this.safeString(e,"margin_balance"),S=this.safeNumber(e,"liquidation_price"),k=this.safeString(e,"adjust_factor"),T=ai.stringDiv(k,l),I=ai.stringMul(T,y),_=ai.stringDiv(I,w);return{info:e,id:void 0,symbol:s,contracts:this.parseNumber(i),contractSize:n,entryPrice:a,collateral:this.parseNumber(w),side:c,unrealizedProfit:u,leverage:this.parseNumber(l),percentage:this.parseNumber(p),marginMode:h,notional:this.parseNumber(y),markPrice:void 0,liquidationPrice:S,initialMargin:this.parseNumber(o),initialMarginPercentage:this.parseNumber(b),maintenanceMargin:this.parseNumber(I),maintenanceMarginPercentage:this.parseNumber(T),marginRatio:this.parseNumber(_),timestamp:void 0,datetime:void 0}}async fetchPositions(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s;[s,t]=this.handleMarginModeAndParams("fetchPositions",t),s=s===void 0?"cross":s;const i=this.safeString(this.options,"defaultSubType","inverse");let n;[n,t]=this.handleMarketTypeAndParams("fetchPositions",void 0,t),n==="spot"&&(n="future");let r;i==="linear"?r=this.getSupportedMapping(s,{isolated:"contractPrivatePostLinearSwapApiV1SwapPositionInfo",cross:"contractPrivatePostLinearSwapApiV1SwapCrossPositionInfo"}):r=this.getSupportedMapping(n,{future:"contractPrivatePostApiV1ContractPositionInfo",swap:"contractPrivatePostSwapApiV1SwapPositionInfo"});const a=await this[r](t),o=this.safeValue(a,"data",[]),d=this.safeInteger(a,"ts"),c=[];for(let u=0;u<o.length;u++){const h=o[u],l=this.parsePosition(h);c.push(this.extend(l,{timestamp:d,datetime:this.iso8601(d)}))}return this.filterByArray(c,"symbol",e,!1)}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e);let i;[i,t]=this.handleMarginModeAndParams("fetchPosition",t),i=i===void 0?"cross":i;const[n,r]=this.handleMarketTypeAndParams("fetchPosition",s,t);let a;s.linear?a=this.getSupportedMapping(i,{isolated:"contractPrivatePostLinearSwapApiV1SwapAccountPositionInfo",cross:"contractPrivatePostLinearSwapApiV1SwapCrossAccountPositionInfo"}):a=this.getSupportedMapping(n,{future:"contractPrivatePostApiV1ContractAccountPositionInfo",swap:"contractPrivatePostSwapApiV1SwapAccountPositionInfo"});const o={};s.future&&s.inverse?o.symbol=s.settleId:(i==="cross"&&(o.margin_account="USDT"),o.contract_code=s.id);const d=await this[a](this.extend(o,r)),c=this.safeValue(d,"data");let u;i==="cross"?u=c:u=this.safeValue(c,0);const h=this.omit(u,["positions"]),l=this.safeValue(u,"positions");let p;if(s.future&&s.inverse)for(let y=0;y<l.length;y++){const b=l[y];if(b.contract_code===s.id){p=b;break}}else p=this.safeValue(l,0);const m=this.safeInteger(d,"ts"),g=this.parsePosition(this.extend(p,h));return this.extend(g,{timestamp:m,datetime:this.iso8601(m)})}parseLedgerEntryType(e){const t={trade:"trade",etf:"trade","transact-fee":"fee","fee-deduction":"fee",transfer:"transfer",credit:"credit",liquidation:"trade",interest:"credit",deposit:"deposit",withdraw:"withdrawal","withdraw-fee":"fee",exchange:"exchange","other-types":"transfer",rebate:"rebate"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"transactId"),i=this.safeString(e,"currency"),n=this.safeCurrencyCode(i,t),r=this.safeNumber(e,"transactAmt"),a=this.safeString(e,"transferType"),o=this.parseLedgerEntryType(a),d=this.safeString(e,"direction"),c=this.safeInteger(e,"transactTime"),u=this.iso8601(c),h=this.safeString(e,"accountId");return{id:s,direction:d,account:h,referenceId:s,referenceAccount:h,type:o,currency:n,amount:r,timestamp:c,datetime:u,before:void 0,after:void 0,status:void 0,fee:void 0,info:e}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={accountId:await this.fetchAccountIdByType("spot",i)};let a;e!==void 0&&(a=this.currency(e),r.currency=a.id),t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=s);const o=await this.spotPrivateGetV2AccountLedger(this.extend(r,i)),d=this.safeValue(o,"data",[]);return this.parseLedger(d,a,t,s)}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const s=await this.contractPublicGetLinearSwapApiV1SwapAdjustfactor(t),i=this.safeValue(s,"data");return this.parseLeverageTiers(i,e,"contract_code")}async fetchMarketLeverageTiers(e,t={}){await this.loadMarkets();const s={};if(e!==void 0){const a=this.market(e);if(!a.contract)throw new vi(this.id+" fetchMarketLeverageTiers() symbol supports contract markets only");s.contract_code=a.id}const i=await this.contractPublicGetLinearSwapApiV1SwapAdjustfactor(this.extend(s,t)),n=this.safeValue(i,"data"),r=this.parseLeverageTiers(n,[e],"contract_code");return this.safeValue(r,e)}parseLeverageTiers(e,t=void 0,s=void 0){const i={};for(let n=0;n<e.length;n++){const r=e[n],a=this.safeValue(r,"list",[]),o=[],d=this.safeString(r,"trade_partition"),c=this.safeString(r,s),u=this.safeSymbol(c);if(this.inArray(u,t)){for(let h=0;h<a.length;h++){const l=a[h],p=this.safeString(l,"lever_rate"),m=this.safeValue(l,"ladders",[]);for(let g=0;g<m.length;g++){const y=m[g],b=this.safeString(y,"adjust_factor");o.push({tier:this.safeInteger(y,"ladder"),currency:this.safeCurrencyCode(d),minNotional:this.safeNumber(y,"min_size"),maxNotional:this.safeNumber(y,"max_size"),maintenanceMarginRate:this.parseNumber(ai.stringDiv(b,p)),maxLeverage:this.parseNumber(p),info:y})}}i[u]=o}}return i}async fetchOpenInterestHistory(e,t="1h",s=void 0,i=void 0,n={}){if(t!=="1h"&&t!=="4h"&&t!=="12h"&&t!=="1d")throw new vi(this.id+" fetchOpenInterestHistory cannot only use the 1h, 4h, 12h and 1d timeframe");await this.loadMarkets();const r={"1h":"60min","4h":"4hour","12h":"12hour","1d":"1day"},a=this.market(e),o=this.safeNumber2(n,"amount_type","amountType");if(o===void 0)throw new Ds(this.id+" fetchOpenInterestHistory requires parameter params.amountType to be either 1 (cont), or 2 (cryptocurrency)");const d={period:r[t],amount_type:o};let c;a.future?(d.contract_type=this.safeString(a.info,"contract_type"),d.symbol=a.baseId,c="contractPublicGetApiV1ContractHisOpenInterest"):a.linear?(d.contract_type="swap",d.contract_code=a.id,d.contract_code=a.id,c="contractPublicGetLinearSwapApiV1SwapHisOpenInterest"):(d.contract_code=a.id,c="contractPublicGetSwapApiV1SwapHisOpenInterest"),i!==void 0&&(d.size=i);const u=await this[c](this.extend(d,n)),h=this.safeValue(u,"data"),l=this.safeValue(h,"tick");return this.parseOpenInterests(l,a,s,i)}async fetchOpenInterest(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.contract)throw new vi(this.id+" fetchOpenInterest() supports contract markets only");if(s.option)throw new Ti(this.id+" fetchOpenInterest() does not currently support option markets");const i={contract_code:s.id};let n;s.future?(i.contract_type=this.safeString(s.info,"contract_type"),i.symbol=s.baseId,n="contractPublicGetApiV1ContractOpenInterest"):s.linear?(i.contract_type="swap",n="contractPublicGetLinearSwapApiV1SwapOpenInterest"):n="contractPublicGetSwapApiV1SwapOpenInterest";const r=await this[n](this.extend(i,t)),a=this.safeValue(r,"data",[]),o=this.parseOpenInterest(a[0],s),d=this.safeInteger(r,"ts");return this.extend(o,{timestamp:d,datetime:this.iso8601(d)})}parseOpenInterest(e,t=void 0){const s=this.safeInteger(e,"ts"),i=this.safeNumber(e,"volume"),n=this.safeNumber(e,"value");return{symbol:this.safeString(t,"symbol"),baseVolume:i,quoteVolume:n,openInterestAmount:i,openInterestValue:n,timestamp:s,datetime:this.iso8601(s),info:e}}async borrowMargin(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.currency(e),r={currency:n.id,amount:this.currencyToPrecision(e,t)};let a;[a,i]=this.handleMarginModeAndParams("borrowMargin",i),a=a===void 0?"cross":a;let o;if(a==="isolated"){if(s===void 0)throw new Ds(this.id+" borrowMargin() requires a symbol argument for isolated margin");const u=this.market(s);r.symbol=u.id,o="privatePostMarginOrders"}else a==="cross"&&(o="privatePostCrossMarginOrders");const d=await this[o](this.extend(r,i)),c=this.parseMarginLoan(d,n);return this.extend(c,{amount:t,symbol:s})}async repayMargin(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.currency(e);let r;[r,i]=this.handleMarginModeAndParams("repayMargin",i),r=r===void 0?"cross":r;const a=this.safeValue(this.options,"marginAccounts",{}),o=this.getSupportedMapping(r,a),d=await this.fetchAccountIdByType(o,i),c={currency:n.id,amount:this.currencyToPrecision(e,t),accountId:d},u=await this.v2PrivatePostAccountRepayment(this.extend(c,i)),h=this.safeValue(u,"Data",[]),l=this.safeValue(h,0),p=this.parseMarginLoan(l,n);return this.extend(p,{amount:t,symbol:s})}parseMarginLoan(e,t=void 0){const s=this.safeInteger(e,"repayTime");return{id:this.safeInteger2(e,"repayId","data"),currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:s,datetime:this.iso8601(s),info:e}}async fetchSettlementHistory(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeString(i,"code"),r=this.safeInteger2(i,"until","till");i=this.omit(i,["until","till"]);const a=e===void 0?void 0:this.market(e),[o,d]=this.handleMarketTypeAndParams("fetchSettlementHistory",a,i);if(o==="future"){if(e===void 0&&n===void 0)throw new Ds(this.id+' requires a symbol argument or params["code"] for fetchSettlementHistory future')}else if(e===void 0)throw new Ds(this.id+" requires a symbol argument for fetchSettlementHistory swap");const c={};a.future?c.symbol=a.baseId:c.contract_code=a.id,t!==void 0&&(c.start_at=t),s!==void 0&&(c.page_size=s),r!==void 0&&(c.end_at=r);let u="contractPublicGetApiV1ContractSettlementRecords";a.swap&&(a.linear?u="contractPublicGetLinearSwapApiV1SwapSettlementRecords":u="contractPublicGetSwapApiV1SwapSettlementRecords");const h=await this[u](this.extend(c,d)),l=this.safeValue(h,"data"),p=this.safeValue(l,"settlement_record"),m=this.parseSettlements(p,a);return this.sortBy(m,"timestamp")}parseSettlements(e,t){const s=[];for(let i=0;i<e.length;i++){const n=e[i],r=this.safeValue(n,"list");if(r!==void 0){const a=this.safeInteger(n,"settlement_time"),o={timestamp:a,datetime:this.iso8601(a)};for(let d=0;d<r.length;d++){const c=r[d],u=this.parseSettlement(c,t);s.push(this.extend(u,o))}}else s.push(this.parseSettlement(e[i],t))}return s}parseSettlement(e,t){const s=this.safeInteger(e,"settlement_time"),i=this.safeString(e,"contract_code");return{info:e,symbol:this.safeSymbol(i,t),price:this.safeNumber(e,"settlement_price"),timestamp:s,datetime:this.iso8601(s)}}};const dD=me,{AuthenticationError:ov,ExchangeError:dv,PermissionDenied:cD,ExchangeNotAvailable:cv,OnMaintenance:P0,InvalidOrder:Fn,OrderNotFound:A0,InsufficientFunds:uv,ArgumentsRequired:uD,BadSymbol:Ic,BadRequest:$f,RequestTimeout:fD,NetworkError:hD}=oe,{TRUNCATE:lD,TICK_SIZE:pD}=pe,B0=ke;var F_=class extends dD{describe(){return this.deepExtend(super.describe(),{id:"huobijp",name:"Huobi Japan",countries:["JP"],rateLimit:100,userAgent:this.userAgents.chrome39,certified:!1,version:"v1",accounts:void 0,accountsById:void 0,hostname:"api-cloud.huobi.co.jp",pro:!0,has:{CORS:void 0,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchAccounts:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingLimits:!0,fetchWithdrawals:!0,withdraw:!0},timeframes:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"60min","4h":"4hour","1d":"1day","1w":"1week","1M":"1mon","1y":"1year"},urls:{logo:"https://user-images.githubusercontent.com/1294454/85734211-85755480-b705-11ea-8b35-0b7f1db33a2f.jpg",api:{market:"https://{hostname}",public:"https://{hostname}",private:"https://{hostname}",v2Public:"https://{hostname}",v2Private:"https://{hostname}"},www:"https://www.huobi.co.jp",referral:"https://www.huobi.co.jp/register/?invite_code=znnq3",doc:"https://api-doc.huobi.co.jp",fees:"https://www.huobi.co.jp/support/fee"},api:{v2Public:{get:{"reference/currencies":1,"market-status":1}},v2Private:{get:{"account/ledger":1,"account/withdraw/quota":1,"account/withdraw/address":1,"account/deposit/address":1,"account/repayment":5,"reference/transact-fee-rate":1,"account/asset-valuation":.2,"point/account":5,"sub-user/user-list":1,"sub-user/user-state":1,"sub-user/account-list":1,"sub-user/deposit-address":1,"sub-user/query-deposit":1,"user/api-key":1,"user/uid":1,"algo-orders/opening":1,"algo-orders/history":1,"algo-orders/specific":1,"c2c/offers":1,"c2c/offer":1,"c2c/transactions":1,"c2c/repayment":1,"c2c/account":1,"etp/reference":1,"etp/transactions":5,"etp/transaction":5,"etp/rebalance":1,"etp/limit":1},post:{"account/transfer":1,"account/repayment":5,"point/transfer":5,"sub-user/management":1,"sub-user/creation":1,"sub-user/tradable-market":1,"sub-user/transferability":1,"sub-user/api-key-generation":1,"sub-user/api-key-modification":1,"sub-user/api-key-deletion":1,"sub-user/deduct-mode":1,"algo-orders":1,"algo-orders/cancel-all-after":1,"algo-orders/cancellation":1,"c2c/offer":1,"c2c/cancellation":1,"c2c/cancel-all":1,"c2c/repayment":1,"c2c/transfer":1,"etp/creation":5,"etp/redemption":5,"etp/{transactId}/cancel":10,"etp/batch-cancel":50}},market:{get:{"history/kline":1,"detail/merged":1,depth:1,trade:1,"history/trade":1,detail:1,tickers:1,etp:1}},public:{get:{"common/symbols":1,"common/currencys":1,"common/timestamp":1,"common/exchange":1,"settings/currencys":1}},private:{get:{"account/accounts":.2,"account/accounts/{id}/balance":.2,"account/accounts/{sub-uid}":1,"account/history":4,"cross-margin/loan-info":1,"margin/loan-info":1,"fee/fee-rate/get":1,"order/openOrders":.4,"order/orders":.4,"order/orders/{id}":.4,"order/orders/{id}/matchresults":.4,"order/orders/getClientOrder":.4,"order/history":1,"order/matchresults":1,"query/deposit-withdraw":1,"margin/loan-orders":.2,"margin/accounts/balance":.2,"cross-margin/loan-orders":1,"cross-margin/accounts/balance":1,"points/actions":1,"points/orders":1,"subuser/aggregate-balance":10,"stable-coin/exchange_rate":1,"stable-coin/quote":1},post:{"account/transfer":1,"futures/transfer":1,"order/batch-orders":.4,"order/orders/place":.2,"order/orders/submitCancelClientOrder":.2,"order/orders/batchCancelOpenOrders":.4,"order/orders/{id}/submitcancel":.2,"order/orders/batchcancel":.4,"dw/withdraw/api/create":1,"dw/withdraw-virtual/{id}/cancel":1,"dw/transfer-in/margin":10,"dw/transfer-out/margin":10,"margin/orders":10,"margin/orders/{id}/repay":10,"cross-margin/transfer-in":1,"cross-margin/transfer-out":1,"cross-margin/orders":1,"cross-margin/orders/{id}/repay":1,"stable-coin/exchange":1,"subuser/transfer":10}}},fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},precisionMode:pD,exceptions:{broad:{"contract is restricted of closing positions on API.  Please contact customer service":P0,maintain:P0},exact:{"bad-request":$f,"base-date-limit-error":$f,"api-not-support-temp-addr":cD,timeout:fD,"gateway-internal-error":cv,"account-frozen-balance-insufficient-error":uv,"invalid-amount":Fn,"order-limitorder-amount-min-error":Fn,"order-limitorder-amount-max-error":Fn,"order-marketorder-amount-min-error":Fn,"order-limitorder-price-min-error":Fn,"order-limitorder-price-max-error":Fn,"order-holding-limit-failed":Fn,"order-orderprice-precision-error":Fn,"order-etp-nav-price-max-error":Fn,"order-orderstate-error":A0,"order-queryorder-invalid":A0,"order-update-error":cv,"api-signature-check-failed":ov,"api-signature-not-valid":ov,"base-record-invalid":A0,"base-symbol-trade-disabled":Ic,"base-symbol-error":Ic,"system-maintenance":P0,"invalid symbol":Ic,"symbol trade not open now":Ic,"invalid-address":$f,"base-currency-chain-error":$f,"dw-insufficient-balance":uv}},options:{defaultNetwork:"ERC20",networks:{ETH:"erc20",TRX:"trc20",HRC20:"hrc20",HECO:"hrc20",HT:"hrc20",ALGO:"algo",OMNI:""},fetchOrdersByStatesMethod:"private_get_order_orders",fetchOpenOrdersMethod:"fetch_open_orders_v1",createMarketBuyOrderRequiresPrice:!0,fetchMarketsMethod:"publicGetCommonSymbols",fetchBalanceMethod:"privateGetAccountAccountsIdBalance",createOrderMethod:"privatePostOrderOrdersPlace",language:"en-US",broker:{id:"AA03022abc"}},commonCurrencies:{GET:"Themis",GTC:"Game.com",HIT:"HitChain",HOT:"Hydro Protocol",PNT:"Penta",SBTC:"Super Bitcoin",BIFI:"Bitcoin File"}})}async fetchTime(e={}){const t=await this.publicGetCommonTimestamp(e);return this.safeInteger(t,"data")}async fetchTradingLimits(e=void 0,t={}){await this.loadMarkets(),e===void 0&&(e=this.symbols);const s={};for(let i=0;i<e.length;i++){const n=e[i];s[n]=await this.fetchTradingLimitsById(this.marketId(n),t)}return s}async fetchTradingLimitsById(e,t={}){const s={symbol:e},i=await this.publicGetCommonExchange(this.extend(s,t));return this.parseTradingLimits(this.safeValue(i,"data",{}))}parseTradingLimits(e,t=void 0,s={}){return{info:e,limits:{amount:{min:this.safeNumber(e,"limit-order-must-greater-than"),max:this.safeNumber(e,"limit-order-must-less-than")}}}}costToPrecision(e,t){return this.decimalToPrecision(t,lD,this.markets[e].precision.cost,this.precisionMode)}async fetchMarkets(e={}){const t=this.options.fetchMarketsMethod,s=await this[t](e),i=this.safeValue(s,"data",[]);if(i.length<1)throw new hD(this.id+" fetchMarkets() returned empty response: "+this.json(i));const r=[];for(let a=0;a<i.length;a++){const o=i[a],d=this.safeString(o,"base-currency"),c=this.safeString(o,"quote-currency"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),l=this.safeString(o,"state"),p=this.safeString(o,"leverage-ratio","1"),m=this.safeString(o,"super-margin-leverage-ratio","1"),g=B0.stringGt(p,"1")||B0.stringGt(m,"1"),y=u==="OMG"?0:.2/100;r.push({id:d+c,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:g,swap:!1,future:!1,option:!1,active:l==="online",contract:!1,linear:void 0,inverse:void 0,taker:y,maker:y,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{price:this.parseNumber(this.parsePrecision(this.safeString(o,"price-precision"))),amount:this.parseNumber(this.parsePrecision(this.safeString(o,"amount-precision"))),cost:this.parseNumber(this.parsePrecision(this.safeString(o,"value-precision")))},limits:{leverage:{min:this.parseNumber("1"),max:this.parseNumber(p),superMax:this.parseNumber(m)},amount:{min:this.safeNumber(o,"min-order-amt"),max:this.safeNumber(o,"max-order-amt")},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(o,"min-order-value"),max:void 0}},info:o})}return r}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeInteger(e,"ts");let n,r,a,o;"bid"in e&&(Array.isArray(e.bid)?(n=this.safeString(e.bid,0),r=this.safeString(e.bid,1)):(n=this.safeString(e,"bid"),r=this.safeString(e,"bidSize"))),"ask"in e&&(Array.isArray(e.ask)?(a=this.safeString(e.ask,0),o=this.safeString(e.ask,1)):(a=this.safeString(e,"ask"),o=this.safeString(e,"askSize")));const d=this.safeString(e,"open"),c=this.safeString(e,"close"),u=this.safeString(e,"amount"),h=this.safeString(e,"vol");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:n,bidVolume:r,ask:a,askVolume:o,vwap:void 0,open:d,close:c,last:c,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:u,quoteVolume:h,info:e},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={symbol:this.market(e).id,type:"step0"},r=await this.marketGetDepth(this.extend(n,s));if("tick"in r){if(!r.tick)throw new Ic(this.id+" fetchOrderBook() returned empty response: "+this.json(r));const a=this.safeValue(r,"tick"),o=this.safeInteger(a,"ts",this.safeInteger(r,"ts")),d=this.parseOrderBook(a,e,o);return d.nonce=this.safeInteger(a,"version"),d}throw new dv(this.id+" fetchOrderBook() returned unrecognized response: "+this.json(r))}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.marketGetDetailMerged(this.extend(i,t)),r=this.parseTicker(n.tick,s),a=this.safeInteger(n,"ts");return r.timestamp=a,r.datetime=this.iso8601(a),r}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.marketGetTickers(t),i=this.safeValue(s,"data",[]),n=this.safeInteger(s,"ts"),r={};for(let a=0;a<i.length;a++){const o=this.safeString(i[a],"symbol"),d=this.safeMarket(o),c=d.symbol,u=this.parseTicker(i[a],d);u.timestamp=n,u.datetime=this.iso8601(n),r[c]=u}return this.filterByArray(r,"symbol",e)}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeInteger2(e,"ts","created-at"),r=this.safeString(e,"order-id");let a=this.safeString(e,"direction"),o=this.safeString(e,"type");if(o!==void 0){const k=o.split("-");a=k[0],o=k[1]}const d=this.safeString(e,"role"),c=this.safeString(e,"price"),u=this.safeString2(e,"filled-amount","amount"),h=this.parseNumber(c),l=this.parseNumber(u),p=this.parseNumber(B0.stringMul(c,u));let m,g=this.safeNumber(e,"filled-fees"),y=this.safeCurrencyCode(this.safeString(e,"fee-currency"));const b=this.safeNumber(e,"filled-points");b!==void 0&&(g===void 0||g===0)&&(g=b,y=this.safeCurrencyCode(this.safeString(e,"fee-deduct-currency"))),g!==void 0&&(m={cost:g,currency:y});const w=this.safeString2(e,"trade-id","tradeId");return{id:this.safeString(e,"id",w),info:e,order:r,timestamp:n,datetime:this.iso8601(n),symbol:i,type:o,side:a,takerOrMaker:d,price:h,amount:l,cost:p,fee:m}}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={id:e},a=await this.privateGetOrderOrdersIdMatchresults(this.extend(r,n));return this.parseTrades(a.data,void 0,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),s!==void 0&&(r.size=s),t!==void 0&&(r["start-time"]=t);const a=await this.privateGetOrderMatchresults(this.extend(r,i));return this.parseTrades(a.data,n,t,s)}async fetchTrades(e,t=void 0,s=1e3,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.size=s);const a=await this.marketGetHistoryTrade(this.extend(r,i)),o=this.safeValue(a,"data",[]);let d=[];for(let c=0;c<o.length;c++){const u=this.safeValue(o[c],"data",[]);for(let h=0;h<u.length;h++){const l=this.parseTrade(u[h],n);d.push(l)}}return d=this.sortBy(d,"timestamp"),this.filterBySymbolSinceLimit(d,n.symbol,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"id"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"amount")]}async fetchOHLCV(e,t="1m",s=void 0,i=1e3,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,period:this.timeframes[t]};i!==void 0&&(a.size=i);const o=await this.marketGetHistoryKline(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseOHLCVs(d,r,t,s,i)}async fetchAccounts(e={}){return await this.loadMarkets(),(await this.privateGetAccountAccounts(e)).data}async fetchCurrencies(e={}){const t={language:this.options.language},s=await this.publicGetSettingsCurrencys(this.extend(t,e)),i=this.safeValue(s,"data",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeValue(a,"name"),d=this.safeCurrencyCode(o),c=this.safeValue(a,"deposit-enabled"),u=this.safeValue(a,"withdraw-enabled"),h=this.safeValue(a,"country-disabled"),l=this.safeValue(a,"visible",!1),p=this.safeString(a,"state"),m=l&&c&&u&&p==="online"&&!h,g=this.safeString(a,"display-name"),y=this.parseNumber(this.parsePrecision(this.safeString(a,"withdraw-precision")));n[d]={id:o,code:d,type:"crypto",name:g,active:m,deposit:c,withdraw:u,fee:void 0,precision:y,limits:{amount:{min:y,max:void 0},deposit:{min:this.safeNumber(a,"deposit-min-amount"),max:void 0},withdraw:{min:this.safeNumber(a,"withdraw-min-amount"),max:void 0}},info:a}}return n}parseBalance(e){const t=this.safeValue(e.data,"list",[]),s={info:e};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r);let o;a in s?o=s[a]:o=this.account(),n.type==="trade"&&(o.free=this.safeString(n,"balance")),n.type==="frozen"&&(o.used=this.safeString(n,"balance")),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets(),await this.loadAccounts();const t=this.options.fetchBalanceMethod,s={id:this.accounts[0].id},i=await this[t](this.extend(s,e));return this.parseBalance(i)}async fetchOrdersByStates(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={states:e};let a;t!==void 0&&(a=this.market(t),r.symbol=a.id);const o=this.safeString(this.options,"fetchOrdersByStatesMethod","private_get_order_orders"),d=await this[o](this.extend(r,n));return this.parseOrders(d.data,a,s,i)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetOrderOrdersId(this.extend(i,s)),r=this.safeValue(n,"data");return this.parseOrder(r)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStates("pre-submitted,submitted,partial-filled,filled,partial-canceled,canceled",e,t,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeString(this.options,"fetchOpenOrdersMethod","fetch_open_orders_v1");return await this[n](e,t,s,i)}async fetchOpenOrdersV1(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new uD(this.id+" fetchOpenOrdersV1() requires a symbol argument");return await this.fetchOrdersByStates("pre-submitted,submitted,partial-filled",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStates("filled,partial-canceled,canceled",e,t,s,i)}async fetchOpenOrdersV2(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id);let a=this.safeString(i,"account-id");if(a===void 0){await this.loadAccounts();for(let u=0;u<this.accounts.length;u++){const h=this.accounts[u];if(h.type==="spot"&&(a=this.safeString(h,"id"),a!==void 0))break}}n["account-id"]=a,s!==void 0&&(n.size=s);const o=this.omit(i,"account-id"),d=await this.privateGetOrderOpenOrders(this.extend(n,o)),c=this.safeValue(d,"data",[]);return this.parseOrders(c,r,t,s)}parseOrderStatus(e){const t={"partial-filled":"open","partial-canceled":"canceled",filled:"closed",canceled:"canceled",submitted:"open"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id");let i,n,r;if("type"in e){const g=e.type.split("-");i=g[0],n=g[1],r=this.parseOrderStatus(this.safeString(e,"state"))}const a=this.safeString(e,"symbol");t=this.safeMarket(a,t);const o=this.safeInteger(e,"created-at"),d=this.safeString(e,"client-order-id"),c=this.safeString(e,"amount"),u=this.safeString2(e,"filled-amount","field-amount"),h=this.safeString(e,"price"),l=this.safeString2(e,"filled-cash-amount","field-cash-amount"),p=this.safeString2(e,"filled-fees","field-fees");let m;if(p!==void 0){const g=i==="sell"?t.quote:t.base;m={cost:p,currency:g}}return this.safeOrder({info:e,id:s,clientOrderId:d,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:void 0,symbol:t.symbol,type:n,timeInForce:void 0,postOnly:void 0,side:i,price:h,stopPrice:void 0,average:void 0,cost:l,amount:c,filled:u,remaining:void 0,status:r,fee:m,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets(),await this.loadAccounts();const a=this.market(e),o={"account-id":this.accounts[0].id,symbol:a.id,type:s+"-"+t},d=this.safeString2(r,"clientOrderId","client-order-id");if(d===void 0){const p=this.safeValue(this.options,"broker",{}),m=this.safeString(p,"id");o["client-order-id"]=m+this.uuid()}else o["client-order-id"]=d;if(r=this.omit(r,["clientOrderId","client-order-id"]),t==="market"&&s==="buy")if(this.options.createMarketBuyOrderRequiresPrice){if(n===void 0)throw new Fn(this.id+" market buy order requires price argument to calculate cost (total amount of quote currency to spend for buying, amount * price). To switch off this warning exception and specify cost in the amount argument, set .options['createMarketBuyOrderRequiresPrice'] = false. Make sure you know what you're doing.");o.amount=this.costToPrecision(e,parseFloat(i)*parseFloat(n))}else o.amount=this.costToPrecision(e,i);else o.amount=this.amountToPrecision(e,i);(t==="limit"||t==="ioc"||t==="limit-maker"||t==="stop-limit"||t==="stop-limit-fok")&&(o.price=this.priceToPrecision(e,n));const c=this.options.createOrderMethod,u=await this[c](this.extend(o,r)),h=this.milliseconds(),l=this.safeString(u,"data");return{info:u,id:l,timestamp:h,datetime:this.iso8601(h),lastTradeTimestamp:void 0,status:void 0,symbol:e,type:t,side:s,price:n,amount:i,filled:void 0,remaining:void 0,cost:void 0,trades:void 0,fee:void 0,clientOrderId:void 0,average:void 0}}async cancelOrder(e,t=void 0,s={}){const i=await this.privatePostOrderOrdersIdSubmitcancel({id:e});return this.extend(this.parseOrder(i),{id:e,status:"canceled"})}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue2(s,"clientOrderIds","client-order-ids");s=this.omit(s,["clientOrderIds","client-order-ids"]);const n={};return i===void 0?n["order-ids"]=e:n["client-order-ids"]=i,await this.privatePostOrderOrdersBatchcancel(this.extend(n,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;return e!==void 0&&(i=this.market(e),s.symbol=i.id),await this.privatePostOrderOrdersBatchCancelOpenOrders(this.extend(s,t))}currencyToPrecision(e,t,s=void 0){return this.decimalToPrecision(t,0,this.currencies[e].precision,this.precisionMode)}safeNetwork(e){const t=e.length-1;e[t]==="1"&&(e=e.slice(0,t));const i={};return this.safeString(i,e,e)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"addressTag"),n=this.safeString(e,"currency");t=this.safeCurrency(n,t);const r=this.safeCurrencyCode(n,t),a=this.safeString(e,"chain"),o=this.safeValue(t,"networks",{}),d=this.indexBy(o,"id"),c=this.safeValue(d,a,a),u=this.safeString(c,"network");return this.checkAddress(s),{currency:r,address:s,tag:i,network:u,info:e}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){(s===void 0||s>100)&&(s=100),await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r={type:"deposit",from:0};n!==void 0&&(r.currency=n.id),s!==void 0&&(r.size=s);const a=await this.privateGetQueryDepositWithdraw(this.extend(r,i));return this.parseTransactions(a.data,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){(s===void 0||s>100)&&(s=100),await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r={type:"withdraw",from:0};n!==void 0&&(r.currency=n.id),s!==void 0&&(r.size=s);const a=await this.privateGetQueryDepositWithdraw(this.extend(r,i));return this.parseTransactions(a.data,n,t,s)}parseTransaction(e,t=void 0){const s=this.safeInteger(e,"created-at"),i=this.safeInteger(e,"updated-at"),n=this.safeCurrencyCode(this.safeString(e,"currency"));let r=this.safeString(e,"type");r==="withdraw"&&(r="withdrawal");const a=this.parseTransactionStatus(this.safeString(e,"state")),o=this.safeString(e,"address-tag");let d=this.safeNumber(e,"fee");d!==void 0&&(d=Math.abs(d));const c=this.safeString(e,"address"),u=this.safeStringUpper(e,"chain");return{info:e,id:this.safeString2(e,"id","data"),txid:this.safeString(e,"tx-hash"),timestamp:s,datetime:this.iso8601(s),network:u,address:c,addressTo:void 0,addressFrom:void 0,tag:o,tagTo:void 0,tagFrom:void 0,type:r,amount:this.safeNumber(e,"amount"),currency:n,status:a,updated:i,fee:{currency:n,cost:d,rate:void 0}}}parseTransactionStatus(e){const t={unknown:"failed",confirming:"pending",confirmed:"ok",safe:"ok",orphan:"failed",submitted:"pending",canceled:"canceled",reexamine:"pending",reject:"failed",pass:"pending","wallet-reject":"failed","confirm-error":"failed",repealed:"failed","wallet-transfer":"pending","pre-transfer":"pending"};return this.safeString(t,e,e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets(),this.checkAddress(s);const r=this.currency(e),a={address:s,amount:t,currency:r.id.toLowerCase()};i!==void 0&&(a["addr-tag"]=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeStringLower(o,d,d),d!==void 0&&(d==="erc20"?a.chain=r.id+d:a.chain=d+r.id,n=this.omit(n,"network"));const c=await this.privatePostDwWithdrawApiCreate(this.extend(a,n));return this.parseTransaction(c,r)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/";t==="market"?a+=t:t==="public"||t==="private"?a+=this.version:(t==="v2Public"||t==="v2Private")&&(a+="v2"),a+="/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="private"||t==="v2Private"){this.checkRequiredCredentials();const d=this.ymdhms(this.milliseconds(),"T");let c={SignatureMethod:"HmacSHA256",SignatureVersion:"2",AccessKeyId:this.apiKey,Timestamp:d};s!=="POST"&&(c=this.extend(c,o)),c=this.keysort(c);let u=this.urlencode(c);const h=[s,this.hostname,a,u].join(`
`),l=this.hmac(this.encode(h),this.encode(this.secret),"sha256","base64");u+="&"+this.urlencode({Signature:l}),a+="?"+u,s==="POST"?(r=this.json(o),n={"Content-Type":"application/json"}):n={"Content-Type":"application/x-www-form-urlencoded"}}else Object.keys(i).length&&(a+="?"+this.urlencode(i));return a=this.implodeParams(this.urls.api[t],{hostname:this.hostname})+a,{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&"status"in a&&this.safeString(a,"status")==="error"){const u=this.safeString(a,"err-code"),h=this.id+" "+r;this.throwBroadlyMatchedException(this.exceptions.broad,r,h),this.throwExactlyMatchedException(this.exceptions.exact,u,h);const l=this.safeString(a,"err-msg");throw this.throwExactlyMatchedException(this.exceptions.exact,l,h),new dv(h)}}};const mD=Ob;var gD=class extends mD{describe(){return this.deepExtend(super.describe(),{id:"huobipro",alias:!0,name:"Huobi Pro"})}};const yD=me,{TICK_SIZE:bD,PAD_WITH_ZERO:fv,ROUND:wD,TRUNCATE:SD,DECIMAL_PLACES:kD}=pe,{InvalidOrder:vD,InsufficientFunds:TD,ExchangeError:OD,ExchangeNotAvailable:ID,DDoSProtection:xD,BadRequest:La,NotSupported:_D,InvalidAddress:N0,AuthenticationError:CD}=oe,MD=ke;var D_=class extends yD{describe(){return this.deepExtend(super.describe(),{id:"idex",name:"IDEX",countries:["US"],rateLimit:200,version:"v3",pro:!0,certified:!0,requiresWeb3:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!1,createDepositAddress:!1,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:void 0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:void 0,fetchWithdrawal:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","6h":"6h","1d":"1d"},urls:{test:{MATIC:"https://api-sandbox-matic.idex.io"},logo:"https://user-images.githubusercontent.com/51840849/94481303-2f222100-01e0-11eb-97dd-bc14c5943a86.jpg",api:{MATIC:"https://api-matic.idex.io"},www:"https://idex.io",doc:["https://docs.idex.io/"]},api:{public:{get:{ping:1,time:1,exchange:1,assets:1,markets:1,tickers:1,candles:1,trades:1,orderbook:1}},private:{get:{user:1,wallets:1,balances:1,orders:1,fills:1,deposits:1,withdrawals:1,wsToken:1},post:{wallets:1,orders:1,"orders/test":1,withdrawals:1},delete:{orders:1}}},options:{defaultTimeInForce:"gtc",defaultSelfTradePrevention:"cn",network:"MATIC"},exceptions:{INVALID_ORDER_QUANTITY:vD,INSUFFICIENT_FUNDS:TD,SERVICE_UNAVAILABLE:ID,EXCEEDED_RATE_LIMIT:xD,INVALID_PARAMETER:La,WALLET_NOT_ASSOCIATED:N0,INVALID_WALLET_SIGNATURE:CD},requiredCredentials:{walletAddress:!0,privateKey:!0,apiKey:!0,secret:!0},precisionMode:bD,paddingMode:fv,commonCurrencies:{}})}priceToPrecision(e,t){const s=this.market(e),i=this.safeValue(s,"info",{}),n=this.safeInteger(i,"quoteAssetPrecision");return t=this.decimalToPrecision(t,wD,s.precision.price,this.precisionMode),this.decimalToPrecision(t,SD,n,kD,fv)}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=await this.publicGetExchange(),i=this.safeNumber(s,"makerFeeRate"),n=this.safeNumber(s,"takerFeeRate"),r=this.safeString(s,"makerTradeMinimum"),a=this.safeString(s,"takerTradeMinimum"),o=this.parseNumber(MD.stringMin(r,a)),d=[];for(let c=0;c<t.length;c++){const u=t[c],h=this.safeString(u,"market"),l=this.safeString(u,"baseAsset"),p=this.safeString(u,"quoteAsset"),m=this.safeCurrencyCode(l),g=this.safeCurrencyCode(p),y=this.parseNumber(this.parsePrecision(this.safeString(u,"baseAssetPrecision"))),b=this.parseNumber(this.parsePrecision(this.safeString(u,"quoteAssetPrecision"))),w=this.safeString(u,"status");let S;g==="ETH"&&(S=o),d.push({id:h,symbol:m+"/"+g,base:m,quote:g,settle:void 0,baseId:l,quoteId:p,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:w!=="inactive",contract:!1,linear:void 0,inverse:void 0,taker:n,maker:i,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:y,price:this.safeNumber(u,"tickSize")},limits:{leverage:{min:void 0,max:void 0},amount:{min:y,max:void 0},price:{min:b,max:void 0},cost:{min:S,max:void 0}},info:u})}return d}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id},n=await this.publicGetTickers(this.extend(i,t)),r=this.safeValue(n,0);return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickers(t);return this.parseTickers(s,e)}parseTicker(e,t=void 0){const s=this.safeString(e,"market");t=this.safeMarket(s,t,"-");const i=t.symbol,n=this.safeInteger(e,"time"),r=this.safeString(e,"close");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:r,last:r,previousClose:void 0,change:void 0,percentage:this.safeString(e,"percentChange"),average:void 0,baseVolume:this.safeString(e,"baseVolume"),quoteVolume:this.safeString(e,"quoteVolume"),info:e},t)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={market:r.id,interval:t};s!==void 0&&(a.start=s),i!==void 0&&(a.limit=i);const o=await this.publicGetCandles(this.extend(a,n));return Array.isArray(o)?this.parseOHLCVs(o,r,t,s,i):[]}parseOHLCV(e,t=void 0){const s=this.safeInteger(e,"start"),i=this.safeNumber(e,"open"),n=this.safeNumber(e,"high"),r=this.safeNumber(e,"low"),a=this.safeNumber(e,"close"),o=this.safeNumber(e,"volume");return[s,i,n,r,a,o]}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market:n.id};t!==void 0&&(r.start=t),s!==void 0&&(r.limit=s);const a=await this.publicGetTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"fillId"),i=this.safeString(e,"price"),n=this.safeString(e,"quantity"),r=this.safeString(e,"quoteQuantity"),a=this.safeInteger(e,"time"),o=this.safeString(e,"market"),d=this.safeSymbol(o,t,"-"),u=this.safeString(e,"makerSide")==="buy"?"sell":"buy",h=this.safeString(e,"side",u),l=this.safeString(e,"liquidity","taker"),p=this.safeString(e,"fee");let m;if(p!==void 0){const y=this.safeString(e,"feeAsset");m={cost:p,currency:this.safeCurrencyCode(y)}}const g=this.safeString(e,"orderId");return this.safeTrade({info:e,timestamp:a,datetime:this.iso8601(a),symbol:d,id:s,order:g,type:"limit",side:h,takerOrMaker:l,price:i,amount:n,cost:r,fee:m},t)}async fetchTradingFees(e={}){this.checkRequiredCredentials(),await this.loadMarkets();const s={nonce:this.uuidv1()};let i;i=await this.privateGetUser(this.extend(s,e));const n=this.safeNumber(i,"makerFeeRate"),r=this.safeNumber(i,"takerFeeRate"),a={};for(let o=0;o<this.symbols.length;o++){const d=this.symbols[o];a[d]={info:i,symbol:d,maker:n,taker:r,percentage:!0,tierBased:!1}}return a}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={market:this.market(e).id,level:2};t!==void 0&&(n.limit=t);const r=await this.publicGetOrderbook(this.extend(n,s)),a=this.safeInteger(r,"sequence");return{symbol:e,timestamp:void 0,datetime:void 0,nonce:a,bids:this.parseSide(r,"bids"),asks:this.parseSide(r,"asks")}}parseSide(e,t){const s=this.safeValue(e,t,[]),i=[];for(let r=0;r<s.length;r++){const a=s[r],o=this.safeNumber(a,0),d=this.safeNumber(a,1),c=this.safeInteger(a,2);i.push([o,d,c])}const n=t==="bids";return this.sortBy(i,0,n)}async fetchCurrencies(e={}){const t=await this.publicGetAssets(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"name"),a=this.safeString(n,"symbol"),o=this.safeCurrencyCode(a),d=this.parseNumber(this.parsePrecision(this.safeString(n,"exchangeDecimals")));s[o]={id:a,code:o,info:n,type:void 0,name:r,active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,precision:d,limits:{amount:{min:d,max:void 0},withdraw:{min:d,max:void 0}}}}return s}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"asset"),r=this.safeCurrencyCode(n),a=this.account();a.total=this.safeString(i,"quantity"),a.free=this.safeString(i,"availableForTrade"),a.used=this.safeString(i,"locked"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){this.checkRequiredCredentials(),await this.loadMarkets();const s={nonce:this.uuidv1(),wallet:this.walletAddress},i=this.extend(s,e);if(i.wallet===void 0)throw new La(this.id+' fetchBalance() wallet is undefined, set this.walletAddress or "address" in params');let n;try{n=await this.privateGetBalances(i)}catch(r){if(r instanceof N0){const a=i.wallet;await this.associateWallet(a),n=await this.privateGetBalances(i)}else throw r}return this.parseBalance(n)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){this.checkRequiredCredentials(),await this.loadMarkets();let n;const r={nonce:this.uuidv1(),wallet:this.walletAddress};e!==void 0&&(n=this.market(e),r.market=n.id),t!==void 0&&(r.start=t),s!==void 0&&(r.limit=s);const a=this.extend(r,i);if(a.wallet===void 0)throw new La(this.id+' fetchMyTrades() walletAddress is undefined, set this.walletAddress or "address" in params');let o;try{o=await this.privateGetFills(a)}catch(d){if(d instanceof N0){const c=a.wallet;await this.associateWallet(c),o=await this.privateGetFills(a)}else throw d}return this.parseTrades(o,n,t,s)}async fetchOrder(e,t=void 0,s={}){const i={orderId:e};return await this.fetchOrdersHelper(t,void 0,void 0,this.extend(i,s))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={closed:!1};return await this.fetchOrdersHelper(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={closed:!0};return await this.fetchOrdersHelper(e,t,s,this.extend(n,i))}async fetchOrdersHelper(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={nonce:this.uuidv1(),wallet:this.walletAddress};let r;e!==void 0&&(r=this.market(e),n.market=r.id),t!==void 0&&(n.start=t),s!==void 0&&(n.limit=s);const a=await this.privateGetOrders(this.extend(n,i));return Array.isArray(a)?this.parseOrders(a,r,t,s):this.parseOrder(a,r)}parseOrderStatus(e){const t={active:"open",partiallyFilled:"open",rejected:"canceled",filled:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"time"),i=this.safeValue(e,"fills",[]),n=this.safeString(e,"orderId"),r=this.safeString(e,"clientOrderId"),a=this.safeString(e,"market"),o=this.safeString(e,"side"),d=this.safeSymbol(a,t,"-"),c=this.safeString(e,"type"),u=this.safeString(e,"originalQuantity"),h=this.safeString(e,"executedQuantity"),l=this.safeString(e,"avgExecutionPrice"),p=this.safeString(e,"price"),m=this.safeString(e,"status"),g=this.safeStringUpper(e,"timeInForce"),y=this.parseOrderStatus(m);return this.safeOrder({info:e,id:n,clientOrderId:r,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,symbol:d,type:c,timeInForce:g,postOnly:void 0,side:o,price:p,stopPrice:void 0,amount:u,cost:void 0,average:l,filled:h,remaining:void 0,status:y,fee:void 0,trades:i},t)}async associateWallet(e,t={}){const s=this.uuidv1(),i=this.remove0xPrefix(e),n=[this.base16ToBinary(s),this.base16ToBinary(i)],r=this.binaryConcatArray(n),a=this.hash(r,"keccak","hex"),o=this.signMessageString(a,this.privateKey),d={parameters:{nonce:s,wallet:e},signature:o};return await this.privatePostWallets(d)}async createOrder(e,t,s,i,n=void 0,r={}){this.checkRequiredCredentials(),await this.loadMarkets();const a=this.market(e),o=this.uuidv1();let d;const c={stopLoss:3,stopLossLimit:4,takeProfit:5,takeProfitLimit:6};let u;if(t==="stopLossLimit"||t==="takeProfitLimit"||"stopPrice"in r){if(!("stopPrice"in r))throw new La(this.id+" createOrder() stopPrice is a required parameter for "+t+"orders");u=this.priceToPrecision(e,r.stopPrice)}const h={limit:1,limitMaker:2};let l;const m=t.toLowerCase().indexOf("limit")>=0;if(t in h)d=h[t],l=this.priceToPrecision(e,n);else if(t in c)d=c[t],l=this.priceToPrecision(e,n);else if(t==="market")d=0;else throw new La(this.id+" "+t+" is not a valid order type");let g=0;if("quoteOrderQuantity"in r){if(t!=="market")throw new _D(this.id+" createOrder() quoteOrderQuantity is not supported for "+t+" orders, only supported for market orders");g=1,i=this.safeNumber(r,"quoteOrderQuantity")}const y=s==="buy"?0:1,b=this.remove0xPrefix(this.walletAddress),w=this.safeString(this.options,"network","ETH"),S=this.getSupportedMapping(w,{ETH:1,BSC:2,MATIC:4}),k=this.amountToPrecision(e,i),T={gtc:0,ioc:2,fok:3},I=this.safeString(this.options,"defaultTimeInForce","gtc"),_=this.safeString(r,"timeInForce",I);let N;if(_ in T)N=T[_];else{const Q=Object.keys(T).join(", ");throw new La(this.id+" "+_+" is not a valid timeInForce, please choose one of "+Q)}const M={dc:0,co:1,cn:2,cb:3},x=this.safeString(this.options,"defaultSelfTradePrevention","cn"),v=this.safeString(r,"selfTradePrevention",x);let O;if(v in M)O=M[v];else{const Q=Object.keys(M).join(", ");throw new La(this.id+" "+v+" is not a valid selfTradePrevention, please choose one of "+Q)}const A=[this.numberToBE(S,1),this.base16ToBinary(o),this.base16ToBinary(b),this.stringToBinary(this.encode(a.id)),this.numberToBE(d,1),this.numberToBE(y,1),this.stringToBinary(this.encode(k)),this.numberToBE(g,1)];if(m){const X=this.stringToBinary(this.encode(l));A.push(X)}if(t in c){const X=this.stringToBinary(this.encode(u||l));A.push(X)}const V=this.safeString(r,"clientOrderId");V!==void 0&&A.push(this.stringToBinary(this.encode(V)));const q=[this.numberToBE(N,1),this.numberToBE(O,1),this.numberToBE(0,8)],R=this.arrayConcat(A,q),H=this.binaryConcatArray(R),F=this.hash(H,"keccak","hex"),P=this.signMessageString(F,this.privateKey),E={parameters:{nonce:o,market:a.id,side:s,type:t,wallet:this.walletAddress,selfTradePrevention:v},signature:P};t!=="market"&&(E.parameters.timeInForce=_),m&&(E.parameters.price=l),t in c&&(E.parameters.stopPrice=u||l),g===0?E.parameters.quantity=k:E.parameters.quoteOrderQuantity=k,V!==void 0&&(E.parameters.clientOrderId=V);const j=await this.privatePostOrders(E);return this.parseOrder(j,a)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkRequiredCredentials(),await this.loadMarkets();const r=this.uuidv1(),a=this.currencyToPrecision(e,t),o=this.currency(e),d=this.remove0xPrefix(this.walletAddress),c=[this.base16ToBinary(r),this.base16ToBinary(d),this.stringToBinary(this.encode(o.id)),this.stringToBinary(this.encode(a)),this.numberToBE(1,1)],u=this.binaryConcatArray(c),h=this.hash(u,"keccak","hex"),l=this.signMessageString(h,this.privateKey),p={parameters:{nonce:r,wallet:s,asset:o.id,quantity:a},signature:l},m=await this.privatePostWithdrawals(p);return this.parseTransaction(m,o)}async cancelAllOrders(e=void 0,t={}){this.checkRequiredCredentials(),await this.loadMarkets();let s;e!==void 0&&(s=this.market(e));const i=this.uuidv1(),n={parameters:{nonce:i,wallet:this.walletAddress}},r=this.remove0xPrefix(this.walletAddress),a=[this.base16ToBinary(i),this.base16ToBinary(r)];s!==void 0&&(a.push(this.stringToBinary(this.encode(s.id))),n.parameters.market=s.id);const o=this.binaryConcatArray(a),d=this.hash(o,"keccak","hex"),c=this.signMessageString(d,this.privateKey);n.signature=c;const u=await this.privateDeleteOrders(this.extend(n,t));return this.parseOrders(u,s)}async cancelOrder(e,t=void 0,s={}){this.checkRequiredCredentials(),await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));const n=this.uuidv1(),r=this.remove0xPrefix(this.walletAddress),a=[this.base16ToBinary(n),this.base16ToBinary(r),this.stringToBinary(this.encode(e))],o=this.binaryConcatArray(a),d=this.hash(o,"keccak","hex"),c=this.signMessageString(d,this.privateKey),u={parameters:{nonce:n,wallet:this.walletAddress,orderId:e},signature:c},h=await this.privateDeleteOrders(this.extend(u,s)),l=this.safeValue(h,0);return this.parseOrder(l,i)}handleErrors(e,t,s,i,n,r,a,o,d){const c=this.safeString(a,"code"),u=this.safeString(a,"message");if(c in this.exceptions){const h=this.exceptions[c];throw new h(this.id+" "+u)}if(c!==void 0)throw new OD(this.id+" "+u)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const n={nonce:this.uuidv1(),wallet:this.walletAddress,depositId:e},r=await this.privateGetDeposits(this.extend(n,s));return this.parseTransaction(r,t)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return i=this.extend({method:"privateGetDeposits"},i),this.fetchTransactionsHelper(e,t,s,i)}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeNumber(t,"serverTime")}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const n={nonce:this.uuidv1(),wallet:this.walletAddress,withdrawalId:e},r=await this.privateGetWithdrawals(this.extend(n,s));return this.parseTransaction(r,t)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return i=this.extend({method:"privateGetWithdrawals"},i),this.fetchTransactionsHelper(e,t,s,i)}async fetchTransactionsHelper(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={nonce:this.uuidv1(),wallet:this.walletAddress};let a;e!==void 0&&(a=this.currency(e),r.asset=a.id),t!==void 0&&(r.start=t),s!==void 0&&(r.limit=s);const o=i.method;i=this.omit(i,"method");const d=await this[o](this.extend(r,i));return this.parseTransactions(d,a,t,s)}parseTransactionStatus(e){const t={mined:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){let s;"depositId"in e?s="deposit":("withdrawId"in e||"withdrawalId"in e)&&(s="withdrawal");let i=this.safeString2(e,"depositId","withdrawId");i=this.safeString(e,"withdrawalId",i);const n=this.safeCurrencyCode(this.safeString(e,"asset"),t),r=this.safeNumber(e,"quantity"),a=this.safeString(e,"txId"),o=this.safeInteger2(e,"txTime","time");let d;"fee"in e&&(d={cost:this.safeNumber(e,"fee"),currency:"ETH"});const c=this.safeString(e,"txStatus"),u=this.parseTransactionStatus(c),h=this.safeInteger(e,"confirmationTime");return{info:e,id:i,txid:a,timestamp:o,datetime:this.iso8601(o),network:void 0,address:void 0,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:s,amount:r,currency:n,status:u,updated:h,fee:d}}calculateRateLimiterCost(e,t,s,i,n={},r={}){const a=this.apiKey!==void 0,o=this.secret!==void 0,d=this.walletAddress!==void 0,c=this.privateKey!==void 0,u=this.safeValue(n,"cost",1);return a&&o&&d&&c?u/2:u}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.safeString(this.options,"network","ETH"),o=this.safeString(this.options,"version","v1");let d=this.urls.api[a]+"/"+o+"/"+e;const u=Object.keys(i).length;let h;if(u>0&&(s==="GET"?(h=this.urlencode(i),d=d+"?"+h):r=this.json(i)),n={"Content-Type":"application/json"},this.apiKey!==void 0&&(n["IDEX-API-Key"]=this.apiKey),t==="private"){let l;s==="GET"?l=h:l=r,n["IDEX-HMAC-Signature"]=this.hmac(this.encode(l),this.encode(this.secret),"sha256","hex")}return{url:d,method:s,body:r,headers:n}}};const PD=me,{TICK_SIZE:AD}=pe,hv=ke;var BD=class extends PD{describe(){return this.deepExtend(super.describe(),{id:"independentreserve",name:"Independent Reserve",countries:["AU","NZ"],rateLimit:1e3,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},urls:{logo:"https://user-images.githubusercontent.com/51840849/87182090-1e9e9080-c2ec-11ea-8e49-563db9a38f37.jpg",api:{public:"https://api.independentreserve.com/Public",private:"https://api.independentreserve.com/Private"},www:"https://www.independentreserve.com",doc:"https://www.independentreserve.com/API"},api:{public:{get:["GetValidPrimaryCurrencyCodes","GetValidSecondaryCurrencyCodes","GetValidLimitOrderTypes","GetValidMarketOrderTypes","GetValidOrderTypes","GetValidTransactionTypes","GetMarketSummary","GetOrderBook","GetAllOrders","GetTradeHistorySummary","GetRecentTrades","GetFxRates","GetOrderMinimumVolumes","GetCryptoWithdrawalFees"]},private:{post:["GetOpenOrders","GetClosedOrders","GetClosedFilledOrders","GetOrderDetails","GetAccounts","GetTransactions","GetFiatBankAccounts","GetDigitalCurrencyDepositAddress","GetDigitalCurrencyDepositAddresses","GetTrades","GetBrokerageFees","GetDigitalCurrencyWithdrawal","PlaceLimitOrder","PlaceMarketOrder","CancelOrder","SynchDigitalCurrencyDepositAddressWithBlockchain","RequestFiatWithdrawal","WithdrawFiatCurrency","WithdrawDigitalCurrency"]}},fees:{trading:{taker:this.parseNumber("0.005"),maker:this.parseNumber("0.005"),percentage:!0,tierBased:!1}},commonCurrencies:{PLA:"PlayChip"},precisionMode:AD})}async fetchMarkets(e={}){const t=await this.publicGetGetValidPrimaryCurrencyCodes(e),s=await this.publicGetGetValidSecondaryCurrencyCodes(e),i=await this.publicGetGetOrderMinimumVolumes(e),n=[];for(let r=0;r<t.length;r++){const a=t[r],o=this.safeCurrencyCode(a),d=this.safeNumber(i,a);for(let c=0;c<s.length;c++){const u=s[c],h=this.safeCurrencyCode(u),l=a+"/"+u;n.push({id:l,symbol:o+"/"+h,base:o,quote:h,settle:void 0,baseId:a,quoteId:u,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:void 0,price:void 0},limits:{leverage:{min:void 0,max:void 0},amount:{min:d,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:l})}}return n}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"CurrencyCode"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"AvailableBalance"),a.total=this.safeString(i,"TotalBalance"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetAccounts(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={primaryCurrencyCode:i.baseId,secondaryCurrencyCode:i.quoteId},r=await this.publicGetGetOrderBook(this.extend(n,s)),a=this.parse8601(this.safeString(r,"CreatedTimestampUtc"));return this.parseOrderBook(r,i.symbol,a,"BuyOrders","SellOrders","Price","Volume")}parseTicker(e,t=void 0){const s=this.parse8601(this.safeString(e,"CreatedTimestampUtc")),i=this.safeString(e,"PrimaryCurrencyCode"),n=this.safeString(e,"SecondaryCurrencyCode");let r;i!==void 0&&n!==void 0&&(r=i+"/"+n),t=this.safeMarket(r,t,"/");const a=t.symbol,o=this.safeString(e,"LastPrice");return this.safeTicker({symbol:a,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"DayHighestPrice"),low:this.safeString(e,"DayLowestPrice"),bid:this.safeString(e,"CurrentHighestBidPrice"),bidVolume:void 0,ask:this.safeString(e,"CurrentLowestOfferPrice"),askVolume:void 0,vwap:void 0,open:void 0,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeString(e,"DayAvgPrice"),baseVolume:this.safeString(e,"DayVolumeXbtInSecondaryCurrrency"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={primaryCurrencyCode:s.baseId,secondaryCurrencyCode:s.quoteId},n=await this.publicGetGetMarketSummary(this.extend(i,t));return this.parseTicker(n,s)}parseOrder(e,t=void 0){let s;const i=this.safeString(e,"PrimaryCurrencyCode"),n=this.safeString(e,"SecondaryCurrencyCode");let r,a;i!==void 0&&n!==void 0?(r=this.safeCurrencyCode(i),a=this.safeCurrencyCode(n),s=r+"/"+a):t!==void 0&&(s=t.symbol,r=t.base,a=t.quote);let o=this.safeString2(e,"Type","OrderType"),d;o!==void 0&&(o.indexOf("Bid")>=0?d="buy":o.indexOf("Offer")>=0&&(d="sell"),o.indexOf("Market")>=0?o="market":o.indexOf("Limit")>=0&&(o="limit"));const c=this.parse8601(this.safeString(e,"CreatedTimestampUtc")),u=this.safeString(e,"VolumeFilled"),h=this.safeString(e,"FeePercent");let l;return h!==void 0&&u!==void 0&&(l=hv.stringMul(h,u)),this.safeOrder({info:e,id:this.safeString(e,"OrderGuid"),clientOrderId:void 0,timestamp:c,datetime:this.iso8601(c),lastTradeTimestamp:void 0,symbol:s,type:o,timeInForce:void 0,postOnly:void 0,side:d,price:this.safeString(e,"Price"),stopPrice:void 0,cost:this.safeString(e,"Value"),average:this.safeString(e,"AvgPrice"),amount:this.safeString2(e,"VolumeOrdered","Volume"),filled:u,remaining:this.safeString(e,"Outstanding"),status:this.parseOrderStatus(this.safeString(e,"Status")),fee:{rate:h,cost:l,currency:r},trades:void 0},t)}parseOrderStatus(e){const t={Open:"open",PartiallyFilled:"open",Filled:"closed",PartiallyFilledAndCancelled:"canceled",Cancelled:"canceled",PartiallyFilledAndExpired:"canceled",Expired:"canceled"};return this.safeString(t,e,e)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=await this.privatePostGetOrderDetails(this.extend({orderGuid:e},s));let n;return t!==void 0&&(n=this.market(t)),this.parseOrder(i,n)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.ordered({});let r;e!==void 0&&(r=this.market(e),n.primaryCurrencyCode=r.baseId,n.secondaryCurrencyCode=r.quoteId),s===void 0&&(s=50),n.pageIndex=1,n.pageSize=s;const a=await this.privatePostGetOpenOrders(this.extend(n,i)),o=this.safeValue(a,"Data",[]);return this.parseOrders(o,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.ordered({});let r;e!==void 0&&(r=this.market(e),n.primaryCurrencyCode=r.baseId,n.secondaryCurrencyCode=r.quoteId),s===void 0&&(s=50),n.pageIndex=1,n.pageSize=s;const a=await this.privatePostGetClosedOrders(this.extend(n,i)),o=this.safeValue(a,"Data",[]);return this.parseOrders(o,r,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=50,i={}){await this.loadMarkets();const n=this.safeInteger(i,"pageIndex",1);s===void 0&&(s=50);const r=this.ordered({pageIndex:n,pageSize:s}),a=await this.privatePostGetTrades(this.extend(r,i));let o;return e!==void 0&&(o=this.market(e)),this.parseTrades(a.Data,o,t,s)}parseTrade(e,t=void 0){const s=this.parse8601(e.TradeTimestampUtc),i=this.safeString(e,"TradeGuid"),n=this.safeString(e,"OrderGuid"),r=this.safeString2(e,"Price","SecondaryCurrencyTradePrice"),a=this.safeString2(e,"VolumeTraded","PrimaryCurrencyAmount"),o=this.parseNumber(r),d=this.parseNumber(a),c=this.parseNumber(hv.stringMul(r,a)),u=this.safeString(e,"PrimaryCurrencyCode"),h=this.safeString(e,"SecondaryCurrencyCode");let l;u!==void 0&&h!==void 0&&(l=u+"/"+h);const p=this.safeSymbol(l,t,"/");let m=this.safeString(e,"OrderType");return m!==void 0&&(m.indexOf("Bid")>=0?m="buy":m.indexOf("Offer")>=0&&(m="sell")),{id:i,info:e,timestamp:s,datetime:this.iso8601(s),symbol:p,order:n,type:void 0,side:m,takerOrMaker:void 0,price:o,amount:d,cost:c,fee:void 0}}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={primaryCurrencyCode:n.baseId,secondaryCurrencyCode:n.quoteId,numberOfRecentTradesToRetrieve:50},a=await this.publicGetGetRecentTrades(this.extend(r,i));return this.parseTrades(a.Trades,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostGetBrokerageFees(e),s={};for(let n=0;n<t.length;n++){const r=t[n],a=this.safeString(r,"CurrencyCode"),o=this.safeCurrencyCode(a),d=this.safeNumber(r,"Fee");s[o]={info:r,fee:d}}const i={};for(let n=0;n<this.symbols.length;n++){const r=this.symbols[n],a=this.market(r),o=this.safeValue(s,a.base,{});i[r]={info:this.safeValue(o,"info"),symbol:r,maker:this.safeNumber(o,"fee"),taker:this.safeNumber(o,"fee"),percentage:!0,tierBased:!0}}return i}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.capitalize(t),d="privatePostPlace"+o+"Order";let c=o;c+=s==="sell"?"Offer":"Bid";const u=this.ordered({primaryCurrencyCode:a.baseId,secondaryCurrencyCode:a.quoteId,orderType:c});t==="limit"&&(u.price=n),u.volume=i;const h=await this[d](this.extend(u,r));return{info:h,id:h.OrderGuid}}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderGuid:e};return await this.privatePostCancelOrder(this.extend(i,s))}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/"+e;if(t==="public")Object.keys(i).length&&(a+="?"+this.urlencode(i));else{this.checkRequiredCredentials();const o=this.nonce(),d=[a,"apiKey="+this.apiKey,"nonce="+o.toString()],c=Object.keys(i);for(let p=0;p<c.length;p++){const m=c[p],g=i[m].toString();d.push(m+"="+g)}const u=d.join(","),h=this.hmac(this.encode(u),this.encode(this.secret)),l=this.ordered({});l.apiKey=this.apiKey,l.nonce=o,l.signature=h.toUpperCase();for(let p=0;p<c.length;p++){const m=c[p];l[m]=i[m]}r=this.json(l),n={"Content-Type":"application/json"}}return{url:a,method:s,body:r,headers:n}}};const ND=me,{ExchangeError:E0,ArgumentsRequired:jf,InsufficientFunds:ED,InvalidOrder:lv,OrderNotFound:VD,AuthenticationError:pv,BadSymbol:qD}=oe,{TICK_SIZE:LD}=pe;var RD=class extends ND{describe(){return this.deepExtend(super.describe(),{id:"indodax",name:"INDODAX",countries:["ID"],rateLimit:100,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!1,cancelOrder:!0,cancelOrders:!1,createDepositAddress:!1,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchDeposit:!1,fetchDeposits:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:void 0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:void 0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:void 0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFee:!0,fetchTransactionFees:!1,fetchTransactions:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!1,reduceMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},version:"2.0",urls:{logo:"https://user-images.githubusercontent.com/51840849/87070508-9358c880-c221-11ea-8dc5-5391afbbb422.jpg",api:{public:"https://indodax.com/api",private:"https://indodax.com/tapi"},www:"https://www.indodax.com",doc:"https://github.com/btcid/indodax-official-api-docs",referral:"https://indodax.com/ref/testbitcoincoid/1"},api:{public:{get:{server_time:5,pairs:5,price_increments:5,summaries:5,ticker_all:5,"{pair}/ticker":5,"{pair}/trades":5,"{pair}/depth":5}},private:{post:{getInfo:4,transHistory:4,trade:1,tradeHistory:4,openOrders:4,orderHistory:4,getOrder:4,cancelOrder:4,withdrawFee:4,withdrawCoin:4,listDownline:4,checkDownline:4,createVoucher:4}}},fees:{trading:{tierBased:!1,percentage:!0,maker:0,taker:.003}},exceptions:{exact:{invalid_pair:qD,"Insufficient balance.":ED,"invalid order.":VD,"Invalid credentials. API not found or session has expired.":pv,"Invalid credentials. Bad sign.":pv},broad:{"Minimum price":lv,"Minimum order":lv}},options:{recvWindow:5*1e3,timeDifference:0,adjustForTimeDifference:!1},commonCurrencies:{STR:"XLM",BCHABC:"BCH",BCHSV:"BSV",DRK:"DASH",NEM:"XEM"},precisionMode:LD})}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchTime(e={}){const t=await this.publicGetServerTime(e);return this.safeInteger(t,"server_time")}async fetchMarkets(e={}){const t=await this.publicGetPairs(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"ticker_id"),a=this.safeString(n,"traded_currency"),o=this.safeString(n,"base_currency"),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o),u=this.safeInteger(n,"is_maintenance");s.push({id:r,symbol:d+"/"+c,base:d,quote:c,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!u,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(n,"trade_fee_percent"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,percentage:!0,precision:{amount:this.parseNumber(this.parsePrecision("8")),price:this.parseNumber(this.parsePrecision(this.safeString(n,"price_round"))),cost:this.parseNumber(this.parsePrecision(this.safeString(n,"volume_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(n,"trade_min_traded_currency"),max:void 0},price:{min:this.safeNumber(n,"trade_min_base_currency"),max:void 0},cost:{min:void 0,max:void 0}},info:n})}return s}parseBalance(e){const t=this.safeValue(e,"return",{}),s=this.safeValue(t,"balance",{}),i=this.safeValue(t,"balance_hold",{}),n=this.safeTimestamp(t,"server_time"),r={info:e,timestamp:n,datetime:this.iso8601(n)},a=Object.keys(s);for(let o=0;o<a.length;o++){const d=a[o],c=this.safeCurrencyCode(d),u=this.account();u.free=this.safeString(s,d),u.used=this.safeString(i,d),r[c]=u}return this.safeBalance(r)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetInfo(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id},r=await this.publicGetPairDepth(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"buy","sell")}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeTimestamp(e,"server_time"),n="vol_"+t.baseId.toLowerCase(),r="vol_"+t.quoteId.toLowerCase(),a=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,n),quoteVolume:this.safeString(e,r),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetPairTicker(this.extend(i,t)),r=this.safeValue(n,"ticker",{});return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickerAll(t),i=this.safeValue(s,"tickers");return this.parseTickers(i,e)}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"date");return this.safeTrade({id:this.safeString(e,"tid"),info:e,timestamp:s,datetime:this.iso8601(s),symbol:this.safeSymbol(void 0,t),type:void 0,side:this.safeString(e,"type"),order:void 0,takerOrMaker:void 0,price:this.safeString(e,"price"),amount:this.safeString(e,"amount"),cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id},a=await this.publicGetPairTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseOrderStatus(e){const t={open:"open",filled:"closed",cancelled:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){let s;"type"in e&&(s=e.type);const i=this.parseOrderStatus(this.safeString(e,"status","open"));let n,r;const a=this.safeString(e,"price");let o,d;if(t!==void 0){n=t.symbol;let l=t.quoteId,p=t.baseId;t.quoteId==="idr"&&"order_rp"in e&&(l="rp"),t.baseId==="idr"&&"remain_rp"in e&&(p="rp"),r=this.safeString(e,"order_"+l),r||(o=this.safeString(e,"order_"+p),d=this.safeString(e,"remain_"+p))}const c=this.safeInteger(e,"submit_time"),u=void 0,h=this.safeString(e,"order_id");return this.safeOrder({info:e,id:h,clientOrderId:void 0,timestamp:c,datetime:this.iso8601(c),lastTradeTimestamp:void 0,symbol:n,type:"limit",timeInForce:void 0,postOnly:void 0,side:s,price:a,stopPrice:void 0,cost:r,average:void 0,amount:o,filled:void 0,remaining:d,status:i,fee:u,trades:void 0})}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new jf(this.id+" fetchOrder() requires a symbol");await this.loadMarkets();const i=this.market(t),n={pair:i.id,order_id:e},r=await this.privatePostGetOrder(this.extend(n,s)),a=r.return,o=this.parseOrder(this.extend({id:e},a.order),i);return this.extend({info:r},o)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.pair=n.id);const o=(await this.privatePostOpenOrders(this.extend(r,i))).return.orders;if(!o)return[];if(e!==void 0)return this.parseOrders(o,n,t,s);const d=Object.keys(o);let c=[];for(let u=0;u<d.length;u++){const h=d[u],l=o[h];n=this.markets_by_id[h];const p=this.parseOrders(l,n,t,s);c=this.arrayConcat(c,p)}return c}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new jf(this.id+" fetchClosedOrders() requires a symbol argument");await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),e=r.symbol,n.pair=r.id);const a=await this.privatePostOrderHistory(this.extend(n,i));let o=this.parseOrders(a.return.orders,r);return o=this.filterBy(o,"status","closed"),this.filterBySymbolSinceLimit(o,e,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){if(t!=="limit")throw new E0(this.id+" createOrder() allows limit orders only");await this.loadMarkets();const a=this.market(e),o={pair:a.id,type:s,price:n},d=a.baseId;s==="buy"?o[a.quoteId]=i*n:o[a.baseId]=i,o[d]=i;const c=await this.privatePostTrade(this.extend(o,r)),u=this.safeValue(c,"return",{}),h=this.safeString(u,"order_id");return{info:c,id:h}}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new jf(this.id+" cancelOrder() requires a symbol argument");const i=this.safeValue(s,"side");if(i===void 0)throw new jf(this.id+' cancelOrder() requires an extra "side" param');await this.loadMarkets();const n=this.market(t),r={order_id:e,pair:n.id,type:i};return await this.privatePostCancelOrder(this.extend(r,s))}async fetchTransactionFee(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=await this.privatePostWithdrawFee(this.extend(i,t)),r=this.safeValue(n,"return",{}),a=this.safeString(r,"currency");return{info:n,rate:this.safeNumber(r,"withdraw_fee"),currency:this.safeCurrencyCode(a,s)}}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};if(t!==void 0){const h=this.iso8601(t).slice(0,10);n.start=h,n.end=this.iso8601(this.milliseconds()).slice(0,10)}const r=await this.privatePostTransHistory(this.extend(n,i)),a=this.safeValue(r,"return",{}),o=this.safeValue(a,"withdraw",{}),d=this.safeValue(a,"deposit",{});let c=[],u;if(e===void 0){let h=Object.keys(o);for(let l=0;l<h.length;l++){const p=h[l];c=this.arrayConcat(c,o[p])}h=Object.keys(d);for(let l=0;l<h.length;l++){const p=h[l];c=this.arrayConcat(c,d[p])}}else{u=this.currency(e);const h=this.safeValue(o,u.id,[]),l=this.safeValue(d,u.id,[]);c=this.arrayConcat(h,l)}return this.parseTransactions(c,u,t,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a=this.milliseconds(),o={currency:r.id,withdraw_amount:t,withdraw_address:s,request_id:a.toString()};i&&(o.withdraw_memo=i);const d=await this.privatePostWithdrawCoin(this.extend(o,n));return this.parseTransaction(d,r)}parseTransaction(e,t=void 0){const s=this.safeString(e,"status"),i=this.safeTimestamp2(e,"success_time","submit_time"),n=this.safeString(e,"deposit_id"),r=this.safeNumber(e,"fee");let a;return r!==void 0&&(a={currency:this.safeCurrencyCode(void 0,t),cost:r}),{id:this.safeString2(e,"withdraw_id","deposit_id"),txid:this.safeString2(e,"txid","tx"),timestamp:i,datetime:this.iso8601(i),network:void 0,addressFrom:void 0,address:this.safeString(e,"withdraw_address"),addressTo:void 0,amount:this.safeNumberN(e,["amount","withdraw_amount","deposit_amount"]),type:n===void 0?"withdraw":"deposit",currency:this.safeCurrencyCode(void 0,t),status:this.parseTransactionStatus(s),updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:this.safeString(e,"withdraw_memo"),fee:a,info:e}}parseTransactionStatus(e){const t={success:"ok"};return this.safeString(t,e,e)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t];return t==="public"?a+="/"+this.implodeParams(e,i):(this.checkRequiredCredentials(),r=this.urlencode(this.extend({method:e,timestamp:this.nonce(),recvWindow:this.options.recvWindow},i)),n={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:this.hmac(this.encode(r),this.encode(this.secret),"sha512")}),{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0||Array.isArray(a))return;const c=this.safeValue(a,"error","");if(!("success"in a)&&c==="")return;if(this.safeInteger(a,"success",0)===1){if("return"in a)return;throw new E0(this.id+": malformed response: "+this.json(a))}const u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u),new E0(u)}};const FD=me,{ExchangeError:Wr,AuthenticationError:DD,ArgumentsRequired:HD}=oe,{TICK_SIZE:GD}=pe,mv=ke;var UD=class extends FD{describe(){return this.deepExtend(super.describe(),{id:"itbit",name:"itBit",countries:["US"],rateLimit:2e3,version:"v1",has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactions:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/27822159-66153620-60ad-11e7-89e7-005f6d7f3de0.jpg",api:{rest:"https://api.itbit.com"},www:"https://www.itbit.com",doc:["https://api.itbit.com/docs","https://www.itbit.com/api"]},api:{public:{get:["markets/{symbol}/ticker","markets/{symbol}/order_book","markets/{symbol}/trades"]},private:{get:["wallets","wallets/{walletId}","wallets/{walletId}/balances/{currencyCode}","wallets/{walletId}/funding_history","wallets/{walletId}/trades","wallets/{walletId}/orders","wallets/{walletId}/orders/{id}"],post:["wallet_transfers","wallets","wallets/{walletId}/cryptocurrency_deposits","wallets/{walletId}/cryptocurrency_withdrawals","wallets/{walletId}/orders","wire_withdrawal"],delete:["wallets/{walletId}/orders/{id}"]}},markets:{"BTC/USD":{id:"XBTUSD",symbol:"BTC/USD",base:"BTC",quote:"USD",baseId:"XBT",quoteId:"USD",type:"spot",spot:!0},"BTC/SGD":{id:"XBTSGD",symbol:"BTC/SGD",base:"BTC",quote:"SGD",baseId:"XBT",quoteId:"SGD",type:"spot",spot:!0},"BTC/EUR":{id:"XBTEUR",symbol:"BTC/EUR",base:"BTC",quote:"EUR",baseId:"XBT",quoteId:"EUR",type:"spot",spot:!0},"ETH/USD":{id:"ETHUSD",symbol:"ETH/USD",base:"ETH",quote:"USD",baseId:"ETH",quoteId:"USD",type:"spot",spot:!0},"ETH/EUR":{id:"ETHEUR",symbol:"ETH/EUR",base:"ETH",quote:"EUR",baseId:"ETH",quoteId:"EUR",type:"spot",spot:!0},"ETH/SGD":{id:"ETHSGD",symbol:"ETH/SGD",base:"ETH",quote:"SGD",baseId:"ETH",quoteId:"SGD",type:"spot",spot:!0},PAXGUSD:{id:"PAXGUSD",symbol:"PAXG/USD",base:"PAXG",quote:"USD",baseId:"PAXG",quoteId:"USD",type:"spot",spot:!0},BCHUSD:{id:"BCHUSD",symbol:"BCH/USD",base:"BCH",quote:"USD",baseId:"BCH",quoteId:"USD",type:"spot",spot:!0},LTCUSD:{id:"LTCUSD",symbol:"LTC/USD",base:"LTC",quote:"USD",baseId:"LTC",quoteId:"USD",type:"spot",spot:!0}},fees:{trading:{maker:this.parseNumber("-0.0003"),taker:this.parseNumber("0.0035")}},commonCurrencies:{XBT:"BTC"},precisionMode:GD})}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id},r=await this.publicGetMarketsSymbolOrderBook(this.extend(n,s));return this.parseOrderBook(r,i.symbol)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeString(e,"serverTimeUTC");if(!i)throw new Wr(this.id+" fetchTicker() returned a bad response: "+this.json(e));const n=this.parse8601(i),r=this.safeString(e,"vwap24h"),a=this.safeString(e,"volume24h"),o=mv.stringMul(a,r),d=this.safeString(e,"lastPrice");return this.safeTicker({symbol:s,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high24h"),low:this.safeString(e,"low24h"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:r,open:this.safeString(e,"openToday"),close:d,last:d,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:a,quoteVolume:o,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetMarketsSymbolTicker(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){const s=this.safeString2(e,"executionId","matchNumber"),i=this.parse8601(this.safeString(e,"timestamp")),n=this.safeString(e,"direction"),r=this.safeString(e,"orderId");let a=this.safeNumber(e,"commissionPaid");const o=this.safeString(e,"commissionCurrency"),d=this.safeCurrencyCode(o);let c=this.safeNumber(e,"rebatesApplied");c!==void 0&&(c=-c);const u=this.safeString(e,"rebateCurrency"),h=this.safeCurrencyCode(u),l=this.safeString2(e,"price","rate"),p=this.safeString2(e,"currency1Amount","amount"),m=this.parseNumber(l),g=this.parseNumber(p),y=this.parseNumber(mv.stringMul(l,p));let b;if(this.safeString(e,"instrument")!==void 0){const k=this.safeString(e,"currency1"),T=this.safeString(e,"currency2"),I=this.safeCurrencyCode(k),_=this.safeCurrencyCode(T);b=I+"/"+_}const S={info:e,id:s,timestamp:i,datetime:this.iso8601(i),symbol:b,order:r,type:void 0,side:n,takerOrMaker:void 0,price:m,amount:g,cost:y,fee:void 0};return a!==void 0&&(c!==void 0?d===h?(a=this.sum(a,c),S.fee={cost:a,currency:d}):S.fees=[{cost:a,currency:d},{cost:c,currency:h}]:S.fee={cost:a,currency:d}),"fee"in S||"fees"in S||(S.fee=void 0),S}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeString(i,"walletId");if(n===void 0)throw new HD(this.id+" fetchTransactions() requires a walletId parameter");const r={walletId:n};s!==void 0&&(r.perPage=s);const o=(await this.privateGetWalletsWalletIdFundingHistory(this.extend(r,i))).fundingHistory,d=[];for(let c=0;c<o.length;c++){const u=o[c],h=this.safeString(u,"time"),l=this.parse8601(h),p=this.safeString(u,"currency"),m=this.safeString(u,"destinationAddress"),g=this.safeString(u,"txnHash"),y=this.safeStringLower(u,"transactionType"),b=this.safeString(u,"status"),w=this.parseTransferStatus(b);d.push({id:this.safeString(u,"withdrawalId"),timestamp:l,datetime:this.iso8601(l),currency:this.safeCurrencyCode(p),address:m,tag:void 0,txid:g,type:y,status:w,amount:this.safeNumber(u,"amount"),fee:void 0,info:u})}return d}parseTransferStatus(e){const t={cancelled:"canceled",completed:"ok"};return this.safeString(t,e,"pending")}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeString(i,"walletId");if(n===void 0)throw new Wr(this.id+" fetchMyTrades() requires a walletId parameter");const r={walletId:n};t!==void 0&&(r.rangeStart=this.ymdhms(t,"T")),s!==void 0&&(r.perPage=s);const a=await this.privateGetWalletsWalletIdTrades(this.extend(r,i)),o=this.safeValue(a,"tradingHistory",[]);let d;return e!==void 0&&(d=this.market(e)),this.parseTrades(o,d,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.publicGetMarketsSymbolTrades(this.extend(r,i)),o=this.safeValue(a,"recentTrades",[]);return this.parseTrades(o,n,t,s)}parseBalance(e){const t=e[0].balances,s={info:e};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(n,"availableBalance"),o.total=this.safeString(n,"totalBalance"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.fetchWallets(e);return this.parseBalance(t)}async fetchWallets(e={}){if(await this.loadMarkets(),!this.uid)throw new DD(this.id+" fetchWallets() requires uid API credential");const t={userId:this.uid};return await this.privateGetWallets(this.extend(t,e))}async fetchWallet(e,t={}){await this.loadMarkets();const s={walletId:e};return await this.privateGetWalletsWalletId(this.extend(s,t))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"open"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"filled"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;if(e!==void 0&&(n=this.market(e)),!("walletId"in i))throw new Wr(this.id+" fetchOrders() requires a walletId parameter");const o={walletId:i.walletId},d=await this.privateGetWalletsWalletIdOrders(this.extend(o,i));return this.parseOrders(d,n,t,s)}parseOrderStatus(e){const t={submitted:"open",open:"open",filled:"closed",cancelled:"canceled",rejected:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"side"),i=this.safeString(e,"type"),n=this.safeString(e,"instrument"),r=this.safeSymbol(n,t),a=this.safeString(e,"createdTime"),o=this.parse8601(a),d=this.safeString(e,"amount"),c=this.safeString(e,"amountFilled"),u=void 0,h=this.safeString(e,"price"),l=this.safeString(e,"volumeWeightedAveragePrice"),p=this.safeString(e,"clientOrderIdentifier"),m=this.safeString(e,"id"),y=this.safeString(e,"postOnly")==="True";return this.safeOrder({id:m,clientOrderId:p,info:e,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:void 0,status:this.parseOrderStatus(this.safeString(e,"status")),symbol:r,type:i,timeInForce:void 0,postOnly:y,side:s,price:h,stopPrice:void 0,cost:void 0,average:l,amount:d,filled:c,remaining:void 0,fee:u,trades:void 0},t)}nonce(){return this.milliseconds()}async createOrder(e,t,s,i,n=void 0,r={}){if(await this.loadMarkets(),t==="market")throw new Wr(this.id+" createOrder() allows limit orders only");if(!("walletId"in r))throw new Wr(this.id+" createOrder() requires a walletId parameter");i=i.toString(),n=n.toString();const o=this.market(e),d={side:s,type:t,currency:o.id.replace(o.quote,""),amount:i,display:i,price:n,instrument:o.id},c=await this.privatePostWalletsWalletIdOrders(this.extend(d,r));return{info:c,id:c.id}}async fetchOrder(e,t=void 0,s={}){if(await this.loadMarkets(),!("walletId"in s))throw new Wr(this.id+" fetchOrder() requires a walletId parameter");const n={id:e},r=await this.privateGetWalletsWalletIdOrdersId(this.extend(n,s));return this.parseOrder(r)}async cancelOrder(e,t=void 0,s={}){if(!("walletId"in s))throw new Wr(this.id+" cancelOrder() requires a walletId parameter");const n={id:e};return await this.privateDeleteWalletsWalletIdOrdersId(this.extend(n,s))}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(s==="GET"&&Object.keys(o).length&&(a+="?"+this.urlencode(o)),s==="POST"&&Object.keys(o).length&&(r=this.json(o)),t==="private"){this.checkRequiredCredentials();const d=this.nonce().toString(),c=d,h=[s,a,s==="POST"?r:"",d,c],l=d+this.json(h).replace("\\/","/"),p=this.hash(this.encode(l),"sha256","binary"),m=this.stringToBinary(this.encode(a)),g=this.binaryConcat(m,p),y=this.hmac(g,this.encode(this.secret),"sha512","base64");n={Authorization:this.apiKey+":"+y,"Content-Type":"application/json","X-Auth-Timestamp":c,"X-Auth-Nonce":d}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;if(this.safeString(a,"code")!==void 0)throw new Wr(this.id+" "+this.json(a))}};const $D=me,{BadSymbol:V0,BadRequest:gv,ExchangeNotAvailable:xc,ArgumentsRequired:_c,PermissionDenied:jD,AuthenticationError:yv,ExchangeError:Cc,OrderNotFound:bv,DDoSProtection:Wf,InvalidNonce:wv,InsufficientFunds:Sv,CancelPending:WD,InvalidOrder:zf,InvalidAddress:kv,RateLimitExceeded:zD,OnMaintenance:KD,AccountSuspended:XD}=oe,{TRUNCATE:YD,TICK_SIZE:QD}=pe,Ra=ke;var H_=class extends $D{describe(){return this.deepExtend(super.describe(),{id:"kraken",name:"Kraken",countries:["US"],version:"0",rateLimit:1e3,certified:!1,pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createDepositAddress:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchBorrowInterest:!1,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLedgerEntry:!0,fetchLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderTrades:"emulated",fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchWithdrawals:!0,setLeverage:!1,setMarginMode:!1,withdraw:!0},marketsByAltname:{},timeframes:{"1m":1,"5m":5,"15m":15,"30m":30,"1h":60,"4h":240,"1d":1440,"1w":10080,"2w":21600},urls:{logo:"https://user-images.githubusercontent.com/51840849/76173629-fc67fb00-61b1-11ea-84fe-f2de582f58a3.jpg",api:{public:"https://api.kraken.com",private:"https://api.kraken.com",zendesk:"https://kraken.zendesk.com/api/v2/help_center/en-us/articles"},www:"https://www.kraken.com",doc:"https://www.kraken.com/features/api",fees:"https://www.kraken.com/en-us/features/fee-schedule"},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0026"),maker:this.parseNumber("0.0016"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.0026")],[this.parseNumber("50000"),this.parseNumber("0.0024")],[this.parseNumber("100000"),this.parseNumber("0.0022")],[this.parseNumber("250000"),this.parseNumber("0.0020")],[this.parseNumber("500000"),this.parseNumber("0.0018")],[this.parseNumber("1000000"),this.parseNumber("0.0016")],[this.parseNumber("2500000"),this.parseNumber("0.0014")],[this.parseNumber("5000000"),this.parseNumber("0.0012")],[this.parseNumber("10000000"),this.parseNumber("0.0001")]],maker:[[this.parseNumber("0"),this.parseNumber("0.0016")],[this.parseNumber("50000"),this.parseNumber("0.0014")],[this.parseNumber("100000"),this.parseNumber("0.0012")],[this.parseNumber("250000"),this.parseNumber("0.0010")],[this.parseNumber("500000"),this.parseNumber("0.0008")],[this.parseNumber("1000000"),this.parseNumber("0.0006")],[this.parseNumber("2500000"),this.parseNumber("0.0004")],[this.parseNumber("5000000"),this.parseNumber("0.0002")],[this.parseNumber("10000000"),this.parseNumber("0.0")]]}}},handleContentTypeApplicationZip:!0,api:{zendesk:{get:["360000292886","201893608"]},public:{get:{Assets:1,AssetPairs:1,Depth:1,OHLC:1,Spread:1,Ticker:1,Time:1,Trades:1}},private:{post:{AddOrder:0,AddExport:3,Balance:3,CancelAll:3,CancelOrder:0,CancelOrderBatch:0,ClosedOrders:6,DepositAddresses:3,DepositMethods:3,DepositStatus:3,ExportStatus:3,GetWebSocketsToken:3,Ledgers:6,OpenOrders:3,OpenPositions:3,QueryLedgers:3,QueryOrders:3,QueryTrades:3,RetrieveExport:3,RemoveExport:3,TradeBalance:3,TradesHistory:6,TradeVolume:3,Withdraw:3,WithdrawCancel:3,WithdrawInfo:3,WithdrawStatus:3,Stake:3,Unstake:3,"Staking/Assets":3,"Staking/Pending":3,"Staking/Transactions":3}}},commonCurrencies:{LUNA:"LUNC",LUNA2:"LUNA",REPV2:"REP",REP:"REPV1",UST:"USTC",XBT:"BTC","XBT.M":"BTC.M",XDG:"DOGE"},options:{delistedMarketsById:{},inactiveCurrencies:["CAD","USD","JPY","GBP"],networks:{ETH:"ERC20",TRX:"TRC20"},depositMethods:{"1INCH":"1inch (1INCH)",AAVE:"Aave",ADA:"ADA",ALGO:"Algorand",ANKR:"ANKR (ANKR)",ANT:"Aragon (ANT)",ATOM:"Cosmos",AXS:"Axie Infinity Shards (AXS)",BADGER:"Bager DAO (BADGER)",BAL:"Balancer (BAL)",BAND:"Band Protocol (BAND)",BAT:"BAT",BCH:"Bitcoin Cash",BNC:"Bifrost (BNC)",BNT:"Bancor (BNT)",BTC:"Bitcoin",CHZ:"Chiliz (CHZ)",COMP:"Compound (COMP)",CQT:"	Covalent Query Token (CQT)",CRV:"Curve DAO Token (CRV)",CTSI:"Cartesi (CTSI)",DAI:"Dai",DASH:"Dash",DOGE:"Dogecoin",DOT:"Polkadot",DYDX:"dYdX (DYDX)",ENJ:"Enjin Coin (ENJ)",EOS:"EOS",ETC:"Ether Classic (Hex)",ETH:"Ether (Hex)",EWT:"Energy Web Token",FEE:"Kraken Fee Credit",FIL:"Filecoin",FLOW:"Flow",GHST:"Aavegotchi (GHST)",GNO:"GNO",GRT:"GRT",ICX:"Icon",INJ:"Injective Protocol (INJ)",KAR:"Karura (KAR)",KAVA:"Kava",KEEP:"Keep Token (KEEP)",KNC:"Kyber Network (KNC)",KSM:"Kusama",LINK:"Link",LPT:"Livepeer Token (LPT)",LRC:"Loopring (LRC)",LSK:"Lisk",LTC:"Litecoin",MANA:"MANA",MATIC:"Polygon (MATIC)",MINA:"Mina",MIR:"Mirror Protocol (MIR)",MKR:"Maker (MKR)",MLN:"MLN",MOVR:"Moonriver (MOVR)",NANO:"NANO",OCEAN:"OCEAN",OGN:"Origin Protocol (OGN)",OMG:"OMG",OXT:"Orchid (OXT)",OXY:"Oxygen (OXY)",PAXG:"PAX (Gold)",PERP:"Perpetual Protocol (PERP)",PHA:"Phala (PHA)",QTUM:"QTUM",RARI:"Rarible (RARI)",RAY:"Raydium (RAY)",REN:"Ren Protocol (REN)",REP:"REPv2",REPV1:"REP",SAND:"The Sandbox (SAND)",SC:"Siacoin",SDN:"Shiden (SDN)",SOL:"Solana",SNX:"Synthetix  Network (SNX)",SRM:"Serum",STORJ:"Storj (STORJ)",SUSHI:"Sushiswap (SUSHI)",TBTC:"tBTC",TRX:"Tron",UNI:"UNI",USDC:"USDC",USDT:"Tether USD (ERC20)","USDT-TRC20":"Tether USD (TRC20)",WAVES:"Waves",WBTC:"Wrapped Bitcoin (WBTC)",XLM:"Stellar XLM",XMR:"Monero",XRP:"Ripple XRP",XTZ:"XTZ",YFI:"YFI",ZEC:"Zcash (Transparent)",ZRX:"0x (ZRX)"}},precisionMode:QD,exceptions:{"EQuery:Invalid asset pair":V0,"EAPI:Invalid key":yv,"EFunding:Unknown withdraw key":kv,"EFunding:Invalid amount":Sv,"EService:Unavailable":xc,"EDatabase:Internal error":xc,"EService:Busy":xc,"EQuery:Unknown asset":V0,"EAPI:Rate limit exceeded":Wf,"EOrder:Rate limit exceeded":Wf,"EGeneral:Internal error":xc,"EGeneral:Temporary lockout":Wf,"EGeneral:Permission denied":jD,"EOrder:Unknown order":zf,"EOrder:Order minimum not met":zf,"EGeneral:Invalid arguments":gv,"ESession:Invalid session":yv,"EAPI:Invalid nonce":wv,"EFunding:No funding method":gv,"EFunding:Unknown asset":V0,"EService:Market in post_only mode":KD,"EGeneral:Too many requests":Wf,"ETrade:User Locked":XD}})}feeToPrecision(e,t){return this.decimalToPrecision(t,YD,this.markets[e].precision.amount,this.precisionMode)}async fetchMarkets(e={}){const t=await this.publicGetAssetPairs(e),s=this.safeValue(t,"result",{}),i=Object.keys(s);let n=[];for(let r=0;r<i.length;r++){const a=i[r],o=s[a],d=this.safeString(o,"base"),c=this.safeString(o,"quote"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),l=a.indexOf(".d")>=0,p=this.safeString(o,"altname"),m=this.safeValue(o,"fees_maker",[]),g=this.safeValue(m,0,[]),y=this.safeString(g,1);let b;y!==void 0&&(b=this.parseNumber(Ra.stringDiv(y,"100")));const w=this.safeValue(o,"fees",[]),S=this.safeValue(w,0,[]),k=this.safeString(S,1);let T;k!==void 0&&(T=this.parseNumber(Ra.stringDiv(k,"100")));const I=this.safeValue(o,"leverage_buy",[]),_=I.length,N=this.parseNumber(this.parsePrecision(this.safeString(o,"pair_decimals")));n.push({id:a,symbol:l?p:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,darkpool:l,altname:o.altname,type:"spot",spot:!0,margin:_>0,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,taker:T,maker:b,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(o,"lot_decimals"))),price:N},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(I,_-1,1)},amount:{min:this.safeNumber(o,"ordermin"),max:void 0},price:{min:N,max:void 0},cost:{min:void 0,max:void 0}},info:o})}return n=this.appendInactiveMarkets(n),this.marketsByAltname=this.indexBy(n,"altname"),n}safeCurrency(e,t=void 0){if(e!==void 0&&e.length>3&&(e.indexOf("X")===0||e.indexOf("Z")===0)){if(e.indexOf(".")>0)return super.safeCurrency(e,t);e=e.slice(1)}return super.safeCurrency(e,t)}appendInactiveMarkets(e){const t={amount:this.parseNumber("0.00000001"),price:this.parseNumber("0.00000001")},s={min:void 0,max:void 0},i={min:t.price,max:void 0},r={amount:{min:t.amount,max:void 0},price:i,cost:s},a={darkpool:!1,info:void 0,maker:void 0,taker:void 0,active:!1,precision:t,limits:r},o=[];for(let d=0;d<o.length;d++)e.push(this.extend(a,o[d]));return e}async fetchCurrencies(e={}){const t=await this.publicGetAssets(e),s=this.safeValue(t,"result",{}),i=Object.keys(s),n={};for(let r=0;r<i.length;r++){const a=i[r],o=s[a],d=this.safeCurrencyCode(this.safeString(o,"altname")),c=this.parseNumber(this.parsePrecision(this.safeString(o,"decimals"))),u=!this.inArray(d,this.options.inactiveCurrencies);n[d]={id:a,code:d,info:o,name:d,active:u,deposit:void 0,withdraw:void 0,fee:void 0,precision:c,limits:{amount:{min:c,max:void 0},withdraw:{min:void 0,max:void 0}}}}return n}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id,"fee-info":!0},n=await this.privatePostTradeVolume(this.extend(i,t)),r=this.safeValue(n,"result",{});return this.parseTradingFee(r,s)}parseTradingFee(e,t){const s=this.safeValue(e,"fees_maker",{}),i=this.safeValue(e,"fees",{}),n=this.safeValue(s,t.id,{}),r=this.safeValue(i,t.id,{});return{info:e,symbol:t.symbol,maker:this.safeNumber(n,"fee"),taker:this.safeNumber(r,"fee"),percentage:!0,tierBased:!0}}parseBidAsk(e,t=0,s=1){const i=this.safeNumber(e,t),n=this.safeNumber(e,s),r=this.safeInteger(e,2);return[i,n,r]}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);if(i.darkpool)throw new Cc(this.id+" fetchOrderBook() does not provide an order book for darkpool symbol "+e);const n={pair:i.id};t!==void 0&&(n.count=t);const r=await this.publicGetDepth(this.extend(n,s)),a=this.safeValue(r,"result",{});let o=this.safeValue(a,i.id);const d=this.safeValue(i,"info",{}),c=this.safeValue(d,"wsname");return c!==void 0&&(o=this.safeValue(a,c,o)),this.parseOrderBook(o,e)}parseTicker(e,t=void 0){const s=this.milliseconds(),i=this.safeSymbol(void 0,t),n=this.safeValue(e,"v",[]),r=this.safeString(n,1),a=this.safeValue(e,"p",[]),o=this.safeString(a,1),d=Ra.stringMul(r,o),c=this.safeValue(e,"c",[]),u=this.safeString(c,0),h=this.safeValue(e,"h",[]),l=this.safeValue(e,"l",[]),p=this.safeValue(e,"b",[]),m=this.safeValue(e,"a",[]);return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(h,1),low:this.safeString(l,1),bid:this.safeString(p,0),bidVolume:void 0,ask:this.safeString(m,0),askVolume:void 0,vwap:o,open:this.safeString(e,"o"),close:u,last:u,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:d,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};if(e!==void 0){e=this.marketSymbols(e);const o=[];for(let d=0;d<e.length;d++){const c=e[d],u=this.markets[c];u.active&&!u.darkpool&&o.push(u.id)}s.pair=o.join(",")}const n=(await this.publicGetTicker(this.extend(s,t))).result,r=Object.keys(n),a={};for(let o=0;o<r.length;o++){const d=r[o],c=this.safeMarket(d),u=c.symbol,h=n[d];a[u]=this.parseTicker(h,c)}return this.filterByArray(a,"symbol",e)}async fetchTicker(e,t={}){if(await this.loadMarkets(),e.indexOf(".d")>=0)throw new Cc(this.id+" fetchTicker() does not provide a ticker for darkpool symbol "+e);const i=this.market(e),n={pair:i.id},a=(await this.publicGetTicker(this.extend(n,t))).result[i.id];return this.parseTicker(a,i)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,6)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id,interval:this.timeframes[t]};s!==void 0&&(a.since=parseInt((s-1)/1e3));const o=await this.publicGetOHLC(this.extend(a,n)),d=this.safeValue(o,"result",{}),c=this.safeValue(d,r.id,[]);return this.parseOHLCVs(c,r,t,s,i)}parseLedgerEntryType(e){const t={trade:"trade",withdrawal:"transaction",deposit:"transaction",transfer:"transfer",margin:"margin"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"id");let i;const n=void 0,r=this.safeString(e,"refid"),a=void 0,o=this.parseLedgerEntryType(this.safeString(e,"type")),d=this.safeCurrencyCode(this.safeString(e,"asset"),t);let c=this.safeString(e,"amount");Ra.stringLt(c,"0")?(i="out",c=Ra.stringAbs(c)):i="in";const u=this.safeNumber(e,"time");let h;return u!==void 0&&(h=parseInt(u*1e3)),{info:e,id:s,direction:i,account:n,referenceId:r,referenceAccount:a,type:o,currency:d,amount:this.parseNumber(c),before:void 0,after:this.safeNumber(e,"balance"),status:"ok",timestamp:h,datetime:this.iso8601(h),fee:{cost:this.safeNumber(e,"fee"),currency:d}}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.asset=r.id),t!==void 0&&(n.start=parseInt(t/1e3));const a=await this.privatePostLedgers(this.extend(n,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"ledger",{}),c=Object.keys(d),u=[];for(let h=0;h<c.length;h++){const l=c[h],p=d[l];p.id=l,u.push(p)}return this.parseLedger(u,r,t,s)}async fetchLedgerEntriesByIds(e,t=void 0,s={}){await this.loadMarkets(),e=e.join(",");const i=this.extend({id:e},s),r=(await this.privatePostQueryLedgers(i)).result,a=Object.keys(r),o=[];for(let d=0;d<a.length;d++){const c=a[d],u=r[c];u.id=c,o.push(u)}return this.parseLedger(o)}async fetchLedgerEntry(e,t=void 0,s={}){return(await this.fetchLedgerEntriesByIds([e],t,s))[0]}parseTrade(e,t=void 0){let s,i,n,r,a,o,d,c,u;if(Array.isArray(e))s=this.safeTimestamp(e,2),i=e[3]==="s"?"sell":"buy",n=e[4]==="l"?"limit":"market",r=this.safeString(e,0),a=this.safeString(e,1),e.length>6&&(o=this.safeString(e,6));else if(typeof e=="string")o=e;else if("ordertxid"in e){const l=this.safeString(e,"pair"),p=this.findMarketByAltnameOrId(l);if(p!==void 0?t=p:l!==void 0&&(t=this.getDelistedMarketById(l)),d=this.safeString(e,"ordertxid"),o=this.safeString2(e,"id","postxid"),s=this.safeTimestamp(e,"time"),i=this.safeString(e,"type"),n=this.safeString(e,"ordertype"),r=this.safeString(e,"price"),a=this.safeString(e,"vol"),"fee"in e){let m;t!==void 0&&(m=t.quote),c={cost:this.safeString(e,"fee"),currency:m}}}t!==void 0&&(u=t.symbol);const h=this.safeString(e,"cost");return this.safeTrade({id:o,order:d,info:e,timestamp:s,datetime:this.iso8601(s),symbol:u,type:n,side:i,takerOrMaker:void 0,price:r,amount:a,cost:h,fee:c},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r=n.id,a={pair:r};if(t!==void 0&&(a.since=t*1e6,a.since=t.toString()+"000000"),s!==void 0&&s!==1e3&&this.safeValue(this.options,"fetchTradesWarning",!0))throw new Cc(this.id+" fetchTrades() cannot serve "+s.toString()+" trades without breaking the pagination, see https://github.com/ccxt/ccxt/issues/5698 for more details. Set exchange.options['fetchTradesWarning'] to acknowledge this warning and silence it.");const d=(await this.publicGetTrades(this.extend(a,i))).result,c=d[r],u=c.length;if(u<=0)return[];const h=c[u-1],l=this.safeString(d,"last");return h.push(l),this.parseTrades(c,n,t,s)}parseBalance(e){const t=this.safeValue(e,"result",{}),s={info:e,timestamp:void 0,datetime:void 0},i=Object.keys(t);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(t,r),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalance(e);return this.parseBalance(t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const o={pair:this.market(e).id,type:s,ordertype:t,volume:this.amountToPrecision(e,i)},d=this.safeString2(r,"userref","clientOrderId");if(r=this.omit(r,["userref","clientOrderId"]),d!==void 0&&(o.userref=d),t==="limit")o.price=this.priceToPrecision(e,n);else if(t==="stop-loss"||t==="take-profit"){const l=this.safeNumber2(r,"price","stopPrice",n);if(l===void 0)throw new _c(this.id+" createOrder() requires a price argument or a price/stopPrice parameter for a "+t+" order");o.price=this.priceToPrecision(e,l)}else if(t==="stop-loss-limit"||t==="take-profit-limit"){const l=this.safeNumber2(r,"price","stopPrice"),p=this.safeNumber(r,"price2"),m=l!==void 0,g=p!==void 0;if(m&&g)o.price=this.priceToPrecision(e,l),o.price2=this.priceToPrecision(e,p);else{if(n===void 0||!(m||g))throw new _c(this.id+" createOrder() requires a price argument and/or price/stopPrice/price2 parameters for a "+t+" order");m?(o.price=this.priceToPrecision(e,l),o.price2=this.priceToPrecision(e,n)):g&&(o.price=this.priceToPrecision(e,n),o.price2=this.priceToPrecision(e,p))}}let c=this.safeValue(r,"close");if(c!==void 0){c=this.extend({},c);const l=this.safeValue(c,"price");l!==void 0&&(c.price=this.priceToPrecision(e,l));const p=this.safeValue(c,"price2");p!==void 0&&(c.price2=this.priceToPrecision(e,p)),o.close=c}r=this.omit(r,["price","stopPrice","price2","close"]);const u=await this.privatePostAddOrder(this.extend(o,r)),h=this.safeValue(u,"result");return this.parseOrder(h)}findMarketByAltnameOrId(e){return e in this.marketsByAltname?this.marketsByAltname[e]:this.safeMarket(e)}getDelistedMarketById(e){if(e===void 0)return e;let t=this.safeValue(this.options.delistedMarketsById,e);if(t!==void 0)return t;const s=0;let i=3,n=3,r=6;e.length===8?(i=4,n=4,r=8):e.length===7&&(i=4,n=4,r=7);const a=e.slice(s,i),o=e.slice(n,r),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o);return t={symbol:d+"/"+c,base:d,quote:c,baseId:a,quoteId:o},this.options.delistedMarketsById[e]=t,t}parseOrderStatus(e){const t={pending:"open",open:"open",closed:"closed",canceled:"canceled",expired:"expired"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeValue(e,"descr",{}),i=this.safeString(s,"order");let n,r,a,o,d,c;if(i!==void 0){const k=i.split(" ");n=this.safeString(k,0),d=this.safeString(k,1),a=this.safeString(k,2),r=this.safeString(k,4),r==="stop"?(c=this.safeString(k,6),o=this.safeString(k,9)):r==="limit"&&(o=this.safeString(k,5))}n=this.safeString(s,"type",n),r=this.safeString(s,"ordertype",r),a=this.safeString(s,"pair",a);const u=this.findMarketByAltnameOrId(a);let h;u!==void 0?t=u:a!==void 0&&(t=this.getDelistedMarketById(a));const l=this.safeTimestamp(e,"opentm");d=this.safeString(e,"vol",d);const p=this.safeString(e,"vol_exec");let m;o=this.safeString(s,"price",o),(o===void 0||Ra.stringEquals(o,"0"))&&(o=this.safeString(s,"price2")),(o===void 0||Ra.stringEquals(o,"0"))&&(o=this.safeString(e,"price",o));const g=this.safeNumber(e,"price");if(t!==void 0&&(h=t.symbol,"fee"in e)){const k=e.oflags;m={cost:this.safeString(e,"fee"),rate:void 0},k.indexOf("fciq")>=0?m.currency=t.quote:k.indexOf("fcib")>=0&&(m.currency=t.base)}const y=this.parseOrderStatus(this.safeString(e,"status"));let b=this.safeString(e,"id");if(b===void 0){const k=this.safeValue(e,"txid");b=this.safeString(k,0)}const w=this.safeString(e,"userref"),S=this.safeValue(e,"trades");return c=this.safeNumber(e,"stopprice",c),this.safeOrder({id:b,clientOrderId:w,info:e,timestamp:l,datetime:this.iso8601(l),lastTradeTimestamp:void 0,status:y,symbol:h,type:r,timeInForce:void 0,postOnly:void 0,side:n,price:o,stopPrice:c,cost:void 0,amount:d,filled:p,average:g,remaining:void 0,fee:m,trades:S},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue2(s,"userref","clientOrderId"),n={trades:!0};let r=s;i!==void 0?(n.userref=i,r=this.omit(s,["userref","clientOrderId"])):n.txid=e;const a=await this.privatePostQueryOrders(this.extend(n,r)),o=this.safeValue(a,"result",[]);if(!(e in o))throw new bv(this.id+" fetchOrder() could not find order id "+e);const d=this.parseOrder(this.extend({id:e},o[e]));return this.extend({info:a},d)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){const r=this.safeValue(n,"trades"),a=[];if(r===void 0)throw new _c(this.id+" fetchOrderTrades() requires a unified order structure in the params argument or a 'trades' param (an array of trade id strings)");for(let l=0;l<r.length;l++){const p=r[l];typeof p=="string"?a.push(p):a.push(p.id)}await this.loadMarkets(),t!==void 0&&(t=this.symbol(t));const o=this.safeValue(this.options,"fetchOrderTrades",{}),d=this.safeInteger(o,"batchSize",20),c=a.length;let u=parseInt(c/d);u=this.sum(u,1);let h=[];for(let l=0;l<u;l++){const p=[];for(let k=0;k<d;k++){const T=this.sum(l*d,k);T<c&&p.push(a[T])}const m={txid:p.join(",")},g=await this.privatePostQueryTrades(m),y=this.safeValue(g,"result"),b=Object.keys(y);for(let k=0;k<b.length;k++)y[b[k]].id=b[k];const w=this.parseTrades(y,void 0,s,i),S=this.filterBySymbol(w,t);h=this.arrayConcat(h,S)}return h}async fetchOrdersByIds(e,t=void 0,s={}){await this.loadMarkets();const i=await this.privatePostQueryOrders(this.extend({trades:!0,txid:e.join(",")},s)),n=this.safeValue(i,"result",{}),r=[],a=Object.keys(n);for(let o=0;o<a.length;o++){const d=a[o],c=n[d],u=this.parseOrder(this.extend({id:d},c));r.push(u)}return r}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.start=parseInt(t/1e3));const a=(await this.privatePostTradesHistory(this.extend(n,i))).result.trades,o=Object.keys(a);for(let c=0;c<o.length;c++)a[o[c]].id=o[c];let d;return e!==void 0&&(d=this.market(e)),this.parseTrades(a,d,t,s)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();let i;const r={txid:this.safeValue2(s,"userref","clientOrderId",e)};s=this.omit(s,["userref","clientOrderId"]);try{i=await this.privatePostCancelOrder(this.extend(r,s))}catch(a){throw this.last_http_response&&this.last_http_response.indexOf("EOrder:Unknown order")>=0?new bv(this.id+" cancelOrder() error "+this.last_http_response):a}return i}async cancelOrders(e,t=void 0,s={}){const i={orders:e};return await this.privatePostCancelOrderBatch(this.extend(i,s))}async cancelAllOrders(e=void 0,t={}){return await this.loadMarkets(),await this.privatePostCancelAll(t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.start=parseInt(t/1e3));let r=i;const a=this.safeValue2(i,"userref","clientOrderId");a!==void 0&&(n.userref=a,r=this.omit(i,["userref","clientOrderId"]));const o=await this.privatePostOpenOrders(this.extend(n,r));let d;e!==void 0&&(d=this.market(e));const c=this.safeValue(o,"result",{}),u=this.safeValue(c,"open",[]);return this.parseOrders(u,d,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.start=parseInt(t/1e3));let r=i;const a=this.safeValue2(i,"userref","clientOrderId");a!==void 0&&(n.userref=a,r=this.omit(i,["userref","clientOrderId"]));const o=await this.privatePostClosedOrders(this.extend(n,r));let d;e!==void 0&&(d=this.market(e));const c=this.safeValue(o,"result",{}),u=this.safeValue(c,"closed",[]);return this.parseOrders(u,d,t,s)}parseTransactionStatus(e){const t={Initial:"pending",Pending:"pending",Success:"ok",Settled:"pending",Failure:"failed",Partial:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"refid"),i=this.safeString(e,"txid"),n=this.safeTimestamp(e,"time"),r=this.safeString(e,"asset"),a=this.safeCurrencyCode(r,t),o=this.safeString(e,"info"),d=this.safeNumber(e,"amount");let c=this.parseTransactionStatus(this.safeString(e,"status"));const u=this.safeString(e,"status-prop");(u==="on-hold"||u==="cancel-pending"||u==="onhold")&&(c="pending");const m=this.safeString(e,"type");let g=this.safeNumber(e,"fee");return g===void 0&&m==="deposit"&&(g=0),{info:e,id:s,currency:a,amount:d,network:void 0,address:o,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,status:c,type:m,updated:void 0,txid:i,timestamp:n,datetime:this.iso8601(n),fee:{currency:a,cost:g}}}parseTransactionsByType(e,t,s=void 0,i=void 0,n=void 0){const r=[];for(let a=0;a<t.length;a++){const o=this.parseTransaction(this.extend({type:e},t[a]));r.push(o)}return this.filterByCurrencySinceLimit(r,s,i,n)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new _c(this.id+" fetchDeposits() requires a currency code argument");await this.loadMarkets();const r={asset:this.currency(e).id},a=await this.privatePostDepositStatus(this.extend(r,i));return this.parseTransactionsByType("deposit",a.result,e,t,s)}async fetchTime(e={}){const t=await this.publicGetTime(e),s=this.safeValue(t,"result",{});return this.safeTimestamp(s,"unixtime")}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new _c(this.id+" fetchWithdrawals() requires a currency code argument");await this.loadMarkets();const r={asset:this.currency(e).id},a=await this.privatePostWithdrawStatus(this.extend(r,i));return this.parseTransactionsByType("withdrawal",a.result,e,t,s)}async createDepositAddress(e,t={}){const s={new:"true"};return await this.fetchDepositAddress(e,this.extend(s,t))}async fetchDepositMethods(e,t={}){await this.loadMarkets();const i={asset:this.currency(e).id},n=await this.privatePostDepositMethods(this.extend(i,t));return this.safeValue(n,"result")}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e);let i=this.safeStringUpper(t,"network");const n=this.safeValue(this.options,"networks",{});i=this.safeString(n,i,i),t=this.omit(t,"network"),e==="USDT"&&i==="TRC20"&&(e=e+"-"+i);const r=this.safeValue(this.options,"depositMethods",{}),a=this.safeString(r,e);let o=this.safeString(t,"method",a);if(o===void 0){const l=await this.fetchDepositMethods(e);if(i!==void 0)for(let p=0;p<l.length;p++){const m=this.safeString(l[p],"method");if(m.indexOf(i)>=0){o=m;break}}if(o===void 0){const p=this.safeValue(l,0,{});o=this.safeString(p,"method")}}const d={asset:s.id,method:o},c=await this.privatePostDepositAddresses(this.extend(d,t)),u=this.safeValue(c,"result",[]),h=this.safeValue(u,0,{});if(h===void 0)throw new kv(this.id+" privatePostDepositAddresses() returned no addresses for "+e);return this.parseDepositAddress(h,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"tag");t=this.safeCurrency(void 0,t);const n=t.code;return this.checkAddress(s),{currency:n,address:s,tag:i,network:void 0,info:e}}async withdraw(e,t,s,i=void 0,n={}){if([i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),"key"in n){await this.loadMarkets();const r=this.currency(e),a={asset:r.id,amount:t},o=await this.privatePostWithdraw(this.extend(a,n)),d=this.safeValue(o,"result",{});return this.parseTransaction(d,r)}throw new Cc(this.id+" withdraw() requires a 'key' parameter (withdrawal key name, as set up on your account)")}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s={},i=await this.privatePostOpenPositions(this.extend(s,t));return this.safeValue(i,"result")}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.version+"/"+t+"/"+e;if(t==="public")Object.keys(i).length&&(a+="?"+this.urlencodeNested(i));else if(t==="private"){const o=e==="CancelOrderBatch";this.checkRequiredCredentials();const d=this.nonce().toString();o?r=this.json(this.extend({nonce:d},i)):r=this.urlencodeNested(this.extend({nonce:d},i));const c=this.encode(d+r),u=this.hash(c,"sha256","binary"),h=this.stringToBinary(this.encode(a)),l=this.binaryConcat(h,u),p=this.base64ToBinary(this.secret),m=this.hmac(l,p,"sha512","base64");n={"API-Key":this.apiKey,"API-Sign":m},o?n["Content-Type"]="application/json":n["Content-Type"]="application/x-www-form-urlencoded"}else a="/"+e;return a=this.urls.api[t]+a,{url:a,method:s,body:r,headers:n}}nonce(){return this.milliseconds()}handleErrors(e,t,s,i,n,r,a,o,d){if(e===520)throw new xc(this.id+" "+e.toString()+" "+t);if(r.indexOf("Invalid order")>=0)throw new zf(this.id+" "+r);if(r.indexOf("Invalid nonce")>=0)throw new wv(this.id+" "+r);if(r.indexOf("Insufficient funds")>=0)throw new Sv(this.id+" "+r);if(r.indexOf("Cancel pending")>=0)throw new WD(this.id+" "+r);if(r.indexOf("Invalid arguments:volume")>=0)throw new zf(this.id+" "+r);if(r.indexOf("Rate limit exceeded")>=0)throw new zD(this.id+" "+r);if(a!==void 0&&r[0]==="{"&&typeof a!="string"&&"error"in a&&a.error.length){const u=this.id+" "+r;for(let h=0;h<a.error.length;h++){const l=a.error[h];this.throwExactlyMatchedException(this.exceptions,l,u)}throw new Cc(u)}}};const ZD=me,{ExchangeError:Lo,ExchangeNotAvailable:q0,InsufficientFunds:Mc,OrderNotFound:L0,InvalidOrder:Sn,AccountSuspended:JD,InvalidNonce:eH,NotSupported:Kf,BadRequest:Pc,AuthenticationError:Fa,BadSymbol:vv,RateLimitExceeded:Tv,PermissionDenied:Ov,InvalidAddress:tH}=oe,{TICK_SIZE:sH}=pe,Ro=ke;var Ib=class extends ZD{describe(){return this.deepExtend(super.describe(),{id:"kucoin",name:"KuCoin",countries:["SC"],rateLimit:50,version:"v2",certified:!0,pro:!0,comment:"Platform 2.0",quoteJsonNumbers:!1,has:{CORS:void 0,spot:!0,margin:!0,swap:!1,future:!1,option:void 0,borrowMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBorrowInterest:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!0,fetchBorrowRates:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchL3OrderBook:!0,fetchLedger:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrdersByStatus:!0,fetchOrderTrades:!0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactionFee:!0,fetchWithdrawals:!0,repayMargin:!0,setMarginMode:!1,transfer:!0,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/51840849/87295558-132aaf80-c50e-11ea-9801-a2fb0c57c799.jpg",referral:"https://www.kucoin.com/ucenter/signup?rcode=E5wkqe",api:{public:"https://api.kucoin.com",private:"https://api.kucoin.com",futuresPrivate:"https://api-futures.kucoin.com",futuresPublic:"https://api-futures.kucoin.com"},test:{public:"https://openapi-sandbox.kucoin.com",private:"https://openapi-sandbox.kucoin.com",futuresPrivate:"https://api-sandbox-futures.kucoin.com",futuresPublic:"https://api-sandbox-futures.kucoin.com"},www:"https://www.kucoin.com",doc:["https://docs.kucoin.com"]},requiredCredentials:{apiKey:!0,secret:!0,password:!0},api:{public:{get:{timestamp:1,status:1,symbols:1,markets:1,"market/allTickers":1,"market/orderbook/level{level}_{limit}":1,"market/orderbook/level2_20":1,"market/orderbook/level2_100":1,"market/histories":1,"market/candles":1,"market/stats":1,currencies:1,"currencies/{currency}":1,prices:1,"mark-price/{symbol}/current":1,"margin/config":1,"margin/trade/last":1},post:{"bullet-public":1}},private:{get:{"market/orderbook/level{level}":1,"market/orderbook/level2":{v3:2},"market/orderbook/level3":1,accounts:1,"accounts/{accountId}":1,"accounts/ledgers":3.333,"accounts/{accountId}/holds":1,"accounts/transferable":1,"base-fee":1,"sub/user":1,"user-info":1,"sub/api-key":1,"sub-accounts":1,"sub-accounts/{subUserId}":1,"deposit-addresses":1,deposits:10,"hist-deposits":10,"hist-withdrawals":10,withdrawals:10,"withdrawals/quotas":1,orders:2,"order/client-order/{clientOid}":1,"orders/{orderId}":1,"limit/orders":1,fills:6.66667,"limit/fills":1,"isolated/accounts":2,"isolated/account/{symbol}":2,"isolated/borrow/outstanding":2,"isolated/borrow/repaid":2,"isolated/symbols":2,"margin/account":1,"margin/borrow":1,"margin/borrow/outstanding":1,"margin/borrow/repaid":1,"margin/lend/active":1,"margin/lend/done":1,"margin/lend/trade/unsettled":1,"margin/lend/trade/settled":1,"margin/lend/assets":1,"margin/market":1,"stop-order/{orderId}":1,"stop-order":1,"stop-order/queryOrderByClientOid":1,"trade-fees":1.3333},post:{accounts:1,"accounts/inner-transfer":{v2:1},"accounts/sub-transfer":{v2:25},"deposit-addresses":1,withdrawals:1,orders:4,"orders/multi":20,"isolated/borrow":2,"isolated/repay/all":2,"isolated/repay/single":2,"margin/borrow":1,"margin/order":1,"margin/repay/all":1,"margin/repay/single":1,"margin/lend":1,"margin/toggle-auto-lend":1,"bullet-private":1,"stop-order":1,"sub/user":1,"sub/api-key":1,"sub/api-key/update":1},delete:{"withdrawals/{withdrawalId}":1,orders:20,"order/client-order/{clientOid}":1,"orders/{orderId}":1,"margin/lend/{orderId}":1,"stop-order/cancelOrderByClientOid":1,"stop-order/{orderId}":1,"stop-order/cancel":1,"sub/api-key":1}},futuresPublic:{get:{"contracts/active":1.3953,"contracts/{symbol}":1.3953,ticker:1.3953,"level2/snapshot":2,"level2/depth20":1.3953,"level2/depth100":1.3953,"level2/message/query":1.3953,"level3/message/query":1.3953,"level3/snapshot":1.3953,"trade/history":1.3953,"interest/query":1.3953,"index/query":1.3953,"mark-price/{symbol}/current":1.3953,"premium/query":1.3953,"funding-rate/{symbol}/current":1.3953,timestamp:1.3953,status:1.3953,"kline/query":1.3953},post:{"bullet-public":1.3953}},futuresPrivate:{get:{"account-overview":2,"transaction-history":6.666,"deposit-address":1.3953,"deposit-list":1.3953,"withdrawals/quotas":1.3953,"withdrawal-list":1.3953,"transfer-list":1.3953,orders:1.3953,stopOrders:1.3953,recentDoneOrders:1.3953,"orders/{orderId}":1.3953,"orders/byClientOid":1.3953,fills:6.666,recentFills:6.666,openOrderStatistics:1.3953,position:1.3953,positions:6.666,"funding-history":6.666},post:{withdrawals:1.3953,"transfer-out":1.3953,orders:1.3953,"position/margin/auto-deposit-status":1.3953,"position/margin/deposit-margin":1.3953,"bullet-private":1.3953},delete:{"withdrawals/{withdrawalId}":1.3953,"cancel/transfer-out":1.3953,"orders/{orderId}":1.3953,orders:6.666,stopOrders:1.3953}}},timeframes:{"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","2h":"2hour","4h":"4hour","6h":"6hour","8h":"8hour","12h":"12hour","1d":"1day","1w":"1week"},precisionMode:sH,exceptions:{exact:{"order not exist":L0,"order not exist.":L0,order_not_exist:L0,order_not_exist_or_not_allow_to_cancel:Sn,"Order size below the minimum requirement.":Sn,"The withdrawal amount is below the minimum requirement.":Lo,"Unsuccessful! Exceeded the max. funds out-transfer limit":Mc,400:Pc,401:Fa,403:Kf,404:Kf,405:Kf,429:Tv,500:q0,503:q0,101030:Ov,103e3:Sn,200004:Mc,210014:Sn,210021:Mc,230003:Mc,260100:Mc,3e5:Sn,4e5:vv,400001:Fa,400002:eH,400003:Fa,400004:Fa,400005:Fa,400006:Fa,400007:Fa,400008:Kf,400100:Pc,400200:Sn,400350:Sn,400370:Sn,400500:Sn,400600:vv,400760:Sn,401e3:Pc,411100:JD,415e3:Pc,5e5:q0,260220:tH,900014:Pc},broad:{"Exceeded the access frequency":Tv,"require more permission":Ov}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0.001"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("50"),this.parseNumber("0.001")],[this.parseNumber("200"),this.parseNumber("0.0009")],[this.parseNumber("500"),this.parseNumber("0.0008")],[this.parseNumber("1000"),this.parseNumber("0.0007")],[this.parseNumber("2000"),this.parseNumber("0.0007")],[this.parseNumber("4000"),this.parseNumber("0.0006")],[this.parseNumber("8000"),this.parseNumber("0.0005")],[this.parseNumber("15000"),this.parseNumber("0.00045")],[this.parseNumber("25000"),this.parseNumber("0.0004")],[this.parseNumber("40000"),this.parseNumber("0.00035")],[this.parseNumber("60000"),this.parseNumber("0.0003")],[this.parseNumber("80000"),this.parseNumber("0.00025")]],maker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("50"),this.parseNumber("0.0009")],[this.parseNumber("200"),this.parseNumber("0.0007")],[this.parseNumber("500"),this.parseNumber("0.0005")],[this.parseNumber("1000"),this.parseNumber("0.0003")],[this.parseNumber("2000"),this.parseNumber("0")],[this.parseNumber("4000"),this.parseNumber("0")],[this.parseNumber("8000"),this.parseNumber("0")],[this.parseNumber("15000"),this.parseNumber("-0.00005")],[this.parseNumber("25000"),this.parseNumber("-0.00005")],[this.parseNumber("40000"),this.parseNumber("-0.00005")],[this.parseNumber("60000"),this.parseNumber("-0.00005")],[this.parseNumber("80000"),this.parseNumber("-0.00005")]]}},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}},commonCurrencies:{HOT:"HOTNOW",EDGE:"DADI",WAX:"WAXP",TRY:"Trias",VAI:"VAIOT"},options:{version:"v1",symbolSeparator:"-",fetchMyTradesMethod:"private_get_fills",fetchBalance:"trade",fetchMarkets:{fetchTickersFees:!0},versions:{public:{GET:{"currencies/{currency}":"v2",status:"v1","market/orderbook/level2_20":"v1","market/orderbook/level2_100":"v1","market/orderbook/level{level}_{limit}":"v1"}},private:{GET:{"market/orderbook/level2":"v3","market/orderbook/level3":"v3","market/orderbook/level{level}":"v3","deposit-addresses":"v1"},POST:{"accounts/inner-transfer":"v2","accounts/sub-transfer":"v2",accounts:"v2"}},futuresPrivate:{GET:{"account-overview":"v1",positions:"v1"},POST:{"transfer-out":"v2"}},futuresPublic:{GET:{"level3/snapshot":"v2"}}},partner:{spot:{id:"ccxt",key:"9e58cc35-5b5e-4133-92ec-166e3f077cb8"},future:{id:"ccxtfutures",key:"1b327198-f30c-4f14-a0ac-918871282f15"}},accountsByType:{spot:"trade",margin:"margin",cross:"margin",isolated:"isolated",main:"main",funding:"main",future:"contract",mining:"pool"},networks:{Native:"bech32","BTC-Segwit":"btc",ERC20:"eth",BEP20:"bsc",TRC20:"trx",TERRA:"luna",BNB:"bsc",HRC20:"heco",HT:"heco"}}})}nonce(){return this.milliseconds()}async fetchTime(e={}){const t=await this.publicGetTimestamp(e);return this.safeInteger(t,"data")}async fetchStatus(e={}){const t=await this.publicGetStatus(e),s=this.safeValue(t,"data",{});return{status:this.safeString(s,"status")==="open"?"ok":"maintenance",updated:void 0,eta:void 0,url:void 0,info:t}}async fetchMarkets(e={}){const t=await this.publicGetSymbols(e),s=this.safeValue(t,"data"),i=this.safeValue(this.options,"fetchMarkets",{}),n=this.safeValue(i,"fetchTickersFees",!0);let r={};n&&(r=await this.publicGetMarketAllTickers(e));const a=this.safeValue(r,"data",{}),o=this.safeValue(a,"ticker",[]),d=this.indexBy(o,"symbol"),c=[];for(let u=0;u<s.length;u++){const h=s[u],l=this.safeString(h,"symbol"),[p,m]=l.split("-"),g=this.safeCurrencyCode(p),y=this.safeCurrencyCode(m),b=this.safeValue(d,l,{}),w=this.safeString(b,"makerFeeRate"),S=this.safeString(b,"makerFeeRate"),k=this.safeString(b,"makerCoefficient"),T=this.safeString(b,"takerCoefficient");c.push({id:l,symbol:g+"/"+y,base:g,quote:y,settle:void 0,baseId:p,quoteId:m,settleId:void 0,type:"spot",spot:!0,margin:this.safeValue(h,"isMarginEnabled"),swap:!1,future:!1,option:!1,active:this.safeValue(h,"enableTrading"),contract:!1,linear:void 0,inverse:void 0,taker:this.parseNumber(Ro.stringMul(S,T)),maker:this.parseNumber(Ro.stringMul(w,k)),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(h,"baseIncrement"),price:this.safeNumber(h,"priceIncrement")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(h,"baseMinSize"),max:this.safeNumber(h,"baseMaxSize")},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(h,"quoteMinSize"),max:this.safeNumber(h,"quoteMaxSize")}},info:h})}return c}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeString(r,"fullName"),d=this.safeCurrencyCode(a),c=this.safeValue(r,"isWithdrawEnabled",!1),u=this.safeValue(r,"isDepositEnabled",!1),h=this.safeNumber(r,"withdrawalMinFee"),l=c&&u;i[d]={id:a,name:o,code:d,precision:this.parseNumber(this.parsePrecision(this.safeString(r,"precision"))),info:r,active:l,deposit:u,withdraw:c,fee:h,limits:this.limits}}return i}async fetchAccounts(e={}){const t=await this.privateGetAccounts(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"id"),o=this.safeString(r,"currency"),d=this.safeCurrencyCode(o),c=this.safeString(r,"type");i.push({id:a,type:c,currency:d,info:r})}return i}async fetchTransactionFee(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper2(t,"network","chain");r=this.safeStringLower(n,r,r),r!==void 0&&(r=r.toLowerCase(),i.chain=r.toLowerCase(),t=this.omit(t,["network","chain"]));const a=await this.privateGetWithdrawalsQuotas(this.extend(i,t)),o=a.data,d={};return d[e]=this.safeNumber(o,"withdrawMinFee"),{info:a,withdraw:d,deposit:{}}}isFuturesMethod(e,t){const s=this.safeString2(this.options,e,"defaultType","trade"),i=this.safeString(t,"type",s),n=this.safeValue(this.options,"accountsByType"),r=this.safeString(n,i);if(r===void 0){const a=Object.keys(n);throw new Lo(this.id+" isFuturesMethod() type must be one of "+a.join(", "))}return t=this.omit(t,"type"),r==="contract"||r==="future"||r==="futures"}parseTicker(e,t=void 0){let s=this.safeString(e,"changeRate");s!==void 0&&(s=Ro.stringMul(s,"100"));let i=this.safeString2(e,"last","lastTradedPrice");i=this.safeString(e,"price",i);const n=this.safeString(e,"symbol");t=this.safeMarket(n,t,"-");const r=t.symbol,a=this.safeString(e,"vol"),o=this.safeString(e,"volValue"),d=this.safeInteger2(e,"time","datetime");return this.safeTicker({symbol:r,timestamp:d,datetime:this.iso8601(d),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString2(e,"buy","bestBid"),bidVolume:this.safeString(e,"bestBidSize"),ask:this.safeString2(e,"sell","bestAsk"),askVolume:this.safeString(e,"bestAskSize"),vwap:void 0,open:this.safeString(e,"open"),close:i,last:i,previousClose:void 0,change:this.safeString(e,"changePrice"),percentage:s,average:this.safeString(e,"averagePrice"),baseVolume:a,quoteVolume:o,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetMarketAllTickers(t),i=this.safeValue(s,"data",{}),n=this.safeValue(i,"ticker",[]),r=this.safeInteger(i,"time"),a={};for(let o=0;o<n.length;o++){n[o].time=r;const d=this.parseTicker(n[o]),c=this.safeString(d,"symbol");c!==void 0&&(a[c]=d)}return this.filterByArray(a,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetMarketStats(this.extend(i,t));return this.parseTicker(n.data,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),o={symbol:r.id,type:this.timeframes[t]},d=this.parseTimeframe(t)*1e3;let c=this.milliseconds();s!==void 0?(o.startAt=parseInt(Math.floor(s/1e3)),i===void 0&&(i=this.safeInteger(this.options,"fetchOHLCVLimit",1500)),c=this.sum(s,i*d)):i!==void 0&&(s=c-i*d,o.startAt=parseInt(Math.floor(s/1e3))),o.endAt=parseInt(Math.floor(c/1e3));const u=await this.publicGetMarketCandles(this.extend(o,n)),h=this.safeValue(u,"data",[]);return this.parseOHLCVs(h,r,t,s,i)}async createDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper2(t,"chain","network");r=this.safeStringLower(n,r,r),r!==void 0&&(r=r.toLowerCase(),i.chain=r,t=this.omit(t,["chain","network"]));const a=await this.privatePostDepositAddresses(this.extend(i,t)),o=this.safeValue(a,"data",{});let d=this.safeString(o,"address");d!==void 0&&(d=d.replace("bitcoincash:",""));const c=this.safeString(o,"memo");return e!=="NIM"&&this.checkAddress(d),{info:a,currency:e,network:this.safeString(o,"chain"),address:d,tag:c}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper2(t,"chain","network");r=this.safeStringLower(n,r,r),r!==void 0&&(r=r.toLowerCase(),i.chain=r,t=this.omit(t,["chain","network"]));const a=this.options.versions.private.GET["deposit-addresses"];this.options.versions.private.GET["deposit-addresses"]="v1";const o=await this.privateGetDepositAddresses(this.extend(i,t));this.options.versions.private.GET["deposit-addresses"]=a;const d=this.safeValue(o,"data",{});return this.parseDepositAddress(d,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=t.id;return i!=="NIM"&&this.checkAddress(s),{info:e,currency:i,address:s,tag:this.safeString(e,"memo"),network:this.safeString(e,"chain")}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=this.options.versions.private.GET["deposit-addresses"];this.options.versions.private.GET["deposit-addresses"]="v2";const r=await this.privateGetDepositAddresses(this.extend(i,t));this.options.versions.private.GET["deposit-addresses"]=n;const a=this.safeValue(r,"data",[]);return this.parseDepositAddressesByNetwork(a,s)}parseDepositAddressesByNetwork(e,t=void 0){const s=[];for(let i=0;i<e.length;i++){const n=e[i];s.push({info:n,currency:this.safeCurrencyCode(t.id,t),network:this.safeString(n,"chain"),address:this.safeString(n,"address"),tag:this.safeString(n,"memo")})}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n=this.safeInteger(s,"level",2),r={symbol:i.id};let a="publicGetMarketOrderbookLevelLevelLimit";const o=this.checkRequiredCredentials(!1);let d;if(!o||t!==void 0){if(n===2){if(r.level=n,t!==void 0)if(t===20||t===100)r.limit=t;else throw new Lo(this.id+" fetchOrderBook() limit argument must be 20 or 100");r.limit=t||100}}else a="privateGetMarketOrderbookLevel2";d=await this[a](this.extend(r,s));const c=this.safeValue(d,"data",{}),u=this.safeInteger(c,"time"),h=this.parseOrderBook(c,i.symbol,u,"bids","asks",n-2,n-1);return h.nonce=this.safeInteger(c,"sequence"),h}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.marketId(e),o=this.safeString2(r,"clientOid","clientOrderId",this.uuid());r=this.omit(r,["clientOid","clientOrderId"]);const d={clientOid:o,side:s,symbol:a,type:t},c=this.safeNumber2(r,"cost","funds");let u,h;t==="market"?c!==void 0?(r=this.omit(r,["cost","funds"]),h=this.amountToPrecision(e,c),d.funds=h):(u=this.amountToPrecision(e,i),d.size=this.amountToPrecision(e,i)):(u=this.amountToPrecision(e,i),d.size=u,d.price=this.priceToPrecision(e,n));const l=this.safeValue(r,"stopLossPrice"),p=this.safeValue2(r,"takeProfitPrice","stopPrice"),m=l!==void 0,g=p!==void 0;if(m&&g)throw new Lo(this.id+" createOrder() stopLossPrice and takeProfitPrice cannot both be defined");const y=this.safeString(r,"tradeType");r=this.omit(r,["stopLossPrice","takeProfitPrice","stopPrice"]);let b="privatePostOrders";if(m||g){d.stop=m?"entry":"loss";const _=m?l:p;d.stopPrice=this.priceToPrecision(e,_),b="privatePostStopOrder"}else y==="MARGIN_TRADE"&&(b="privatePostMarginOrder");const w=await this[b](this.extend(d,r)),S=this.safeValue(w,"data",{}),k=this.milliseconds();return{id:this.safeString(S,"orderId"),clientOrderId:o,info:S,timestamp:k,datetime:this.iso8601(k),lastTradeTimestamp:void 0,symbol:e,type:t,side:s,price:n,amount:this.parseNumber(u),cost:this.parseNumber(h),average:void 0,filled:void 0,remaining:void 0,status:void 0,fee:void 0,trades:void 0}}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={},n=this.safeString2(s,"clientOid","clientOrderId"),r=this.safeValue(s,"stop");let a="privateDeleteOrdersOrderId";return n!==void 0?(i.clientOid=n,r?a="privateDeleteStopOrderCancelOrderByClientOid":a="privateDeleteOrderClientOrderClientOid"):(r&&(a="privateDeleteStopOrderOrderId"),i.orderId=e),s=this.omit(s,["clientOid","clientOrderId","stop"]),await this[a](this.extend(i,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;e!==void 0&&(i=this.market(e),s.symbol=i.id);let n="privateDeleteOrders";return this.safeValue(t,"stop")&&(n="privateDeleteStopOrderCancel"),await this[n](this.extend(s,t))}async fetchOrdersByStatus(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r=e.toLowerCase();r==="open"?r="active":r==="closed"&&(r="done");const a={status:r};let o;t!==void 0&&(o=this.market(t),a.symbol=o.id),s!==void 0&&(a.startAt=s),i!==void 0&&(a.pageSize=i);const d=this.safeInteger2(n,"until","till");d&&(a.endAt=d);const c=this.safeValue(n,"stop");n=this.omit(n,["stop","till","until"]);let u="privateGetOrders";c&&(u="privateGetStopOrder");const h=await this[u](this.extend(a,n)),l=this.safeValue(h,"data",{}),p=this.safeValue(l,"items",[]);return this.parseOrders(p,o,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("done",e,t,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("active",e,t,s,i)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={},n=this.safeString2(s,"clientOid","clientOrderId"),r=this.safeValue(s,"stop");let a;t!==void 0&&(a=this.market(t)),s=this.omit(s,"stop");let o="privateGetOrdersOrderId";if(n!==void 0)i.clientOid=n,r?(o="privateGetStopOrderQueryOrderByClientOid",t!==void 0&&(i.symbol=a.id)):o="privateGetOrderClientOrderClientOid";else{if(e===void 0)throw new Sn(this.id+" fetchOrder() requires an order id");r&&(o="privateGetStopOrderOrderId"),i.orderId=e}s=this.omit(s,["clientOid","clientOrderId"]);const d=await this[o](this.extend(i,s));let c=this.safeValue(d,"data");return o==="privateGetStopOrderQueryOrderByClientOid"&&(c=this.safeValue(c,0)),this.parseOrder(c,a)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t,"-"),n=this.safeString(e,"id"),r=this.safeString(e,"type"),a=this.safeInteger(e,"createdAt"),o=this.iso8601(a),d=this.safeString(e,"price"),c=this.safeString(e,"side"),u=this.safeString(e,"feeCurrency"),h=this.safeCurrencyCode(u),l=this.safeNumber(e,"fee"),p=this.safeString(e,"size"),m=this.safeString(e,"dealSize"),g=this.safeString(e,"dealFunds"),y=this.safeValue(e,"isActive",!1),b=this.safeValue(e,"cancelExist",!1),w=this.safeString(e,"stop"),S=this.safeValue(e,"stopTriggered",!1);let k=y?"open":"closed";k=b||!y&&w&&!S?"canceled":k;const I={currency:h,cost:l},_=this.safeString(e,"clientOid"),N=this.safeString(e,"timeInForce"),M=this.safeNumber(e,"stopPrice"),x=this.safeValue(e,"postOnly");return this.safeOrder({id:n,clientOrderId:_,symbol:i,type:r,timeInForce:N,postOnly:x,side:c,amount:p,price:d,stopPrice:M,cost:g,filled:m,remaining:void 0,timestamp:a,datetime:o,fee:I,status:k,info:e,lastTradeTimestamp:void 0,average:void 0,trades:void 0},t)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){const r={orderId:e};return await this.fetchMyTrades(t,s,i,this.extend(r,n))}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),s!==void 0&&(n.pageSize=s);const a=this.options.fetchMyTradesMethod;let o=!1;if(a==="private_get_fills")t!==void 0&&(n.startAt=t);else if(a==="private_get_limit_fills")o=!0;else if(a==="private_get_hist_orders")t!==void 0&&(n.startAt=parseInt(t/1e3));else throw new Lo(this.id+" fetchMyTradesMethod() invalid method");const d=await this[a](this.extend(n,i)),c=this.safeValue(d,"data",{});let u;return o?u=c:u=this.safeValue(c,"items",[]),this.parseTrades(u,r,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.publicGetMarketHistories(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,"-");const i=this.safeString2(e,"tradeId","id"),n=this.safeString(e,"orderId"),r=this.safeString(e,"liquidity");let a=this.safeInteger(e,"time");a!==void 0?a=parseInt(a/1e6):(a=this.safeInteger(e,"createdAt"),"dealValue"in e&&a!==void 0&&(a=a*1e3));const o=this.safeString2(e,"price","dealPrice"),d=this.safeString2(e,"size","amount"),c=this.safeString(e,"side");let u;const h=this.safeString(e,"fee");if(h!==void 0){const m=this.safeString(e,"feeCurrency");let g=this.safeCurrencyCode(m);g===void 0&&(g=c==="sell"?t.quote:t.base),u={cost:h,currency:g,rate:this.safeString(e,"feeRate")}}let l=this.safeString(e,"type");l==="match"&&(l=void 0);const p=this.safeString2(e,"funds","dealValue");return this.safeTrade({info:e,id:i,order:n,timestamp:a,datetime:this.iso8601(a),symbol:t.symbol,type:l,takerOrMaker:r,side:c,price:o,amount:d,cost:p,fee:u},t)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbols:s.id},n=await this.privateGetTradeFees(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0),o=this.safeString(a,"symbol");return{info:n,symbol:this.safeSymbol(o,s),maker:this.safeNumber(a,"makerFeeRate"),taker:this.safeNumber(a,"takerFeeRate"),percentage:!0,tierBased:!0}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets(),this.checkAddress(s);const r=this.currency(e),a={currency:r.id,address:s,amount:t};i!==void 0&&(a.memo=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeStringLower(o,d,d),d!==void 0&&(d=d.toLowerCase(),a.chain=d,n=this.omit(n,"network"));const c=await this.privatePostWithdrawals(this.extend(a,n)),u=this.safeValue(c,"data",{});return this.parseTransaction(u,r)}parseTransactionStatus(e){const t={SUCCESS:"ok",PROCESSING:"ok",FAILURE:"failed"};return this.safeString(t,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"currency"),i=this.safeCurrencyCode(s,t);let n=this.safeString(e,"address");const r=this.safeString(e,"amount");let a=this.safeString(e,"walletTxId");if(a!==void 0){const y=a.split("@");y.length>1&&n===void 0&&y[1].length>1&&(n=y[1]),a=y[0]}let o=a===void 0?"withdrawal":"deposit";const d=this.safeString(e,"status");let c;const u=this.safeString(e,"fee");if(u!==void 0){let y;r!==void 0&&(y=Ro.stringDiv(u,r)),c={cost:this.parseNumber(u),rate:this.parseNumber(y),currency:i}}let h=this.safeInteger2(e,"createdAt","createAt"),l=this.safeInteger(e,"updatedAt");!("createdAt"in e)&&(o="address"in e?"withdrawal":"deposit",h!==void 0&&(h=h*1e3),l!==void 0&&(l=l*1e3));const m=this.safeString(e,"memo"),g=this.safeString(e,"chain");return{info:e,id:this.safeString2(e,"id","withdrawalId"),timestamp:h,datetime:this.iso8601(h),network:g,address:n,addressTo:n,addressFrom:void 0,tag:m,tagTo:m,tagFrom:void 0,currency:i,amount:this.parseNumber(r),txid:a,type:o,status:this.parseTransactionStatus(d),comment:this.safeString(e,"remark"),fee:c,updated:l}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.pageSize=s);let a="privateGetDeposits";t!==void 0&&(t<1550448e6?(n.startAt=parseInt(t/1e3),a="privateGetHistDeposits"):n.startAt=t);const d=(await this[a](this.extend(n,i))).data.items;return this.parseTransactions(d,r,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.pageSize=s);let a="privateGetWithdrawals";t!==void 0&&(t<1550448e6?(n.startAt=parseInt(t/1e3),a="privateGetHistWithdrawals"):n.startAt=t);const d=(await this[a](this.extend(n,i))).data.items;return this.parseTransactions(d,r,t,s,{type:"withdrawal"})}parseBalanceHelper(e){const t=this.account();t.used=this.safeString(e,"holdBalance"),t.free=this.safeString(e,"availableBalance"),t.total=this.safeString(e,"totalBalance");const s=this.safeString(e,"liability"),i=this.safeString(e,"interest");return t.debt=Ro.stringAdd(s,i),t}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"code");let s;t!==void 0&&(s=this.currency(t));const i=this.safeString2(this.options,"fetchBalance","defaultType","spot"),n=this.safeString(e,"type",i),r=this.safeValue(this.options,"accountsByType"),a=this.safeString(r,n,n);e=this.omit(e,"type");const[o,d]=this.handleMarginModeAndParams("fetchBalance",e);let c="privateGetAccounts";const u={},h=o==="isolated"||a==="isolated",l=o==="cross"||a==="cross";h?(c="privateGetIsolatedAccounts",s!==void 0&&(u.balanceCurrency=s.id)):l?c="privateGetMarginAccount":(s!==void 0&&(u.currency=s.id),u.type=a);const p=await this[c](this.extend(u,d)),m=this.safeValue(p,"data",[]),g={info:p,timestamp:void 0,datetime:void 0};if(h){const y=this.safeValue(m,"assets",[]);for(let b=0;b<y.length;b++){const w=y[b],S=this.safeString(w,"symbol"),k=this.safeSymbol(S,void 0,"_"),T=this.safeValue(w,"baseAsset",{}),I=this.safeValue(w,"quoteAsset",{}),_=this.safeCurrencyCode(this.safeString(T,"currency")),N=this.safeCurrencyCode(this.safeString(I,"currency")),M={};M[_]=this.parseBalanceHelper(T),M[N]=this.parseBalanceHelper(I),g[k]=this.safeBalance(M)}}else if(l){const y=this.safeValue(m,"accounts",[]);for(let b=0;b<y.length;b++){const w=y[b],S=this.safeString(w,"currency"),k=this.safeCurrencyCode(S);g[k]=this.parseBalanceHelper(w)}}else for(let y=0;y<m.length;y++){const b=m[y];if(this.safeString(b,"type")===a){const S=this.safeString(b,"currency"),k=this.safeCurrencyCode(S),T=this.account();T.total=this.safeString(b,"balance"),T.free=this.safeString(b,"available"),T.used=this.safeString(b,"holds"),g[k]=T}}return h?g:this.safeBalance(g)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.currencyToPrecision(e,t);let o=this.convertTypeToAccount(s),d=this.convertTypeToAccount(i);const c=this.inArray(o,this.ids),u=this.inArray(d,this.ids);if(o==="contract"){if(d!=="main")throw new Lo(this.id+" transfer() only supports transferring from futures account to main account");const h={currency:r.id,amount:a};"bizNo"in n||(h.bizNo=this.uuid22());const l=await this.futuresPrivatePostTransferOut(this.extend(h,n)),p=this.safeValue(l,"data");return this.parseTransfer(p,r)}else{const h={currency:r.id,amount:a};(c||u)&&(this.inArray(o,this.ids)&&(h.fromTag=o,o="isolated"),this.inArray(d,this.ids)&&(h.toTag=d,d="isolated")),h.from=o,h.to=d,"clientOid"in n||(h.clientOid=this.uuid());const l=await this.privatePostAccountsInnerTransfer(this.extend(h,n)),p=this.safeValue(l,"data"),m=this.parseTransfer(p,r);return this.extend(m,{amount:a,fromAccount:o,toAccount:d})}}parseTransfer(e,t=void 0){const s=this.safeInteger(e,"createdAt"),i=this.safeString(e,"currency"),n=this.safeString(e,"status"),r=this.safeStringLower(e,"payAccountType"),a=this.safeStringLower(e,"recAccountType"),o=this.safeValue(this.options,"accountsByType"),d=this.safeString(o,r,r),c=this.safeString(o,a,a);return{id:this.safeString2(e,"applyId","orderId"),currency:this.safeCurrencyCode(i,t),timestamp:s,datetime:this.iso8601(s),amount:this.safeNumber(e,"amount"),fromAccount:d,toAccount:c,status:this.parseTransferStatus(n),info:e}}parseTransferStatus(e){const t={PROCESSING:"pending"};return this.safeString(t,e,e)}parseLedgerEntryType(e){const t={"Assets Transferred in After Upgrading":"transfer",Deposit:"transaction",Withdrawal:"transaction",Transfer:"transfer",Trade_Exchange:"trade","KuCoin Bonus":"bonus","Referral Bonus":"referral",Rewards:"bonus","Airdrop/Fork":"airdrop","Other rewards":"bonus","Fee Rebate":"rebate","Buy Crypto":"trade","Sell Crypto":"sell","Public Offering Purchase":"trade","Refunded Fees":"fee","KCS Pay Fees":"fee","Margin Trade":"trade",Loans:"Loans","Instant Exchange":"trade","Sub-account transfer":"transfer","Liquidation Fees":"fee"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"currency"),n=this.safeCurrencyCode(i,t),r=this.safeNumber(e,"amount"),a=void 0,o=this.safeString(e,"bizType"),d=this.parseLedgerEntryType(o),c=this.safeString(e,"direction"),u=this.safeInteger(e,"createdAt"),h=this.iso8601(u),l=this.safeString(e,"accountType"),p=this.safeString(e,"context");let m;if(p!==void 0&&p!=="")try{const w=JSON.parse(p),S=this.safeString(w,"orderId"),k=this.safeString(w,"tradeId");k!==void 0?m=k:m=S}catch{m=p}let g;const y=this.safeNumber(e,"fee");let b;return y!==0&&(b=n,g={cost:y,currency:b}),{id:s,direction:c,account:l,referenceId:m,referenceAccount:l,type:d,currency:n,amount:r,timestamp:u,datetime:h,before:void 0,after:a,status:void 0,fee:g,info:e}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.loadAccounts();const n={};t!==void 0&&(n.startAt=t);let r;e!==void 0&&(r=this.currency(e),n.currency=r.id);const a=await this.privateGetAccountsLedgers(this.extend(n,i)),o=this.safeValue(a,"data"),d=this.safeValue(o,"items");return this.parseLedger(d,r,t,s)}calculateRateLimiterCost(e,t,s,i,n={},r={}){const a=this.safeValue(this.options,"versions",{}),o=this.safeValue(a,e,{}),d=this.safeValue(o,t,{}),c=this.safeString(d,s,this.options.version),u=this.safeString(i,"version",c);return u==="v3"&&"v3"in n?n.v3:u==="v2"&&"v2"in n?n.v2:u==="v1"&&"v1"in n?n.v1:this.safeValue(n,"cost",1)}async fetchBorrowRateHistory(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={currency:this.currency(e).id},a=await this.privateGetMarginTradeLast(this.extend(r,i)),o=this.safeValue(a,"data",{});return this.parseBorrowRateHistory(o,e)}parseBorrowRateHistory(e,t,s,i){const n=[];for(let a=0;a<e.length;a++){const o=e[a],d=this.parseBorrowRate(o);n.push(d)}const r=this.sortBy(n,"timestamp");return this.filterByCurrencySinceLimit(r,t,s,i)}parseBorrowRate(e,t=void 0){const s=this.safeString(e,"timestamp"),i=Ro.stringMul(s,"0.000001"),n=this.safeString(e,"currency");return{currency:this.safeCurrencyCode(n,t),rate:this.safeNumber(e,"dailyIntRate"),period:864e5,timestamp:i,datetime:this.iso8601(i),info:e}}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;[r,n]=this.handleMarginModeAndParams("fetchBorrowInterest",n),r===void 0&&(r="cross");const a={};let o="privateGetMarginBorrowOutstanding";if(r==="isolated"){if(e!==void 0){const h=this.currency(e);a.balanceCurrency=h.id}o="privateGetIsolatedAccounts"}else if(e!==void 0){const h=this.currency(e);a.currency=h.id}const d=await this[o](this.extend(a,n)),c=this.safeValue(d,"data",{}),u=r==="isolated"?this.safeValue(c,"assets",[]):this.safeValue(c,"items",[]);return this.parseBorrowInterests(u,void 0)}parseBorrowInterest(e,t=void 0){const s=this.safeString(e,"symbol"),i=s===void 0?"cross":"isolated";t=this.safeMarket(s,t);const n=this.safeString(t,"symbol"),r=this.safeInteger(e,"createdAt"),a=this.safeValue(e,"baseAsset",{});let o,d,c;return i==="isolated"?(o=this.safeNumber(a,"liability"),d=this.safeNumber(a,"interest"),c=this.safeString(a,"currency")):(o=this.safeNumber(e,"principal"),d=this.safeNumber(e,"accruedInterest"),c=this.safeString(e,"currency")),{symbol:n,marginMode:i,currency:this.safeCurrencyCode(c),interest:d,interestRate:this.safeNumber(e,"dailyIntRate"),amountBorrowed:o,timestamp:r,datetime:this.iso8601(r),info:e}}async borrowMargin(e,t,s=void 0,i={}){const n=this.safeString(i,"marginMode");i=this.omit(i,"marginMode"),this.checkRequiredMarginArgument("borrowMargin",s,n),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,size:this.currencyToPrecision(e,t)};let o;const d=this.safeStringN(i,["timeInForce","type","borrowStrategy"],"IOC");let c;if(s===void 0)o="privatePostMarginBorrow",c="type";else{const l=this.market(s);a.symbol=l.id,c="borrowStrategy",o="privatePostIsolatedBorrow"}a[c]=d,i=this.omit(i,["timeInForce","type","borrowStrategy"]);const u=await this[o](this.extend(a,i)),h=this.safeValue(u,"data",{});return this.parseMarginLoan(h,r)}async repayMargin(e,t,s=void 0,i={}){const n=this.safeString(i,"marginMode");i=this.omit(i,"marginMode"),this.checkRequiredMarginArgument("repayMargin",s,n),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,size:this.currencyToPrecision(e,t)};let o;const d=this.safeString2(i,"sequence","seqStrategy","RECENTLY_EXPIRE_FIRST");let c;if(s===void 0)o="privatePostMarginRepayAll",c="sequence";else{const h=this.market(s);a.symbol=h.id,c="seqStrategy",o="privatePostIsolatedRepayAll"}a[c]=d,i=this.omit(i,["sequence","seqStrategy"]);const u=await this[o](this.extend(a,i));return this.parseMarginLoan(u,r)}parseMarginLoan(e,t=void 0){const s=this.milliseconds(),i=this.safeString(e,"currency");return{id:this.safeString(e,"orderId"),currency:this.safeCurrencyCode(i,t),amount:this.safeNumber(e,"actualSize"),symbol:void 0,timestamp:s,datetime:this.iso8601(s),info:e}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.safeValue(this.options,"versions",{}),o=this.safeValue(a,t,{}),d=this.safeValue(o,s,{}),c=this.safeString(d,e,this.options.version),u=this.safeString(i,"version",c);i=this.omit(i,"version");let h="/api/"+u+"/"+this.implodeParams(e,i);const l=this.omit(i,this.extractParams(e));let p="";n=n!==void 0?n:{};let m=this.urls.api[t];const g=m.indexOf("sandbox")>=0;e==="symbols"&&!g&&(h="/api/v2/"+this.implodeParams(e,i)),Object.keys(l).length&&(s==="GET"||s==="DELETE"?h+="?"+this.rawencode(l):(r=this.json(l),p=r,n["Content-Type"]="application/json")),m=m+h;const y=t==="futuresPrivate";if(t==="private"||y){this.checkRequiredCredentials();const w=this.nonce().toString();if(n=this.extend({"KC-API-KEY-VERSION":"2","KC-API-KEY":this.apiKey,"KC-API-TIMESTAMP":w},n),this.safeString(n,"KC-API-KEY-VERSION")==="2"){const M=this.hmac(this.encode(this.password),this.encode(this.secret),"sha256","base64");n["KC-API-PASSPHRASE"]=M}else n["KC-API-PASSPHRASE"]=this.password;const k=w+s+h+p,T=this.hmac(this.encode(k),this.encode(this.secret),"sha256","base64");n["KC-API-SIGN"]=T;let I=this.safeValue(this.options,"partner",{});I=y?this.safeValue(I,"future",I):this.safeValue(I,"spot",I);const _=this.safeString(I,"id"),N=this.safeString2(I,"secret","key");if(_!==void 0&&N!==void 0){const M=w+_+this.apiKey,x=this.hmac(this.encode(M),this.encode(N),"sha256","base64");n["KC-API-PARTNER-SIGN"]=x,n["KC-API-PARTNER"]=_}}return{url:m,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(!a){this.throwBroadlyMatchedException(this.exceptions.broad,r,r);return}const c=this.safeString(a,"code"),u=this.safeString(a,"msg",""),h=this.id+" "+u;this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwExactlyMatchedException(this.exceptions.exact,c,h),this.throwBroadlyMatchedException(this.exceptions.broad,r,h)}};const{ArgumentsRequired:R0,ExchangeNotAvailable:F0,InvalidOrder:Xf,InsufficientFunds:Yf,AccountSuspended:iH,InvalidNonce:nH,NotSupported:Qf,OrderNotFound:rH,BadRequest:oi,AuthenticationError:Da,RateLimitExceeded:aH,PermissionDenied:oH}=oe,Xs=ke,dH=Ib,{TICK_SIZE:cH}=pe;var uH=class extends dH{describe(){return this.deepExtend(super.describe(),{id:"kucoinfutures",name:"KuCoin Futures",countries:["SC"],rateLimit:75,version:"v1",certified:!1,pro:!1,comment:"Platform 2.0",quoteJsonNumbers:!1,has:{CORS:void 0,spot:!1,margin:!1,swap:!0,future:!0,option:!1,addMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!1,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!1,fetchIndexOHLCV:!1,fetchL3OrderBook:!0,fetchLedger:!0,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarketLeverageTiers:!0,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!1,fetchTime:!0,fetchTrades:!0,fetchTransactionFee:!0,fetchWithdrawals:!0,setMarginMode:!1,transfer:!0,withdraw:void 0},urls:{logo:"https://user-images.githubusercontent.com/1294454/147508995-9e35030a-d046-43a1-a006-6fabd981b554.jpg",doc:["https://docs.kucoin.com/futures","https://docs.kucoin.com"],www:"https://futures.kucoin.com/",referral:"https://futures.kucoin.com/?rcode=E5wkqe",api:{public:"https://openapi-v2.kucoin.com",private:"https://openapi-v2.kucoin.com",futuresPrivate:"https://api-futures.kucoin.com",futuresPublic:"https://api-futures.kucoin.com"},test:{public:"https://openapi-sandbox.kucoin.com",private:"https://openapi-sandbox.kucoin.com",futuresPrivate:"https://api-sandbox-futures.kucoin.com",futuresPublic:"https://api-sandbox-futures.kucoin.com"}},requiredCredentials:{apiKey:!0,secret:!0,password:!0},api:{futuresPublic:{get:{"contracts/active":1,"contracts/{symbol}":1,"contracts/risk-limit/{symbol}":1,ticker:1,"level2/snapshot":1.33,"level2/depth{limit}":1,"level2/message/query":1,"level3/message/query":1,"level3/snapshot":1,"trade/history":1,"interest/query":1,"index/query":1,"mark-price/{symbol}/current":1,"premium/query":1,"funding-rate/{symbol}/current":1,timestamp:1,status:1,"kline/query":1},post:{"bullet-public":1}},futuresPrivate:{get:{"account-overview":1.33,"transaction-history":4.44,"deposit-address":1,"deposit-list":1,"withdrawals/quotas":1,"withdrawal-list":1,"transfer-list":1,orders:1.33,stopOrders:1,recentDoneOrders:1,"orders/{orderId}":1,"orders/byClientOid":1,fills:4.44,recentFills:4.44,openOrderStatistics:1,position:1,positions:4.44,"funding-history":4.44},post:{withdrawals:1,"transfer-out":1,orders:1.33,"position/margin/auto-deposit-status":1,"position/margin/deposit-margin":1,"bullet-private":1},delete:{"withdrawals/{withdrawalId}":1,"cancel/transfer-out":1,"orders/{orderId}":1,orders:4.44,stopOrders:1}}},precisionMode:cH,exceptions:{exact:{400:oi,401:Da,403:Qf,404:Qf,405:Qf,415:oi,429:aH,500:F0,503:F0,100001:Xf,100004:oi,101030:oH,200004:Yf,230003:Yf,260100:Yf,300003:Yf,300012:Xf,400001:Da,400002:nH,400003:Da,400004:Da,400005:Da,400006:Da,400007:Da,404e3:Qf,400100:oi,411100:iH,5e5:F0},broad:{"Position does not exist":rH}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0006"),maker:this.parseNumber("0.0002"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.0006")],[this.parseNumber("50"),this.parseNumber("0.0006")],[this.parseNumber("200"),this.parseNumber("0.0006")],[this.parseNumber("500"),this.parseNumber("0.0005")],[this.parseNumber("1000"),this.parseNumber("0.0004")],[this.parseNumber("2000"),this.parseNumber("0.0004")],[this.parseNumber("4000"),this.parseNumber("0.00038")],[this.parseNumber("8000"),this.parseNumber("0.00035")],[this.parseNumber("15000"),this.parseNumber("0.00032")],[this.parseNumber("25000"),this.parseNumber("0.0003")],[this.parseNumber("40000"),this.parseNumber("0.0003")],[this.parseNumber("60000"),this.parseNumber("0.0003")],[this.parseNumber("80000"),this.parseNumber("0.0003")]],maker:[[this.parseNumber("0"),this.parseNumber("0.02")],[this.parseNumber("50"),this.parseNumber("0.015")],[this.parseNumber("200"),this.parseNumber("0.01")],[this.parseNumber("500"),this.parseNumber("0.01")],[this.parseNumber("1000"),this.parseNumber("0.01")],[this.parseNumber("2000"),this.parseNumber("0")],[this.parseNumber("4000"),this.parseNumber("0")],[this.parseNumber("8000"),this.parseNumber("0")],[this.parseNumber("15000"),this.parseNumber("-0.003")],[this.parseNumber("25000"),this.parseNumber("-0.006")],[this.parseNumber("40000"),this.parseNumber("-0.009")],[this.parseNumber("60000"),this.parseNumber("-0.012")],[this.parseNumber("80000"),this.parseNumber("-0.015")]]}},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}},commonCurrencies:{HOT:"HOTNOW",EDGE:"DADI",WAX:"WAXP",TRY:"Trias",VAI:"VAIOT",XBT:"BTC"},timeframes:{"1m":1,"3m":void 0,"5m":5,"15m":15,"30m":30,"1h":60,"2h":120,"4h":240,"6h":void 0,"8h":480,"12h":720,"1d":1440,"1w":10080},options:{version:"v1",symbolSeparator:"-",defaultType:"swap",code:"USDT",marginModes:{},marginTypes:{},versions:{futuresPrivate:{POST:{"transfer-out":"v2"}},futuresPublic:{GET:{"level3/snapshot":"v2"}}},networks:{OMNI:"omni",ERC20:"eth",TRC20:"trx"}}})}async fetchAccounts(e={}){throw new oi(this.id+" fetchAccounts() is not supported yet")}async fetchStatus(e={}){const t=await this.futuresPublicGetStatus(e),s=this.safeValue(t,"data",{});return{status:this.safeString(s,"status")==="open"?"ok":"maintenance",updated:void 0,eta:void 0,url:void 0,info:t}}async fetchMarkets(e={}){const t=await this.futuresPublicGetContractsActive(e),s=[],i=this.safeValue(t,"data",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"symbol"),o=this.safeInteger(r,"expireDate"),d=!!o,c=!d,u=this.safeString(r,"baseCurrency"),h=this.safeString(r,"quoteCurrency"),l=this.safeString(r,"settleCurrency"),p=this.safeCurrencyCode(u),m=this.safeCurrencyCode(h),g=this.safeCurrencyCode(l);let y=p+"/"+m+":"+g,b="swap";d&&(y=y+"-"+this.yymmdd(o,""),b="future");const w=this.safeValue(r,"isInverse"),S=this.safeString(r,"status"),k=this.safeString(r,"multiplier"),T=this.safeNumber(r,"tickSize"),I=this.safeNumber(r,"lotSize");let _=I;_===void 0&&(_=this.safeNumber(r,"baseMinSize"));let N=this.safeNumber(r,"maxOrderQty");N===void 0&&(N=this.safeNumber(r,"baseMaxSize"));let M=this.safeNumber(r,"maxPrice");if(M===void 0){const x=this.safeString(r,"baseMinSize"),v=this.safeString(r,"quoteMaxSize");M=this.parseNumber(Xs.stringDiv(v,x))}s.push({id:a,symbol:y,base:p,quote:m,settle:g,baseId:u,quoteId:h,settleId:l,type:b,spot:!1,margin:!1,swap:c,future:d,option:!1,active:S==="Open",contract:!0,linear:!w,inverse:w,taker:this.safeNumber(r,"takerFeeRate"),maker:this.safeNumber(r,"makerFeeRate"),contractSize:this.parseNumber(Xs.stringAbs(k)),expiry:o,expiryDatetime:this.iso8601(o),strike:void 0,optionType:void 0,precision:{amount:I,price:T},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(r,"maxLeverage")},amount:{min:_,max:N},price:{min:T,max:M},cost:{min:this.safeNumber(r,"quoteMinSize"),max:this.safeNumber(r,"quoteMaxSize")}},info:r})}return s}async fetchTime(e={}){const t=await this.futuresPublicGetTimestamp(e);return this.safeNumber(t,"data")}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),o={symbol:r.id,granularity:this.timeframes[t]},d=this.parseTimeframe(t)*1e3;let c=this.milliseconds();s!==void 0?(o.from=s,i===void 0&&(i=this.safeInteger(this.options,"fetchOHLCVLimit",200)),c=this.sum(s,i*d)):i!==void 0&&(s=c-i*d,o.from=s),o.to=c;const u=await this.futuresPublicGetKlineQuery(this.extend(o,n)),h=this.safeValue(u,"data",[]);return this.parseOHLCVs(h,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async createDepositAddress(e,t={}){throw new oi(this.id+" createDepositAddress() is not supported yet")}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i=this.currency(e).id,n={currency:i},r=await this.futuresPrivateGetDepositAddress(this.extend(n,t)),a=this.safeValue(r,"data",{}),o=this.safeString(a,"address");return i!=="NIM"&&this.checkAddress(o),{info:r,currency:i,address:o,tag:this.safeString(a,"memo"),network:this.safeString(a,"chain")}}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeNumber(s,"level");if(i!==2&&i!==void 0)throw new oi(this.id+" fetchOrderBook() can only return level 2");const n=this.market(e),r={symbol:n.id};if(t!==void 0)if(t===20||t===100)r.limit=t;else throw new oi(this.id+" fetchOrderBook() limit argument must be 20 or 100");else r.limit=20;const a=await this.futuresPublicGetLevel2DepthLimit(this.extend(r,s)),o=this.safeValue(a,"data",{}),d=parseInt(this.safeInteger(o,"ts")/1e6),c=this.parseOrderBook(o,n.symbol,d,"bids","asks",0,1);return c.nonce=this.safeInteger(o,"sequence"),c}async fetchL3OrderBook(e,t=void 0,s={}){throw new oi(this.id+" fetchL3OrderBook() is not supported yet")}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.futuresPublicGetTicker(this.extend(i,t));return this.parseTicker(n.data,s)}parseTicker(e,t=void 0){const s=this.safeString(e,"price"),i=this.safeString(e,"symbol");t=this.safeMarket(i,t,"-");const n=this.safeIntegerProduct(e,"ts",1e-6);return this.safeTicker({symbol:t.symbol,timestamp:n,datetime:this.iso8601(n),high:void 0,low:void 0,bid:this.safeString(e,"bestBidPrice"),bidVolume:this.safeString(e,"bestBidSize"),ask:this.safeString(e,"bestAskPrice"),askVolume:this.safeString(e,"bestAskSize"),vwap:void 0,open:void 0,close:s,last:s,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:void 0,info:e},t)}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new R0(this.id+" fetchFundingHistory() requires a symbol argument");await this.loadMarkets();const r={symbol:this.market(e).id};t!==void 0&&(r.startAt=t),s!==void 0&&(r.maxCount=s);const a=await this.futuresPrivateGetFundingHistory(this.extend(r,i)),o=this.safeValue(a,"data"),d=this.safeValue(o,"dataList",[]),c=[];for(let u=0;u<d.length;u++){const h=d[u],l=this.safeInteger(h,"timePoint");c.push({info:h,symbol:e,code:this.safeCurrencyCode(this.safeString(h,"settleCurrency")),timestamp:l,datetime:this.iso8601(l),id:this.safeNumber(h,"id"),amount:this.safeNumber(h,"funding"),fundingRate:this.safeNumber(h,"fundingRate"),markPrice:this.safeNumber(h,"markPrice"),positionQty:this.safeNumber(h,"positionQty"),positionCost:this.safeNumber(h,"positionCost")})}return c}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.futuresPrivateGetPositions(t),i=this.safeValue(s,"data");return this.parsePositions(i,e)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeNumber(e,"currentTimestamp"),n=this.safeString(e,"currentQty");let r;Xs.stringGt(n,"0")?r="long":Xs.stringLt(n,"0")&&(r="short");const a=Xs.stringAbs(this.safeString(e,"posCost")),o=this.safeString(e,"posInit"),d=Xs.stringDiv(o,a),c=this.safeString(e,"unrealisedPnl"),h=this.safeValue(e,"crossMode")?"cross":"isolated";return{info:e,id:void 0,symbol:this.safeString(t,"symbol"),timestamp:i,datetime:this.iso8601(i),initialMargin:this.parseNumber(o),initialMarginPercentage:this.parseNumber(d),maintenanceMargin:this.safeNumber(e,"posMaint"),maintenanceMarginPercentage:this.safeNumber(e,"maintMarginReq"),entryPrice:this.safeNumber(e,"avgEntryPrice"),notional:this.parseNumber(a),leverage:this.safeNumber(e,"realLeverage"),unrealizedPnl:this.parseNumber(c),contracts:this.parseNumber(Xs.stringAbs(n)),contractSize:this.safeValue(t,"contractSize"),marginRatio:void 0,liquidationPrice:this.safeNumber(e,"liquidationPrice"),markPrice:this.safeNumber(e,"markPrice"),collateral:this.safeNumber(e,"maintMargin"),marginMode:h,side:r,percentage:this.parseNumber(Xs.stringDiv(c,o))}}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeString2(r,"clientOid","clientOrderId",this.uuid());if(r=this.omit(r,["clientOid","clientOrderId"]),i<1)throw new Xf(this.id+" createOrder() minimum contract order amount is 1");const d=parseInt(this.amountToPrecision(e,i)),c={clientOid:o,side:s,symbol:a.id,type:t,size:d,leverage:1},u=this.safeValue2(r,"triggerPrice","stopPrice");if(u){c.stop=s==="buy"?"up":"down";const w=this.safeString(r,"stopPriceType","TP");c.stopPriceType=w,c.stopPrice=this.priceToPrecision(e,u)}const h=t.toUpperCase(),l=this.safeStringUpper(r,"timeInForce");if(h==="LIMIT"){if(n===void 0)throw new R0(this.id+" createOrder() requires a price argument for limit orders");c.price=this.priceToPrecision(e,n),l!==void 0&&(c.timeInForce=l)}const p=this.safeValue(r,"postOnly",!1),m=this.safeValue(r,"hidden");if(p&&m!==void 0)throw new oi(this.id+" createOrder() does not support the postOnly parameter together with a hidden parameter");if(this.safeValue(r,"iceberg")&&this.safeValue(r,"visibleSize")===void 0)throw new R0(this.id+" createOrder() requires a visibleSize parameter for iceberg orders");r=this.omit(r,["timeInForce","stopPrice","triggerPrice"]);const y=await this.futuresPrivatePostOrders(this.extend(c,r)),b=this.safeValue(y,"data",{});return{id:this.safeString(b,"orderId"),clientOrderId:void 0,timestamp:void 0,datetime:void 0,lastTradeTimestamp:void 0,symbol:void 0,type:void 0,side:void 0,price:void 0,amount:void 0,cost:void 0,average:void 0,filled:void 0,remaining:void 0,status:void 0,fee:void 0,trades:void 0,timeInForce:void 0,postOnly:void 0,stopPrice:void 0,info:y}}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e},n=await this.futuresPrivateDeleteOrdersOrderId(this.extend(i,s));return this.safeValue(n,"data")}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};e!==void 0&&(s.symbol=this.marketId(e));const n=this.safeValue(t,"stop")?"futuresPrivateDeleteStopOrders":"futuresPrivateDeleteOrders",r=await this[n](this.extend(s,t));return this.safeValue(r,"data")}async addMargin(e,t,s={}){await this.loadMarkets();const i=this.market(e),n=this.uuid(),r={symbol:i.id,margin:this.amountToPrecision(e,t),bizNo:n},a=await this.futuresPrivatePostPositionMarginDepositMargin(this.extend(r,s)),o=this.safeValue(a,"data");return this.extend(this.parseMarginModification(o,i),{amount:this.amountToPrecision(e,t),direction:"in"})}parseMarginModification(e,t=void 0){const s=this.safeString(e,"id");t=this.safeMarket(s,t);const i=this.safeString(e,"settleCurrency"),r=this.safeValue(e,"crossMode")?"cross":"isolated",a=this.safeString(t,"symbol");return{info:e,direction:void 0,mode:r,amount:void 0,code:this.safeCurrencyCode(i),symbol:this.safeSymbol(a,t),status:void 0}}async fetchOrdersByStatus(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.safeValue(n,"stop"),a=this.safeInteger2(n,"until","till");n=this.omit(n,["stop","until","till"]),e==="closed"?e="done":e==="open"&&(e="active");const o={};if(!r)o.status=e;else if(e!=="active")throw new oi(this.id+" fetchOrdersByStatus() can only fetch untriggered stop orders");let d;t!==void 0&&(d=this.market(t),o.symbol=d.id),s!==void 0&&(o.startAt=s),a!==void 0&&(o.endAt=a);const u=await this[r?"futuresPrivateGetStopOrders":"futuresPrivateGetOrders"](this.extend(o,n)),h=this.safeValue(u,"data",{}),l=this.safeValue(h,"items",[]);return this.parseOrders(l,d,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("done",e,t,s,i)}async fetchOrder(e=void 0,t=void 0,s={}){await this.loadMarkets();const i={};let n="futuresPrivateGetOrdersOrderId";if(e===void 0){const d=this.safeString2(s,"clientOid","clientOrderId");if(d===void 0)throw new Xf(this.id+" fetchOrder() requires parameter id or params.clientOid");i.clientOid=d,n="futuresPrivateGetOrdersByClientOid",s=this.omit(s,["clientOid","clientOrderId"])}else i.orderId=e;const r=await this[n](this.extend(i,s)),a=t!==void 0?this.market(t):void 0,o=this.safeValue(r,"data");return this.parseOrder(o,a)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeString(e,"id"),r=this.safeString(e,"type"),a=this.safeInteger(e,"createdAt"),o=this.iso8601(a),d=this.safeString(e,"price"),c=this.safeString(e,"side"),u=this.safeString(e,"feeCurrency"),h=this.safeCurrencyCode(u),l=this.safeNumber(e,"fee"),p=this.safeString(e,"size"),m=this.safeString(e,"dealSize"),g=this.safeString2(e,"dealFunds","filledValue"),y=this.safeString(e,"leverage"),b=Xs.stringDiv(g,y);let w;if(Xs.stringGt(m,"0")){const v=this.safeString(t,"contractSize");t.linear?w=Xs.stringDiv(g,Xs.stringMul(v,m)):w=Xs.stringDiv(Xs.stringMul(v,m),g)}const S=this.safeValue(e,"isActive",!1),k=this.safeValue(e,"cancelExist",!1);let T=S?"open":"closed";T=k?"canceled":T;const I={currency:h,cost:l},_=this.safeString(e,"clientOid"),N=this.safeString(e,"timeInForce"),M=this.safeNumber(e,"stopPrice"),x=this.safeValue(e,"postOnly");return this.safeOrder({id:n,clientOrderId:_,symbol:i,type:r,timeInForce:N,postOnly:x,side:c,amount:p,price:d,stopPrice:M,cost:b,filled:m,remaining:void 0,timestamp:a,datetime:o,fee:I,status:T,info:e,lastTradeTimestamp:void 0,average:w,trades:void 0},t)}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.futuresPublicGetFundingRateSymbolCurrent(this.extend(i,t)),r=this.safeValue(n,"data"),a=this.safeNumber(r,"timePoint");return{info:r,symbol:s.symbol,markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeNumber(r,"predictedValue"),fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:this.safeNumber(r,"value"),previousFundingTimestamp:a,previousFundingDatetime:this.iso8601(a)}}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"data"),i=this.safeString(s,"currency"),n=this.safeCurrencyCode(i),r=this.account();return r.free=this.safeString(s,"availableBalance"),r.total=this.safeString(s,"accountEquity"),t[n]=r,this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();let t=this.safeString(this.options,"code");const s=this.safeValue(this.options,"fetchBalance",{});t=this.safeString(s,"code",t);const i=this.safeString(e,"code",t),r={currency:this.currency(i).id},a=await this.futuresPrivateGetAccountOverview(this.extend(r,e));return this.parseBalance(a)}async transfer(e,t,s,i,n={}){if(i!=="main"&&i!=="funding"||s!=="futures"&&s!=="future"&&s!=="contract")throw new oi(this.id+" transfer() only supports transfers from contract(future) account to main(funding) account");await this.loadMarkets();const r=this.currency(e),a=this.currencyToPrecision(e,t),o={currency:this.safeString(r,"id"),amount:a},d=await this.futuresPrivatePostTransferOut(this.extend(o,n)),c=this.safeValue(d,"data");return this.extend(this.parseTransfer(c,r),{amount:this.parseNumber(a),fromAccount:"future",toAccount:"spot"})}parseTransfer(e,t=void 0){const s=this.safeInteger(e,"updatedAt");return{id:this.safeString(e,"applyId"),timestamp:s,datetime:this.iso8601(s),currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:this.safeString(e,"status"),info:e}}parseTransferStatus(e){const t={PROCESSING:"pending"};return this.safeString(t,e,e)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),t!==void 0&&(n.startAt=t);const a=await this.futuresPrivateGetFills(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"items",{});return this.parseTrades(d,r,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.futuresPublicGetTradeHistory(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,"-");const i=this.safeString2(e,"tradeId","id"),n=this.safeString(e,"orderId"),r=this.safeString(e,"liquidity");let a=this.safeInteger(e,"ts");a!==void 0?a=parseInt(a/1e6):(a=this.safeInteger(e,"createdAt"),"dealValue"in e&&a!==void 0&&(a=a*1e3));const o=this.safeString2(e,"price","dealPrice"),d=this.safeString2(e,"size","amount"),c=this.safeString(e,"side");let u;const h=this.safeString(e,"fee");if(h!==void 0){const m=this.safeString(e,"feeCurrency");let g=this.safeCurrencyCode(m);g===void 0&&(g=c==="sell"?t.quote:t.base),u={cost:h,currency:g,rate:this.safeString(e,"feeRate")}}let l=this.safeString2(e,"type","orderType");l==="match"&&(l=void 0);let p=this.safeString2(e,"funds","value");if(p===void 0){const m=this.safeString(t,"contractSize"),g=Xs.stringMul(o,d);p=Xs.stringMul(g,m)}return this.safeTrade({info:e,id:i,order:n,timestamp:a,datetime:this.iso8601(a),symbol:t.symbol,type:l,takerOrMaker:r,side:c,price:o,amount:d,cost:p,fee:u},t)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.pageSize=s),t!==void 0&&(n.startAt=t);const o=(await this.futuresPrivateGetDepositList(this.extend(n,i))).data.items;return this.parseTransactions(o,r,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.pageSize=s),t!==void 0&&(n.startAt=t);const o=(await this.futuresPrivateGetWithdrawalList(this.extend(n,i))).data.items;return this.parseTransactions(o,r,t,s,{type:"withdrawal"})}async fetchTransactionFee(e,t={}){throw new oi(this.id+" fetchTransactionFee() is not supported yet")}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){throw new oi(this.id+" fetchLedger() is not supported yet")}async fetchMarketLeverageTiers(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.contract)throw new oi(this.id+" fetchMarketLeverageTiers() supports contract markets only");const i={symbol:s.id},n=await this.futuresPublicGetContractsRiskLimitSymbol(this.extend(i,t)),r=this.safeValue(n,"data");return this.parseMarketLeverageTiers(r,s)}parseMarketLeverageTiers(e,t){const s=[];for(let i=0;i<e.length;i++){const n=e[i];s.push({tier:this.safeNumber(n,"level"),currency:t.base,minNotional:this.safeNumber(n,"minRiskLimit"),maxNotional:this.safeNumber(n,"maxRiskLimit"),maintenanceMarginRate:this.safeNumber(n,"maintainMargin"),maxLeverage:this.safeNumber(n,"maxLeverage"),info:n})}return s}};const fH=me,{ArgumentsRequired:Iv,InsufficientFunds:hH,OrderNotFound:xv,NotSupported:lH}=oe,{TICK_SIZE:pH}=pe;var mH=class extends fH{describe(){return this.deepExtend(super.describe(),{id:"kuna",name:"Kuna",countries:["UA"],rateLimit:1e3,version:"v2",has:{CORS:void 0,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelOrder:!0,createOrder:!0,fetchBalance:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchL3OrderBook:!0,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:"emulated",fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,reduceMargin:!1,setLeverage:!1,setPositionMode:!1,withdraw:void 0},timeframes:void 0,urls:{extension:".json",referral:"https://kuna.io?r=kunaid-gvfihe8az7o4",logo:"https://user-images.githubusercontent.com/51840849/87153927-f0578b80-c2c0-11ea-84b6-74612568e9e1.jpg",api:{xreserve:"https://api.xreserve.fund",v3:"https://api.kuna.io",public:"https://kuna.io",private:"https://kuna.io"},www:"https://kuna.io",doc:"https://kuna.io/documents/api",fees:"https://kuna.io/documents/api"},api:{xreserve:{get:{nonce:1,fee:1,"delegated-transactions":1},post:{"delegate-transfer":1}},v3:{public:{get:{timestamp:1,currencies:1,markets:1,tickers:1,k:1,trades_history:1,fees:1,"exchange-rates":1,"exchange-rates/currency":1,"book/market":1,"kuna_codes/code/check":1,landing_page_statistic:1,"translations/locale":1,"trades/market/hist":1},post:{http_test:1,deposit_channels:1,withdraw_channels:1,subscription_plans:1,send_to:1,confirm_token:1,kunaid:1,"withdraw/prerequest":1,"deposit/prerequest":1,"deposit/exchange-rates":1}},sign:{get:{"reset_password/token":1},post:{"signup/google":1,"signup/resend_confirmation":1,signup:1,signin:1,"signin/two_factor":1,"signin/resend_confirm_device":1,"signin/confirm_device":1,reset_password:1,"cool-signin":1},put:{"reset_password/token":1,"signup/code/confirm":1}},private:{post:{"auth/w/order/submit":1,"auth/r/orders":1,"auth/r/orders/market":1,"auth/r/orders/markets":1,"auth/api_tokens/delete":1,"auth/api_tokens/create":1,"auth/api_tokens":1,"auth/signin_history/uniq":1,"auth/signin_history":1,"auth/disable_withdraw_confirmation":1,"auth/change_password":1,"auth/deposit_address":1,"auth/announcements/accept":1,"auth/announcements/unaccepted":1,"auth/otp/deactivate":1,"auth/otp/activate":1,"auth/otp/secret":1,"auth/r/order/market/:order_id/trades":1,"auth/r/orders/market/hist":1,"auth/r/orders/hist":1,"auth/r/orders/hist/markets":1,"auth/r/orders/details":1,"auth/assets-history":1,"auth/assets-history/withdraws":1,"auth/assets-history/deposits":1,"auth/r/wallets":1,"auth/markets/favorites":1,"auth/markets/favorites/list":1,"auth/me/update":1,"auth/me":1,"auth/fund_sources":1,"auth/fund_sources/list":1,"auth/withdraw/resend_confirmation":1,"auth/withdraw":1,"auth/withdraw/details":1,"auth/withdraw/info":1,"auth/payment_addresses":1,"auth/deposit/prerequest":1,"auth/deposit/exchange-rates":1,"auth/deposit":1,"auth/deposit/details":1,"auth/deposit/info":1,"auth/kuna_codes/count":1,"auth/kuna_codes/details":1,"auth/kuna_codes/edit":1,"auth/kuna_codes/send-pdf":1,"auth/kuna_codes":1,"auth/kuna_codes/redeemed-by-me":1,"auth/kuna_codes/issued-by-me":1,"auth/payment_requests/invoice":1,"auth/payment_requests/type":1,"auth/referral_program/weekly_earnings":1,"auth/referral_program/stats":1,"auth/merchant/payout_services":1,"auth/merchant/withdraw":1,"auth/merchant/payment_services":1,"auth/merchant/deposit":1,"auth/verification/auth_token":1,"auth/kunaid_purchase/create":1,"auth/devices/list":1,"auth/sessions/list":1,"auth/subscriptions/reactivate":1,"auth/subscriptions/cancel":1,"auth/subscriptions/prolong":1,"auth/subscriptions/create":1,"auth/subscriptions/list":1,"auth/kuna_ids/list":1,"order/cancel/multi":1,"order/cancel":1},put:{"auth/fund_sources/id":1,"auth/kuna_codes/redeem":1},delete:{"auth/markets/favorites":1,"auth/fund_sources":1,"auth/devices":1,"auth/devices/list":1,"auth/sessions/list":1,"auth/sessions":1}}},public:{get:["depth","k_with_pending_trades","k","markets","order_book","order_book/{market}","tickers","tickers/{market}","timestamp","trades","trades/{market}"]},private:{get:["members/me","deposits","deposit","deposit_address","orders","order","trades/my","withdraws","withdraw"],post:["orders","orders/multi","orders/clear","order/delete","withdraw"]}},fees:{trading:{tierBased:!1,percentage:!0,taker:this.parseNumber("0.0025"),maker:this.parseNumber("0.0025")},funding:{withdraw:{UAH:"1%",BTC:.001,BCH:.001,ETH:.01,WAVES:.01,GOL:0,GBG:0},deposit:{}}},commonCurrencies:{PLA:"Plair"},precisionMode:pH,exceptions:{2002:hH,2003:xv}})}async fetchTime(e={}){return await this.publicGetTimestamp(e)*1e3}async fetchMarkets(e={}){const t=["btc","rub","uah","usd","usdt","usdc"],s=[],i=await this.publicGetTickers(e),n=Object.keys(i);for(let r=0;r<n.length;r++){const a=n[r];for(let o=0;o<t.length;o++){const d=t[o],c=a.slice(1),u=c.indexOf(d),h=c.slice(u);if(u>0&&h===d){const l=a[0]+c.replace(d,""),p=this.safeCurrencyCode(l),m=this.safeCurrencyCode(d);s.push({id:a,symbol:p+"/"+m,base:p,quote:m,settle:void 0,baseId:l,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:void 0,price:void 0},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:void 0})}}}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={market:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetDepth(this.extend(n,s)),a=this.safeTimestamp(r,"timestamp");return this.parseOrderBook(r,i.symbol,a)}parseTicker(e,t=void 0){const s=this.safeTimestamp(e,"at");e=e.ticker;const i=this.safeSymbol(void 0,t),n=this.safeString(e,"last");return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"vol"),quoteVolume:void 0,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTickers(t),i=Object.keys(s),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeMarket(a),d=o.symbol;n[d]=this.parseTicker(s[a],o)}return this.filterByArray(n,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id},n=await this.publicGetTickersMarket(this.extend(i,t));return this.parseTicker(n,s)}async fetchL3OrderBook(e,t=void 0,s={}){return await this.fetchOrderBook(e,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market:n.id},a=await this.publicGetTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"created_at"));let i;t&&(i=t.symbol);let n=this.safeString2(e,"side","trend");if(n!==void 0){const u={ask:"sell",bid:"buy"};n=this.safeString(u,n,n)}const r=this.safeString(e,"price"),a=this.safeString(e,"volume"),o=this.safeNumber(e,"funds"),d=this.safeString(e,"order_id"),c=this.safeString(e,"id");return this.safeTrade({id:c,info:e,timestamp:s,datetime:this.iso8601(s),symbol:i,type:void 0,side:n,order:d,takerOrMaker:void 0,price:r,amount:a,cost:o,fee:void 0},t)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=await this.fetchTrades(e,s,i,n),a=this.buildOHLCVC(r,t,s,i),o=[];for(let d=0;d<a.length;d++){const c=a[d];o.push([c[0],c[1],c[2],c[3],c[4],c[5]])}return o}parseBalance(e){const t=this.safeValue(e,"accounts",[]),s={info:t};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(n,"balance"),o.used=this.safeString(n,"locked"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetMembersMe(e);return this.parseBalance(t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={market:a.id,side:s,volume:i.toString(),ord_type:t};t==="limit"&&(o.price=n.toString());const d=await this.privatePostOrders(this.extend(o,r));return this.parseOrder(d,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privatePostOrderDelete(this.extend(i,s)),r=this.parseOrder(n),a=r.status;if(a==="closed"||a==="canceled")throw new xv(this.id+" "+this.json(r));return r}parseOrderStatus(e){const t={done:"closed",wait:"open",cancel:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeSymbol(s,t),n=this.parse8601(this.safeString(e,"created_at")),r=this.parseOrderStatus(this.safeString(e,"state")),a=this.safeString(e,"type"),o=this.safeString(e,"side"),d=this.safeString(e,"id");return this.safeOrder({id:d,clientOrderId:void 0,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,status:r,symbol:i,type:a,timeInForce:void 0,postOnly:void 0,side:o,price:this.safeString(e,"price"),stopPrice:void 0,amount:this.safeString(e,"volume"),filled:this.safeString(e,"executed_volume"),remaining:this.safeString(e,"remaining_volume"),trades:void 0,fee:void 0,info:e,cost:void 0,average:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:parseInt(e)},n=await this.privateGetOrder(this.extend(i,s));return this.parseOrder(n)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Iv(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={market:n.id},a=await this.privateGetOrders(this.extend(r,i));return this.parseOrders(a,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Iv(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={market:n.id},a=await this.privateGetTradesMy(this.extend(r,i));return this.parseTrades(a,n,t,s)}nonce(){return this.milliseconds()}encodeParams(e){if("orders"in e){const t=e.orders;let s=this.urlencode(this.keysort(this.omit(e,"orders")));for(let i=0;i<t.length;i++){const n=t[i],r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=n[o];s+="&orders%5B%5D%5B"+o+"%5D="+d.toString()}}return s}return this.urlencode(this.keysort(e))}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a;if(Array.isArray(t)){const[o,d]=t;if(a=this.urls.api[o]+"/"+o+"/"+this.implodeParams(e,i),d==="public")s==="GET"?Object.keys(i).length&&(a+="?"+this.urlencode(i)):(s==="POST"||s==="PUT")&&(n={"Content-Type":"application/json"},r=this.json(i));else if(d==="private")throw new lH(this.id+" private v3 API is not supported yet")}else{let o="/api/"+this.version+"/"+this.implodeParams(e,i);"extension"in this.urls&&(o+=this.urls.extension);const d=this.omit(i,this.extractParams(e));if(a=this.urls.api[t]+o,t==="public")Object.keys(d).length&&(a+="?"+this.urlencode(d));else{this.checkRequiredCredentials();const c=this.nonce().toString(),u=this.encodeParams(this.extend({access_key:this.apiKey,tonce:c},i)),h=s+"|"+o+"|"+u,l=this.hmac(this.encode(h),this.encode(this.secret)),p=u+"&signature="+l;s==="GET"?a+="?"+p:(r=p,n={"Content-Type":"application/x-www-form-urlencoded"})}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&e===400){const c=this.safeValue(a,"error"),u=this.safeString(c,"code"),h=this.id+" "+this.json(a);this.throwExactlyMatchedException(this.exceptions,u,h)}}};const gH=me,{ExchangeError:Zf,AuthenticationError:Ha,ArgumentsRequired:yH,InvalidNonce:bH,BadRequest:Fo,ExchangeNotAvailable:wH,PermissionDenied:_v,AccountSuspended:D0,RateLimitExceeded:SH,InsufficientFunds:kH,BadSymbol:H0,InvalidOrder:Cv}=oe,{TICK_SIZE:vH}=pe;var TH=class extends gH{describe(){return this.deepExtend(super.describe(),{id:"latoken",name:"Latoken",countries:["KY"],version:"v2",rateLimit:1e3,has:{CORS:void 0,spot:!0,margin:!1,swap:void 0,future:void 0,option:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchCurrencies:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPositionMode:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactions:!0,fetchTransfer:!1,fetchTransfers:!0,transfer:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/61511972-24c39f00-aa01-11e9-9f7c-471f1d6e5214.jpg",api:{rest:"https://api.latoken.com"},www:"https://latoken.com",doc:["https://api.latoken.com"],fees:"https://latoken.com/fees",referral:"https://latoken.com/invite?r=mvgp2djk"},api:{public:{get:{"book/{currency}/{quote}":1,"chart/week":1,"chart/week/{currency}/{quote}":1,currency:1,"currency/available":1,"currency/quotes":1,"currency/{currency}":1,pair:1,"pair/available":1,ticker:1,"ticker/{base}/{quote}":1,time:1,"trade/history/{currency}/{quote}":1,"trade/fee/{currency}/{quote}":1,"trade/feeLevels":1,"transaction/bindings":1}},private:{get:{"auth/account":1,"auth/account/currency/{currency}/{type}":1,"auth/order":1,"auth/order/getOrder/{id}":1,"auth/order/pair/{currency}/{quote}":1,"auth/order/pair/{currency}/{quote}/active":1,"auth/stopOrder":1,"auth/stopOrder/getOrder/{id}":1,"auth/stopOrder/pair/{currency}/{quote}":1,"auth/stopOrder/pair/{currency}/{quote}/active":1,"auth/trade":1,"auth/trade/pair/{currency}/{quote}":1,"auth/trade/fee/{currency}/{quote}":1,"auth/transaction":1,"auth/transaction/bindings":1,"auth/transaction/bindings/{currency}":1,"auth/transaction/{id}":1,"auth/transfer":1},post:{"auth/order/cancel":1,"auth/order/cancelAll":1,"auth/order/cancelAll/{currency}/{quote}":1,"auth/order/place":1,"auth/spot/deposit":1,"auth/spot/withdraw":1,"auth/stopOrder/cancel":1,"auth/stopOrder/cancelAll":1,"auth/stopOrder/cancelAll/{currency}/{quote}":1,"auth/stopOrder/place":1,"auth/transaction/depositAddress":1,"auth/transaction/withdraw":1,"auth/transaction/withdraw/cancel":1,"auth/transaction/withdraw/confirm":1,"auth/transaction/withdraw/resendCode":1,"auth/transfer/email":1,"auth/transfer/id":1,"auth/transfer/phone":1}}},precisionMode:vH,fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,maker:this.parseNumber("0.0049"),taker:this.parseNumber("0.0049")}},commonCurrencies:{BUX:"Buxcoin",CBT:"Community Business Token",CTC:"CyberTronchain",DMD:"Diamond Coin",FREN:"Frenchie",GDX:"GoldenX",GEC:"Geco One",GEM:"NFTmall",GMT:"GMT Token",IMC:"IMCoin",MT:"Monarch",TPAY:"Tetra Pay",TRADE:"Smart Trade Coin",TSL:"Treasure SL",UNO:"Unobtanium",WAR:"Warrior Token"},exceptions:{exact:{INTERNAL_ERROR:Zf,SERVICE_UNAVAILABLE:wH,NOT_AUTHORIZED:Ha,FORBIDDEN:_v,BAD_REQUEST:Fo,NOT_FOUND:Zf,ACCESS_DENIED:_v,REQUEST_REJECTED:Zf,HTTP_MEDIA_TYPE_NOT_SUPPORTED:Fo,MEDIA_TYPE_NOT_ACCEPTABLE:Fo,METHOD_ARGUMENT_NOT_VALID:Fo,VALIDATION_ERROR:Fo,ACCOUNT_EXPIRED:D0,BAD_CREDENTIALS:Ha,COOKIE_THEFT:Ha,CREDENTIALS_EXPIRED:D0,INSUFFICIENT_AUTHENTICATION:Ha,UNKNOWN_LOCATION:Ha,TOO_MANY_REQUESTS:SH,INSUFFICIENT_FUNDS:kH,ORDER_VALIDATION:Cv,BAD_TICKS:Cv},broad:{"invalid API key, signature or digest":Ha,"The API key was revoked":Ha,"request expired or bad":bH,"For input string":Fo,"Unable to resolve currency by tag":H0,"Can't find currency with tag":H0,"Unable to place order because pair is in inactive state":H0,"API keys are not available for FROZEN user":D0}},options:{defaultType:"spot",types:{wallet:"ACCOUNT_TYPE_WALLET",spot:"ACCOUNT_TYPE_SPOT"},accounts:{ACCOUNT_TYPE_WALLET:"wallet",ACCOUNT_TYPE_SPOT:"spot"},fetchTradingFee:{method:"fetchPrivateTradingFee"}}})}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeInteger(t,"serverTime")}async fetchMarkets(e={}){const t=await this.fetchCurrenciesFromCache(e),s=await this.publicGetPair(e);this.safeValue(this.options,"adjustForTimeDifference",!0)&&await this.loadTimeDifference();const i=this.indexBy(t,"id"),n=[];for(let r=0;r<s.length;r++){const a=s[r],o=this.safeString(a,"id"),d=this.safeString(a,"baseCurrency"),c=this.safeString(a,"quoteCurrency"),u=this.safeValue(i,d),h=this.safeValue(i,c);if(u!==void 0&&h!==void 0){const l=this.safeCurrencyCode(this.safeString(u,"tag")),p=this.safeCurrencyCode(this.safeString(h,"tag")),m=p.toLowerCase(),g=this.capitalize(m),y=this.safeString(a,"status");n.push({id:o,symbol:l+"/"+p,base:l,quote:p,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:y==="PAIR_STATUS_ACTIVE",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(a,"quantityTick"),price:this.safeNumber(a,"priceTick")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(a,"minOrderQuantity"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(a,"minOrderCost"+g),max:this.safeNumber(a,"maxOrderCost"+g)}},info:a})}}return n}async fetchCurrenciesFromCache(e={}){const t=this.safeValue(this.options,"fetchCurrencies",{}),s=this.safeInteger(t,"timestamp"),i=this.safeInteger(t,"expires",1e3),n=this.milliseconds();if(s===void 0||n-s>i){const r=await this.publicGetCurrency(e);this.options.fetchCurrencies=this.extend(t,{response:r,timestamp:n})}return this.safeValue(this.options.fetchCurrencies,"response")}async fetchCurrencies(e={}){const t=await this.fetchCurrenciesFromCache(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"id"),a=this.safeString(n,"tag"),o=this.safeCurrencyCode(a),d=this.safeNumber(n,"fee"),u=this.safeString(n,"type").split("_"),h=u.length,p=this.safeValue(u,h-1).toLowerCase(),g=this.safeString(n,"status")==="CURRENCY_STATUS_ACTIVE",y=this.safeString(n,"name");s[o]={id:r,code:o,info:n,name:y,type:p,active:g,deposit:void 0,withdraw:void 0,fee:d,precision:this.parseNumber(this.parsePrecision(this.safeString(n,"decimals"))),limits:{amount:{min:this.safeNumber(n,"minTransferAmount"),max:void 0},withdraw:{min:void 0,max:void 0}}}}return s}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAuthAccount(e),s={info:t,timestamp:void 0,datetime:void 0};let i;const n=this.safeString2(this.options,"fetchBalance","defaultType","spot"),r=this.safeString(e,"type",n),a=this.safeValue(this.options,"types",{}),o=this.safeString(a,r,r),d=this.groupBy(t,"type"),c=this.safeValue(d,o,[]);for(let u=0;u<c.length;u++){const h=c[u],l=this.safeString(h,"currency"),p=this.safeInteger(h,"timestamp");p!==void 0&&(i===void 0?i=p:i=Math.max(i,p));const m=this.safeCurrencyCode(l),g=this.account();g.free=this.safeString(h,"available"),g.used=this.safeString(h,"blocked"),s[m]=g}return s.timestamp=i,s.datetime=this.iso8601(i),this.safeBalance(s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={currency:i.baseId,quote:i.quoteId};t!==void 0&&(n.limit=t);const r=await this.publicGetBookCurrencyQuote(this.extend(n,s));return this.parseOrderBook(r,e,void 0,"bid","ask","price","quantity")}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeString(e,"lastPrice"),r=this.safeString(e,"change24h"),a=this.nonce();return this.safeTicker({symbol:i,timestamp:a,datetime:this.iso8601(a),low:this.safeString(e,"low"),high:this.safeString(e,"high"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:r,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:this.safeString(e,"volume24h"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={base:s.baseId,quote:s.quoteId},n=await this.publicGetTickerBaseQuote(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTicker(t);return this.parseTickers(s,e)}parseTrade(e,t=void 0){const i=this.safeInteger(e,"timestamp"),n=this.safeString(e,"price"),r=this.safeString(e,"quantity"),a=this.safeString(e,"cost"),o=this.safeValue(e,"makerBuyer");let d=this.safeString(e,"direction");d===void 0?d=o?"sell":"buy":d==="TRADE_DIRECTION_BUY"?d="buy":d==="TRADE_DIRECTION_SELL"&&(d="sell");const u=o&&d==="buy"?"maker":"taker",h=this.safeString(e,"baseCurrency"),l=this.safeString(e,"quoteCurrency"),p=this.safeCurrencyCode(h),m=this.safeCurrencyCode(l),g=p+"/"+m;g in this.markets&&(t=this.market(g));const y=this.safeString(e,"id"),b=this.safeString(e,"order"),w=this.safeString(e,"fee");let S;return w!==void 0&&(S={cost:w,currency:m}),this.safeTrade({info:e,timestamp:i,datetime:this.iso8601(i),symbol:g,id:y,order:b,type:void 0,takerOrMaker:u,side:d,price:n,amount:r,cost:a,fee:S},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={currency:n.baseId,quote:n.quoteId};s!==void 0&&(r.limit=s);const a=await this.publicGetTradeHistoryCurrencyQuote(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTradingFee(e,t={}){let s=this.safeString(t,"method");if(t=this.omit(t,"method"),s===void 0){const i=this.safeValue(this.options,"fetchTradingFee",{});s=this.safeString(i,"method","fetchPrivateTradingFee")}return await this[s](e,t)}async fetchPublicTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={currency:s.baseId,quote:s.quoteId},n=await this.publicGetTradeFeeCurrencyQuote(this.extend(i,t));return{info:n,symbol:s.symbol,maker:this.safeNumber(n,"makerFee"),taker:this.safeNumber(n,"takerFee")}}async fetchPrivateTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={currency:s.baseId,quote:s.quoteId},n=await this.privateGetAuthTradeFeeCurrencyQuote(this.extend(i,t));return{info:n,symbol:s.symbol,maker:this.safeNumber(n,"makerFee"),taker:this.safeNumber(n,"takerFee")}}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r="privateGetAuthTrade",a;e!==void 0&&(a=this.market(e),n.currency=a.baseId,n.quote=a.quoteId,r="privateGetAuthTradePairCurrencyQuote"),s!==void 0&&(n.limit=s);const o=await this[r](this.extend(n,i));return this.parseTrades(o,a,t,s)}parseOrderStatus(e){const t={ORDER_STATUS_PLACED:"open",ORDER_STATUS_CLOSED:"closed",ORDER_STATUS_CANCELLED:"canceled"};return this.safeString(t,e,e)}parseOrderType(e){const t={ORDER_TYPE_MARKET:"market",ORDER_TYPE_LIMIT:"limit"};return this.safeString(t,e,e)}parseTimeInForce(e){const t={ORDER_CONDITION_GOOD_TILL_CANCELLED:"GTC",ORDER_CONDITION_IMMEDIATE_OR_CANCEL:"IOC",ORDER_CONDITION_FILL_OR_KILL:"FOK"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeInteger(e,"timestamp"),n=this.safeString(e,"baseCurrency"),r=this.safeString(e,"quoteCurrency"),a=this.safeCurrencyCode(n),o=this.safeCurrencyCode(r);let d;a!==void 0&&o!==void 0&&(d=a+"/"+o,d in this.markets&&(t=this.market(d)));const c=this.safeString(e,"side");let u;if(c!==void 0){const k=c.split("_"),T=k.length;u=this.safeStringLower(k,T-1)}const h=this.parseOrderType(this.safeString(e,"type")),l=this.safeString(e,"price"),p=this.safeString(e,"quantity"),m=this.safeString(e,"filled"),g=this.safeString(e,"cost");let y=this.parseOrderStatus(this.safeString(e,"status"));const b=this.safeString(e,"message");b!==void 0&&(b.indexOf("cancel")>=0?y="canceled":b.indexOf("accept")>=0&&(y="open"));const w=this.safeString(e,"clientOrderId"),S=this.parseTimeInForce(this.safeString(e,"condition"));return this.safeOrder({id:s,clientOrderId:w,info:e,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,status:y,symbol:d,type:h,timeInForce:S,postOnly:void 0,side:u,price:l,stopPrice:void 0,cost:g,amount:p,filled:m,average:void 0,remaining:void 0,fee:void 0,trades:void 0},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new yH(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={currency:n.baseId,quote:n.quoteId},a=await this.privateGetAuthOrderPairCurrencyQuoteActive(this.extend(r,i));return this.parseOrders(a,n,t,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r="privateGetAuthOrder",a;e!==void 0&&(a=this.market(e),n.currency=a.baseId,n.quote=a.quoteId,r="privateGetAuthOrderPairCurrencyQuote"),s!==void 0&&(n.limit=s);const o=await this[r](this.extend(n,i));return this.parseOrders(o,a,t,s)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetAuthOrderGetOrderId(this.extend(i,s));return this.parseOrder(n)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=t.toUpperCase(),d={baseCurrency:a.baseId,quoteCurrency:a.quoteId,side:s.toUpperCase(),condition:"GTC",type:o,clientOrderId:this.uuid()};o==="LIMIT"&&(d.price=this.priceToPrecision(e,n)),d.quantity=this.amountToPrecision(e,i),d.timestamp=this.seconds();const c=await this.privatePostAuthOrderPlace(this.extend(d,r));return this.parseOrder(c,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privatePostAuthOrderCancel(this.extend(i,s));return this.parseOrder(n)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i="privatePostAuthOrderCancelAll",n;return e!==void 0&&(n=this.market(e),s.currency=n.baseId,s.quote=n.quoteId,i="privatePostAuthOrderCancelAllCurrencyQuote"),await this[i](this.extend(s,t))}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={},r=await this.privateGetAuthTransaction(this.extend(n,i));let a;e!==void 0&&(a=this.currency(e));const o=this.safeValue(r,"content",[]);return this.parseTransactions(o,a,t,s)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeInteger(e,"timestamp"),n=this.safeString(e,"currency"),r=this.safeCurrencyCode(n,t),a=this.parseTransactionStatus(this.safeString(e,"status")),o=this.safeNumber(e,"amount"),d=this.safeString(e,"senderAddress"),c=this.safeString(e,"recipientAddress"),u=this.safeString(e,"transactionHash"),h=this.safeString(e,"memo");let l;const p=this.safeNumber(e,"transactionFee");p!==void 0&&(l={cost:p,currency:r});const m=this.parseTransactionType(this.safeString(e,"type"));return{info:e,id:s,txid:u,timestamp:i,datetime:this.iso8601(i),network:void 0,addressFrom:d,addressTo:c,address:c,tagFrom:void 0,tagTo:h,tag:h,type:m,amount:o,currency:r,status:a,updated:void 0,fee:l}}parseTransactionStatus(e){const t={TRANSACTION_STATUS_CONFIRMED:"ok",TRANSACTION_STATUS_EXECUTED:"ok"};return this.safeString(t,e,e)}parseTransactionType(e){const t={TRANSACTION_TYPE_DEPOSIT:"deposit",TRANSACTION_TYPE_WITHDRAWAL:"withdrawal"};return this.safeString(t,e,e)}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.currency(e),r=await this.privateGetAuthTransfer(i),a=this.safeValue(r,"content",[]);return this.parseTransfers(a,n,t,s)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e);let a;i.indexOf("@")>=0?a="privatePostAuthTransferEmail":i.length===36?a="privatePostAuthTransferId":a="privatePostAuthTransferPhone";const o={currency:r.id,recipient:i,value:this.currencyToPrecision(e,t)},d=await this[a](this.extend(o,n));return this.parseTransfer(d)}parseTransfer(e,t=void 0){const s=this.safeTimestamp(e,"timestamp"),i=this.safeString(e,"currency"),n=this.safeString(e,"status");return{info:e,id:this.safeString(e,"id"),timestamp:this.safeInteger(e,"timestamp"),datetime:this.iso8601(s),currency:this.safeCurrencyCode(i,t),amount:this.safeNumber(e,"transferringFunds"),fromAccount:this.safeString(e,"fromAccount"),toAccount:this.safeString(e,"toAccount"),status:this.parseTransferStatus(n)}}parseTransferStatus(e){const t={TRANSFER_STATUS_COMPLETED:"ok",TRANSFER_STATUS_PENDING:"pending",TRANSFER_STATUS_REJECTED:"failed",TRANSFER_STATUS_UNVERIFIED:"pending",TRANSFER_STATUS_CANCELLED:"canceled"};return this.safeString(t,e,e)}sign(e,t="public",s="GET",i=void 0,n=void 0,r=void 0){const a="/"+this.version+"/"+this.implodeParams(e,i);let o=a;const d=this.omit(i,this.extractParams(e)),c=this.urlencode(d);if(s==="GET"&&Object.keys(d).length&&(o+="?"+c),t==="private"){this.checkRequiredCredentials();const h=s+a+c,l=this.hmac(this.encode(h),this.encode(this.secret),"sha512");n={"X-LA-APIKEY":this.apiKey,"X-LA-SIGNATURE":l,"X-LA-DIGEST":"HMAC-SHA512"},s==="POST"&&(n["Content-Type"]="application/json",r=this.json(d))}return{url:this.urls.api.rest+o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(!a)return;const c=this.safeString(a,"message"),u=this.id+" "+r;c!==void 0&&(this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u));const h=this.safeValue(a,"error"),l=this.safeString(h,"message");if(h!==void 0||l!==void 0)throw this.throwExactlyMatchedException(this.exceptions.exact,h,u),this.throwBroadlyMatchedException(this.exceptions.broad,r,u),new Zf(u)}};const OH=me,{ExchangeError:IH,DDoSProtection:xH,AuthenticationError:Ac,InvalidOrder:zr}=oe,{TICK_SIZE:_H}=pe,CH=ke;var MH=class extends OH{describe(){return this.deepExtend(super.describe(),{id:"lbank",name:"LBank",countries:["CN"],version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:void 0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},timeframes:{"1m":"minute1","5m":"minute5","15m":"minute15","30m":"minute30","1h":"hour1","2h":"hour2","4h":"hour4","6h":"hour6","8h":"hour8","12h":"hour12","1d":"day1","1w":"week1"},urls:{logo:"https://user-images.githubusercontent.com/1294454/38063602-9605e28a-3302-11e8-81be-64b1e53c4cfb.jpg",api:{rest:"https://api.lbank.info"},www:"https://www.lbank.info",doc:"https://github.com/LBank-exchange/lbank-official-api-docs",fees:"https://www.lbank.info/fees.html",referral:"https://www.lbank.info/invitevip?icode=7QCY"},api:{public:{get:["currencyPairs","ticker","depth","trades","kline","accuracy"]},private:{post:["user_info","create_order","cancel_order","orders_info","orders_info_history","withdraw","withdrawCancel","withdraws","withdrawConfigs"]}},fees:{trading:{maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")},funding:{withdraw:{}}},commonCurrencies:{GMT:"GMT Token",PNT:"Penta",SHINJA:"SHINJA(1M)",VET_ERC20:"VEN"},options:{cacheSecretAsPem:!0},precisionMode:_H})}async fetchMarkets(e={}){const t=await this.publicGetAccuracy(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=n.symbol,a=r.split("_");let o,d;a.length>2?(o=a[0]+"_"+a[1],d=a[2]):(o=a[0],d=a[1]);const u=this.safeCurrencyCode(o),h=this.safeCurrencyCode(d);s.push({id:r,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(n,"quantityAccuracy"))),price:this.parseNumber(this.parsePrecision(this.safeString(n,"priceAccuracy")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeFloat(n,"minTranQua"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return s}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,"_");const i=t.symbol,n=this.safeInteger(e,"timestamp"),r=e;e=r.ticker;const a=this.safeString(e,"latest"),o=this.safeString(e,"change");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:o,average:void 0,baseVolume:this.safeString(e,"vol"),quoteVolume:this.safeString(e,"turnover"),info:r},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetTicker(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={symbol:"all"},i=await this.publicGetTicker(this.extend(s,t)),n={};for(let r=0;r<i.length;r++){const a=this.parseTicker(i[r]),o=a.symbol;n[o]=a}return this.filterByArray(n,"symbol",e)}async fetchOrderBook(e,t=60,s={}){await this.loadMarkets();let i=60;t!==void 0&&(i=Math.min(t,i));const n=this.market(e),r={symbol:n.id,size:i},a=await this.publicGetDepth(this.extend(r,s));return this.parseOrderBook(a,n.symbol)}parseTrade(e,t=void 0){t=this.safeMarket(void 0,t);const s=this.safeInteger(e,"date_ms"),i=this.safeString(e,"price"),n=this.safeString(e,"amount"),r=this.parseNumber(i),a=this.parseNumber(n),o=this.parseNumber(CH.stringMul(i,n)),d=this.safeString(e,"tid"),c=void 0;let u=this.safeString(e,"type");return u=u.split("_")[0],{id:d,info:this.safeValue(e,"info",e),timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:void 0,type:c,side:u,takerOrMaker:void 0,price:r,amount:a,cost:o,fee:void 0}}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id,size:100};t!==void 0&&(r.time=parseInt(t)),s!==void 0&&(r.size=s);const a=await this.publicGetTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=1e3,n={}){await this.loadMarkets();const r=this.market(e);if(i===void 0&&(i=100),s===void 0){const d=this.parseTimeframe(t);s=this.milliseconds()-d*1e3*i}const a={symbol:r.id,type:this.timeframes[t],size:i,time:parseInt(s/1e3)},o=await this.publicGetKline(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"info",{}),i=this.safeValue(s,"free",{}),n=this.safeValue(s,"freeze",{}),r=this.safeValue(s,"asset",{}),a=Object.keys(i);for(let o=0;o<a.length;o++){const d=a[o],c=this.safeCurrencyCode(d),u=this.account();u.free=this.safeString(i,d),u.used=this.safeString(n,d),u.total=this.safeString(r,d),t[c]=u}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostUserInfo(e);return this.parseBalance(t)}parseOrderStatus(e){const t={"-1":"cancelled",0:"open",1:"open",2:"closed",4:"closed"};return this.safeString(t,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t,"_"),n=this.safeInteger(e,"create_time"),r=this.safeString(e,"price"),a=this.safeString(e,"amount"),o=this.safeString(e,"deal_amount"),d=this.safeString(e,"avg_price"),c=this.parseOrderStatus(this.safeString(e,"status")),u=this.safeString(e,"order_id"),h=this.safeString(e,"order_type"),l=this.safeString(e,"type");return this.safeOrder({id:u,clientOrderId:void 0,datetime:this.iso8601(n),timestamp:n,lastTradeTimestamp:void 0,status:c,symbol:i,type:h,timeInForce:void 0,postOnly:void 0,side:l,price:r,stopPrice:void 0,cost:void 0,amount:a,filled:o,remaining:void 0,trades:void 0,fee:void 0,info:this.safeValue(e,"info",e),average:d},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o={symbol:a.id,type:s,amount:i};t==="market"?o.type+="_market":o.price=n;const d=await this.privatePostCreateOrder(this.extend(o,r));return o=this.omit(o,"type"),o.order_id=d.order_id,o.type=s,o.order_type=t,o.create_time=this.milliseconds(),o.info=d,this.parseOrder(o,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const n={symbol:this.market(t).id,order_id:e};return await this.privatePostCancelOrder(this.extend(n,s))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(t),n={symbol:i.id,order_id:e},r=await this.privatePostOrdersInfo(this.extend(n,s)),a=this.safeValue(r,"orders",[]),o=this.parseOrders(a,i);return o.length===1?o[0]:o}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),s===void 0&&(s=100);const r={symbol:this.market(e).id,current_page:1,page_length:s},a=await this.privatePostOrdersInfoHistory(this.extend(r,i)),o=this.safeValue(a,"orders",[]);return this.parseOrders(o,void 0,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),e!==void 0&&(e=this.market(e).symbol);const n=await this.fetchOrders(e,t,s,i),r=this.filterBy(n,"status","closed"),a=this.filterBy(n,"status","cancelled"),o=this.arrayConcat(r,a);return this.filterBySymbolSinceLimit(o,e,t,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={assetCode:r.id,amount:t,account:s};i!==void 0&&(a.memo=i);const o=this.privatePostWithdraw(this.extend(a,n));return this.parseTransaction(o,r)}parseTransaction(e,t=void 0){return t=this.safeCurrency(void 0,t),{id:this.safeString2(e,"id","withdrawId"),txid:void 0,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0,info:e}}convertSecretToPem(e){const s=e.length-0;let i=parseInt(s/64);i=this.sum(i,1);let n=`-----BEGIN PRIVATE KEY-----
`;for(let r=0;r<i;r++){const a=r*64,o=this.sum(a,64);n+=this.secret.slice(a,o)+`
`}return n+"-----END PRIVATE KEY-----"}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.omit(i,this.extractParams(e));let o=this.urls.api.rest+"/"+this.version+"/"+this.implodeParams(e,i);if(o+=".do",t==="public")Object.keys(a).length&&(o+="?"+this.urlencode(a));else{this.checkRequiredCredentials();const d=this.keysort(this.extend({api_key:this.apiKey},i)),c=this.rawencode(d),u=this.hash(this.encode(c)).toUpperCase(),h=this.safeValue(this.options,"cacheSecretAsPem",!0);let l;h?(l=this.safeValue(this.options,"pem"),l===void 0&&(l=this.convertSecretToPem(this.secret),this.options.pem=l)):l=this.convertSecretToPem(this.secret);const p=this.binaryToBase64(this.rsa(u,this.encode(l),"RS256"));d.sign=p,r=this.urlencode(d),n={"Content-Type":"application/x-www-form-urlencoded"}}return{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;if(this.safeString(a,"result")==="false"){const u=this.safeString(a,"error_code"),h=this.safeString({1e4:"Internal error",10001:"The required parameters can not be empty",10002:"verification failed",10003:"Illegal parameters",10004:"User requests are too frequent",10005:"Key does not exist",10006:"user does not exist",10007:"Invalid signature",10008:"This currency pair is not supported",10009:"Limit orders can not be missing orders and the number of orders",10010:"Order price or order quantity must be greater than 0",10011:"Market orders can not be missing the amount of the order",10012:"market sell orders can not be missing orders",10013:"is less than the minimum trading position 0.001",10014:"Account number is not enough",10015:"The order type is wrong",10016:"Account balance is not enough",10017:"Abnormal server",10018:"order inquiry can not be more than 50 less than one",10019:"withdrawal orders can not be more than 3 less than one",10020:"less than the minimum amount of the transaction limit of 0.001",10022:"Insufficient key authority"},u,this.json(a)),l=this.safeValue({10002:Ac,10004:xH,10005:Ac,10006:Ac,10007:Ac,10009:zr,10010:zr,10011:zr,10012:zr,10013:zr,10014:zr,10015:zr,10016:zr,10022:Ac},u,IH);throw new l(h)}}};const PH=me,{ExchangeError:dr,InvalidAddress:AH,DuplicateOrderId:BH,ArgumentsRequired:Kr,InsufficientFunds:G0,InvalidOrder:kn,InvalidNonce:NH,AuthenticationError:Jf,RateLimitExceeded:EH,PermissionDenied:eh,BadRequest:di,BadSymbol:Mv}=oe,{TICK_SIZE:VH}=pe,qH=ke;var LH=class extends PH{describe(){return this.deepExtend(super.describe(),{id:"lbank2",name:"LBank",countries:["CN"],version:"v2",rateLimit:20,has:{CORS:!1,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedPositions:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFees:!0,fetchTransactionFees:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!1},timeframes:{"1m":"minute1","5m":"minute5","15m":"minute15","30m":"minute30","1h":"hour1","2h":"hour2","4h":"hour4","6h":"hour6","8h":"hour8","12h":"hour12","1d":"day1","1w":"week1"},urls:{logo:"https://user-images.githubusercontent.com/1294454/38063602-9605e28a-3302-11e8-81be-64b1e53c4cfb.jpg",api:{rest:"https://api.lbank.info"},api2:"https://api.lbkex.com",www:"https://www.lbank.info",doc:"https://www.lbank.info/en-US/docs/index.html",fees:"https://lbankinfo.zendesk.com/hc/en-gb/articles/360012072873-Trading-Fees",referral:"https://www.lbank.info/invitevip?icode=7QCY"},api:{public:{get:{currencyPairs:2.5,accuracy:2.5,usdToCny:2.5,withdrawConfigs:2.5,timestamp:2.5,"ticker/24hr":2.5,ticker:2.5,depth:2.5,incrDepth:2.5,trades:2.5,kline:2.5,"supplement/system_ping":2.5,"supplement/incrDepth":2.5,"supplement/trades":2.5,"supplement/ticker/price":2.5,"supplement/ticker/bookTicker":2.5},post:{"supplement/system_status":2.5}},private:{post:{user_info:2.5,"subscribe/get_key":2.5,"subscribe/refresh_key":2.5,"subscribe/destroy_key":2.5,get_deposit_address:2.5,deposit_history:2.5,create_order:1,batch_create_order:1,cancel_order:1,cancel_clientOrders:1,orders_info:2.5,orders_info_history:2.5,order_transaction_detail:2.5,transaction_history:2.5,orders_info_no_deal:2.5,withdraw:2.5,withdrawCancel:2.5,withdraws:2.5,"supplement/user_info":2.5,"supplement/withdraw":2.5,"supplement/deposit_history":2.5,"supplement/withdraws":2.5,"supplement/get_deposit_address":2.5,"supplement/asset_detail":2.5,"supplement/customer_trade_fee":2.5,"supplement/api_Restrictions":2.5,"supplement/system_ping":2.5,"supplement/create_order_test":1,"supplement/create_order":1,"supplement/cancel_order":1,"supplement/cancel_order_by_symbol":1,"supplement/orders_info":2.5,"supplement/orders_info_no_deal":2.5,"supplement/orders_info_history":2.5,"supplement/user_info_account":2.5,"supplement/transaction_history":2.5}}},fees:{trading:{maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")},funding:{withdraw:{}}},commonCurrencies:{VET_ERC20:"VEN",PNT:"Penta"},precisionMode:VH,options:{cacheSecretAsPem:!0,createMarketBuyOrderRequiresPrice:!0,fetchTrades:{method:"publicGetTrades"},fetchTransactionFees:{method:"fetchPrivateTransactionFees"},fetchDepositAddress:{method:"fetchDepositAddressDefault"},createOrder:{method:"privatePostSupplementCreateOrder"},fetchOrder:{method:"fetchOrderSupplement"},fetchBalance:{method:"privatePostSupplementUserInfo"},networks:{ERC20:"erc20",ETH:"erc20",TRC20:"trc20",TRX:"trc20",OMNI:"omni",ASA:"asa",BEP20:"bep20(bsc)",BSC:"bep20(bsc)",HT:"heco",BNB:"bep2",BTC:"btc",DOGE:"dogecoin",MATIC:"matic",POLYGON:"matic",OEC:"oec",BTCTRON:"btctron",XRP:"xrp"},"inverse-networks":{erc20:"ERC20",trc20:"TRC20",omni:"OMNI",asa:"ASA","bep20(bsc)":"BSC",bep20:"BSC",heco:"HT",bep2:"BNB",btc:"BTC",dogecoin:"DOGE",matic:"MATIC",oec:"OEC",btctron:"BTCTRON",xrp:"XRP"},defaultNetworks:{USDT:"TRC20"}}})}async fetchMarkets(e={}){const t=await this.publicGetAccuracy(),s=this.safeValue(t,"data"),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=a.split("_"),d=o[0],c=o[1],u=d.toUpperCase(),h=c.toUpperCase();let l=u+"/"+h;const p={"3l":!0,"5l":!0,"3s":!0,"5s":!0},m=d.slice(-2),g=this.safeValue(p,m,!1);g&&(l+=":"+h);let y;g===!0&&(y=!0),i.push({id:a,symbol:l,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:g,future:!1,option:!1,active:!0,contract:g,linear:y,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"quantityAccuracy"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"priceAccuracy")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"minTranQua"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeInteger(e,"timestamp"),r=this.safeValue(e,"ticker");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(r,"high"),low:this.safeString(r,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:void 0,last:this.safeString(r,"latest"),previousClose:void 0,change:void 0,percentage:this.safeString(r,"change"),average:void 0,baseVolume:this.safeString(r,"vol"),quoteVolume:this.safeString(r,"turnover"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetTicker24hr(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0,{});return this.parseTicker(a,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={symbol:"all"},i=await this.publicGetTicker24hr(this.extend(s,t)),n=this.safeValue(i,"data",[]);return this.parseTickers(n,e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);t===void 0&&(t=60);const n={symbol:i.id,size:t},a=(await this.publicGetDepth(this.extend(n,s))).data,o=this.milliseconds();return this.parseOrderBook(a,i.symbol,o)}parseTrade(e,t=void 0){let s=this.safeInteger2(e,"date_ms","time");s===void 0&&(s=this.safeInteger(e,"dealTime"));let i=this.safeString2(e,"amount","qty");i===void 0&&(i=this.safeString(e,"dealQuantity"));let n=this.safeString(e,"price");n===void 0&&(n=this.safeString(e,"dealPrice"));let r=this.safeString(e,"quoteQty");r===void 0&&(r=this.safeString(e,"dealVolumePrice"));let a=this.safeString2(e,"tradeType","type"),o,d;if(a!==void 0){const m=a.split("_");a=this.safeString(m,0);const g=this.safeString(m,1);o="limit",d="taker",g!==void 0&&(g==="market"?o="market":g==="maker"&&(d="maker"))}let c=this.safeString2(e,"tid","id");c===void 0&&(c=this.safeString(e,"txUuid"));const u=this.safeString(e,"orderUuid"),h=this.safeSymbol(void 0,t);let l;const p=this.safeString(e,"tradeFee");return p!==void 0&&(l={cost:p,currency:void 0,rate:this.safeString(e,"tradeFeeRate")}),this.safeTrade({timestamp:s,datetime:this.iso8601(s),symbol:h,id:c,order:u,type:o,takerOrMaker:d,side:a,price:n,amount:i,cost:r,fee:l,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};t!==void 0&&(r.time=t),s!==void 0?r.size=s:r.size=600;let a=this.safeString(i,"method");if(i=this.omit(i,"method"),a===void 0){const c=this.safeValue(this.options,"fetchTrades",{});a=this.safeString(c,"method","publicGetTrades")}const o=await this[a](this.extend(r,i)),d=this.safeValue(o,"data",[]);return this.parseTrades(d,n,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);if(i===void 0&&(i=100),s===void 0){const c=this.parseTimeframe(t);s=this.milliseconds()-c*1e3*i}const a={symbol:r.id,type:this.timeframes[t],time:parseInt(s/1e3),size:i},o=await this.publicGetKline(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseOHLCVs(d,r,t,s,i)}parseBalance(e){const t=this.safeInteger(e,"ts"),s={info:e,timestamp:t,datetime:this.iso8601(t)},i=this.safeValue(e,"data");if(this.safeValue(i,"toBtc")!==void 0){const o=this.safeValue(i,"freeze",{}),d=this.safeValue(i,"free",{}),c=Object.keys(d);for(let u=0;u<c.length;u++){const h=c[u],l=this.safeCurrencyCode(h),p=this.account();p.used=this.safeString(o,h),p.free=this.safeString(d,h),s[l]=p}return this.safeBalance(s)}const r=this.safeValue(i,"balances");if(r!==void 0){for(let o=0;o<r.length;o++){const d=r[o],c=this.safeString(d,"asset"),u=this.safeCurrencyCode(c),h=this.account();h.free=this.safeString(d,"free"),h.used=this.safeString(d,"locked"),s[u]=h}return this.safeBalance(s)}if(Array.isArray(i)===!0){for(let o=0;o<i.length;o++){const d=i[o],c=this.safeString(d,"coin"),u=this.safeCurrencyCode(c),h=this.account();h.free=this.safeString(d,"usableAmt"),h.used=this.safeString(d,"freezeAmt"),s[u]=h}return this.safeBalance(s)}}async fetchBalance(e={}){await this.loadMarkets();let t=this.safeString(e,"method");if(t===void 0){const i=this.safeValue(this.options,"fetchBalance",{});t=this.safeString(i,"method","privatePostSupplementUserInfo")}const s=await this[t]();return this.parseBalance(s)}parseTradingFee(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s);return{info:e,symbol:i,maker:this.safeNumber(e,"makerCommission"),taker:this.safeNumber(e,"takerCommission")}}async fetchTradingFee(e,t={}){const s=this.market(e);return await this.fetchTradingFees(this.extend(t,{category:s.id}))}async fetchTradingFees(e={}){await this.loadMarkets();const t={},s=await this.privatePostSupplementCustomerTradeFee(this.extend(t,e)),i=this.safeValue(s,"data",[]),n={};for(let r=0;r<i.length;r++){const a=this.parseTradingFee(i[r]),o=a.symbol;n[o]=a}return n}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeString2(r,"custom_id","clientOrderId"),d=this.safeValue(r,"postOnly",!1),c=this.safeStringUpper(r,"timeInForce");r=this.omit(r,["custom_id","clientOrderId","timeInForce","postOnly"]);const u={symbol:a.id},h=c==="IOC",l=c==="FOK",p=d||c==="PO";if(t==="market"&&(h||l||p))throw new kn(this.id+" createOrder () does not allow market FOK, IOC, or postOnly orders. Only limit IOC, FOK, and postOnly orders are allowed");if(t==="limit")u.type=s,u.price=this.priceToPrecision(e,n),u.amount=this.amountToPrecision(e,i),h?u.type=s+"_ioc":l?u.type=s+"_fok":p&&(u.type=s+"_maker");else if(t==="market"){if(s==="sell")u.type=s+"_market",u.amount=this.amountToPrecision(e,i);else if(s==="buy")if(u.type=s+"_market",this.options.createMarketBuyOrderRequiresPrice){if(n===void 0)throw new kn(this.id+" createOrder () requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply the price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)");{const b=this.numberToString(i),w=this.numberToString(n),S=qH.stringMul(b,w),k=this.parseNumber(S);u.price=this.priceToPrecision(e,k)}}else u.price=i}o!==void 0&&(u.custom_id=o);let m;if(m=this.safeString(r,"method"),r=this.omit(r,"method"),m===void 0){const b=this.safeValue(this.options,"createOrder",{});m=this.safeString(b,"method","privatePostSupplementCreateOrder")}const g=await this[m](this.extend(u,r)),y=this.safeValue(g,"data",{});return{id:this.safeString(y,"order_id"),info:y}}parseOrderStatus(e){const t={"-1":"canceled",0:"open",1:"open",2:"closed",3:"canceled",4:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString2(e,"orderId","order_id"),i=this.safeString2(e,"clientOrderId","custom_id"),n=this.safeInteger2(e,"time","create_time"),r=this.safeString(e,"status"),a=this.safeString(e,"symbol");t=this.safeMarket(a,t);let o,d=!1,c="limit";const u=this.safeString(e,"type"),h=u.split("_"),l=this.safeString(h,0),p=this.safeString(h,1);p==="market"&&(c="market"),p==="maker"&&(d=!0,o="PO"),p==="ioc"&&(o="IOC"),p==="fok"&&(o="FOK");const m=this.safeString(e,"price"),g=this.safeString(e,"cummulativeQuoteQty");let y;u!=="buy_market"&&(y=this.safeString2(e,"origQty","amount"));const b=this.safeString2(e,"executedQty","deal_amount");return this.safeOrder({id:s,clientOrderId:i,datetime:this.iso8601(n),timestamp:n,lastTradeTimestamp:void 0,status:this.parseOrderStatus(r),symbol:t.symbol,type:c,timeInForce:o,postOnly:d,side:l,price:m,stopPrice:void 0,cost:g,amount:y,filled:b,remaining:void 0,trades:void 0,fee:void 0,info:e,average:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();let i=this.safeString(s,"method");if(i===void 0){const r=this.safeValue(this.options,"fetchOrder",{});i=this.safeString(r,"method","fetchOrderSupplement")}return await this[i](e,t,s)}async fetchOrderSupplement(e,t=void 0,s={}){if(await this.loadMarkets(),t===void 0)throw new Kr(this.id+" fetchOrder () requires a symbol argument");const n={symbol:this.market(t).id,orderId:e},r=await this.privatePostSupplementOrdersInfo(this.extend(n,s)),a=this.safeValue(r,"data",{});return this.parseOrder(a)}async fetchOrderDefault(e,t=void 0,s={}){if(await this.loadMarkets(),t===void 0)throw new Kr(this.id+" fetchOrder () requires a symbol argument");const n={symbol:this.market(t).id,order_id:e},r=await this.privatePostOrdersInfo(this.extend(n,s)),a=this.safeValue(r,"data",[]),o=a.length;if(o===1)return this.parseOrder(a[0]);{const d=[];for(let c=0;c<o;c++){const u=this.parseOrder(a[c]);d.push(u)}return d}}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Kr(this.id+" fetchMyTrades () requires a symbol argument");await this.loadMarkets();const n=this.market(e);t=this.safeValue(i,"start_date",t),i=this.omit(i,"start_date");const r={symbol:n.id};s!==void 0&&(r.size=s),t!==void 0&&(r.start_date=this.ymd(t,"-"));const a=await this.privatePostTransactionHistory(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Kr(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e);s===void 0&&(s=100);const r={symbol:n.id,current_page:1,page_length:s},a=await this.privatePostSupplementOrdersInfoHistory(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"orders",[]);return this.parseOrders(d,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Kr(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e);s===void 0&&(s=100);const r={symbol:n.id,current_page:1,page_length:s},a=await this.privatePostSupplementOrdersInfoNoDeal(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"orders",[]);return this.parseOrders(d,n,t,s)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Kr(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.safeString2(s,"origClientOrderId","clientOrderId");s=this.omit(s,["origClientOrderId","clientOrderId"]);const r={symbol:this.market(t).id};i!==void 0&&(r.origClientOrderId=i),r.orderId=e;const a=await this.privatePostSupplementCancelOrder(this.extend(r,s));return this.safeValue(a,"data",{})}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new Kr(this.id+" cancelAllOrders() requires a symbol argument");await this.loadMarkets();const i={symbol:this.market(e).id},n=await this.privatePostSupplementCancelOrderBySymbol(this.extend(i,t));return this.safeValue(n,"data",[])}getNetworkCodeForCurrency(e,t){const s=this.safeValue(this.options,"defaultNetworks"),i=this.safeStringUpper(s,e),n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper(t,"network",i);return r=this.safeString(n,r,r),r}async fetchDepositAddress(e,t={}){await this.loadMarkets();let s=this.safeString(t,"method");if(t=this.omit(t,"method"),s===void 0){const i=this.safeValue(this.options,"fetchDepositAddress",{});s=this.safeString(i,"method","fetchPrivateTradingFees")}return await this[s](e,t)}async fetchDepositAddressDefault(e,t={}){await this.loadMarkets();const i={assetCode:this.currency(e).id},n=this.getNetworkCodeForCurrency(e,t);n!==void 0&&(i.netWork=n,t=this.omit(t,"network"));const r=await this.privatePostGetDepositAddress(this.extend(i,t)),a=this.safeValue(r,"data"),o=this.safeString(a,"address"),d=this.safeString(a,"memo"),c=this.safeString(a,"netWork"),u=this.safeValue(this.options,"inverse-networks",{}),h=this.safeStringUpper(u,c,c);return{currency:e,address:o,tag:d,network:h,info:r}}async fetchDepositAddressSupplement(e,t={}){await this.loadMarkets();const i={coin:this.currency(e).id},n=this.safeValue(this.options,"networks");let r=this.safeStringUpper(t,"network");r=this.safeString(n,r,r),r!==void 0&&(i.networkName=r,t=this.omit(t,"network"));const a=await this.privatePostSupplementGetDepositAddress(this.extend(i,t)),o=this.safeValue(a,"data"),d=this.safeString(o,"address"),c=this.safeString(o,"memo"),u=this.safeValue(this.options,"inverse-networks",{}),h=this.safeStringUpper(u,r,r);return{currency:e,address:d,tag:c,network:h,info:a}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.safeString(n,"fee");if(n=this.omit(n,"fee"),r===void 0)throw new Kr(this.id+" withdraw () requires a fee argument to be supplied in params, the relevant coin network fee can be found by calling fetchTransactionFees (), note: if no network param is supplied then the default network will be used, this can also be found in fetchTransactionFees ()");const a=this.currency(e),o={address:s,coin:a.id,amount:t,fee:r};i!==void 0&&(o.memo=i);const d=this.safeStringUpper2(n,"network","networkName");n=this.omit(n,["network","networkName"]);const c=this.safeValue(this.options,"networks"),u=this.safeString(c,d,d);u!==void 0&&(o.networkName=u);const h=await this.privatePostSupplementWithdraw(this.extend(o,n)),l=this.safeValue(h,"data",{});return{info:l,id:this.safeString(l,"withdrawId")}}parseTransactionStatus(e,t){const s={deposit:{1:"pending",2:"ok",3:"failed",4:"canceled",5:"transfer"},withdrawal:{1:"pending",2:"canceled",3:"failed",4:"ok"}};return this.safeString(this.safeValue(s,t,{}),e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id");let i;s===void 0?i="deposit":i="withdrawal";const n=this.safeString(e,"txId"),r=this.safeInteger2(e,"insertTime","applyTime"),a=this.safeValue(this.options,"inverse-networks",{}),o=this.safeString(e,"networkName"),d=this.safeString(a,o,o),c=this.safeString(e,"address");let u,h;i==="deposit"?u=c:h=c;const l=this.safeNumber(e,"amount"),p=this.safeString2(e,"coin","coid"),m=this.safeCurrencyCode(p,t),g=this.parseTransactionStatus(this.safeString(e,"status"),i);let y;const b=this.safeNumber(e,"fee");return b!==void 0&&(y={cost:b,currency:m}),{info:e,id:s,txid:n,timestamp:r,datetime:this.iso8601(r),network:d,address:c,addressTo:h,addressFrom:u,tag:void 0,tagTo:void 0,tagFrom:void 0,type:i,amount:l,currency:m,status:g,updated:void 0,comment:void 0,internal:g==="transfer",fee:y}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.coin=r.id),t!==void 0&&(n.startTime=t);const a=await this.privatePostSupplementDepositHistory(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"depositOrders",[]);return this.parseTransactions(d,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.coin=r.id),t!==void 0&&(n.startTime=t);const a=await this.privatePostSupplementWithdraws(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"withdraws",[]);return this.parseTransactions(d,r,t,s)}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=this.checkRequiredCredentials(!1);let i;if(s===!0){let n=this.safeString(t,"method");if(t=this.omit(t,"method"),n===void 0){const r=this.safeValue(this.options,"fetchTransactionFees",{});n=this.safeString(r,"method","fetchPrivateTransactionFees")}i=await this[n](t)}else i=await this.fetchPublicTransactionFees(t);return i}async fetchPrivateTransactionFees(e={}){await this.loadMarkets();const t=await this.privatePostSupplementUserInfo(),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"coin"),o=this.safeCurrencyCode(a),d=this.safeValue(r,"networkList",[]);i[o]={};for(let c=0;c<d.length;c++){const u=d[c],h=this.safeString(u,"name"),l=this.safeString(this.options["inverse-networks"],h,h),p=this.safeNumber(u,"withdrawFee");p!==void 0&&(i[o][l]=p)}}return{withdraw:i,deposit:{},info:t}}async fetchPublicTransactionFees(e={}){await this.loadMarkets();const t=this.safeString2(e,"coin","assetCode");e=this.omit(e,["coin","assetCode"]);const s={};if(t!==void 0){const a=this.currency(t);s.assetCode=a.id}const i=await this.publicGetWithdrawConfigs(this.extend(s,e)),n=this.safeValue(i,"data",[]),r={};for(let a=0;a<n.length;a++){const o=n[a];if(this.safeString(o,"canWithDraw")==="true"){const c=this.safeString(o,"assetCode"),u=this.safeCurrencyCode(c),h=this.safeString(o,"chain");let l=this.safeString(this.options["inverse-networks"],h,h);l===void 0&&(l=u);const p=this.safeString(o,"fee");r[u]===void 0&&(r[u]={}),r[u][l]=this.parseNumber(p)}}return{withdraw:r,deposit:{},info:i}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.omit(i,this.extractParams(e)),o=this.urls.api.rest+"/"+this.version+"/"+this.implodeParams(e,i);if(o+=".do",t==="public")Object.keys(a).length&&(o+="?"+this.urlencode(this.keysort(a)));else{this.checkRequiredCredentials();const d=this.milliseconds().toString(),c=this.uuid22()+this.uuid16();a=this.extend({api_key:this.apiKey},a);let u;this.secret.length>32?u="RSA":u="HmacSHA256";const h=this.rawencode(this.keysort(this.extend({echostr:c,signature_method:u,timestamp:d},a))),l=this.encode(h),m=this.hash(l).toUpperCase();let g;if(u==="RSA"){const y=this.safeValue(this.options,"cacheSecretAsPem",!0);let b;y?(b=this.safeValue(this.options,"pem"),b===void 0&&(b=this.convertSecretToPem(this.encode(this.secret)),this.options.pem=b)):b=this.convertSecretToPem(this.encode(this.secret));const w=this.encode(b);g=this.binaryToBase64(this.rsa(m,w,"RS256"))}else u==="HmacSHA256"&&(g=this.hmac(this.encode(m),this.encode(this.secret)));a.sign=g,r=this.urlencode(this.keysort(a)),n={"Content-Type":"application/x-www-form-urlencoded",timestamp:d,signature_method:u,echostr:c}}return{url:o,method:s,body:r,headers:n}}convertSecretToPem(e){const s=e.length-0;let i=parseInt(s/64);i=this.sum(i,1);let n=`-----BEGIN PRIVATE KEY-----
`;for(let r=0;r<i;r++){const a=r*64,o=this.sum(a,64);n+=this.secret.slice(a,o)+`
`}return n+"-----END PRIVATE KEY-----"}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;if(this.safeString(a,"result")==="false"){const u=this.safeString(a,"error_code"),h=this.safeString({1e4:"Internal error",10001:"The required parameters can not be empty",10002:"Validation failed",10003:"Invalid parameter",10004:"Request too frequent",10005:"Secret key does not exist",10006:"User does not exist",10007:"Invalid signature",10008:"Invalid Trading Pair",10009:"Price and/or Amount are required for limit order",10010:"Price and/or Amount must be less than minimum requirement",10013:"The amount is too small",10014:"Insufficient amount of money in the account",10015:"Invalid order type",10016:"Insufficient account balance",10017:"Server Error",10018:"Page size should be between 1 and 50",10019:"Cancel NO more than 3 orders in one request",10020:"Volume < 0.001",10021:"Price < 0.01",10022:"Invalid authorization",10023:"Market Order is not supported yet",10024:"User cannot trade on this pair",10025:"Order has been filled",10026:"Order has been cancelld",10027:"Order is cancelling",10028:"Wrong query time",10029:"from is not in the query time",10030:"from do not match the transaction type of inqury",10031:"echostr length must be valid and length must be from 30 to 40",10033:"Failed to create order",10036:"customID duplicated",10100:"Has no privilege to withdraw",10101:"Invalid fee rate to withdraw",10102:"Too little to withdraw",10103:"Exceed daily limitation of withdraw",10104:"Cancel was rejected",10105:"Request has been cancelled",10106:"None trade time",10107:"Start price exception",10108:"can not create order",10109:"wallet address is not mapping",10110:"transfer fee is not mapping",10111:"mount > 0",10112:"fee is too lower",10113:"transfer fee is 0",10600:"intercepted by replay attacks filter, check timestamp",10601:"Interface closed unavailable",10701:"invalid asset code",10702:"not allowed deposit"},u,this.json(a)),l=this.safeValue({10001:di,10002:Jf,10003:di,10004:EH,10005:Jf,10006:Jf,10007:Jf,10008:Mv,10009:kn,10010:kn,10013:kn,10014:G0,10015:kn,10016:G0,10017:dr,10018:di,10019:di,10020:di,10021:kn,10022:eh,10023:kn,10024:eh,10025:kn,10026:kn,10027:kn,10028:di,10029:di,10030:di,10031:NH,10033:dr,10036:BH,10100:eh,10101:di,10102:G0,10103:dr,10104:dr,10105:dr,10106:di,10107:di,10108:dr,10109:AH,10110:dr,10111:di,10112:di,10113:di,10600:di,10601:dr,10701:Mv,10702:eh},u,dr);throw new l(h)}}};const RH=me,{TICK_SIZE:FH}=pe,{ExchangeError:DH,ArgumentsRequired:HH,InvalidNonce:GH,OrderNotFound:U0,InvalidOrder:Bc,InsufficientFunds:UH,AuthenticationError:Pv,DDoSProtection:Av,NotSupported:$H,BadSymbol:jH}=oe,WH=ke;var zH=class extends RH{describe(){return this.deepExtend(super.describe(),{id:"liquid",name:"Liquid",countries:["JP","CN","TW"],version:"2",rateLimit:1e3,has:{CORS:void 0,spot:!0,margin:void 0,swap:void 0,future:!1,option:!1,cancelOrder:!0,createOrder:!0,editOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPositionMode:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchWithdrawals:!0,transfer:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/45798859-1a872600-bcb4-11e8-8746-69291ce87b04.jpg",api:{rest:"https://api.liquid.com"},www:"https://www.liquid.com",doc:["https://developers.liquid.com"],fees:"https://help.liquid.com/getting-started-with-liquid/the-platform/fee-structure",referral:"https://www.liquid.com/sign-up/?affiliate=SbzC62lt30976"},api:{public:{get:["currencies","products","products/{id}","products/{id}/price_levels","executions","ir_ladders/{currency}","fees"]},private:{get:["accounts","accounts/balance","accounts/main_asset","accounts/{id}","accounts/{currency}/reserved_balance_details","crypto_accounts","crypto_withdrawal","crypto_withdrawals","crypto_withdrawals/crypto_networks","executions/me","fiat_accounts","fund_infos","loan_bids","loans","orders","orders/{id}","orders/{id}/trades","trades","trades/{id}/loans","trading_accounts","trading_accounts/{id}","transactions","withdrawals","user/fee_tier","user/fees","trading_accounts/{id}","bank_accounts","accounts/{currency}/reserved_balance_details"],post:["crypto_withdrawals","fund_infos","fiat_accounts","loan_bids","orders","withdrawals","fees/estimate"],put:["crypto_withdrawal/{id}/cancel","loan_bids/{id}/close","loans/{id}","orders/{id}","orders/{id}/cancel","trades/{id}","trades/{id}/adjust_margin","trades/{id}/close","trades/close_all","trading_accounts/{id}","withdrawals/{id}/cancel"]}},fees:{trading:{tierBased:!0,percentage:!0,taker:.003,maker:0,tiers:{perpetual:{maker:[[0,0],[25e3,0],[5e4,-25e-5],[1e5,-25e-5],[1e6,-25e-5],[1e7,-25e-5],[25e6,-25e-5],[5e7,-25e-5],[75e6,-25e-5],[1e8,-25e-5],[2e8,-25e-5],[3e8,-25e-5]],taker:[[0,.0012],[25e3,.00115],[5e4,.0011],[1e5,.00105],[1e6,.001],[1e7,95e-5],[25e6,9e-4],[5e7,85e-5],[75e6,8e-4],[1e8,75e-5],[2e8,7e-4],[3e8,65e-5]]},spot:{taker:[[0,.003],[1e4,.0029],[2e4,.0028],[5e4,.0026],[1e5,.002],[1e6,.0016],[5e6,.0012],[1e7,.001],[25e6,9e-4],[5e7,8e-4],[1e8,7e-4],[2e8,6e-4],[5e8,4e-4],[1e9,3e-4]],maker:[[0,0],[1e4,.002],[2e4,.0019],[5e4,.0018],[1e5,.0016],[1e6,8e-4],[5e6,7e-4],[1e7,5e-4],[25e6,0],[5e7,0],[1e8,0],[2e8,0],[5e8,0],[1e9,0]]}}}},precisionMode:FH,exceptions:{exact:{"API rate limit exceeded. Please retry after 300s":Av,"API Authentication failed":Pv,"Nonce is too small":GH,"Order not found":U0,"Can not update partially filled order":Bc,"Can not update non-live order":U0,not_enough_free_balance:UH,must_be_positive:Bc,less_than_order_size:Bc,price_too_high:Bc,price_too_small:Bc,product_disabled:jH},broad:{"is not in your IP whitelist":Pv}},commonCurrencies:{BIFI:"BIFIF",HOT:"HOT Token",MIOTA:"IOTA","P-BTC":"BTC",TON:"Tokamak Network"},options:{cancelOrderException:!0,networks:{ETH:"ERC20",TRX:"TRC20",XLM:"Stellar",ALGO:"Algorand"},swap:{fetchMarkets:{settlementCurrencies:["BTC","ETH","XRP","QASH","USD","JPY","EUR","SGD","AUD"]}}}})}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.safeString(n,"name"),d=this.safeValue(n,"depositable"),c=this.safeValue(n,"withdrawable"),u=d&&c,h=this.parseNumber(this.parsePrecision(this.safeString(n,"assets_precision")));s[a]={id:r,code:a,info:n,name:o,active:u,deposit:d,withdraw:c,fee:this.safeNumber(n,"withdrawal_fee"),precision:h,limits:{amount:{min:h,max:void 0},withdraw:{min:this.safeNumber(n,"minimum_withdrawal"),max:void 0}}}}return s}async fetchMarkets(e={}){const t=await this.publicGetProducts(e),s=await this.publicGetProducts({perpetual:"1"}),i=await this.fetchCurrencies(),n=this.indexBy(i,"code"),r=[],a=this.arrayConcat(t,s);for(let o=0;o<a.length;o++){const d=a[o],c=this.safeString(d,"id"),u=this.safeString(d,"base_currency"),h=this.safeString(d,"quoted_currency"),p=this.safeString(d,"product_type")==="Perpetual",m=p?"swap":"spot",g=!p,y=this.safeCurrencyCode(u),b=this.safeCurrencyCode(h),w=this.safeValue(d,"disabled",!1),S=this.safeValue(n,y);let k;S!==void 0&&(k=this.safeNumber(S.info,"minimum_order_quantity"));const T=this.safeNumber(d,"last_traded_price");let I,_;if(T){const A=this.safeNumber(d,"multiplier_down"),V=this.safeNumber(d,"multiplier_up");A!==void 0&&(I=T*A),V!==void 0&&(_=T*V)}const N=this.safeValue(d,"margin_enabled"),M=y+"/"+b,x=this.fees.trading.maker,v=this.fees.trading.taker,O={id:c,symbol:M,base:y,quote:b,settle:void 0,baseId:u,quoteId:h,settleId:void 0,type:m,spot:g,margin:g&&N,swap:p,future:!1,option:!1,active:!w,contract:p,linear:void 0,inverse:void 0,taker:v,maker:x,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber("0.00000001"),price:this.safeNumber(d,"tick_size")},limits:{leverage:{min:void 0,max:void 0},amount:{min:k,max:void 0},price:{min:I,max:_},cost:{min:void 0,max:void 0}},info:d};if(p){const A=this.options.fetchMarkets.settlementCurrencies;for(let V=0;V<A.length;V++){const q=A[V];O.settle=q,O.symbol=M+":"+q,O.linear=b===q,O.inverse=y===q,O.taker=this.safeNumber(d,"taker_fee",v),O.maker=this.safeNumber(d,"maker_fee",x),O.contractSize=this.parseNumber("1"),r.push(O)}}else r.push(O)}return r}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"crypto_accounts",[]),i=this.safeValue(e,"fiat_accounts",[]);for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.account();d.total=this.safeString(r,"balance"),d.used=this.safeString(r,"reserved_balance"),t[o]=d}for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.account();d.total=this.safeString(r,"balance"),d.used=this.safeString(r,"reserved_balance"),t[o]=d}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccounts(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={id:i.id},r=await this.publicGetProductsIdPriceLevels(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"buy_price_levels","sell_price_levels")}parseTicker(e,t=void 0){const s=this.milliseconds();let i;"last_traded_price"in e&&e.last_traded_price&&e.last_traded_price.length>0&&(i=this.safeString(e,"last_traded_price"));const n=this.safeString(e,"id");t=this.safeMarket(n,t);let r=t.symbol;const a=this.safeString(e,"base_currency"),o=this.safeString(e,"quoted_currency");a!==void 0&&o!==void 0&&(r=this.safeCurrencyCode(a)+"/"+this.safeCurrencyCode(o));const d=this.safeString(e,"last_price_24h");return this.safeTicker({symbol:r,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high_market_ask"),low:this.safeString(e,"low_market_bid"),bid:this.safeString(e,"market_bid"),bidVolume:void 0,ask:this.safeString(e,"market_ask"),askVolume:void 0,vwap:void 0,open:d,close:i,last:i,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume_24h"),quoteVolume:void 0,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetProducts(t),i={};for(let n=0;n<s.length;n++){const r=this.parseTicker(s[n]),a=r.symbol;i[a]=r}return this.filterByArray(i,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={id:s.id},n=await this.publicGetProductsId(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"created_at"),i=this.safeString(e,"order_id"),n=this.safeString(e,"taker_side"),r=this.safeString(e,"my_side"),a=r!==void 0?r:n;let o;r!==void 0&&(o=n===r?"taker":"maker");const d=this.safeString(e,"price"),c=this.safeString(e,"quantity"),u=this.safeString(e,"id");return t=this.safeMarket(void 0,t),this.safeTrade({info:e,id:u,order:i,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:void 0,side:a,takerOrMaker:o,price:d,amount:c,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={product_id:n.id};s!==void 0&&(r.limit=s),t!==void 0&&(r.timestamp=parseInt(t/1e3));const a=await this.publicGetExecutions(this.extend(r,i)),o=t!==void 0?a:a.models;return this.parseTrades(o,n,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={id:s.id},n=await this.publicGetProductsId(this.extend(i,t));return this.parseTradingFee(n,s)}parseTradingFee(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeSymbol(s,t);return{info:e,symbol:i,maker:this.safeNumber(e,"maker_fee"),taker:this.safeNumber(e,"taker_fee"),percentage:!0,tierBased:!0}}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetProducts(e),s=await this.publicGetProducts({perpetual:"1"}),i=this.arrayConcat(t,s),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"id"),d=this.safeSymbol(o,a);n[d]=this.parseTradingFee(a)}return n}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={product_id:n.id,with_details:!0};s!==void 0&&(r.limit=s);const a=await this.privateGetExecutionsMe(this.extend(r,i));return this.parseTrades(a.models,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.safeString2(r,"clientOrderId","client_order_id");r=this.omit(r,["clientOrderId","client_order_id"]);const o=this.market(e),d={order_type:t,product_id:o.id,side:s,quantity:this.amountToPrecision(o.symbol,i)};a!==void 0&&(d.client_order_id=a),(t==="limit"||t==="limit_post_only"||t==="market_with_range"||t==="stop")&&(d.price=this.priceToPrecision(o.symbol,n));const c=await this.privatePostOrders(this.extend(d,r));return this.parseOrder(c)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privatePutOrdersIdCancel(this.extend(i,s)),r=this.parseOrder(n);if(r.status==="closed"&&this.options.cancelOrderException)throw new U0(this.id+" order closed already: "+this.json(n));return r}async editOrder(e,t,s,i,n,r=void 0,a={}){if(await this.loadMarkets(),r===void 0)throw new HH(this.id+" editOrder() requires the price argument");const o={order:{quantity:this.amountToPrecision(t,n),price:this.priceToPrecision(t,r)},id:e},d=await this.privatePutOrdersId(this.extend(o,a));return this.parseOrder(d)}parseOrderStatus(e){const t={live:"open",filled:"closed",cancelled:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeTimestamp(e,"created_at"),n=this.safeString(e,"product_id");t=this.safeMarket(n,t);const r=this.parseOrderStatus(this.safeString(e,"status")),a=this.safeString(e,"quantity"),o=this.safeString(e,"filled_quantity"),d=this.safeString(e,"price"),c=this.safeString(e,"order_type"),u=this.safeString(e,"average_price"),h=this.safeValue(e,"executions",[]),l=this.safeString(e,"side"),p=this.safeString(e,"client_order_id");return this.safeOrder({id:s,clientOrderId:p,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,type:c,timeInForce:void 0,postOnly:void 0,status:r,symbol:t.symbol,side:l,price:d,stopPrice:void 0,amount:a,filled:o,cost:void 0,remaining:void 0,average:u,trades:h,fee:{currency:t.quote,cost:this.safeString(e,"order_fee")},info:e})}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetOrdersId(this.extend(i,s));return this.parseOrder(n)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={with_details:1};e!==void 0&&(n=this.market(e),r.product_id=n.id),s!==void 0&&(r.limit=s);const a=await this.privateGetOrders(this.extend(r,i)),o=this.safeValue(a,"models",[]);return this.parseOrders(o,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"live"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"filled"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={crypto_withdrawal:{currency:r.id,address:s,amount:t}};if(i!==void 0)if(e==="XRP")a.crypto_withdrawal.payment_id=i;else if(e==="XLM")a.crypto_withdrawal.memo_type="text",a.crypto_withdrawal.memo_value=i;else throw new $H(this.id+" withdraw() only supports a tag along the address for XRP or XLM");const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");if(d===void 0){const u=this.safeValue(n,"crypto_withdrawal",{});d=this.safeStringUpper(u,"network")}d=this.safeString(o,d,d),d!==void 0&&(a.crypto_withdrawal.network=d,n=this.omit(n,"network"),n.crypto_withdrawal=this.omit(n.crypto_withdrawal,"network"));const c=await this.privatePostCryptoWithdrawals(this.deepExtend(a,n));return this.parseTransaction(c,r)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e));const a=await this.privateGetCryptoWithdrawals(this.extend(n,i)),o=this.safeValue(a,"models",[]);return this.parseTransactions(o,r,t,s)}parseTransactionStatus(e){const t={pending:"pending",cancelled:"canceled",approved:"ok",processing:"pending",processed:"ok",reverted:"failed",to_be_reviewed:"pending",declined:"failed",broadcasted:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"address"),n=this.safeString2(e,"payment_id","memo_value"),r=this.safeString(e,"transaction_hash"),a=this.safeString2(e,"currency","asset"),o=this.safeCurrencyCode(a,t),d=this.safeTimestamp(e,"created_at"),c=this.safeTimestamp(e,"updated_at"),u="withdrawal",h=this.parseTransactionStatus(this.safeString(e,"state")),l=this.safeString(e,"amount"),p=this.safeString(e,"withdrawal_fee"),m=this.parseNumber(WH.stringSub(l,p)),g=this.safeString(e,"chain_name");return{info:e,id:s,txid:r,timestamp:d,datetime:this.iso8601(d),network:g,address:i,addressTo:void 0,addressFrom:void 0,tag:n,tagTo:void 0,tagFrom:void 0,type:u,amount:m,currency:o,status:h,updated:c,fee:{currency:o,cost:this.parseNumber(p)}}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(n={"X-Quoine-API-Version":this.version,"Content-Type":"application/json"},t==="private"){this.checkRequiredCredentials(),s==="GET"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):Object.keys(o).length&&(r=this.json(o));const d=this.nonce(),c={path:a,token_id:this.apiKey,iat:Math.floor(d/1e3)};"client_order_id"in o||(c.nonce=d),n["X-Quoine-Auth"]=this.jwt(c,this.encode(this.secret))}else Object.keys(o).length&&(a+="?"+this.urlencode(o));return a=this.urls.api.rest+a,{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(e>=200&&e<300)return;if(e===401){this.throwExactlyMatchedException(this.exceptions.exact,r,r);return}if(e===429)throw new Av(this.id+" "+r);if(a===void 0)return;const c=this.id+" "+r,u=this.safeString(a,"message"),h=this.safeValue(a,"errors");if(u!==void 0)this.throwExactlyMatchedException(this.exceptions.exact,u,c),this.throwBroadlyMatchedException(this.exceptions.broad,u,c);else if(h!==void 0){const l=Object.keys(h);for(let p=0;p<l.length;p++){const m=l[p],g=h[m];for(let y=0;y<g.length;y++){const b=g[y];this.throwExactlyMatchedException(this.exceptions.exact,b,c)}}}else throw new DH(c)}};const KH=me,{ExchangeError:th,ArgumentsRequired:Bv}=oe,{TICK_SIZE:XH}=pe,Do=ke;var G_=class extends KH{describe(){return this.deepExtend(super.describe(),{id:"luno",name:"luno",countries:["GB","SG","ZA"],rateLimit:200,version:"1",pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchAccounts:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},urls:{referral:"https://www.luno.com/invite/44893A",logo:"https://user-images.githubusercontent.com/1294454/27766607-8c1a69d8-5ede-11e7-930c-540b5eb9be24.jpg",api:{public:"https://api.luno.com/api",private:"https://api.luno.com/api",exchange:"https://api.luno.com/api/exchange"},www:"https://www.luno.com",doc:["https://www.luno.com/en/api","https://npmjs.org/package/bitx","https://github.com/bausmeier/node-bitx"]},api:{exchange:{get:{markets:1}},public:{get:{orderbook:1,orderbook_top:1,ticker:1,tickers:1,trades:1}},private:{get:{"accounts/{id}/pending":1,"accounts/{id}/transactions":1,balance:1,beneficiaries:1,fee_info:1,funding_address:1,listorders:1,listtrades:1,"orders/{id}":1,"quotes/{id}":1,withdrawals:1,"withdrawals/{id}":1,transfers:1},post:{accounts:1,"accounts/{id}/name":1,postorder:1,marketorder:1,stoporder:1,funding_address:1,withdrawals:1,send:1,quotes:1,"oauth2/grant":1},put:{"accounts/{id}/name":1,"quotes/{id}":1},delete:{"quotes/{id}":1,"withdrawals/{id}":1}}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0")}},precisionMode:XH})}async fetchMarkets(e={}){const t=await this.exchangeGetMarkets(e),s=[],i=this.safeValue(t,"markets",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"market_id"),o=this.safeString(r,"base_currency"),d=this.safeString(r,"counter_currency"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d),h=this.safeString(r,"trading_status");s.push({id:a,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:h==="ACTIVE",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"volume_scale"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"price_scale")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"min_volume"),max:this.safeNumber(r,"max_volume")},price:{min:this.safeNumber(r,"min_price"),max:this.safeNumber(r,"max_price")},cost:{min:void 0,max:void 0}},info:r})}return s}async fetchAccounts(e={}){const t=await this.privateGetBalance(e),s=this.safeValue(t,"balance",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"account_id"),o=this.safeString(r,"asset"),d=this.safeCurrencyCode(o);i.push({id:a,type:void 0,currency:d,info:r})}return i}parseBalance(e){const t=this.safeValue(e,"balance",[]),s={info:e,timestamp:void 0,datetime:void 0};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"asset"),a=this.safeCurrencyCode(r),o=this.safeString(n,"reserved"),d=this.safeString(n,"unconfirmed"),c=this.safeString(n,"balance"),u=Do.stringAdd(o,d),h=Do.stringAdd(c,d);if(a in s)s[a].used=Do.stringAdd(s[a].used,u),s[a].total=Do.stringAdd(s[a].total,h);else{const l=this.account();l.used=u,l.total=h,s[a]=l}}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();let i="publicGetOrderbook";t!==void 0&&t<=100&&(i+="Top");const n=this.market(e),r={pair:n.id},a=await this[i](this.extend(r,s)),o=this.safeInteger(a,"timestamp");return this.parseOrderBook(a,n.symbol,o,"bids","asks","price","volume")}parseOrderStatus(e){const t={PENDING:"open"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"creation_timestamp");let i=this.parseOrderStatus(this.safeString(e,"state"));i=i;let n;const r=this.safeString(e,"type");r==="ASK"||r==="SELL"?n="sell":(r==="BID"||r==="BUY")&&(n="buy");const a=this.safeString(e,"pair");t=this.safeMarket(a,t);const o=this.safeString(e,"limit_price"),d=this.safeString(e,"limit_volume"),c=this.safeNumber(e,"fee_counter"),u=this.safeNumber(e,"fee_base"),h=this.safeString(e,"base"),l=this.safeString(e,"counter");let p;c!==void 0?p={cost:c,currency:t.quote}:u!==void 0&&(p={cost:u,currency:t.base});const m=this.safeString(e,"order_id");return this.safeOrder({id:m,clientOrderId:void 0,datetime:this.iso8601(s),timestamp:s,lastTradeTimestamp:void 0,status:i,symbol:t.symbol,type:void 0,timeInForce:void 0,postOnly:void 0,side:n,price:o,stopPrice:void 0,amount:d,filled:h,cost:l,remaining:void 0,trades:void 0,fee:p,info:e,average:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetOrdersId(this.extend(i,s));return this.parseOrder(n)}async fetchOrdersByState(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a;e!==void 0&&(r.state=e),t!==void 0&&(a=this.market(t),r.pair=a.id);const o=await this.privateGetListorders(this.extend(r,n)),d=this.safeValue(o,"orders",[]);return this.parseOrders(d,a,s,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState(void 0,e,t,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState("PENDING",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState("COMPLETE",e,t,s,i)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"pair"),n=this.safeSymbol(i,t),r=this.safeString(e,"last_trade");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:void 0,low:void 0,bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"rolling_24_hour_volume"),quoteVolume:void 0,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTickers(t),i=this.indexBy(s.tickers,"pair"),n=Object.keys(i),r={};for(let a=0;a<n.length;a++){const o=n[a],d=this.safeMarket(o),c=d.symbol,u=i[o];r[c]=this.parseTicker(u,d)}return this.filterByArray(r,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetTicker(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t){const s=this.safeString(e,"order_id"),i=this.safeString(e,"sequence");let n,r;if(s!==void 0){const h=this.safeString(e,"type");h==="ASK"||h==="SELL"?r="sell":(h==="BID"||h==="BUY")&&(r="buy"),r==="sell"&&e.is_buy||r==="buy"&&!e.is_buy?n="maker":n="taker"}else r=e.is_buy?"buy":"sell";const a=this.safeString(e,"fee_base"),o=this.safeString(e,"fee_counter");let d,c;a!==void 0?Do.stringEquals(a,"0.0")||(d=t.base,c=a):o!==void 0&&(Do.stringEquals(o,"0.0")||(d=t.quote,c=o));const u=this.safeInteger(e,"timestamp");return this.safeTrade({info:e,id:i,timestamp:u,datetime:this.iso8601(u),symbol:t.symbol,order:s,type:void 0,side:r,takerOrMaker:n,price:this.safeString(e,"price"),amount:this.safeString2(e,"volume","base"),cost:this.safeString(e,"counter"),fee:{cost:c,currency:d}},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id};t!==void 0&&(r.since=t);const a=await this.publicGetTrades(this.extend(r,i)),o=this.safeValue(a,"trades",[]);return this.parseTrades(o,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Bv(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={pair:n.id};t!==void 0&&(r.since=t),s!==void 0&&(r.limit=s);const a=await this.privateGetListtrades(this.extend(r,i)),o=this.safeValue(a,"trades",[]);return this.parseTrades(o,n,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const i={symbol:this.market(e).id},n=await this.privateGetFeeInfo(this.extend(i,t));return{info:n,symbol:e,maker:this.safeNumber(n,"maker_fee"),taker:this.safeNumber(n,"taker_fee")}}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();let a="privatePost";const o=this.market(e),d={pair:o.id};t==="market"?(a+="Marketorder",d.type=s.toUpperCase(),s==="buy"?d.counter_volume=this.amountToPrecision(o.symbol,i):d.base_volume=this.amountToPrecision(o.symbol,i)):(a+="Postorder",d.volume=this.amountToPrecision(o.symbol,i),d.price=this.priceToPrecision(o.symbol,n),d.type=s==="buy"?"BID":"ASK");const c=await this[a](this.extend(d,r));return{info:c,id:c.order_id}}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e};return await this.privatePostStoporder(this.extend(i,s))}async fetchLedgerByEntries(e=void 0,t=-1,s=1,i={}){const r={min_row:t,max_row:this.sum(t,s)};return await this.fetchLedger(e,void 0,s,this.extend(r,i))}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.loadAccounts();let n,r=this.safeString(i,"id"),a=this.safeValue(i,"min_row"),o=this.safeValue(i,"max_row");if(r===void 0){if(e===void 0)throw new Bv(this.id+" fetchLedger() requires a currency code argument if no account id specified in params");n=this.currency(e);const h=this.indexBy(this.accounts,"currency"),l=this.safeValue(h,e);if(l===void 0)throw new th(this.id+" fetchLedger() could not find account id for "+e);r=l.id}if(a===void 0&&o===void 0)o=0,a=-1e3;else if(a===void 0||o===void 0)throw new th(this.id+" fetchLedger() require both params 'max_row' and 'min_row' or neither to be defined");if(s!==void 0&&o-a>s&&(o<=0?a=o-s:a>0&&(o=a+s)),o-a>1e3)throw new th(this.id+" fetchLedger() requires the params 'max_row' - 'min_row' <= 1000");const d={id:r,min_row:a,max_row:o},c=await this.privateGetAccountsIdTransactions(this.extend(i,d)),u=this.safeValue(c,"transactions",[]);return this.parseLedger(u,n,t,s)}parseLedgerComment(e){const t=e.split(" "),s={Withdrawal:"fee",Trading:"fee",Payment:"transaction",Sent:"transaction",Deposit:"transaction",Received:"transaction",Released:"released",Reserved:"reserved",Sold:"trade",Bought:"trade",Failure:"failed"};let i;const n=this.safeString(t,0),r=this.safeString(t,2),a=this.safeString(t,3);let o=this.safeString(s,n,void 0);return o===void 0&&r==="fee"&&(o="fee"),o==="reserved"&&a==="order"&&(i=this.safeString(t,4)),{type:o,referenceId:i}}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"row_index"),i=this.safeString(e,"account_id"),n=this.safeValue(e,"timestamp"),r=this.safeString(e,"currency"),a=this.safeCurrencyCode(r,t),o=this.safeNumber(e,"available_delta"),d=this.safeNumber(e,"balance_delta"),c=this.safeNumber(e,"balance"),u=this.safeString(e,"description");let h=c,l=0;const p=this.parseLedgerComment(u),m=p.type,g=p.referenceId;let y,b;return d!==0?(h=c-d,b="ok",l=Math.abs(d)):o<0?(b="pending",l=Math.abs(o)):o>0&&(b="canceled",l=Math.abs(o)),d>0||o>0?y="in":(d<0||o<0)&&(y="out"),{id:s,direction:y,account:i,referenceId:g,referenceAccount:void 0,type:m,currency:a,amount:l,timestamp:n,datetime:this.iso8601(n),before:h,after:c,status:b,fee:void 0,info:e}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(Object.keys(o).length&&(a+="?"+this.urlencode(o)),t==="private"){this.checkRequiredCredentials();const d=this.stringToBase64(this.apiKey+":"+this.secret);n={Authorization:"Basic "+this.decode(d)}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;if(this.safeValue(a,"error")!==void 0)throw new th(this.id+" "+this.json(a))}};const YH=me,{NotSupported:QH,ExchangeError:Xr,BadRequest:ZH,InsufficientFunds:Nc,InvalidOrder:Zi,DuplicateOrderId:JH}=oe,{TICK_SIZE:e9}=pe,t9=ke;var s9=class extends YH{describe(){return this.deepExtend(super.describe(),{id:"lykke",name:"Lykke",countries:["UK"],version:"2",rateLimit:200,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,editOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:"emulated",fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchOrderTrades:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!1,fetchTransactions:!0,fetchWithdrawals:!1,setLeverage:!1,setMarginMode:!1,withdraw:!0},requiredCredentials:{apiKey:!0,secret:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/155840500-1ea4fdf0-47c0-4daa-9597-c6c1cd51b9ec.jpg",api:{public:"https://hft-apiv2.lykke.com/api",private:"https://hft-apiv2.lykke.com/api"},www:"https://www.lykke.com",doc:["https://hft-apiv2.lykke.com/swagger/ui/index.html","https://lykkecity.github.io/Trading-API"],fees:"https://support.lykke.com/hc/en-us/articles/115002141125-What-are-the-fees-and-charges-"},api:{public:{get:{assetpairs:2.5,"assetpairs/{id}":2.5,assets:2.5,"assets/{id}":2.5,isalive:2.5,orderbooks:2.5,tickers:2.5,prices:2.5,"trades/public/{assetPairId}":2.5}},private:{get:{balance:2.5,trades:2.5,"trades/order/{orderId}":2.5,"orders/active":1,"orders/closed":1,"orders/{orderId}":1,operations:2.5,"operations/deposits/addresses":2.5,"operations/deposits/addresses/{assetId}":2.5},post:{"orders/limit":1,"orders/market":1,"orders/bulk":1,"operations/withdrawals":2.5,"operations/deposits/addresses":2.5},delete:{orders:1,"orders/{orderId}":1}}},fees:{trading:{tierBased:!1,percentage:!0,maker:0,taker:0}},precisionMode:e9,exceptions:{exact:{1001:Xr,1100:Xr,1101:Xr,2e3:ZH,2001:Nc,2202:JH,2003:Xr,2004:QH,2005:Xr,2006:Nc,2007:Nc,2008:Nc,2009:Xr,2010:Nc,2011:Zi,2012:Zi,2013:Zi,2014:Zi,2015:Zi,2016:Zi,2017:Zi,2018:Zi,2019:Zi,2020:Zi,2021:Zi,2022:Zi,2023:Xr},broad:{}},commonCurrencies:{}})}async fetchCurrencies(e={}){const t=await this.publicGetAssets(e),s=this.safeValue(t,"payload",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"assetId"),o=this.safeString(r,"symbol"),d=this.safeString(r,"name"),c=this.safeString(r,"type"),u=this.safeValue(r,"blockchainDepositEnabled"),h=this.safeValue(r,"blockchainWithdrawal"),p=!this.safeValue(r,"isDisabled");i[o]={id:a,code:o,info:r,type:c,name:d,active:p,deposit:u,withdraw:h,fee:void 0,precision:this.parseNumber(this.parsePrecision(this.safeString(r,"accuracy"))),limits:{withdraw:{min:this.safeValue(r,"cashoutMinimalAmount"),max:void 0},amount:{min:this.safeValue(r,"lowVolumeAmount"),max:void 0}}}}return i}async fetchMarkets(e={}){const t=await this.publicGetAssetpairs(e),s=this.safeValue(t,"payload",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"assetPairId"),o=this.safeString(r,"name"),d=this.safeString(r,"baseAssetId"),c=this.safeString(r,"quoteAssetId"),[u,h]=o.split("/"),l=this.safeCurrencyCode(u),p=this.safeCurrencyCode(h),m=l+"/"+p;i.push({id:a,symbol:m,base:l,quote:p,baseId:d,quoteId:c,settle:void 0,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,contract:!1,active:!0,info:r,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"baseAssetAccuracy"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"priceAccuracy")))},limits:{amount:{min:this.safeNumber(r,"minVolume"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(r,"minOppositeVolume"),max:void 0},leverage:{min:void 0,max:void 0}}})}return i}parseTicker(e,t=void 0){const i=this.safeString(e,"assetPairId");t=this.safeMarket(i,t);const n=this.safeString(e,"lastPrice");return this.safeTicker({symbol:this.safeString(t,"symbol"),timestamp:void 0,datetime:this.iso8601(void 0),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:this.safeString(e,"priceChange"),percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volumeBase"),quoteVolume:this.safeString(e,"volumeQuote"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={assetPairIds:s.id},n=this.safeString(this.options,"fetchTickerMethod","publicGetTickers"),r=await this[n](this.extend(i,t)),a=this.safeValue(r,"payload",[]);return this.parseTicker(this.safeValue(a,0,{}),s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickers(t),i=this.safeValue(s,"payload",[]);return this.parseTickers(i,e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={assetPairId:i.id};t!==void 0&&(n.depth=t);const r=await this.publicGetOrderbooks(this.extend(n,s)),a=this.safeValue(r,"payload",[]),o=this.safeValue(a,0,{}),d=this.safeInteger(o,"timestamp");return this.parseOrderBook(o,i.symbol,d,"bids","asks","p","v")}parseTrade(e,t){const s=this.safeString(e,"assetPairId");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeString2(e,"id","id"),r=this.safeString(e,"orderId"),a=this.safeInteger(e,"timestamp"),o=this.safeString2(e,"price","price");let d=this.safeString2(e,"volume","amount");d===void 0&&(d=this.safeString2(e,"baseVolume","amount"));const c=this.safeStringLower(e,"side");return this.safeTrade({id:n,info:e,timestamp:a,datetime:this.iso8601(a),symbol:i,type:void 0,order:r,side:c,takerOrMaker:void 0,price:o,amount:d,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={assetPairId:n.id};s!==void 0&&(r.take=s);const a=await this.publicGetTradesPublicAssetPairId(this.extend(r,i)),o=this.safeValue(a,"payload",[]);return this.parseTrades(o,n,t,s)}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"assetId"),r=this.safeCurrencyCode(n),a=this.account(),o=this.safeString(i,"available"),d=this.safeString(i,"reserved");a.free=o,a.used=d,t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalance(e),s=this.safeValue(t,"payload",[]);return this.parseBalance(s)}parseOrderStatus(e){const t={Open:"open",Pending:"open",InOrderBook:"open",Processing:"open",Matched:"closed",Cancelled:"canceled",Rejected:"rejected",Replaced:"canceled",Placed:"open"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.parseOrderStatus(this.safeString(e,"status")),n=this.safeString(e,"assetPairId"),r=this.safeSymbol(n,t),a=this.safeStringLower(e,"type"),o=this.safeInteger(e,"lastTradeTimestamp"),d=this.safeInteger(e,"timestamp"),c=this.safeString(e,"price"),u=this.safeStringLower(e,"side"),h=this.safeString(e,"volume"),l=this.safeString(e,"remainingVolume"),p=this.safeString(e,"filledVolume"),m=this.safeString(e,"cost");return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:d,datetime:this.iso8601(d),lastTradeTimestamp:o,symbol:r,type:a,timeInForce:void 0,postOnly:void 0,side:u,price:c,stopPrice:void 0,amount:h,cost:m,average:void 0,filled:p,remaining:l,status:i,fee:void 0,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={assetPairId:a.id,side:this.capitalize(s),volume:parseFloat(this.amountToPrecision(a.symbol,i))};t==="limit"&&(o.price=parseFloat(this.priceToPrecision(a.symbol,n)));const d="privatePostOrders"+this.capitalize(t),c=await this[d](this.extend(o,r)),u=this.safeValue(c,"payload"),h=this.safeString(u,"orderId");return t==="market"&&(n=this.safeNumber(u,"price")),{id:h,info:c,clientOrderId:void 0,timestamp:void 0,datetime:void 0,lastTradeTimestamp:void 0,symbol:a.symbol,type:t,side:s,price:n,amount:i,cost:void 0,average:void 0,filled:void 0,remaining:void 0,status:void 0,fee:void 0,trades:void 0}}async cancelOrder(e,t=void 0,s={}){const i={orderId:e};return await this.privateDeleteOrdersOrderId(this.extend(i,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;return e!==void 0&&(i=this.market(e),s.assetPairId=i.id),await this.privateDeleteOrders(this.extend(s,t))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e},n=await this.privateGetOrdersOrderId(this.extend(i,s)),r=this.safeValue(n,"payload");return this.parseOrder(r)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));const r={};s!==void 0&&(r.take=s);const a=await this.privateGetOrdersActive(this.extend(r,i)),o=this.safeValue(a,"payload");return this.parseOrders(o,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));const r={};s!==void 0&&(r.take=s);const a=await this.privateGetOrdersClosed(this.extend(r,i)),o=this.safeValue(a,"payload");return this.parseOrders(o,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;s!==void 0&&(n.take=s),e!==void 0&&(r=this.market(e),n.assetPairId=r.id),t!==void 0&&(n.from=t);const a=await this.privateGetTrades(this.extend(n,i)),o=this.safeValue(a,"payload");return this.parseTrades(o,r,t,s)}parseBidAsk(e,t=0,s=1){const i=this.safeString(e,t),n=t9.stringAbs(this.safeString(e,s));return[this.parseNumber(i),this.parseNumber(n)]}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={assetId:this.safeString(s,"id")},n=await this.privateGetOperationsDepositsAddressesAssetId(this.extend(i,t)),r=this.safeString(n,"baseAddress"),a=this.safeString(n,"addressExtension");return this.checkAddress(r),{currency:e,address:r,tag:a,network:void 0,info:n}}parseTransaction(e,t=void 0){let s,i,n,r,a,o,d;if(typeof e=="string")s=e;else{s=this.safeString(e,"operationId"),i=this.safeString(e,"assetId"),n=this.safeCurrencyCode(i,t),r=this.safeNumber(e,"totalVolume"),o=this.safeString(e,"type"),d=this.safeInteger(e,"timestamp");const c=this.safeNumber(e,"fee");a={currency:n,cost:c}}return{info:e,id:s,txid:void 0,timestamp:d,datetime:this.iso8601(d),network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,type:o,amount:r,currency:n,status:void 0,updated:void 0,fee:a}}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};s!==void 0&&(n.take=s);const r=await this.privateGetOperations(this.extend(n,i)),a=this.safeValue(r,"payload",[]);let o;return e!==void 0&&(o=this.currency(e)),this.parseTransactions(a,o,t,s)}async withdraw(e,t,s,i=void 0,n={}){await this.loadMarkets(),this.checkAddress(s);const r=this.currency(e),a={assetId:r.id,volume:parseFloat(this.currencyToPrecision(e,t)),destinationAddress:s};i!==void 0&&(a.destinationAddressExtension=i);const o=await this.privatePostOperationsWithdrawals(this.extend(a,n));return this.parseTransaction(o,r)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));return n={Accept:"application/json","Content-Type":"application/json"},t==="public"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):t==="private"&&((s==="GET"||s==="DELETE")&&Object.keys(o).length&&(a+="?"+this.urlencode(o)),this.checkRequiredCredentials(),n.Authorization="Bearer "+this.apiKey,s==="POST"&&Object.keys(i).length&&(r=this.json(i)),e==="operations/withdrawals"&&(n["X-Request-ID"]=this.uuid())),{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeValue(a,"error",{}),u=this.safeString(c,"code");if(u!==void 0&&u!=="0"){const h=this.id+" "+r,l=this.safeString(c,"message");throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwBroadlyMatchedException(this.exceptions.broad,l,h),new Xr(h)}}};const i9=me,{ExchangeError:n9,ArgumentsRequired:Yr,InvalidOrder:r9}=oe,{TICK_SIZE:a9}=pe;var o9=class extends i9{describe(){return this.deepExtend(super.describe(),{id:"mercado",name:"Mercado Bitcoin",countries:["BR"],rateLimit:1e3,version:"v3",has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:"emulated",fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:void 0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},timeframes:{"15m":"15m","1h":"1h","3h":"3h","1d":"1d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27837060-e7c58714-60ea-11e7-9192-f05e86adb83f.jpg",api:{public:"https://www.mercadobitcoin.net/api",private:"https://www.mercadobitcoin.net/tapi",v4Public:"https://www.mercadobitcoin.com.br/v4",v4PublicNet:"https://api.mercadobitcoin.net/api/v4"},www:"https://www.mercadobitcoin.com.br",doc:["https://www.mercadobitcoin.com.br/api-doc","https://www.mercadobitcoin.com.br/trade-api","https://api.mercadobitcoin.net/api/v4/docs/"]},api:{public:{get:["coins","{coin}/orderbook/","{coin}/ticker/","{coin}/trades/","{coin}/trades/{from}/","{coin}/trades/{from}/{to}","{coin}/day-summary/{year}/{month}/{day}/"]},private:{post:["cancel_order","get_account_info","get_order","get_withdrawal","list_system_messages","list_orders","list_orderbook","place_buy_order","place_sell_order","place_market_buy_order","place_market_sell_order","withdraw_coin"]},v4Public:{get:["{coin}/candle/"]},v4PublicNet:{get:["candles"]}},fees:{trading:{maker:.003,taker:.007}},options:{limits:{BTC:.001,BCH:.001,ETH:.01,LTC:.01,XRP:.1}},precisionMode:a9})}async fetchMarkets(e={}){const t=await this.publicGetCoins(e),s=[],i=this.safeValue(this.options,"limits",{});for(let n=0;n<t.length;n++){const r=t[n],a=r,o="BRL",d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o),u=c+d,h="1e-5";s.push({id:u,symbol:d+"/"+c,base:d,quote:c,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber("0.00000001"),price:this.parseNumber("0.00001")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(i,a),max:void 0},price:{min:this.parseNumber(h),max:void 0},cost:{min:void 0,max:void 0}},info:r})}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={coin:i.base},r=await this.publicGetCoinOrderbook(this.extend(n,s));return this.parseOrderBook(r,i.symbol)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeTimestamp(e,"date"),n=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"vol"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={coin:s.base},n=await this.publicGetCoinTicker(this.extend(i,t)),r=this.safeValue(n,"ticker",{});return this.parseTicker(r,s)}parseTrade(e,t=void 0){const s=this.safeTimestamp2(e,"date","executed_timestamp");t=this.safeMarket(void 0,t);const i=this.safeString2(e,"tid","operation_id"),n=void 0,r=this.safeString(e,"type"),a=this.safeString(e,"price"),o=this.safeString2(e,"amount","quantity"),d=this.safeString(e,"fee_rate");let c;return d!==void 0&&(c={cost:d,currency:void 0}),this.safeTrade({id:i,info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:void 0,type:n,side:r,takerOrMaker:void 0,price:a,amount:o,cost:void 0,fee:c},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);let r="publicGetCoinTrades";const a={coin:n.base};t!==void 0&&(r+="From",a.from=parseInt(t/1e3)),this.safeInteger(i,"to")!==void 0&&(r+="To");const d=await this[r](this.extend(a,i));return this.parseTrades(d,n,t,s)}parseBalance(e){const t=this.safeValue(e,"response_data",{}),s=this.safeValue(t,"balance",{}),i={info:e},n=Object.keys(s);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeCurrencyCode(a);if(a in s){const d=this.safeValue(s,a,{}),c=this.account();c.free=this.safeString(d,"available"),c.total=this.safeString(d,"total"),i[o]=c}}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetAccountInfo(e);return this.parseBalance(t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={coin_pair:a.id};let d=this.capitalize(s)+"Order";if(t==="limit")d="privatePostPlace"+d,o.limit_price=this.priceToPrecision(a.symbol,n),o.quantity=this.amountToPrecision(a.symbol,i);else if(d="privatePostPlaceMarket"+d,s==="buy"){if(n===void 0)throw new r9(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount");o.cost=this.priceToPrecision(a.symbol,i*n)}else o.quantity=this.amountToPrecision(a.symbol,i);const c=await this[d](this.extend(o,r));return{info:c,id:c.response_data.order.order_id.toString()}}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Yr(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={coin_pair:i.id,order_id:e},r=await this.privatePostCancelOrder(this.extend(n,s)),a=this.safeValue(r,"response_data",{}),o=this.safeValue(a,"order",{});return this.parseOrder(o,i)}parseOrderStatus(e){const t={2:"open",3:"canceled",4:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"order_id"),i=this.safeString(e,"order_type");let n;"order_type"in e&&(n=i==="1"?"buy":"sell");const r=this.parseOrderStatus(this.safeString(e,"status")),a=this.safeString(e,"coin_pair");t=this.safeMarket(a,t);const o=this.safeTimestamp(e,"created_timestamp"),d={cost:this.safeString(e,"fee"),currency:t.quote},c=this.safeString(e,"limit_price"),u=this.safeString(e,"executed_price_avg"),h=this.safeString(e,"quantity"),l=this.safeString(e,"executed_quantity"),p=this.safeTimestamp(e,"updated_timestamp"),m=this.safeValue(e,"operations",[]);return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:p,symbol:t.symbol,type:"limit",timeInForce:void 0,postOnly:void 0,side:n,price:c,stopPrice:void 0,cost:void 0,average:u,amount:h,filled:l,remaining:void 0,status:r,fee:d,trades:m},t)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Yr(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={coin_pair:i.id,order_id:parseInt(e)},r=await this.privatePostGetOrder(this.extend(n,s)),a=this.safeValue(r,"response_data",{}),o=this.safeValue(a,"order");return this.parseOrder(o,i)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={coin:r.id,quantity:t.toFixed(10),address:s};if(e==="BRL"){if(!("account_ref"in n))throw new Yr(this.id+" withdraw() requires account_ref parameter to withdraw "+e)}else if(e!=="LTC"){if(!("tx_fee"in n))throw new Yr(this.id+" withdraw() requires tx_fee parameter to withdraw "+e);if(e==="XRP")if(i===void 0){if(!("destination_tag"in n))throw new Yr(this.id+" withdraw() requires a tag argument or destination_tag parameter to withdraw "+e)}else a.destination_tag=i}const o=await this.privatePostWithdrawCoin(this.extend(a,n)),d=this.safeValue(o,"response_data",{}),c=this.safeValue(d,"withdrawal");return this.parseTransaction(c,r)}parseTransaction(e,t=void 0){return t=this.safeCurrency(void 0,t),{id:this.safeString(e,"id"),txid:void 0,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0,info:e}}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="15m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={resolution:this.timeframes[t],symbol:r.base+"-"+r.quote};i===void 0&&(i=100),s!==void 0?(a.from=parseInt(s/1e3),a.to=this.sum(a.from,i*this.parseTimeframe(t))):(a.to=this.seconds(),a.from=a.to-i*this.parseTimeframe(t));const o=await this.v4PublicNetGetCandles(this.extend(a,n)),d=this.convertTradingViewToOHLCV(o,"t","o","h","l","c","v");return this.parseOHLCVs(d,r,t,s,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Yr(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={coin_pair:n.id},a=await this.privatePostListOrders(this.extend(r,i)),o=this.safeValue(a,"response_data",{}),d=this.safeValue(o,"orders",[]);return this.parseOrders(d,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Yr(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={coin_pair:n.id,status_list:"[2]"},a=await this.privatePostListOrders(this.extend(r,i)),o=this.safeValue(a,"response_data",{}),d=this.safeValue(o,"orders",[]);return this.parseOrders(d,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Yr(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={coin_pair:n.id,has_fills:!0},a=await this.privatePostListOrders(this.extend(r,i)),o=this.safeValue(a,"response_data",{}),d=this.safeValue(o,"orders",[]),c=this.parseOrders(d,n,t,s),u=this.ordersToTrades(c);return this.filterBySymbolSinceLimit(u,n.symbol,t,s)}ordersToTrades(e){const t=[];for(let s=0;s<e.length;s++){const i=this.safeValue(e[s],"trades",[]);for(let n=0;n<i.length;n++)t.push(i[n])}return t}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/";const o=this.omit(i,this.extractParams(e));if(t==="public"||t==="v4Public"||t==="v4PublicNet")a+=this.implodeParams(e,i),Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials(),a+=this.version+"/";const d=this.nonce();r=this.urlencode(this.extend({tapi_method:e,tapi_nonce:d},i));const c="/tapi/"+this.version+"/?"+r;n={"Content-Type":"application/x-www-form-urlencoded","TAPI-ID":this.apiKey,"TAPI-MAC":this.hmac(this.encode(c),this.encode(this.secret),"sha512")}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;if(this.safeValue(a,"error_message")!==void 0)throw new n9(this.id+" "+this.json(a))}};const d9=me,{AccountNotEnabled:c9,InvalidAddress:$0,ExchangeError:j0,BadRequest:u9,AuthenticationError:sh,RateLimitExceeded:f9,BadSymbol:Ga,InvalidOrder:Bi,InsufficientFunds:Nv,ArgumentsRequired:Ji,OrderNotFound:h9,PermissionDenied:W0,NotSupported:l9}=oe,{TICK_SIZE:p9}=pe,vn=ke;var U_=class extends d9{describe(){return this.deepExtend(super.describe(),{id:"mexc",name:"MEXC Global",countries:["SC"],rateLimit:50,version:"v2",certified:!0,pro:!0,has:{CORS:void 0,spot:!0,margin:void 0,swap:!0,future:!1,option:!1,addMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createMarketOrder:!1,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!1,createStopOrder:!0,fetchBalance:!0,fetchCanceledOrders:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchIndexOHLCV:!0,fetchLeverage:void 0,fetchLeverageTiers:!0,fetchMarginMode:!1,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionMode:!0,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!0,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransfer:!0,fetchTransfers:!0,fetchWithdrawals:!0,reduceMargin:!0,setLeverage:!0,setMarginMode:!1,setPositionMode:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","1d":"1d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/137283979-8b2a818d-8633-461b-bfca-de89e8c446b2.jpg",api:{spot:{public:"https://www.mexc.com/open/api/v2",private:"https://www.mexc.com/open/api/v2"},contract:{public:"https://contract.mexc.com/api/v1/contract",private:"https://contract.mexc.com/api/v1/private"}},www:"https://www.mexc.com/",doc:["https://mxcdevelop.github.io/APIDoc/"],fees:["https://www.mexc.com/fee"],referral:"https://m.mexc.com/auth/signup?inviteCode=1FQ1G"},api:{contract:{public:{get:{ping:2,detail:2,support_currencies:2,"depth/{symbol}":2,"depth_commits/{symbol}/{limit}":2,"index_price/{symbol}":2,"fair_price/{symbol}":2,"funding_rate/{symbol}":2,"kline/{symbol}":2,"kline/index_price/{symbol}":2,"kline/fair_price/{symbol}":2,"deals/{symbol}":2,ticker:2,risk_reverse:2,"risk_reverse/history":2,"funding_rate/history":2}},private:{get:{"account/assets":2,"account/asset/{currency}":2,"account/transfer_record":2,"position/list/history_positions":2,"position/open_positions":2,"position/funding_records":2,"position/position_mode":2,"order/list/open_orders/{symbol}":2,"order/list/history_orders":2,"order/external/{symbol}/{external_oid}":2,"order/get/{order_id}":2,"order/batch_query":8,"order/deal_details/{order_id}":2,"order/list/order_deals":2,"planorder/list/orders":2,"stoporder/list/orders":2,"stoporder/order_details/{stop_order_id}":2,"account/risk_limit":2,"account/tiered_fee_rate":2},post:{"position/change_margin":2,"position/change_leverage":2,"position/change_position_mode":2,"order/submit":2,"order/submit_batch":40,"order/cancel":2,"order/cancel_with_external":2,"order/cancel_all":2,"account/change_risk_level":2,"planorder/place":2,"planorder/cancel":2,"planorder/cancel_all":2,"stoporder/cancel":2,"stoporder/cancel_all":2,"stoporder/change_price":2,"stoporder/change_plan_price":2}}},spot:{public:{get:{"market/symbols":1,"market/coin/list":2,"common/timestamp":1,"common/ping":1,"market/ticker":1,"market/depth":1,"market/deals":1,"market/kline":1,"market/api_default_symbols":2}},private:{get:{"account/info":1,"order/open_orders":1,"order/list":1,"order/query":1,"order/deals":1,"order/deal_detail":1,"asset/deposit/address/list":2,"asset/deposit/list":2,"asset/address/list":2,"asset/withdraw/list":2,"asset/internal/transfer/record":10,"account/balance":10,"asset/internal/transfer/info":10,"market/api_symbols":2},post:{"order/place":1,"order/place_batch":1,"asset/withdraw":2,"asset/internal/transfer":10},delete:{"order/cancel":1,"order/cancel_by_symbol":1,"asset/withdraw":2}}}},precisionMode:p9,fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},options:{timeframes:{spot:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","1d":"1d","1M":"1M"},contract:{"1m":"Min1","5m":"Min5","15m":"Min15","30m":"Min30","1h":"Min60","4h":"Hour4","8h":"Hour8","1d":"Day1","1w":"Week1","1M":"Month1"}},defaultType:"spot",networks:{TRX:"TRC20",ETH:"ERC20",BEP20:"BEP20(BSC)",BSC:"BEP20(BSC)"},accountsByType:{spot:"MAIN",swap:"CONTRACT"},transfer:{accountsById:{MAIN:"spot",CONTRACT:"swap"},status:{SUCCESS:"ok",FAILED:"failed",WAIT:"pending"}},fetchOrdersByState:{method:"spotPrivateGetOrderList"},cancelOrder:{method:"spotPrivateDeleteOrderCancel"}},commonCurrencies:{BEYONDPROTOCOL:"BEYOND",BIFI:"BIFIF",BYN:"BeyondFi",COFI:"COFIX",DFI:"DfiStarter",DFT:"dFuture",DRK:"DRK",EGC:"Egoras Credit",FLUX1:"FLUX",FLUX:"FLUX1",FREE:"FreeRossDAO",GMT:"GMT Token",HERO:"Step Hero",MIMO:"Mimosa",PROS:"Pros.Finance",SIN:"Sin City Token",SOUL:"Soul Swap",STEPN:"GMT"},exceptions:{exact:{400:u9,401:sh,402:sh,403:W0,429:f9,703:W0,1e3:c9,1002:Bi,10072:sh,10073:sh,10075:W0,10101:Nv,10216:$0,10232:Ga,3e4:Ga,30001:Bi,30002:Bi,30003:Bi,30004:Nv,30005:Bi,30010:Bi,30014:Ga,30016:Ga,30019:Bi,30020:Ga,30021:Ga,33333:Ga},broad:{"price and quantity must be positive":Bi}}})}async fetchTime(e={}){const[t,s]=this.handleMarketTypeAndParams("fetchTime",void 0,e),i=this.getSupportedMapping(t,{spot:"spotPublicGetCommonTimestamp",swap:"contractPublicGetPing"}),n=await this[i](this.extend(s));return this.safeInteger(n,"data")}async fetchStatus(e={}){const t=await this.spotPublicGetCommonPing(e);return{status:this.safeInteger(t,"code")===200?"ok":"maintenance",updated:void 0,eta:void 0,url:void 0,info:t}}async fetchCurrencies(e={}){const t=await this.spotPublicGetMarketCoinList(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.safeString(r,"full_name");let c=!1,u,h,l,p;const m={},g=this.safeValue(r,"coins",[]);let y=!1,b=!1;for(let k=0;k<g.length;k++){const T=g[k],I=this.safeString(T,"chain"),_=this.safeNetwork(I),N=this.safeValue(T,"is_deposit_enabled",!1),M=this.safeValue(T,"is_withdraw_enabled",!1),x=N&&M;c=x||c;const v=this.safeString(T,"withdraw_limit_min"),O=this.safeString(T,"withdraw_limit_max");l=l===void 0?v:l,p=p===void 0?O:p,vn.stringGt(l,v)&&(l=v),vn.stringLt(p,O)&&(p=O),N&&(y=!0),M&&(b=!0);const A=this.parsePrecision(this.safeString(T,"precision"));A!==void 0&&(u=u===void 0?A:vn.stringMin(A,u)),m[_]={info:T,id:I,network:_,active:x,deposit:N,withdraw:M,fee:this.safeNumber(T,"fee"),precision:this.parseNumber(u),limits:{withdraw:{min:v,max:O}}}}const S=Object.keys(m).length;if(S===1||"NONE"in m){const k=this.safeValue2(m,"NONE",S-1);k!==void 0&&(h=k.fee)}i[o]={id:a,code:o,info:r,name:d,active:c,deposit:y,withdraw:b,fee:h,precision:this.parseNumber(u),limits:{amount:{min:void 0,max:void 0},withdraw:{min:l,max:p}},networks:m}}return i}async fetchMarkets(e={}){const t=this.safeString2(this.options,"fetchMarkets","defaultType","spot"),s=this.safeString(e,"type",t),i=this.omit(e,"type"),n=s==="spot",r=s==="swap";if(!n&&!r)throw new j0(this.id+" does not support '"+s+"' type, set exchange.options['defaultType'] to 'spot' or 'swap''");if(n)return await this.fetchSpotMarkets(i);if(r)return await this.fetchContractMarkets(i)}async fetchContractMarkets(e={}){const t=await this.contractPublicGetDetail(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeString(r,"baseCoin"),d=this.safeString(r,"quoteCoin"),c=this.safeString(r,"settleCoin"),u=this.safeCurrencyCode(o),h=this.safeCurrencyCode(d),l=this.safeCurrencyCode(c),p=this.safeString(r,"state");i.push({id:a,symbol:u+"/"+h+":"+l,base:u,quote:h,settle:l,baseId:o,quoteId:d,settleId:c,type:"swap",spot:!1,margin:!1,swap:!0,future:!1,option:!1,active:p==="0",contract:!0,linear:!0,inverse:!1,taker:this.safeNumber(r,"takerFeeRate"),maker:this.safeNumber(r,"makerFeeRate"),contractSize:this.safeNumber(r,"contractSize"),expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(r,"volUnit"),price:this.safeNumber(r,"priceUnit")},limits:{leverage:{min:this.safeNumber(r,"minLeverage"),max:this.safeNumber(r,"maxLeverage")},amount:{min:this.safeNumber(r,"minVol"),max:this.safeNumber(r,"maxVol")},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}async fetchSpotMarkets(e={}){const t=await this.spotPublicGetMarketSymbols(e),s=this.safeValue(t,"data",[]),i=await this.spotPublicGetMarketApiDefaultSymbols(e),n=this.safeValue(i,"data",{}),r=this.safeValue(n,"symbol",[]),a=[];for(let o=0;o<s.length;o++){const d=s[o],c=this.safeString(d,"symbol"),[u,h]=c.split("_"),l=this.safeCurrencyCode(u),p=this.safeCurrencyCode(h),m=this.safeString(d,"state");let g=!1;for(let y=0;y<r.length;y++)if(r[y]===c){m==="ENABLED"&&(g=!0);break}a.push({id:c,symbol:l+"/"+p,base:l,quote:p,settle:void 0,baseId:u,quoteId:h,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:g,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(d,"taker_fee_rate"),maker:this.safeNumber(d,"maker_fee_rate"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(d,"quantity_scale"))),price:this.parseNumber(this.parsePrecision(this.safeString(d,"price_scale")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(d,"min_amount"),max:this.safeNumber(d,"max_amount")}},info:d})}return a}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeString(e,0);let i;s!==void 0&&(i=this.market(s));const[n,r]=this.handleMarketTypeAndParams("fetchTickers",i,t),a=this.getSupportedMapping(n,{spot:"spotPublicGetMarketTicker",swap:"contractPublicGetTicker"}),o=await this[a](this.extend(r)),d=this.safeValue(o,"data",[]);return this.parseTickers(d,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let n;s.spot?n="spotPublicGetMarketTicker":s.swap&&(n="contractPublicGetTicker");const r=await this[n](this.extend(i,t));if(s.spot){const a=this.safeValue(r,"data",[]),o=this.safeValue(a,0);return this.parseTicker(o,s)}else if(s.swap){const a=this.safeValue(r,"data",{});return this.parseTicker(a,s)}}parseTicker(e,t=void 0){const s=this.safeInteger2(e,"time","timestamp"),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t,"_"),r=this.safeString2(e,"volume","volume24"),a=this.safeString(e,"amount24"),o=this.safeString(e,"open"),d=this.safeString2(e,"last","lastPrice"),c=this.safeString(e,"riseFallValue"),u=this.safeString(e,"riseFallRate"),h=vn.stringAdd(u,"1");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString2(e,"high","high24Price"),low:this.safeString2(e,"low","lower24Price"),bid:this.safeString2(e,"bid","bid1"),bidVolume:void 0,ask:this.safeString2(e,"ask","ask1"),askVolume:void 0,vwap:void 0,open:o,close:d,last:d,previousClose:void 0,change:c,percentage:h,average:void 0,baseVolume:r,quoteVolume:a,info:e},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};let r;i.spot?(r="spotPublicGetMarketDepth",t===void 0&&(t=100),n.depth=t):i.swap&&(r="contractPublicGetDepthSymbol",t!==void 0&&(n.limit=t));const a=await this[r](this.extend(n,s)),o=this.safeValue(a,"data",{}),d=i.spot?"price":0,c=i.spot?"quantity":1,u=this.safeInteger(o,"timestamp"),h=this.parseOrderBook(o,e,u,"bids","asks",d,c);return h.nonce=this.safeInteger(o,"version"),h}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s);let a;n.spot?a="spotPublicGetMarketDeals":n.swap&&(a="contractPublicGetDealsSymbol");const o=await this[a](this.extend(r,i)),d=this.safeValue(o,"data",[]);return this.parseTrades(d,n,t,s)}parseTrade(e,t=void 0){let s=this.safeInteger2(e,"create_time","trade_time");s=this.safeInteger(e,"t",s);const i=this.safeString(e,"symbol");t=this.safeMarket(i,t,"_");const n=t.symbol;let r=this.safeString2(e,"price","trade_price");r=this.safeString(e,"p",r);let a=this.safeString2(e,"quantity","trade_quantity");a=this.safeString(e,"v",a);const o=this.safeString(e,"amount");let d=this.safeString2(e,"trade_type","T");d==="BID"||d==="1"?d="buy":(d==="ASK"||d==="2")&&(d="sell");let c=this.safeString2(e,"id","trade_time");c===void 0&&(c=this.safeString(e,"t",c),c!==void 0&&(c+="-"+t.id+"-"+a));const u=this.safeString(e,"fee");let h;if(u!==void 0){const g=this.safeString(e,"fee_currency"),y=this.safeCurrencyCode(g);h={cost:u,currency:y}}const l=this.safeString(e,"order_id"),m=this.safeValue(e,"is_taker",!0)?"taker":"maker";return this.safeTrade({info:e,id:c,order:l,timestamp:s,datetime:this.iso8601(s),symbol:n,type:void 0,side:d,takerOrMaker:m,price:r,amount:a,cost:o,fee:h},t)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.spotPublicGetMarketSymbols(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),d=this.safeMarket(a,void 0,"_").symbol;i[d]={info:r,symbol:d,maker:this.safeNumber(r,"maker_fee_rate"),taker:this.safeNumber(r,"taker_fee_rate"),percentage:!0,tierBased:!1}}return i}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.safeValue(this.options,"timeframes",{}),o=this.safeValue(a,r.type,{}),d=this.safeString(o,t);if(d===void 0)throw new l9(this.id+" fetchOHLCV() does not support "+t+" timeframe for "+r.type+" markets");const c={symbol:r.id,interval:d};let u;r.spot?(u="spotPublicGetMarketKline",s!==void 0&&(c.start_time=parseInt(s/1e3)),i!==void 0&&(c.limit=i)):r.swap&&(u="contractPublicGetKlineSymbol",s!==void 0&&(c.start=parseInt(s/1e3)));const h=await this[u](this.extend(c,n));if(r.spot){const l=this.safeValue(h,"data",[]);return this.parseOHLCVs(l,r,t,s,i)}else if(r.swap){const l=this.safeValue(h,"data",{}),p=this.convertTradingViewToOHLCV(l,"time","open","high","low","close","vol");return this.parseOHLCVs(p,r,t,s,i)}}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,t.spot?3:2),this.safeNumber(e,t.spot?4:3),this.safeNumber(e,t.spot?2:4),this.safeNumber(e,5)]}async fetchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),i=this.getSupportedMapping(t,{spot:"spotPrivateGetAccountInfo",margin:"spotPrivateGetAccountInfo",swap:"contractPrivateGetAccountAssets"}),n=t==="spot",r=await this[i](s),a=this.safeValue(r,"data",{}),o=this.milliseconds(),d={info:r,timestamp:o,datetime:this.iso8601(o)};if(n){const c=Object.keys(a);for(let u=0;u<c.length;u++){const h=c[u],l=this.safeCurrencyCode(h),p=this.safeValue(a,h,{}),m=this.account();m.free=this.safeString(p,"available"),m.used=this.safeString(p,"frozen"),d[l]=m}}else for(let c=0;c<a.length;c++){const u=a[c],h=this.safeString(u,"currency"),l=this.safeCurrencyCode(h),p=this.account();p.free=this.safeString(u,"availableBalance"),p.used=this.safeString(u,"frozenBalance"),d[l]=p}return this.safeBalance(d)}safeNetwork(e){if(e.indexOf("BSC")>=0)return"BEP20";e=e.split(" ").join(""),e=e.replace("-20","20");const s={ETH:"ETH",ERC20:"ERC20","BEP20(BSC)":"BEP20",TRX:"TRC20"};return this.safeString(s,e,e)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeCurrencyCode(void 0,t),n=this.safeString(e,"chain"),r=this.safeNetwork(n);return this.checkAddress(s),{currency:i,address:s,tag:void 0,network:r,info:e}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=await this.spotPrivateGetAssetDepositAddressList(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"chains",[]),o=[];for(let d=0;d<a.length;d++){const c=this.parseDepositAddress(a[d],s);o.push(c)}return this.indexBy(o,"network")}async fetchDepositAddress(e,t={}){const s=this.safeStringUpper(t,"network");t=this.omit(t,"network");const i=await this.fetchDepositAddressesByNetwork(e,t),n=this.safeValue(this.options,"networks",{}),r=this.safeString(n,s,s);let a;if(r===void 0){if(a=this.safeValue(i,e),a===void 0){const o=this.safeString(n,e,e);if(a=this.safeValue(i,o),a===void 0){const d=this.safeString(this.options,"defaultNetwork","ERC20");if(a=this.safeValue(i,d),a===void 0){const c=Object.values(i);if(a=this.safeValue(c,0),a===void 0)throw new $0(this.id+" fetchDepositAddress() cannot find deposit address for "+e)}}}return a}if(a=this.safeValue(i,s),a===void 0)throw new $0(this.id+" fetchDepositAddress() cannot find "+r+" deposit address for "+e);return a}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),t!==void 0&&(n.start_time=t),s!==void 0&&(n.limit=s);const a=await this.spotPrivateGetAssetDepositList(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"result_list",[]);return this.parseTransactions(d,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),t!==void 0&&(n.start_time=t),s!==void 0&&(n.limit=s);const a=await this.spotPrivateGetAssetWithdrawList(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"result_list",[]);return this.parseTransactions(d,r,t,s)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=s===void 0?"deposit":"withdrawal",n=this.parse8601(this.safeString(e,"create_time")),r=this.parse8601(this.safeString(e,"update_time"));let a=this.safeString(e,"currency"),o;if(a!==void 0&&a.indexOf("-")>=0){const g=a.split("-");a=this.safeString(g,0);const y=this.safeString(g,1);o=this.safeNetwork(y)}const d=this.safeCurrencyCode(a,t),c=this.parseTransactionStatus(this.safeString(e,"state"));let u=this.safeString(e,"amount");const h=this.safeString(e,"address"),l=this.safeString(e,"tx_id");let p;const m=this.safeString(e,"fee");return m!==void 0&&(p={cost:this.parseNumber(m),currency:d}),i==="withdrawal"&&(u=vn.stringSub(u,m)),{info:e,id:s,txid:l,timestamp:n,datetime:this.iso8601(n),network:o,address:h,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:i,amount:this.parseNumber(u),currency:d,status:c,updated:r,fee:p}}parseTransactionStatus(e){const t={WAIT:"pending",WAIT_PACKAGING:"pending",SUCCESS:"ok"};return this.safeString(t,e,e)}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.fetchPositions(this.extend(i,t)),r=this.safeValue(n,0);return this.parsePosition(r,s)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.contractPrivateGetPositionOpenPositions(t),i=this.safeValue(s,"data",[]);return this.parsePositions(i,e)}parsePosition(e,t=void 0){t=this.safeMarket(this.safeString(e,"symbol"),t);const s=t.symbol,i=this.safeString(e,"holdVol"),n=this.safeNumber(e,"openAvgPrice"),r=this.safeString(e,"im"),o=this.safeString(e,"positionType")==="1"?"long":"short",c=this.safeString(e,"margin_mode")==="1"?"isolated":"cross",u=this.safeString(e,"leverage"),h=this.safeNumber(e,"liquidatePrice"),l=this.safeNumber(e,"updateTime");return{info:e,symbol:s,contracts:this.parseNumber(i),contractSize:void 0,entryPrice:n,collateral:void 0,side:o,unrealizedProfit:void 0,leverage:this.parseNumber(u),percentage:void 0,marginMode:c,notional:void 0,markPrice:void 0,liquidationPrice:h,initialMargin:this.parseNumber(r),initialMarginPercentage:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,marginRatio:void 0,timestamp:l,datetime:this.iso8601(l)}}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),[o,d]=this.handleMarketTypeAndParams("createOrder",a,r);if(o==="spot")return await this.createSpotOrder(e,t,s,i,n,d);if(o==="swap")return await this.createSwapOrder(e,t,s,i,n,d)}async createSpotOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o;s==="buy"?o="BID":s==="sell"&&(o="ASK");let d=t.toUpperCase();const c=d==="MARKET";if(c)throw new Bi(this.id+" createOrder () does not support market orders, only limit orders are allowed");d==="LIMIT"&&(d="LIMIT_ORDER");const u=this.isPostOnly(c,d==="POST_ONLY",r),h=this.safeStringUpper(r,"timeInForce");if(u?d="POST_ONLY":h==="IOC"&&(d="IMMEDIATE_OR_CANCEL"),h==="FOK")throw new Bi(this.id+" createOrder () does not support timeInForce FOK, only IOC, PO, and GTC are allowed");if(d!=="POST_ONLY"&&d!=="IMMEDIATE_OR_CANCEL"&&d!=="LIMIT_ORDER")throw new Bi(this.id+" createOrder () does not support "+t+" order type, only LIMIT, LIMIT_ORDER, POST_ONLY or IMMEDIATE_OR_CANCEL are allowed");const p={symbol:a.id,price:this.priceToPrecision(e,n),quantity:this.amountToPrecision(e,i),trade_type:o,order_type:d},m=this.safeString2(r,"clientOrderId","client_order_id");m!==void 0&&(p.client_order_id=m),r=this.omit(r,["type","clientOrderId","client_order_id","postOnly","timeInForce"]);const g=await this.spotPrivatePostOrderPlace(this.extend(p,r));return this.parseOrder(g,a)}async createSwapOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeInteger(r,"openType");if(o===void 0)throw new Ji(this.id+" createSwapOrder () requires an integer openType parameter, 1 for isolated margin, 2 for cross margin");if(t!=="limit"&&t!=="market"&&t!==1&&t!==2&&t!==3&&t!==4&&t!==5&&t!==6)throw new Bi(this.id+" createSwapOrder () order type must either limit, market, or 1 for limit orders, 2 for post-only orders, 3 for IOC orders, 4 for FOK orders, 5 for market orders or 6 to convert market price to current price");const d=t==="market"||t===5;this.isPostOnly(d,t===2,r)?t=2:t==="limit"?t=1:t==="market"&&(t=5);const u=this.safeStringUpper(r,"timeInForce");if(u==="IOC"?t=3:u==="FOK"&&(t=4),s!==1&&s!==2&&s!==3&&s!==4)throw new Bi(this.id+" createSwapOrder () order side must be 1 open long, 2 close short, 3 open short or 4 close long");const p={symbol:a.id,vol:parseFloat(this.amountToPrecision(e,i)),side:s,type:t,openType:o};let m="contractPrivatePostOrderSubmit";const g=this.safeNumber2(r,"triggerPrice","stopPrice");if(r=this.omit(r,["stopPrice","triggerPrice","timeInForce","postOnly"]),g!==void 0&&(m="contractPrivatePostPlanorderPlace",p.triggerPrice=this.priceToPrecision(e,g),p.triggerType=this.safeInteger(r,"triggerType",1),p.executeCycle=this.safeInteger(r,"executeCycle",1),p.trend=this.safeInteger(r,"trend",1),p.orderType=this.safeInteger(r,"orderType",t)),t!==5&&t!==6&&t!=="market"&&(p.price=parseFloat(this.priceToPrecision(e,n))),o===1&&this.safeInteger(r,"leverage")===void 0)throw new Ji(this.id+" createSwapOrder () requires a leverage parameter for isolated margin orders");const y=this.safeString2(r,"clientOrderId","externalOid");y!==void 0&&(p.externalOid=y),r=this.omit(r,["clientOrderId","externalOid"]);const b=await this[m](this.extend(p,r));return this.parseOrder(b,a)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Ji(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=this.safeValue(this.options,"cancelOrder",{}),r=this.safeString(n,"method","spotPrivateDeleteOrderCancel");let a=this.safeString(s,"method",r);const o=this.safeValue(s,"stop");let d={};if(i.type==="spot"){a="spotPrivateDeleteOrderCancel";const h=this.safeString2(s,"clientOrderId","client_order_ids");h!==void 0?(s=this.omit(s,["clientOrderId","client_order_ids"]),d.client_order_ids=h):d.order_ids=e}else if(o)if(a="contractPrivatePostPlanorderCancel",d=[],Array.isArray(e))for(let h=0;h<e.length;h++)d.push({symbol:i.id,orderId:e[h]});else typeof e=="string"&&d.push({symbol:i.id,orderId:e});else i.type==="swap"&&(a="contractPrivatePostOrderCancel",d=[e]);const c=await this[a](d);let u=this.safeValue(c,"data",[]);return o&&(u=c),this.parseOrder(u,i)}parseOrderStatus(e,t=void 0){let s={};return t.type==="spot"?s={NEW:"open",FILLED:"closed",PARTIALLY_FILLED:"open",CANCELED:"canceled",PARTIALLY_CANCELED:"canceled"}:t.type==="swap"?s={2:"open",3:"closed",4:"canceled"}:s={1:"open",2:"canceled",3:"closed"},this.safeString(s,e,e)}parseOrder(e,t=void 0){let s=this.safeString2(e,"data","id"),i;if(s===void 0){const T=Object.keys(e);s=this.safeString(T,0),this.safeString(e,s)==="success"&&(i="canceled")}const n=this.safeString(e,"state"),r=this.safeInteger2(e,"create_time","createTime"),a=this.safeString(e,"price"),o=this.safeString2(e,"quantity","vol"),d=this.safeString(e,"remain_quantity"),c=this.safeString2(e,"deal_quantity","dealVol"),u=this.safeString(e,"deal_amount"),h=this.safeString(e,"symbol"),l=this.safeSymbol(h,t,"_"),p=this.safeInteger(e,"side");let m;const g=this.safeString(e,"type");g==="BID"?m="buy":g==="ASK"&&(m="sell"),p===1?m="open long":m===2?m="close short":m===3?m="open short":m===4&&(m="close long"),i=this.parseOrderStatus(n,t);const y=this.safeString2(e,"client_order_id","orderId"),b=this.safeString2(e,"orderType","order_type");let w,S,k;return b!==void 0&&(k=!1,b==="1"?(w="limit",S="GTC"):b==="2"?(w="limit",S="PO",k=!0):b==="3"?(w="limit",S="IOC"):b==="4"?(w="limit",S="FOK"):b==="5"||b==="6"?(w="market",S="GTC"):b==="LIMIT_ORDER"?(w="limit",S="GTC"):b==="POST_ONLY"?(w="limit",S="PO",k=!0):b==="IMMEDIATE_OR_CANCEL"&&(w="limit",S="IOC")),this.safeOrder({id:s,clientOrderId:y,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:this.safeInteger(e,"updateTime"),status:i,symbol:l,type:w,timeInForce:S,postOnly:k,side:m,price:a,stopPrice:this.safeString(e,"triggerPrice"),average:this.safeString(e,"dealAvgPrice"),amount:o,cost:u,filled:c,remaining:d,fee:void 0,trades:void 0,info:e},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Ji(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id},[a,o]=this.handleMarketTypeAndParams("fetchOpenOrders",n,i),d=this.getSupportedMapping(a,{spot:"spotPrivateGetOrderOpenOrders",swap:"contractPrivateGetOrderListOpenOrdersSymbol"});if(this.safeValue(i,"stop"))return await this.fetchOrdersByState("1",e,t,s,i);const u=await this[d](this.extend(r,o)),h=this.safeValue(u,"data",[]);return this.parseOrders(h,n,t,s)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Ji(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),[n,r]=this.handleMarketTypeAndParams("fetchOrder",i,s),a={order_ids:e},o=this.getSupportedMapping(n,{spot:"spotPrivateGetOrderQuery",swap:"contractPrivateGetOrderBatchQuery"}),d=await this[o](this.extend(a,r)),c=this.safeValue(d,"data",[]),u=this.safeValue(c,0);if(u===void 0)throw new h9(this.id+" fetchOrder() could not find the order id "+e);return this.parseOrder(u,i)}async fetchOrdersByState(e,t=void 0,s=void 0,i=void 0,n={}){if(t===void 0)throw new Ji(this.id+" fetchOrdersByState() requires a symbol argument");await this.loadMarkets();const r=this.market(t),a={symbol:r.id,states:e},o=this.safeValue(n,"stop"),d=o?"page_size":"limit";i!==void 0&&(a[d]=i),s!==void 0&&(a.start_time=s);const c=this.safeValue(this.options,"fetchOrdersByState",{}),u=this.safeString(c,"method","spotPrivateGetOrderList");let h=this.safeString(n,"method",u);h=this.getSupportedMapping(r.type,{spot:"spotPrivateGetOrderList",swap:"contractPrivateGetOrderListHistoryOrders"}),o&&(h="contractPrivateGetPlanorderListOrders");const l=this.omit(n,["method","stop"]),p=await this[h](this.extend(a,l)),m=this.safeValue(p,"data",[]);return this.parseOrders(m,r,s,i)}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Ji(this.id+" fetchCanceledOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=this.safeValue(i,"stop");let a="CANCELED";return n.type==="swap"?a="4":r&&(a="2"),await this.fetchOrdersByState(a,e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Ji(this.id+" fetchClosedOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=this.safeValue(i,"stop");let a="FILLED";return(r||n.type==="swap")&&(a="3"),await this.fetchOrdersByState(a,e,t,s,i)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let n=this.getSupportedMapping(s.type,{spot:"spotPrivateDeleteOrderCancelBySymbol",swap:"contractPrivatePostOrderCancelAll"});this.safeValue(t,"stop")&&(n="contractPrivatePostPlanorderCancelAll");const a=this.omit(t,["method","stop"]);return await this[n](this.extend(i,a))}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Ji(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};t!==void 0&&(r.start_time=t),s!==void 0&&(r.limit=s);const a=await this.spotPrivateGetOrderDeals(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;t!==void 0&&(r=this.market(t));const a={order_id:e},o=await this.spotPrivateGetOrderDealDetail(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseTrades(d,r,s,i)}async modifyMarginHelper(e,t,s,i={}){const n=this.safeInteger(i,"positionId");if(n===void 0)throw new Ji(this.id+" modifyMarginHelper() requires a positionId parameter");await this.loadMarkets();const r=this.market(e);t=this.amountToPrecision(e,t);const a={positionId:n,amount:t,type:s},o=await this.contractPrivatePostPositionChangeMargin(this.extend(a,i)),d=s==="ADD"?"add":"reduce";return this.extend(this.parseMarginModification(o,r),{amount:this.parseNumber(t),type:d})}parseMarginModification(e,t=void 0){const i=this.safeValue(e,"success")===!0?"ok":"failed";return{info:e,type:void 0,amount:void 0,code:void 0,symbol:this.safeSymbol(void 0,t),status:i}}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"SUB",s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"ADD",s)}async setLeverage(e,t=void 0,s={}){await this.loadMarkets();const i={leverage:e},n=this.safeInteger(s,"positionId");if(n===void 0){const r=this.safeNumber(s,"openType"),a=this.safeNumber(s,"positionType"),o=t!==void 0?this.market(t):void 0;if(r===void 0||a===void 0||o===void 0)throw new Ji(this.id+" setLeverage() requires a positionId parameter or a symbol argument with openType and positionType parameters, use openType 1 or 2 for isolated or cross margin respectively, use positionType 1 or 2 for long or short positions");i.openType=r,i.symbol=o.id,i.positionType=a}else i.positionId=n;return await this.contractPrivatePostPositionChangeLeverage(this.extend(i,s))}async fetchTransfer(e,t=void 0,s={}){const i={transact_id:e},n=await this.spotPrivateGetAssetInternalTransferInfo(this.extend(i,s)),r=this.safeValue(n,"data",{});return this.parseTransfer(r)}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.currency(e),n.currency=r.id),t!==void 0&&(n.start_time=t),s!==void 0){if(s>50)throw new j0("This exchange supports a maximum limit of 50");n["page-size"]=s}const a=await this.spotPrivateGetAssetInternalTransferRecord(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"result_list",[]);return this.parseTransfers(d,r,t,s)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c={currency:r.id,amount:t,from:o,to:d},u=await this.spotPrivatePostAssetInternalTransfer(this.extend(c,n)),h=this.safeValue(u,"data",{});return this.parseTransfer(h,r)}parseTransfer(e,t=void 0){const s=this.safeValue(this.options,"transfer",{}),i=this.safeValue(s,"status",{}),n=this.safeString(e,"currency"),r=this.safeString(e,"transact_id"),a=this.safeString(e,"from"),o=this.safeString(e,"to"),d=this.safeValue(s,"accountsById",{}),c=this.safeString(d,a),u=this.safeString(d,o),h=this.safeString(e,"transact_state");return{info:e,id:r,timestamp:void 0,datetime:void 0,currency:this.safeCurrencyCode(n,t),amount:this.safeNumber(e,"amount"),fromAccount:c,toAccount:u,status:this.safeString(i,h)}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n);const r=this.safeValue(this.options,"networks",{});let a=this.safeStringUpper2(n,"network","chain");a=this.safeString(r,a,a),this.checkAddress(s),await this.loadMarkets();const o=this.currency(e);i!==void 0&&(s+=":"+i);const d={currency:o.id,address:s,amount:t};a!==void 0&&(d.chain=a,n=this.omit(n,["network","chain"]));const c=await this.spotPrivatePostAssetWithdraw(this.extend(d,n)),u=this.safeValue(c,"data",{});return{info:u,id:this.safeString(u,"withdrawId")}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const[a,o]=t;let d=this.urls.api[a][o]+"/"+this.implodeParams(e,i);if(i=this.omit(i,this.extractParams(e)),o==="public")Object.keys(i).length&&(d+="?"+this.urlencode(i));else{this.checkRequiredCredentials();const c=this.milliseconds().toString();let u="";n={ApiKey:this.apiKey,"Request-Time":c,"Content-Type":"application/json"},s==="POST"?(u=this.json(i),r=u):(i=this.keysort(i),Object.keys(i).length&&(u+=this.urlencode(i),d+="?"+u)),u=this.apiKey+c+u;const h=this.hmac(this.encode(u),this.encode(this.secret),"sha256");n.Signature=h}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0||this.safeValue(a,"success",!1)===!0)return;const u=this.safeString(a,"code");if(u!=="200"&&u!=="0"){const h=this.id+" "+r;throw this.throwBroadlyMatchedException(this.exceptions.broad,r,h),this.throwExactlyMatchedException(this.exceptions.exact,u,h),new j0(h)}}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),s!==void 0&&(r.page_size=s);const a=await this.contractPrivateGetPositionFundingRecords(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"resultList",[]),c=[];for(let u=0;u<d.length;u++){const h=d[u],l=this.safeInteger(h,"settleTime");c.push({info:h,symbol:e,code:void 0,timestamp:l,datetime:this.iso8601(l),id:this.safeNumber(h,"id"),amount:this.safeNumber(h,"funding")})}return c}parseFundingRate(e,t=void 0){const s=this.safeNumber(e,"fundingRate"),i=this.safeInteger(e,"nextSettleTime"),n=this.safeString(e,"symbol"),r=this.safeSymbol(n,t),a=this.safeInteger(e,"timestamp"),o=this.iso8601(a);return{info:e,symbol:r,markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:a,datetime:o,fundingRate:s,fundingTimestamp:i,fundingDatetime:this.iso8601(i),nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.contractPublicGetFundingRateSymbol(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseFundingRate(r,s)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Ji(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.page_size=s);const a=await this.contractPublicGetFundingRateHistory(this.extend(r,i)),o=this.safeValue(a,"data"),d=this.safeValue(o,"resultList",[]),c=[];for(let h=0;h<d.length;h++){const l=d[h],p=this.safeString(l,"symbol"),m=this.safeSymbol(p),g=this.safeInteger(l,"settleTime");c.push({info:l,symbol:m,fundingRate:this.safeNumber(l,"fundingRate"),timestamp:g,datetime:this.iso8601(g)})}const u=this.sortBy(c,"timestamp");return this.filterBySymbolSinceLimit(u,n.symbol,t,s)}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const s=await this.contractPublicGetDetail(t),i=this.safeValue(s,"data");return this.parseLeverageTiers(i,e,"symbol")}parseMarketLeverageTiers(e,t){let s=this.safeString(e,"maintenanceMarginRate"),i=this.safeString(e,"initialMarginRate");const n=this.safeString(e,"maxVol"),r=this.safeString(e,"riskIncrVol"),a=this.safeString(e,"riskIncrMmr"),o=this.safeString(e,"riskIncrImr");let d="0";const c=[],u=this.safeString(e,"quoteCoin");for(;vn.stringLt(d,n);){const h=vn.stringAdd(d,r);c.push({tier:this.parseNumber(vn.stringDiv(h,r)),currency:this.safeCurrencyCode(u),minNotional:this.parseNumber(d),maxNotional:this.parseNumber(h),maintenanceMarginRate:this.parseNumber(s),maxLeverage:this.parseNumber(vn.stringDiv("1",i)),info:e}),i=vn.stringAdd(i,o),s=vn.stringAdd(s,a),d=h}return c}async setPositionMode(e,t=void 0,s={}){const i={positionMode:e?1:2};return await this.contractPrivatePostPositionChangePositionMode(this.extend(i,s))}async fetchPositionMode(e=void 0,t={}){const s=await this.contractPrivateGetPositionPositionMode(t),i=this.safeInteger(s,"data");return{info:s,hedged:i===1}}};const m9=me,{BadRequest:fs,InvalidNonce:g9,BadSymbol:Ev,InvalidOrder:Tn,InvalidAddress:y9,ExchangeError:Ua,ArgumentsRequired:_s,NotSupported:Vv,InsufficientFunds:$a,PermissionDenied:b9}=oe,{TICK_SIZE:w9}=pe,ci=ke;var S9=class extends m9{describe(){return this.deepExtend(super.describe(),{id:"mexc3",name:"MEXC Global",countries:["SC"],rateLimit:50,version:"v3",has:{CORS:void 0,spot:void 0,margin:!0,swap:void 0,future:void 0,option:void 0,addMargin:!0,borrowMargin:!0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:void 0,createDepositAddress:void 0,createLimitOrder:void 0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!0,deposit:void 0,editOrder:void 0,fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowRate:void 0,fetchBorrowRateHistory:void 0,fetchBorrowRates:void 0,fetchBorrowRatesPerSymbol:void 0,fetchCanceledOrders:!0,fetchClosedOrder:void 0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:void 0,fetchDepositAddress:!0,fetchDepositAddresses:void 0,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:void 0,fetchIndexOHLCV:!0,fetchL2OrderBook:!0,fetchLedger:void 0,fetchLedgerEntry:void 0,fetchLeverageTiers:!0,fetchMarginMode:!1,fetchMarketLeverageTiers:void 0,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrder:void 0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:void 0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionMode:!0,fetchPositions:!0,fetchPositionsRisk:void 0,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:void 0,fetchTradingFees:!0,fetchTradingLimits:void 0,fetchTransactionFee:"emulated",fetchTransactionFees:!0,fetchTransactions:void 0,fetchTransfer:!0,fetchTransfers:!0,fetchWithdrawal:void 0,fetchWithdrawals:!0,privateAPI:!0,publicAPI:!0,reduceMargin:!0,repayMargin:!0,setLeverage:!0,setMarginMode:void 0,setPositionMode:!0,signIn:void 0,transfer:void 0,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/137283979-8b2a818d-8633-461b-bfca-de89e8c446b2.jpg",api:{spot:{public:"https://api.mexc.com",private:"https://api.mexc.com"},spot2:{public:"https://www.mexc.com/open/api/v2",private:"https://www.mexc.com/open/api/v2"},contract:{public:"https://contract.mexc.com/api/v1/contract",private:"https://contract.mexc.com/api/v1/private"}},www:"https://www.mexc.com/",doc:["https://mxcdevelop.github.io/apidocs/spot_v3_en/","https://mxcdevelop.github.io/APIDoc/"],fees:["https://www.mexc.com/fee"],referral:"https://m.mexc.com/auth/signup?inviteCode=1FQ1G"},api:{spot:{public:{get:{ping:1,time:1,exchangeInfo:1,depth:1,trades:1,historicalTrades:1,aggTrades:1,klines:1,avgPrice:1,"ticker/24hr":1,"ticker/price":1,"ticker/bookTicker":1,"etf/info":1}},private:{get:{order:1,openOrders:1,allOrders:1,account:1,myTrades:1,"sub-account/list":1,"sub-account/apiKey":1,"capital/config/getall":1,"capital/deposit/hisrec":1,"capital/withdraw/history":1,"capital/deposit/address":1,"capital/transfer":1,"capital/sub-account/universalTransfer":1,"margin/loan":1,"margin/allOrders":1,"margin/myTrades":1,"margin/openOrders":1,"margin/maxTransferable":1,"margin/priceIndex":1,"margin/order":1,"margin/isolated/account":1,"margin/maxBorrowable":1,"margin/repay":1,"margin/isolated/pair":1,"margin/forceLiquidationRec":1,"margin/isolatedMarginData":1,"margin/isolatedMarginTier":1,"rebate/taxQuery":1,"rebate/detail":1,"rebate/detail/kickback":1},post:{order:1,"order/test":1,"sub-account/virtualSubAccount":1,"sub-account/apiKey":1,"sub-account/futures":1,"sub-account/margin":1,batchOrders:1,"capital/withdraw/apply":1,"capital/transfer":1,"capital/deposit/address":1,"capital/sub-account/universalTransfer":1,"margin/tradeMode":1,"margin/order":1,"margin/loan":1,"margin/repay":1},delete:{order:1,openOrders:1,"sub-account/apiKey":1,"margin/order":1,"margin/openOrders":1}}},contract:{public:{get:{ping:2,detail:2,support_currencies:2,"depth/{symbol}":2,"depth_commits/{symbol}/{limit}":2,"index_price/{symbol}":2,"fair_price/{symbol}":2,"funding_rate/{symbol}":2,"kline/{symbol}":2,"kline/index_price/{symbol}":2,"kline/fair_price/{symbol}":2,"deals/{symbol}":2,ticker:2,risk_reverse:2,"risk_reverse/history":2,"funding_rate/history":2}},private:{get:{"account/assets":2,"account/asset/{currency}":2,"account/transfer_record":2,"position/list/history_positions":2,"position/open_positions":2,"position/funding_records":2,"position/position_mode":2,"order/list/open_orders/{symbol}":2,"order/list/history_orders":2,"order/external/{symbol}/{external_oid}":2,"order/get/{order_id}":2,"order/batch_query":8,"order/deal_details/{order_id}":2,"order/list/order_deals":2,"planorder/list/orders":2,"stoporder/list/orders":2,"stoporder/order_details/{stop_order_id}":2,"account/risk_limit":2,"account/tiered_fee_rate":2,"position/leverage":2},post:{"position/change_margin":2,"position/change_leverage":2,"position/change_position_mode":2,"order/submit":2,"order/submit_batch":40,"order/cancel":2,"order/cancel_with_external":2,"order/cancel_all":2,"account/change_risk_level":2,"planorder/place":2,"planorder/cancel":2,"planorder/cancel_all":2,"stoporder/cancel":2,"stoporder/cancel_all":2,"stoporder/change_price":2,"stoporder/change_plan_price":2}}},spot2:{public:{get:{"market/symbols":1,"market/coin/list":2,"common/timestamp":1,"common/ping":1,"market/ticker":1,"market/depth":1,"market/deals":1,"market/kline":1,"market/api_default_symbols":2}},private:{get:{"account/info":1,"order/open_orders":1,"order/list":1,"order/query":1,"order/deals":1,"order/deal_detail":1,"asset/deposit/address/list":2,"asset/deposit/list":2,"asset/address/list":2,"asset/withdraw/list":2,"asset/internal/transfer/record":10,"account/balance":10,"asset/internal/transfer/info":10,"market/api_symbols":2},post:{"order/place":1,"order/place_batch":1,"order/advanced/place_batch":1,"asset/withdraw":2,"asset/internal/transfer":10},delete:{"order/cancel":1,"order/cancel_by_symbol":1,"asset/withdraw":2}}}},precisionMode:w9,timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},options:{createMarketBuyOrderRequiresPrice:!0,unavailableContracts:{"BTC/USDT:USDT":!0,"LTC/USDT:USDT":!0,"ETH/USDT:USDT":!0},fetchMarkets:{types:{spot:!0,future:{linear:!1,inverse:!1},swap:{linear:!0,inverse:!1}}},timeframes:{spot:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},swap:{"1m":"Min1","5m":"Min5","15m":"Min15","30m":"Min30","1h":"Min60","4h":"Hour4","8h":"Hour8","1d":"Day1","1w":"Week1","1M":"Month1"}},defaultType:"spot",networks:{TRX:"TRC20",ETH:"ERC20",BEP20:"BEP20(BSC)",BSC:"BEP20(BSC)"},networkAliases:{"BSC(BEP20)":"BSC"},recvWindow:5*1e3,maxTimeTillEnd:90*86400*1e3-1},commonCurrencies:{BEYONDPROTOCOL:"BEYOND",BIFI:"BIFIF",BYN:"BeyondFi",COFI:"COFIX",DFI:"DfiStarter",DFT:"dFuture",DRK:"DRK",EGC:"Egoras Credit",FLUX1:"FLUX",FLUX:"FLUX1",FREE:"FreeRossDAO",GMT:"GMT Token",STEPN:"GMT",HERO:"Step Hero",MIMO:"Mimosa",PROS:"Pros.Finance",SIN:"Sin City Token",SOUL:"Soul Swap"},exceptions:{exact:{"-1128":fs,"-2011":fs,"-1121":Ev,10101:$a,2009:Tn,2011:fs,30004:$a,33333:fs,44444:fs,1002:Tn,30019:fs,30005:Tn,2003:Tn,2005:$a,600:fs,70011:b9,88004:$a,88009:Ua,88013:Tn,88015:$a,700003:g9},broad:{"Order quantity error, please try to modify.":fs,"Combination of optional parameters invalid":fs,"api market order is disabled":fs,"Contract not allow place order!":Tn,Oversold:Tn,"Insufficient position":$a,"Insufficient balance!":$a,"Bid price is great than max allow price":Tn,"Invalid symbol.":Ev,"Param error!":fs}}})}async fetchStatus(e={}){const[t,s]=this.handleMarketTypeAndParams("fetchStatus",void 0,e);let i,n,r;return t==="spot"?(i=await this.spotPublicGetPing(s),n=Object.keys(i).length?this.json(i):"ok"):t==="swap"&&(i=await this.contractPublicGetPing(s),n=this.safeValue(i,"success")?"ok":this.json(i),r=this.safeInteger(i,"data")),{status:n,updated:r,url:void 0,eta:void 0,info:i}}async fetchTime(e={}){const[t,s]=this.handleMarketTypeAndParams("fetchTime",void 0,e);let i;if(t==="spot")return i=await this.spotPublicGetTime(s),this.safeInteger(i,"serverTime");if(t==="swap")return i=await this.contractPublicGetPing(s),this.safeInteger(i,"data")}async fetchCurrencies(e={}){if(!this.checkRequiredCredentials(!1))return;const t=await this.spotPrivateGetCapitalConfigGetall(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"coin"),a=this.safeCurrencyCode(r),o=this.safeString(n,"name");let d=!1,c,u,h,l=!1,p=!1;const m={},g=this.safeValue(n,"networkList",[]);for(let w=0;w<g.length;w++){const S=g[w],k=this.safeString(S,"network"),T=this.safeNetwork(k),I=this.safeValue(S,"depositEnable",!1),_=this.safeValue(S,"withdrawEnable",!1),N=I&&_;d=N||d;const M=this.safeString(S,"withdrawMin"),x=this.safeString(S,"withdrawMax");u=u===void 0?M:u,h=h===void 0?x:h;const v=this.safeNumber(S,"withdrawFee");c=c===void 0?v:c,ci.stringGt(u,M)&&(u=M),ci.stringLt(h,x)&&(h=x),I&&(l=!0),_&&(p=!0),m[T]={info:S,id:k,network:T,active:N,deposit:I,withdraw:_,fee:this.safeNumber(S,"fee"),precision:void 0,limits:{withdraw:{min:M,max:x}}}}const b=Object.keys(m).length;if(b===1||"NONE"in m){const w=this.safeValue2(m,"NONE",b-1);w!==void 0&&(c=w.fee)}s[a]={info:n,id:r,code:a,name:o,active:d,deposit:l,withdraw:p,fee:c,precision:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:u,max:h}},networks:m}}return s}safeNetwork(e){if(e.indexOf("BSC")>=0)return"BEP20";e=e.split(" ").join(""),e=e.replace("-20","20");const s={ETH:"ETH",ERC20:"ERC20","BEP20(BSC)":"BEP20",TRX:"TRC20"};return this.safeString(s,e,e)}async fetchMarkets(e={}){const t=await this.fetchSpotMarkets(e),s=await this.fetchSwapMarkets(e);return this.arrayConcat(t,s)}async fetchSpotMarkets(e={}){const t=await this.spotPublicGetExchangeInfo(e),s=this.safeValue(t,"symbols",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeString(r,"baseAsset"),d=this.safeString(r,"quoteAsset"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d),h=this.safeString(r,"status"),l=this.safeValue(r,"isSpotTradingAllowed");let p=!1;h==="ENABLED"&&l&&(p=!0);const m=this.safeValue(r,"isMarginTradingAllowed"),g=this.safeNumber(r,"makerCommission"),y=this.safeNumber(r,"takerCommission"),b=this.safeNumber(r,"maxQuoteAmount");i.push({id:a,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:m,swap:!1,future:!1,option:!1,active:p,contract:!1,linear:void 0,inverse:void 0,taker:y,maker:g,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"baseAssetPrecision"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"quoteAssetPrecision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"baseSizePrecision"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(r,"quoteAmountPrecision"),max:b}},info:r})}return i}async fetchSwapMarkets(e={}){const t=await this.contractPublicGetDetail(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeString(r,"baseCoin"),d=this.safeString(r,"quoteCoin"),c=this.safeString(r,"settleCoin"),u=this.safeCurrencyCode(o),h=this.safeCurrencyCode(d),l=this.safeCurrencyCode(c),p=this.safeString(r,"state");i.push({id:a,symbol:u+"/"+h+":"+l,base:u,quote:h,settle:l,baseId:o,quoteId:d,settleId:c,type:"swap",spot:!1,margin:!1,swap:!0,future:!1,option:!1,active:p==="0",contract:!0,linear:!0,inverse:!1,taker:this.safeNumber(r,"takerFeeRate"),maker:this.safeNumber(r,"makerFeeRate"),contractSize:this.safeNumber(r,"contractSize"),expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(r,"volUnit"),price:this.safeNumber(r,"priceUnit")},limits:{leverage:{min:this.safeNumber(r,"minLeverage"),max:this.safeNumber(r,"maxLeverage")},amount:{min:this.safeNumber(r,"minVol"),max:this.safeNumber(r,"maxVol")},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit=t);let r;if(i.spot){const a=await this.spotPublicGetDepth(this.extend(n,s));r=this.parseOrderBook(a,e),r.nonce=this.safeInteger(a,"lastUpdateId")}else if(i.swap){const a=await this.contractPublicGetDepthSymbol(this.extend(n,s)),o=this.safeValue(a,"data"),d=this.safeInteger(o,"timestamp");r=this.parseOrderBook(o,e,d),r.nonce=this.safeInteger(o,"version")}return r}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s);let a;if(n.spot){let o=this.safeString(this.options,"fetchTradesMethod","spotPublicGetAggTrades");o=this.safeString(i,"method",o),a=await this[o](this.extend(r,i))}else if(n.swap){const o=await this.contractPublicGetDealsSymbol(this.extend(r,i));a=this.safeValue(o,"data")}return this.parseTrades(a,n,t,s)}parseTrade(e,t=void 0){let s,i,n,r,a,d,c,u,h,l;if("v"in e)i=this.safeInteger(e,"t"),t=this.safeMarket(void 0,t),r=t.symbol,u=this.safeString(e,"p"),h=this.safeString(e,"v"),d=this.parseOrderSide(this.safeString(e,"T")),c="taker";else{const p=this.safeString(e,"symbol");if(t=this.safeMarket(p,t),r=t.symbol,s=this.safeString2(e,"id","a"),u=this.safeString2(e,"price","p"),n=this.safeString(e,"orderId"),"positionMode"in e)i=this.safeInteger(e,"timestamp"),h=this.safeString(e,"vol"),d=this.parseOrderSide(this.safeString(e,"side")),a={cost:this.safeString(e,"fee"),currency:this.safeCurrencyCode(this.safeString(e,"feeCurrency"))},c=this.safeValue(e,"taker")?"taker":"maker";else{i=this.safeInteger2(e,"time","T"),h=this.safeString2(e,"qty","q"),l=this.safeString(e,"quoteQty");const m=this.safeValue(e,"isBuyer"),g=this.safeValue(e,"isMaker"),y=this.safeString2(e,"isBuyerMaker","m");g!==void 0&&(c=g?"maker":"taker"),m!==void 0&&(d=m?"buy":"sell"),y!==void 0&&(d=y?"sell":"buy",c="taker");const b=this.safeString(e,"commissionAsset");b!==void 0&&(a={cost:this.safeString(e,"commission"),currency:this.safeCurrencyCode(b)})}}return s===void 0&&(s=this.syntheticTradeId(t,i,d,h,u,void 0,c)),this.safeTrade({id:s,order:n,timestamp:i,datetime:this.iso8601(i),symbol:r,type:void 0,side:d,takerOrMaker:c,price:u,amount:h,cost:l,fee:a,info:e},t)}syntheticTradeId(e=void 0,t=void 0,s=void 0,i=void 0,n=void 0,r=void 0,a=void 0){let o="";return t!==void 0&&(o=this.numberToString(t)+"-"+this.safeString(e,"id","_"),s!==void 0&&(o+="-"+s),i!==void 0&&(o+="-"+this.numberToString(i)),n!==void 0&&(o+="-"+this.numberToString(n)),a!==void 0&&(o+="-"+a),r!==void 0&&(o+="-"+r)),o}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.safeValue(this.options,"timeframes",{}),o=this.safeValue(a,r.type,{}),d=this.safeString(o,t),c={symbol:r.id,interval:d};let u;if(r.spot)s!==void 0&&(c.startTime=s),i!==void 0&&(c.limit=i),u=await this.spotPublicGetKlines(this.extend(c,n));else if(r.swap){s!==void 0&&(c.start=parseInt(s/1e3));const h=this.safeString(n,"price","default");n=this.omit(n,"price");const l=this.getSupportedMapping(h,{default:"contractPublicGetKlineSymbol",index:"contractPublicGetKlineIndexPriceSymbol",mark:"contractPublicGetKlineFairPriceSymbol"}),p=await this[l](this.extend(c,n)),m=this.safeValue(p,"data");u=this.convertTradingViewToOHLCV(m,"time","open","high","low","close","vol")}return this.parseOHLCVs(u,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};let i,n=!1;if(e!==void 0){n=e.length===1;const c=this.safeString(e,0);i=this.market(c)}const[r,a]=this.handleMarketTypeAndParams("fetchTickers",i,t);let o;if(n&&(s.symbol=i.id),r==="spot")o=await this.spotPublicGetTicker24hr(this.extend(s,a));else if(r==="swap"){const d=await this.contractPublicGetTicker(this.extend(s,a));o=this.safeValue(d,"data",[])}return n&&(o=[o]),this.parseTickers(o,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),[i,n]=this.handleMarketTypeAndParams("fetchTicker",s,t);let r;const a={symbol:s.id};if(i==="spot")r=await this.spotPublicGetTicker24hr(this.extend(a,n));else if(i==="swap"){const o=await this.contractPublicGetTicker(this.extend(a,n));r=this.safeValue(o,"data",{})}return this.parseTicker(r,e)}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);let i,n,r,a,o,d,c,u,h,l,p,m,g;return this.safeValue(t,"swap")||"timestamp"in e?(i=this.safeInteger(e,"timestamp"),n=this.safeNumber(e,"bid1"),r=this.safeNumber(e,"ask1"),d=this.safeString(e,"volume24"),c=this.safeString(e,"amount24"),h=this.safeNumber(e,"high24Price"),l=this.safeNumber(e,"lower24Price"),m=this.safeString(e,"riseFallValue"),p=this.safeString(e,"riseFallRate"),p=this.parseNumber(ci.stringMul(p,"100"))):(i=this.safeInteger(e,"closeTime"),n=this.safeNumber(e,"bidPrice"),r=this.safeNumber(e,"askPrice"),a=this.safeNumber(e,"bidQty"),o=this.safeNumber(e,"askQty"),a===0&&(a=void 0),o===0&&(o=void 0),d=this.safeString(e,"volume"),c=this.safeString(e,"quoteVolume"),u=this.safeString(e,"openPrice"),h=this.safeNumber(e,"highPrice"),l=this.safeNumber(e,"lowPrice"),g=this.safeString(e,"prevClosePrice"),m=this.safeString(e,"priceChange"),p=this.safeString(e,"priceChangePercent"),p=this.parseNumber(ci.stringMul(p,"100"))),this.safeTicker({symbol:t.symbol,timestamp:i,datetime:this.iso8601(i),open:u,high:h,low:l,close:this.safeString(e,"lastPrice"),bid:n,bidVolume:a,ask:r,askVolume:o,vwap:void 0,previousClose:g,change:m,percentage:p,average:void 0,baseVolume:d,quoteVolume:c,info:e},t)}async fetchBidsAsks(e=void 0,t={}){await this.loadMarkets();let s,i=!1;e!==void 0&&(i=e.length===1,s=this.market(e[0]));const[n,r]=this.handleMarketTypeAndParams("fetchBidsAsks",s,t);let a;if(n==="spot")a=await this.spotPublicGetTickerBookTicker(r);else if(n==="swap")throw new Vv(this.id+" fetchBidsAsks() is not available for "+n+" markets");return i&&(a=[a]),this.parseTickers(a,e)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),[o,d]=this.handleMarginModeAndParams("createOrder",r);if(a.spot)return await this.createSpotOrder(a,t,s,i,n,o,d);if(a.swap)return await this.createSwapOrder(a,t,s,i,n,o,d)}async createSpotOrder(e,t,s,i,n=void 0,r=void 0,a={}){const o=e.symbol,d=s==="buy"?"BUY":"SELL",c={symbol:e.id,side:d,type:t.toUpperCase()};if(d==="BUY"&&t==="market"){const p=this.safeNumber(a,"quoteOrderQty");if(p!==void 0)i=p;else if(this.options.createMarketBuyOrderRequiresPrice){if(n===void 0)throw new Tn(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)");{const m=this.numberToString(i),g=this.numberToString(n),y=ci.stringMul(m,g);i=this.parseNumber(y)}}c.quoteOrderQty=i}else c.quantity=this.amountToPrecision(o,i);n!==void 0&&(c.price=this.priceToPrecision(o,n));const u=this.safeString(a,"clientOrderId");u!==void 0&&(c.newClientOrderId=u,a=this.omit(a,["type","clientOrderId"]));let h="spotPrivatePostOrder";if(r!==void 0){if(r!=="isolated")throw new fs(this.id+" createOrder() does not support marginMode "+r+" for spot-margin trading");h="spotPrivatePostMarginOrder"}const l=await this[h](this.extend(c,a));return this.extend(this.parseOrder(l,e),{side:s,type:t,price:n,amount:i})}async createSwapOrder(e,t,s,i,n=void 0,r=void 0,a={}){await this.loadMarkets();const o=e.symbol,d=this.safeValue(this.options,"unavailableContracts",{});if(this.safeValue(d,o,!1))throw new Vv(this.id+" createSwapOrder() does not support yet this symbol:"+o);let u;if(r!==void 0)if(r==="cross")u=2;else if(r==="isolated")u=1;else throw new _s(this.id+' createSwapOrder() marginMode parameter should be either "cross" or "isolated"');else u=this.safeInteger(a,"openType",2);if(t!=="limit"&&t!=="market"&&t!==1&&t!==2&&t!==3&&t!==4&&t!==5&&t!==6)throw new Tn(this.id+" createSwapOrder() order type must either limit, market, or 1 for limit orders, 2 for post-only orders, 3 for IOC orders, 4 for FOK orders, 5 for market orders or 6 to convert market price to current price");this.safeValue(a,"postOnly",!1)?t=2:t==="limit"?t=1:t==="market"&&(t=6);const l={symbol:e.id,vol:parseFloat(this.amountToPrecision(o,i)),type:t,openType:u};let p="contractPrivatePostOrderSubmit";const m=this.safeNumber2(a,"triggerPrice","stopPrice");if(a=this.omit(a,["stopPrice","triggerPrice"]),m&&(p="contractPrivatePostPlanorderPlace",l.triggerPrice=this.priceToPrecision(o,m),l.triggerType=this.safeInteger(a,"triggerType",1),l.executeCycle=this.safeInteger(a,"executeCycle",1),l.trend=this.safeInteger(a,"trend",1),l.orderType=this.safeInteger(a,"orderType",1)),t!==5&&t!==6&&t!=="market"&&(l.price=parseFloat(this.priceToPrecision(o,n))),u===1&&this.safeInteger(a,"leverage")===void 0)throw new _s(this.id+" createSwapOrder() requires a leverage parameter for isolated margin orders");this.safeValue(a,"reduceOnly",!1)?l.side=s==="buy"?2:4:l.side=s==="buy"?1:3;const y=this.safeString2(a,"clientOrderId","externalOid");y!==void 0&&(l.externalOid=y),a=this.omit(a,["clientOrderId","externalOid","postOnly"]);const b=await this[p](this.extend(l,a)),w=this.safeString(b,"data");return this.parseOrder(w,e)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new _s(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={symbol:i.id};let r;if(i.spot){const a=this.safeString(s,"clientOrderId");a!==void 0?(s=this.omit(s,"clientOrderId"),n.origClientOrderId=a):n.orderId=e;const[o,d]=this.handleMarginModeAndParams("fetchOrder",s);let c="spotPrivateGetOrder";if(o!==void 0){if(o!=="isolated")throw new fs(this.id+" fetchOrder() does not support marginMode "+o+" for spot-margin trading");c="spotPrivateGetMarginOrder"}r=await this[c](this.extend(n,d))}else if(i.swap){n.order_id=e;const a=await this.contractPrivateGetOrderGetOrderId(this.extend(n,s));r=this.safeValue(a,"data")}return this.parseOrder(r,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id);const[a,o]=this.handleMarketTypeAndParams("fetchOrders",r,i);if(a==="spot"){if(e===void 0)throw new _s(this.id+" fetchOrders() requires a symbol argument for spot market");const[d,c]=this.handleMarginModeAndParams("fetchOrders",i);let u="spotPrivateGetAllOrders";if(d!==void 0){if(d!=="isolated")throw new fs(this.id+" fetchOrders() does not support marginMode "+d+" for spot-margin trading");u="spotPrivateGetMarginAllOrders"}t!==void 0&&(n.startTime=t),s!==void 0&&(n.limit=s);const h=await this[u](this.extend(n,c));return this.parseOrders(h,r,t,s)}else{t!==void 0&&(n.start_time=t,this.safeInteger(i,"end_time")===void 0&&(n.end_time=this.sum(t,this.options.maxTimeTillEnd))),s!==void 0&&(n.page_size=s);let d=this.safeString(this.options,"fetchOrders","contractPrivateGetOrderListHistoryOrders");d=this.safeString(o,"method",d);let c=[],u=[];if(d==="contractPrivateGetOrderListHistoryOrders"){const l=await this.contractPrivateGetOrderListHistoryOrders(this.extend(n,o));c=this.safeValue(l,"data")}else{const l=await this.contractPrivateGetPlanorderListOrders(this.extend(n,o));u=this.safeValue(l,"data")}const h=this.arrayConcat(u,c);return this.parseOrders(h,r,t,s,i)}}async fetchOrdersByIds(e,t=void 0,s={}){await this.loadMarkets();const i={};let n;t!==void 0&&(n=this.market(t),i.symbol=n.id);const[r,a]=this.handleMarketTypeAndParams("fetchOrdersByIds",n,s);if(r==="spot")throw new fs(this.id+" fetchOrdersByIds() is not supported for "+r);{i.order_ids=e.join(",");const o=await this.contractPrivateGetOrderBatchQuery(this.extend(i,a)),d=this.safeValue(o,"data");return this.parseOrders(d,n)}}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id);let a;if([a,i]=this.handleMarketTypeAndParams("fetchOpenOrders",r,i),a==="spot"){if(e===void 0)throw new _s(this.id+" fetchOpenOrders() requires a symbol argument for spot market");let o="spotPrivateGetOpenOrders";const[d,c]=this.handleMarginModeAndParams("fetchOpenOrders",i);if(d!==void 0){if(d!=="isolated")throw new fs(this.id+" fetchOpenOrders() does not support marginMode "+d+" for spot-margin trading");o="spotPrivateGetMarginOpenOrders"}const u=await this[o](this.extend(n,c));return this.parseOrders(u,r,t,s)}else return await this.fetchOrdersByState(2,e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState(3,e,t,s,i)}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState(4,e,t,s,i)}async fetchOrdersByState(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;t!==void 0&&(r=this.market(t),r.id);const[a]=this.handleMarketTypeAndParams("fetchOrdersByState",r,n);if(a==="spot")throw new fs(this.id+" fetchOrdersByState() is not supported for "+a);return n.states=e,this.fetchOrders(t,s,i,n)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t),i.id);let n;[n,s]=this.handleMarketTypeAndParams("cancelOrder",i,s);const[r,a]=this.handleMarginModeAndParams("cancelOrder",s);let o;if(n==="spot"){if(t===void 0)throw new _s(this.id+" cancelOrder() requires a symbol argument");const d={symbol:i.id},c=this.safeString(s,"clientOrderId");c!==void 0?(s=this.omit(a,"clientOrderId"),d.origClientOrderId=c):d.orderId=e;let u="spotPrivateDeleteOrder";if(r!==void 0){if(r!=="isolated")throw new fs(this.id+" cancelOrder() does not support marginMode "+r+" for spot-margin trading");u="spotPrivateDeleteMarginOrder"}o=await this[u](this.extend(d,a))}else{let d=this.safeString(this.options,"cancelOrder","contractPrivatePostOrderCancel");d=this.safeString(a,"method",d);const c=await this[d]([e]);o=this.safeValue(c,"data");const u=this.safeValue(o,0),h=this.safeValue(u,"errorMsg","");if(h!=="success")throw new Tn(this.id+" cancelOrder() the order with id "+e+" cannot be cancelled: "+h)}return this.parseOrder(o,i)}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i=t!==void 0?this.market(t):void 0,[n]=this.handleMarketTypeAndParams("cancelOrders",i,s);if(n==="spot")throw new fs(this.id+" cancelOrders() is not supported for "+n);{const r=await this.contractPrivatePostOrderCancel(e),a=this.safeValue(r,"data");return this.parseOrders(a,i)}}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s=e!==void 0?this.market(e):void 0,i={};let n;[n,t]=this.handleMarketTypeAndParams("cancelAllOrders",s,t);const[r,a]=this.handleMarginModeAndParams("cancelAllOrders",t);if(n==="spot"){if(e===void 0)throw new _s(this.id+" cancelAllOrders() requires a symbol argument on spot");i.symbol=s.id;let o="spotPrivateDeleteOpenOrders";if(r!==void 0){if(r!=="isolated")throw new fs(this.id+" cancelAllOrders() does not support marginMode "+r+" for spot-margin trading");o="spotPrivateDeleteMarginOpenOrders"}const d=await this[o](this.extend(i,a));return this.parseOrders(d,s)}else{e!==void 0&&(i.symbol=s.id);let o=this.safeString(this.options,"cancelAllOrders","contractPrivatePostOrderCancelAll");o=this.safeString(a,"method",o);const d=await this[o](this.extend(i,a)),c=this.safeValue(d,"data",[]);return this.parseOrders(c,s)}}parseOrder(e,t=void 0){let s;typeof e=="string"?s=e:s=this.safeString2(e,"orderId","id");const i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const n=this.safeIntegerN(e,["time","createTime","transactTime"]);let r;const a=this.safeString(e,"feeCurrency");if(a!==void 0){const o=this.safeString(e,"takerFee"),d=this.safeString(e,"makerFee"),c=ci.stringAdd(o,d);r={currency:a,cost:this.parseNumber(c)}}return this.safeOrder({id:s,clientOrderId:this.safeString(e,"clientOrderId"),timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,status:this.parseOrderStatus(this.safeString2(e,"status","state")),symbol:t.symbol,type:this.parseOrderType(this.safeString(e,"type")),timeInForce:this.parseOrderTimeInForce(this.safeString(e,"timeInForce")),side:this.parseOrderSide(this.safeString(e,"side")),price:this.safeNumber(e,"price"),stopPrice:this.safeNumber2(e,"stopPrice","triggerPrice"),average:this.safeNumber(e,"dealAvgPrice"),amount:this.safeNumber2(e,"origQty","vol"),cost:this.safeNumber(e,"cummulativeQuoteQty"),filled:this.safeNumber2(e,"executedQty","dealVol"),remaining:void 0,fee:r,trades:void 0,info:e},t)}parseOrderSide(e){const t={BUY:"buy",SELL:"sell"};return this.safeString(t,e,e)}parseOrderType(e){const t={MARKET:"market",LIMIT:"limit",LIMIT_MAKER:"limit"};return this.safeString(t,e,e)}parseOrderStatus(e){const t={NEW:"open",FILLED:"closed",CANCELED:"canceled",PARTIALLY_FILLED:"open",PARTIALLY_CANCELED:"canceled",2:"open",3:"closed",4:"canceled"};return this.safeString(t,e,e)}parseOrderTimeInForce(e){const t={GTC:"GTC",FOK:"FOK",IOC:"IOC"};return this.safeString(t,e,e)}async fetchAccountHelper(e,t){if(e==="spot")return await this.spotPrivateGetAccount(t);if(e==="swap"){const s=await this.contractPrivateGetAccountAssets(t);return this.safeValue(s,"data")}}async fetchAccounts(e={}){const[t,s]=this.handleMarketTypeAndParams("fetchAccounts",void 0,e);await this.loadMarkets();const i=await this.fetchAccountHelper(t,s),n=this.safeValue(i,"balances",[]),r=[];for(let a=0;a<n.length;a++){const o=n[a],d=this.safeString2(o,"asset","currency"),c=this.safeCurrencyCode(d);r.push({id:this.safeString(o,"id"),type:this.safeString(o,"type"),code:c,info:o})}return r}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.fetchAccountHelper("spot",e);let s=this.safeString(t,"makerCommission"),i=this.safeString(t,"takerCommission");s=ci.stringDiv(s,"1000"),i=ci.stringDiv(i,"1000");const n={};for(let r=0;r<this.symbols.length;r++){const a=this.symbols[r];n[a]={symbol:a,maker:this.parseNumber(s),taker:this.parseNumber(i),percentage:!0,tierBased:!1,info:t}}return n}async fetchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),i={};let n;if(t==="spot"){n=await this.fetchAccountHelper("spot",s);const r=this.safeValue(n,"balances",[]);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeString(o,"asset"),c=this.safeCurrencyCode(d),u=this.account();u.free=this.safeString(o,"free"),u.used=this.safeString(o,"locked"),i[c]=u}}else if(t==="swap"){n=await this.contractPrivateGetAccountAssets(s);const r=this.safeValue(n,"data",[]);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeString(o,"currency"),c=this.safeCurrencyCode(d),u=this.account();u.free=this.safeString(o,"availableBalance"),u.used=this.safeString(o,"frozenBalance"),i[c]=u}}return i.info=n,this.safeBalance(i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new _s(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),[r,a]=this.handleMarketTypeAndParams("fetchMyTrades",n,i),o={symbol:n.id};let d;if(r==="spot")t!==void 0&&(o.start_time=t),s!==void 0&&(o.limit=s),d=await this.spotPrivateGetMyTrades(this.extend(o,a));else{t!==void 0&&(o.start_time=t,this.safeInteger(i,"end_time")===void 0&&(o.end_time=this.sum(t,this.options.maxTimeTillEnd))),s!==void 0&&(o.page_size=s);const c=await this.contractPrivateGetOrderListOrderDeals(this.extend(o,a));d=this.safeValue(c,"data")}return this.parseTrades(d,n,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a;t!==void 0&&(a=this.market(t));const[o,d]=this.handleMarketTypeAndParams("fetchOrderTrades",a,n);let c;if(o==="spot"){if(t===void 0)throw new _s(this.id+" fetchOrderTrades() requires a symbol argument");r.symbol=a.id,r.orderId=e,c=await this.spotPrivateGetMyTrades(this.extend(r,d))}else{r.order_id=e;const u=await this.contractPrivateGetOrderDealDetailsOrderId(this.extend(r,d));c=this.safeValue(u,"data")}return this.parseTrades(c,a,s,i,d)}async modifyMarginHelper(e,t,s,i={}){const n=this.safeInteger(i,"positionId");if(n===void 0)throw new _s(this.id+" modifyMarginHelper() requires a positionId parameter");await this.loadMarkets();const r={positionId:n,amount:t,type:s};return await this.contractPrivatePostPositionChangeMargin(this.extend(r,i))}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"SUB",s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"ADD",s)}async setLeverage(e,t=void 0,s={}){await this.loadMarkets();const i={leverage:e},n=this.safeInteger(s,"positionId");if(n===void 0){const r=this.safeNumber(s,"openType"),a=this.safeNumber(s,"positionType"),o=t!==void 0?this.market(t):void 0;if(r===void 0||a===void 0||o===void 0)throw new _s(this.id+" setLeverage() requires a positionId parameter or a symbol argument with openType and positionType parameters, use openType 1 or 2 for isolated or cross margin respectively, use positionType 1 or 2 for long or short positions");i.openType=r,i.symbol=o.symbol,i.positionType=a}else i.positionId=n;return await this.contractPrivatePostPositionChangeLeverage(this.extend(i,s))}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),s!==void 0&&(r.page_size=s);const a=await this.contractPrivateGetPositionFundingRecords(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"resultList",[]),c=[];for(let u=0;u<d.length;u++){const h=d[u],l=this.safeInteger(h,"settleTime");c.push({info:h,symbol:e,code:void 0,timestamp:l,datetime:this.iso8601(l),id:this.safeNumber(h,"id"),amount:this.safeNumber(h,"funding")})}return c}parseFundingRate(e,t=void 0){const s=this.safeNumber(e,"fundingRate"),i=this.safeInteger(e,"nextSettleTime"),n=this.safeString(e,"symbol"),r=this.safeSymbol(n,t),a=this.safeInteger(e,"timestamp"),o=this.iso8601(a);return{info:e,symbol:r,markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:a,datetime:o,fundingRate:s,fundingTimestamp:i,fundingDatetime:this.iso8601(i),nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.contractPublicGetFundingRateSymbol(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseFundingRate(r,s)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new _s(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.page_size=s);const a=await this.contractPublicGetFundingRateHistory(this.extend(r,i)),o=this.safeValue(a,"data"),d=this.safeValue(o,"resultList",[]),c=[];for(let h=0;h<d.length;h++){const l=d[h],p=this.safeString(l,"symbol"),m=this.safeSymbol(p),g=this.safeInteger(l,"settleTime");c.push({info:l,symbol:m,fundingRate:this.safeNumber(l,"fundingRate"),timestamp:g,datetime:this.iso8601(g)})}const u=this.sortBy(c,"timestamp");return this.filterBySymbolSinceLimit(u,n.symbol,t,s)}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const s=await this.contractPublicGetDetail(t),i=this.safeValue(s,"data");return this.parseLeverageTiers(i,e,"symbol")}parseMarketLeverageTiers(e,t){let s=this.safeString(e,"maintenanceMarginRate"),i=this.safeString(e,"initialMarginRate");const n=this.safeString(e,"maxVol"),r=this.safeString(e,"riskIncrVol"),a=this.safeString(e,"riskIncrMmr"),o=this.safeString(e,"riskIncrImr");let d="0";const c=[],u=this.safeString(e,"quoteCoin");for(;ci.stringLt(d,n);){const h=ci.stringAdd(d,r);c.push({tier:this.parseNumber(ci.stringDiv(h,r)),currency:this.safeCurrencyCode(u),notionalFloor:this.parseNumber(d),notionalCap:this.parseNumber(h),maintenanceMarginRate:this.parseNumber(s),maxLeverage:this.parseNumber(ci.stringDiv("1",i)),info:e}),i=ci.stringAdd(i,o),s=ci.stringAdd(s,a),d=h}return c}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeCurrencyCode(void 0,t),n=this.safeString(e,"chain"),r=this.safeNetwork(n);return this.checkAddress(s),{currency:i,address:s,tag:void 0,network:r,info:e}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const i={coin:this.currency(e).id},n=await this.spotPrivateGetCapitalDepositAddress(this.extend(i,t)),r=[];for(let a=0;a<n.length;a++){const o=n[a],d=this.safeString(o,"coin"),c=this.currency(d),u=this.safeString(o,"network"),h=this.safeNetwork(u),l=this.safeString(o,"address",void 0),p=this.safeString(o,"tag",void 0);r.push({currency:c.id,network:h,address:l,tag:p})}return r}async fetchDepositAddress(e,t={}){const s=this.safeStringUpper(t,"network");t=this.omit(t,"network");const i=await this.fetchDepositAddressesByNetwork(e,t);if(s!==void 0)for(let r=0;r<i.length;r++){const a=i[r],o=this.safeStringUpper(a,"network");if(s===o)return a}const n=this.safeValue(i,0);if(n===void 0)throw new y9(this.id+" fetchDepositAddress() cannot find a deposit address for "+e+", consider creating one using the MEXC platform");return n}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new _s(this.id+" fetchDeposits() requires a currency code argument");await this.loadMarkets();const n={};let r;const a=this.safeString(i,"network");if(i=this.omit(i,"network"),a===void 0)throw new _s(this.id+" fetchDeposits() requires a network parameter when the currency is specified");if(r=this.currency(e),n.coin=r.id+"-"+a,t!==void 0&&(n.startTime=t),s!==void 0){if(s>1e3)throw new Ua("This exchange supports a maximum limit of 1000");n.limit=s}const o=await this.spotPrivateGetCapitalDepositHisrec(this.extend(n,i));return this.parseTransactions(o,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new _s(this.id+" fetchWithdrawals() requires a currency code argument");await this.loadMarkets();const n={},r=this.currency(e);if(n.coin=r.id,t!==void 0&&(n.startTime=t),s!==void 0){if(s>1e3)throw new Ua("This exchange supports a maximum limit of 1000");n.limit=s}const a=await this.spotPrivateGetCapitalWithdrawHistory(this.extend(n,i));return this.parseTransactions(a,r,t,s)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=s===void 0?"deposit":"withdrawal",n=this.safeInteger2(e,"insertTime","applyTime"),r=this.safeString(e,"currency"),a=this.safeString(e,"network"),o=this.safeCurrencyCode(r,t),d=this.parseTransactionStatus(this.safeString(e,"status"));let c=this.safeString(e,"amount");const u=this.safeString(e,"address"),h=this.safeString(e,"txId");let l;const p=this.safeString(e,"transactionFee");return p!==void 0&&(l={cost:this.parseNumber(p),currency:o}),i==="withdrawal"&&(c=ci.stringSub(c,p)),{info:e,id:s,txid:h,timestamp:n,datetime:this.iso8601(n),network:a,address:u,addressTo:u,addressFrom:void 0,tag:this.safeString(e,"memo"),tagTo:void 0,tagFrom:void 0,type:i,amount:this.parseNumber(c),currency:o,status:d,updated:void 0,fee:l}}parseTransactionStatus(e){const t={WAIT:"pending",WAIT_PACKAGING:"pending",SUCCESS:"ok"};return this.safeString(t,e,e)}async fetchPosition(e,t={}){await this.loadMarkets();const i={symbol:this.market(e).id},n=await this.fetchPositions(void 0,this.extend(i,t));return this.safeValue(n,0)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.contractPrivateGetPositionOpenPositions(t),i=this.safeValue(s,"data",[]);return this.parsePositions(i,e)}parsePosition(e,t=void 0){t=this.safeMarket(this.safeString(e,"symbol"),t);const s=t.symbol,i=this.safeString(e,"holdVol"),n=this.safeNumber(e,"openAvgPrice"),r=this.safeString(e,"im"),o=this.safeString(e,"positionType")==="1"?"long":"short",c=this.safeString(e,"margin_mode")==="1"?"isolated":"cross",u=this.safeNumber(e,"leverage"),h=this.safeNumber(e,"liquidatePrice"),l=this.safeNumber(e,"updateTime");return{info:e,id:void 0,symbol:s,contracts:this.parseNumber(i),contractSize:void 0,entryPrice:n,collateral:void 0,side:o,unrealizedProfit:void 0,leverage:this.parseNumber(u),percentage:void 0,marginType:c,notional:void 0,markPrice:void 0,liquidationPrice:h,initialMargin:this.parseNumber(r),initialMarginPercentage:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,marginRatio:void 0,timestamp:l,datetime:this.iso8601(l)}}async fetchTransfer(e,t=void 0,s=void 0,i={}){const[n,r]=this.handleMarketTypeAndParams("fetchTransfer",void 0,i);if(await this.loadMarkets(),n==="spot"){const a={transact_id:e},o=await this.spot2PrivateGetAssetInternalTransferInfo(this.extend(a,r)),d=this.safeValue(o,"data",{});return this.parseTransfer(d)}else if(n==="swap")throw new fs(this.id+" fetchTransfer() is not supported for "+n)}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){const[n,r]=this.handleMarketTypeAndParams("fetchTransfers",void 0,i);await this.loadMarkets();const a={};let o,d;if(e!==void 0&&(o=this.currency(e),a.currency=o.id),n==="spot"){if(t!==void 0&&(a.start_time=t),s!==void 0){if(s>50)throw new Ua("This exchange supports a maximum limit of 50");a["page-size"]=s}const c=await this.spot2PrivateGetAssetInternalTransferRecord(this.extend(a,r)),u=this.safeValue(c,"data",{});d=this.safeValue(u,"result_list",[])}else if(n==="swap"){s!==void 0&&(a.page_size=s);const c=await this.contractPrivateGetAccountTransferRecord(this.extend(a,r)),u=this.safeValue(c,"data");d=this.safeValue(u,"resultList")}return this.parseTransfers(d,o,t,s)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a={spot:"SPOT",swap:"FUTURES",margin:"ISOLATED_MARGIN"},o=this.safeString(a,s),d=this.safeString(a,i);if(o===void 0){const l=Object.keys(a);throw new Ua(this.id+" fromAccount must be one of "+l.join(", "))}if(d===void 0){const l=Object.keys(a);throw new Ua(this.id+" toAccount must be one of "+l.join(", "))}const c={asset:r.id,amount:t,fromAccountType:o,toAccountType:d};if(o==="ISOLATED_MARGIN"||d==="ISOLATED_MARGIN"){const l=this.safeString(n,"symbol");if(n=this.omit(n,"symbol"),l===void 0)throw new _s(this.id+" transfer() requires a symbol argument for isolated margin");const p=this.market(l);c.symbol=p.id}const u=await this.spotPrivatePostCapitalTransfer(this.extend(c,n)),h=this.parseTransfer(u,r);return this.extend(h,{amount:t,fromAccount:s,toAccount:i})}parseTransfer(e,t=void 0){const s=this.safeString(e,"currency"),i=this.safeStringN(e,["transact_id","txid","tranId"]),n=this.safeInteger(e,"createTime"),r=n!==void 0?this.iso8601(n):void 0,a=this.safeString(e,"type");let o,d;return a!==void 0?(o=a==="IN"?"MAIN":"CONTRACT",d=a==="IN"?"CONTRACT":"MAIN"):(o=this.safeString(e,"from"),d=this.safeString(e,"to")),{info:e,id:i,timestamp:n,datetime:r,currency:this.safeCurrencyCode(s,t),amount:this.safeNumber(e,"amount"),fromAccount:this.parseAccountId(o),toAccount:this.parseAccountId(d),status:this.parseTransferStatus(this.safeString2(e,"transact_state","state"))}}parseAccountId(e){const t={MAIN:"spot",CONTRACT:"swap"};return this.safeString(t,e,e)}parseTransferStatus(e){const t={SUCCESS:"ok",FAILED:"failed",WAIT:"pending"};return this.safeString(t,e,e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n);const r=this.safeValue(this.options,"networks",{});let a=this.safeStringUpper2(n,"network","chain");a=this.safeString(r,a,a),this.checkAddress(s),await this.loadMarkets();const o=this.currency(e),d={coin:o.id,address:s,amount:t};i!==void 0&&(d.memo=i),a!==void 0&&(d.network=a,n=this.omit(n,"network"));const c=await this.spotPrivatePostCapitalWithdrawApply(this.extend(d,n));return this.parseTransaction(c,o)}async setPositionMode(e,t=void 0,s={}){const i={positionMode:e?1:2};return await this.contractPrivatePostPositionChangePositionMode(this.extend(i,s))}async fetchPositionMode(e=void 0,t={}){const s=await this.contractPrivateGetPositionPositionMode(t),i=this.safeInteger(s,"data");return{info:s,hedged:i===1}}async borrowMargin(e,t,s=void 0,i={}){if(await this.loadMarkets(),s===void 0)throw new _s(this.id+" borrowMargin() requires a symbol argument for isolated margin");const n=this.market(s),r=this.currency(e),a={asset:r.id,amount:this.currencyToPrecision(e,t),symbol:n.id},o=await this.spotPrivatePostMarginLoan(this.extend(a,i)),d=this.parseMarginLoan(o,r);return this.extend(d,{amount:t,symbol:s})}async repayMargin(e,t,s=void 0,i={}){if(await this.loadMarkets(),s===void 0)throw new _s(this.id+" repayMargin() requires a symbol argument for isolated margin");const n=this.safeString2(i,"id","borrowId");if(n===void 0)throw new _s(this.id+" repayMargin() requires a borrowId argument in the params");const r=this.market(s),a=this.currency(e),o={asset:a.id,amount:this.currencyToPrecision(e,t),borrowId:n,symbol:r.id},d=await this.spotPrivatePostMarginRepay(this.extend(o,i)),c=this.parseMarginLoan(d,a);return this.extend(c,{amount:t,symbol:s})}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.spotPrivateGetCapitalConfigGetall(t);return this.parseTransactionFees(s,e)}parseTransactionFees(e,t=void 0){const s={};for(let i=0;i<e.length;i++){const n=e[i],r=this.safeString(n,"coin"),a=this.safeCurrency(r),o=this.safeString(a,"code");(t===void 0||this.inArray(o,t))&&(s[o]=this.parseTransactionFee(n,a))}return{withdraw:s,deposit:{},info:e}}parseTransactionFee(e,t=void 0){const s=this.safeValue(e,"networkList",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"network"),o=this.safeString(this.options.networks,a,a),d=this.safeNumber(r,"withdrawFee");i[o]=d}return i}parseMarginLoan(e,t=void 0){return{id:this.safeString(e,"tranId"),currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}handleMarginModeAndParams(e,t={},s=void 0){const i=this.safeString(this.options,"defaultType"),n=this.safeValue(t,"margin",!1);let r;return[r,t]=super.handleMarginModeAndParams(e,t,s),(i==="margin"||n===!0)&&(r="isolated"),[r,t]}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const[a,o]=t;[e,i]=this.resolvePath(e,i);let d;if(a==="spot"){d=this.urls.api[a][o]+"/api/"+this.version+"/"+e;let c="";if(o==="private"&&(i.timestamp=this.milliseconds(),i.recvWindow=this.safeInteger(this.options,"recvWindow",5e3)),Object.keys(i).length&&(c=this.urlencode(i),d+="?"+c),o==="private"){this.checkRequiredCredentials();const u=this.hmac(this.encode(c),this.encode(this.secret),"sha256");d+="&signature="+u,n={"X-MEXC-APIKEY":this.apiKey}}s==="POST"&&(n["Content-Type"]="application/json")}else if(a==="contract"||a==="spot2")if(d=this.urls.api[a][o]+"/"+this.implodeParams(e,i),i=this.omit(i,this.extractParams(e)),o==="public")Object.keys(i).length&&(d+="?"+this.urlencode(i));else{this.checkRequiredCredentials();const c=this.milliseconds().toString();let u="";n={ApiKey:this.apiKey,"Request-Time":c,"Content-Type":"application/json"},s==="POST"?(u=this.json(i),r=u):(i=this.keysort(i),Object.keys(i).length&&(u+=this.urlencode(i),d+="?"+u)),u=this.apiKey+c+u;const h=this.hmac(this.encode(u),this.encode(this.secret),"sha256");n.Signature=h}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0||this.safeValue(a,"success",!1)===!0)return;const u=this.safeString(a,"code",void 0);if(u!==void 0&&u!=="200"&&u!=="0"){const h=this.id+" "+r;throw this.throwBroadlyMatchedException(this.exceptions.broad,r,h),this.throwExactlyMatchedException(this.exceptions.exact,u,h),new Ua(h)}}};const k9=me,{AuthenticationError:v9,ExchangeError:ih,PermissionDenied:T9,BadRequest:O9,CancelPending:I9,OrderNotFound:x9,InsufficientFunds:qv,RateLimitExceeded:_9,InvalidOrder:Dn,AccountSuspended:C9,BadSymbol:Lv,OnMaintenance:M9,ArgumentsRequired:P9,AccountNotEnabled:A9}=oe,{TICK_SIZE:B9}=pe;var N9=class extends k9{describe(){return this.deepExtend(super.describe(),{id:"novadax",name:"NovaDAX",countries:["BR"],rateLimit:16.6667,version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactions:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"ONE_MIN","5m":"FIVE_MIN","15m":"FIFTEEN_MIN","30m":"HALF_HOU","1h":"ONE_HOU","1d":"ONE_DAY","1w":"ONE_WEE","1M":"ONE_MON"},urls:{logo:"https://user-images.githubusercontent.com/1294454/92337550-2b085500-f0b3-11ea-98e7-5794fb07dd3b.jpg",api:{public:"https://api.novadax.com",private:"https://api.novadax.com"},www:"https://www.novadax.com.br",doc:["https://doc.novadax.com/pt-BR/"],fees:"https://www.novadax.com.br/fees-and-limits",referral:"https://www.novadax.com.br/?s=ccxt"},api:{public:{get:{"common/symbol":1.2,"common/symbols":1.2,"common/timestamp":1.2,"market/tickers":1.2,"market/ticker":1.2,"market/depth":1.2,"market/trades":1.2,"market/kline/history":1.2}},private:{get:{"orders/get":3,"orders/list":3,"orders/fill":3,"orders/fills":3,"account/getBalance":3,"account/subs":3,"account/subs/balance":3,"account/subs/transfer/record":3,"wallet/query/deposit-withdraw":3},post:{"orders/create":3,"orders/cancel":3,"account/withdraw/coin":3,"account/subs/transfer":3}}},fees:{trading:{tierBased:!1,percentage:!0,taker:this.parseNumber("0.005"),maker:this.parseNumber("0.0025")}},requiredCredentials:{apiKey:!0,secret:!0},precisionMode:B9,exceptions:{exact:{A99999:ih,A10001:O9,A10002:ih,A10003:v9,A10004:_9,A10005:T9,A10006:C9,A10007:A9,A10011:Lv,A10012:Lv,A10013:M9,A30001:x9,A30002:Dn,A30003:Dn,A30004:Dn,A30005:Dn,A30006:Dn,A30007:qv,A30008:Dn,A30009:Dn,A30010:I9,A30011:Dn,A30012:Dn,A40004:qv},broad:{}},options:{fetchOHLCV:{volume:"amount"},transfer:{fillResponseFromRequest:!0}}})}async fetchTime(e={}){const t=await this.publicGetCommonTimestamp(e);return this.safeInteger(t,"data")}async fetchMarkets(e={}){const t=await this.publicGetCommonSymbols(e),s=[],i=this.safeValue(t,"data",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"baseCurrency"),o=this.safeString(r,"quoteCurrency"),d=this.safeString(r,"symbol"),c=this.safeCurrencyCode(a),u=this.safeCurrencyCode(o),h=this.safeString(r,"status");s.push({id:d,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:h==="ONLINE",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"amountPrecision"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"pricePrecision"))),cost:this.parseNumber(this.parsePrecision(this.safeString(r,"valuePrecision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"minOrderAmount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(r,"minOrderValue"),max:void 0}},info:r})}return s}parseTicker(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t,"_"),r=this.safeString(e,"open24h"),a=this.safeString(e,"lastPrice"),o=this.safeString(e,"baseVolume24h"),d=this.safeString(e,"quoteVolume24h");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high24h"),low:this.safeString(e,"low24h"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:r,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:o,quoteVolume:d,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetMarketTicker(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetMarketTickers(t),i=this.safeValue(s,"data",[]),n={};for(let r=0;r<i.length;r++){const a=this.parseTicker(i[r]),o=a.symbol;n[o]=a}return this.filterByArray(n,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetMarketDepth(this.extend(n,s)),a=this.safeValue(r,"data",{}),o=this.safeInteger(a,"timestamp");return this.parseOrderBook(a,i.symbol,o,"bids","asks")}parseTrade(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"orderId"),n=this.safeInteger(e,"timestamp"),r=this.safeStringLower(e,"side"),a=this.safeString(e,"price"),o=this.safeString(e,"amount"),d=this.safeString(e,"symbol"),c=this.safeSymbol(d,t,"_"),u=this.safeStringLower(e,"role"),h=this.safeString(e,"fee");let l;if(h!==void 0){const p=this.safeString(e,"feeCurrency"),m=this.safeCurrencyCode(p);l={cost:this.safeString(e,"feeAmount"),currency:m}}return this.safeTrade({id:s,order:i,timestamp:n,datetime:this.iso8601(n),symbol:c,type:void 0,side:r,price:a,amount:o,cost:void 0,takerOrMaker:u,fee:l,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetMarketTrades(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,unit:this.timeframes[t]},o=this.parseTimeframe(t),d=this.seconds();if(i===void 0&&(i=3e3),s===void 0)a.from=d-i*o,a.to=d;else{const h=parseInt(s/1e3);a.from=h,a.to=this.sum(h,i*o)}const c=await this.publicGetMarketKlineHistory(this.extend(a,n)),u=this.safeValue(c,"data",[]);return this.parseOHLCVs(u,r,t,s,i)}parseOHLCV(e,t=void 0){const s=this.safeValue(this.options,"fetchOHLCV",{}),i=this.safeString(s,"volume","amount");return[this.safeTimestamp(e,"score"),this.safeNumber(e,"openPrice"),this.safeNumber(e,"highPrice"),this.safeNumber(e,"lowPrice"),this.safeNumber(e,"closePrice"),this.safeNumber(e,i)]}parseBalance(e){const t=this.safeValue(e,"data",[]),s={info:e,timestamp:void 0,datetime:void 0};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(n,"balance"),o.free=this.safeString(n,"available"),o.used=this.safeString(n,"hold"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountGetBalance(e);return this.parseBalance(t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o=t.toUpperCase();const d=s.toUpperCase(),c={symbol:a.id,side:d},u=this.safeValue2(r,"triggerPrice","stopPrice");if(u===void 0){if(o==="STOP_LIMIT"||o==="STOP_MARKET")throw new P9(this.id+" createOrder() requires a stopPrice parameter for "+o+" orders")}else{o==="LIMIT"?o="STOP_LIMIT":o==="MARKET"&&(o="STOP_MARKET");const p=d==="BUY"?"LTE":"GTE";c.operator=this.safeString(r,"operator",p),c.stopPrice=this.priceToPrecision(e,u),r=this.omit(r,["triggerPrice","stopPrice"])}if(o==="LIMIT"||o==="STOP_LIMIT")c.price=this.priceToPrecision(e,n),c.amount=this.amountToPrecision(e,i);else if(o==="MARKET"||o==="STOP_MARKET"){if(d==="SELL")c.amount=this.amountToPrecision(e,i);else if(d==="BUY"){let p=this.safeNumber(r,"value");if(this.safeValue(this.options,"createMarketBuyOrderRequiresPrice",!0)){if(n!==void 0)p===void 0&&(p=i*n);else if(p===void 0)throw new Dn(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total cost value in the 'amount' argument or in the 'value' extra parameter (the exchange-specific behaviour)")}else p=p===void 0?i:p;c.value=this.costToPrecision(e,p)}}c.type=o;const h=await this.privatePostOrdersCreate(this.extend(c,r)),l=this.safeValue(h,"data",{});return this.parseOrder(l,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privatePostOrdersCancel(this.extend(i,s)),r=this.safeValue(n,"data",{});return this.parseOrder(r)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetOrdersGet(this.extend(i,s)),r=this.safeValue(n,"data",{});return this.parseOrder(r)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),s!==void 0&&(n.limit=s),t!==void 0&&(n.fromTimestamp=t);const a=await this.privateGetOrdersList(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseOrders(o,r,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"SUBMITTED,PROCESSING,PARTIAL_FILLED,CANCELING"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"FILLED,CANCELED,REJECTED"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={id:e},a=await this.privateGetOrdersFill(this.extend(r,n));let o;t!==void 0&&(o=this.market(t));const d=this.safeValue(a,"data",[]);return this.parseTrades(d,o,s,i)}parseOrderStatus(e){const t={SUBMITTED:"open",PROCESSING:"open",PARTIAL_FILLED:"open",CANCELING:"open",FILLED:"closed",CANCELED:"canceled",REJECTED:"rejected"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"amount"),n=this.safeString(e,"price"),r=this.safeString2(e,"filledValue","value"),a=this.safeStringLower(e,"type"),o=this.safeStringLower(e,"side"),d=this.parseOrderStatus(this.safeString(e,"status")),c=this.safeInteger(e,"timestamp"),u=this.safeString(e,"averagePrice"),h=this.safeString(e,"filledAmount");let l;const p=this.safeNumber(e,"filledFee");p!==void 0&&(l={cost:p,currency:void 0});const m=this.safeString(e,"symbol"),g=this.safeSymbol(m,t,"_"),y=this.safeNumber(e,"stopPrice");return this.safeOrder({id:s,clientOrderId:void 0,info:e,timestamp:c,datetime:this.iso8601(c),lastTradeTimestamp:void 0,symbol:g,type:a,timeInForce:void 0,postOnly:void 0,side:o,price:n,stopPrice:y,amount:i,cost:r,average:u,filled:h,remaining:void 0,status:d,fee:l,trades:void 0},t)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e);if(s!=="main"&&i!=="main")throw new ih(this.id+" transfer() supports transfers between main account and subaccounts only");const a=s==="main"?"master-transfer-in":"master-transfer-out",o={transferAmount:this.currencyToPrecision(e,t),currency:r.id,subId:a==="master-transfer-in"?i:s,transferType:a},d=await this.privatePostAccountSubsTransfer(this.extend(o,n)),c=this.parseTransfer(d,r),u=this.safeValue(this.options,"transfer",{});return this.safeValue(u,"fillResponseFromRequest",!0)&&(c.fromAccount=s,c.toAccount=i,c.amount=t),c}parseTransfer(e,t=void 0){const s=this.safeString(e,"data"),i=this.safeString(e,"message"),n=this.safeCurrencyCode(void 0,t);return{info:e,id:s,amount:void 0,code:n,currency:n,fromAccount:void 0,toAccount:void 0,timestamp:void 0,datetime:void 0,status:i}}parseTransferStatus(e){const t={SUCCESS:"pending"};return this.safeString(t,e,"failed")}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets();const r=this.currency(e),a={code:r.id,amount:this.currencyToPrecision(e,t),wallet:s};i!==void 0&&(a.tag=i);const o=await this.privatePostAccountWithdrawCoin(this.extend(a,n));return this.parseTransaction(o,r)}async fetchAccounts(e={}){const t=await this.privateGetAccountSubs(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"subId"),o=this.safeString(r,"subAccount");i.push({id:a,type:o,currency:void 0,info:r})}return i}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){const n={type:"coin_in"};return await this.fetchTransactions(e,t,s,this.extend(n,i))}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const n={type:"coin_out"};return await this.fetchTransactions(e,t,s,this.extend(n,i))}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.size=s);const a=await this.privateGetWalletQueryDepositWithdraw(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,r,t,s)}parseTransactionStatus(e){const t=e.split(" ");e=this.safeString(t,1,e);const s={Pending:"pending",confirming:"pending",SUCCESS:"ok",FAIL:"failed"};return this.safeString(s,e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"id","data");let i=this.safeString(e,"type");i==="COIN_IN"?i="deposit":i==="COIN_OUT"&&(i="withdraw");const n=this.safeNumber(e,"amount"),r=this.safeString(e,"address"),a=this.safeString(e,"addressTag"),o=this.safeString(e,"txHash"),d=this.safeInteger(e,"createdAt"),c=this.safeInteger(e,"updatedAt"),u=this.safeString(e,"currency"),h=this.safeCurrencyCode(u,t),l=this.parseTransactionStatus(this.safeString(e,"state")),p=this.safeString(e,"chain");return{info:e,id:s,currency:h,amount:n,network:p,address:r,addressTo:r,addressFrom:void 0,tag:a,tagTo:a,tagFrom:void 0,status:l,type:i,updated:c,txid:o,timestamp:d,datetime:this.iso8601(d),fee:void 0}}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),s!==void 0&&(n.limit=s),t!==void 0&&(n.fromTimestamp=t);const a=await this.privateGetOrdersFills(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,r,t,s)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a="/"+this.version+"/"+this.implodeParams(e,i);let o=this.urls.api[t]+a;const d=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(d).length&&(o+="?"+this.urlencode(d));else if(t==="private"){this.checkRequiredCredentials();const c=this.milliseconds().toString();n={"X-Nova-Access-Key":this.apiKey,"X-Nova-Timestamp":c};let u;s==="POST"?(r=this.json(d),u=this.hash(this.encode(r),"md5"),n["Content-Type"]="application/json"):(Object.keys(d).length&&(o+="?"+this.urlencode(d)),u=this.urlencode(this.keysort(d)));const h=s+`
`+a+`
`+u+`
`+c;n["X-Nova-Signature"]=this.hmac(this.encode(h),this.encode(this.secret))}return{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"code");if(c!=="A10000"){const u=this.safeString(a,"message"),h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,h),this.throwBroadlyMatchedException(this.exceptions.broad,u,h),new ih(h)}}};const E9=me,{ExchangeError:V9,AuthenticationError:Ec,ArgumentsRequired:Rv,BadRequest:Vc,InvalidOrder:q9,InsufficientFunds:L9,OrderNotFound:z0,PermissionDenied:Fv}=oe,{TICK_SIZE:R9}=pe;var F9=class extends E9{describe(){return this.deepExtend(super.describe(),{id:"oceanex",name:"OceanEx",countries:["BS"],version:"v1",rateLimit:3e3,urls:{logo:"https://user-images.githubusercontent.com/1294454/58385970-794e2d80-8001-11e9-889c-0567cd79b78e.jpg",api:{rest:"https://api.oceanex.pro"},www:"https://www.oceanex.pro.com",doc:"https://api.oceanex.pro/doc/v1",referral:"https://oceanex.pro/signup?referral=VE24QX"},has:{CORS:void 0,spot:!0,margin:!1,swap:void 0,future:void 0,option:void 0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createMarketOrder:!0,createOrder:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchMarkets:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!0,fetchOrders:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTradingLimits:void 0,fetchTransactionFees:void 0},timeframes:{"1m":"1","5m":"5","15m":"15","30m":"30","1h":"60","2h":"120","4h":"240","6h":"360","12h":"720","1d":"1440","3d":"4320","1w":"10080"},api:{public:{get:["markets","tickers/{pair}","tickers_multi","order_book","order_book/multi","fees/trading","trades","timestamp"],post:["k"]},private:{get:["key","members/me","orders","orders/filter"],post:["orders","orders/multi","order/delete","order/delete/multi","orders/clear"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")}},commonCurrencies:{PLA:"Plair"},precisionMode:R9,exceptions:{codes:{"-1":Vc,"-2":Vc,1001:Vc,1004:Rv,1006:Ec,1008:Ec,1010:Ec,1011:Fv,2001:Ec,2002:q9,2004:z0,9003:Fv},exact:{"market does not have a valid value":Vc,"side does not have a valid value":Vc,"Account::AccountError: Cannot lock funds":L9,"The account does not exist":Ec}}})}async fetchMarkets(e={}){const t={show_details:!0},s=await this.publicGetMarkets(this.extend(t,e)),i=[],n=this.safeValue(s,"data",[]);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeValue(a,"id"),d=this.safeValue(a,"name");let[c,u]=d.split("/");const h=this.safeCurrencyCode(c),l=this.safeCurrencyCode(u);c=c.toLowerCase(),u=u.toLowerCase();const p=h+"/"+l;i.push({id:o,symbol:p,base:h,quote:l,settle:void 0,baseId:c,quoteId:u,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(a,"amount_precision"))),price:this.parseNumber(this.parsePrecision(this.safeString(a,"price_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(a,"minimum_trading_amount"),max:void 0}},info:a})}return i}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetTickersPair(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e),e===void 0&&(e=this.symbols);const i={markets:this.marketIds(e)},n=await this.publicGetTickersMulti(this.extend(i,t)),r=this.safeValue(n,"data",[]),a={};for(let o=0;o<r.length;o++){const d=r[o],c=this.safeString(d,"market"),u=this.safeMarket(c),h=u.symbol;a[h]=this.parseTicker(d,u)}return this.filterByArray(a,"symbol",e)}parseTicker(e,t=void 0){const s=this.safeValue(e,"ticker",{}),i=this.safeTimestamp(e,"at"),n=this.safeSymbol(void 0,t);return this.safeTicker({symbol:n,timestamp:i,datetime:this.iso8601(i),high:this.safeString(s,"high"),low:this.safeString(s,"low"),bid:this.safeString(s,"buy"),bidVolume:void 0,ask:this.safeString(s,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:this.safeString(s,"last"),last:this.safeString(s,"last"),previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(s,"volume"),quoteVolume:void 0,info:s},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={market:this.market(e).id};t!==void 0&&(n.limit=t);const r=await this.publicGetOrderBook(this.extend(n,s)),a=this.safeValue(r,"data",{}),o=this.safeTimestamp(a,"timestamp");return this.parseOrderBook(a,e,o)}async fetchOrderBooks(e=void 0,t=void 0,s={}){await this.loadMarkets(),e===void 0&&(e=this.symbols);const n={markets:this.marketIds(e)};t!==void 0&&(n.limit=t);const r=await this.publicGetOrderBookMulti(this.extend(n,s)),a=this.safeValue(r,"data",[]),o={};for(let d=0;d<a.length;d++){const c=a[d],u=this.safeString(c,"market"),h=this.safeSymbol(u),l=this.safeTimestamp(c,"timestamp");o[h]=this.parseOrderBook(c,h,l)}return o}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetTrades(this.extend(r,i)),o=this.safeValue(a,"data");return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){let s=this.safeValue(e,"side");s==="bid"?s="buy":s==="ask"&&(s="sell");const i=this.safeValue(e,"market"),n=this.safeSymbol(i,t);let r=this.safeTimestamp(e,"created_on");r===void 0&&(r=this.parse8601(this.safeString(e,"created_at")));const a=this.safeString(e,"price"),o=this.safeString(e,"volume");return this.safeTrade({info:e,timestamp:r,datetime:this.iso8601(r),symbol:n,id:this.safeString(e,"id"),order:void 0,type:"limit",takerOrMaker:void 0,side:s,price:a,amount:o,cost:void 0,fee:void 0},t)}async fetchTime(e={}){const t=await this.publicGetTimestamp(e);return this.safeTimestamp(t,"data")}async fetchTradingFees(e={}){const t=await this.publicGetFeesTrading(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeValue(r,"ask_fee",{}),o=this.safeValue(r,"bid_fee",{}),d=this.safeString(r,"market"),c=this.safeSymbol(d);i[c]={info:r,symbol:c,maker:this.safeNumber(a,"value"),taker:this.safeNumber(o,"value"),percentage:!0}}return i}async fetchKey(e={}){const t=await this.privateGetKey(e);return this.safeValue(t,"data")}parseBalance(e){const t=this.safeValue(e,"data"),s=this.safeValue(t,"accounts",[]),i={info:e};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeValue(r,"currency"),o=this.safeCurrencyCode(a),d=this.account();d.free=this.safeString(r,"balance"),d.used=this.safeString(r,"locked"),i[o]=d}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetMembersMe(e);return this.parseBalance(t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={market:a.id,side:s,ord_type:t,volume:this.amountToPrecision(e,i)};t==="limit"&&(o.price=this.priceToPrecision(e,n));const d=await this.privatePostOrders(this.extend(o,r)),c=this.safeValue(d,"data");return this.parseOrder(c,a)}async fetchOrder(e,t=void 0,s={}){let i=e;Array.isArray(e)||(i=[e]),await this.loadMarkets();let n;t!==void 0&&(n=this.market(t));const r={ids:i},a=await this.privateGetOrders(this.extend(r,s)),o=this.safeValue(a,"data"),d=o.length;if(o===void 0)throw new z0(this.id+" could not found matching order");if(Array.isArray(e))return this.parseOrders(o,n);if(d===0)throw new z0(this.id+" could not found matching order");return this.parseOrder(o[0],n)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={states:["wait"]};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={states:["done","cancel"]};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Rv(this.id+" fetchOrders() requires a `symbol` argument");await this.loadMarkets();const n=this.market(e),r=this.safeValue(i,"states",["wait","done","cancel"]),a=this.omit(i,"states"),o={market:n.id,states:r,need_price:"True"};s!==void 0&&(o.limit=s);const d=await this.privateGetOrdersFilter(this.extend(o,a)),c=this.safeValue(d,"data",[]);let u=[];for(let h=0;h<c.length;h++){const l=this.safeValue(c[h],"orders",[]),p=this.parseOrderStatus(this.safeValue(c[h],"state")),m=this.parseOrders(l,n,t,s,{status:p});u=this.arrayConcat(u,m)}return u}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={market:r.id,period:this.timeframes[t]};s!==void 0&&(a.timestamp=s),i!==void 0&&(a.limit=i);const o=await this.publicPostK(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseOHLCVs(d,r,t,s,i)}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeValue(e,"state")),i=this.safeString2(e,"market","market_id"),n=this.safeSymbol(i,t);let r=this.safeTimestamp(e,"created_on");r===void 0&&(r=this.parse8601(this.safeString(e,"created_at")));const a=this.safeString(e,"price"),o=this.safeString(e,"avg_price"),d=this.safeString(e,"volume"),c=this.safeString(e,"remaining_volume"),u=this.safeString(e,"executed_volume");return this.safeOrder({info:e,id:this.safeString(e,"id"),clientOrderId:void 0,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,symbol:n,type:this.safeValue(e,"ord_type"),timeInForce:void 0,postOnly:void 0,side:this.safeValue(e,"side"),price:a,stopPrice:void 0,average:o,amount:d,remaining:c,filled:u,status:s,cost:void 0,trades:void 0,fee:void 0},t)}parseOrderStatus(e){const t={wait:"open",done:"closed",cancel:"canceled"};return this.safeString(t,e,e)}async createOrders(e,t,s={}){await this.loadMarkets();const n={market:this.market(e).id,orders:t},a=(await this.privatePostOrdersMulti(this.extend(n,s))).data;return this.parseOrders(a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=await this.privatePostOrderDelete(this.extend({id:e},s)),n=this.safeValue(i,"data");return this.parseOrder(n)}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i=await this.privatePostOrderDeleteMulti(this.extend({ids:e},s)),n=this.safeValue(i,"data");return this.parseOrders(n)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s=await this.privatePostOrdersClear(t),i=this.safeValue(s,"data");return this.parseOrders(i)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="public")if(e==="tickers_multi"||e==="order_book/multi"){let d="?";const c=this.safeValue(i,"markets");for(let h=0;h<c.length;h++)d+="markets[]="+c[h]+"&";const u=this.safeValue(i,"limit");u!==void 0&&(d+="limit="+u),a+=d}else Object.keys(o).length&&(a+="?"+this.urlencode(o));else if(t==="private"){this.checkRequiredCredentials();const d={uid:this.apiKey,data:o},c=this.jwt(d,this.encode(this.secret),"RS256");a+="?user_jwt="+c}return n={"Content-Type":"application/json"},{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"code"),u=this.safeString(a,"message");if(c!==void 0&&c!=="0"){const h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.codes,c,h),this.throwExactlyMatchedException(this.exceptions.exact,u,h),new V9(h)}}};const D9=me,{ExchangeError:ae,ExchangeNotAvailable:Ho,OnMaintenance:H9,ArgumentsRequired:ui,BadRequest:hs,AccountSuspended:nh,InvalidAddress:K0,PermissionDenied:Os,DDoSProtection:Dv,InsufficientFunds:On,InvalidNonce:G9,CancelPending:U9,InvalidOrder:Ie,OrderNotFound:X0,AuthenticationError:Oi,RequestTimeout:Hv,NotSupported:ja,BadSymbol:Gv,RateLimitExceeded:Uv}=oe,{TICK_SIZE:$9}=pe,Nt=ke;var $_=class extends D9{describe(){return this.deepExtend(super.describe(),{id:"okcoin",name:"OKCoin",countries:["CN","US"],version:"v3",rateLimit:20,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:void 0,future:!0,option:void 0,cancelOrder:!0,createOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchLedger:!0,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:void 0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositions:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTransactions:void 0,fetchWithdrawals:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"60","3m":"180","5m":"300","15m":"900","30m":"1800","1h":"3600","2h":"7200","4h":"14400","6h":"21600","12h":"43200","1d":"86400","1w":"604800","1M":"2678400","3M":"8035200","6M":"16070400","1y":"31536000"},hostname:"okcoin.com",urls:{logo:"https://user-images.githubusercontent.com/51840849/87295551-102fbf00-c50e-11ea-90a9-462eebba5829.jpg",api:{rest:"https://www.{hostname}"},www:"https://www.okcoin.com",doc:"https://www.okcoin.com/docs/en/",fees:"https://www.okcoin.com/coin-fees",referral:"https://www.okcoin.com/account/register?flag=activity&channelId=600001513",test:{rest:"https://testnet.okex.com"}},api:{general:{get:{time:8.3334}},account:{get:{wallet:8.3334,"sub-account":1e3,"asset-valuation":1e3,"wallet/{currency}":8.3334,"withdrawal/history":8.3334,"withdrawal/history/{currency}":8.3334,ledger:5,"deposit/address":8.3334,"deposit/history":8.3334,"deposit/history/{currency}":8.3334,currencies:8.3334,"withdrawal/fee":8.3334,"deposit-lightning":50,"withdrawal-lightning":50,"fiat/deposit/detail":5,"fiat/deposit/details":8.3334,"fiat/withdraw/detail":5,"fiat/withdraw/details":8.3334,"fiat/channel":8.3334},post:{transfer:100,withdrawal:8.3334,"fiat/cancel_deposit":1,"fiat/deposit":8.3334,"fiat/withdraw":8.3334,"fiat/cancel_withdrawal":1}},otc:{get:{"rfq/instruments":50,"rfq/trade":50,"rfq/history":50},post:{"rfq/quote":50,"rfq/trade":50}},users:{get:{"subaccount-info":20,"account-info":20,"subaccount/apikey":20},post:{"create-subaccount":5,"delete-subaccount":5,"subaccount/apikey":50,"subacount/delete-apikey":20,"subacount/modify-apikey":20}},earning:{get:{offers:5,orders:5,positions:8.3334},post:{purchase:5,redeem:5,cancel:5}},spot:{get:{accounts:5,"accounts/{currency}":5,"accounts/{currency}/ledger":5,orders:10,orders_pending:5,"orders/{order_id}":5,"orders/{client_oid}":5,trade_fee:5,fills:10,algo:5,instruments:5,"instruments/{instrument_id}/book":5,"instruments/ticker":5,"instruments/{instrument_id}/ticker":5,"instruments/{instrument_id}/trades":5,"instruments/{instrument_id}/candles":5},post:{order_algo:2.5,orders:1,batch_orders:2,"cancel_orders/{order_id}":1,"cancel_orders/{client_oid}":1,cancel_batch_algos:5,cancel_batch_orders:5,"amend_order/{instrument_id}":2.5,amend_batch_orders:5}},margin:{get:{accounts:5,"accounts/{instrument_id}":5,"accounts/{instrument_id}/ledger":5,"accounts/availability":5,"accounts/{instrument_id}/availability":5,"accounts/borrowed":5,"accounts/{instrument_id}/borrowed":5,orders:10,"accounts/{instrument_id}/leverage":1,"orders/{order_id}":5,"orders/{client_oid}":5,orders_pending:5,fills:10,"instruments/{instrument_id}/mark_price":5},post:{"accounts/borrow":1,"accounts/repayment":1,orders:1,batch_orders:2,cancel_orders:1,"cancel_orders/{order_id}":1,"cancel_orders/{client_oid}":1,cancel_batch_orders:2,"amend_order/{instrument_id}":2.5,amend_batch_orders:5,"accounts/{instrument_id}/leverage":1}},system:{get:{status:250}},market:{get:{oracle:250}},futures:{get:["position","{instrument_id}/position","accounts","accounts/{underlying}","accounts/{underlying}/leverage","accounts/{underlying}/ledger","order_algo/{instrument_id}","orders/{instrument_id}","orders/{instrument_id}/{order_id}","orders/{instrument_id}/{client_oid}","fills","trade_fee","accounts/{instrument_id}/holds","order_algo/{instrument_id}","instruments","instruments/{instrument_id}/book","instruments/ticker","instruments/{instrument_id}/ticker","instruments/{instrument_id}/trades","instruments/{instrument_id}/candles","instruments/{instrument_id}/history/candles","instruments/{instrument_id}/index","rate","instruments/{instrument_id}/estimated_price","instruments/{instrument_id}/open_interest","instruments/{instrument_id}/price_limit","instruments/{instrument_id}/mark_price","instruments/{instrument_id}/liquidation"],post:["accounts/{underlying}/leverage","order","amend_order/{instrument_id}","orders","cancel_order/{instrument_id}/{order_id}","cancel_order/{instrument_id}/{client_oid}","cancel_batch_orders/{instrument_id}","accounts/margin_mode","close_position","cancel_all","order_algo","cancel_algos"]},swap:{get:["position","{instrument_id}/position","accounts","{instrument_id}/accounts","accounts/{instrument_id}/settings","accounts/{instrument_id}/ledger","orders/{instrument_id}","orders/{instrument_id}/{order_id}","orders/{instrument_id}/{client_oid}","fills","accounts/{instrument_id}/holds","trade_fee","order_algo/{instrument_id}","instruments","instruments/{instrument_id}/depth","instruments/ticker","instruments/{instrument_id}/ticker","instruments/{instrument_id}/trades","instruments/{instrument_id}/candles","instruments/{instrument_id}/history/candles","instruments/{instrument_id}/index","rate","instruments/{instrument_id}/open_interest","instruments/{instrument_id}/price_limit","instruments/{instrument_id}/liquidation","instruments/{instrument_id}/funding_time","instruments/{instrument_id}/mark_price","instruments/{instrument_id}/historical_funding_rate"],post:["accounts/{instrument_id}/leverage","order","amend_order/{instrument_id}","orders","cancel_order/{instrument_id}/{order_id}","cancel_order/{instrument_id}/{client_oid}","cancel_batch_orders/{instrument_id}","order_algo","cancel_algos","close_position","cancel_all","order_algo","cancel_algos"]},option:{get:["accounts","position","{underlying}/position","accounts/{underlying}","orders/{underlying}","fills/{underlying}","accounts/{underlying}/ledger","trade_fee","orders/{underlying}/{order_id}","orders/{underlying}/{client_oid}","underlying","instruments/{underlying}","instruments/{underlying}/summary","instruments/{underlying}/summary/{instrument_id}","instruments/{instrument_id}/book","instruments/{instrument_id}/trades","instruments/{instrument_id}/ticker","instruments/{instrument_id}/candles"],post:["order","orders","cancel_order/{underlying}/{order_id}","cancel_order/{underlying}/{client_oid}","cancel_batch_orders/{underlying}","amend_order/{underlying}","amend_batch_orders/{underlying}"]},information:{get:["{currency}/long_short_ratio","{currency}/volume","{currency}/taker","{currency}/sentiment","{currency}/margin"]},index:{get:["{instrument_id}/constituents"]}},fees:{trading:{taker:.002,maker:.001},spot:{taker:.0015,maker:.001}},requiredCredentials:{apiKey:!0,secret:!0,password:!0},exceptions:{exact:{1:ae,"failure to get a peer from the ring-balancer":Ho,"Server is busy, please try again.":Ho,"An unexpected error occurred":ae,"System error":ae,4010:Os,4001:ae,4002:ae,30001:Oi,30002:Oi,30003:Oi,30004:Oi,30005:G9,30006:Oi,30007:hs,30008:Hv,30009:ae,30010:Oi,30011:Os,30012:Oi,30013:Oi,30014:Dv,30015:Oi,30016:ae,30017:ae,30018:ae,30019:Ho,30020:hs,30021:hs,30022:Os,30023:hs,30024:Gv,30025:hs,30026:Dv,30027:Oi,30028:Os,30029:nh,30030:Ho,30031:hs,30032:Gv,30033:hs,30034:ae,30035:ae,30036:ae,30037:Ho,30038:H9,30044:Hv,32001:nh,32002:Os,32003:U9,32004:ae,32005:Ie,32006:Ie,32007:Ie,32008:Ie,32009:Ie,32010:ae,32011:ae,32012:ae,32013:ae,32014:ae,32015:ae,32016:ae,32017:ae,32018:ae,32019:ae,32020:ae,32021:ae,32022:ae,32023:ae,32024:ae,32025:ae,32026:ae,32027:ae,32028:ae,32029:ae,32030:Ie,32031:ui,32038:Oi,32040:ae,32044:ae,32045:ae,32046:ae,32047:ae,32048:Ie,32049:ae,32050:Ie,32051:Ie,32052:ae,32053:ae,32057:ae,32054:ae,32055:Ie,32056:ae,32058:ae,32059:Ie,32060:Ie,32061:Ie,32062:Ie,32063:Ie,32064:ae,32065:ae,32066:ae,32067:ae,32068:ae,32069:ae,32070:ae,32071:ae,32072:ae,32073:ae,32074:ae,32075:ae,32076:ae,32077:ae,32078:ae,32079:ae,32080:ae,32083:ae,33001:Os,33002:nh,33003:On,33004:ae,33005:ae,33006:ae,33007:ae,33008:On,33009:ae,33010:ae,33011:ae,33012:ae,33013:Ie,33014:X0,33015:Ie,33016:ae,33017:On,33018:ae,33020:ae,33021:hs,33022:Ie,33023:ae,33024:Ie,33025:Ie,33026:ae,33027:Ie,33028:Ie,33029:Ie,33034:ae,33035:ae,33036:ae,33037:ae,33038:ae,33039:ae,33040:ae,33041:ae,33042:ae,33043:ae,33044:ae,33045:ae,33046:ae,33047:ae,33048:ae,33049:ae,33050:ae,33051:ae,33059:hs,33060:hs,33061:ae,33062:ae,33063:ae,33064:ae,33065:ae,33085:Ie,21009:ae,34001:Os,34002:K0,34003:ae,34004:ae,34005:ae,34006:ae,34007:ae,34008:On,34009:ae,34010:ae,34011:ae,34012:ae,34013:ae,34014:ae,34015:ae,34016:Os,34017:nh,34018:Oi,34019:Os,34020:Os,34021:K0,34022:ae,34023:Os,34026:Uv,34036:ae,34037:ae,34038:ae,34039:ae,35001:ae,35002:ae,35003:ae,35004:ae,35005:Oi,35008:Ie,35010:Ie,35012:Ie,35014:Ie,35015:Ie,35017:ae,35019:Ie,35020:Ie,35021:Ie,35022:hs,35024:hs,35025:On,35026:hs,35029:X0,35030:Ie,35031:Ie,35032:ae,35037:ae,35039:On,35040:Ie,35044:ae,35046:On,35047:On,35048:ae,35049:Ie,35050:Ie,35052:On,35053:ae,35055:On,35057:ae,35058:ae,35059:hs,35060:hs,35061:hs,35062:Ie,35063:Ie,35064:Ie,35066:Ie,35067:Ie,35068:Ie,35069:Ie,35070:Ie,35071:Ie,35072:Ie,35073:Ie,35074:Ie,35075:Ie,35076:Ie,35077:Ie,35078:Ie,35079:Ie,35080:Ie,35081:Ie,35082:Ie,35083:Ie,35084:Ie,35085:Ie,35086:Ie,35087:Ie,35088:Ie,35089:Ie,35090:ae,35091:ae,35092:ae,35093:ae,35094:ae,35095:hs,35096:ae,35097:ae,35098:ae,35099:ae,35102:Uv,36001:hs,36002:hs,36005:ae,36101:Oi,36102:Os,36103:Os,36104:Os,36105:Os,36106:Os,36107:Os,36108:On,36109:Os,36201:Os,36202:Os,36203:Ie,36204:ae,36205:hs,36206:hs,36207:Ie,36208:Ie,36209:Ie,36210:Ie,36211:Ie,36212:Ie,36213:Ie,36214:ae,36216:X0,36217:Ie,36218:Ie,36219:Ie,36220:Ie,36221:Ie,36222:Ie,36223:Ie,36224:Ie,36225:Ie,36226:Ie,36227:Ie,36228:Ie,36229:Ie,36230:Ie},broad:{}},precisionMode:$9,options:{fetchOHLCV:{type:"Candles"},createMarketBuyOrderRequiresPrice:!0,fetchMarkets:["spot"],defaultType:"spot",accountsByType:{spot:"1",funding:"6",main:"6"},accountsById:{1:"spot",6:"funding"},auth:{time:"public",currencies:"private",instruments:"public",rate:"public","{instrument_id}/constituents":"public"},warnOnFetchCurrenciesWithoutAuthorization:!1},commonCurrencies:{AE:"AET",BOX:"DefiBox",HOT:"Hydro Protocol",HSR:"HC",MAG:"Maggie",SBTC:"Super Bitcoin",TRADE:"Unitrade",YOYO:"YOYOW",WIN:"WinToken"}})}async fetchTime(e={}){const t=await this.generalGetTime(e);return this.parse8601(this.safeString(t,"iso"))}async fetchMarkets(e={}){const t=this.safeValue(this.options,"fetchMarkets");let s=[];for(let i=0;i<t.length;i++){const n=await this.fetchMarketsByType(t[i],e);s=this.arrayConcat(s,n)}return s}parseMarkets(e){const t=[];for(let s=0;s<e.length;s++)t.push(this.parseMarket(e[s]));return t}parseMarket(e){const t=this.safeString(e,"instrument_id");let s=this.safeValue(e,"option_type");const i=this.safeNumber(e,"contract_val"),n=i!==void 0,r=this.safeString(e,"alias");let a="spot";const o=!n,d=s!==void 0,c=!d&&r!==void 0,u=n&&!c&&!d;let h=this.safeString(e,"base_currency"),l=this.safeString(e,"quote_currency");const p=this.safeString(e,"settlement_currency");if(d){const q=this.safeString(e,"underlying").split("-");h=this.safeString(q,0),l=this.safeString(q,1),a="option"}else c?(h=this.safeString(e,"underlying_index"),a="futures"):u&&(a="swap");const m=this.safeCurrencyCode(h),g=this.safeCurrencyCode(l),y=this.safeCurrencyCode(p);let b=m+"/"+g,w=this.safeString(e,"delivery"),S;const k=this.safeValue(e,"strike");n&&(b=b+":"+y,(c||d)&&(c&&(w+="T00:00:00Z"),S=this.parse8601(w),b=b+"-"+this.yymmdd(S),d&&(b=b+":"+k+":"+s,s=s==="C"?"call":"put")));const T=this.safeNumber2(e,"lot_size","trade_increment"),I=this.safeString(e,"tick_size"),_=this.safeString2(e,"min_size","base_min_size"),N=this.parseNumber(_);let M;N!==void 0&&I!==void 0&&(M=this.parseNumber(Nt.stringMul(I,_)));const x=this.safeValue2(this.fees,a,"trading",{}),v=this.safeString(e,"max_leverage","1"),O=this.parseNumber(Nt.stringMax(v,"1")),A=this.parseNumber(I);return this.extend(x,{id:t,symbol:b,base:m,quote:g,settle:y,baseId:h,quoteId:l,settleId:p,type:a,spot:o,margin:!1,swap:u,future:c,futures:c,option:d,active:!0,contract:n,linear:n?g===y:void 0,inverse:n?m===y:void 0,contractSize:i,expiry:S,expiryDatetime:this.iso8601(S),strike:k,optionType:s,precision:{amount:this.safeNumber(e,"size_increment",T),price:A},limits:{leverage:{min:this.parseNumber("1"),max:this.parseNumber(O)},amount:{min:N,max:void 0},price:{min:A,max:void 0},cost:{min:M,max:void 0}},info:e})}async fetchMarketsByType(e,t={}){if(e==="option"){const s=await this.optionGetUnderlying(t);let i=[];for(let n=0;n<s.length;n++){const r=await this.optionGetInstrumentsUnderlying({underlying:s[n]});i=this.arrayConcat(i,r)}return this.parseMarkets(i)}else if(e==="spot"||e==="futures"||e==="swap"){const s=e+"GetInstruments",i=await this[s](t);return this.parseMarkets(i)}else throw new ja(this.id+" fetchMarketsByType() does not support market type "+e)}async fetchCurrencies(e={}){if(this.checkRequiredCredentials(!1)){const t=await this.accountGetCurrencies(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.safeString(n,"name"),d=this.safeInteger(n,"can_deposit"),c=this.safeInteger(n,"can_withdraw"),u=d===1,h=c===1,l=!!(d&&c);s[a]={id:r,code:a,info:n,type:void 0,name:o,active:l,deposit:u,withdraw:h,fee:void 0,precision:this.parseNumber("0.00000001"),limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.safeNumber(n,"min_withdrawal"),max:void 0}}}}return s}else{if(this.options.warnOnFetchCurrenciesWithoutAuthorization)throw new ae(this.id+' fetchCurrencies() is a private API endpoint that requires authentication with API keys. Set the API keys on the exchange instance or exchange.options["warnOnFetchCurrenciesWithoutAuthorization"] = false to suppress this warning message.');return}}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);let n=i.type+"GetInstrumentsInstrumentId";n+=i.type==="swap"?"Depth":"Book";const r={instrument_id:i.id};t!==void 0&&(r.size=t);const a=await this[n](this.extend(r,s)),o=this.parse8601(this.safeString2(a,"timestamp","time"));return this.parseOrderBook(a,e,o)}parseTicker(e,t=void 0){const s=this.parse8601(this.safeString(e,"timestamp")),i=this.safeString(e,"instrument_id");t=this.safeMarket(i,t,"-");const n=t.symbol,r=this.safeString(e,"last"),a=this.safeString(e,"open_24h");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high_24h"),low:this.safeString(e,"low_24h"),bid:this.safeString(e,"best_bid"),bidVolume:this.safeString(e,"best_bid_size"),ask:this.safeString(e,"best_ask"),askVolume:this.safeString(e,"best_ask_size"),vwap:void 0,open:a,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"base_volume_24h"),quoteVolume:this.safeString(e,"quote_volume_24h"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=s.type+"GetInstrumentsInstrumentIdTicker",n={instrument_id:s.id},r=await this[i](this.extend(n,t));return this.parseTicker(r)}async fetchTickersByType(e,t=void 0,s={}){await this.loadMarkets(),t=this.marketSymbols(t);const i=e+"GetInstrumentsTicker",n=await this[i](s),r={};for(let a=0;a<n.length;a++){const o=this.parseTicker(n[a]),d=o.symbol;r[d]=o}return this.filterByArray(r,"symbol",t)}async fetchTickers(e=void 0,t={}){e=this.marketSymbols(e);const s=this.safeString(e,0);let i;s!==void 0&&(i=this.market(s));let n;return[n,t]=this.handleMarketTypeAndParams("fetchTickers",i,t),await this.fetchTickersByType(n,e,this.omit(t,"type"))}parseTrade(e,t=void 0){const s=this.safeString(e,"instrument_id");t=this.safeMarket(s,t,"-");const i=t.symbol,n=this.parse8601(this.safeString2(e,"timestamp","created_at")),r=this.safeString(e,"price");let a=this.safeString2(e,"size","qty");a=this.safeString(e,"order_qty",a);let o=this.safeString2(e,"exec_type","liquidity");o==="M"?o="maker":o==="T"&&(o="taker");const d=this.safeString(e,"side"),c=this.safeString(e,"fee");let u;if(c!==void 0){const l=d==="buy"?t.base:t.quote;u={cost:Nt.stringNeg(c),currency:l}}const h=this.safeString(e,"order_id");return this.safeTrade({info:e,timestamp:n,datetime:this.iso8601(n),symbol:i,id:this.safeString2(e,"trade_id","ledger_id"),order:h,type:void 0,takerOrMaker:o,side:d,price:r,amount:a,cost:void 0,fee:u},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r=n.type+"GetInstrumentsInstrumentIdTrades";(s===void 0||s>100)&&(s=100);const a={instrument_id:n.id,limit:s},o=await this[r](this.extend(a,i));return this.parseTrades(o,n,t,s)}parseOHLCV(e,t=void 0){if(Array.isArray(e)){const i=e.length>6?6:5;let n=this.safeValue(e,0);return typeof n=="string"&&(n=this.parse8601(n)),[n,this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,i)]}else return[this.parse8601(this.safeString(e,"time")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.parseTimeframe(t),o={instrument_id:r.id,granularity:this.timeframes[t]},d=this.safeValue(this.options,"fetchOHLCV",{}),c=this.safeString(d,"type","Candles"),u=this.safeString(n,"type",c);n=this.omit(n,"type");const h=r.type+"GetInstrumentsInstrumentId"+u;if(u==="Candles"){if(s!==void 0)i!==void 0&&(o.end=this.iso8601(this.sum(s,i*a*1e3))),o.start=this.iso8601(s);else if(i!==void 0){const p=this.milliseconds();o.start=this.iso8601(p-i*a*1e3),o.end=this.iso8601(p)}}else if(u==="HistoryCandles"){if(r.option)throw new ja(this.id+" fetchOHLCV() does not have "+u+" for "+r.type+" markets");if(s!==void 0)i===void 0&&(i=300),o.start=this.iso8601(this.sum(s,i*a*1e3)),o.end=this.iso8601(s);else if(i!==void 0){const p=this.milliseconds();o.end=this.iso8601(p-i*a*1e3),o.start=this.iso8601(p)}}const l=await this[h](this.extend(o,n));return this.parseOHLCVs(l,r,t,s,i)}parseAccountBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.total=this.safeString(i,"balance"),a.used=this.safeString(i,"hold"),a.free=this.safeString(i,"available"),t[r]=a}return this.safeBalance(t)}parseFuturesBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"info",{}),i=Object.keys(s);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeCurrencyCode(r),o=this.safeValue(s,r,{}),d=this.account(),c=this.safeString(o,"total_avail_balance");if(this.safeString(o,"margin_mode")==="fixed"){const u=this.safeValue(o,"contracts",[]);let h=c;for(let l=0;l<u.length;l++){const p=u[l],m=this.safeString(p,"fixed_balance"),g=this.safeString(p,"realized_pnl"),y=this.safeString(p,"margin_frozen"),b=this.safeString(p,"margin_for_unfilled"),w=Nt.stringSub(Nt.stringSub(Nt.stringAdd(m,g),y),b);h=Nt.stringAdd(h,w)}d.free=h}else{const u=this.safeString(o,"realized_pnl"),h=this.safeString(o,"unrealized_pnl"),l=this.safeString(o,"margin_frozen"),p=this.safeString(o,"margin_for_unfilled"),m=Nt.stringAdd(Nt.stringAdd(c,u),h);d.free=Nt.stringSub(Nt.stringSub(m,l),p)}d.total=this.safeString(o,"equity"),t[a]=d}return this.safeBalance(t)}parseSwapBalance(e){const t={info:e};let s;const i=this.safeValue(e,"info",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"instrument_id"),o=this.safeSymbol(a),d=this.parse8601(this.safeString(r,"timestamp"));s=s===void 0?d:Math.max(s,d);const c=this.account();c.total=this.safeString(r,"equity"),c.free=this.safeString(r,"total_avail_balance"),t[o]=c}return t.timestamp=s,t.datetime=this.iso8601(s),this.safeBalance(t)}async fetchBalance(e={}){const t=this.safeString2(this.options,"fetchBalance","defaultType"),s=this.safeString(e,"type",t);if(s===void 0)throw new ui(this.id+" fetchBalance() requires a type parameter (one of 'account', 'spot', 'futures', 'swap')");await this.loadMarkets();const i=s==="account"?"Wallet":"Accounts",n=s+"Get"+i,r=this.omit(e,"type"),a=await this[n](r);return this.parseBalanceByType(s,a)}parseBalanceByType(e,t){if(e==="account"||e==="spot")return this.parseAccountBalance(t);if(e==="futures")return this.parseFuturesBalance(t);if(e==="swap")return this.parseSwapBalance(t);throw new ja(this.id+" fetchBalance does not support the '"+e+"' type (the type must be one of 'account', 'spot', 'futures', 'swap')")}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o={instrument_id:a.id};const d=this.safeString2(r,"client_oid","clientOrderId");d!==void 0&&(o.client_oid=d,r=this.omit(r,["client_oid","clientOrderId"]));let c;if(a.futures||a.swap){const l=a.futures?this.numberToString(i):this.amountToPrecision(e,i);o=this.extend(o,{type:t,size:l});const p=this.safeString(r,"order_type");t==="market"||p==="4"?o.order_type="4":o.price=this.priceToPrecision(e,n),a.futures&&(o.leverage="10"),c=a.type+"PostOrder"}else{if(o=this.extend(o,{side:s,type:t}),t==="limit")o.price=this.priceToPrecision(e,n),o.size=this.amountToPrecision(e,i);else if(t==="market")if(s==="buy"){let l=this.safeNumber(r,"notional");if(this.safeValue(this.options,"createMarketBuyOrderRequiresPrice",!0)){if(n!==void 0)l===void 0&&(l=i*n);else if(l===void 0)throw new Ie(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total cost value in the 'amount' argument or in the 'notional' extra parameter (the exchange-specific behaviour)")}else l=l===void 0?i:l;o.notional=this.costToPrecision(e,l)}else o.size=this.amountToPrecision(e,i);c="spotPostOrders"}const u=await this[c](this.extend(o,r)),h=this.parseOrder(u,a);return this.extend(h,{type:t,side:s})}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new ui(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t);let n;if(i.futures||i.swap)n=i.type;else{const h=this.safeString2(this.options,"cancelOrder","defaultType",i.type);n=this.safeString(s,"type",h)}if(n===void 0)throw new ui(this.id+" cancelOrder() requires a type parameter (one of 'spot', 'futures', 'swap').");let r=n+"PostCancelOrder";const a={instrument_id:i.id};i.futures||i.swap?r+="InstrumentId":r+="s";const o=this.safeString2(s,"client_oid","clientOrderId");o!==void 0?(r+="ClientOid",a.client_oid=o):(r+="OrderId",a.order_id=e);const d=this.omit(s,["type","client_oid","clientOrderId"]),c=await this[r](this.extend(a,d)),u="result"in c?c:this.safeValue(c,i.id,{});return this.parseOrder(u,i)}parseOrderStatus(e){const t={"-2":"failed","-1":"canceled",0:"open",1:"open",2:"closed",3:"open",4:"canceled"};return this.safeString(t,e,e)}parseOrderSide(e){const t={1:"buy",2:"sell",3:"sell",4:"buy"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"order_id"),i=this.parse8601(this.safeString(e,"timestamp"));let n=this.safeString(e,"side");const r=this.safeString(e,"type");n!=="buy"&&n!=="sell"&&(n=this.parseOrderSide(r));const a=this.safeString(e,"instrument_id");t=this.safeMarket(a,t);let o=this.safeString(e,"size");const d=this.safeString2(e,"filled_size","filled_qty");let c;o!==void 0&&d!==void 0&&(o=Nt.stringMax(o,d),c=Nt.stringMax("0",Nt.stringSub(o,d))),r==="market"&&(c="0");let u=this.safeString2(e,"filled_notional","funds");const h=this.safeString(e,"price");let l=this.safeString(e,"price_avg");u===void 0?d!==void 0&&l!==void 0&&(u=Nt.stringMul(l,d)):l===void 0&&d!==void 0&&Nt.stringGt(d,"0")&&(l=Nt.stringDiv(u,d));const p=this.parseOrderStatus(this.safeString(e,"state")),m=this.safeNumber(e,"fee");let g;m!==void 0&&(g={cost:m,currency:void 0});let y=this.safeString(e,"client_oid");y!==void 0&&y.length<1&&(y=void 0);const b=this.safeNumber(e,"trigger_price");return this.safeOrder({info:e,id:s,clientOrderId:y,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,symbol:t.symbol,type:r,timeInForce:void 0,postOnly:void 0,side:n,price:h,stopPrice:b,average:l,cost:u,amount:o,filled:d,remaining:c,status:p,fee:g,trades:void 0},t)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new ui(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=this.safeString2(this.options,"fetchOrder","defaultType",i.type),r=this.safeString(s,"type",n);if(r===void 0)throw new ui(this.id+" fetchOrder() requires a type parameter (one of 'spot', 'futures', 'swap').");const a=i.futures||i.swap?"InstrumentId":"";let o=r+"GetOrders"+a;const d={instrument_id:i.id},c=this.safeString(s,"client_oid");c!==void 0?(o+="ClientOid",d.client_oid=c):(o+="OrderId",d.order_id=e);const u=this.omit(s,"type"),h=await this[o](this.extend(d,u));return this.parseOrder(h)}async fetchOrdersByState(e,t=void 0,s=void 0,i=void 0,n={}){if(t===void 0)throw new ui(this.id+" fetchOrdersByState() requires a symbol argument");await this.loadMarkets();const r=this.market(t);let a;if(r.futures||r.swap)a=r.type;else{const l=this.safeString2(this.options,"fetchOrder","defaultType",r.type);a=this.safeString(n,"type",l)}if(a===void 0)throw new ui(this.id+" fetchOrdersByState() requires a type parameter (one of 'spot', 'futures', 'swap').");const o={instrument_id:r.id,state:e};let d=a+"GetOrders";(r.futures||r.swap)&&(d+="InstrumentId");const c=this.omit(n,"type"),u=await this[d](this.extend(o,c));let h;if(r.swap||r.futures)h=this.safeValue(u,"order_info",[]);else{h=u;const l=u.length;if(l<1)return[];l>1&&this.safeValue(u[1],"before")!==void 0&&(h=u[0])}return this.parseOrders(h,r,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState("6",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState("7",e,t,s,i)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address");let i=this.safeString2(e,"tag","payment_id");i=this.safeString2(e,"memo","Memo",i);const n=this.safeString(e,"currency"),r=this.safeCurrencyCode(n);return this.checkAddress(s),{currency:r,address:s,tag:i,info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=e.split("-"),n={currency:this.currency(s[0]).id},r=await this.accountGetDepositAddress(this.extend(n,t)),a=this.parseDepositAddresses(r),o=this.safeValue(a,e);if(o===void 0)throw new K0(this.id+" fetchDepositAddress() cannot return nonexistent addresses, you should create withdrawal addresses with the exchange website first");return o}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c={amount:this.currencyToPrecision(e,t),currency:r.id,from:o,to:d,type:"0"};o==="main"?(c.type="1",c.sub_account=d,c.to="0"):d==="main"&&(c.type="2",c.sub_account=o,c.from="0",c.to="6");const u=await this.accountPostTransfer(this.extend(c,n));return this.parseTransfer(u,r)}parseTransfer(e,t=void 0){const s=this.safeValue(this.options,"accountsById",{});return{info:e,id:this.safeString(e,"transfer_id"),timestamp:void 0,datetime:void 0,currency:this.safeCurrencyCode(this.safeString(e,"currency"),t),amount:this.safeNumber(e,"amount"),fromAccount:this.safeString(s,this.safeString(e,"from")),toAccount:this.safeString(s,this.safeString(e,"to")),status:this.parseTransferStatus(this.safeString(e,"result"))}}parseTransferStatus(e){const t={true:"ok"};return this.safeString(t,e,"failed")}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e);i&&(s=s+":"+i);const a=this.safeString(n,"fee");if(a===void 0)throw new ui(this.id+" withdraw() requires a 'fee' string parameter, network transaction fee must be \u2265 0. Withdrawals to OKCoin or OKEx are fee-free, please set '0'. Withdrawing to external digital asset address requires network transaction fee.");const o={currency:r.id,to_address:s,destination:"4",amount:this.numberToString(t),fee:a};"password"in n?o.trade_pwd=n.password:"trade_pwd"in n?o.trade_pwd=n.trade_pwd:this.password&&(o.trade_pwd=this.password);const d=this.omit(n,["fee","password","trade_pwd"]);if(!("trade_pwd"in o))throw new ae(this.id+" withdraw() requires this.password set on the exchange instance or a password / trade_pwd parameter");const c=await this.accountPostWithdrawal(this.extend(o,d));return this.parseTransaction(c,r)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r="accountGetDepositHistory",a;e!==void 0&&(a=this.currency(e),n.currency=a.id,r+="Currency");const o=await this[r](this.extend(n,i));return this.parseTransactions(o,a,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r="accountGetWithdrawalHistory",a;e!==void 0&&(a=this.currency(e),n.currency=a.id,r+="Currency");const o=await this[r](this.extend(n,i));return this.parseTransactions(o,a,t,s,i)}parseTransactionStatus(e){const t={"-3":"pending","-2":"canceled","-1":"failed",0:"pending",1:"pending",2:"ok",3:"pending",4:"pending",5:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){let s,i,n;const r=this.safeString(e,"withdrawal_id"),a=this.safeString(e,"from"),o=this.safeString(e,"to"),d=this.safeString(e,"tag");r!==void 0?(s="withdrawal",i=r,n=o):(i=this.safeString2(e,"payment_id","deposit_id"),s="deposit",n=o);const c=this.safeString(e,"currency"),u=this.safeCurrencyCode(c),h=this.safeNumber(e,"amount"),l=this.parseTransactionStatus(this.safeString(e,"status")),p=this.safeString(e,"txid"),m=this.parse8601(this.safeString(e,"timestamp"));let g;if(s==="deposit")g=0;else if(c!==void 0){const y=this.safeString(e,"fee");if(y!==void 0){const b=c.toLowerCase(),w=y.replace(b,"");g=parseFloat(w)}}return{info:e,id:i,currency:u,amount:h,network:void 0,addressFrom:a,addressTo:o,address:n,tagFrom:void 0,tagTo:d,tag:d,status:l,type:s,updated:void 0,txid:p,timestamp:m,datetime:this.iso8601(m),fee:{currency:u,cost:g}}}parseMyTrade(e,t=void 0){const s=this.safeValue(e,1),i=this.safeValue(e,0),n=this.safeString(i,"instrument_id"),r=this.safeString(s,"instrument_id");if(n!==r)throw new ja(this.id+" parseMyTrade() received unrecognized response format, differing instrument_ids in one fill, the exchange API might have changed, paste your verbose output: https://github.com/ccxt/ccxt/wiki/FAQ#what-is-required-to-get-help");const a=n;t=this.safeMarket(a,t);const o=t.symbol,d=t.quoteId;let c,u,h;const l=this.safeString(s,"currency");let p;l===d?(c=this.safeString(i,"side"),u=this.safeString(i,"size"),h=this.safeString(s,"size"),p=this.safeString(i,"currency")):(c=this.safeString(s,"side"),u=this.safeString(s,"size"),h=this.safeString(i,"size"),p=this.safeString(s,"currency"));const m=this.safeString(s,"trade_id"),g=this.safeString(s,"price"),y=this.safeString(i,"fee"),b=this.safeString(s,"fee"),w=this.safeCurrencyCode(this.safeString(i,"currency")),S=this.safeCurrencyCode(this.safeString(s,"currency"));let k,T;y!==void 0&&!Nt.stringEquals(y,"0")?b!==void 0&&!Nt.stringEquals(b,"0")?T=[{cost:Nt.stringNeg(y),currency:w},{cost:Nt.stringNeg(b),currency:S}]:k={cost:Nt.stringNeg(y),currency:w}:b!==void 0&&!Nt.stringEquals(b,"0")?k={cost:Nt.stringNeg(b),currency:S}:k={cost:"0",currency:this.safeCurrencyCode(p)};const I=this.parse8601(this.safeString2(s,"timestamp","created_at"));let _=this.safeString2(s,"exec_type","liquidity");_==="M"?_="maker":_==="T"&&(_="taker");const N=this.safeString(s,"order_id");return this.safeTrade({info:e,timestamp:I,datetime:this.iso8601(I),symbol:o,id:m,order:N,type:void 0,takerOrMaker:_,side:c,price:g,amount:u,cost:h,fee:k,fees:T},t)}parseMyTrades(e,t=void 0,s=void 0,i=void 0,n={}){const r=this.groupBy(e,"trade_id"),a=Object.keys(r),o=[];for(let d=0;d<a.length;d++){const c=a[d],u=r[c];if(u.length===2){const l=this.parseMyTrade(u);o.push(l)}}return t=this.safeMarket(void 0,t),this.filterBySymbolSinceLimit(o,t.symbol,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new ui(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e);s!==void 0&&s>100&&(s=100);const r={instrument_id:n.id},a=this.safeString2(this.options,"fetchMyTrades","defaultType"),o=this.safeString(i,"type",a),d=this.omit(i,"type"),c=o+"GetFills",u=await this[c](this.extend(r,d));return this.parseMyTrades(u,n,t,s,i)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){const r={order_id:e};return await this.fetchMyTrades(t,s,i,this.extend(r,n))}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e);let i;const n={instrument_id:s.id},r=s.type;if(r==="futures"||r==="swap")i=r+"GetInstrumentIdPosition";else if(r==="option"){if(this.safeString(t,"underlying")===void 0)throw new ui(this.id+" fetchPosition() requires an underlying parameter for "+r+" market "+e);i=r+"GetUnderlyingPosition"}else throw new ja(this.id+" fetchPosition() does not support "+r+" market "+e+", supported market types are futures, swap or option");return await this[i](this.extend(n,t))}async fetchPositions(e=void 0,t={}){await this.loadMarkets();let s;const i=this.safeString2(this.options,"fetchPositions","defaultType"),n=this.safeString(t,"type",i);if(n==="futures"||n==="swap")s=n+"GetPosition";else if(n==="option"){if(this.safeString(t,"underlying")===void 0)throw new ui(this.id+" fetchPositions() requires an underlying parameter for "+n+" markets");s=n+"GetUnderlyingPosition"}else throw new ja(this.id+" fetchPositions() does not support "+n+" markets, supported market types are futures, swap or option");return t=this.omit(t,"type"),await this[s](t)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeString2(this.options,"fetchLedger","defaultType"),r=this.safeString(i,"type",n),a=this.omit(i,"type"),o=r==="account"?"":"Accounts";let d="";const c={};s!==void 0&&(c.limit=s);let u;if(r==="spot"){if(e===void 0)throw new ui(this.id+" fetchLedger() requires a currency code argument for '"+r+"' markets");d="Currency",u=this.currency(e),c.currency=u.id}else if(r==="futures"){if(e===void 0)throw new ui(this.id+" fetchLedger() requires an underlying symbol for '"+r+"' markets");d="Underlying";const m=this.market(e),g=this.safeValue(m,"info",{}),y=this.safeString(g,"settlement_currency"),b=this.safeCurrencyCode(y);u=this.currency(b);const w=this.safeString(g,"underlying");c.underlying=w}else if(r==="swap"){if(e===void 0)throw new ui(this.id+" fetchLedger() requires a code argument (a market symbol) for '"+r+"' markets");d="InstrumentId";const m=this.market(e);u=this.currency(m.base),c.instrument_id=m.id}else if(r==="account")e!==void 0&&(u=this.currency(e),c.currency=u.id);else throw new ja(this.id+" fetchLedger does not support the '"+r+"' type (the type must be one of 'account', 'spot', 'margin', 'futures', 'swap')");const h=r+"Get"+o+d+"Ledger",l=await this[h](this.extend(c,a));if(l.length<1)return[];if(r==="swap"){const m=this.parseLedger(l);return this.filterBySymbolSinceLimit(m,e,t,s)}return this.parseLedger(l,u,t,s)}parseLedgerEntryType(e){const t={transfer:"transfer",trade:"trade",rebate:"rebate",match:"trade",fee:"fee",settlement:"trade",liquidation:"trade",funding:"fee",margin:"margin"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"ledger_id"),i=void 0,n=this.safeValue(e,"details",{}),r=this.safeString(n,"order_id"),a=void 0,o=this.parseLedgerEntryType(this.safeString(e,"type")),d=this.safeCurrencyCode(this.safeString(e,"currency"),t),c=this.safeNumber(e,"amount"),u=this.parse8601(this.safeString(e,"timestamp")),h={cost:this.safeNumber(e,"fee"),currency:d},l=void 0,p=this.safeNumber(e,"balance"),m="ok",g=this.safeString(e,"instrument_id"),y=this.safeSymbol(g);return{info:e,id:s,account:i,referenceId:r,referenceAccount:a,type:o,currency:d,symbol:y,amount:c,before:l,after:p,status:m,timestamp:u,datetime:this.iso8601(u),fee:h}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=Array.isArray(i);let o="/api/"+t+"/"+this.version+"/";o+=a?e:this.implodeParams(e,i);const d=a?i:this.omit(i,this.extractParams(e));let c=this.implodeHostname(this.urls.api.rest)+o;const u=this.getPathAuthenticationType(e);if(u==="public"||u==="information")Object.keys(d).length&&(c+="?"+this.urlencode(d));else if(u==="private"){this.checkRequiredCredentials();const h=this.iso8601(this.milliseconds());n={"OK-ACCESS-KEY":this.apiKey,"OK-ACCESS-PASSPHRASE":this.password,"OK-ACCESS-TIMESTAMP":h};let l=h+s+o;if(s==="GET"){if(Object.keys(d).length){const m="?"+this.urlencode(d);c+=m,l+=m}}else(a||Object.keys(d).length)&&(r=this.json(d),l+=r),n["Content-Type"]="application/json";const p=this.hmac(this.encode(l),this.encode(this.secret),"sha256","base64");n["OK-ACCESS-SIGN"]=p}return{url:c,method:s,body:r,headers:n}}getPathAuthenticationType(e){if(e==="underlying")return"public";const t=this.safeValue(this.options,"auth",{}),s=this.findBroadlyMatchedKey(t,e);return this.safeString(t,s,"private")}handleErrors(e,t,s,i,n,r,a,o,d){if(!a)return;const c=this.id+" "+r;if(e===503)throw new Ho(c);const u=this.safeString(a,"message"),h=this.safeString2(a,"code","error_code"),l=u!==void 0&&u!=="",p=h!==void 0&&h!=="0";if(l&&(this.throwExactlyMatchedException(this.exceptions.exact,u,c),this.throwBroadlyMatchedException(this.exceptions.broad,u,c)),p&&this.throwExactlyMatchedException(this.exceptions.exact,h,c),p||l)throw new ae(c)}};const j9=me,{ExchangeError:ye,ExchangeNotAvailable:Wa,OnMaintenance:W9,ArgumentsRequired:Ni,BadRequest:gt,AccountSuspended:Qr,InvalidAddress:rh,PermissionDenied:Y0,InsufficientFunds:Hn,InvalidNonce:$v,InvalidOrder:Ce,OrderNotFound:ah,AuthenticationError:jt,RequestTimeout:z9,BadSymbol:Ei,RateLimitExceeded:oh,NetworkError:K9,CancelPending:X9,NotSupported:jv,AccountNotEnabled:Y9}=oe,{TICK_SIZE:Q9}=pe,ns=ke;var xb=class extends j9{describe(){return this.deepExtend(super.describe(),{id:"okx",name:"OKX",countries:["CN","US"],version:"v5",rateLimit:100,pro:!0,certified:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!0,option:void 0,addMargin:!0,borrowMargin:!0,cancelAllOrders:!1,cancelOrder:!0,cancelOrders:!0,createDepositAddress:!1,createOrder:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowInterest:!0,fetchBorrowRate:!0,fetchBorrowRateHistories:!0,fetchBorrowRateHistory:!0,fetchBorrowRates:!0,fetchBorrowRatesPerSymbol:!1,fetchCanceledOrders:!0,fetchClosedOrder:void 0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchIndexOHLCV:!0,fetchL3OrderBook:!1,fetchLedger:!0,fetchLedgerEntry:void 0,fetchLeverage:!0,fetchLeverageTiers:!1,fetchMarketLeverageTiers:!0,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenInterestHistory:!0,fetchOpenOrder:void 0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrders:!1,fetchOrderTrades:!0,fetchPermissions:void 0,fetchPosition:!0,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTradingLimits:!1,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfer:!0,fetchTransfers:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,fetchWithdrawalWhitelist:!1,reduceMargin:!0,repayMargin:!0,setLeverage:!0,setMargin:!1,setMarginMode:!0,setPositionMode:!0,signIn:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1H","2h":"2H","4h":"4H","6h":"6H","12h":"12H","1d":"1D","1w":"1W","1M":"1M","3M":"3M","6M":"6M","1y":"1Y"},hostname:"www.okx.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/152485636-38b19e4a-bece-4dec-979a-5982859ffc04.jpg",api:{rest:"https://{hostname}"},www:"https://www.okx.com",doc:"https://www.okx.com/docs-v5/en/",fees:"https://www.okx.com/pages/products/fees.html",referral:"https://www.okx.com/join/1888677",test:{rest:"https://{hostname}"}},api:{public:{get:{"market/tickers":1,"market/ticker":1,"market/index-tickers":1,"market/books":1,"market/books-lite":1.66,"market/candles":.5,"market/history-candles":1,"market/history-mark-price-candles":120,"market/history-index-candles":120,"market/index-candles":1,"market/mark-price-candles":1,"market/trades":1,"market/platform-24-volume":10,"market/open-oracle":100,"market/index-components":1,"public/instruments":1,"public/delivery-exercise-history":.5,"public/open-interest":1,"public/funding-rate":1,"public/funding-rate-history":1,"public/price-limit":1,"public/opt-summary":1,"public/estimated-price":2,"public/discount-rate-interest-free-quota":10,"public/time":2,"public/liquidation-orders":.5,"public/mark-price":2,"public/position-tiers":2,"public/underlying":1,"public/interest-rate-loan-quota":10,"public/vip-interest-rate-loan-quota":10,"rubik/stat/trading-data/support-coin":4,"rubik/stat/taker-volume":4,"rubik/stat/margin/loan-ratio":4,"rubik/stat/contracts/long-short-account-ratio":4,"rubik/stat/contracts/open-interest-volume":4,"rubik/stat/option/open-interest-volume":4,"rubik/stat/option/open-interest-volume-ratio":4,"rubik/stat/option/open-interest-volume-expiry":4,"rubik/stat/option/open-interest-volume-strike":4,"rubik/stat/option/taker-block-volume":4,"system/status":100,"asset/lending-rate-summary":5/3,"asset/lending-rate-history":5/3,"market/exchange-rate":20}},private:{get:{"account/account-position-risk":2,"account/balance":2,"account/positions":2,"account/bills":5/3,"account/bills-archive":5/3,"account/config":4,"account/max-size":1,"account/max-avail-size":1,"account/leverage-info":1,"account/max-loan":1,"account/trade-fee":4,"account/interest-accrued":4,"account/interest-rate":4,"account/max-withdrawal":1,"account/risk-state":2,"account/borrow-repay-history":4,"account/interest-limits":4,"asset/asset-valuation":1/5,"asset/deposit-address":5/3,"asset/balances":5/3,"asset/transfer-state":10,"asset/deposit-history":5/3,"asset/withdrawal-history":5/3,"asset/currencies":5/3,"asset/bills":5/3,"asset/piggy-balance":5/3,"asset/deposit-lightning":5,"asset/lending-history":5/3,"asset/saving-balance":5/3,"trade/order":1/3,"trade/orders-pending":1,"trade/orders-history":.5,"trade/orders-history-archive":1,"trade/fills":1/3,"trade/fills-history":2,"trade/orders-algo-pending":1,"trade/orders-algo-history":1,"account/subaccount/balances":10,"asset/subaccount/bills":5/3,"users/subaccount/list":10,"users/subaccount/apikey":10,"users/entrust-subaccount-list":10,"broker/nd/info":10,"broker/nd/subaccount-info":10,"asset/broker/nd/subaccount-deposit-address":4,"asset/broker/nd/subaccount-deposit-history":4,"broker/nd/rebate-daily":1,"broker/nd/subaccount/apikey":10,"broker/nd/rebate-per-orders":300,"asset/convert/currencies":5/3,"asset/convert/currency-pair":5/3,"asset/convert/estimate-quote":5,"asset/convert/trade":5,"asset/convert/history":5/3,"account/greeks":2,"finance/staking-defi/offers":1,"finance/staking-defi/orders-active":1,"finance/staking-defi/orders-history":1},post:{"account/set-position-mode":4,"account/set-leverage":1,"account/position/margin-balance":1,"account/set-greeks":4,"account/set-isolated-mode":4,"account/simulated_margin":10,"account/borrow-repay":5/3,"asset/transfer":10,"asset/withdrawal":5/3,"asset/purchase_redempt":5/3,"asset/withdrawal-lightning":5,"asset/set-lending-rate":5/3,"asset/cancel-withdrawal":5/3,"asset/convert-dust-assets":10,"trade/order":1/3,"trade/batch-orders":1/15,"trade/cancel-order":1/3,"trade/cancel-batch-orders":1/15,"trade/amend-order":1/3,"trade/amend-batch-orders":1/3,"trade/close-position":1,"trade/order-algo":1,"trade/cancel-algos":1,"trade/cancel-advance-algos":1,"users/subaccount/delete-apikey":10,"users/subaccount/modify-apikey":10,"users/subaccount/apikey":10,"asset/subaccount/transfer":10,"asset/subaccount/set-transfer-out":10,"broker/nd/create-subaccount":10,"broker/nd/delete-subaccount":10,"broker/nd/set-subaccount-level":4,"broker/nd/set-subaccount-fee-rate":4,"asset/broker/nd/subaccount-deposit-address":4,"broker/nd/subaccount/apikey":10,"broker/nd/subaccount/delete-apikey":10,"broker/nd/subaccount/modify-apikey":10,"broker/nd/rebate-per-orders":36e3,"finance/staking-defi/purchase":3,"finance/staking-defi/redeem":3,"finance/staking-defi/cancel":3}}},fees:{trading:{taker:this.parseNumber("0.0015"),maker:this.parseNumber("0.0010")},spot:{taker:this.parseNumber("0.0015"),maker:this.parseNumber("0.0010")},future:{taker:this.parseNumber("0.0005"),maker:this.parseNumber("0.0002")},swap:{taker:this.parseNumber("0.00050"),maker:this.parseNumber("0.00020")}},requiredCredentials:{apiKey:!0,secret:!0,password:!0},exceptions:{exact:{1:ye,2:ye,5e4:gt,50001:W9,50002:gt,50004:z9,50005:Wa,50006:gt,50007:Qr,50008:jt,50009:Qr,50010:ye,50011:oh,50012:ye,50013:Wa,50014:gt,50015:ye,50016:ye,50017:ye,50018:ye,50019:ye,50020:ye,50021:ye,50022:ye,50023:ye,50024:gt,50025:ye,50026:Wa,50027:Y0,50028:ye,50044:gt,50100:ye,50101:jt,50102:$v,50103:jt,50104:jt,50105:jt,50106:jt,50107:jt,50108:ye,50109:ye,50110:Y0,50111:jt,50112:jt,50113:jt,50114:jt,50115:gt,51e3:gt,51001:Ei,51002:Ei,51003:gt,51004:Ce,51005:Ce,51006:Ce,51007:Ce,51008:Hn,51009:Qr,51010:Y9,51011:Ce,51012:Ei,51014:Ei,51015:Ei,51016:Ce,51017:ye,51018:ye,51019:ye,51020:Ce,51021:Ei,51022:Ei,51023:ye,51024:Qr,51025:ye,51026:Ei,51027:Ei,51028:Ei,51029:Ei,51030:Ei,51031:Ce,51100:Ce,51101:Ce,51102:Ce,51103:Ce,51104:Ce,51105:Ce,51106:Ce,51107:Ce,51108:Ce,51109:Ce,51110:Ce,51111:gt,51112:Ce,51113:oh,51115:Ce,51116:Ce,51117:Ce,51118:Ce,51119:Hn,51120:Ce,51121:Ce,51122:Ce,51124:Ce,51125:Ce,51126:Ce,51127:Hn,51128:Ce,51129:Ce,51130:Ei,51131:Hn,51132:Ce,51133:Ce,51134:Ce,51135:Ce,51136:Ce,51137:Ce,51138:Ce,51139:Ce,51201:Ce,51202:Ce,51203:Ce,51204:Ce,51205:Ce,51250:Ce,51251:Ce,51252:Ce,51253:Ce,51254:Ce,51255:Ce,51256:Ce,51257:Ce,51258:Ce,51259:Ce,51260:Ce,51261:Ce,51262:Ce,51263:Ce,51264:Ce,51265:Ce,51267:Ce,51268:Ce,51269:Ce,51270:Ce,51271:Ce,51272:Ce,51273:Ce,51274:Ce,51275:Ce,51276:Ce,51277:Ce,51278:Ce,51279:Ce,51280:Ce,51400:ah,51401:ah,51402:ah,51403:Ce,51404:Ce,51405:ye,51406:ye,51407:gt,51408:ye,51409:ye,51410:X9,51500:ye,51501:ye,51502:Hn,51503:ye,51506:ye,51508:ye,51509:ye,51510:ye,51511:ye,51600:ye,51601:ye,51602:ye,51603:ah,52e3:ye,54e3:ye,54001:ye,58e3:ye,58001:jt,58002:Y0,58003:ye,58004:Qr,58005:ye,58006:ye,58007:ye,58100:ye,58101:Qr,58102:oh,58103:ye,58104:ye,58105:ye,58106:ye,58107:ye,58108:ye,58109:ye,58110:ye,58111:ye,58112:ye,58114:ye,58115:ye,58116:ye,58117:ye,58200:ye,58201:ye,58202:ye,58203:rh,58204:Qr,58205:ye,58206:ye,58207:rh,58208:ye,58209:ye,58210:ye,58211:ye,58212:ye,58213:jt,58221:gt,58222:gt,58224:gt,58300:ye,58350:Hn,59e3:ye,59001:ye,59100:ye,59101:ye,59102:ye,59103:Hn,59104:ye,59105:ye,59106:ye,59107:ye,59108:Hn,59109:ye,59200:Hn,59201:Hn,59300:ye,59301:ye,59401:ye,59500:ye,59501:ye,59502:ye,59503:ye,59504:ye,59505:ye,59506:ye,59507:ye,59508:Qr,60001:jt,60002:jt,60003:jt,60004:jt,60005:jt,60006:$v,60007:jt,60008:jt,60009:jt,60010:jt,60011:jt,60012:gt,60013:gt,60014:oh,60015:K9,60016:Wa,60017:gt,60018:gt,60019:gt,63999:ye,70010:gt,70013:gt,70016:gt},broad:{"Internal Server Error":Wa,"server error":Wa}},httpExceptions:{429:Wa},precisionMode:Q9,options:{defaultNetwork:"ERC20",networks:{ETH:"ERC20",TRX:"TRC20",OMNI:"Omni",SOLANA:"Solana",POLYGON:"Polygon",OEC:"OEC",ALGO:"ALGO"},fetchOpenInterestHistory:{timeframes:{"5m":"5m","1h":"1H","1d":"1D","5M":"5m","1H":"1H","1D":"1D"}},fetchOHLCV:{timezone:"UTC"},createOrder:"privatePostTradeBatchOrders",createMarketBuyOrderRequiresPrice:!1,fetchMarkets:["spot","future","swap","option"],defaultType:"spot",defaultMarginMode:"cross",fetchLedger:{method:"privateGetAccountBills"},fetchOrder:{method:"privateGetTradeOrder"},fetchOpenOrders:{method:"privateGetTradeOrdersPending"},cancelOrders:{method:"privatePostTradeCancelBatchOrders"},fetchCanceledOrders:{method:"privateGetTradeOrdersHistory"},fetchClosedOrders:{method:"privateGetTradeOrdersHistory"},algoOrderTypes:{conditional:!0,trigger:!0,oco:!0,move_order_stop:!0,iceberg:!0,twap:!0},accountsByType:{spot:"1",future:"3",futures:"3",margin:"5",funding:"6",swap:"9",option:"12",trading:"18"},accountsById:{1:"spot",3:"future",5:"margin",6:"funding",9:"swap",12:"option",18:"trading"},exchangeType:{spot:"SPOT",margin:"MARGIN",swap:"SWAP",future:"FUTURES",futures:"FUTURES",option:"OPTION",SPOT:"SPOT",MARGIN:"MARGIN",SWAP:"SWAP",FUTURES:"FUTURES",OPTION:"OPTION"},brokerId:"e847386590ce4dBC"},commonCurrencies:{AE:"AET",BOX:"DefiBox",HOT:"Hydro Protocol",HSR:"HC",MAG:"Maggie",SBTC:"Super Bitcoin",TRADE:"Unitrade",YOYO:"YOYOW",WIN:"WinToken"}})}handleMarketTypeAndParams(e,t=void 0,s={}){const i=this.safeString(s,"instType");return s=this.omit(s,"instType"),this.safeString(s,"type")===void 0&&i!==void 0&&(s.type=i),super.handleMarketTypeAndParams(e,t,s)}convertToInstrumentType(e){const t=this.safeValue(this.options,"exchangeType",{});return this.safeString(t,e,e)}async fetchStatus(e={}){const t=await this.publicGetSystemStatus(e),s=this.safeValue(t,"data",[]),n={updated:void 0,status:s.length===0?"ok":"maintenance",eta:void 0,url:void 0,info:t};for(let r=0;r<s.length;r++){const a=s[r];this.safeString(a,"state")==="ongoing"&&(n.eta=this.safeInteger(a,"end"),n.status="maintenance")}return n}async fetchTime(e={}){const t=await this.publicGetPublicTime(e),s=this.safeValue(t,"data",[]),i=this.safeValue(s,0,{});return this.safeInteger(i,"ts")}async fetchAccounts(e={}){const t=await this.privateGetAccountConfig(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"uid"),o=this.safeString(r,"acctLv");i.push({id:a,type:o,currency:void 0,info:r})}return i}async fetchMarkets(e={}){const t=this.safeValue(this.options,"fetchMarkets");let s=[],i=[];for(let n=0;n<t.length;n++)s.push(this.fetchMarketsByType(t[n],e));s=await Promise.all(s);for(let n=0;n<s.length;n++)i=this.arrayConcat(i,s[n]);return i}parseMarkets(e){const t=[];for(let s=0;s<e.length;s++)t.push(this.parseMarket(e[s]));return t}parseMarket(e){const t=this.safeString(e,"instId");let s=this.safeStringLower(e,"instType");s==="futures"&&(s="future");const i=s==="spot",n=s==="future",r=s==="swap",a=s==="option",o=r||n||a;let d=this.safeString(e,"baseCcy"),c=this.safeString(e,"quoteCcy");const u=this.safeString(e,"settleCcy"),h=this.safeCurrencyCode(u),l=this.safeString(e,"uly");if(l!==void 0&&!i){const M=l.split("-");d=this.safeString(M,0),c=this.safeString(M,1)}const p=this.safeCurrencyCode(d),m=this.safeCurrencyCode(c);let g=p+"/"+m,y,b,w;if(o){if(g=g+":"+h,y=this.safeInteger(e,"expTime"),n){const M=this.yymmdd(y);g=g+"-"+M}else if(a){b=this.safeString(e,"stk"),w=this.safeString(e,"optType");const M=this.yymmdd(y);g=g+"-"+M+"-"+b+"-"+w,w=w==="P"?"put":"call"}}const S=this.safeString(e,"tickSz"),k=this.safeString(e,"minSz"),T=this.parseNumber(k),I=this.safeValue2(this.fees,s,"trading",{}),_=this.parseNumber(S);let N=this.safeString(e,"lever","1");return N=ns.stringMax(N,"1"),this.extend(I,{id:t,symbol:g,base:p,quote:m,settle:h,baseId:d,quoteId:c,settleId:u,type:s,spot:i,margin:i&&ns.stringGt(N,"1"),swap:r,future:n,option:a,active:!0,contract:o,linear:o?c===u:void 0,inverse:o?d===u:void 0,contractSize:o?this.safeNumber(e,"ctVal"):void 0,expiry:y,expiryDatetime:this.iso8601(y),strike:b,optionType:w,precision:{amount:this.safeNumber(e,"lotSz"),price:_},limits:{leverage:{min:this.parseNumber("1"),max:this.parseNumber(N)},amount:{min:T,max:void 0},price:{min:_,max:void 0},cost:{min:void 0,max:void 0}},info:e})}async fetchMarketsByType(e,t={}){const s={instType:this.convertToInstrumentType(e)};if(e==="option"){const r=this.safeValue(this.options,"defaultUnderlying","BTC-USD"),a=this.safeString2(t,"uly","marketId",r);if(a===void 0)throw new Ni(this.id+" fetchMarketsByType() requires an underlying uly or marketId parameter for options markets");s.uly=a}const i=await this.publicGetPublicInstruments(this.extend(s,t)),n=this.safeValue(i,"data",[]);return this.parseMarkets(n)}safeNetwork(e){const t={Bitcoin:"BTC",Omni:"OMNI",TRON:"TRC20"};return this.safeString(t,e,e)}async fetchCurrencies(e={}){if(!this.checkRequiredCredentials(!1))return;const t=await this.privateGetAssetCurrencies(e),s=this.safeValue(t,"data",[]),i={},n=this.groupBy(s,"ccy"),r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],c=this.safeCurrency(o).code,u=n[o],h={};let l=!1,p,m,g;for(let b=0;b<u.length;b++){const w=u[b],S=this.safeValue(w,"canDep"),k=this.safeValue(w,"canWd"),T=this.safeValue(w,"canInternal"),I=!!(S&&k&&T);l=l===void 0?I:l;const _=this.safeString(w,"chain");if(S&&!p?p=!0:S||(p=!1),k&&!m?m=!0:k||(m=!1),_!==void 0&&_.indexOf("-")>=0){const N=_.split("-"),M=this.safeString(N,1,_),x=this.safeNetwork(M),v=this.parsePrecision(this.safeString(w,"wdTickSz"));g===void 0?g=v:g=ns.stringMin(g,v),h[x]={id:_,network:x,active:I,deposit:S,withdraw:k,fee:this.safeNumber(w,"minFee"),precision:this.parseNumber(v),limits:{withdraw:{min:this.safeNumber(w,"minWd"),max:this.safeNumber(w,"maxWd")}},info:w}}}const y=this.safeValue(u,0);i[c]={info:void 0,code:c,id:o,name:this.safeString(y,"name"),active:l,deposit:p,withdraw:m,fee:void 0,precision:this.parseNumber(g),limits:{amount:{min:void 0,max:void 0}},networks:h}}return i}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={instId:this.market(e).id};t=t===void 0?20:t,t!==void 0&&(n.sz=t);const r=await this.publicGetMarketBooks(this.extend(n,s)),a=this.safeValue(r,"data",[]),o=this.safeValue(a,0,{}),d=this.safeInteger(o,"ts");return this.parseOrderBook(o,e,d)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"ts"),i=this.safeString(e,"instId");t=this.safeMarket(i,t,"-");const n=t.symbol,r=this.safeString(e,"last"),a=this.safeString(e,"open24h"),d=this.safeValue(t,"spot",!1)?this.safeString(e,"volCcy24h"):void 0,c=this.safeString(e,"vol24h"),u=this.safeString(e,"high24h"),h=this.safeString(e,"low24h");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:u,low:h,bid:this.safeString(e,"bidPx"),bidVolume:this.safeString(e,"bidSz"),ask:this.safeString(e,"askPx"),askVolume:this.safeString(e,"askSz"),vwap:void 0,open:a,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:c,quoteVolume:d,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={instId:s.id},n=await this.publicGetMarketTicker(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0,{});return this.parseTicker(a,s)}async fetchTickersByType(e,t=void 0,s={}){await this.loadMarkets();const i={instType:this.convertToInstrumentType(e)};if(e==="option"){const a=this.safeValue(this.options,"defaultUnderlying","BTC-USD"),o=this.safeString2(s,"uly","marketId",a);if(o===void 0)throw new Ni(this.id+" fetchTickersByType() requires an underlying uly or marketId parameter for options markets");i.uly=o}const n=await this.publicGetMarketTickers(this.extend(i,s)),r=this.safeValue(n,"data",[]);return this.parseTickers(r,t)}async fetchTickers(e=void 0,t={}){e=this.marketSymbols(e);const s=this.safeString(e,0);let i;s!==void 0&&(i=this.market(s));const[n,r]=this.handleMarketTypeAndParams("fetchTickers",i,t);return await this.fetchTickersByType(n,e,r)}parseTrade(e,t=void 0){const s=this.safeString(e,"tradeId"),i=this.safeString(e,"instId");t=this.safeMarket(i,t,"-");const n=t.symbol,r=this.safeInteger(e,"ts"),a=this.safeString2(e,"fillPx","px"),o=this.safeString2(e,"fillSz","sz"),d=this.safeString(e,"side"),c=this.safeString(e,"ordId"),u=this.safeString(e,"fee");let h;if(u!==void 0){const p=ns.stringNeg(u),m=this.safeString(e,"feeCcy"),g=this.safeCurrencyCode(m);h={cost:p,currency:g}}let l=this.safeString(e,"execType");return l==="T"?l="taker":l==="M"&&(l="maker"),this.safeTrade({info:e,timestamp:r,datetime:this.iso8601(r),symbol:n,id:s,order:c,type:void 0,takerOrMaker:l,side:d,price:a,amount:o,cost:void 0,fee:h},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={instId:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetMarketTrades(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.safeString(n,"price");n=this.omit(n,"price");const o=this.safeValue(this.options,"fetchOHLCV",{}),d=this.safeString(o,"timezone","UTC");i===void 0&&(i=100);const c=this.parseTimeframe(t);let u=this.timeframes[t];d==="UTC"&&c>=21600&&(u+=d.toLowerCase());const h={instId:r.id,bar:u,limit:i};let l="Candles";if(s!==void 0){this.milliseconds()-s>i*c*1e3&&(l="HistoryCandles");const k=c*1e3,T=Math.max(s-1,0);h.before=T,h.after=this.sum(T,k*i)}const p=this.safeInteger(n,"until");p!==void 0&&(h.after=p,n=this.omit(n,"until")),l=this.safeString(o,"type",l);const m=this.safeString(n,"type",l);n=this.omit(n,"type");let g="publicGetMarket"+m;a==="mark"?g="publicGetMarketMarkPriceCandles":a==="index"&&(g="publicGetMarketIndexCandles");const y=await this[g](this.extend(h,n)),b=this.safeValue(y,"data",[]);return this.parseOHLCVs(b,r,t,s,i)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Ni(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={instId:n.id};t!==void 0&&(r.before=Math.max(t-1,0)),s!==void 0&&(r.limit=s);const a=await this.publicGetPublicFundingRateHistory(this.extend(r,i)),o=[],d=this.safeValue(a,"data",[]);for(let u=0;u<d.length;u++){const h=d[u],l=this.safeNumber(h,"fundingTime");o.push({info:h,symbol:this.safeSymbol(this.safeString(h,"instId")),fundingRate:this.safeNumber(h,"realizedRate"),timestamp:l,datetime:this.iso8601(l)})}const c=this.sortBy(o,"timestamp");return this.filterBySymbolSinceLimit(c,n.symbol,t,s)}parseBalanceByType(e,t){return e==="funding"?this.parseFundingBalance(t):this.parseTradingBalance(t)}parseTradingBalance(e){const t={info:e},s=this.safeValue(e,"data",[]),i=this.safeValue(s,0,{}),n=this.safeInteger(i,"uTime"),r=this.safeValue(i,"details",[]);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeString(o,"ccy"),c=this.safeCurrencyCode(d),u=this.account(),h=this.safeString(o,"eq"),l=this.safeString(o,"availEq");h===void 0||l===void 0?(u.free=this.safeString(o,"availBal"),u.used=this.safeString(o,"frozenBal")):(u.total=h,u.free=l),t[c]=u}return t.timestamp=n,t.datetime=this.iso8601(n),this.safeBalance(t)}parseFundingBalance(e){const t={info:e},s=this.safeValue(e,"data",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeString(n,"ccy"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(n,"bal"),o.free=this.safeString(n,"availBal"),o.used=this.safeString(n,"frozenBal"),t[a]=o}return this.safeBalance(t)}parseTradingFee(e,t=void 0){return{info:e,symbol:this.safeSymbol(void 0,t),maker:this.parseNumber(ns.stringNeg(this.safeString2(e,"maker","makerU"))),taker:this.parseNumber(ns.stringNeg(this.safeString2(e,"taker","takerU")))}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={instType:this.convertToInstrumentType(s.type)};if(s.spot)i.instId=s.id;else if(s.swap||s.future||s.option)i.uly=s.baseId+"-"+s.quoteId;else throw new jv(this.id+" fetchTradingFee() supports spot, swap, future or option markets only");const n=await this.privateGetAccountTradeFee(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0,{});return this.parseTradingFee(a,s)}async fetchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("fetchBalance",void 0,e);let i;t==="funding"?i="privateGetAssetBalances":i="privateGetAccountBalance";const n={},r=await this[i](this.extend(n,s));return this.parseBalanceByType(t,r)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={instId:a.id,side:s,ordType:t,sz:this.amountToPrecision(e,i)},d=a.spot,c=a.contract,u=this.safeValueN(r,["triggerPrice","stopPrice","triggerPx"]),h=this.safeString(r,"timeInForce","GTC"),l=this.safeValue2(r,"takeProfitPrice","tpTriggerPx"),p=this.safeValue(r,"tpOrdPx",n),m=this.safeString(r,"tpTriggerPxType","last"),g=this.safeValue2(r,"stopLossPrice","slTriggerPx"),y=this.safeValue(r,"slOrdPx",n),b=this.safeString(r,"slTriggerPxType","last"),w=this.safeString2(r,"clOrdId","clientOrderId"),S=this.safeString2(this.options,"defaultMarginMode","marginMode","cross");let k=this.safeString2(r,"marginMode","tdMode"),T=!1;if(k!==void 0&&k!=="cash"?T=!0:(k=S,T=this.safeValue(r,"margin",!1)),d){if(T){const Q=s==="buy"?a.quote:a.base,Se=this.safeString(r,"ccy",Q);o.ccy=this.safeCurrencyCode(Se)}const X=T?k:"cash";o.tdMode=X}else c&&(o.tdMode=k);const I=t==="market",_=this.isPostOnly(I,t==="post_only",r);r=this.omit(r,["currency","ccy","marginMode","timeInForce","stopPrice","triggerPrice","clientOrderId","stopLossPrice","takeProfitPrice","slOrdPx","tpOrdPx","margin"]);const N=h==="IOC"||t==="ioc",M=h==="FOK"||t==="fok",x=u!==void 0||t==="trigger",v=g!==void 0||l!==void 0||t==="conditional",O=I&&N||t==="optimal_limit_ioc",A=this.safeString(this.options,"createOrder","privatePostTradeBatchOrders"),V=this.safeString(this.options,"tgtCcy","base_ccy"),q=this.safeString(r,"tgtCcy",V);!c&&!T&&(o.tgtCcy=q);let R=A;if(I||O){if(o.ordType="market",d&&s==="buy"&&q==="quote_ccy"){let X=this.safeNumber2(r,"cost","sz");if(this.safeValue(this.options,"createMarketBuyOrderRequiresPrice",!0)){if(n!==void 0){if(X===void 0){const Se=this.numberToString(i),he=this.numberToString(n),xe=ns.stringMul(Se,he);X=this.parseNumber(xe)}}else if(X===void 0)throw new Ce(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total cost value in the 'amount' argument or in the 'cost' unified extra parameter or in exchange-specific 'sz' extra parameter (the exchange-specific behaviour)")}else X=X===void 0?i:X;o.sz=this.costToPrecision(e,X),r=this.omit(r,["cost","sz"])}O&&c&&(o.ordType="optimal_limit_ioc")}else!x&&!v&&(o.px=this.priceToPrecision(e,n));if(_?(R=A,o.ordType="post_only"):N&&!O?(R=A,o.ordType="ioc"):M?(R=A,o.ordType="fok"):x?(R="privatePostTradeOrderAlgo",o.ordType="trigger",o.triggerPx=this.priceToPrecision(e,u),o.orderPx=I?"-1":this.priceToPrecision(e,n)):v&&(R="privatePostTradeOrderAlgo",o.ordType="conditional",l!==void 0&&g!==void 0&&(o.ordType="oco"),l!==void 0&&(o.tpTriggerPx=this.priceToPrecision(e,l),o.tpOrdPx=p===void 0?"-1":this.priceToPrecision(e,p),o.tpTriggerPxType=m),g!==void 0&&(o.slTriggerPx=this.priceToPrecision(e,g),o.slOrdPx=y===void 0?"-1":this.priceToPrecision(e,y),o.slTriggerPxType=b)),(t==="oco"||t==="move_order_stop"||t==="iceberg"||t==="twap")&&(R="privatePostTradeOrderAlgo"),w===void 0){const X=this.safeString(this.options,"brokerId");X!==void 0&&(o.clOrdId=X+this.uuid16(),o.tag=X)}else o.clOrdId=w,r=this.omit(r,["clOrdId","clientOrderId"]);let H;if(R==="privatePostTradeOrder"||R==="privatePostTradeOrderAlgo")H=this.extend(o,r);else if(R==="privatePostTradeBatchOrders")H=[this.extend(o,r)];else throw new ye(this.id+' createOrder() this.options["createOrder"] must be either privatePostTradeBatchOrders or privatePostTradeOrder');const F=await this[R](H),P=this.safeValue(F,"data",[]),E=this.safeValue(P,0),j=this.parseOrder(E,a);return this.extend(j,{type:t,side:s})}async cancelOrder(e,t=void 0,s={}){if(this.safeValue(s,"stop")){const h=await this.cancelOrders([e],t,s);return this.safeValue(h,0)}if(t===void 0)throw new Ni(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const n=this.market(t),r={instId:n.id},a=this.safeString2(s,"clOrdId","clientOrderId");a!==void 0?r.clOrdId=a:r.ordId=e;const o=this.omit(s,["clOrdId","clientOrderId"]),d=await this.privatePostTradeCancelOrder(this.extend(r,o)),c=this.safeValue(d,"data",[]),u=this.safeValue(c,0);return this.parseOrder(u,n)}parseIds(e){return typeof e=="string"?e.split(","):e}async cancelOrders(e,t=void 0,s={}){if(t===void 0)throw new Ni(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=[],r=this.safeValue(this.options,"cancelOrders",{}),a=this.safeString(r,"method","privatePostTradeCancelBatchOrders");let o=this.safeString(s,"method",a);const d=this.parseIds(this.safeValue2(s,"clOrdId","clientOrderId")),c=this.parseIds(this.safeValue(s,"algoId")),u=this.safeValue(s,"stop");if(u&&(o="privatePostTradeCancelAlgos"),d===void 0){if(e=this.parseIds(e),c!==void 0)for(let p=0;p<c.length;p++)n.push({algoId:c[p],instId:i.id});for(let p=0;p<e.length;p++)u?n.push({algoId:e[p],instId:i.id}):n.push({ordId:e[p],instId:i.id})}else for(let p=0;p<d.length;p++)n.push({instId:i.id,clOrdId:d[p]});const h=await this[o](n),l=this.safeValue(h,"data",[]);return this.parseOrders(l,i,void 0,void 0,s)}parseOrderStatus(e){const t={canceled:"canceled",live:"open",partially_filled:"open",filled:"closed",effective:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString2(e,"algoId","ordId"),i=this.safeInteger(e,"cTime"),n=this.safeInteger(e,"fillTime"),r=this.safeString(e,"side");let a=this.safeString(e,"ordType"),o,d;a==="post_only"?(o=!0,a="limit"):a==="fok"?(d="FOK",a="limit"):a==="ioc"&&(d="IOC",a="limit");const c=this.safeString(e,"instId"),u=this.safeSymbol(c,t,"-"),h=this.safeString(e,"accFillSz"),l=this.safeString2(e,"px","ordPx"),p=this.safeString(e,"avgPx"),m=this.parseOrderStatus(this.safeString(e,"state")),g=this.safeString(e,"fee");let y,b;const w=this.safeString(this.options,"tgtCcy","base_ccy"),S=this.safeString(e,"tgtCcy",w),k=this.safeString(e,"instType");r==="buy"&&a==="market"&&k==="SPOT"&&S==="quote_ccy"?b=this.safeString(e,"sz"):y=this.safeString(e,"sz");let T;if(g!==void 0){const M=ns.stringNeg(g),x=this.safeString(e,"feeCcy"),v=this.safeCurrencyCode(x);T={cost:this.parseNumber(M),currency:v}}let I=this.safeString(e,"clOrdId");I!==void 0&&I.length<1&&(I=void 0);const _=this.safeNumberN(e,["tpTriggerPx","triggerPx","slTriggerPx"]);let N=this.safeString(e,"reduceOnly");return N!==void 0&&(N=N==="true"),this.safeOrder({info:e,id:s,clientOrderId:I,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:n,symbol:u,type:a,timeInForce:d,postOnly:o,side:r,price:l,stopPrice:_,average:p,cost:b,amount:y,filled:h,remaining:void 0,status:m,fee:T,trades:void 0,reduceOnly:N},t)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Ni(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={instId:i.id},r=this.safeString2(s,"clOrdId","clientOrderId"),a=this.safeValue(this.options,"fetchOrder",{}),o=this.safeString(a,"method","privateGetTradeOrder"),d=this.safeString(s,"method",o);if(this.safeValue(s,"stop"))throw new jv(this.id+" fetchOrder() does not support stop orders, use fetchOpenOrders() fetchCanceledOrders() or fetchClosedOrders()");r!==void 0?n.clOrdId=r:n.ordId=e;const u=this.omit(s,["method","clOrdId","clientOrderId"]),h=await this[d](this.extend(n,u)),l=this.safeValue(h,"data",[]),p=this.safeValue(l,0);return this.parseOrder(p,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.instId=r.id),s!==void 0&&(n.limit=s);const a=this.safeValue(this.options,"fetchOpenOrders",{}),o=this.safeValue(this.options,"algoOrderTypes",{}),d=this.safeString(a,"method","privateGetTradeOrdersPending");let c=this.safeString(i,"method",d);const u=this.safeString(i,"ordType"),h=this.safeValue(i,"stop");if((h||u in o)&&(c="privateGetTradeOrdersAlgoPending",h&&u===void 0))throw new Ni(this.id+' fetchOpenOrders() requires an "ordType" string parameter, "conditional", "oco", "trigger", "move_order_stop", "iceberg", or "twap"');const l=this.omit(i,["method","stop"]),p=await this[c](this.extend(n,l)),m=this.safeValue(p,"data",[]);return this.parseOrders(m,r,t,s)}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.instId=r.id);let a,o;[a,o]=this.handleMarketTypeAndParams("fetchCanceledOrders",r,i),n.instType=this.convertToInstrumentType(a),s!==void 0&&(n.limit=s),n.state="canceled";const d=this.safeValue(this.options,"fetchCanceledOrders",{}),c=this.safeValue(this.options,"algoOrderTypes",{}),u=this.safeString(d,"method","privateGetTradeOrdersHistory");let h=this.safeString(i,"method",u);const l=this.safeString(i,"ordType"),p=this.safeValue(i,"stop");if(p||l in c){h="privateGetTradeOrdersAlgoHistory";const b=this.safeString(i,"algoId");if(b!==void 0&&(n.algoId=b,i=this.omit(i,"algoId")),p){if(l===void 0)throw new Ni(this.id+' fetchCanceledOrders() requires an "ordType" string parameter, "conditional", "oco", "trigger", "move_order_stop", "iceberg", or "twap"');n.ordType=l}}else{t!==void 0&&(n.begin=t);const b=this.safeInteger2(o,"till","until");b!==void 0&&(n.end=b,o=this.omit(o,["until","till"]))}const m=this.omit(o,["method","stop","ordType"]),g=await this[h](this.extend(n,m)),y=this.safeValue(g,"data",[]);return this.parseOrders(y,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.instId=r.id);let a,o;[a,o]=this.handleMarketTypeAndParams("fetchClosedOrders",r,i),n.instType=this.convertToInstrumentType(a),s!==void 0&&(n.limit=s);const d=this.safeValue(this.options,"fetchClosedOrders",{}),c=this.safeValue(this.options,"algoOrderTypes",{}),u=this.safeString(d,"method","privateGetTradeOrdersHistory");let h=this.safeString(i,"method",u);const l=this.safeString(i,"ordType"),p=this.safeValue(i,"stop");if(p||l in c){if(h="privateGetTradeOrdersAlgoHistory",p&&l===void 0)throw new Ni(this.id+' fetchClosedOrders() requires an "ordType" string parameter, "conditional", "oco", "trigger", "move_order_stop", "iceberg", or "twap"');n.state="effective"}else{t!==void 0&&(n.begin=t);const b=this.safeInteger2(o,"till","until");b!==void 0&&(n.end=b,o=this.omit(o,["until","till"])),n.state="filled"}const m=this.omit(o,["method","stop"]),g=await this[h](this.extend(n,m)),y=this.safeValue(g,"data",[]);return this.parseOrders(y,r,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.instId=r.id);const[a,o]=this.handleMarketTypeAndParams("fetchMyTrades",r,i);n.instType=this.convertToInstrumentType(a),s!==void 0&&(n.limit=s);const d=await this.privateGetTradeFillsHistory(this.extend(n,o)),c=this.safeValue(d,"data",[]);return this.parseTrades(c,r,t,s,o)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){const r={ordId:e};return await this.fetchMyTrades(t,s,i,this.extend(r,n))}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeValue(this.options,"fetchLedger",{});let r=this.safeString(n,"method");r=this.safeString(i,"method",r),i=this.omit(i,"method");const a={};let o;[o,i]=this.handleMarginModeAndParams("fetchLedger",i),o===void 0&&(o=this.safeString(i,"mgnMode")),r!=="privateGetAssetBills"&&o!==void 0&&(a.mgnMode=o);const[d,c]=this.handleMarketTypeAndParams("fetchLedger",void 0,i);d!==void 0&&(a.instType=this.convertToInstrumentType(d)),s!==void 0&&(a.limit=s);let u;e!==void 0&&(u=this.currency(e),a.ccy=u.id);const h=await this[r](this.extend(a,c)),l=this.safeValue(h,"data",[]);return this.parseLedger(l,u,t,s)}parseLedgerEntryType(e){const t={1:"transfer",2:"trade",3:"trade",4:"rebate",5:"trade",6:"transfer",7:"trade",8:"fee",9:"trade",10:"trade",11:"trade"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"billId"),i=void 0,n=this.safeString(e,"ordId"),r=void 0,a=this.parseLedgerEntryType(this.safeString(e,"type")),o=this.safeCurrencyCode(this.safeString(e,"ccy"),t),d=this.safeString(e,"balChg"),c=this.parseNumber(d),u=this.safeInteger(e,"ts"),h=this.safeString(e,"fee");let l;h!==void 0&&(l={cost:this.parseNumber(ns.stringNeg(h)),currency:o});const p=void 0,m=this.safeString(e,"bal"),g=this.parseNumber(m),y="ok",b=this.safeString(e,"instId"),w=this.safeSymbol(b,void 0,"-");return{id:s,info:e,timestamp:u,datetime:this.iso8601(u),account:i,referenceId:n,referenceAccount:r,type:a,currency:o,symbol:w,amount:c,before:p,after:g,status:y,fee:l}}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"addr");let i=this.safeString2(e,"tag","pmtId");i=this.safeString(e,"memo",i);const n=this.safeString(e,"ccy");t=this.safeCurrency(n,t);const r=t.code,a=this.safeString(e,"chain"),o=this.safeValue(t,"networks",{}),d=this.indexBy(o,"id");let c=this.safeValue(d,a);a==="USDT-Polygon"&&(c=this.safeValue(d,"USDT-Polygon-Bridge"));const u=this.safeString(c,"network");return this.checkAddress(s),{currency:r,address:s,tag:i,network:u,info:e}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const i={ccy:this.currency(e).id},n=await this.privateGetAssetDepositAddress(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.filterBy(r,"selected",!0),o=this.parseDepositAddresses(a,[e],!1);return this.indexBy(o,"network")}async fetchDepositAddress(e,t={}){const s=this.safeStringUpper(t,"network"),i=this.safeValue(this.options,"networks",{}),n=this.safeString(i,s,s);t=this.omit(t,"network");const r=await this.fetchDepositAddressesByNetwork(e,t);let a;if(n===void 0){if(a=this.safeValue(r,e),a===void 0){const o=this.safeString(i,e,e);if(a=this.safeValue(r,o),a===void 0){const d=this.safeString(this.options,"defaultNetwork","ERC20");if(a=this.safeValue(r,d),a===void 0){const c=Object.values(r);if(a=this.safeValue(c,0),a===void 0)throw new rh(this.id+" fetchDepositAddress() cannot find deposit address for "+e)}}}return a}if(a=this.safeValue(r,n),a===void 0)throw new rh(this.id+" fetchDepositAddress() cannot find "+n+" deposit address for "+e);return a}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e);i!==void 0&&(s=s+":"+i);const a=this.safeString(n,"fee");if(a===void 0)throw new Ni(this.id+" withdraw() requires a 'fee' string parameter, network transaction fee must be \u2265 0. Withdrawals to OKCoin or OKX are fee-free, please set '0'. Withdrawing to external digital asset address requires network transaction fee.");const o={ccy:r.id,toAddr:s,dest:"4",amt:this.numberToString(t),fee:this.numberToString(a)};"password"in n?o.pwd=n.password:"pwd"in n&&(o.pwd=n.pwd);const d=this.safeValue(this.options,"networks",{});let c=this.safeStringUpper(n,"network");c=this.safeString(d,c,c),c!==void 0&&(o.chain=r.id+"-"+c,n=this.omit(n,"network"));const u=this.omit(n,["fee","password","pwd"]);if(!("pwd"in o))throw new ye(this.id+" withdraw() requires a password parameter or a pwd parameter, it must be the funding password, not the API passphrase");const h=await this.privatePostAssetWithdrawal(this.extend(o,u)),l=this.safeValue(h,"data",[]),p=this.safeValue(l,0);return this.parseTransaction(p,r)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.ccy=r.id),t!==void 0&&(n.before=Math.max(t-1,0)),s!==void 0&&(n.limit=s);const a=await this.privateGetAssetDepositHistory(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,r,t,s,i)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const i={depId:e};let n;t!==void 0&&(n=this.currency(t),i.ccy=n.id);const r=await this.privateGetAssetDepositHistory(this.extend(i,s)),a=this.safeValue(r,"data"),o=this.safeValue(a,0,{});return this.parseTransaction(o,n)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.ccy=r.id),t!==void 0&&(n.before=Math.max(t-1,0)),s!==void 0&&(n.limit=s);const a=await this.privateGetAssetWithdrawalHistory(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,r,t,s,i)}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const i={wdId:e};let n;t!==void 0&&(n=this.currency(t),i.ccy=n.id);const r=await this.privateGetAssetWithdrawalHistory(this.extend(i,s)),a=this.safeValue(r,"data"),o=this.safeValue(a,0,{});return this.parseTransaction(o)}parseTransactionStatus(e){const t={"-3":"pending","-2":"canceled","-1":"failed",0:"pending",1:"pending",2:"ok",3:"pending",4:"pending",5:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){let s,i;const n=this.safeString(e,"wdId"),r=this.safeString(e,"from"),a=this.safeString(e,"to"),o=a;let d=this.safeString2(e,"tag","memo");d=this.safeString2(e,"pmtId",d),n!==void 0?(s="withdrawal",i=n):(i=this.safeString(e,"depId"),s="deposit");const c=this.safeString(e,"ccy"),u=this.safeCurrencyCode(c),h=this.safeNumber(e,"amt"),l=this.parseTransactionStatus(this.safeString(e,"state")),p=this.safeString(e,"txId"),m=this.safeInteger(e,"ts");let g;return s==="deposit"?g=0:g=this.safeNumber(e,"fee"),{info:e,id:i,currency:u,amount:h,network:void 0,addressFrom:r,addressTo:a,address:o,tagFrom:void 0,tagTo:d,tag:d,status:l,type:s,updated:void 0,txid:p,timestamp:m,datetime:this.iso8601(m),fee:{currency:u,cost:g}}}async fetchLeverage(e,t={}){await this.loadMarkets();let s;if([s,t]=this.handleMarginModeAndParams("fetchLeverage",t),s===void 0&&(s=this.safeString(t,"mgnMode","cross")),s!=="cross"&&s!=="isolated")throw new gt(this.id+" fetchLeverage() requires a marginMode parameter that must be either cross or isolated");const n={instId:this.market(e).id,mgnMode:s};return await this.privateGetAccountLeverageInfo(this.extend(n,t))}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e),[i,n]=this.handleMarketTypeAndParams("fetchPosition",s,t);s.id,i!==void 0&&this.convertToInstrumentType(i);const r=await this.privateGetAccountPositions(n),a=this.safeValue(r,"data",[]),o=this.safeValue(a,0);return o===void 0?o:this.parsePosition(o)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s={};if(e!==void 0){const a=[];for(let o=0;o<e.length;o++){const d=e[o],c=this.market(d);a.push(c.id)}a.length>0&&(s.instId=a.join(","))}const i=await this.privateGetAccountPositions(this.extend(s,t)),n=this.safeValue(i,"data",[]),r=[];for(let a=0;a<n.length;a++)r.push(this.parsePosition(n[a]));return this.filterByArray(r,"symbol",e,!1)}parsePosition(e,t=void 0){const s=this.safeString(e,"instId");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeString(e,"pos"),r=ns.stringAbs(n);let a,o=this.safeString(e,"posSide");const d=o!=="net";n!==void 0&&(a=this.parseNumber(r),o==="net"&&(ns.stringGt(n,"0")?o="long":o="short"));const c=this.safeValue(t,"contractSize"),u=this.numberToString(c),h=this.safeString(e,"markPx");let l=this.safeString(e,"notionalUsd");t.inverse&&(l=ns.stringDiv(ns.stringMul(r,u),h));const p=this.parseNumber(l),m=this.safeString(e,"mgnMode");let g;const y=this.safeString(e,"avgPx"),b=this.safeString(e,"upl"),w=this.safeString(e,"lever");let S,k;m==="cross"?(g=this.safeString(e,"imr"),k=ns.stringAdd(g,b)):m==="isolated"&&(S=ns.stringDiv("1",w),k=this.safeString(e,"margin"));const T=this.safeString(e,"mmr"),I=this.parseNumber(T);let _=ns.stringDiv(T,l);S===void 0?S=this.parseNumber(ns.stringDiv(g,l,4)):g===void 0&&(g=ns.stringMul(S,l));const N="0.00005";_=this.parseNumber(ns.stringDiv(ns.stringAdd(_,N),"1",4));const M=this.safeNumber(e,"liqPx"),x=this.safeString(e,"uplRatio"),v=this.parseNumber(ns.stringMul(x,"100")),O=this.safeInteger(e,"uTime"),A=this.parseNumber(ns.stringDiv(T,k,4));return{info:e,id:void 0,symbol:i,notional:p,marginMode:m,liquidationPrice:M,entryPrice:this.parseNumber(y),unrealizedPnl:this.parseNumber(b),percentage:v,contracts:a,contractSize:c,markPrice:this.parseNumber(h),side:o,hedged:d,timestamp:O,datetime:this.iso8601(O),maintenanceMargin:I,maintenanceMarginPercentage:_,collateral:this.parseNumber(k),initialMargin:this.parseNumber(g),initialMarginPercentage:this.parseNumber(S),leverage:this.parseNumber(w),marginRatio:A}}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c={ccy:r.id,amt:this.currencyToPrecision(e,t),type:"0",from:o,to:d};o==="master"?(c.type="1",c.subAcct=d,c.from=this.safeString(n,"from","6"),c.to=this.safeString(n,"to","6")):d==="master"&&(c.type="2",c.subAcct=o,c.from=this.safeString(n,"from","6"),c.to=this.safeString(n,"to","6"));const u=await this.privatePostAssetTransfer(this.extend(c,n)),h=this.safeValue(u,"data",[]),l=this.safeValue(h,0,{});return this.parseTransfer(l,r)}parseTransfer(e,t=void 0){const s=this.safeString(e,"transId"),i=this.safeString(e,"ccy"),n=this.safeCurrencyCode(i,t),r=this.safeNumber(e,"amt"),a=this.safeString(e,"from"),o=this.safeString(e,"to"),d=this.safeValue(this.options,"accountsById",{}),c=this.safeString(d,a),u=this.safeString(d,o),h=this.milliseconds(),l=this.safeString(e,"state");return{info:e,id:s,timestamp:h,datetime:this.iso8601(h),currency:n,amount:r,fromAccount:c,toAccount:u,status:l}}async fetchTransfer(e,t=void 0,s={}){await this.loadMarkets();const i={transId:e},n=await this.privateGetAssetTransferState(this.extend(i,s)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0);return this.parseTransfer(a)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=Array.isArray(i),o="/api/"+this.version+"/"+this.implodeParams(e,i),d=this.omit(i,this.extractParams(e));let c=this.implodeHostname(this.urls.api.rest)+o;if(t==="public")Object.keys(d).length&&(c+="?"+this.urlencode(d));else if(t==="private"){this.checkRequiredCredentials();const u=this.iso8601(this.milliseconds());n={"OK-ACCESS-KEY":this.apiKey,"OK-ACCESS-PASSPHRASE":this.password,"OK-ACCESS-TIMESTAMP":u};let h=u+s+o;if(s==="GET"){if(Object.keys(d).length){const p="?"+this.urlencode(d);c+=p,h+=p}}else(a||Object.keys(d).length)&&(r=this.json(d),h+=r),n["Content-Type"]="application/json";const l=this.hmac(this.encode(h),this.encode(this.secret),"sha256","base64");n["OK-ACCESS-SIGN"]=l}return{url:c,method:s,body:r,headers:n}}parseFundingRate(e,t=void 0){const s=this.safeInteger(e,"nextFundingTime"),i=this.safeString(e,"instId"),n=this.safeSymbol(i,t),r=this.safeNumber(e,"nextFundingRate"),a=this.safeInteger(e,"fundingTime");return{info:e,symbol:n,markPrice:void 0,indexPrice:void 0,interestRate:this.parseNumber("0"),estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeNumber(e,"fundingRate"),fundingTimestamp:a,fundingDatetime:this.iso8601(a),nextFundingRate:r,nextFundingTimestamp:s,nextFundingDatetime:this.iso8601(s),previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new ye(this.id+" fetchFundingRate() is only valid for swap markets");const i={instId:s.id},n=await this.publicGetPublicFundingRate(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0,{});return this.parseFundingRate(a,s)}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={type:"8"};s!==void 0&&(n.limit=s.toString());let r;e!==void 0&&(r=this.market(e),e=r.symbol,r.contract&&(r.linear?(n.ctType="linear",n.ccy=r.quoteId):(n.ctType="inverse",n.ccy=r.baseId)));const[a,o]=this.handleMarketTypeAndParams("fetchFundingHistory",r,i);a==="swap"&&(n.instType=this.convertToInstrumentType(a));const d=await this.privateGetAccountBillsArchive(this.extend(n,o)),c=this.safeValue(d,"data",[]),u=[];for(let l=0;l<c.length;l++){const p=c[l],m=this.safeInteger(p,"ts"),g=this.safeString(p,"instId"),y=this.safeMarket(g),b=this.safeString(p,"ccy"),w=this.safeCurrencyCode(b);u.push({info:p,symbol:y.symbol,code:w,timestamp:m,datetime:this.iso8601(m),id:this.safeString(p,"billId"),amount:this.safeNumber(p,"balChg")})}const h=this.sortBy(u,"timestamp");return this.filterBySymbolSinceLimit(h,e,t,s)}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new Ni(this.id+" setLeverage() requires a symbol argument");if(e<1||e>125)throw new gt(this.id+" setLeverage() leverage should be between 1 and 125");await this.loadMarkets();const i=this.market(t);let n;if([n,s]=this.handleMarginModeAndParams("setLeverage",s),n===void 0&&(n=this.safeString(s,"mgnMode","cross")),n!=="cross"&&n!=="isolated")throw new gt(this.id+" setLeverage() requires a marginMode parameter that must be either cross or isolated");const r={lever:e,mgnMode:n,instId:i.id},a=this.safeString(s,"posSide");if(n==="isolated"){if(a===void 0)throw new Ni(this.id+" setLeverage() requires a posSide argument for isolated margin");if(a!=="long"&&a!=="short")throw new gt(this.id+' setLeverage() requires the posSide argument to be either "long" or "short"')}return await this.privatePostAccountSetLeverage(this.extend(r,s))}async setPositionMode(e,t=void 0,s={}){let i;e?i="long_short_mode":i="net_mode";const n={posMode:i};return await this.privatePostAccountSetPositionMode(this.extend(n,s))}async setMarginMode(e,t=void 0,s={}){if(t===void 0)throw new Ni(this.id+" setMarginMode() requires a symbol argument");if(e=e.toLowerCase(),e!=="cross"&&e!=="isolated")throw new gt(this.id+" setMarginMode() marginMode must be either cross or isolated");await this.loadMarkets();const i=this.market(t),n=this.safeInteger(s,"lever");if(n===void 0||n<1||n>125)throw new gt(this.id+' setMarginMode() params["lever"] should be between 1 and 125');s=this.omit(s,["lever"]);const r={lever:n,mgnMode:e,instId:i.id};return await this.privatePostAccountSetLeverage(this.extend(r,s))}async fetchBorrowRates(e={}){await this.loadMarkets();const t=await this.privateGetAccountInterestRate(e),s=this.milliseconds(),i=this.safeValue(t,"data"),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeCurrencyCode(this.safeString(a,"ccy"));n[o]={currency:o,rate:this.safeNumber(a,"interestRate"),period:864e5,timestamp:s,datetime:this.iso8601(s),info:a}}return n}async fetchBorrowRate(e,t={}){await this.loadMarkets();const i={ccy:this.currency(e).id},n=await this.privateGetAccountInterestRate(this.extend(i,t)),r=this.safeValue(n,"data"),a=this.safeValue(r,0);return this.parseBorrowRate(a)}parseBorrowRate(e,t=void 0){const s=this.safeString(e,"ccy"),i=this.safeInteger(e,"ts");return{currency:this.safeCurrencyCode(s),rate:this.safeNumber2(e,"interestRate","rate"),period:864e5,timestamp:i,datetime:this.iso8601(i),info:e}}parseBorrowRateHistories(e,t,s,i){const n={};for(let a=0;a<e.length;a++){const o=e[a],d=this.safeCurrencyCode(this.safeString(o,"ccy"));if(t===void 0||this.inArray(d,t)){d in n||(n[d]=[]);const c=this.parseBorrowRate(o);n[d].push(c)}}const r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a];n[o]=this.filterByCurrencySinceLimit(n[o],o,s,i)}return n}parseBorrowRateHistory(e,t,s,i){const n=[];for(let a=0;a<e.length;a++){const o=e[a],d=this.parseBorrowRate(o);n.push(d)}const r=this.sortBy(n,"timestamp");return this.filterByCurrencySinceLimit(r,t,s,i)}async fetchBorrowRateHistories(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.before=t),s!==void 0&&(n.limit=s);const r=await this.publicGetAssetLendingRateHistory(this.extend(n,i)),a=this.safeValue(r,"data");return this.parseBorrowRateHistories(a,e,t,s)}async fetchBorrowRateHistory(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={ccy:this.currency(e).id};t!==void 0&&(r.before=t),s!==void 0&&(r.limit=s);const a=await this.publicGetAssetLendingRateHistory(this.extend(r,i)),o=this.safeValue(a,"data");return this.parseBorrowRateHistory(o,e,t,s)}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets();const n=this.market(e),r=this.safeString(i,"posSide","net");i=this.omit(i,["posSide"]);const a={instId:n.id,amt:t,type:s,posSide:r},o=await this.privatePostAccountPositionMarginBalance(this.extend(a,i));return this.parseMarginModification(o,n)}parseMarginModification(e,t=void 0){const s=this.safeValue(e,"data",[]),i=this.safeValue(s,0,{}),r=this.safeString(e,"code")==="0"?"ok":"failed",a=this.safeNumber(i,"amt"),d=this.safeString(i,"type")==="reduce"?"reduce":"add",c=this.safeString(i,"instId"),u=this.safeMarket(c,t),h=u.inverse?u.base:u.quote;return{info:e,type:d,amount:a,code:h,symbol:u.symbol,status:r}}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"reduce",s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"add",s)}async fetchMarketLeverageTiers(e,t={}){await this.loadMarkets();const s=this.market(e),i=s.spot?"MARGIN":this.convertToInstrumentType(s.type),n=this.safeString(s.info,"uly");if(!n&&i!=="MARGIN")throw new gt(this.id+" fetchMarketLeverageTiers() cannot fetch leverage tiers for "+e);let r;[r,t]=this.handleMarginModeAndParams("fetchMarketLeverageTiers",t),r===void 0&&(r=this.safeString(t,"tdMode","cross"));const a={instType:i,tdMode:r,uly:n};i==="MARGIN"&&(a.instId=s.id);const o=await this.publicGetPublicPositionTiers(this.extend(a,t)),d=this.safeValue(o,"data");return this.parseMarketLeverageTiers(d,s)}parseMarketLeverageTiers(e,t=void 0){const s=[];for(let i=0;i<e.length;i++){const n=e[i];s.push({tier:this.safeInteger(n,"tier"),currency:t.quote,minNotional:this.safeNumber(n,"minSz"),maxNotional:this.safeNumber(n,"maxSz"),maintenanceMarginRate:this.safeNumber(n,"mmr"),maxLeverage:this.safeNumber(n,"maxLever"),info:n})}return s}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;[r,n]=this.handleMarginModeAndParams("fetchBorrowInterest",n),r===void 0&&(r=this.safeString(n,"mgnMode","cross"));const a={mgnMode:r};let o;if(e!==void 0){const h=this.currency(e);a.ccy=h.id}s!==void 0&&(a.before=s-1),i!==void 0&&(a.limit=i),t!==void 0&&(o=this.market(t),a.instId=o.id);const d=await this.privateGetAccountInterestAccrued(this.extend(a,n)),c=this.safeValue(d,"data"),u=this.parseBorrowInterests(c);return this.filterByCurrencySinceLimit(u,e,s,i)}parseBorrowInterest(e,t=void 0){const s=this.safeString(e,"instId");s!==void 0&&(t=this.safeMarket(s,t));const i=this.safeInteger(e,"ts");return{symbol:this.safeString(t,"symbol"),marginMode:this.safeString(e,"mgnMode"),currency:this.safeCurrencyCode(this.safeString(e,"ccy")),interest:this.safeNumber(e,"interest"),interestRate:this.safeNumber(e,"interestRate"),amountBorrowed:this.safeNumber(e,"liab"),timestamp:i,datetime:this.iso8601(i),info:e}}async borrowMargin(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.currency(e),r={ccy:n.id,amt:this.currencyToPrecision(e,t),side:"borrow"},a=await this.privatePostAccountBorrowRepay(this.extend(r,i)),o=this.safeValue(a,"data",[]),d=this.safeValue(o,0),c=this.parseMarginLoan(d,n);return this.extend(c,{symbol:s})}async repayMargin(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.currency(e),r={ccy:n.id,amt:this.currencyToPrecision(e,t),side:"repay"},a=await this.privatePostAccountBorrowRepay(this.extend(r,i)),o=this.safeValue(a,"data",[]),d=this.safeValue(o,0),c=this.parseMarginLoan(d,n);return this.extend(c,{symbol:s})}parseMarginLoan(e,t=void 0){const s=this.safeString(e,"ccy");return{id:void 0,currency:this.safeCurrencyCode(s,t),amount:this.safeNumber(e,"amt"),symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}async fetchOpenInterest(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.contract)throw new gt(this.id+" fetchOpenInterest() supports contract markets only");const i=this.convertToInstrumentType(s.type),n=this.safeString(s.info,"uly"),r={instType:i,uly:n,instId:s.id},a=await this.publicGetPublicOpenInterest(this.extend(r,t)),o=this.safeValue(a,"data",[]);return this.parseOpenInterest(o[0],s)}async fetchOpenInterestHistory(e,t="5m",s=void 0,i=void 0,n={}){const r=this.safeValue(this.options,"fetchOpenInterestHistory",{}),a=this.safeValue(r,"timeframes",{});if(t=this.safeString(a,t,t),t!=="5m"&&t!=="1H"&&t!=="1D")throw new gt(this.id+" fetchOpenInterestHistory cannot only use the 5m, 1h, and 1d timeframe");await this.loadMarkets();const d={ccy:this.currency(e).id,period:t};s!==void 0&&(d.begin=s);const c=this.safeInteger2(n,"till","until");c!==void 0&&(d.end=c,n=this.omit(n,["until","till"]));const u=await this.publicGetRubikStatContractsOpenInterestVolume(this.extend(d,n)),h=this.safeValue(u,"data");return this.parseOpenInterests(h,void 0,s,i)}parseOpenInterest(e,t=void 0){const s=this.safeString(e,"instId");t=this.safeMarket(s,t);const i=this.safeInteger(e,"ts"),n=this.safeNumber(e,0,i),r=this.safeNumber(e,"oi"),a=this.safeNumber(e,"oiCcy"),o=this.safeNumber(e,1,a);return{symbol:this.safeSymbol(s),baseVolume:void 0,quoteVolume:o,openInterestAmount:r,openInterestValue:o,timestamp:n,datetime:this.iso8601(n),info:e}}setSandboxMode(e){super.setSandboxMode(e),e?this.headers["x-simulated-trading"]="1":"x-simulated-trading"in this.headers&&(this.headers=this.omit(this.headers,"x-simulated-trading"))}handleErrors(e,t,s,i,n,r,a,o,d){if(!a)return;const c=this.safeString(a,"code");if(c!=="0"){const u=this.id+" "+r,h=this.safeValue(a,"data",[]);for(let l=0;l<h.length;l++){const p=h[l],m=this.safeString(p,"sCode"),g=this.safeString(p,"sMsg");this.throwExactlyMatchedException(this.exceptions.exact,m,u),this.throwBroadlyMatchedException(this.exceptions.broad,g,u)}throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),new ye(u)}}};const Z9=xb;var j_=class extends Z9{describe(){return this.deepExtend(super.describe(),{id:"okex",alias:!0})}};const J9=j_;var eG=class extends J9{describe(){return this.deepExtend(super.describe(),{id:"okex5",alias:!0})}};const tG=me,{ExchangeError:Q0}=oe,{TICK_SIZE:sG}=pe,iG=ke;var nG=class extends tG{describe(){return this.deepExtend(super.describe(),{id:"paymium",name:"Paymium",countries:["FR","EU"],rateLimit:2e3,version:"v1",has:{CORS:!0,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,fetchBalance:!0,fetchDepositAddress:!0,fetchDepositAddresses:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarkOHLCV:!1,fetchOpenInterestHistory:!1,fetchOrderBook:!0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,transfer:!0},urls:{logo:"https://user-images.githubusercontent.com/51840849/87153930-f0f02200-c2c0-11ea-9c0a-40337375ae89.jpg",api:{rest:"https://paymium.com/api"},www:"https://www.paymium.com",fees:"https://www.paymium.com/page/help/fees",doc:["https://github.com/Paymium/api-documentation","https://www.paymium.com/page/developers","https://paymium.github.io/api-documentation/"],referral:"https://www.paymium.com/page/sign-up?referral=eDAzPoRQFMvaAB8sf-qj"},api:{public:{get:["countries","data/{currency}/ticker","data/{currency}/trades","data/{currency}/depth","bitcoin_charts/{id}/trades","bitcoin_charts/{id}/depth"]},private:{get:["user","user/addresses","user/addresses/{address}","user/orders","user/orders/{uuid}","user/price_alerts","merchant/get_payment/{uuid}"],post:["user/addresses","user/orders","user/withdrawals","user/email_transfers","user/payment_requests","user/price_alerts","merchant/create_payment"],delete:["user/orders/{uuid}","user/orders/{uuid}/cancel","user/price_alerts/{id}"]}},markets:{"BTC/EUR":{id:"eur",symbol:"BTC/EUR",base:"BTC",quote:"EUR",baseId:"btc",quoteId:"eur",type:"spot",spot:!0}},fees:{trading:{maker:this.parseNumber("-0.001"),taker:this.parseNumber("0.005")}},precisionMode:sG})}parseBalance(e){const t={info:e},s=Object.keys(this.currencies);for(let i=0;i<s.length;i++){const n=s[i],a=this.currency(n).id,o="balance_"+a;if(o in e){const d=this.account(),c="locked_"+a;d.free=this.safeString(e,o),d.used=this.safeString(e,c),t[n]=d}}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetUser(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={currency:i.id},r=await this.publicGetDataCurrencyDepth(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"bids","asks","price","amount")}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeTimestamp(e,"at"),n=this.safeString(e,"vwap"),r=this.safeString(e,"volume"),a=iG.stringMul(r,n),o=this.safeString(e,"price");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:n,open:this.safeString(e,"open"),close:o,last:o,previousClose:void 0,change:void 0,percentage:this.safeString(e,"variation"),average:void 0,baseVolume:r,quoteVolume:a,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={currency:s.id},n=await this.publicGetDataCurrencyTicker(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t){const s=this.safeTimestamp(e,"created_at_int"),i=this.safeString(e,"uuid");t=this.safeMarket(void 0,t);const n=this.safeString(e,"side"),r=this.safeString(e,"price"),a="traded_"+t.base.toLowerCase(),o=this.safeString(e,a);return this.safeTrade({info:e,id:i,order:void 0,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:void 0,side:n,takerOrMaker:void 0,price:r,amount:o,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={currency:n.id},a=await this.publicGetDataCurrencyTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async createDepositAddress(e,t={}){await this.loadMarkets();const s=await this.privatePostUserAddresses(t);return this.parseDepositAddress(s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s={address:e},i=await this.privateGetUserAddressesAddress(this.extend(s,t));return this.parseDepositAddress(i)}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetUserAddresses(t);return this.parseDepositAddresses(s,e)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"currency");return{info:e,currency:this.safeCurrencyCode(i,t),address:s,tag:void 0,network:void 0}}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={type:this.capitalize(t)+"Order",currency:a.id,direction:s,amount:i};t!=="market"&&(o.price=n);const d=await this.privatePostUserOrders(this.extend(o,r));return{info:d,id:d.uuid}}async cancelOrder(e,t=void 0,s={}){const i={uuid:e};return await this.privateDeleteUserOrdersUuidCancel(this.extend(i,s))}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e);if(i.indexOf("@")<0)throw new Q0(this.id+" transfer() only allows transfers to an email address");if(e!=="BTC"&&e!=="EUR")throw new Q0(this.id+" transfer() only allows BTC or EUR");const a={currency:r.id,amount:this.currencyToPrecision(e,t),email:i},o=await this.privatePostUserEmailTransfers(this.extend(a,n));return this.parseTransfer(o,r)}parseTransfer(e,t=void 0){const s=this.safeString(e,"currency"),i=this.safeString(e,"updated_at"),n=this.parseDate(i),r=this.safeValue(e,"account_operations"),a=this.safeValue(r,0,{}),o=this.safeString(e,"state");return{info:e,id:this.safeString(e,"uuid"),timestamp:n,datetime:this.iso8601(n),currency:this.safeCurrencyCode(s,t),amount:this.safeNumber(e,"amount"),fromAccount:void 0,toAccount:this.safeString(a,"address"),status:this.parseTransferStatus(o)}}parseTransferStatus(e){const t={executed:"ok"};return this.safeString(t,e,e)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials();const d=this.nonce().toString();let c=d+a;if(n={"Api-Key":this.apiKey,"Api-Nonce":d},s==="POST")Object.keys(o).length&&(r=this.json(o),c+=r,n["Content-Type"]="application/json");else if(Object.keys(o).length){const u=this.urlencode(o);c+=u,a+="?"+u}n["Api-Signature"]=this.hmac(this.encode(c),this.encode(this.secret))}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;if(this.safeValue(a,"errors")!==void 0)throw new Q0(this.id+" "+this.json(a))}};const rG=me,{ExchangeError:As,BadSymbol:qc,AuthenticationError:Z0,InsufficientFunds:Gn,InvalidOrder:ve,ArgumentsRequired:Bs,OrderNotFound:dh,BadRequest:Hs,PermissionDenied:ch,AccountSuspended:aG,CancelPending:uh,DDoSProtection:Wv,DuplicateOrderId:J0,RateLimitExceeded:oG}=oe,{TICK_SIZE:dG}=pe,ls=ke;var W_=class extends rG{describe(){return this.deepExtend(super.describe(),{id:"phemex",name:"Phemex",countries:["CN"],rateLimit:100,version:"v1",certified:!1,pro:!0,hostname:"api.phemex.com",has:{CORS:void 0,spot:!0,margin:!1,swap:!0,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistories:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!0,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransfers:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!0,setMargin:!0,setMarginMode:!0,setPositionMode:!1,transfer:!0,withdraw:void 0},urls:{logo:"https://user-images.githubusercontent.com/1294454/85225056-221eb600-b3d7-11ea-930d-564d2690e3f6.jpg",test:{v1:"https://testnet-api.phemex.com/v1",public:"https://testnet-api.phemex.com/exchange/public",private:"https://testnet-api.phemex.com"},api:{v1:"https://{hostname}/v1",public:"https://{hostname}/exchange/public",private:"https://{hostname}"},www:"https://phemex.com",doc:"https://github.com/phemex/phemex-api-docs",fees:"https://phemex.com/fees-conditions",referral:{url:"https://phemex.com/register?referralCode=EDNVJ",discount:.1}},timeframes:{"1m":"60","3m":"180","5m":"300","15m":"900","30m":"1800","1h":"3600","2h":"7200","3h":"10800","4h":"14400","6h":"21600","12h":"43200","1d":"86400","1w":"604800","1M":"2592000"},api:{public:{get:["cfg/v2/products","cfg/fundingRates","products","nomics/trades","md/kline"]},v1:{get:["md/orderbook","md/trade","md/ticker/24hr","md/ticker/24hr/all","md/spot/ticker/24hr","md/spot/ticker/24hr/all","exchange/public/products"]},private:{get:["spot/orders/active","spot/orders","spot/wallets","exchange/spot/order","exchange/spot/order/trades","accounts/accountPositions","accounts/positions","api-data/futures/funding-fees","orders/activeList","exchange/order/list","exchange/order","exchange/order/trade","phemex-user/users/children","phemex-user/wallets/v2/depositAddress","phemex-user/wallets/tradeAccountDetail","phemex-user/order/closedPositionList","exchange/margins/transfer","exchange/wallets/confirm/withdraw","exchange/wallets/withdrawList","exchange/wallets/depositList","exchange/wallets/v2/depositAddress","api-data/spots/funds","assets/convert","assets/transfer","assets/spots/sub-accounts/transfer","assets/futures/sub-accounts/transfer","assets/quote","assets/convert"],post:["spot/orders","orders","positions/assign","exchange/wallets/transferOut","exchange/wallets/transferIn","exchange/margins","exchange/wallets/createWithdraw","exchange/wallets/cancelWithdraw","exchange/wallets/createWithdrawAddress","assets/transfer","assets/spots/sub-accounts/transfer","assets/futures/sub-accounts/transfer","assets/universal-transfer","assets/convert"],put:["spot/orders","orders/replace","positions/leverage","positions/riskLimit"],delete:["spot/orders","spot/orders/all","orders/cancel","orders","orders/all"]}},precisionMode:dG,fees:{trading:{tierBased:!1,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0.001")}},requiredCredentials:{apiKey:!0,secret:!0},exceptions:{exact:{412:Hs,6001:Hs,19999:Hs,10001:J0,10002:dh,10003:uh,10004:uh,10005:uh,11001:Gn,11002:ve,11003:Gn,11004:ve,11005:Gn,11006:As,11007:As,11008:As,11009:As,11010:Gn,11011:ve,11012:ve,11013:ve,11014:ve,11015:ve,11016:Hs,11017:As,11018:As,11019:As,11020:As,11021:As,11022:aG,11023:As,11024:As,11025:Hs,11026:As,11027:qc,11028:qc,11029:As,11030:As,11031:Wv,11032:Wv,11033:J0,11034:ve,11035:ve,11036:ve,11037:ve,11038:ve,11039:ve,11040:ve,11041:ve,11042:ve,11043:ve,11044:ve,11045:ve,11046:ve,11047:ve,11048:ve,11049:ve,11050:ve,11051:ve,11052:ve,11053:ve,11054:ve,11055:ve,11056:ve,11057:ve,11058:ve,11059:ve,11060:ve,11061:uh,11062:ve,11063:ve,11064:ve,11065:ve,11066:ve,11067:ve,11068:ve,11069:As,11070:qc,11071:ve,11072:ve,11073:ve,11074:ve,11075:ve,11076:ve,11077:ve,11078:ve,11079:ve,11080:ve,11081:ve,11082:Gn,11083:ve,11084:ve,11085:J0,11086:ve,11087:ve,11088:ve,11089:ve,11090:ve,11091:ve,11092:ve,11093:ve,11094:ve,11095:ve,11096:ve,11097:Hs,11098:Hs,11099:As,11100:Gn,11101:Gn,11102:Hs,11103:Hs,11104:Hs,11105:Gn,11106:Gn,11107:As,11108:ve,11109:ve,11110:ve,11111:ve,11112:ve,11113:Hs,11114:ve,11115:ve,11116:ve,11117:ve,11118:ve,11119:ve,11120:ve,11121:ve,11122:ve,11123:ve,11124:ve,11125:ve,11126:ve,11128:ve,11129:ve,11130:ve,11131:ve,11132:ve,11133:ve,11134:ve,3e4:Hs,30018:Hs,34003:ch,35104:Gn,39995:oG,39996:ch},broad:{"401 Insufficient privilege":ch,"401 Request IP mismatch":ch,"Failed to find api-key":Z0,"Missing required parameter":Hs,"API Signature verification failed":Z0,"Api key not found":Z0}},options:{brokerId:"ccxt2022","x-phemex-request-expiry":60,createOrderByQuoteRequiresPrice:!0,networks:{TRC20:"TRX",ERC20:"ETH"},defaultNetworks:{USDT:"ETH"},defaultSubType:"linear",accountsByType:{spot:"spot",future:"future"},transfer:{fillResponseFromRequest:!0}}})}parseSafeNumber(e=void 0){if(e===void 0)return e;let t=e.split(",");return e=t.join(""),t=e.split(" "),this.safeNumber(t,0)}parseSwapMarket(e){const t=this.safeString(e,"symbol"),s=this.safeString2(e,"baseCurrency","contractUnderlyingAssets"),i=this.safeString(e,"quoteCurrency"),n=this.safeString(e,"settleCurrency"),r=this.safeCurrencyCode(s),a=this.safeCurrencyCode(i),o=this.safeCurrencyCode(n);let d=!1;n!==i&&(d=!0);const c=this.safeInteger(e,"priceScale"),u=this.safeInteger(e,"ratioScale"),h=this.safeInteger(e,"valueScale"),l=this.safeString(e,"minPriceEp"),p=this.safeString(e,"maxPriceEp"),m=this.safeString(e,"makerFeeRateEr"),g=this.safeString(e,"takerFeeRateEr"),y=this.safeString(e,"status"),b=this.safeString(e,"contractSize"," ");let w;if(b.indexOf(" ")){const S=b.split(" ");w=this.parseNumber(S[0])}else w=this.parseNumber(b);return{id:t,symbol:r+"/"+a+":"+o,base:r,quote:a,settle:o,baseId:s,quoteId:i,settleId:n,type:"swap",spot:!1,margin:!1,swap:!0,future:!1,option:!1,active:y==="Listed",contract:!0,linear:!d,inverse:d,taker:this.parseNumber(this.fromEn(g,u)),maker:this.parseNumber(this.fromEn(m,u)),contractSize:w,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,priceScale:c,valueScale:h,ratioScale:u,precision:{amount:this.safeNumber(e,"lotSize"),price:this.safeNumber(e,"tickSize")},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(e,"maxLeverage")},amount:{min:void 0,max:void 0},price:{min:this.parseNumber(this.fromEn(l,c)),max:this.parseNumber(this.fromEn(p,c))},cost:{min:void 0,max:this.parseNumber(this.safeString(e,"maxOrderQty"))}},info:e}}parseSpotMarket(e){const t=this.safeStringLower(e,"type"),s=this.safeString(e,"symbol"),i=this.safeString(e,"quoteCurrency"),n=this.safeString(e,"baseCurrency"),r=this.safeCurrencyCode(n),a=this.safeCurrencyCode(i),o=this.safeString(e,"status"),d=this.parseSafeNumber(this.safeString(e,"baseTickSize")),c=this.parseSafeNumber(this.safeString(e,"quoteTickSize"));return{id:s,symbol:r+"/"+a,base:r,quote:a,settle:void 0,baseId:n,quoteId:i,settleId:void 0,type:t,spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:o==="Listed",contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(e,"defaultTakerFee"),maker:this.safeNumber(e,"defaultMakerFee"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,priceScale:8,valueScale:8,ratioScale:8,precision:{amount:d,price:c},limits:{leverage:{min:void 0,max:void 0},amount:{min:d,max:this.parseSafeNumber(this.safeString(e,"maxBaseOrderSize"))},price:{min:c,max:void 0},cost:{min:this.parseSafeNumber(this.safeString(e,"minOrderValue")),max:this.parseSafeNumber(this.safeString(e,"maxOrderValue"))}},info:e}}async fetchMarkets(e={}){const t=await this.publicGetCfgV2Products(e),s=await this.v1GetExchangePublicProducts(e),i=this.safeValue(s,"data",[]),n=this.safeValue(t,"data",{}),r=this.safeValue(n,"products",[]),a=this.safeValue(n,"riskLimits",[]),o=this.indexBy(a,"symbol"),d=this.indexBy(i,"symbol"),c=[];for(let u=0;u<r.length;u++){let h=r[u];if(this.safeStringLower(h,"type")==="perpetual"){const p=this.safeString(h,"symbol"),m=this.safeValue(o,p,{});h=this.extend(h,m);const g=this.safeValue(d,p,{});h=this.extend(h,g),h=this.parseSwapMarket(h)}else h=this.parseSpotMarket(h);c.push(h)}return c}async fetchCurrencies(e={}){const t=await this.publicGetCfgV2Products(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"currencies",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"currency"),d=this.safeString(a,"name"),c=this.safeCurrencyCode(o),u=this.safeString(a,"valueScale"),h=parseInt(u),l=this.safeString(a,"minValueEv"),p=this.safeString(a,"maxValueEv");let m,g,y;if(h!==void 0){const b=this.parsePrecision(u);y=this.parseNumber(b),m=this.parseNumber(ls.stringMul(l,b)),g=this.parseNumber(ls.stringMul(p,b))}n[c]={id:o,info:a,code:c,name:d,active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,precision:y,limits:{amount:{min:m,max:g},withdraw:{min:void 0,max:void 0}},valueScale:h}}return n}parseBidAsk(e,t=0,s=1,i=void 0){if(i===void 0)throw new Bs(this.id+" parseBidAsk() requires a market argument");let n=this.safeString(e,s);return i.spot&&(n=this.fromEv(n,i)),[this.parseNumber(this.fromEp(this.safeString(e,t),i)),this.parseNumber(n)]}parseOrderBook(e,t,s=void 0,i="bids",n="asks",r=0,a=1,o=void 0){const d={symbol:t,timestamp:s,datetime:this.iso8601(s),nonce:void 0},c=[i,n];for(let u=0;u<c.length;u++){const h=c[u],l=[],p=this.safeValue(e,h);for(let m=0;m<p.length;m++)l.push(this.parseBidAsk(p[m],r,a,o));d[h]=l}return d[i]=this.sortBy(d[i],0,!0),d[n]=this.sortBy(d[n],0),d}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id},r=await this.v1GetMdOrderbook(this.extend(n,s)),a=this.safeValue(r,"result",{}),o=this.safeValue(a,"book",{}),d=this.safeIntegerProduct(a,"timestamp",1e-6),c=this.parseOrderBook(o,e,d,"bids","asks",0,1,i);return c.nonce=this.safeInteger(a,"sequence"),c}toEn(e,t){const s=e.toString(),i=new ls(s);i.decimals=i.decimals-t,i.reduce();const n=i.toString();return parseInt(parseFloat(n))}toEv(e,t=void 0){return e===void 0||t===void 0?e:this.toEn(e,t.valueScale)}toEp(e,t=void 0){return e===void 0||t===void 0?e:this.toEn(e,t.priceScale)}fromEn(e,t){if(e===void 0)return;const s=new ls(e);return s.decimals=this.sum(s.decimals,t),s.reduce(),s.toString()}fromEp(e,t=void 0){return e===void 0||t===void 0?e:this.fromEn(e,this.safeInteger(t,"priceScale"))}fromEv(e,t=void 0){return e===void 0||t===void 0?e:this.fromEn(e,this.safeInteger(t,"valueScale"))}fromEr(e,t=void 0){return e===void 0||t===void 0?e:this.fromEn(e,this.safeInteger(t,"ratioScale"))}parseOHLCV(e,t=void 0){let s;return t!==void 0&&t.spot?s=this.parseNumber(this.fromEv(this.safeString(e,7),t)):s=this.safeNumber(e,7),[this.safeTimestamp(e,0),this.parseNumber(this.fromEp(this.safeString(e,3),t)),this.parseNumber(this.fromEp(this.safeString(e,4),t)),this.parseNumber(this.fromEp(this.safeString(e,5),t)),this.parseNumber(this.fromEp(this.safeString(e,6),t)),s]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){const r={resolution:this.timeframes[t]},a=this.parseTimeframe(t),o=this.seconds(),d=2e3;i===void 0?i=100:i=Math.min(i,d),s!==void 0?(i=Math.min(i,d),s=parseInt(s/1e3),r.from=s,r.to=Math.min(o,this.sum(s,a*i))):(i<d&&(i=i+1),r.from=o-a*i,r.to=o),await this.loadMarkets();const c=this.market(e);r.symbol=c.id;const u=await this.publicGetMdKline(this.extend(r,n)),h=this.safeValue(u,"data",{}),l=this.safeValue(h,"rows",[]);return this.parseOHLCVs(l,c,t,s,i)}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeIntegerProduct(e,"timestamp",1e-6),r=this.fromEp(this.safeString(e,"lastEp"),t),a=this.fromEv(this.safeString(e,"turnoverEv"),t);let o=this.safeString(e,"volume");o===void 0&&(o=this.fromEv(this.safeString(e,"volumeEv"),t));const d=this.fromEp(this.safeString(e,"openEp"),t);return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.fromEp(this.safeString(e,"highEp"),t),low:this.fromEp(this.safeString(e,"lowEp"),t),bid:this.fromEp(this.safeString(e,"bidEp"),t),bidVolume:void 0,ask:this.fromEp(this.safeString(e,"askEp"),t),askVolume:void 0,vwap:void 0,open:d,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:o,quoteVolume:a,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=s.spot?"v1GetMdSpotTicker24hr":"v1GetMdTicker24hr",r=await this[n](this.extend(i,t)),a=this.safeValue(r,"result",{});return this.parseTicker(a,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.v1GetMdTrade(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"trades",[]);return this.parseTrades(d,n,t,s)}parseTrade(e,t=void 0){let s,i,n,r,a,o,d,c;const u=this.safeString(e,"symbol");t=this.safeMarket(u,t);const h=t.symbol;let l,p;if(Array.isArray(e)){const m=e.length;n=this.safeIntegerProduct(e,0,1e-6),m>4&&(r=this.safeString(e,m-4)),a=this.safeStringLower(e,m-3),s=this.fromEp(this.safeString(e,m-2),t),i=this.fromEv(this.safeString(e,m-1),t)}else{n=this.safeIntegerProduct(e,"transactTimeNs",1e-6),r=this.safeString2(e,"execId","execID"),l=this.safeString(e,"orderID"),a=this.safeStringLower(e,"side"),d=this.parseOrderType(this.safeString(e,"ordType")),this.safeString(e,"execStatus")==="MakerFill"&&(p="maker"),s=this.fromEp(this.safeString(e,"execPriceEp"),t),i=this.fromEv(this.safeString(e,"execBaseQtyEv"),t),i=this.safeString(e,"execQty",i),o=this.fromEv(this.safeString2(e,"execQuoteQtyEv","execValueEv"),t);const g=this.fromEv(this.safeString(e,"execFeeEv"),t);if(g!==void 0){const y=this.fromEr(this.safeString(e,"feeRateEr"),t);let b;if(t.spot)b=a==="buy"?t.base:t.quote;else{const w=this.safeValue(t,"info");if(w!==void 0){const S=this.safeString(w,"settlementCurrency");b=this.safeCurrencyCode(S)}}c={cost:g,rate:y,currency:b}}}return this.safeTrade({info:e,id:r,symbol:h,timestamp:n,datetime:this.iso8601(n),order:l,type:d,side:a,takerOrMaker:p,price:s,amount:i,cost:o,fee:c},t)}parseSpotBalance(e){let t;const s={info:e},i=this.safeValue(e,"data",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.safeValue(this.currencies,o,{}),c=this.safeInteger(d,"valueScale",8),u=this.account(),h=this.safeString(r,"balanceEv"),l=this.safeString(r,"lockedTradingBalanceEv"),p=this.safeString(r,"lockedWithdrawEv"),m=this.fromEn(h,c),g=this.fromEn(l,c),y=this.fromEn(p,c),b=ls.stringAdd(g,y),w=this.safeIntegerProduct(r,"lastUpdateTimeNs",1e-6);t=t===void 0?w:Math.max(t,w),u.total=m,u.used=b,s[o]=u}return s.timestamp=t,s.datetime=this.iso8601(t),this.safeBalance(s)}parseSwapBalance(e){const t={info:e},s=this.safeValue(e,"data",{}),i=this.safeValue(s,"account",{}),n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.currency(r),o=this.account(),d=this.safeString(i,"accountBalanceEv"),c=this.safeString(i,"totalUsedBalanceEv"),u=this.safeInteger(a,"valueScale",8);return o.total=this.fromEn(d,u),o.used=this.fromEn(c,u),t[r]=o,this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString2(this.options,"defaultType","fetchBalance","spot"),s=this.safeString(e,"type",t);let i="privateGetSpotWallets";const n={};if(s==="swap"){const o=this.safeString(e,"code");if(o!==void 0){const d=this.currency(o);n.currency=d.id,e=this.omit(e,"code")}else if(this.safeString(e,"currency")===void 0)throw new Bs(this.id+" fetchBalance() requires a code parameter or a currency parameter for "+s+" type");i="privateGetAccountsAccountPositions"}e=this.omit(e,"type");const r=await this[i](this.extend(n,e));return s==="swap"?this.parseSwapBalance(r):this.parseSpotBalance(r)}parseOrderStatus(e){const t={Created:"open",Untriggered:"open",Deactivated:"closed",Triggered:"open",Rejected:"rejected",New:"open",PartiallyFilled:"open",Filled:"closed",Canceled:"canceled"};return this.safeString(t,e,e)}parseOrderType(e){const t={Limit:"limit",Market:"market"};return this.safeString(t,e,e)}parseTimeInForce(e){const t={GoodTillCancel:"GTC",PostOnly:"PO",ImmediateOrCancel:"IOC",FillOrKill:"FOK"};return this.safeString(t,e,e)}parseSpotOrder(e,t=void 0){const s=this.safeString(e,"orderID");let i=this.safeString(e,"clOrdID");i!==void 0&&i.length<1&&(i=void 0);const n=this.safeString(e,"symbol"),r=this.safeSymbol(n,t),a=this.fromEp(this.safeString(e,"priceEp"),t),o=this.fromEv(this.safeString(e,"baseQtyEv"),t),d=this.omitZero(this.fromEv(this.safeString(e,"leavesBaseQtyEv"),t)),c=this.fromEv(this.safeString2(e,"cumBaseQtyEv","cumBaseValueEv"),t),u=this.fromEv(this.safeString2(e,"cumQuoteValueEv","quoteQtyEv"),t),h=this.fromEp(this.safeString(e,"avgPriceEp"),t),l=this.parseOrderStatus(this.safeString(e,"ordStatus")),p=this.safeStringLower(e,"side"),m=this.parseOrderType(this.safeString(e,"ordType")),g=this.safeIntegerProduct2(e,"actionTimeNs","createTimeNs",1e-6);let y;const b=this.fromEv(this.safeString(e,"cumFeeEv"),t);b!==void 0&&(y={cost:b,currency:void 0});const w=this.parseTimeInForce(this.safeString(e,"timeInForce")),S=this.parseNumber(this.omitZero(this.fromEp(this.safeString(e,"stopPxEp",t)))),k=w==="PO";return this.safeOrder({info:e,id:s,clientOrderId:i,timestamp:g,datetime:this.iso8601(g),lastTradeTimestamp:void 0,symbol:r,type:m,timeInForce:w,postOnly:k,side:p,price:a,stopPrice:S,amount:o,cost:u,average:h,filled:c,remaining:d,status:l,fee:y,trades:void 0},t)}parseSwapOrder(e,t=void 0){const s=this.safeString(e,"orderID");let i=this.safeString(e,"clOrdID");i!==void 0&&i.length<1&&(i=void 0);const n=this.safeString(e,"symbol"),r=this.safeSymbol(n,t),a=this.parseOrderStatus(this.safeString(e,"ordStatus")),o=this.safeStringLower(e,"side"),d=this.parseOrderType(this.safeString(e,"orderType")),c=this.parseNumber(this.fromEp(this.safeString(e,"priceEp"),t)),u=this.safeNumber(e,"orderQty"),h=this.safeNumber(e,"cumQty"),l=this.safeNumber(e,"leavesQty"),p=this.safeIntegerProduct(e,"actionTimeNs",1e-6),m=this.safeNumber(e,"cumValue");let g=this.safeIntegerProduct(e,"transactTimeNs",1e-6);g===0&&(g=void 0);const y=this.parseTimeInForce(this.safeString(e,"timeInForce")),b=this.safeNumber(e,"stopPx"),w=y==="PO";let S=this.safeValue(e,"reduceOnly");return this.safeString(e,"execInst")==="ReduceOnly"&&(S=!0),{info:e,id:s,clientOrderId:i,datetime:this.iso8601(p),timestamp:p,lastTradeTimestamp:g,symbol:r,type:d,timeInForce:y,postOnly:w,reduceOnly:S,side:o,price:c,stopPrice:b,amount:u,filled:h,remaining:l,cost:m,average:void 0,status:a,fee:void 0,trades:void 0}}parseOrder(e,t=void 0){return"closedPnl"in e?this.parseSwapOrder(e,t):this.parseSpotOrder(e,t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);s=this.capitalize(s),t=this.capitalize(t);const o=this.safeValue(r,"reduceOnly"),d={symbol:a.id,side:s,ordType:t},c=this.safeString2(r,"clOrdID","clientOrderId");if(c===void 0){const y=this.safeString(this.options,"brokerId");y!==void 0&&(d.clOrdID=y+this.uuid16())}else d.clOrdID=c,r=this.omit(r,["clOrdID","clientOrderId"]);const u=this.safeString2(r,"stopPx","stopPrice");if(u!==void 0&&(d.stopPxEp=this.toEp(u,a)),r=this.omit(r,["stopPx","stopPrice"]),a.spot){let y=this.safeValue(r,"qtyType","ByBase");if((t==="Market"||t==="Stop"||t==="MarketIfTouched")&&n!==void 0&&(y="ByQuote"),d.qtyType=y,y==="ByQuote"){let b=this.safeNumber(r,"cost");if(r=this.omit(r,"cost"),this.options.createOrderByQuoteRequiresPrice){if(n!==void 0){const S=this.numberToString(i),k=this.numberToString(n),T=ls.stringMul(S,k);b=this.parseNumber(T)}else if(b===void 0)throw new Bs(this.id+" createOrder() "+y+" requires a price argument or a cost parameter")}b=b===void 0?i:b;const w=b.toString();d.quoteQtyEv=this.toEv(w,a)}else{const b=i.toString();d.baseQtyEv=this.toEv(b,a)}}else if(a.swap&&(o!==void 0&&(d.reduceOnly=o),d.orderQty=parseInt(i),u!==void 0)){const y=this.safeString(r,"triggerType","ByMarkPrice");d.triggerType=y}if(t==="Limit"||t==="StopLimit"||t==="LimitIfTouched"){const y=n.toString();d.priceEp=this.toEp(y,a)}const h=this.safeString(r,"takeProfitPrice");h!==void 0&&(d.takeProfitEp=this.toEp(h,a),r=this.omit(r,"takeProfitPrice"));const l=this.safeString(r,"stopLossPrice");l!==void 0&&(d.stopLossEp=this.toEp(l,a),r=this.omit(r,"stopLossPrice"));const p=a.spot?"privatePostSpotOrders":"privatePostOrders";r=this.omit(r,"reduceOnly");const m=await this[p](this.extend(d,r)),g=this.safeValue(m,"data",{});return this.parseOrder(g,a)}async editOrder(e,t,s=void 0,i=void 0,n=void 0,r=void 0,a={}){if(t===void 0)throw new Bs(this.id+" editOrder() requires a symbol argument");if(s!==void 0)throw new Bs(this.id+" editOrder() type changing is not implemented. Try to cancel & recreate order for that purpose");if(i!==void 0)throw new Bs(this.id+" editOrder() side changing is not implemented. Try to cancel & recreate order for that purpose");await this.loadMarkets();const o=this.market(t),d={symbol:o.id},c=this.safeString2(a,"clientOrderId","clOrdID");a=this.omit(a,["clientOrderId","clOrdID"]),c!==void 0?d.clOrdID=c:d.orderID=e,r!==void 0&&(d.priceEp=this.toEp(r,o));const u=this.safeString(a,"baseQtyEv");a=this.omit(a,["baseQtyEv"]),u!==void 0?d.baseQtyEV=u:n!==void 0&&(d.baseQtyEV=this.toEv(n,o));const h=this.safeString2(a,"stopPx","stopPrice");h!==void 0&&(d.stopPxEp=this.toEp(h,o)),a=this.omit(a,["stopPx","stopPrice"]);const l=o.spot?"privatePutSpotOrders":"privatePutOrdersReplace",p=await this[l](this.extend(d,a)),m=this.safeValue(p,"data",{});return this.parseOrder(m,o)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Bs(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={symbol:i.id},r=this.safeString2(s,"clientOrderId","clOrdID");s=this.omit(s,["clientOrderId","clOrdID"]),r!==void 0?n.clOrdID=r:n.orderID=e;const a=i.spot?"privateDeleteSpotOrders":"privateDeleteOrdersCancel",o=await this[a](this.extend(n,s)),d=this.safeValue(o,"data",{});return this.parseOrder(d,i)}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new Bs(this.id+" cancelAllOrders() requires a symbol argument");await this.loadMarkets();const s={},i=this.market(e);let n="privateDeleteSpotOrdersAll";return i.swap&&(n="privateDeleteOrdersAll"),s.symbol=i.id,await this[n](this.extend(s,t))}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Bs(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=i.spot?"privateGetSpotOrdersActive":"privateGetExchangeOrder",r={symbol:i.id},a=this.safeString2(s,"clientOrderId","clOrdID");s=this.omit(s,["clientOrderId","clOrdID"]),a!==void 0?r.clOrdID=a:r.orderID=e;const o=await this[n](this.extend(r,s)),d=this.safeValue(o,"data",{});let c=d;if(Array.isArray(d)){if(d.length<1)throw a!==void 0?new dh(this.id+" fetchOrder() "+t+" order with clientOrderId "+a+" not found"):new dh(this.id+" fetchOrder() "+t+" order with id "+e+" not found");c=this.safeValue(d,0,{})}return this.parseOrder(c,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Bs(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=n.spot?"privateGetSpotOrders":"privateGetExchangeOrderList",a={symbol:n.id};t!==void 0&&(a.start=t),s!==void 0&&(a.limit=s);const o=await this[r](this.extend(a,i)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"rows",[]);return this.parseOrders(c,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Bs(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=n.spot?"privateGetSpotOrders":"privateGetOrdersActiveList",a={symbol:n.id};let o;try{o=await this[r](this.extend(a,i))}catch(c){if(c instanceof dh)return[]}const d=this.safeValue(o,"data",{});if(Array.isArray(d))return this.parseOrders(d,n,t,s);{const c=this.safeValue(d,"rows",[]);return this.parseOrders(c,n,t,s)}}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Bs(this.id+" fetchClosedOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=n.spot?"privateGetExchangeSpotOrder":"privateGetExchangeOrderList",a={symbol:n.id};t!==void 0&&(a.start=t),s!==void 0&&(a.limit=s);const o=await this[r](this.extend(a,i)),d=this.safeValue(o,"data",{});if(Array.isArray(d))return this.parseOrders(d,n,t,s);{const c=this.safeValue(d,"rows",[]);return this.parseOrders(c,n,t,s)}}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Bs(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=n.spot?"privateGetExchangeSpotOrderTrades":"privateGetExchangeOrderTrade",a={symbol:n.id};t!==void 0&&(a.start=t),n.swap&&s!==void 0&&(a.limit=s);const o=await this[r](this.extend(a,i)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"rows",[]);return this.parseTrades(c,n,t,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=this.safeValue(this.options,"defaultNetworks"),r=this.safeStringUpper(n,e),a=this.safeValue(this.options,"networks",{});let o=this.safeStringUpper(t,"network",r);o=this.safeString(a,o,o),o===void 0?i.chainName=s.id:(i.chainName=o,t=this.omit(t,"network"));const d=await this.privateGetPhemexUserWalletsV2DepositAddress(this.extend(i,t)),c=this.safeValue(d,"data",{}),u=this.safeString(c,"address"),h=this.safeString(c,"tag");return this.checkAddress(u),{currency:e,address:u,tag:h,network:void 0,info:d}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r=await this.privateGetExchangeWalletsDepositList(i),a=this.safeValue(r,"data",{});return this.parseTransactions(a,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r=await this.privateGetExchangeWalletsWithdrawList(i),a=this.safeValue(r,"data",{});return this.parseTransactions(a,n,t,s)}parseTransactionStatus(e){const t={Success:"ok",Succeed:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"address"),n=void 0,r=this.safeString(e,"txHash"),a=this.safeString(e,"currency");t=this.safeCurrency(a,t);const o=t.code,d=this.safeInteger2(e,"createdAt","submitedAt");let c=this.safeStringLower(e,"type");const u=this.parseNumber(this.fromEn(this.safeString(e,"feeEv"),t.valueScale));let h;u!==void 0&&(c="withdrawal",h={cost:u,currency:o});const l=this.parseTransactionStatus(this.safeString(e,"status")),p=this.parseNumber(this.fromEn(this.safeString(e,"amountEv"),t.valueScale));return{info:e,id:s,txid:r,timestamp:d,datetime:this.iso8601(d),network:void 0,address:i,addressTo:i,addressFrom:void 0,tag:n,tagTo:n,tagFrom:void 0,type:c,amount:p,currency:o,status:l,updated:void 0,fee:h}}async fetchPositions(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeString(this.options,"defaultSubType","linear");let i=this.safeString(t,"code");i===void 0?i=s==="linear"?"USD":"BTC":t=this.omit(t,"code");const r={currency:this.currency(i).id},a=await this.privateGetAccountsAccountPositions(this.extend(r,t)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"positions",[]),c=[];for(let u=0;u<d.length;u++){const h=d[u];c.push(this.parsePosition(h))}return this.filterByArray(c,"symbol",e,!1)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeString(e,"positionMargin"),r=this.safeString(e,"value"),a=this.safeString(e,"maintMarginReq"),o=ls.stringMul(r,a),d=this.safeString(e,"assignedPosBalance"),c=ls.stringDiv(d,r),u=this.safeNumber(e,"liquidationPrice"),h=this.safeString(e,"markPrice"),l=this.safeString(e,"size"),p=this.safeValue(t,"contractSize"),m=this.numberToString(p),g=this.safeNumber(e,"leverage"),y=this.safeString(e,"avgEntryPrice"),w=this.safeString(e,"side")==="Buy"?"long":"short";let S;this.safeString(e,"currency")==="USD"?w==="long"?S=ls.stringSub(h,y):S=ls.stringSub(y,h):w==="long"?S=ls.stringSub(ls.stringDiv("1",y),ls.stringDiv("1",h)):S=ls.stringSub(ls.stringDiv("1",h),ls.stringDiv("1",y));const T=ls.stringMul(ls.stringMul(S,l),m),I=ls.stringMul(ls.stringDiv(T,d),"100"),_=ls.stringDiv(o,n);return{info:e,id:void 0,symbol:i,contracts:this.parseNumber(l),contractSize:p,unrealizedPnl:this.parseNumber(T),leverage:g,liquidationPrice:u,collateral:this.parseNumber(n),notional:this.parseNumber(r),markPrice:this.parseNumber(h),entryPrice:this.parseNumber(y),timestamp:void 0,initialMargin:this.parseNumber(d),initialMarginPercentage:this.parseNumber(c),maintenanceMargin:this.parseNumber(o),maintenanceMarginPercentage:this.parseNumber(a),marginRatio:this.parseNumber(_),datetime:void 0,marginMode:void 0,side:w,hedged:!1,percentage:this.parseNumber(I)}}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),e===void 0)throw new Bs(this.id+" fetchFundingHistory() requires a symbol argument");const n=this.market(e),r={symbol:n.id};if(s>200)throw new Hs(this.id+" fetchFundingHistory() limit argument cannot exceed 200");s!==void 0&&(r.limit=s);const a=await this.privateGetApiDataFuturesFundingFees(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"rows",[]),c=[];for(let u=0;u<d.length;u++){const h=d[u],l=this.safeInteger(h,"createTime");c.push({info:h,symbol:this.safeString(h,"symbol"),code:this.safeCurrencyCode(this.safeString(h,"currency")),timestamp:l,datetime:this.iso8601(l),id:void 0,amount:this.fromEv(this.safeString(h,"execFeeEv"),n)})}return c}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new qc(this.id+" fetchFundingRate() supports swap contracts only");const i={symbol:s.id},n=await this.v1GetMdTicker24hr(this.extend(i,t)),r=this.safeValue(n,"result",{});return this.parseFundingRate(r,s)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeIntegerProduct(e,"timestamp",1e-6);return{info:e,symbol:i,markPrice:this.fromEp(this.safeString(e,"markEp"),t),indexPrice:this.fromEp(this.safeString(e,"indexEp"),t),interestRate:void 0,estimatedSettlePrice:void 0,timestamp:n,datetime:this.iso8601(n),fundingRate:this.fromEr(this.safeString(e,"fundingRateEr"),t),fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:this.fromEr(this.safeString(e,"predFundingRateEr"),t),nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async setMargin(e,t,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id,posBalanceEv:this.toEv(t,i)},r=await this.privatePostPositionsAssign(this.extend(n,s));return this.extend(this.parseMarginModification(r,i),{amount:t})}parseMarginStatus(e){const t={0:"ok"};return this.safeString(t,e,e)}parseMarginModification(e,t=void 0){t=this.safeMarket(void 0,t);const i=this.safeValue(t,"inverse")?"base":"quote";return{info:e,type:"set",amount:void 0,total:void 0,code:t[i],symbol:this.safeSymbol(void 0,t),status:this.parseMarginStatus(this.safeString(e,"code"))}}async setMarginMode(e,t=void 0,s={}){if(t===void 0)throw new Bs(this.id+" setMarginMode() requires a symbol argument");if(e=e.toLowerCase(),e!=="isolated"&&e!=="cross")throw new Hs(this.id+" setMarginMode() marginMode argument should be isolated or cross");await this.loadMarkets();const i=this.market(t);if(i.type!=="swap")throw new qc(this.id+" setMarginMode() supports swap contracts only");let n=this.safeInteger(s,"leverage");if(e==="cross"&&(n=0),n===void 0)throw new Bs(this.id+" setMarginMode() requires a leverage parameter");const r={symbol:i.id,leverage:n};return await this.privatePutPositionsLeverage(this.extend(r,s))}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetCfgV2Products(t),i=this.safeValue(s,"data",{}),n=this.safeValue(i,"riskLimits");return this.parseLeverageTiers(n,e,"symbol")}parseMarketLeverageTiers(e,t=void 0){t=this.safeMarket(void 0,t);const s=t.info.riskLimits,i=[];let n=0;for(let r=0;r<s.length;r++){const a=s[r],o=this.safeInteger(a,"limit");i.push({tier:this.sum(r,1),currency:t.settle,minNotional:n,maxNotional:o,maintenanceMarginRate:this.safeString(a,"maintenanceMargin"),maxLeverage:void 0,info:a}),n=o}return i}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.omit(i,this.extractParams(e)),o="/"+this.implodeParams(e,i);let d=o,c="";if((s==="GET"||s==="DELETE"||s==="PUT"||d==="/positions/assign")&&Object.keys(a).length&&(c=this.urlencodeWithArrayRepeat(a),d+="?"+c),t==="private"){this.checkRequiredCredentials();const u=this.seconds(),h=this.safeInteger(this.options,"x-phemex-request-expiry",60),p=this.sum(u,h).toString();n={"x-phemex-access-token":this.apiKey,"x-phemex-request-expiry":p};let m="";s==="POST"&&(m=this.json(i),r=m,n["Content-Type"]="application/json");const g=o+c+p+m;n["x-phemex-request-signature"]=this.hmac(this.encode(g),this.encode(this.secret))}return d=this.implodeHostname(this.urls.api[t])+d,{url:d,method:s,body:r,headers:n}}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new Bs(this.id+" setLeverage() requires a symbol argument");if(e<1||e>100)throw new Hs(this.id+" setLeverage() leverage should be between 1 and 100");await this.loadMarkets();const n={symbol:this.market(t).id,leverage:e};return await this.privatePutPositionsLeverage(this.extend(n,s))}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c=this.toEv(t,r);let u,h;if(o==="spot"&&d==="future"?u=2:o==="future"&&d==="spot"&&(u=1),u!==void 0){const m={currency:r.id,moveOp:u,amountEv:c},g=await this.privatePostAssetsTransfer(this.extend(m,n)),y=this.safeValue(g,"data",{});h=this.parseTransfer(y,r)}else{const m={fromUserId:o,toUserId:d,amountEv:c,currency:r.id,bizType:this.safeString(n,"bizType","SPOT")},g=await this.privatePostAssetsUniversalTransfer(this.extend(m,n));h=this.parseTransfer(g)}const l=this.safeValue(this.options,"transfer",{});return this.safeValue(l,"fillResponseFromRequest",!0)&&(h.fromAccount===void 0&&(h.fromAccount=s),h.toAccount===void 0&&(h.toAccount=i),h.amount===void 0&&(h.amount=t),h.currency===void 0&&(h.currency=e)),h}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),e===void 0)throw new Bs(this.id+" fetchTransfers() requires a code argument");const n=this.currency(e),r={currency:n.id};t!==void 0&&(r.start=t),s!==void 0&&(r.limit=s);const a=await this.privateGetAssetsTransfer(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"rows",[]);return this.parseTransfers(d,n,t,s)}parseTransfer(e,t=void 0){const s=this.safeString(e,"linkKey"),i=this.safeString(e,"status"),n=this.safeString(e,"amountEv"),r=this.fromEv(n,t),a=this.safeString(e,"currency"),o=this.safeCurrencyCode(a,t),d=this.safeInteger(e,"side");let c,u;d===1?(c="swap",u="spot"):d===2&&(c="spot",u="swap");const h=this.safeInteger(e,"createTime");return{info:e,id:s,timestamp:h,datetime:this.iso8601(h),currency:o,amount:r,fromAccount:c,toAccount:u,status:this.parseTransferStatus(i)}}parseTransferStatus(e){const t={3:"rejected",6:"canceled",10:"ok",11:"failed"};return this.safeString(t,e,e)}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeValue(a,"error",a),u=this.safeString(c,"code"),h=this.safeString(c,"msg");if(u!==void 0&&u!=="0"){const l=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,l),this.throwBroadlyMatchedException(this.exceptions.broad,h,l),new As(l)}}};const cG=me,{ArgumentsRequired:zv,ExchangeError:Kv,ExchangeNotAvailable:uG,RequestTimeout:fG,AuthenticationError:hG,PermissionDenied:Xv,RateLimitExceeded:Yv,InsufficientFunds:lG,OrderNotFound:fh,InvalidOrder:Lc,AccountSuspended:eg,CancelPending:pG,InvalidNonce:mG,OnMaintenance:gG,BadSymbol:tg}=oe,{DECIMAL_PLACES:yG}=pe,Qv=ke;var bG=class extends cG{describe(){return this.deepExtend(super.describe(),{id:"poloniex",name:"Poloniex",countries:["US"],rateLimit:5,certified:!1,pro:!1,has:{CORS:void 0,spot:!0,margin:void 0,swap:void 0,future:void 0,option:void 0,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createMarketOrder:void 0,createOrder:!0,editOrder:!1,fetchBalance:!0,fetchClosedOrder:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionMode:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawals:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"MINUTE_1","5m":"MINUTE_5","10m":"MINUTE_10","15m":"MINUTE_15","30m":"MINUTE_30","1h":"HOUR_1","2h":"HOUR_2","4h":"HOUR_4","6h":"HOUR_6","12h":"HOUR_12","1d":"DAY_1","3d":"DAY_3","1w":"WEEK_1","1M":"MONTH_1"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766817-e9456312-5ee6-11e7-9b3c-b628ca5626a5.jpg",api:"https://api.poloniex.com",test:"https://sand-spot-api-gateway.poloniex.com",www:"https://www.poloniex.com",doc:"https://docs.poloniex.com",fees:"https://poloniex.com/fees",referral:"https://poloniex.com/signup?c=UBFZJRPJ"},api:{public:{get:{markets:20,"markets/{symbol}":1,currencies:20,"currencies/{currency}":20,timestamp:1,"markets/price":1,"markets/{symbol}/price":1,"markets/{symbol}/orderBook":1,"markets/{symbol}/candles":1,"markets/{symbol}/trades":20,"markets/ticker24h":20,"markets/{symbol}/ticker24h":20}},private:{get:{accounts:4,"accounts/activity":4,"accounts/balances":4,"accounts/{id}/balances":4,"accounts/transfer":20,"accounts/transfer/{id}":4,feeinfo:20,"wallets/addresses":20,"wallets/activity":20,"wallets/addresses/{currency}":20,orders:20,"orders/{id}":4,"orders/history":20,"orders/killSwitchStatus":4,smartorders:20,"smartorders/{id}":4,"smartorders/history":20,trades:20,"orders/{id}/trades":4},post:{"accounts/transfer":4,"wallets/address":20,"wallets/withdraw":20,orders:4,"orders/killSwitch":4,"orders/batch":20,smartorders:4},delete:{"orders/{id}":4,"orders/cancelByIds":20,orders:20,"smartorders/{id}":4,"smartorders/cancelByIds":20,smartorders:20}}},fees:{trading:{feeSide:"get",maker:this.parseNumber("0.0009"),taker:this.parseNumber("0.0009")},funding:{}},commonCurrencies:{AIR:"AirCoin",APH:"AphroditeCoin",BCC:"BTCtalkcoin",BCHABC:"BCHABC",BDG:"Badgercoin",BTM:"Bitmark",CON:"Coino",GOLD:"GoldEagles",GPUC:"GPU",HOT:"Hotcoin",ITC:"Information Coin",KEY:"KEYCoin",MASK:"NFTX Hashmasks Index",MEME:"Degenerator Meme",PLX:"ParallaxCoin",REPV2:"REP",STR:"XLM",SOC:"SOCC",TRADE:"Unitrade",XAP:"API Coin",USDTTRON:"USDT",USDTETH:"USDT",UST:"USTC"},options:{networks:{BEP20:"BSC",ERC20:"ETH",TRX:"TRON",TRC20:"TRON"},limits:{cost:{min:{BTC:1e-4,ETH:1e-4,USDT:1,TRX:100,BNB:.06,USDC:1,USDJ:1,TUSD:1e-4,DAI:1,PAX:1,BUSD:1}}},accountsByType:{spot:"spot",future:"futures"},accountsById:{exchange:"spot",futures:"future"}},precisionMode:yG,exceptions:{exact:{"You may only place orders that reduce your position.":Lc,"Invalid order number, or you are not the person who placed the order.":fh,"Permission denied":Xv,"Permission denied.":Xv,"Connection timed out. Please try again.":fG,"Internal error. Please try again.":uG,"Currently in maintenance mode.":gG,"Order not found, or you are not the person who placed it.":fh,"Invalid API key/secret pair.":hG,"Please do not make more than 8 API calls per second.":Yv,"This IP has been temporarily throttled. Please ensure your requests are valid and try again in one minute.":Yv,"Rate must be greater than zero.":Lc,"Invalid currency pair.":tg,"Invalid currencyPair parameter.":tg,"Trading is disabled in this market.":tg,"Invalid orderNumber parameter.":fh,"Order is beyond acceptable bounds.":Lc,"This account is closed.":eg},broad:{"Total must be at least":Lc,"This account is frozen":eg,"This account is locked.":eg,"Not enough":lG,"Nonce must be greater":mG,"You have already called cancelOrder":pG,"Amount must be at least":Lc,"is either completed or does not exist":fh,"Error pulling ":Kv}}})}parseOHLCV(e,t=void 0){return[this.safeInteger(e,12),this.safeNumber(e,2),this.safeNumber(e,1),this.safeNumber(e,0),this.safeNumber(e,3),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,interval:this.timeframes[t]};s!==void 0&&(a.startTime=s),i!==void 0&&(a.limit=i);const o=await this.publicGetMarketsSymbolCandles(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}async loadMarkets(e=!1,t={}){const s=await super.loadMarkets(e,t);return(this.safeValue(this.options,"currenciesByNumericId")===void 0||e)&&(this.options.currenciesByNumericId=this.indexBy(this.currencies,"numericId")),s}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=[];for(let i=0;i<t.length;i++){const n=this.safeValue(t,i),r=this.safeString(n,"symbol"),a=this.safeString(n,"baseCurrencyName"),o=this.safeString(n,"quoteCurrencyName"),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o),h=this.safeString(n,"state")==="NORMAL",l=this.safeValue(n,"symbolTradeLimit");s.push({id:r,symbol:d+"/"+c,base:d,quote:c,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:h,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeInteger(l,"quantityScale"),price:this.safeInteger(l,"priceScale")},limits:{amount:{min:this.safeNumber(l,"minQuantity"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(l,"minAmount"),max:void 0}},info:n})}return s}async fetchTime(e={}){const t=await this.publicGetTimestamp(e);return this.safeInteger(t,"serverTime")}parseTicker(e,t=void 0){const s=this.safeInteger(e,"ts"),i=this.safeString(e,"symbol");t=this.safeMarket(i);const n=this.safeString(e,"close"),r=this.safeString(e,"percentChange"),a=Qv.stringMul(r,"100");return this.safeTicker({id:i,symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:n,last:n,previousClose:void 0,change:void 0,percentage:a,average:void 0,baseVolume:this.safeString(e,"quantity"),quoteVolume:this.safeString(e,"amount"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetMarketsTicker24h(t);return this.parseTickers(s,e)}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s={};for(let i=0;i<t.length;i++){const n=this.safeValue(t,i),r=Object.keys(n),a=this.safeValue(r,0),o=this.safeValue(n,a),d=this.safeCurrencyCode(a),c=this.safeValue(o,"delisted"),h=this.safeString(o,"walletState")==="ENABLED",p=!c&&h,m=this.safeInteger(o,"id"),g=this.safeNumber(o,"withdrawalFee");s[d]={id:a,numericId:m,code:d,info:o,name:o.name,active:p,deposit:void 0,withdraw:void 0,fee:g,precision:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:g,max:void 0}}}}return s}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetMarketsSymbolTicker24h(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){const s=this.safeString2(e,"id","tradeID"),i=this.safeString(e,"orderId"),n=this.safeInteger2(e,"ts","createTime"),r=this.safeString(e,"symbol");t=this.safeMarket(r,t,"_");const a=t.symbol,o=this.safeStringLower(e,"side");let d;const c=this.safeString(e,"price"),u=this.safeString(e,"quantity"),h=this.safeString(e,"amount"),l=this.safeString(e,"feeCurrency"),p=this.safeString(e,"feeAmount");if(p!==void 0){const m=this.safeCurrencyCode(l);d={cost:p,currency:m}}return this.safeTrade({id:s,info:e,timestamp:n,datetime:this.iso8601(n),symbol:a,order:i,type:this.safeStringLower(e,"type"),side:o,takerOrMaker:this.safeStringLower(e,"matchRole"),price:c,amount:u,cost:h,fee:d},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetMarketsSymbolTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));const r={};t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=parseInt(s));const a=await this.privateGetTrades(this.extend(r,i)),o=this.parseTrades(a,n);return this.filterBySinceLimit(o,t,s)}parseOrderStatus(e){const t={NEW:"open",PARTIALLY_FILLED:"open",FILLED:"closed",PENDING_CANCEL:"canceled",PARTIALLY_CANCELED:"canceled",CANCELED:"canceled",FAILED:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){let s=this.safeInteger2(e,"timestamp","createTime");s===void 0&&(s=this.parse8601(this.safeString(e,"date")));const i=this.safeString(e,"symbol");t=this.safeMarket(i,t,"_");const n=t.symbol;let r=this.safeValue(e,"resultingTrades");Array.isArray(r)||(r=this.safeValue(r,this.safeString(t,"id",i)));const a=this.safeString2(e,"price","rate"),o=this.safeString(e,"quantity"),d=this.safeString(e,"filledQuantity"),c=this.parseOrderStatus(this.safeString(e,"state")),u=this.safeStringLower(e,"side"),h=this.safeString(e,"type"),l=this.parseOrderType(h),p=this.safeString2(e,"orderNumber","id");let m;const g=this.safeString(e,"tokenFeeCurrency");let y,b;const w=this.safeString(e,"fee");g===void 0?b=u==="buy"?t.base:t.quote:(b=this.safeCurrencyCode(g),y=this.safeString(e,"tokenFee")),y!==void 0&&(m={rate:w,cost:y,currency:b});const S=this.safeString(e,"clientOrderId");return this.safeOrder({info:e,id:p,clientOrderId:S,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:this.safeInteger(e,"updateTime"),status:c,symbol:n,type:l,timeInForce:this.safeString(e,"timeInForce"),postOnly:void 0,side:u,price:a,stopPrice:void 0,cost:void 0,average:this.safeString(e,"avgPrice"),amount:o,filled:d,remaining:void 0,trades:r,fee:m},t)}parseOrderType(e){const t={MARKET:"market",LIMIT:"limit","STOP-LIMIT":"limit","STOP-MARKET":"market"};return this.safeString(t,e,e)}parseOpenOrders(e,t,s){for(let i=0;i<e.length;i++){const n=e[i],r=this.extend(n,{status:"open",type:"limit",side:n.type,price:n.rate});s.push(this.parseOrder(r,t))}return s}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),s!==void 0&&(r.limit=s);const a=await this.privateGetOrders(this.extend(r,i)),o={status:"open"};return this.parseOrders(a,n,t,s,o)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o=t.toUpperCase();const d=o==="MARKET";this.isPostOnly(d,o==="LIMIT_MAKER",r)&&(o="LIMIT_MAKER",r=this.omit(r,"postOnly"));const u={symbol:a.id,side:s,type:o};d?s==="buy"?u.amount=this.currencyToPrecision(a.quote,i):u.quantity=this.amountToPrecision(e,i):(u.quantity=this.amountToPrecision(e,i),u.price=this.priceToPrecision(e,n));const h=this.safeString(r,"clientOrderId");h!==void 0&&(u.clientOrderId=h,r=this.omit(r,"clientOrderId"));let l=await this.privatePostOrders(this.extend(u,r));return l=this.extend(l,{type:s}),this.parseOrder(l,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={},n=this.safeValue(s,"clientOrderId");return n!==void 0&&(e=n),i.id=e,s=this.omit(s,"clientOrderId"),await this.privateDeleteOrdersId(this.extend(i,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;return e!==void 0&&(i=this.market(e),s.symbols=[i.id]),await this.privateDeleteOrders(this.extend(s,t))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets(),e=e.toString();const i={id:e},n=await this.privateGetOrdersId(this.extend(i,s));return this.extend(this.parseOrder(n),{id:e})}async fetchOrderStatus(e,t=void 0,s={}){await this.loadMarkets();const i=await this.fetchOpenOrders(t,void 0,void 0,s),n=this.indexBy(i,"id");return e in n?"open":"closed"}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={id:e},a=await this.privateGetOrdersIdTrades(this.extend(r,n));return this.parseTrades(a)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=this.safeValue(e,s,{}),n=this.safeValue(i,"balances");for(let r=0;r<n.length;r++){const a=this.safeValue(n,r),o=this.safeString(a,"currency"),d=this.safeCurrencyCode(o),c=this.account();c.free=this.safeString(a,"available"),c.used=this.safeString(a,"hold"),t[d]=c}}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t={accountType:"SPOT"},s=await this.privateGetAccountsBalances(this.extend(t,e));return this.parseBalance(s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetFeeinfo(e),s={};for(let i=0;i<this.symbols.length;i++){const n=this.symbols[i];s[n]={info:t,symbol:n,maker:this.safeNumber(t,"makerRate"),taker:this.safeNumber(t,"takerRate"),percentage:!0,tierBased:!0}}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetMarketsSymbolOrderBook(this.extend(n,s)),a=this.safeInteger(r,"time"),o=this.safeValue(r,"asks"),d=this.safeValue(r,"bids"),c=[],u=[];for(let h=0;h<o.length;h++)if(h%2<1){const l=this.safeNumber(o,h),p=this.safeNumber(o,this.sum(h,1));c.push([l,p])}for(let h=0;h<d.length;h++)if(h%2<1){const l=this.safeNumber(d,h),p=this.safeNumber(d,this.sum(h,1));u.push([l,p])}return{symbol:i.symbol,bids:this.sortBy(u,0,!0),asks:this.sortBy(c,0),timestamp:a,datetime:this.iso8601(a),nonce:void 0}}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper(t,"network");if(r=this.safeString(n,r,r),r!==void 0)i.currency+=r,t=this.omit(t,"network");else if(s.id==="USDT")throw new zv(this.id+" createDepositAddress requires a network parameter for "+e+".");const a=await this.privatePostWalletsAddress(this.extend(i,t));let o=this.safeString(a,"address"),d;if(this.checkAddress(o),s!==void 0){const c=this.safeString(s.info,"depositAddress");c!==void 0&&(d=o,o=c)}return{currency:e,address:o,tag:d,network:r,info:a}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper(t,"network");if(r=this.safeString(n,r,r),r!==void 0)i.currency+=r,t=this.omit(t,"network");else if(s.id==="USDT")throw new zv(this.id+" fetchDepositAddress requires a network parameter for "+e+".");const a=await this.privateGetWalletsAddresses(this.extend(i,t));let o=this.safeString(a,i.currency),d;if(this.checkAddress(o),s!==void 0){const c=this.safeString(s.info,"depositAddress");c!==void 0&&(d=o,o=c)}return{currency:e,address:o,tag:d,network:r,info:a}}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e);t=this.currencyToPrecision(e,t);const a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,s),c={amount:t,currency:r.id,fromAccount:o,toAccount:d},u=await this.privatePostAccountsTransfer(this.extend(c,n));return this.parseTransfer(u,r)}parseTransferStatus(e){const t={1:"ok"};return this.safeString(t,e,e)}parseTransfer(e,t=void 0){const i=this.safeString(e,"message").split(" "),n=this.safeNumber(i,1),r=this.safeString(i,2),a=this.safeString(i,4),o=this.safeString(i,6),d=this.safeValue(this.options,"accountsById",{});return{info:e,id:void 0,timestamp:void 0,datetime:void 0,currency:this.safeCurrencyCode(r,t),amount:n,fromAccount:this.safeString(d,a),toAccount:this.safeString(d,o),status:this.parseOrderStatus(this.safeString(e,"success","failed"))}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,amount:t,address:s};i!==void 0&&(a.paymentId=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeString(o,d,d),d!==void 0&&(a.currency+=d,n=this.omit(n,"network"));const c=await this.privatePostWalletsWithdraw(this.extend(a,n));return this.parseTransaction(c,r)}async fetchTransactionsHelper(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=31104e3,r=this.seconds(),o={start:t!==void 0?parseInt(t/1e3):r-10*n,end:r};return await this.privateGetWalletsActivity(this.extend(o,i))}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=await this.fetchTransactionsHelper(e,t,s,i);let r;e!==void 0&&(r=this.currency(e));const a=this.safeValue(n,"withdrawals",[]),o=this.safeValue(n,"deposits",[]),d=this.parseTransactions(a,r,t,s),c=this.parseTransactions(o,r,t,s),u=this.arrayConcat(c,d);return this.filterByCurrencySinceLimit(this.sortBy(u,"timestamp"),e,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const n=await this.fetchTransactionsHelper(e,t,s,i);let r;e!==void 0&&(r=this.currency(e));const a=this.safeValue(n,"withdrawals",[]),o=this.parseTransactions(a,r,t,s);return this.filterByCurrencySinceLimit(o,e,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){const n=await this.fetchTransactionsHelper(e,t,s,i);let r;e!==void 0&&(r=this.currency(e));const a=this.safeValue(n,"deposits",[]),o=this.parseTransactions(a,r,t,s);return this.filterByCurrencySinceLimit(o,e,t,s)}parseTransactionStatus(e){const t={COMPLETE:"ok",COMPLETED:"ok","AWAITING APPROVAL":"pending",AWAITING_APPROVAL:"pending",PENDING:"pending",PROCESSING:"pending","COMPLETE ERROR":"failed",COMPLETE_ERROR:"failed"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeTimestamp(e,"timestamp"),i=this.safeString(e,"currency"),n=this.safeCurrencyCode(i);let r=this.safeString(e,"status","pending");r=this.parseTransactionStatus(r);const a=this.safeString(e,"txid"),o="withdrawalRequestsId"in e?"withdrawal":"deposit",d=this.safeString2(e,"withdrawalRequestsId","depositNumber"),c=this.safeString(e,"address"),u=this.safeString(e,"paymentID");let h=this.safeString(e,"amount");const l=this.safeString(e,"fee");return o==="withdrawal"&&(h=Qv.stringSub(h,l)),{info:e,id:d,currency:n,amount:this.parseNumber(h),network:void 0,address:c,addressTo:void 0,addressFrom:void 0,tag:u,tagTo:void 0,tagFrom:void 0,status:r,type:o,updated:void 0,txid:a,timestamp:s,datetime:this.iso8601(s),fee:{currency:n,cost:this.parseNumber(l)}}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api;const o=this.omit(i,this.extractParams(e)),d=this.implodeParams(e,i);if(t==="public")a+="/"+d,Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials();const c=this.nonce().toString();let u=s+`
`;if(a+="/"+d,u+="/"+d,s==="POST"||s==="PUT"||s==="DELETE")u+=`
`,Object.keys(o).length&&(r=this.json(o),u+="requestBody="+r+"&"),u+="signTimestamp="+c;else{let l=this.extend({signTimestamp:c},o);l=this.keysort(l),u+=`
`+this.urlencode(l),Object.keys(o).length&&(a+="?"+this.urlencode(o))}const h=this.hmac(this.encode(u),this.encode(this.secret),"sha256","base64");n={"Content-Type":"application/json",key:this.apiKey,signTimestamp:c,signature:h}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&"error"in a){const c=a.error,u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u),new Kv(u)}}};const wG=me,{ExchangeError:SG,ExchangeNotAvailable:Zv,BadResponse:kG,BadRequest:sg,InvalidOrder:Jv,InsufficientFunds:vG,AuthenticationError:ig,ArgumentsRequired:eT,InvalidAddress:tT,RateLimitExceeded:TG,DDoSProtection:OG,BadSymbol:ng}=oe,{TRUNCATE:IG,TICK_SIZE:xG}=pe,hh=ke;var _G=class extends wG{describe(){return this.deepExtend(super.describe(),{id:"probit",name:"ProBit",countries:["SC","KR"],rateLimit:50,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddresses:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,signIn:!0,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","10m":"10m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","6h":"6h","12h":"12h","1d":"1D","1w":"1W","1M":"1M"},version:"v1",urls:{logo:"https://user-images.githubusercontent.com/51840849/79268032-c4379480-7ea2-11ea-80b3-dd96bb29fd0d.jpg",api:{accounts:"https://accounts.probit.com",public:"https://api.probit.com/api/exchange",private:"https://api.probit.com/api/exchange"},www:"https://www.probit.com",doc:["https://docs-en.probit.com","https://docs-ko.probit.com"],fees:"https://support.probit.com/hc/en-us/articles/360020968611-Trading-Fees",referral:"https://www.probit.com/r/34608773"},api:{public:{get:{market:1,currency:1,currency_with_platform:1,time:1,ticker:1,order_book:1,trade:1,candle:1}},private:{post:{new_order:2,cancel_order:1,withdrawal:2},get:{balance:1,order:1,open_order:1,order_history:1,trade_history:1,deposit_address:1}},accounts:{post:{token:1}}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},exceptions:{exact:{UNAUTHORIZED:ig,INVALID_ARGUMENT:sg,TRADING_UNAVAILABLE:Zv,NOT_ENOUGH_BALANCE:vG,NOT_ALLOWED_COMBINATION:sg,INVALID_ORDER:Jv,RATE_LIMIT_EXCEEDED:TG,MARKET_UNAVAILABLE:Zv,INVALID_MARKET:ng,MARKET_CLOSED:ng,MARKET_NOT_FOUND:ng,INVALID_CURRENCY:sg,TOO_MANY_OPEN_ORDERS:OG,DUPLICATE_ADDRESS:tT,invalid_grant:ig}},requiredCredentials:{apiKey:!0,secret:!0},precisionMode:xG,options:{createMarketBuyOrderRequiresPrice:!0,timeInForce:{limit:"gtc",market:"ioc"},networks:{BEP20:"BSC",ERC20:"ETH",TRC20:"TRON",TRX:"TRON"}},commonCurrencies:{AUTO:"Cube",AZU:"Azultec",BCC:"BCC",BDP:"BidiPass",BIRD:"Birdchain",BTCBEAR:"BEAR",BTCBULL:"BULL",CBC:"CryptoBharatCoin",CHE:"Chellit",CLR:"Color Platform",CTK:"Cryptyk",CTT:"Castweet",DIP:"Dipper",DKT:"DAKOTA",EGC:"EcoG9coin",EPS:"Epanus",FX:"Fanzy",GDT:"Gorilla Diamond",GM:"GM Holding",GOGOL:"GOL",GOL:"Goldofir",GRB:"Global Reward Bank",HBC:"Hybrid Bank Cash",HUSL:"The Hustle App",LAND:"Landbox",LBK:"Legal Block",ORC:"Oracle System",PXP:"PIXSHOP COIN",PYE:"CreamPYE",ROOK:"Reckoon",SOC:"Soda Coin",SST:"SocialSwap",TCT:"Top Coin Token",TOR:"Torex",TPAY:"Tetra Pay",UNI:"UNICORN Token",UNISWAP:"UNI"}})}async fetchMarkets(e={}){const t=await this.publicGetMarket(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"id"),o=this.safeString(r,"base_currency_id"),d=this.safeString(r,"quote_currency_id"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d),h=this.safeValue(r,"closed",!1),l=this.safeString(r,"taker_fee_rate"),p=hh.stringDiv(l,"100"),m=this.safeString(r,"maker_fee_rate"),g=hh.stringDiv(m,"100");i.push({id:a,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!h,contract:!1,linear:void 0,inverse:void 0,taker:this.parseNumber(p),maker:this.parseNumber(g),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"quantity_precision"))),price:this.safeNumber(r,"price_increment"),cost:this.parseNumber(this.parsePrecision(this.safeString(r,"cost_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"min_quantity"),max:this.safeNumber(r,"max_quantity")},price:{min:this.safeNumber(r,"min_price"),max:this.safeNumber(r,"max_price")},cost:{min:this.safeNumber(r,"min_cost"),max:this.safeNumber(r,"max_cost")}},info:r})}return i}async fetchCurrencies(e={}){const t=await this.publicGetCurrencyWithPlatform(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"id"),o=this.safeCurrencyCode(a),d=this.safeValue(r,"display_name"),c=this.safeString(d,"en-us"),u=this.safeValue(r,"platform",[]),h=this.sortBy(u,"priority"),l=this.safeValue(h,0,{}),p=this.safeValue(l,"deposit_suspended"),m=this.safeValue(l,"withdrawal_suspended"),g=!p,y=!m,b=g&&y,w=this.safeValue(l,"withdrawal_fee",{}),S=[];for(let _=0;_<w.length;_++){const N=w[_],M=this.safeNumber(N,"amount"),x=this.safeInteger(N,"priority");M!==void 0&&x!==void 0&&S.push(N)}const k=this.sortBy(S,"priority"),T=this.safeValue(k,0,{}),I=this.safeNumber(T,"amount");i[o]={id:a,code:o,info:r,name:c,active:b,deposit:g,withdraw:y,fee:I,precision:this.parseNumber(this.parsePrecision(this.safeString(l,"precision"))),limits:{amount:{min:void 0,max:void 0},deposit:{min:this.safeNumber(l,"min_deposit_amount"),max:void 0},withdraw:{min:this.safeNumber(l,"min_withdrawal_amount"),max:void 0}}}}return i}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"data",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeString(n,"currency_id"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(n,"total"),o.free=this.safeString(n,"available"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={market_id:i.id},r=await this.publicGetOrderBook(this.extend(n,s)),a=this.safeValue(r,"data",[]),o=this.groupBy(a,"side");return this.parseOrderBook(o,i.symbol,void 0,"buy","sell","price","quantity")}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};if(e!==void 0){const r=this.marketIds(e);s.market_ids=r.join(",")}const i=await this.publicGetTicker(this.extend(s,t)),n=this.safeValue(i,"data",[]);return this.parseTickers(n,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market_ids:s.id},n=await this.publicGetTicker(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0);if(a===void 0)throw new kG(this.id+" fetchTicker() returned an empty response");return this.parseTicker(a,s)}parseTicker(e,t=void 0){const s=this.parse8601(this.safeString(e,"time")),i=this.safeString(e,"market_id"),n=this.safeSymbol(i,t,"-"),r=this.safeString(e,"last"),a=this.safeString(e,"change"),o=this.safeString(e,"base_volume"),d=this.safeString(e,"quote_volume");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:a,percentage:void 0,average:void 0,baseVolume:o,quoteVolume:d,info:e},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={limit:100,start_time:this.iso8601(0),end_time:this.iso8601(this.milliseconds())};e!==void 0&&(n=this.market(e),r.market_id=n.id),t!==void 0&&(r.start_time=this.iso8601(t)),s!==void 0&&(r.limit=s);const a=await this.privateGetTradeHistory(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market_id:n.id,limit:100,start_time:"1970-01-01T00:00:00.000Z",end_time:this.iso8601(this.milliseconds())};t!==void 0&&(r.start_time=this.iso8601(t)),s!==void 0&&(r.limit=s);const a=await this.publicGetTrade(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"time")),i=this.safeString(e,"id");let n;if(i!==void 0){const l=i.split(":");n=this.safeString(l,0)}n=this.safeString(e,"market_id",n);const r=this.safeSymbol(n,t,"-"),a=this.safeString(e,"side"),o=this.safeString(e,"price"),d=this.safeString(e,"quantity"),c=this.safeString(e,"order_id"),u=this.safeString(e,"fee_amount");let h;if(u!==void 0){const l=this.safeString(e,"fee_currency_id"),p=this.safeCurrencyCode(l);h={cost:u,currency:p}}return this.safeTrade({id:i,info:e,timestamp:s,datetime:this.iso8601(s),symbol:r,order:c,type:void 0,side:a,takerOrMaker:void 0,price:o,amount:d,cost:void 0,fee:h},t)}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.parse8601(this.safeString(t,"data"))}normalizeOHLCVTimestamp(e,t,s=!1){const i=this.parseTimeframe(t);if(t==="1M"){const r=this.iso8601(e).split("-"),a=this.safeString(r,0);let o=this.safeInteger(r,1);return s&&(o=this.sum(o,1)),o<10?o="0"+o.toString():o=o.toString(),a+"-"+o+"-01T00:00:00.000Z"}else if(t==="1w"){e=parseInt(e/1e3);const n=259200,r=e-n,a=Math.floor(r/i);let o=this.sum(n,a*i);return s&&(o=this.sum(o,i)),this.iso8601(o*1e3)}else return e=parseInt(e/1e3),e=i*parseInt(e/i),s&&(e=this.sum(e,i)),this.iso8601(e*1e3)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.timeframes[t];i=i===void 0?100:i;let o=this.sum(i,1);o=Math.min(1e3,o);const d={market_ids:r.id,interval:a,sort:"asc",limit:o},c=this.milliseconds(),u=this.parseTimeframe(t);let h=s,l=c;s===void 0?(i===void 0&&(i=o),h=c-i*u*1e3):i===void 0?l=c:l=this.sum(s,this.sum(i,1)*u*1e3);const p=this.normalizeOHLCVTimestamp(h,t),m=this.normalizeOHLCVTimestamp(l,t,!0);d.start_time=p,d.end_time=m;const g=await this.publicGetCandle(this.extend(d,n)),y=this.safeValue(g,"data",[]);return this.parseOHLCVs(y,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"start_time")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"base_volume")]}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),t=this.parse8601(t);const n={};let r;e!==void 0&&(r=this.market(e),n.market_id=r.id);const a=await this.privateGetOpenOrder(this.extend(n,i)),o=this.safeValue(a,"data");return this.parseOrders(o,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={start_time:this.iso8601(0),end_time:this.iso8601(this.milliseconds()),limit:100};let r;e!==void 0&&(r=this.market(e),n.market_id=r.id),t&&(n.start_time=this.iso8601(t)),s&&(n.limit=s);const a=await this.privateGetOrderHistory(this.extend(n,i)),o=this.safeValue(a,"data");return this.parseOrders(o,r,t,s)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new eT(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={market_id:i.id},r=this.safeString2(s,"clientOrderId","client_order_id");r!==void 0?n.client_order_id=r:n.order_id=e;const a=this.omit(s,["clientOrderId","client_order_id"]),o=await this.privateGetOrder(this.extend(n,a)),d=this.safeValue(o,"data",[]),c=this.safeValue(d,0);return this.parseOrder(c,i)}parseOrderStatus(e){const t={open:"open",cancelled:"canceled",filled:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString(e,"status")),i=this.safeString(e,"id"),n=this.safeString(e,"type"),r=this.safeString(e,"side"),a=this.safeString(e,"market_id"),o=this.safeSymbol(a,t,"-"),d=this.parse8601(this.safeString(e,"time"));let c=this.safeString(e,"limit_price");const u=this.safeString(e,"filled_quantity");let h=this.safeString(e,"open_quantity");const l=this.safeString(e,"cancelled_quantity");l!==void 0&&(h=hh.stringAdd(h,l));const p=this.safeString(e,"quantity",hh.stringAdd(u,h)),m=this.safeString2(e,"filled_cost","cost");n==="market"&&(c=void 0);const g=this.safeString(e,"client_order_id"),y=this.safeStringUpper(e,"time_in_force");return this.safeOrder({id:i,info:e,clientOrderId:g,timestamp:d,datetime:this.iso8601(d),lastTradeTimestamp:void 0,symbol:o,type:n,timeInForce:y,side:r,status:s,price:c,stopPrice:void 0,amount:p,filled:u,remaining:h,average:void 0,cost:m,fee:void 0,trades:void 0},t)}costToPrecision(e,t){return this.decimalToPrecision(t,IG,this.markets[e].precision.cost,this.precisionMode)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeValue(this.options,"timeInForce"),d=this.safeValue(o,t),c=this.safeString2(r,"timeInForce","time_in_force",d),u={market_id:a.id,type:t,side:s,time_in_force:c},h=this.safeString2(r,"clientOrderId","client_order_id");h!==void 0&&(u.client_order_id=h);let l;if(t==="limit")u.limit_price=this.priceToPrecision(e,n),u.quantity=this.amountToPrecision(e,i);else if(t==="market")if(s==="buy"){let b=this.safeNumber(r,"cost");if(this.safeValue(this.options,"createMarketBuyOrderRequiresPrice",!0)){if(n!==void 0)b===void 0&&(b=i*n);else if(b===void 0)throw new Jv(this.id+" createOrder() requires the price argument for market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total cost value in the 'amount' argument or in the 'cost' extra parameter (the exchange-specific behaviour)")}else b=b===void 0?i:b;l=this.costToPrecision(e,b),u.cost=l}else u.quantity=this.amountToPrecision(e,i);const p=this.omit(r,["timeInForce","time_in_force","clientOrderId","client_order_id"]),m=await this.privatePostNewOrder(this.extend(u,p)),g=this.safeValue(m,"data"),y=this.parseOrder(g,a);return t==="market"&&s==="buy"&&(y.amount=void 0,y.cost=this.parseNumber(l),y.remaining=void 0),y}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new eT(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const n={market_id:this.market(t).id,order_id:e},r=await this.privatePostCancelOrder(this.extend(n,s)),a=this.safeValue(r,"data");return this.parseOrder(a)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"destination_tag"),n=this.safeString(e,"currency_id");t=this.safeCurrency(n,t);const r=t.code,a=this.safeString(e,"platform_id");return this.checkAddress(s),{currency:r,address:s,tag:i,network:a,info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency_id:s.id},n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper(t,"network");r=this.safeString(n,r,r),r!==void 0&&(i.platform_id=r,t=this.omit(t,"platform_id"));const a=await this.privateGetDepositAddress(this.extend(i,t)),o=this.safeValue(a,"data",[]),d=this.safeValue(o,0);if(d===void 0)throw new tT(this.id+" fetchDepositAddress() returned an empty response");return this.parseDepositAddress(d,s)}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s={};if(e){const r=[];for(let a=0;a<e.length;a++){const o=this.currency(e[a]);r.push(o.id)}s.currency_id=e.join(",")}const i=await this.privateGetDepositAddress(this.extend(s,t)),n=this.safeValue(i,"data",[]);return this.parseDepositAddresses(n)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e);i===void 0&&(i="");const a={currency_id:r.id,address:s,destination_tag:i,amount:this.numberToString(t)},o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeString(o,d,d),d!==void 0&&(a.platform_id=d,n=this.omit(n,"network"));const c=await this.privatePostWithdrawal(this.extend(a,n)),u=this.safeValue(c,"data");return this.parseTransaction(u,r)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeNumber(e,"amount"),n=this.safeString(e,"address"),r=this.safeString(e,"destination_tag"),a=this.safeString(e,"hash"),o=this.parse8601(this.safeString(e,"time")),d=this.safeString(e,"type"),c=this.safeString(e,"currency_id"),u=this.safeCurrencyCode(c),h=this.parseTransactionStatus(this.safeString(e,"status")),l=this.safeNumber(e,"fee");let p;return l!==void 0&&l!==0&&(p={currency:u,cost:l}),{id:s,currency:u,amount:i,network:void 0,addressFrom:void 0,address:n,addressTo:n,tagFrom:void 0,tag:r,tagTo:r,status:h,type:d,txid:a,timestamp:o,datetime:this.iso8601(o),updated:void 0,fee:p,info:e}}parseTransactionStatus(e){const t={requested:"pending",pending:"pending",confirming:"pending",confirmed:"pending",applying:"pending",done:"ok",cancelled:"canceled",cancelling:"canceled"};return this.safeString(t,e,e)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/";const o=this.omit(i,this.extractParams(e));if(t==="accounts"){this.checkRequiredCredentials(),a+=this.implodeParams(e,i);const d=this.apiKey+":"+this.secret,c=this.stringToBase64(d);n={Authorization:"Basic "+this.decode(c),"Content-Type":"application/json"},Object.keys(o).length&&(r=this.json(o))}else if(a+=this.version+"/",t==="public")a+=this.implodeParams(e,i),Object.keys(o).length&&(a+="?"+this.urlencode(o));else if(t==="private"){const d=this.milliseconds();this.checkRequiredCredentials();const c=this.safeInteger(this.options,"expires");if(c===void 0||c<d)throw new ig(this.id+" access token expired, call signIn() method");n={Authorization:"Bearer "+this.safeString(this.options,"accessToken")},a+=this.implodeParams(e,i),s==="GET"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):Object.keys(o).length&&(r=this.json(o),n["Content-Type"]="application/json")}return{url:a,method:s,body:r,headers:n}}async signIn(e={}){this.checkRequiredCredentials();const t={grant_type:"client_credentials"},s=await this.accountsPostToken(this.extend(t,e)),i=this.safeInteger(s,"expires_in"),n=this.safeString(s,"access_token");return this.options.accessToken=n,this.options.expires=this.sum(this.milliseconds(),i*1e3),s}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&"errorCode"in a){const c=this.safeString(a,"errorCode"),u=this.safeString(a,"message");if(c!==void 0){const h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwBroadlyMatchedException(this.exceptions.exact,c,h),new SG(h)}}}};const CG=me,{ExchangeError:MG,InvalidOrder:sT,InsufficientFunds:PG,AuthenticationError:AG,RateLimitExceeded:BG,BadSymbol:NG}=oe,{TICK_SIZE:EG}=pe,iT=ke;var VG=class extends CG{describe(){return this.deepExtend(super.describe(),{id:"qtrade",name:"qTrade",countries:["US"],rateLimit:1e3,version:"v1",urls:{logo:"https://user-images.githubusercontent.com/51840849/80491487-74a99c00-896b-11ea-821e-d307e832f13e.jpg",api:{rest:"https://api.qtrade.io"},www:"https://qtrade.io",doc:"https://qtrade-exchange.github.io/qtrade-docs",referral:"https://qtrade.io/?ref=BKOQWVFGRH2C",fees:"https://qtrade.io/fees"},has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactions:void 0,fetchTransfer:!1,fetchTransfers:!0,fetchWithdrawal:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"5m":"fivemin","15m":"fifteenmin","30m":"thirtymin","1h":"onehour","2h":"twohour","4h":"fourhour","1d":"oneday"},api:{public:{get:["ticker/{market_string}","tickers","currency/{code}","currencies","common","market/{market_string}","markets","market/{market_string}/trades","orderbook/{market_string}","market/{market_string}/ohlcv/{interval}"]},private:{get:["me","balances","balances_all","market/{market_string}","orders","order/{order_id}","trades","withdraw/{withdraw_id}","withdraws","deposit/{deposit_id}","deposits","transfers"],post:["cancel_order","withdraw","deposit_address/{currency}","sell_limit","buy_limit"]}},fees:{trading:{feeSide:"quote",tierBased:!0,percentage:!0,taker:this.parseNumber("0.005"),maker:this.parseNumber("0.0")},funding:{withdraw:{}}},commonCurrencies:{BTM:"Bitmark"},precisionMode:EG,exceptions:{exact:{invalid_auth:AG,insuff_funds:PG,market_not_found:NG,too_small:sT,limit_exceeded:BG}}})}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"markets",[]),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"market_string"),d=this.safeInteger(a,"id"),c=this.safeString(a,"market_currency"),u=this.safeString(a,"base_currency"),h=this.safeCurrencyCode(c),l=this.safeCurrencyCode(u),p=this.safeValue(a,"can_view",!1),g=this.safeValue(a,"can_trade",!1)&&p;n.push({id:o,numericId:d,symbol:h+"/"+l,base:h,quote:l,settle:void 0,baseId:c,quoteId:u,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:g,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(a,"taker_fee"),maker:this.safeNumber(a,"maker_fee"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(a,"market_precision"))),price:this.parseNumber(this.parsePrecision(this.safeString(a,"base_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(a,"minimum_sell_value"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(a,"minimum_buy_value"),max:void 0}},info:a})}return n}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"currencies",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"code"),d=this.safeCurrencyCode(o),c=this.safeString(a,"long_name"),u=this.safeString(a,"type"),h=this.safeValue(a,"can_withdraw",!0),l=this.safeValue(a,"withdraw_disabled",!1),m=!this.safeValue(a,"deposit_disabled",!1),g=h&&!l,y=this.safeValue(a,"config",{}),b=this.safeString(a,"status"),w=g&&m&&b==="ok";n[d]={id:o,code:d,info:a,type:u,name:c,fee:this.safeNumber(y,"withdraw_fee"),precision:this.parseNumber(this.parsePrecision(this.safeString(a,"precision"))),active:w,deposit:m,withdraw:g,limits:{amount:{min:this.safeNumber(a,"minimum_order"),max:void 0},withdraw:{min:void 0,max:void 0}}}}return n}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"time")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"market_volume")]}async fetchOHLCV(e,t="5m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={market_string:r.id,interval:this.timeframes[t]},o=await this.publicGetMarketMarketStringOhlcvInterval(this.extend(a,n)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"slices",[]);return this.parseOHLCVs(c,r,t,s,i)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={market_string:i.id},r=await this.publicGetOrderbookMarketString(this.extend(n,s)),a=this.safeValue(r,"data",{}),o={},d={buy:"bids",sell:"asks"},c=Object.keys(d);for(let h=0;h<c.length;h++){const l=c[h],p=d[l],m=this.safeValue(a,l,{}),g=Object.keys(m),y=[];for(let b=0;b<g.length;b++){const w=g[b],S=this.safeNumber(g,b),k=this.safeNumber(m,w);y.push([S,k])}o[p]=y}const u=this.safeIntegerProduct(a,"last_change",.001);return this.parseOrderBook(o,i.symbol,u)}parseTicker(e,t=void 0){const s=this.safeString(e,"id_hr"),i=this.safeSymbol(s,t,"_"),n=this.safeIntegerProduct(e,"last_change",.001),r=this.safeString(e,"day_open"),a=this.safeString(e,"last"),o=this.safeString(e,"day_change"),d=this.safeString(e,"day_avg_price"),c=this.safeString(e,"day_volume_market"),u=this.safeString(e,"day_volume_base"),h=iT.stringMul(o,"100"),l=iT.stringMul(o,r);return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"day_high"),low:this.safeString(e,"day_low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:r,close:a,last:a,previousClose:void 0,change:l,percentage:h,average:d,baseVolume:c,quoteVolume:u,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTickers(t),i=this.safeValue(s,"data",{}),n=this.safeValue(i,"markets",[]),r={};for(let a=0;a<n.length;a++){const o=this.parseTicker(n[a]),d=o.symbol;r[d]=o}return this.filterByArray(r,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market_string:s.id},n=await this.publicGetTickerMarketString(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTicker(r,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market_string:n.id},a=await this.publicGetMarketMarketStringTrades(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"trades",[]);return this.parseTrades(d,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={desc:!0};let r;const a=this.safeValue(i,"market_id");a!==void 0?n.market_id=a:e!==void 0&&(r=this.market(e),n.market_string=r.id);const o=await this.privateGetTrades(this.extend(n,i)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"trades",[]);return this.parseTrades(c,r,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"id");let i=this.safeIntegerProduct(e,"created_at_ts",.001);i===void 0&&(i=this.parse8601(this.safeString(e,"created_at")));const n=this.safeString(e,"side"),r=this.safeString(e,"market_string");t=this.safeMarket(r,t);const a=this.safeString2(e,"base_volume","base_amount"),o=this.safeString(e,"price"),d=this.safeString2(e,"market_amount","amount");let c;const u=this.safeString(e,"base_fee");u!==void 0&&(c={currency:t===void 0?void 0:t.quote,cost:u});const l=this.safeValue(e,"taker",!0)?"taker":"maker",p=this.safeString(e,"order_id");return this.safeTrade({id:s,info:e,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,order:p,type:void 0,side:n,takerOrMaker:l,price:o,amount:d,cost:a,fee:c},t)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={market_string:s.id},n=await this.publicGetMarketMarketString(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"market",{});return{info:a,symbol:s.symbol,maker:this.safeNumber(a,"maker_fee"),taker:this.safeNumber(a,"taker_fee"),percentage:!0,tierBased:!0}}parseBalance(e){const t=this.safeValue(e,"data",{});let s=this.safeValue(t,"balances",[]);const i={info:e,timestamp:void 0,datetime:void 0};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=o in i?i[o]:this.account();d.free=this.safeString(r,"balance"),d.used="0",i[o]=d}s=this.safeValue(t,"order_balances",[]);for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=o in i?i[o]:this.account();d.used=this.safeString(r,"balance"),i[o]=d}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalancesAll(e);return this.parseBalance(t)}async createOrder(e,t,s,i,n=void 0,r={}){if(t!=="limit")throw new sT(this.id+" createOrder() allows limit orders only");await this.loadMarkets();const a=this.market(e),o={amount:this.amountToPrecision(a.symbol,i),market_id:a.numericId,price:this.priceToPrecision(a.symbol,n)},c=await this[s==="sell"?"privatePostSellLimit":"privatePostBuyLimit"](this.extend(o,r)),u=this.safeValue(c,"data",{}),h=this.safeValue(u,"order",{});return this.parseOrder(h,a)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.parse8601(this.safeString(e,"created_at")),n=this.safeString(e,"order_type");let r,a;if(n!==void 0){const y=n.split("_");a=this.safeString(y,0),r=this.safeString(y,1)}const o=this.safeString(e,"price"),d=this.safeString(e,"market_amount"),c=this.safeString(e,"market_amount_remaining"),u=this.safeValue(e,"open",!1),h=this.safeString(e,"close_reason");let l;u?l="open":h==="canceled"?l="canceled":l="closed";const p=this.safeString(e,"market_string");t=this.safeMarket(p,t,"_");const m=t.symbol,g=this.safeValue(e,"trades",[]);return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,symbol:m,type:r,timeInForce:void 0,postOnly:void 0,side:a,price:o,stopPrice:void 0,average:void 0,amount:d,remaining:c,filled:void 0,status:l,fee:void 0,fees:void 0,cost:void 0,trades:g},t)}async cancelOrder(e,t=void 0,s={}){const i={id:parseInt(e)};return await this.privatePostCancelOrder(this.extend(i,s))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privateGetOrderOrderId(this.extend(i,s)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"order",{});return this.parseOrder(a)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;const a=this.safeValue(i,"market_id");a!==void 0?n.market_id=a:e!==void 0&&(r=this.market(e),n.market_string=r.id);const o=await this.privateGetOrders(this.extend(n,i)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"orders",[]);return this.parseOrders(c,r,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={open:!0};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={open:!1};return await this.fetchOrders(e,t,s,this.extend(n,i))}parseDepositAddress(e,t=void 0){const s=t===void 0?void 0:t.code;let i=this.safeString(e,"address"),n;if(i!==void 0){const r=i.split(":");i=this.safeString(r,0),n=this.safeString(r,1)}return this.checkAddress(i),{currency:s,address:i,tag:n,network:void 0,info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=await this.privatePostDepositAddressCurrency(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseDepositAddress(r,s)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const i={deposit_id:e},n=await this.privateGetDepositDepositId(this.extend(i,s)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"deposit",{});return this.parseTransaction(a)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r=await this.privateGetDeposits(i),a=this.safeValue(r,"data",{}),o=this.safeValue(a,"deposits",[]);return this.parseTransactions(o,n,t,s)}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r=await this.privateGetTransfers(i),a=this.safeValue(r,"data",{}),o=this.safeValue(a,"transfers",[]);return this.parseTransfers(o,n,t,s)}parseTransfer(e,t=void 0){const s=this.safeString(e,"currency"),i=this.safeString(e,"created_at");return{info:e,id:this.safeString(e,"id"),timestamp:this.parse8601(i),datetime:i,currency:this.safeCurrencyCode(s,t),amount:this.safeNumber(e,"amount"),fromAccount:this.safeString(e,"sender_id"),toAccount:void 0,status:"ok"}}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const i={withdraw_id:e},n=await this.privateGetWithdrawWithdrawId(this.extend(i,s)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"withdraw",{});return this.parseTransaction(a)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r=await this.privateGetWithdraws(i),a=this.safeValue(r,"data",{}),o=this.safeValue(a,"withdraws",[]);return this.parseTransactions(o,n,t,s)}parseTransaction(e,t=void 0){const s=this.parse8601(this.safeString(e,"created_at")),i=this.safeString(e,"id"),n=this.safeValue(e,"network_data",{}),r=this.safeValue(n,"unsigned_tx",{}),a=this.safeString(r,"from"),o=this.safeString(n,"txid");let d=this.safeString(e,"address"),c;if(d!==void 0){const T=d.split(":");T.length>1&&(d=this.safeString(T,0),c=this.safeString(T,1))}const u=d,h=void 0,l=c,p=this.safeValue(e,"cancel_requested"),m=p===void 0?"deposit":"withdrawal",g=this.safeNumber(e,"amount"),y=this.safeString(e,"currency"),b=this.safeCurrencyCode(y);let w=this.parseTransactionStatus(this.safeString(e,"status"));const S=this.safeString(e,"code");p?w="canceled":w===void 0&&(w=this.parseTransactionStatus(S));const k=void 0;return{info:e,id:i,txid:o,timestamp:s,datetime:this.iso8601(s),network:void 0,addressFrom:a,addressTo:u,address:d,tagFrom:h,tagTo:l,tag:c,type:m,amount:g,currency:b,status:w,updated:void 0,fee:k}}parseTransactionStatus(e){const t={initiated:"pending",needs_create:"pending",credited:"ok",confirmed:"ok"};return this.safeString(t,e,e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets();const r=this.currency(e),a={address:s,amount:t,currency:r.id};i!==void 0&&(a.address+=":"+i);const o=await this.privatePostWithdraw(this.extend(a,n)),d=this.safeValue(o,"data",{}),c=this.parseTransaction(d);return this.extend(c,{currency:e,address:s,addressTo:s,tag:i,tagTo:i,amount:t})}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.version+"/";t==="private"&&(a+="user/"),a+=this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(s==="POST"?r=this.json(o):Object.keys(o).length&&(a+="?"+this.urlencode(o)),t==="private"){const d=this.milliseconds().toString(),u=[s,a,d,s==="POST"?r:"",this.secret].join(`
`),h=this.hash(this.encode(u),"sha256","base64");let l=this.apiKey;typeof l!="string"&&(l=l.toString()),n={Authorization:"HMAC-SHA256 "+l+":"+h,"HMAC-Timestamp":d},s==="POST"&&(n["Content-Type"]="application/json")}return a=this.urls.api.rest+a,{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeValue(a,"errors",[]);if(c.length<1)return;const h=this.id+" "+r;for(let l=0;l<c.length;l++){const p=c[l],m=this.safeString(p,"code");this.throwExactlyMatchedException(this.exceptions.exact,m,h)}throw new MG(h)}};const qG=me,{AuthenticationError:nT,ExchangeError:rg,BadSymbol:rT,BadRequest:ag,InvalidOrder:aT,ArgumentsRequired:lh,OrderNotFound:LG,InsufficientFunds:RG,DDoSProtection:FG}=oe,{TICK_SIZE:DG}=pe;var z_=class extends qG{describe(){return this.deepExtend(super.describe(),{id:"ripio",name:"Ripio",countries:["AR","BR"],rateLimit:50,version:"v1",pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/94507548-a83d6a80-0218-11eb-9998-28b9cec54165.jpg",api:{public:"https://api.exchange.ripio.com/api",private:"https://api.exchange.ripio.com/api"},www:"https://exchange.ripio.com",doc:["https://exchange.ripio.com/en/api/"],fees:"https://exchange.ripio.com/en/fee"},api:{public:{get:["rate/all/","rate/{pair}/","orderbook/{pair}/","tradehistory/{pair}/","pair/","currency/","orderbook/{pair}/depth/"]},private:{get:["balances/exchange_balances/","order/{pair}/{order_id}/","order/{pair}/","trade/{pair}/"],post:["order/{pair}/","order/{pair}/{order_id}/cancel/"]}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0"),maker:this.parseNumber("0.0")}},precisionMode:DG,requiredCredentials:{apiKey:!0,secret:!1},exceptions:{exact:{},broad:{"Authentication credentials were not provided":nT,"Disabled pair":rT,"Invalid order type":aT,"Your balance is not enough":RG,"Order couldn't be created":rg,"not found":LG,"Invalid pair":rT,"amount must be a number":ag,"Total must be at least":aT,"Account not found":ag,"Wrong password provided":nT,"User tokens limit":FG,"Something unexpected ocurred":rg,account_balance:ag}}})}async fetchMarkets(e={}){const t=await this.publicGetPair(e),s=[],i=this.safeValue(t,"results",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"base"),o=this.safeString(r,"quote"),d=this.safeString(r,"symbol"),c=this.safeCurrencyCode(a),u=this.safeCurrencyCode(o),h=this.safeValue(r,"fees",[]),l=this.safeValue(h,0,{});s.push({id:d,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:this.safeValue(r,"enabled",!0),contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(l,"taker_fee",0),maker:this.safeNumber(l,"maker_fee",0),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(r,"min_amount"),price:this.safeNumber(r,"price_tick")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"min_amount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(r,"min_value"),max:void 0}},info:r})}return s}async fetchCurrencies(e={}){const t=await this.publicGetCurrency(e),s=this.safeValue(t,"results",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.safeString(r,"name"),c=this.safeValue(r,"enabled",!0);i[o]={id:a,code:o,name:d,info:r,active:c,deposit:void 0,withdraw:void 0,fee:void 0,precision:this.parseNumber(this.parsePrecision(this.safeString(r,"decimal_places"))),limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}}}return i}parseTicker(e,t=void 0){const s=this.parse8601(this.safeString(e,"created_at")),i=this.safeString(e,"pair");t=this.safeMarket(i,t,"_");const n=t.symbol,r=this.safeString(e,"last_price"),a=this.safeString(e,"avg");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:this.safeString(e,"bid_volume"),ask:this.safeString(e,"ask"),askVolume:this.safeString(e,"ask_volume"),vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:a,baseVolume:void 0,quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetRatePair(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetRateAll(t),i={};for(let n=0;n<s.length;n++){const r=this.parseTicker(s[n]),a=r.symbol;i[a]=r}return this.filterByArray(i,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id},r=await this.publicGetOrderbookPair(this.extend(n,s)),a=this.parseOrderBook(r,i.symbol,void 0,"buy","sell","price","amount");return a.nonce=this.safeInteger(r,"updated_id"),a}parseTrade(e,t=void 0){const s=this.safeString(e,"id");let i=this.safeInteger(e,"timestamp");i=this.safeTimestamp(e,"created_at",i);let n=this.safeString(e,"side");const a=this.safeString(e,"taker_side")===n?"taker":"maker";n!==void 0&&(n=n.toLowerCase());const o=this.safeString2(e,"price","match_price"),d=this.safeString2(e,"amount","exchanged"),c=this.safeString(e,"pair");t=this.safeMarket(c,t);const u=this.safeString(e,a+"_fee"),h=this.safeString(e,a);let l;return u!==void 0&&(l={cost:u,currency:n==="buy"?t.base:t.quote}),this.safeTrade({id:s,order:h,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,type:void 0,side:n,price:o,amount:d,cost:void 0,takerOrMaker:a,fee:l,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id},a=await this.publicGetTradehistoryPair(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetPair(e),s=this.safeValue(t,"results",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeSymbol(a,void 0,"_"),d=this.safeValue(r,"fees",[]),c=this.safeValue(d,0,{});i[o]={info:r,symbol:o,maker:this.safeNumber(c,"maker_fee"),taker:this.safeNumber(c,"taker_fee"),tierBased:!1}}return i}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"symbol"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"available"),a.used=this.safeString(i,"locked"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalancesExchangeBalances(e);return this.parseBalance(t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=t.toUpperCase(),d=s.toUpperCase(),c={pair:a.id,order_type:o,side:d,amount:this.amountToPrecision(e,i)};o==="LIMIT"&&(c.limit_price=this.priceToPrecision(e,n));const u=await this.privatePostOrderPair(this.extend(c,r));return this.parseOrder(u,a)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new lh(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={pair:i.id,order_id:e},r=await this.privatePostOrderPairOrderIdCancel(this.extend(n,s));return this.parseOrder(r,i)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new lh(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={pair:i.id,order_id:e},r=await this.privateGetOrderPairOrderId(this.extend(n,s));return this.parseOrder(r,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new lh(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={pair:n.id};s!==void 0&&(r.offset=s);const a=await this.privateGetOrderPair(this.extend(r,i)),o=this.safeValue(a,"results",{}),d=this.safeValue(o,"data",[]);return this.parseOrders(d,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"OPEN,PART"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"CLOS,CANC,COMP"};return await this.fetchOrders(e,t,s,this.extend(n,i))}parseOrderStatus(e){const t={OPEN:"open",PART:"open",CLOS:"canceled",CANC:"canceled",COMP:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"order_id"),i=this.safeString(e,"amount"),n=this.safeString(e,"notional"),r=this.safeStringLower(e,"order_type"),a=r==="market"?"fill_price":"limit_price",o=this.safeString(e,a),d=this.safeStringLower(e,"side"),c=this.parseOrderStatus(this.safeString(e,"status")),u=this.safeTimestamp(e,"created_at"),h=this.safeString(e,"fill_price"),l=this.safeString(e,"filled"),p=this.safeValue(e,"fills"),m=this.safeString(e,"pair");return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:u,datetime:this.iso8601(u),lastTradeTimestamp:void 0,symbol:this.safeSymbol(m,t,"_"),type:r,timeInForce:void 0,postOnly:void 0,side:d,price:o,stopPrice:this.safeString(e,"stop_price"),amount:i,cost:n,average:h,filled:l,remaining:void 0,status:c,fee:void 0,trades:p},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new lh(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={pair:n.id};s!==void 0&&(r.limit=s);const a=await this.privateGetTradePair(this.extend(r,i)),o=this.safeValue(a,"results",{}),d=this.safeValue(o,"data",[]);return this.parseTrades(d,n,t,s)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a="/"+this.version+"/"+this.implodeParams(e,i);let o=this.urls.api[t]+a;const d=this.omit(i,this.extractParams(e));return t==="public"?Object.keys(d).length&&(o+="?"+this.urlencode(d)):t==="private"&&(this.checkRequiredCredentials(),s==="POST"?r=this.json(d):Object.keys(d).length&&(o+="?"+this.urlencode(d)),n={"Content-Type":"application/json",Authorization:"Bearer "+this.apiKey}),{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"detail");if(c!==void 0){const h=this.id+" "+r;this.throwBroadlyMatchedException(this.exceptions.broad,c,h)}const u=this.safeValue(a,"errors");if(u!==void 0){const h=this.id+" "+r,l=Object.keys(u);for(let p=0;p<l.length;p++){const m=l[p],g=this.safeValue(u,m,[]),y=this.safeString(g,0);this.throwBroadlyMatchedException(this.exceptions.broad,y,h)}throw new rg(h)}}};const HG=me,{ArgumentsRequired:GG,AuthenticationError:UG,ExchangeError:Go,InsufficientFunds:$G,OrderNotFound:oT,PermissionDenied:dT,BadRequest:jG,BadSymbol:WG,DDoSProtection:zG,InvalidOrder:KG,AccountSuspended:XG}=oe,{TICK_SIZE:YG}=pe,Un=ke;var QG=class extends HG{describe(){return this.deepExtend(super.describe(),{id:"stex",name:"STEX",countries:["EE"],rateLimit:1e3/3,certified:!1,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createMarketOrder:!1,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrder:!0,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactionFees:!0,fetchWithdrawal:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!0,withdraw:!0},version:"v3",urls:{logo:"https://user-images.githubusercontent.com/1294454/69680782-03fd0b80-10bd-11ea-909e-7f603500e9cc.jpg",api:{rest:"https://api3.stex.com"},www:"https://www.stex.com",doc:["https://apidocs.stex.com/","https://help.stex.com/en/collections/1593608-api-v3-documentation"],fees:"https://app.stex.com/en/pairs-specification",referral:"https://app.stex.com?ref=36416021"},requiredCredentials:{apiKey:!1,secret:!1,token:!0},timeframes:{"1m":"1","5m":"5","30m":"30","1h":"60","4h":"240","12h":"720","1d":"1D"},api:{public:{get:{currencies:1,"currencies/{currencyId}":1,markets:1,"pairs-groups":1,"currency_pairs/list/{code}":1,"currency_pairs/group/{currencyPairGroupId}":1,"currency_pairs/{currencyPairId}":1,ticker:1,"ticker/{currencyPairId}":1,"trades/{currencyPairId}":1,"orderbook/{currencyPairId}":1,"chart/{currencyPairId}/{candlesType}":1,"deposit-statuses":1,"deposit-statuses/{statusId}":1,"withdrawal-statuses":1,"withdrawal-statuses/{statusId}":1,ping:1,"mobile-versions":1,twitter:1}},trading:{get:{"fees/{currencyPairId}":1,orders:12,"orders/{currencyPairId}":6,"order/{orderId}":12},post:{"orders/{currencyPairId}":1.5,"orders/bulk/{currencyPairId}":12},delete:{orders:30,"orders/{currencyPairId}":12,"order/{orderId}":1.5}},reports:{get:{currencies:12,currency_pairs:12,orders:12,"orders/{orderId}":12,"trades/{currencyPairId}":12,"background/{listMode}":12,"background/{id}":12,"background/download/{id}":12},post:{"background/create":12},delete:{"background/{id}":12}},profile:{get:{info:3,wallets:3,"wallets/{walletId}":3,"wallets/address/{walletId}":3,deposits:3,"deposits/{id}":3,rewards:3,"rewards/{id}":3,addressbook:3,"addressbook/{itemId}":3,withdrawals:3,"withdrawals/{id}":3,notifications:3,"notifications/price":3,"favorite/currency_pairs":3,"token-scopes":3},post:{"wallets/burn/{walletId}":3,"wallets/{walletId}/hold_amount":3,"wallets/{currencyId}":3,"wallets/address/{walletId}":3,"addressbook/disable_item/{itemId}":3,"addressbook/enable_item/{itemId}":3,"addressbook/enable_strict_wd":3,"addressbook/disable_strict_wd":3,withdraw:30,"notifications/price":3,"referral/program":3,"referral/insert/{code}":3,"referral/bonus_transfer/{currencyId}":3},put:{"favorite/currency_pairs/set":3},delete:{"addressbook/{itemId}":3,"withdraw/{withdrawalId}":30,"notifications/price/{priceAlertId}":3}},verification:{get:{countries:1,status:1,"fractal/url":1,"smart-id":1,stex:1,"cryptonomica/code":1},post:{"smart-id":1,stex:1,cryptonomica:1}},settings:{get:{"notifications/{event}":1,notifications:1},put:{notifications:1,"notifications/set":1}}},fees:{trading:{tierBased:!1,percentage:!0,taker:this.parseNumber("0.002"),maker:this.parseNumber("0.002")}},commonCurrencies:{BC:"Bitcoin Confidential",BITS:"Bitcoinus",BITSW:"BITS",BHD:"Bithold",BTH:"Bithereum",MPH:"Chasyr Token",SBTC:"SBTCT"},options:{parseOrderToPrecision:!1,networks:{ERC20:5,ETH:5,OMNI:10,XLM:20,BEP2:22,TRC20:24,TRX:24,SOL:25,BEP20:501},accountsByType:{spot:"spot",hold:"hold",funding:"funding",referal:"referal"},transfer:{fillResponseFromRequest:!0}},precisionMode:YG,exceptions:{exact:{"Wrong parameters":jG,"Unauthenticated.":UG,"Server Error":Go,"This feature is only enabled for users verifies by Cryptonomica":dT,"Too Many Attempts.":zG,"Selected Pair is disabled":WG,"Invalid scope(s) provided.":dT,"The maximum amount of open orders with the same price cannot exceed 10":KG,"Your account not verified!":XG},broad:{"Not enough":$G}}})}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s={},i=this.safeValue(t,"data",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"id"),o=this.safeInteger(r,"id"),d=this.safeCurrencyCode(this.safeString(r,"code")),c=this.parseNumber(this.parsePrecision(this.safeString(r,"precision"))),u=this.safeNumber(r,"withdrawal_fee_const"),h=this.safeValue(r,"active",!0);s[d]={id:a,numericId:o,code:d,info:r,type:void 0,name:this.safeString(r,"name"),active:h,deposit:void 0,withdraw:void 0,fee:u,precision:c,limits:{amount:{min:c,max:void 0},deposit:{min:this.safeNumber(r,"minimum_deposit_amount"),max:void 0},withdraw:{min:this.safeNumber(r,"minimum_withdrawal_amount"),max:void 0}}}}return s}async fetchMarkets(e={}){const t={code:"ALL"},s=await this.publicGetCurrencyPairsListCode(this.extend(t,e)),i=[],n=this.safeValue(s,"data",[]);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeString(a,"id"),d=this.safeInteger(a,"id"),c=this.safeString(a,"currency_id"),u=this.safeString(a,"market_currency_id"),h=this.safeInteger(a,"currency_id"),l=this.safeInteger(a,"market_currency_id"),p=this.safeCurrencyCode(this.safeString(a,"currency_code")),m=this.safeCurrencyCode(this.safeString(a,"market_code")),g=this.safeString(a,"min_buy_price"),y=this.safeString(a,"min_sell_price"),b=Un.stringMax(g,y),w=Un.stringDiv(this.safeString(a,"buy_fee_percent"),"100"),S=Un.stringDiv(this.safeString(a,"sell_fee_percent"),"100"),k=Un.stringMax(w,S);i.push({id:o,numericId:d,symbol:p+"/"+m,base:p,quote:m,settle:void 0,baseId:c,quoteId:u,settleId:void 0,baseNumericId:h,quoteNumericId:l,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:this.safeValue(a,"active"),contract:!1,linear:void 0,inverse:void 0,taker:k,maker:k,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(a,"currency_precision"))),price:this.parseNumber(this.parsePrecision(this.safeString(a,"market_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(a,"min_order_amount"),max:void 0},price:{min:b,max:void 0},cost:{min:void 0,max:void 0}},info:a})}return i}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={currencyPairId:s.id},n=await this.publicGetTickerCurrencyPairId(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTicker(r,s)}async fetchTime(e={}){const t=await this.publicGetPing(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"server_datetime",{});return this.parse8601(this.safeString(i,"date"))}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={currencyPairId:this.market(e).id};t!==void 0&&(n.limit_bids=t,n.limit_asks=t);const r=await this.publicGetOrderbookCurrencyPairId(this.extend(n,s)),a=this.safeValue(r,"data",{});return this.parseOrderBook(a,e,void 0,"bid","ask","price","amount")}parseTicker(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString2(e,"id","symbol"),n=this.safeSymbol(i,t,"_"),r=this.safeString(e,"last"),a=this.safeString(e,"open");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:a,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volumeQuote"),quoteVolume:this.safeString(e,"volume"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTicker(t),i=this.safeValue(s,"data",[]);return this.parseTickers(i,e)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"time"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={currencyPairId:r.id,candlesType:this.timeframes[t]};i===void 0?i=100:a.limit=i;const o=this.parseTimeframe(t),d=i*o;s===void 0?(a.timeEnd=this.seconds(),a.timeStart=a.timeEnd-d):(a.timeStart=parseInt(s/1e3),a.timeEnd=this.sum(a.timeStart,d));const c=await this.publicGetChartCurrencyPairIdCandlesType(this.extend(a,n)),u=this.safeValue(c,"data",[]);return this.parseOHLCVs(u,r,t,s,i)}parseTrade(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeTimestamp(e,"timestamp"),n=this.safeString(e,"price"),r=this.safeString(e,"amount");let a;a===void 0&&t!==void 0&&(a=t.symbol);const o=this.safeStringLower2(e,"type","trade_type");return this.safeTrade({info:e,timestamp:i,datetime:this.iso8601(i),symbol:a,id:s,order:void 0,type:void 0,takerOrMaker:void 0,side:o,price:n,amount:r,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={currencyPairId:n.id};s!==void 0&&(r.limit=s),t!==void 0&&(r.sort="ASC",r.from=parseInt(t/1e3));const a=await this.publicGetTradesCurrencyPairId(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={currencyPairId:s.id},n=await this.tradingGetFeesCurrencyPairId(this.extend(i,t)),r=this.safeValue(n,"data");return{info:n,symbol:s.symbol,maker:this.safeNumber(r,"sell_fee"),taker:this.safeNumber(r,"buy_fee"),percentage:!0,tierBased:!0}}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"data",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeCurrencyCode(this.safeString(n,"currency_id")),a=this.account();a.free=this.safeString(n,"balance"),a.used=this.safeString(n,"frozen_balance"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.profileGetWallets(e);return this.parseBalance(t)}parseOrderStatus(e){const t={PROCESSING:"open",PENDING:"open",PARTIAL:"open",FINISHED:"closed",CANCELLED:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.parseOrderStatus(this.safeString(e,"status")),n=this.safeString2(e,"currency_pair_id","currency_pair_name"),r=this.safeSymbol(n,t,"_"),a=this.safeTimestamp(e,"timestamp"),o=this.safeString(e,"price"),d=this.safeString(e,"initial_amount"),c=this.safeString(e,"processed_amount");let u,h;c!==void 0&&(d!==void 0&&(u=Un.stringSub(d,c),this.options.parseOrderToPrecision&&(u=this.amountToPrecision(r,u)),u=Un.stringMax(u,"0.0")),o!==void 0&&h===void 0&&(h=Un.stringMul(o,c)));let l=this.safeString(e,"original_type");(l==="BUY"||l==="SELL")&&(l=void 0);const p=this.safeStringLower(e,"type"),m=this.safeValue(e,"trades"),g=this.safeNumber(e,"trigger_price"),y={info:e,id:s,clientOrderId:void 0,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:void 0,symbol:r,type:l,timeInForce:void 0,postOnly:void 0,side:p,price:o,stopPrice:g,amount:d,cost:h,average:void 0,filled:c,remaining:u,status:i,trades:m},b=this.safeValue(e,"fees");if(b===void 0)y.fee=void 0;else if(b.length>0){y.fees=[];for(let S=0;S<b.length;S++){const k=this.safeString(b[S],"amount");if(k!==void 0){const T=this.safeString(b[S],"currency_id"),I=this.safeCurrencyCode(T);y.fees.push({cost:k,currency:I})}}}else y.fee=void 0;return this.safeOrder(y,t)}async createOrder(e,t,s,i,n=void 0,r={}){if(t==="market")throw new Go(this.id+" createOrder() allows limit orders only");await this.loadMarkets();const a=this.market(e);t==="limit"&&(t=s);const o={currencyPairId:a.id,type:t.toUpperCase(),amount:parseFloat(this.amountToPrecision(e,i)),price:parseFloat(this.priceToPrecision(e,n))},d=await this.tradingPostOrdersCurrencyPairId(this.extend(o,r)),c=this.safeValue(d,"data",{});return this.parseOrder(c,a)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e},n=await this.tradingGetOrderOrderId(this.extend(i,s)),r=this.safeValue(n,"data",{});let a;return t!==void 0&&(a=this.market(t)),this.parseOrder(r,a)}async fetchClosedOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e},n=await this.reportsGetOrdersOrderId(this.extend(i,s)),r=this.safeValue(n,"data",{});let a;return t!==void 0&&(a=this.market(t)),this.parseOrder(r,a)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){return(await this.fetchClosedOrder(e,t,n)).trades}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r="tradingGetOrders";const a={};e!==void 0&&(r="tradingGetOrdersCurrencyPairId",n=this.market(e),a.currencyPairId=n.id),s!==void 0&&(a.limit=s);const o=await this[r](this.extend(a,i)),d=this.safeValue(o,"data",[]);return this.parseOrders(d,n,t,s)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e},n=await this.tradingDeleteOrderOrderId(this.extend(i,s)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"put_into_processing_queue",[]),o=this.safeValue(r,"not_put_into_processing_queue",[]),d=a.length,c=o.length;if(d<1){if(c<1)throw new oT(this.id+" cancelOrder() received an empty response: "+this.json(n));return this.parseOrder(o[0])}else{if(c<1)return this.parseOrder(a[0]);throw new oT(this.id+" cancelOrder() received an empty response: "+this.json(n))}}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i="tradingDeleteOrders";if(e!==void 0){const r=this.market(e);s.currencyPairId=r.id,i="tradingDeleteOrdersCurrencyPairId"}return await this[i](this.extend(s,t))}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new GG(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={currencyPairId:n.id};t!==void 0&&(r.timeStart=this.iso8601(t)),s!==void 0&&(r.limit=s);const a=await this.reportsGetTradesCurrencyPairId(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async createDepositAddress(e,t={}){await this.loadMarkets();const i={currencyId:this.currency(e).id},n=await this.profilePostWalletsCurrencyId(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"deposit_address",{}),o=this.safeString(a,"address"),d=this.safeString(a,"additional_address_parameter");return this.checkAddress(o),{currency:e,address:o,tag:d,info:n}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=await this.fetchBalance(),i=this.safeValue(s.info,"data",[]),n=this.indexBy(i,"currency_id"),r=this.currency(e),a=this.safeValue(n,r.id);if(a===void 0)throw new Go(this.id+" fetchDepositAddress() could not find the wallet id for currency code "+e+", try to call createDepositAddress() first");const o=this.safeInteger(a,"id");if(o===void 0)throw new Go(this.id+" fetchDepositAddress() could not find the wallet id for currency code "+e+", try to call createDepositAddress() first");const d={walletId:o},c=await this.profileGetWalletsWalletId(this.extend(d,t)),u=this.safeValue(c,"data",[]),h=this.safeValue(u,"deposit_address",{}),l=this.safeString(h,"address"),p=this.safeString(h,"additional_address_parameter");return this.checkAddress(l),{currency:e,address:l,tag:p,network:void 0,info:c}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+t+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));return t==="public"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):(this.checkRequiredCredentials(),n={Authorization:"Bearer "+this.token},s==="GET"||s==="DELETE"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):(r=this.json(o),Object.keys(o).length&&(n["Content-Type"]="application/json"))),{url:a,method:s,body:r,headers:n}}parseTransactionStatus(e){const t={processing:"pending","checking by system":"pending",hodl:"pending","amount too low":"failed","not confirmed":"pending","cancelled by user":"canceled",approved:"pending",finished:"ok","withdrawal error":"failed","deposit error":"failed","cancelled by admin":"canceled",awaiting:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeValue(e,"withdrawal_address",{}),n=this.safeString(i,"address"),r=this.safeString(i,"additional_address_parameter"),a=this.safeString(e,"currency_id");let o;a in this.currencies_by_id?t=this.currencies_by_id[a]:o=this.commonCurrencyCode(this.safeString(e,"currency_code")),o===void 0&&t!==void 0&&(o=t.code);const d="deposit_status_id"in e?"deposit":"withdrawal",c=this.safeNumber(e,"amount"),u=this.parseTransactionStatus(this.safeStringLower(e,"status")),h=this.safeTimestamp2(e,"timestamp","created_ts"),l=this.safeTimestamp(e,"updated_ts"),p=this.safeString(e,"txid");let m;const g=this.safeNumber(e,"fee");if(g!==void 0){const b=this.safeString2(e,"fee_currency_id","deposit_fee_currency_id"),w=this.safeCurrencyCode(b);m={cost:g,currency:w}}const y=this.safeString(i,"protocol_name");return{info:e,id:s,txid:p,timestamp:h,datetime:this.iso8601(h),network:y,addressFrom:void 0,address:n,addressTo:n,tagFrom:void 0,tag:r,tagTo:r,type:d,amount:c,currency:o,status:u,updated:l,fee:m}}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.profileGetDepositsId(this.extend(i,s)),r=this.safeValue(n,"data",{});return this.parseTransaction(r)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.currencyId=n.id),s!==void 0&&(r.limit=s),t!==void 0&&(r.timeStart=t);const a=await this.profileGetDeposits(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s)}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.profileGetWithdrawalsId(this.extend(i,s)),r=this.safeValue(n,"data",{});return this.parseTransaction(r)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.currencyId=n.id),s!==void 0&&(r.limit=s),t!==void 0&&(r.timeStart=t);const a=await this.profileGetWithdrawals(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e);let a;const o={};if(s==="referal"&&i==="spot")o.currencyId=r.id,a="profilePostReferralBonusTransferCurrencyId";else if(i==="hold")o.walletId=s,t=this.currencyToPrecision(e,t),t=Un.stringNeg(t),o.amount=t,a="profilePostWalletsWalletIdHoldAmount";else if(s==="hold")o.walletId=i,o.amount=t,a="profilePostWalletsWalletIdHoldAmount";else throw new Go(this.id+" transfer() only allows transfers of referal to spot and between a walletId and funding");const d=await this[a](this.extend(o,n)),c=this.safeValue(d,"data",{}),u=this.parseTransfer(c,r),h=this.safeValue(this.options,"transfer",{});return this.safeValue(h,"fillResponseFromRequest",!0)&&(u.fromAccount=s,u.toAccount=i,typeof t=="string"&&Un.stringLt(t,"0")&&(t=this.parseNumber(Un.stringNeg(t))),u.amount=t,u.currency===void 0&&(u.currency=e)),u}parseTransfer(e,t=void 0){const s=this.safeString(e,"currency_id");let i;return s in this.currencies_by_id?t=this.currencies_by_id[s]:i=this.commonCurrencyCode(this.safeString(e,"currency_code")),i===void 0&&(i=this.safeValue(t,"code")),{info:e,id:this.safeString(e,"id"),timestamp:void 0,datetime:void 0,currency:i,amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency_id:r.id,amount:parseFloat(this.currencyToPrecision(e,t)),address:s};i!==void 0&&(a.additional_address_parameter=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeInteger(o,d,d),d!==void 0&&(a.protocol_id=d,n=this.omit(n,"network"));const c=await this.profilePostWithdraw(this.extend(a,n)),u=this.safeValue(c,"data",{});return this.parseTransaction(u,r)}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=Object.keys(this.currencies),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.currencies[r];if(e!==void 0&&!this.inArray(r,e))continue;const o=this.safeValue(a,"info");i[r]={withdraw:this.safeNumber(a,"fee"),deposit:this.safeNumber(o,"deposit_fee_const"),info:o}}return i}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;if(!this.safeValue(a,"success",!1)){const u=this.safeString(a,"message"),h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwBroadlyMatchedException(this.exceptions.broad,u,h),new Go(h)}}};const ZG=me,{ExchangeError:cT,ArgumentsRequired:og,BadRequest:za,OrderNotFound:JG,InvalidAddress:uT}=oe,{TICK_SIZE:e7}=pe,Zr=ke;var t7=class extends ZG{describe(){return this.deepExtend(super.describe(),{id:"therock",name:"TheRockTrading",countries:["MT"],rateLimit:100,version:"v1",has:{CORS:void 0,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelOrder:!0,createOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransactions:"emulated",fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawals:!0,transfer:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766869-75057fa2-5ee9-11e7-9a6f-13e641fa4707.jpg",api:{rest:"https://api.therocktrading.com"},www:"https://therocktrading.com",doc:["https://api.therocktrading.com/doc/v1/index.html","https://api.therocktrading.com/doc/"]},api:{public:{get:{funds:1,"funds/{id}":1,"funds/{id}/orderbook":1,"funds/{id}/ticker":1,"funds/{id}/trades":1,"funds/{id}/ohlc_statistics":1,"funds/tickers":1}},private:{get:{balances:1,"balances/{id}":1,discounts:1,"discounts/{id}":1,funds:1,"funds/{id}":1,"funds/{id}/trades":1,"funds/{fund_id}/orders":1,"funds/{fund_id}/orders/{id}":1,"funds/{fund_id}/position_balances":1,"funds/{fund_id}/positions":1,"funds/{fund_id}/positions/{id}":1,transactions:1,"transactions/{id}":1,"withdraw_limits/{id}":1,withdraw_limits:1},post:{"atms/withdraw":1,"funds/{fund_id}/orders":1},delete:{"funds/{fund_id}/orders/{id}":1,"funds/{fund_id}/orders/remove_all":1}}},fees:{trading:{maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{BTC:0,BCH:0,PPC:0,ETH:0,ZEC:0,LTC:0,EUR:0}}},precisionMode:e7,exceptions:{exact:{"Request already running":za,"cannot specify multiple address types":za,"Currency is not included in the list":za,"Record not found":JG},broad:{"before must be greater than after param":za,"must be shorter than 60 days":za,"must be a multiple of (period param) in minutes":za,"Address allocation limit reached for currency":uT,"is not a valid value for param currency":za," is invalid":uT}},options:{withdraw:{fillResponseFromRequest:!0}}})}async fetchMarkets(e={}){const t=await this.publicGetFunds(e),s=this.safeValue(t,"funds"),i=[];if(s===void 0)throw new cT(this.id+" fetchMarkets() got an unexpected response");for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"id"),o=this.safeString(r,"trade_currency"),d=this.safeString(r,"base_currency"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d),h=this.safeString(r,"buy_fee"),l=this.safeString(r,"sell_fee");let p=Zr.stringMax(h,l);p=this.parseNumber(Zr.stringDiv(p,"100"));const m=this.safeValue(r,"leverages"),g=m.length;i.push({id:a,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:g>0,swap:!1,future:!1,option:!1,contract:!1,linear:void 0,inverse:void 0,taker:p,maker:p,contractSize:void 0,active:!0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"trade_currency_decimals"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"base_currency_decimals")))},limits:{leverage:{min:1,max:this.safeValue(m,g-1,1)},amount:{min:this.safeNumber(r,"minimum_quantity_offer"),max:void 0},price:{min:this.safeNumber(r,"minimum_price_offer"),max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}parseBalance(e){const t=this.safeValue(e,"balances",[]),s={info:e};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(n,"trading_balance"),o.total=this.safeString(n,"balance"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalances(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={id:i.id},r=await this.publicGetFundsIdOrderbook(this.extend(n,s)),a=this.parse8601(this.safeString(r,"date"));return this.parseOrderBook(r,i.symbol,a,"bids","asks","price","amount")}parseTicker(e,t=void 0){const s=this.parse8601(this.safeString(e,"date"));t=this.safeMarket(void 0,t);const i=this.safeString(e,"last");return this.safeTicker({symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:i,last:i,previousClose:this.safeString(e,"close"),change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume_traded"),quoteVolume:this.safeString(e,"volume"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetFundsTickers(t),i=this.indexBy(s.tickers,"fund_id"),n=Object.keys(i),r={};for(let a=0;a<n.length;a++){const o=n[a],d=this.safeMarket(o),c=d.symbol,u=i[o];r[c]=this.parseTicker(u,d)}return this.filterByArray(r,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={id:s.id},n=await this.publicGetFundsIdTicker(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"fund_id"),i=this.safeSymbol(s,t),n=this.parse8601(this.safeString(e,"date")),r=this.safeString(e,"id"),a=this.safeString(e,"order_id"),o=this.safeString(e,"side"),d=this.safeString(e,"price"),c=this.safeString(e,"amount");let u,h;const l=this.safeValue(e,"transactions",[]),p=this.groupBy(l,"type"),m=this.safeValue(p,"paid_commission",[]);for(let g=0;g<m.length;g++)h===void 0&&(h="0.0"),h=Zr.stringAdd(h,this.safeString(m[g],"price"));return h!==void 0&&(u={cost:h,currency:t.quote}),this.safeTrade({info:e,id:r,order:a,timestamp:n,datetime:this.iso8601(n),symbol:i,type:void 0,side:o,takerOrMaker:void 0,price:d,amount:c,cost:void 0,fee:u},t)}parseLedgerEntryDirection(e){const t={affiliate_earnings:"in",atm_payment:"in",bought_currency_from_fund:"out",bought_shares:"out",paid_commission:"out",paypal_payment:"in",pos_payment:"in",released_currency_to_fund:"out",rollover_commission:"out",sold_currency_to_fund:"in",sold_shares:"in",transfer_received:"in",transfer_sent:"out",withdraw:"out"};return this.safeString(t,e,e)}parseLedgerEntryType(e){const t={affiliate_earnings:"referral",atm_payment:"transaction",bought_currency_from_fund:"trade",bought_shares:"trade",paid_commission:"fee",paypal_payment:"transaction",pos_payment:"transaction",released_currency_to_fund:"trade",rollover_commission:"fee",sold_currency_to_fund:"trade",sold_shares:"trade",transfer_received:"transfer",transfer_sent:"transfer",withdraw:"transaction"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"id");let i,n=this.safeString(e,"type");const r=this.parseLedgerEntryDirection(n);n=this.parseLedgerEntryType(n),(n==="trade"||n==="fee")&&(i=this.safeString(e,"trade_id"));const a=this.safeString(e,"currency"),o=this.safeCurrencyCode(a),d=this.safeNumber(e,"price"),c=this.parse8601(this.safeString(e,"date"));return{info:e,id:s,direction:r,account:void 0,referenceId:i,referenceAccount:void 0,type:n,currency:o,amount:d,before:void 0,after:void 0,status:"ok",timestamp:c,datetime:this.iso8601(c),fee:void 0}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),t!==void 0&&(n.after=this.iso8601(t));const a=await this.privateGetTransactions(this.extend(n,i)),o=this.safeValue(a,"transactions",[]);return this.parseLedger(o,r,t,s)}parseTransactionType(e){const t={withdraw:"withdrawal",atm_payment:"deposit"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"id","transaction_id"),i=this.parseTransactionType(this.safeString(e,"type")),n=this.safeValue(e,"transfer_detail",{}),r=this.safeString(n,"method");let a,o;r!==void 0&&r!=="wire_transfer"&&(a=this.safeString(n,"id"),o=this.safeString(n,"recipient"));const d=this.safeString(e,"currency"),c=this.safeCurrencyCode(d),u=this.safeNumber(e,"price"),h=this.parse8601(this.safeString(e,"date")),l="ok",p=this.safeString(n,"method");return{info:e,id:s,currency:c,amount:u,network:p,addressFrom:void 0,addressTo:o,address:o,tagFrom:void 0,tagTo:void 0,tag:void 0,status:l,type:i,updated:void 0,txid:a,timestamp:h,datetime:this.iso8601(h),fee:void 0}}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const n={type:"withdraw"};return await this.fetchTransactions(e,t,s,this.extend(n,i))}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){const n={type:"atm_payment"};return await this.fetchTransactions(e,t,s,this.extend(n,i))}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),t!==void 0&&(n.after=this.iso8601(t)),i=this.extend(n,i);const a=await this.privateGetTransactions(i),o=this.safeValue(a,"transactions",[]),d=["withdraw","atm_payment"],c=this.filterByArray(o,"type",d,!1);return this.parseTransactions(c,r,t,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets();const r=this.currency(e);t=this.currencyToPrecision(e,t);const a={currency:r.id,destination_address:s,amount:parseFloat(t)};i!==void 0&&(a.destination_tag=i);const o=await this.privatePostAtmsWithdraw(this.extend(a,n)),d=this.parseTransaction(o,r),c=this.safeValue(this.options,"withdraw",{});return this.safeValue(c,"fillResponseFromRequest",!0)&&(d.addressTo===s&&(d.addressTo=s),d.address===void 0&&(d.address=s),d.tagTo===void 0&&(d.tagTo=i),d.tag===void 0&&(d.tag=i),d.amount===void 0&&(d.amount=t)),d}parseOrderStatus(e){const t={active:"open",executed:"closed",deleted:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"fund_id"),n=this.safeSymbol(i,t),r=this.parseOrderStatus(this.safeString(e,"status")),a=this.parse8601(this.safeString(e,"date")),o=this.safeString(e,"type"),d=this.safeString(e,"side"),c=this.safeNumber(e,"amount"),u=this.safeNumber(e,"amount_unfilled");let h;c!==void 0&&u!==void 0&&(h=c-u);const l=this.safeNumber(e,"price");let p=this.safeValue(e,"trades"),m,g,y;if(p!==void 0){const w=p.length;if(w>0){p=this.parseTrades(p,t,void 0,void 0,{orderId:s}),m=0,h=0;for(let S=0;S<w;S++){const k=p[S];m=this.sum(m,k.cost),h=this.sum(h,k.amount)}h>0&&(g=m/h),y=p[w-1].timestamp}else m=0}const b=this.safeNumber(e,"conditional_price");return{id:s,clientOrderId:void 0,info:e,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:y,status:r,symbol:n,type:o,timeInForce:void 0,postOnly:void 0,side:d,price:l,stopPrice:b,cost:m,amount:c,filled:h,average:g,remaining:u,fee:void 0,trades:p}}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"active"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"executed"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new og(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={fund_id:n.id};t!==void 0&&(r.after=this.iso8601(t));const a=await this.privateGetFundsFundIdOrders(this.extend(r,i)),o=this.safeValue(a,"orders",[]);return this.parseOrders(o,n,t,s)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new og(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={id:e,fund_id:i.id},r=await this.privateGetFundsFundIdOrdersId(this.extend(n,s));return this.parseOrder(r)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets(),t==="market"&&(n=0);const o={fund_id:this.market(e).id,side:s,amount:i,price:n},d=await this.privatePostFundsFundIdOrders(this.extend(o,r));return this.parseOrder(d)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e,fund_id:this.marketId(t)},n=await this.privateDeleteFundsFundIdOrdersId(this.extend(i,s));return this.parseOrder(n)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.parseTimeframe(t),o=parseInt(a/60),d={id:r.id,period:o};s===void 0&&(d.after=this.iso8601(s));const c=await this.publicGetFundsIdOhlcStatistics(this.extend(d,n));return this.parseOHLCVs(c,r,t,s,i)}parseOHLCV(e,t=void 0){const s=this.safeString(e,"interval_starts_at");return[this.parse8601(s),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"base_volume")]}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new og(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={id:n.id};s!==void 0&&(r.per_page=s),t!==void 0&&(r.after=this.iso8601(t));const a=await this.privateGetFundsIdTrades(this.extend(r,i)),o=this.safeValue(a,"trades",[]);return this.parseTrades(o,n,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={id:n.id};s!==void 0&&(r.per_page=s),t!==void 0&&(r.after=this.iso8601(t));const a=await this.publicGetFundsIdTrades(this.extend(r,i));return this.parseTrades(a.trades,n,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e);let i={id:s.id};const n=await this.publicGetFundsId(this.extend(i,t));i={id:s.quoteId};const r=await this.privateGetDiscountsId(this.extend(i,t));return this.parseTradingFee(n,r,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetFunds(e),s=await this.privateGetDiscounts(e),i=this.safeValue(t,"funds",[]),n=this.safeValue(s,"discounts",[]),r={};for(let a=0;a<i.length;a++){const o=i[a],d=this.safeString(o,"id"),c=this.safeMarket(d),u=this.safeValue(c,"quoteId"),h=this.filterBy(n,"currency",u),l=this.parseTradingFee(o,h,c),p=l.symbol;r[p]=l}return r}parseTradingFee(e,t=void 0,s=void 0){const i=this.safeString(e,"id"),n=this.safeString(e,"buy_fee"),r=this.safeString(e,"sell_fee"),a=this.safeString(t,"discount","0"),o=Zr.stringSub("100",a),d=this.parseNumber(Zr.stringDiv(Zr.stringMul(n,o),"10000")),c=this.parseNumber(Zr.stringDiv(Zr.stringMul(r,o),"10000"));return{info:e,symbol:this.safeSymbol(i,s),maker:c,taker:d,percentage:!0,tierBased:!0}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(n=n===void 0?{}:n,t==="private"){if(this.checkRequiredCredentials(),Object.keys(o).length)if(s==="POST")r=this.json(o),n["Content-Type"]="application/json";else{const u=this.rawencode(o);u.length&&(a+="?"+u)}const d=this.nonce().toString(),c=d+a;n["X-TRT-KEY"]=this.apiKey,n["X-TRT-NONCE"]=d,n["X-TRT-SIGN"]=this.hmac(this.encode(c),this.encode(this.secret),"sha512")}else t==="public"&&Object.keys(o).length&&(a+="?"+this.rawencode(o));return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeValue(a,"errors",[]),u=c.length;if(u>0){const h=this.id+" "+r;for(let l=0;l<u;l++){const p=c[l],m=this.safeString(p,"message");this.throwExactlyMatchedException(this.exceptions.exact,m,h),this.throwBroadlyMatchedException(this.exceptions.broad,m,h)}throw new cT(h)}}};const s7=me,{ExchangeError:Rc,ArgumentsRequired:i7,ExchangeNotAvailable:dg,InsufficientFunds:fT,OrderNotFound:n7,DDoSProtection:r7,InvalidOrder:Ka,AuthenticationError:cg,PermissionDenied:a7}=oe,{TICK_SIZE:o7}=pe,hT=ke;var d7=class extends s7{describe(){return this.deepExtend(super.describe(),{id:"tidex",name:"Tidex",countries:["UK"],rateLimit:2e3,version:"3",userAgent:this.userAgents.chrome,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchCurrencies:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/30781780-03149dc4-a12e-11e7-82bb-313b269d24d4.jpg",api:{web:"https://gate.tidex.com/api",public:"https://api.tidex.com/api/3",private:"https://api.tidex.com/tapi"},www:"https://tidex.com",doc:"https://tidex.com/exchange/public-api",referral:"https://tidex.com/exchange",fees:["https://tidex.com/exchange/assets-spec","https://tidex.com/exchange/pairs-spec"]},api:{web:{get:["currency","pairs","tickers","orders","ordershistory","trade-data","trade-data/{id}"]},public:{get:["info","ticker/{pair}","depth/{pair}","trades/{pair}"]},private:{post:["getInfoExt","getInfo","Trade","ActiveOrders","OrderInfo","CancelOrder","TradeHistory","getDepositAddress","createWithdraw","getWithdraw"]}},fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0.001")}},commonCurrencies:{DSH:"DASH",EMGO:"MGO",MGO:"WMGO"},precisionMode:o7,exceptions:{exact:{803:Ka,804:Ka,805:Ka,806:Ka,807:Ka,831:fT,832:fT,833:n7},broad:{"Invalid pair name":Rc,"invalid api key":cg,"invalid sign":cg,"api key dont have trade permission":cg,"invalid parameter":Ka,"invalid order":Ka,"Requests too often":r7,"not available":dg,"data unavailable":dg,"external service unavailable":dg,"IP restricted":a7}},options:{fetchTickersMaxLength:2048},orders:{}})}async fetchCurrencies(e={}){const t=await this.webGetCurrency(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"symbol"),a=this.safeCurrencyCode(r);let d=this.safeValue(n,"visible")===!0;const c=this.safeValue(n,"withdrawEnable",!0),u=this.safeValue(n,"depositEnable",!0);(!c||!u)&&(d=!1);const h=this.safeString(n,"name"),l=this.safeNumber(n,"withdrawFee");s[a]={id:r,code:a,name:h,active:d,deposit:u,withdraw:c,precision:this.parseNumber(this.parsePrecision(this.safeString(n,"amountPoint"))),funding:{withdraw:{active:c,fee:l},deposit:{active:u,fee:this.parseNumber("0")}},limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.safeNumber(n,"withdrawMinAmount"),max:void 0},deposit:{min:this.safeNumber(n,"depositMinAmount"),max:void 0}},info:n}}return s}async fetchMarkets(e={}){const s=(await this.publicGetInfo(e)).pairs,i=Object.keys(s),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=s[a],[d,c]=a.split("_"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),l=this.safeInteger(o,"hidden");let p=this.safeString(o,"fee");p=hT.stringDiv(p,"100"),n.push({id:a,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:l===0,contract:!1,linear:void 0,inverse:void 0,taker:this.parseNumber(p),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(o,"decimal_places"))),price:this.parseNumber(this.parsePrecision(this.safeString(o,"decimal_places")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(o,"min_amount"),max:this.safeNumber(o,"max_amount")},price:{min:this.safeNumber(o,"min_price"),max:this.safeNumber(o,"max_price")},cost:{min:this.safeNumber(o,"min_total"),max:void 0}},info:o})}return n}parseBalance(e){const t=this.safeValue(e,"return"),s=this.safeTimestamp(t,"server_time"),i={info:e,timestamp:s,datetime:this.iso8601(s)},n=this.safeValue(t,"funds",{}),r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeCurrencyCode(o),c=this.safeValue(n,o,{}),u=this.account();u.free=this.safeString(c,"value"),u.used=this.safeString(c,"inOrders"),i[d]=u}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetInfoExt(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetDepthPair(this.extend(n,s));if(!(i.id in r))throw new Rc(this.id+" "+i.symbol+" order book is empty or not available");const o=r[i.id];return this.parseOrderBook(o,e)}async fetchOrderBooks(e=void 0,t=void 0,s={}){await this.loadMarkets();let i;if(e===void 0){if(i=this.ids.join("-"),i.length>2048){const o=this.ids.length;throw new Rc(this.id+" fetchOrderBooks() has "+o.toString()+" symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchOrderBooks")}}else i=this.marketIds(e),i=i.join("-");const n={pair:i};t!==void 0&&(n.limit=t);const r=await this.publicGetDepthPair(this.extend(n,s)),a={};i=Object.keys(r);for(let o=0;o<i.length;o++){const d=i[o],c=this.safeSymbol(d);a[c]=this.parseOrderBook(r[d],c)}return a}parseTicker(e,t=void 0){const s=this.safeTimestamp(e,"updated");t=this.safeMarket(void 0,t);const i=this.safeString(e,"last");return this.safeTicker({symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:i,last:i,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeString(e,"avg"),baseVolume:this.safeString(e,"vol_cur"),quoteVolume:this.safeString(e,"vol"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s=this.ids;if(e===void 0){const o=s.length;if(s=s.join("-"),s.length>this.options.fetchTickersMaxLength){const d=this.safeInteger(this.options,"fetchTickersMaxLength",2048);throw new i7(this.id+" fetchTickers() has "+o.toString()+" markets exceeding max URL length for this endpoint ("+d.toString()+" characters), please, specify a list of symbols of interest in the first argument to fetchTickers")}}else s=this.marketIds(e),s=s.join("-");const i={pair:s},n=await this.publicGetTickerPair(this.extend(i,t)),r={},a=Object.keys(n);for(let o=0;o<a.length;o++){const d=a[o],c=this.safeMarket(d),u=c.symbol;r[u]=this.parseTicker(n[d],c)}return this.filterByArray(r,"symbol",e)}async fetchTicker(e,t={}){return(await this.fetchTickers([e],t))[e]}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"timestamp");let i=this.safeString(e,"type");i==="ask"?i="sell":i==="bid"&&(i="buy");const n=this.safeString2(e,"rate","price"),r=this.safeString2(e,"trade_id","tid"),a=this.safeString(e,"order_id"),o=this.safeString(e,"pair"),d=this.safeSymbol(o,t),c=this.safeString(e,"amount"),u=this.parseNumber(n),h=this.parseNumber(c),l=this.parseNumber(hT.stringMul(n,c)),p="limit";let m,g;const y=this.safeNumber(e,"commission");if(y!==void 0){const w=this.safeString(e,"commissionCurrency"),S=this.safeCurrencyCode(w);g={cost:y,currency:S}}const b=this.safeValue(e,"is_your_order");return b!==void 0&&(m="taker",b&&(m="maker"),g===void 0&&(g=this.calculateFee(d,p,i,h,u,m))),{id:r,order:a,timestamp:s,datetime:this.iso8601(s),symbol:d,type:p,side:i,takerOrMaker:m,price:u,amount:h,cost:l,fee:g,info:e}}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetTradesPair(this.extend(r,i));return Array.isArray(a)&&a.length===0?[]:this.parseTrades(a[n.id],n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){if(t==="market")throw new Rc(this.id+" createOrder() allows limit orders only");const a=i.toString(),o=n.toString();await this.loadMarkets();const d=this.market(e),c={pair:d.id,type:s,amount:this.amountToPrecision(e,i),rate:this.priceToPrecision(e,n)},u=await this.privatePostTrade(this.extend(c,r));let h,l="open",p="0.0",m=a;const g=this.safeValue(u,"return");g!==void 0&&(h=this.safeString(g,"order_id"),h==="0"&&(h=this.safeString(g,"init_order_id"),l="closed"),p=this.safeString(g,"received",p),m=this.safeString(g,"remains",a));const y=this.milliseconds();return this.safeOrder({id:h,timestamp:y,datetime:this.iso8601(y),lastTradeTimestamp:void 0,status:l,symbol:e,type:t,side:s,price:o,cost:void 0,amount:a,remaining:m,filled:p,fee:void 0,info:u,clientOrderId:void 0,average:void 0,trades:void 0},d)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:parseInt(e)};return await this.privatePostCancelOrder(this.extend(i,s))}parseOrderStatus(e){const t={0:"open",1:"closed",2:"canceled",3:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.parseOrderStatus(this.safeString(e,"status")),n=this.safeTimestamp(e,"timestamp_created"),r=this.safeString(e,"pair"),a=this.safeSymbol(r,t);let o,d;const c=this.safeString(e,"rate");"start_amount"in e?(d=this.safeString(e,"start_amount"),o=this.safeString(e,"amount")):o=this.safeString(e,"amount");const u=void 0;return this.safeOrder({info:e,id:s,clientOrderId:void 0,symbol:a,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,type:"limit",timeInForce:void 0,postOnly:void 0,side:this.safeString(e,"type"),price:c,stopPrice:void 0,cost:void 0,amount:d,remaining:o,filled:void 0,status:i,fee:u,average:void 0,trades:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:parseInt(e)},n=await this.privatePostOrderInfo(this.extend(i,s));e=e.toString();const r=this.safeValue(n,"return",{}),a=this.safeValue(r,e);return this.parseOrder(this.extend({id:e},a))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.pair=r.id);const a=await this.privatePostActiveOrders(this.extend(n,i)),o=this.safeValue(a,"return",[]);return this.parseOrders(o,r,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.pair=n.id),s!==void 0&&(r.count=parseInt(s)),t!==void 0&&(r.since=parseInt(t/1e3));const a=await this.privatePostTradeHistory(this.extend(r,i)),o=this.safeValue(a,"return",[]);return this.parseTrades(o,n,t,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={asset:r.id,amount:parseFloat(t),address:s};i!==void 0&&(a.memo=i);const o=await this.privatePostCreateWithdraw(this.extend(a,n)),d=this.safeValue(o,"return",{}),c=this.safeValue(d,"withdraw_info",{});return this.parseTransaction(c,r)}parseTransaction(e,t=void 0){return t=this.safeCurrency(void 0,t),{id:this.safeString(e,"id"),txid:void 0,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0,info:e}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t];const o=this.omit(i,this.extractParams(e));if(t==="private"){this.checkRequiredCredentials();const d=this.nonce();r=this.urlencode(this.extend({nonce:d,method:e},o));const c=this.hmac(this.encode(r),this.encode(this.secret),"sha512");n={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:c}}else t==="public"?(a+="/"+this.implodeParams(e,i),Object.keys(o).length&&(a+="?"+this.urlencode(o))):(a+="/"+this.implodeParams(e,i),s==="GET"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):Object.keys(o).length&&(r=this.json(o),n={"Content-Type":"application/json"}));return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&"success"in a){let c=this.safeValue(a,"success",!1);if(typeof c=="string"&&(c==="true"||c==="1"?c=!0:c=!1),!c){const u=this.safeString(a,"code"),h=this.safeString(a,"error"),l=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,l),this.throwExactlyMatchedException(this.exceptions.exact,h,l),this.throwBroadlyMatchedException(this.exceptions.broad,h,l),new Rc(l)}}}};const c7=me,{ArgumentsRequired:lT,ExchangeError:ph,PermissionDenied:pT,ExchangeNotAvailable:u7,InsufficientFunds:mT,OrderNotFound:gT,InvalidOrder:yT,RateLimitExceeded:f7,NotSupported:h7,BadRequest:Uo,AuthenticationError:mh}=oe,{TICK_SIZE:l7}=pe,ug=ke;var p7=class extends c7{describe(){return this.deepExtend(super.describe(),{id:"timex",name:"TimeX",countries:["AU"],version:"v1",rateLimit:1500,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,cancelOrders:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,editOrder:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchWithdrawal:!1,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},timeframes:{"1m":"I1","5m":"I5","15m":"I15","30m":"I30","1h":"H1","2h":"H2","4h":"H4","6h":"H6","12h":"H12","1d":"D1","1w":"W1"},urls:{logo:"https://user-images.githubusercontent.com/1294454/70423869-6839ab00-1a7f-11ea-8f94-13ae72c31115.jpg",api:{rest:"https://plasma-relay-backend.timex.io"},www:"https://timex.io",doc:"https://docs.timex.io",referral:"https://timex.io/?refcode=1x27vNkTbP1uwkCck"},api:{addressbook:{get:["me"],post:["","id/{id}","id/{id}/remove"]},custody:{get:["credentials","credentials/h/{hash}","credentials/k/{key}","credentials/me","credentials/me/address","deposit-addresses","deposit-addresses/h/{hash}"]},history:{get:["orders","orders/details","orders/export/csv","trades","trades/export/csv"]},currencies:{get:["a/{address}","i/{id}","s/{symbol}"],post:["perform","prepare","remove/perform","s/{symbol}/remove/prepare","s/{symbol}/update/perform","s/{symbol}/update/prepare"]},manager:{get:["deposits","transfers","withdrawals"]},markets:{get:["i/{id}","s/{symbol}"],post:["perform","prepare","remove/perform","s/{symbol}/remove/prepare","s/{symbol}/update/perform","s/{symbol}/update/prepare"]},public:{get:["candles","currencies","markets","orderbook","orderbook/raw","orderbook/v2","tickers","trades"]},statistics:{get:["address"]},trading:{get:["balances","fees","orders"],post:["orders","orders/json"],put:["orders","orders/json"],delete:["orders","orders/json"]},tradingview:{get:["config","history","symbol_info","time"]}},precisionMode:l7,exceptions:{exact:{0:ph,1:h7,4e3:Uo,4001:Uo,4002:mT,4003:mh,4004:mh,4005:Uo,4006:Uo,4007:Uo,4300:pT,4100:mh,4400:gT,5001:yT,5002:ph,400:Uo,401:mh,403:pT,404:gT,429:f7,500:ph,503:u7},broad:{Insufficient:mT}},options:{expireIn:31536e3,fetchTickers:{period:"1d"},fetchTrades:{sort:"timestamp,asc"},fetchMyTrades:{sort:"timestamp,asc"},fetchOpenOrders:{sort:"createdAt,asc"},fetchClosedOrders:{sort:"createdAt,asc"},defaultSort:"timestamp,asc",defaultSortOrders:"createdAt,asc"}})}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=[];for(let i=0;i<t.length;i++)s.push(this.parseMarket(t[i]));return s}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s=[];for(let i=0;i<t.length;i++){const n=t[i];s.push(this.parseCurrency(n))}return this.indexBy(s,"code")}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeString(i,"address");if(i=this.omit(i,"address"),n===void 0)throw new lT(this.id+" fetchDeposits() requires an address parameter");const r={address:n},a=await this.managerGetDeposits(this.extend(r,i));return this.parseTransactions(a,e,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeString(i,"address");if(i=this.omit(i,"address"),n===void 0)throw new lT(this.id+" fetchDeposits() requires an address parameter");const r={address:n},a=await this.managerGetWithdrawals(this.extend(r,i));return this.parseTransactions(a,e,t,s)}getCurrencyByAddress(e){const t=this.currencies;for(let s=0;s<t.length;s++){const i=t[s],n=this.safeValue(i,"info",{});if(this.safeString(n,"address")===e)return i}}parseTransaction(e,t=void 0){const s=this.safeString(e,"timestamp"),i=this.safeString(e,"token","");return t=this.getCurrencyByAddress(i),{info:e,id:this.safeString2(e,"transferHash"),txid:this.safeString(e,"txid"),timestamp:this.parse8601(s),datetime:s,network:void 0,address:void 0,addressTo:this.safeString(e,"to"),addressFrom:this.safeString(e,"from"),tag:void 0,tagTo:void 0,tagFrom:void 0,type:void 0,amount:this.safeNumber(e,"value"),currency:this.safeCurrencyCode(void 0,t),status:"ok",updated:void 0,fee:void 0}}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=this.safeString(this.options.fetchTickers,"period","1d"),i={period:this.timeframes[s]},n=await this.publicGetTickers(this.extend(i,t));return this.parseTickers(n,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=this.safeString(this.options.fetchTickers,"period","1d"),n={market:s.id,period:this.timeframes[i]},r=await this.publicGetTickers(this.extend(n,t)),a=this.safeValue(r,0);return this.parseTicker(a,s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={market:this.market(e).id};t!==void 0&&(n.limit=t);const r=await this.publicGetOrderbookV2(this.extend(n,s)),a=this.parse8601(this.safeString(r,"timestamp"));return this.parseOrderBook(r,e,a,"bid","ask","price","baseTokenAmount")}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r=this.safeValue(this.options,"fetchTrades",{}),a=this.safeValue(r,"sort","timestamp,asc"),o=this.safeString(i,"sort",a),d=this.omit(i,"sort"),c={market:n.id,sort:o};t!==void 0&&(c.from=this.iso8601(t)),s!==void 0&&(c.size=s);const u=await this.publicGetTrades(this.extend(c,d));return this.parseTrades(u,n,t,s)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={market:r.id,period:this.timeframes[t]},o=this.parseTimeframe(t);if(i===void 0&&(i=1e3),s!==void 0)a.from=this.iso8601(s),a.till=this.iso8601(this.sum(s,this.sum(i,1)*o*1e3));else{const c=this.milliseconds();a.till=this.iso8601(c),a.from=this.iso8601(c-i*o*1e3-1)}const d=await this.publicGetCandles(this.extend(a,n));return this.parseOHLCVs(d,r,t,s,i)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.total=this.safeString(i,"totalBalance"),a.used=this.safeString(i,"lockedBalance"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.tradingGetBalances(e);return this.parseBalance(t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=s.toUpperCase();let d=t.toUpperCase();this.safeValue(r,"postOnly",!1)&&(d="POST_ONLY",r=this.omit(r,["postOnly"]));const u={symbol:a.id,quantity:this.amountToPrecision(e,i),side:o,orderTypes:d};let h=r;if(d==="LIMIT"||d==="POST_ONLY"){u.price=this.priceToPrecision(e,n);const g=this.safeInteger(this.options,"expireIn"),y=this.safeValue(r,"expireTime"),b=this.safeValue(r,"expireIn",g);if(y!==void 0)u.expireTime=y;else if(b!==void 0)u.expireIn=b;else throw new yT(this.id+" createOrder() method requires a expireTime or expireIn param for a "+t+" order, you can also set the expireIn exchange-wide option");h=this.omit(r,["expireTime","expireIn"])}else u.price=0;const l=await this.tradingPostOrders(this.extend(u,h)),p=this.safeValue(l,"orders",[]),m=this.safeValue(p,0,{});return this.parseOrder(m,a)}async editOrder(e,t,s,i,n=void 0,r=void 0,a={}){await this.loadMarkets();const o=this.market(t),d={id:e};n!==void 0&&(d.quantity=this.amountToPrecision(t,n)),r!==void 0&&(d.price=this.priceToPrecision(t,r));const c=await this.tradingPutOrders(this.extend(d,a));if("unchangedOrders"in c){const p=this.safeValue(c,"unchangedOrders",[]);return{id:this.safeString(p,0),info:c}}const u=this.safeValue(c,"changedOrders",[]),h=this.safeValue(u,0,{}),l=this.safeValue(h,"newOrder",{});return this.parseOrder(l,o)}async cancelOrder(e,t=void 0,s={}){return await this.loadMarkets(),await this.cancelOrders([e],t,s)}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i={id:e};return await this.tradingDeleteOrders(this.extend(i,s))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderHash:e},n=await this.historyGetOrdersDetails(i),r=this.safeValue(n,"order",{}),a=this.safeValue(n,"trades",[]);return this.parseOrder(this.extend(r,{trades:a}))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeValue(this.options,"fetchOpenOrders",{}),r=this.safeValue(n,"sort","createdAt,asc"),a=this.safeString(i,"sort",r),o=this.omit(i,"sort"),d={sort:a};let c;e!==void 0&&(c=this.market(e),d.symbol=c.id),s!==void 0&&(d.size=s);const u=await this.tradingGetOrders(this.extend(d,o)),h=this.safeValue(u,"orders",[]);return this.parseOrders(h,c,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeValue(this.options,"fetchClosedOrders",{}),r=this.safeValue(n,"sort","createdAt,asc"),a=this.safeString(i,"sort",r),o=this.omit(i,"sort"),d={sort:a,side:"BUY"};let c;e!==void 0&&(c=this.market(e),d.symbol=c.id),t!==void 0&&(d.from=this.iso8601(t)),s!==void 0&&(d.size=s);const u=await this.historyGetOrders(this.extend(d,o)),h=this.safeValue(u,"orders",[]);return this.parseOrders(h,c,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeValue(this.options,"fetchMyTrades",{}),r=this.safeValue(n,"sort","timestamp,asc"),a=this.safeString(i,"sort",r),o=this.omit(i,"sort"),d={sort:a};let c;e!==void 0&&(c=this.market(e),d.symbol=c.id),t!==void 0&&(d.from=this.iso8601(t)),s!==void 0&&(d.size=s);const u=await this.historyGetTrades(this.extend(d,o)),h=this.safeValue(u,"trades",[]);return this.parseTrades(h,c,t,s)}parseTradingFee(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeNumber(e,"fee");return{info:e,symbol:this.safeSymbol(s,t),maker:i,taker:i}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={markets:s.id},n=await this.tradingGetFees(this.extend(i,t)),r=this.safeValue(n,0,{});return this.parseTradingFee(r,s)}parseMarket(e){const t=this.safeValue(e,"locked"),s=this.safeString(e,"symbol"),i=this.safeString(e,"baseCurrency"),n=this.safeString(e,"quoteCurrency"),r=this.safeCurrencyCode(i),a=this.safeCurrencyCode(n),o=this.safeString(e,"quantityIncrement"),d=this.safeString(e,"baseMinSize"),c=ug.stringMax(o,d),u=this.safeString(e,"tickSize"),h=this.safeString(e,"quoteMinSize");return{id:s,symbol:r+"/"+a,base:r,quote:a,settle:void 0,baseId:i,quoteId:n,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!t,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(e,"takerFee"),maker:this.safeNumber(e,"makerFee"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(e,"quantityIncrement"),price:this.safeNumber(e,"tickSize")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.parseNumber(c),max:void 0},price:{min:this.parseNumber(u),max:void 0},cost:{min:h,max:void 0}},info:e}}parseCurrency(e){const t=this.safeString(e,"symbol"),s=this.safeCurrencyCode(t),i=this.safeString(e,"name"),n=this.safeValue(e,"depositEnabled"),r=this.safeValue(e,"withdrawalEnabled"),a=this.safeValue(e,"active"),o=n&&r&&a,d=this.safeString(e,"withdrawalFee"),c=this.safeInteger(e,"tradeDecimals");let u;if(d!==void 0&&c!==void 0){const l=d.length-c;if(l>0){const p=d.slice(0,l),m=d.slice(-l);u=this.parseNumber(p+"."+m)}else{let p=".";for(let m=0;m<-l;m++)p+="0";u=this.parseNumber(p+d)}}return{id:s,code:s,info:e,type:void 0,name:i,active:o,deposit:n,withdraw:r,fee:u,precision:this.parseNumber(this.parsePrecision(this.safeString(e,"decimals"))),limits:{withdraw:{min:u,max:void 0},amount:{min:void 0,max:void 0}}}}parseTicker(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeSymbol(s,t,"/"),n=this.parse8601(this.safeString(e,"timestamp")),r=this.safeString(e,"last"),a=this.safeString(e,"open");return this.safeTicker({symbol:i,info:e,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:a,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:this.safeString(e,"volumeQuote")},t)}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.parse8601(this.safeString(e,"timestamp")),r=this.safeString(e,"price"),a=this.safeString(e,"quantity"),o=this.parseNumber(r),d=this.parseNumber(a),c=this.parseNumber(ug.stringMul(r,a)),u=this.safeString(e,"id"),h=this.safeStringLower2(e,"direction","side"),l=this.safeStringLower(e,"makerOrTaker");let p;l!==void 0&&(p=this.safeString(e,l+"OrderId"));let m;const g=this.safeNumber(e,"fee"),y=this.safeCurrencyCode(this.safeString(e,"feeToken"));return g!==void 0&&(m={cost:g,currency:y}),{info:e,id:u,timestamp:n,datetime:this.iso8601(n),symbol:i,order:p,type:void 0,side:h,price:o,amount:d,cost:c,takerOrMaker:l,fee:m}}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"timestamp")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeStringLower(e,"type"),n=this.safeStringLower(e,"side"),r=this.safeString(e,"symbol"),a=this.safeSymbol(r,t),o=this.parse8601(this.safeString(e,"createdAt")),d=this.safeString(e,"price"),c=this.safeString(e,"quantity"),u=this.safeString(e,"filledQuantity"),h=this.omitZero(this.safeString(e,"cancelledQuantity"));let l;ug.stringEquals(u,c)?l="closed":h!==void 0?l="canceled":l="open";const p=this.safeValue(e,"trades",[]),m=this.safeString(e,"clientOrderId");return this.safeOrder({info:e,id:s,clientOrderId:m,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:void 0,symbol:a,type:i,timeInForce:void 0,postOnly:void 0,side:n,price:d,stopPrice:void 0,amount:c,cost:void 0,average:void 0,filled:u,remaining:void 0,status:l,fee:void 0,trades:p},t)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+t+"/"+e;if(Object.keys(i).length&&(a+="?"+this.urlencodeWithArrayRepeat(i)),t!=="public"){this.checkRequiredCredentials();const o=this.stringToBase64(this.apiKey+":"+this.secret);n={authorization:"Basic "+this.decode(o)}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&e>=400){const c=this.id+" "+r;let u=this.safeValue(a,"error");u===void 0&&(u=a);const h=this.safeString2(u,"code","status"),l=this.safeString2(u,"message","debugMessage");throw this.throwBroadlyMatchedException(this.exceptions.broad,l,c),this.throwExactlyMatchedException(this.exceptions.exact,h,c),this.throwExactlyMatchedException(this.exceptions.exact,l,c),new ph(c)}}};const m7=me,{ExchangeError:ft,ArgumentsRequired:bT,ExchangeNotAvailable:Fc,InsufficientFunds:Wt,OrderNotFound:fg,InvalidOrder:ps,DDoSProtection:Dc,InvalidNonce:g7,AuthenticationError:Ys,RateLimitExceeded:Hc,PermissionDenied:cr,NotSupported:y7,BadRequest:Te,BadSymbol:$o,AccountSuspended:jo,OrderImmediatelyFillable:gh,OnMaintenance:b7,BadResponse:wT,RequestTimeout:w7,OrderNotFillable:S7,MarginModeAlreadySet:k7}=oe,{TRUNCATE:ST,DECIMAL_PLACES:v7}=pe,T7=ke;var O7=class extends m7{describe(){return this.deepExtend(super.describe(),{id:"tokocrypto",name:"Tokocrypto",countries:["ID"],certified:!1,pro:!1,version:"v1",has:{CORS:void 0,spot:!0,margin:!0,swap:!1,future:!1,option:!1,addMargin:void 0,borrowMargin:void 0,cancelAllOrders:!1,cancelOrder:!0,cancelOrders:void 0,createDepositAddress:!1,createOrder:!0,createReduceOnlyOrder:void 0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!0,fetchAccounts:!1,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowInterest:void 0,fetchBorrowRate:void 0,fetchBorrowRateHistories:void 0,fetchBorrowRateHistory:void 0,fetchBorrowRates:void 0,fetchBorrowRatesPerSymbol:void 0,fetchCanceledOrders:!1,fetchClosedOrder:!1,fetchClosedOrders:"emulated",fetchCurrencies:!1,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchL3OrderBook:!1,fetchLedger:void 0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrders:!0,fetchOrderTrades:!1,fetchPosition:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!1,fetchTicker:!1,fetchTickers:!1,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTradingLimits:!1,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,fetchWithdrawalWhitelist:!1,reduceMargin:!1,repayMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,setPositionMode:!1,signIn:!1,transfer:!1,withdraw:!1},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/183870484-d3398d0c-f6a1-4cce-91b8-d58792308716.jpg",api:{rest:{public:"https://www.tokocrypto.com",binance:"https://api.binance.com/api/v3",private:"https://www.tokocrypto.com"}},www:"https://tokocrypto.com",doc:"https://www.tokocrypto.com/apidocs/",fees:"https://www.tokocrypto.com/fees/newschedule"},api:{binance:{get:{ping:1,time:1,depth:{cost:1,byLimit:[[100,1],[500,5],[1e3,10],[5e3,50]]},trades:1,aggTrades:1,historicalTrades:5,klines:1,"ticker/24hr":{cost:1,noSymbol:40},"ticker/price":{cost:1,noSymbol:2},"ticker/bookTicker":{cost:1,noSymbol:2},exchangeInfo:10},put:{userDataStream:1},post:{userDataStream:1},delete:{userDataStream:1}},public:{get:{"open/v1/common/time":1,"open/v1/common/symbols":1,"open/v1/market/depth":1,"open/v1/market/trades":1,"open/v1/market/agg-trades":1,"open/v1/market/klines":1}},private:{get:{"open/v1/orders/detail":1,"open/v1/orders":1,"open/v1/account/spot":1,"open/v1/account/spot/asset":1,"open/v1/orders/trades":1,"open/v1/withdraws":1,"open/v1/deposits":1,"open/v1/deposits/address":1},post:{"open/v1/orders":1,"open/v1/orders/cancel":1,"open/v1/orders/oco":1,"open/v1/withdraws":1,"open/v1/user-data-stream":1}}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0075"),maker:this.parseNumber("0.0075")}},precisionMode:v7,options:{defaultTimeInForce:"GTC",hasAlreadyAuthenticatedSuccessfully:!1,warnOnFetchOpenOrdersWithoutSymbol:!0,recvWindow:5*1e3,timeDifference:0,adjustForTimeDifference:!1,newOrderRespType:{market:"FULL",limit:"FULL"},quoteOrderQty:!1,networks:{ERC20:"ETH",TRC20:"TRX",BEP2:"BNB",BEP20:"BSC",OMNI:"OMNI",EOS:"EOS",SPL:"SOL"},reverseNetworks:{"tronscan.org":"TRC20","etherscan.io":"ERC20","bscscan.com":"BSC","explorer.binance.org":"BEP2","bithomp.com":"XRP","bloks.io":"EOS","stellar.expert":"XLM","blockchair.com/bitcoin":"BTC","blockchair.com/bitcoin-cash":"BCH","blockchair.com/ecash":"XEC","explorer.litecoin.net":"LTC","explorer.avax.network":"AVAX","solscan.io":"SOL","polkadot.subscan.io":"DOT","dashboard.internetcomputer.org":"ICP","explorer.chiliz.com":"CHZ","cardanoscan.io":"ADA","mainnet.theoan.com":"AION","algoexplorer.io":"ALGO","explorer.ambrosus.com":"AMB","viewblock.io/zilliqa":"ZIL","viewblock.io/arweave":"AR","explorer.ark.io":"ARK","atomscan.com":"ATOM","www.mintscan.io":"CTK","explorer.bitcoindiamond.org":"BCD","btgexplorer.com":"BTG","bts.ai":"BTS","explorer.celo.org":"CELO","explorer.nervos.org":"CKB","cerebro.cortexlabs.ai":"CTXC","chainz.cryptoid.info":"VIA","explorer.dcrdata.org":"DCR","digiexplorer.info":"DGB","dock.subscan.io":"DOCK","dogechain.info":"DOGE","explorer.elrond.com":"EGLD","blockscout.com":"ETC","explore-fetchhub.fetch.ai":"FET","filfox.info":"FIL","fio.bloks.io":"FIO","explorer.firo.org":"FIRO","neoscan.io":"NEO","ftmscan.com":"FTM","explorer.gochain.io":"GO","block.gxb.io":"GXS","hash-hash.info":"HBAR","www.hiveblockexplorer.com":"HIVE","explorer.helium.com":"HNT","tracker.icon.foundation":"ICX","www.iostabc.com":"IOST","explorer.iota.org":"IOTA","iotexscan.io":"IOTX","irishub.iobscan.io":"IRIS","kava.mintscan.io":"KAVA","scope.klaytn.com":"KLAY","kmdexplorer.io":"KMD","kusama.subscan.io":"KSM","explorer.lto.network":"LTO","polygonscan.com":"POLYGON","explorer.ont.io":"ONT","minaexplorer.com":"MINA","nanolooker.com":"NANO","explorer.nebulas.io":"NAS","explorer.nbs.plus":"NBS","explorer.nebl.io":"NEBL","nulscan.io":"NULS","nxscan.com":"NXS","explorer.harmony.one":"ONE","explorer.poa.network":"POA","qtum.info":"QTUM","explorer.rsk.co":"RSK","www.oasisscan.com":"ROSE","ravencoin.network":"RVN","sc.tokenview.com":"SC","secretnodes.com":"SCRT","explorer.skycoin.com":"SKY","steemscan.com":"STEEM","explorer.stacks.co":"STX","www.thetascan.io":"THETA","scan.tomochain.com":"TOMO","explore.vechain.org":"VET","explorer.vite.net":"VITE","www.wanscan.org":"WAN","wavesexplorer.com":"WAVES","wax.eosx.io":"WAXP","waltonchain.pro":"WTC","chain.nem.ninja":"XEM","verge-blockchain.info":"XVG","explorer.yoyow.org":"YOYOW","explorer.zcha.in":"ZEC","explorer.zensystem.io":"ZEN"},impliedNetworks:{ETH:{ERC20:"ETH"},TRX:{TRC20:"TRX"}},legalMoney:{MXN:!0,UGX:!0,SEK:!0,CHF:!0,VND:!0,AED:!0,DKK:!0,KZT:!0,HUF:!0,PEN:!0,PHP:!0,USD:!0,TRY:!0,EUR:!0,NGN:!0,PLN:!0,BRL:!0,ZAR:!0,KES:!0,ARS:!0,RUB:!0,AUD:!0,NOK:!0,CZK:!0,GBP:!0,UAH:!0,GHS:!0,HKD:!0,CAD:!0,INR:!0,JPY:!0,NZD:!0}},exceptions:{exact:{"System is under maintenance.":b7,"System abnormality":ft,"You are not authorized to execute this request.":cr,"API key does not exist":Ys,"Order would trigger immediately.":gh,"Stop price would trigger immediately.":gh,"Order would immediately match and take.":gh,"Account has insufficient balance for requested action.":Wt,"Rest API trading is not enabled.":Fc,"You don't have permission.":cr,"Market is closed.":Fc,"Too many requests. Please try again later.":Dc,"This action disabled is on this account.":jo,"-1000":Fc,"-1001":Fc,"-1002":Ys,"-1003":Hc,"-1004":Dc,"-1005":cr,"-1006":wT,"-1007":w7,"-1010":wT,"-1011":cr,"-1013":ps,"-1014":ps,"-1015":Hc,"-1016":Fc,"-1020":Te,"-1021":g7,"-1022":Ys,"-1023":Te,"-1099":Ys,"-1100":Te,"-1101":Te,"-1102":Te,"-1103":Te,"-1104":Te,"-1105":Te,"-1106":Te,"-1108":Te,"-1109":Ys,"-1110":Te,"-1111":Te,"-1112":ps,"-1113":Te,"-1114":Te,"-1115":Te,"-1116":Te,"-1117":Te,"-1118":Te,"-1119":Te,"-1120":Te,"-1121":$o,"-1125":Ys,"-1127":Te,"-1128":Te,"-1130":Te,"-1131":Te,"-1136":Te,"-2008":Ys,"-2010":ft,"-2011":fg,"-2013":fg,"-2014":Ys,"-2015":Ys,"-2016":Te,"-2018":Wt,"-2019":Wt,"-2020":S7,"-2021":gh,"-2022":ps,"-2023":Wt,"-2024":Wt,"-2025":ps,"-2026":ps,"-2027":ps,"-2028":Wt,"-3000":ft,"-3001":Ys,"-3002":$o,"-3003":Te,"-3004":ft,"-3005":Wt,"-3006":Wt,"-3007":ft,"-3008":Wt,"-3009":Te,"-3010":ft,"-3011":Te,"-3012":ft,"-3013":Te,"-3014":jo,"-3015":ft,"-3016":Te,"-3017":ft,"-3018":jo,"-3019":jo,"-3020":Wt,"-3021":Te,"-3022":jo,"-3023":Te,"-3024":ft,"-3025":Te,"-3026":Te,"-3027":$o,"-3028":$o,"-3029":ft,"-3036":jo,"-3037":ft,"-3038":Te,"-3041":Wt,"-3042":Te,"-3043":Te,"-3044":Dc,"-3045":ft,"-3999":ft,"-4001":Te,"-4002":Te,"-4003":Te,"-4004":Ys,"-4005":Hc,"-4006":Te,"-4007":Te,"-4008":Te,"-4010":Te,"-4011":Te,"-4012":Te,"-4013":Ys,"-4014":cr,"-4015":ft,"-4016":cr,"-4017":cr,"-4018":$o,"-4019":$o,"-4021":Te,"-4022":Te,"-4023":ft,"-4024":Wt,"-4025":Wt,"-4026":Wt,"-4027":ft,"-4028":Te,"-4029":Te,"-4030":ft,"-4031":ft,"-4032":ft,"-4033":Te,"-4034":ft,"-4035":cr,"-4036":Te,"-4037":ft,"-4038":ft,"-4039":Te,"-4040":Te,"-4041":ft,"-4042":ft,"-4043":Te,"-4044":Te,"-4045":ft,"-4046":Ys,"-4047":Te,"-5001":Te,"-5002":Wt,"-5003":Wt,"-5004":Te,"-5005":Wt,"-5006":Te,"-5007":Te,"-5008":Wt,"-5009":Te,"-5010":ft,"-5011":Te,"-5012":ft,"-5013":Wt,"-5021":Te,"-6001":Te,"-6003":Te,"-6004":ft,"-6005":ps,"-6006":Te,"-6007":Te,"-6008":Te,"-6009":Hc,"-6011":Te,"-6012":Wt,"-6013":ft,"-6014":Te,"-6015":Te,"-6016":Te,"-6017":Te,"-6018":Te,"-6019":Ys,"-6020":Te,"-7001":Te,"-7002":Te,"-9000":Wt,"-10017":Te,"-11008":Wt,"-12014":Hc,"-13000":Te,"-13001":Te,"-13002":Te,"-13003":Te,"-13004":Te,"-13005":Te,"-13006":ps,"-13007":Ys,"-21001":Te,"-21002":Te,"-21003":Te,100001003:Te,2202:Wt,3210:ps,3203:ps,3211:ps,3207:ps,3218:fg},broad:{"has no operation privilege":cr,MAX_POSITION:ps}}})}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeInteger(t,"serverTime")}async fetchMarkets(e={}){const t=await this.publicGetOpenV1CommonSymbols(e);this.options.adjustForTimeDifference&&await this.loadTimeDifference();const s=this.safeValue(t,"data",{}),i=this.safeValue(s,"list",[]),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"baseAsset"),d=this.safeString(a,"quoteAsset"),c=this.safeString(a,"symbol"),u=this.safeStringLower(a,"symbol"),h=this.safeString(a,"marginAsset"),l=this.safeCurrencyCode(o),p=this.safeCurrencyCode(d),m=this.safeCurrencyCode(h),g=l+"/"+p,y=this.safeValue(a,"filters",[]),b=this.indexBy(y,"filterType");let S=this.safeString2(a,"status","contractStatus")==="TRADING";const k=this.safeValue(a,"permissions",[]);for(let _=0;_<k.length;_++)if(k[_]==="TRD_GRP_003"){S=!1;break}const T=this.safeValue(a,"isMarginTradingAllowed",!1),I={id:c,lowercaseId:u,symbol:g,base:l,quote:p,settle:m,baseId:o,quoteId:d,settleId:h,type:"spot",spot:!0,margin:T,swap:!1,future:!1,delivery:!1,option:!1,active:S,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeInteger(a,"quantityPrecision"),price:this.safeInteger(a,"pricePrecision"),base:this.safeInteger(a,"baseAssetPrecision"),quote:this.safeInteger(a,"quotePrecision")},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:a};if("PRICE_FILTER"in b){const _=this.safeValue(b,"PRICE_FILTER",{}),N=this.safeString(_,"tickSize");I.precision.price=this.precisionFromString(N),I.limits.price={min:this.safeNumber(_,"minPrice"),max:this.safeNumber(_,"maxPrice")},I.precision.price=this.precisionFromString(_.tickSize)}if("LOT_SIZE"in b){const _=this.safeValue(b,"LOT_SIZE",{}),N=this.safeString(_,"stepSize");I.precision.amount=this.precisionFromString(N),I.limits.amount={min:this.safeNumber(_,"minQty"),max:this.safeNumber(_,"maxQty")}}if("MARKET_LOT_SIZE"in b){const _=this.safeValue(b,"MARKET_LOT_SIZE",{});I.limits.market={min:this.safeNumber(_,"minQty"),max:this.safeNumber(_,"maxQty")}}if("MIN_NOTIONAL"in b){const _=this.safeValue(b,"MIN_NOTIONAL",{});I.limits.cost.min=this.safeNumber2(_,"minNotional","notional")}n.push(I)}return n}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.baseId+i.quoteId};t!==void 0&&(n.limit=t);const r=await this.binanceGetDepth(this.extend(n,s)),a=this.safeInteger(r,"T"),o=this.parseOrderBook(r,e,a);return o.nonce=this.safeInteger(r,"lastUpdateId"),o}parseTrade(e,t=void 0){const s=this.safeInteger2(e,"T","time"),i=this.safeString2(e,"p","price"),n=this.safeString2(e,"q","qty"),r=this.safeString2(e,"quoteQty","baseQty"),a=this.safeString(e,"symbol"),o=this.safeSymbol(a,t);let d=this.safeString2(e,"t","a");d=this.safeString2(e,"id","tradeId",d);let c;const u=this.safeString(e,"orderId"),h=this.safeValue2(e,"m","isBuyerMaker");let l;h!==void 0?(c=h?"sell":"buy",l="taker"):"side"in e?c=this.safeStringLower(e,"side"):"isBuyer"in e&&(c=e.isBuyer?"buy":"sell");let p;return"commission"in e&&(p={cost:this.safeString(e,"commission"),currency:this.safeCurrencyCode(this.safeString(e,"commissionAsset"))}),"isMaker"in e&&(l=e.isMaker?"maker":"taker"),"maker"in e&&(l=e.maker?"maker":"taker"),this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:o,id:d,order:u,type:void 0,side:c,takerOrMaker:l,price:i,amount:n,cost:r,fee:p},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.baseId+n.quoteId},a="binanceGetTrades",o=this.safeString(this.options,"fetchTradesMethod",a);o==="binanceGetAggTrades"&&t!==void 0&&(r.startTime=t,r.endTime=this.sum(t,36e5)),s!==void 0&&(r.limit=s);const d=await this[o](this.extend(r,i));return this.parseTrades(d,n,t,s)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"closeTime"),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.safeString(e,"lastPrice"),a="baseVolume"in e;let o,d;return a?(o=this.safeString(e,"baseVolume"),d=this.safeString(e,"volume")):(o=this.safeString(e,"volume"),d=this.safeString(e,"quoteVolume")),this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"highPrice"),low:this.safeString(e,"lowPrice"),bid:this.safeString(e,"bidPrice"),bidVolume:this.safeString(e,"bidQty"),ask:this.safeString(e,"askPrice"),askVolume:this.safeString(e,"askQty"),vwap:this.safeString(e,"weightedAvgPrice"),open:this.safeString(e,"openPrice"),close:r,last:r,previousClose:this.safeString(e,"prevClosePrice"),change:this.safeString(e,"priceChange"),percentage:this.safeString(e,"priceChangePercent"),average:void 0,baseVolume:o,quoteVolume:d,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s="binanceGetTicker24hr",i=this.safeString(this.options,"fetchTickersMethod",s),n=await this[i](t);return this.parseTickers(n,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.baseId+s.quoteId},n=await this.binanceGetTicker24hr(this.extend(i,t));if(Array.isArray(n)){const r=this.safeValue(n,0,{});return this.parseTicker(r,s)}return this.parseTicker(n,s)}async fetchBidsAsks(e=void 0,t={}){await this.loadMarkets();const s=await this.binanceGetTickerBookTicker(t);return this.parseTickers(s,e)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=500,o=1500,d=this.safeString(n,"price"),c=this.safeInteger(n,"until");n=this.omit(n,["price","until"]),i=i===void 0?a:Math.min(i,o);const u={interval:this.timeframes[t],limit:i};d==="index"?u.pair=r.id:u.symbol=r.baseId+r.quoteId,s!==void 0&&(u.startTime=s),c!==void 0&&(u.endTime=c);const h=await this.binanceGetKlines(this.extend(u,n));return this.parseOHLCVs(h,r,t,s,i)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString2(this.options,"fetchBalance","defaultType","spot"),s=this.safeString(e,"type",t),i=this.safeString2(this.options,"marginMode","defaultMarginMode"),n=this.safeStringLower(e,"marginMode",i),r={},a=await this.privateGetOpenV1AccountSpot(this.extend(r,e));return this.parseBalance(a,s,n)}parseBalance(e,t=void 0,s=void 0){const i=this.safeInteger(e,"updateTime"),n={info:e,timestamp:i,datetime:this.iso8601(i)},r=this.safeValue(e,"data",{}),a=this.safeValue(r,"accountAssets",[]);for(let o=0;o<a.length;o++){const d=a[o],c=this.safeString(d,"asset"),u=this.safeCurrencyCode(c),h=this.account();h.free=this.safeString(d,"free"),h.used=this.safeString(d,"locked"),n[u]=h}return this.safeBalance(n)}parseOrderStatus(e){const t={"-2":"open",0:"open",1:"open",2:"closed",3:"canceled",4:"canceling",5:"rejected",6:"expired",NEW:"open",PARTIALLY_FILLED:"open",FILLED:"closed",CANCELED:"canceled",PENDING_CANCEL:"canceling",REJECTED:"rejected",EXPIRED:"expired"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString(e,"status")),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.safeString(e,"executedQty","0"),a=this.safeInteger(e,"createTime"),o=this.safeString(e,"avgPrice"),d=this.safeString(e,"price"),c=this.safeString(e,"origQty");let u=this.safeString2(e,"cummulativeQuoteQty","cumQuote");u=this.safeString(e,"cumBase",u);const h=this.safeString(e,"orderId");let l=this.safeStringLower(e,"type"),p=this.safeStringLower(e,"side");p==="0"?p="buy":p==="1"&&(p="sell");const m=this.safeValue(e,"fills",[]),g=this.safeString(e,"clientOrderId");let y=this.safeString(e,"timeInForce");y==="GTX"&&(y="PO");const b=l==="limit_maker"||y==="PO";l==="limit_maker"&&(l="limit");const w=this.safeString(e,"stopPrice"),S=this.parseNumber(this.omitZero(w));return this.safeOrder({info:e,id:h,clientOrderId:g,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:void 0,symbol:n,type:l,timeInForce:y,postOnly:b,reduceOnly:this.safeValue(e,"reduceOnly"),side:p,price:d,stopPrice:S,amount:c,cost:u,average:o,filled:r,remaining:void 0,status:s,fee:void 0,trades:m},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeString2(r,"clientOrderId","clientId");this.safeValue(r,"postOnly",!1)&&(t="LIMIT_MAKER"),r=this.omit(r,["clientId","clientOrderId"]);const c=t.toUpperCase();let u=c;const h=this.safeValue2(r,"triggerPrice","stopPrice");h!==void 0&&(r=this.omit(r,["triggerPrice","stopPrice"]),u==="MARKET"?u="STOP_LOSS":u==="LIMIT"&&(u="STOP_LOSS_LIMIT"));const l=this.safeValue(a.info,"orderTypes");if(!this.inArray(u,l))throw c!==u?new ps(this.id+" stopPrice parameter is not allowed for "+e+" "+t+" orders"):new ps(this.id+" "+t+" is not a valid order type for the "+e+" market");const p={LIMIT:1,MARKET:2,STOP_LOSS:3,STOP_LOSS_LIMIT:4,TAKE_PROFIT:5,TAKE_PROFIT_LIMIT:6,LIMIT_MAKER:7},m={symbol:a.baseId+"_"+a.quoteId,type:this.safeString(p,u)};if(s==="buy"?m.side=0:s==="sell"&&(m.side=1),o===void 0){const k=this.safeValue(this.options,"broker");if(k!==void 0){const T=this.safeString(k,"marketType");T!==void 0&&(m.clientId=T+this.uuid22())}}else m.clientId=o;let g=!1,y=!1,b=!1;if(u==="MARKET")if(this.safeValue(this.options,"quoteOrderQty",!0)){const T=this.safeValue2(r,"quoteOrderQty","cost"),I=a.precision.price;T!==void 0?(m.quoteOrderQty=this.decimalToPrecision(T,ST,I,this.precisionMode),r=this.omit(r,["quoteOrderQty","cost"])):n!==void 0?m.quoteOrderQty=this.decimalToPrecision(i*n,ST,I,this.precisionMode):b=!0}else b=!0;else u==="LIMIT"?(g=!0,b=!0):u==="STOP_LOSS"||u==="TAKE_PROFIT"?(y=!0,b=!0,(a.linear||a.inverse)&&(g=!0)):u==="STOP_LOSS_LIMIT"||u==="TAKE_PROFIT_LIMIT"?(b=!0,y=!0,g=!0):u==="LIMIT_MAKER"&&(g=!0,b=!0);if(b&&(m.quantity=this.amountToPrecision(e,i)),g){if(n===void 0)throw new ps(this.id+" createOrder() requires a price argument for a "+t+" order");m.price=this.priceToPrecision(e,n)}if(y){if(h===void 0)throw new ps(this.id+" createOrder() requires a stopPrice extra param for a "+t+" order");m.stopPrice=this.priceToPrecision(e,h)}const w=await this.privatePostOpenV1Orders(this.extend(m,r)),S=this.safeValue(w,"data",{});return this.parseOrder(S,a)}async fetchOrder(e,t=void 0,s={}){const i={orderId:e},n=await this.privateGetOpenV1Orders(this.extend(i,s)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"list",[]),o=this.safeValue(a,0,{});return this.parseOrder(o)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new bT(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=s);const a=await this.privateGetOpenV1Orders(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"list",[]);return this.parseOrders(d,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={type:1};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={type:2};return await this.fetchOrders(e,t,s,this.extend(n,i))}async cancelOrder(e,t=void 0,s={}){const i={orderId:e},n=await this.privatePostOpenV1OrdersCancel(this.extend(i,s)),r=this.safeValue(n,"data",{});return this.parseOrder(r)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new bT(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=this.safeInteger2(i,"until","endTime");if(t!==void 0){const u=parseInt(t);r.startTime=u}a!==void 0&&(r.endTime=a,i=this.omit(i,["endTime","until"])),s!==void 0&&(r.limit=s);const o=await this.privateGetOpenV1OrdersTrades(this.extend(r,i)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"list",[]);return this.parseTrades(c,n,t,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={asset:this.currency(e).id},n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper(t,"network");r=this.safeString(n,r,r),r!==void 0&&(i.network=r,t=this.omit(t,"network"));const a=await this.privateGetOpenV1DepositsAddress(this.extend(i,t)),o=this.safeValue(a,"data",{}),d=this.safeString(o,"address");let c=this.safeString(o,"addressTag","");return c.length===0&&(c=void 0),this.checkAddress(d),{currency:e,address:d,tag:c,network:this.safeString(o,"network"),info:a}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={},a=this.safeInteger(i,"until");if(e!==void 0&&(n=this.currency(e),r.coin=n.id),t!==void 0){r.startTime=t;let u=this.sum(t,7776e6);a!==void 0&&(u=Math.min(u,a)),r.endTime=u}s!==void 0&&(r.limit=s);const o=await this.privateGetOpenV1Deposits(this.extend(r,i)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"list",[]);return this.parseTransactions(c,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.coin=r.id),t!==void 0&&(n.startTime=t,n.endTime=this.sum(t,7776e6)),s!==void 0&&(n.limit=s);const a=await this.privateGetOpenV1Withdraws(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"list",[]);return this.parseTransactions(d,r,t,s)}parseTransactionStatusByType(e,t=void 0){const s={deposit:{0:"pending",1:"ok"},withdrawal:{0:"pending",1:"canceled",2:"pending",3:"failed",4:"pending",5:"failed",10:"ok"}},i=this.safeValue(s,t,{});return this.safeString(i,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"address");let n=this.safeString(e,"addressTag");n!==void 0&&n.length<1&&(n=void 0);let r=this.safeString(e,"txId");r!==void 0&&r.indexOf("Internal transfer ")>=0&&(r=r.slice(18));const a=this.safeString2(e,"coin","fiatCurrency"),o=this.safeCurrencyCode(a,t);let d;const c=this.safeInteger(e,"insertTime"),u=this.safeInteger(e,"createTime");let h=this.safeString(e,"type");h===void 0&&(c!==void 0&&u===void 0?(h="deposit",d=c):c===void 0&&u!==void 0&&(h="withdrawal",d=u));const l=this.parseTransactionStatusByType(this.safeString(e,"status"),h),p=this.safeNumber(e,"amount"),m=this.safeNumber2(e,"transactionFee","totalFee");let g;m!==void 0&&(g={currency:o,cost:m});const y=this.safeInteger2(e,"successTime","updateTime");let b=this.safeInteger(e,"transferType");b!==void 0&&(b=!!b);const w=this.safeString(e,"network");return{info:e,id:s,txid:r,timestamp:d,datetime:this.iso8601(d),network:w,address:i,addressTo:i,addressFrom:void 0,tag:n,tagTo:n,tagFrom:void 0,type:h,amount:p,currency:o,status:l,updated:y,internal:b,fee:g}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){if(!(t in this.urls.api.rest))throw new y7(this.id+" does not have a testnet/sandbox URL for "+t+" endpoints");let a=this.urls.api.rest[t];if(a+="/"+e,t==="wapi"&&(a+=".html"),e==="userDataStream"||e==="listenKey")if(this.apiKey)n={"X-MBX-APIKEY":this.apiKey,"Content-Type":"application/x-www-form-urlencoded"},s!=="GET"&&(r=this.urlencode(i));else throw new Ys(this.id+" userDataStream endpoint requires `apiKey` credential");else if(t==="private"||t==="sapi"&&e!=="system/status"||t==="sapiV3"||t==="wapi"&&e!=="systemStatus"||t==="dapiPrivate"||t==="dapiPrivateV2"||t==="fapiPrivate"||t==="fapiPrivateV2"){this.checkRequiredCredentials();let d;const c=this.safeInteger(this.options,"recvWindow"),u=this.extend({timestamp:this.nonce()},i);c!==void 0&&(u.recvWindow=c);const h=this.safeInteger(i,"recvWindow");h!==void 0&&(u.recvWindow=h),t==="sapi"&&e==="asset/dust"?d=this.urlencodeWithArrayRepeat(u):e==="batchOrders"||e.indexOf("sub-account")>=0||e==="capital/withdraw/apply"||e.indexOf("staking")>=0?d=this.rawencode(u):d=this.urlencode(u);const l=this.hmac(this.encode(d),this.encode(this.secret));d+="&signature="+l,n={"X-MBX-APIKEY":this.apiKey},s==="GET"||s==="DELETE"||t==="wapi"?a+="?"+d:(r=d,n["Content-Type"]="application/x-www-form-urlencoded")}else Object.keys(i).length&&(a+="?"+this.urlencode(i));return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(e===418||e===429)throw new Dc(this.id+" "+e.toString()+" "+t+" "+r);if(e>=400){if(r.indexOf("Price * QTY is zero or less")>=0)throw new ps(this.id+" order cost = amount * price is zero or less "+r);if(r.indexOf("LOT_SIZE")>=0)throw new ps(this.id+" order amount should be evenly divisible by lot size "+r);if(r.indexOf("PRICE_FILTER")>=0)throw new ps(this.id+" order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid value in general, use this.priceToPrecision (symbol, amount) "+r)}if(a===void 0)return;const c=this.safeValue(a,"success",!0);if(!c){const l=this.safeString(a,"msg");let p;if(l!==void 0){try{p=JSON.parse(l)}catch{p=void 0}p!==void 0&&(a=p)}}const u=this.safeString(a,"msg");u!==void 0&&(this.throwExactlyMatchedException(this.exceptions.exact,u,this.id+" "+u),this.throwBroadlyMatchedException(this.exceptions.broad,u,this.id+" "+u));const h=this.safeString(a,"code");if(h!==void 0){if(h==="200"||T7.stringEquals(h,"0"))return;if(h==="-2015"&&this.options.hasAlreadyAuthenticatedSuccessfully)throw new Dc(this.id+" "+r);const l=this.id+" "+r;throw u==="No need to change margin type."?new k7(l):(this.throwExactlyMatchedException(this.exceptions.exact,h,l),new ft(l))}if(!c)throw new ft(this.id+" "+r)}calculateRateLimiterCost(e,t,s,i,n={},r={}){if("noCoin"in n&&!("coin"in i))return n.noCoin;if("noSymbol"in n&&!("symbol"in i))return n.noSymbol;if("noPoolId"in n&&!("poolId"in i))return n.noPoolId;if("byLimit"in n&&"limit"in i){const a=i.limit,o=n.byLimit;for(let d=0;d<o.length;d++){const c=o[d];if(a<=c[0])return c[1]}}return this.safeInteger(n,"cost",1)}};const I7=me,{ExchangeError:Gc,BadRequest:x7,AuthenticationError:hg,InvalidOrder:Uc,InsufficientFunds:_7,OrderNotFound:C7,PermissionDenied:kT,AddressPending:M7}=oe,{TICK_SIZE:P7}=pe,vT=ke;var K_=class extends I7{describe(){return this.deepExtend(super.describe(),{id:"upbit",name:"Upbit",countries:["KR"],version:"v1",rateLimit:1e3,pro:!0,has:{CORS:!0,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelOrder:!0,createDepositAddress:!0,createMarketOrder:!0,createOrder:!0,fetchBalance:!0,fetchCanceledOrders:!0,fetchClosedOrders:!0,fetchDepositAddress:!0,fetchDepositAddresses:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:void 0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!0,fetchOrders:void 0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactions:void 0,fetchWithdrawals:!0,transfer:!1,withdraw:!0},timeframes:{"1m":"minutes","3m":"minutes","5m":"minutes","15m":"minutes","30m":"minutes","1h":"minutes","4h":"minutes","1d":"days","1w":"weeks","1M":"months"},hostname:"api.upbit.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/49245610-eeaabe00-f423-11e8-9cba-4b0aed794799.jpg",api:{public:"https://{hostname}",private:"https://{hostname}"},www:"https://upbit.com",doc:"https://docs.upbit.com/docs/%EC%9A%94%EC%B2%AD-%EC%88%98-%EC%A0%9C%ED%95%9C",fees:"https://upbit.com/service_center/guide"},api:{public:{get:["market/all","candles/{timeframe}","candles/{timeframe}/{unit}","candles/minutes/{unit}","candles/minutes/1","candles/minutes/3","candles/minutes/5","candles/minutes/15","candles/minutes/30","candles/minutes/60","candles/minutes/240","candles/days","candles/weeks","candles/months","trades/ticks","ticker","orderbook"]},private:{get:["accounts","orders/chance","order","orders","withdraws","withdraw","withdraws/chance","deposits","deposit","deposits/coin_addresses","deposits/coin_address"],post:["orders","withdraws/coin","withdraws/krw","deposits/generate_coin_address"],delete:["order"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.0025"),taker:this.parseNumber("0.0025")},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}},precisionMode:P7,exceptions:{exact:{"This key has expired.":hg,"Missing request parameter error. Check the required parameters!":x7,"side is missing, side does not have a valid value":Uc},broad:{thirdparty_agreement_required:kT,out_of_scope:kT,order_not_found:C7,insufficient_funds:_7,invalid_access_key:hg,jwt_verification:hg,create_ask_error:Gc,create_bid_error:Gc,volume_too_large:Uc,invalid_funds:Uc}},options:{createMarketBuyOrderRequiresPrice:!0,fetchTickersMaxLength:4096,fetchOrderBooksMaxLength:4096,tradingFeesByQuoteCurrency:{KRW:5e-4}},commonCurrencies:{TON:"Tokamak Network"}})}async fetchCurrency(e,t={}){await this.loadMarkets();const s=this.currency(e);return await this.fetchCurrencyById(s.id,t)}async fetchCurrencyById(e,t={}){const s={currency:e},i=await this.privateGetWithdrawsChance(this.extend(s,t)),n=this.safeValue(i,"member_level",{}),r=this.safeValue(i,"currency",{}),a=this.safeValue(i,"withdraw_limit",{}),o=this.safeValue(a,"can_withdraw"),d=this.safeString(r,"wallet_state"),c=this.safeValue(n,"wallet_locked"),u=this.safeValue(n,"locked");let h=!0;(o!==void 0&&!o||d!=="working"||c!==void 0&&c||u!==void 0&&u)&&(h=!1);const l=this.safeNumber(a,"onetime"),p=this.safeNumber(a,"daily",l),m=this.safeNumber(a,"remaining_daily",p);let g;m>0?g=m:g=p;const y=this.safeString(r,"code"),b=this.safeCurrencyCode(y);return{info:i,id:y,code:b,name:b,active:h,fee:this.safeNumber(r,"withdraw_fee"),precision:void 0,limits:{withdraw:{min:this.safeNumber(a,"minimum"),max:g}}}}async fetchMarket(e,t={}){await this.loadMarkets();const s=this.market(e);return await this.fetchMarketById(s.id,t)}async fetchMarketById(e,t={}){const s={market:e},i=await this.privateGetOrdersChance(this.extend(s,t)),n=this.safeValue(i,"market"),r=this.safeValue(n,"bid"),a=this.safeValue(n,"ask"),o=this.safeString(n,"id"),d=this.safeString(a,"currency"),c=this.safeString(r,"currency"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),l=this.safeString(n,"state"),p=this.safeNumber(i,"bid_fee"),m=this.safeNumber(i,"ask_fee"),g=Math.max(p,m);return{id:o,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:l==="active",contract:!1,linear:void 0,inverse:void 0,taker:g,maker:g,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber("0.00000001"),price:this.parseNumber("0.00000001")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(a,"min_total"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(r,"min_total"),max:this.safeNumber(n,"max_total")},info:i}}}async fetchMarkets(e={}){const t=await this.publicGetMarketAll(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"market"),[a,o]=r.split("-"),d=this.safeCurrencyCode(o),c=this.safeCurrencyCode(a);s.push({id:r,symbol:d+"/"+c,base:d,quote:c,settle:void 0,baseId:o,quoteId:a,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(this.options.tradingFeesByQuoteCurrency,c,this.fees.trading.taker),maker:this.safeNumber(this.options.tradingFeesByQuoteCurrency,c,this.fees.trading.maker),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{price:this.parseNumber("0.00000001"),amount:this.parseNumber("0.00000001")},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:n})}return s}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"balance"),a.used=this.safeString(i,"locked"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccounts(e);return this.parseBalance(t)}async fetchOrderBooks(e=void 0,t=void 0,s={}){await this.loadMarkets();let i;if(e===void 0){if(i=this.ids.join(","),i.length>this.options.fetchOrderBooksMaxLength){const o=this.ids.length;throw new Gc(this.id+" fetchOrderBooks() has "+o.toString()+" symbols ("+i.length.toString()+" characters) exceeding max URL length ("+this.options.fetchOrderBooksMaxLength.toString()+" characters), you are required to specify a list of symbols in the first argument to fetchOrderBooks")}}else i=this.marketIds(e),i=i.join(",");const n={markets:i},r=await this.publicGetOrderbook(this.extend(n,s)),a={};for(let o=0;o<r.length;o++){const d=r[o],c=this.safeString(d,"market"),u=this.safeSymbol(c,void 0,"-"),h=this.safeInteger(d,"timestamp");a[u]={symbol:u,bids:this.sortBy(this.parseBidsAsks(d.orderbook_units,"bid_price","bid_size"),0,!0),asks:this.sortBy(this.parseBidsAsks(d.orderbook_units,"ask_price","ask_size"),0),timestamp:h,datetime:this.iso8601(h),nonce:void 0}}return a}async fetchOrderBook(e,t=void 0,s={}){const i=await this.fetchOrderBooks([e],t,s);return this.safeValue(i,e)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"trade_timestamp"),i=this.safeString2(e,"market","code");t=this.safeMarket(i,t,"-");const n=this.safeString(e,"trade_price");return this.safeTicker({symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high_price"),low:this.safeString(e,"low_price"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:this.safeString(e,"opening_price"),close:n,last:n,previousClose:this.safeString(e,"prev_closing_price"),change:this.safeString(e,"signed_change_price"),percentage:this.safeString(e,"signed_change_rate"),average:void 0,baseVolume:this.safeString(e,"acc_trade_volume_24h"),quoteVolume:this.safeString(e,"acc_trade_price_24h"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s;if(e===void 0){if(s=this.ids.join(","),s.length>this.options.fetchTickersMaxLength){const a=this.ids.length;throw new Gc(this.id+" fetchTickers() has "+a.toString()+" symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchTickers")}}else s=this.marketIds(e),s=s.join(",");const i={markets:s},n=await this.publicGetTicker(this.extend(i,t)),r={};for(let a=0;a<n.length;a++){const o=this.parseTicker(n[a]),d=o.symbol;r[d]=o}return this.filterByArray(r,"symbol",e)}async fetchTicker(e,t={}){const s=await this.fetchTickers([e],t);return this.safeValue(s,e)}parseTrade(e,t=void 0){const s=this.safeString2(e,"sequential_id","uuid"),i=void 0;let n=this.safeInteger(e,"timestamp");n===void 0&&(n=this.parse8601(this.safeString(e,"created_at")));let r;const a=this.safeStringLower2(e,"ask_bid","side");a==="ask"?r="sell":a==="bid"&&(r="buy");const o=this.safeString(e,"funds"),d=this.safeString2(e,"trade_price","price"),c=this.safeString2(e,"trade_volume","volume"),u=this.safeString2(e,"market","code");t=this.safeMarket(u,t,"-");let h;const l=this.safeString(e,a+"_fee");return l!==void 0&&(h={currency:t.quote,cost:l}),this.safeTrade({id:s,info:e,order:i,timestamp:n,datetime:this.iso8601(n),symbol:t.symbol,type:void 0,side:r,takerOrMaker:void 0,price:d,amount:c,cost:o,fee:h},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);s===void 0&&(s=200);const r={market:n.id,count:s},a=await this.publicGetTradesTicks(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const i={market:this.market(e).id},n=await this.privateGetOrdersChance(this.extend(i,t)),r=this.safeString(n,"ask_fee"),a=this.safeString(n,"bid_fee"),o=vT.stringMax(r,a),d=this.safeString(n,"maker_ask_fee"),c=this.safeString(n,"maker_bid_fee"),u=vT.stringMax(d,c);return{info:n,symbol:e,maker:this.parseNumber(u),taker:this.parseNumber(o),percentage:!0,tierBased:!1}}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"candle_date_time_utc")),this.safeNumber(e,"opening_price"),this.safeNumber(e,"high_price"),this.safeNumber(e,"low_price"),this.safeNumber(e,"trade_price"),this.safeNumber(e,"candle_acc_trade_volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.parseTimeframe(t),o=this.timeframes[t];i===void 0&&(i=200);const d={market:r.id,timeframe:o,count:i};let c="publicGetCandlesTimeframe";if(o==="minutes"){const h=Math.round(a/60);d.unit=h,c+="Unit"}s!==void 0&&(d.to=this.iso8601(this.sum(s,a*i*1e3)));const u=await this[c](this.extend(d,n));return this.parseOHLCVs(u,r,t,s,i)}async createOrder(e,t,s,i,n=void 0,r={}){if(t==="market"&&s==="buy"&&this.options.createMarketBuyOrderRequiresPrice){if(n===void 0)throw new Uc(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)");i=i*n}let a;if(s==="buy")a="bid";else if(s==="sell")a="ask";else throw new Uc(this.id+" createOrder() allows buy or sell side only!");await this.loadMarkets();const d={market:this.market(e).id,side:a};t==="limit"?(d.volume=this.amountToPrecision(e,i),d.price=this.priceToPrecision(e,n),d.ord_type=t):t==="market"&&(s==="buy"?(d.ord_type="price",d.price=this.priceToPrecision(e,i)):s==="sell"&&(d.ord_type=t,d.volume=this.amountToPrecision(e,i)));const c=this.safeString2(r,"clientOrderId","identifier");c!==void 0&&(d.identifier=c),r=this.omit(r,["clientOrderId","identifier"]);const u=await this.privatePostOrders(this.extend(d,r));return this.parseOrder(u)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={uuid:e},n=await this.privateDeleteOrder(this.extend(i,s));return this.parseOrder(n)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.limit=s);const a=await this.privateGetDeposits(this.extend(n,i));return this.parseTransactions(a,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.limit=s);const a=await this.privateGetWithdraws(this.extend(n,i));return this.parseTransactions(a,r,t,s)}parseTransactionStatus(e){const t={submitting:"pending",submitted:"pending",almost_accepted:"pending",rejected:"failed",accepted:"pending",processing:"pending",done:"ok",canceled:"canceled"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"uuid"),i=this.safeNumber(e,"amount"),n=void 0,r=void 0,a=this.safeString(e,"txid"),o=this.safeString(e,"done_at"),d=this.parse8601(o),c=this.parse8601(this.safeString(e,"created_at",o));let u=this.safeString(e,"type");u==="withdraw"&&(u="withdrawal");const h=this.safeString(e,"currency"),l=this.safeCurrencyCode(h),p=this.parseTransactionStatus(this.safeStringLower(e,"state")),m=this.safeNumber(e,"fee");return{info:e,id:s,currency:l,amount:i,network:void 0,address:n,addressTo:void 0,addressFrom:void 0,tag:r,tagTo:void 0,tagFrom:void 0,status:p,type:u,updated:d,txid:a,timestamp:c,datetime:this.iso8601(c),fee:{currency:l,cost:m}}}parseOrderStatus(e){const t={wait:"open",done:"closed",cancel:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"uuid");let i=this.safeString(e,"side");i==="bid"?i="buy":i="sell";let n=this.safeString(e,"ord_type");const r=this.parse8601(this.safeString(e,"created_at")),a=this.parseOrderStatus(this.safeString(e,"state"));let o,d=this.safeNumber(e,"price");const c=this.safeNumber(e,"volume"),u=this.safeNumber(e,"remaining_volume"),h=this.safeNumber(e,"executed_volume");let l;n==="price"&&(n="market",l=d,d=void 0);let p,m,g=this.safeNumber(e,"paid_fee");const y=this.safeString(e,"market");t=this.safeMarket(y,t);let b=this.safeValue(e,"trades",[]);b=this.parseTrades(b,t,void 0,void 0,{order:s,type:n});const w=b.length;if(w>0){o=b[w-1].timestamp;let k=!1;g===void 0&&(k=!0,g=0),l=0;for(let T=0;T<w;T++){const I=b[T];if(l=this.sum(l,I.cost),k){const _=this.safeValue(b[T],"fee",{}),N=this.safeNumber(_,"cost");N!==void 0&&(g=this.sum(g,N))}}p=l/h}return g!==void 0&&(m={currency:t.quote,cost:g}),{info:e,id:s,clientOrderId:void 0,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:o,symbol:t.symbol,type:n,timeInForce:void 0,postOnly:void 0,side:i,price:d,stopPrice:void 0,cost:l,average:p,amount:c,filled:h,remaining:u,status:a,fee:m,trades:b}}async fetchOrdersByState(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={state:e};let a;t!==void 0&&(a=this.market(t),r.market=a.id);const o=await this.privateGetOrders(this.extend(r,n));return this.parseOrders(o,a,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState("wait",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState("done",e,t,s,i)}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState("cancel",e,t,s,i)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={uuid:e},n=await this.privateGetOrder(this.extend(i,s));return this.parseOrder(n)}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetDepositsCoinAddresses(t);return this.parseDepositAddresses(s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"deposit_address"),i=this.safeString(e,"secondary_address"),n=this.safeString(e,"currency"),r=this.safeCurrencyCode(n);return this.checkAddress(s),{currency:r,address:s,tag:i,network:void 0,info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i=await this.privateGetDepositsCoinAddress(this.extend({currency:s.id},t));return this.parseDepositAddress(i)}async createDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.privatePostDepositsGenerateCoinAddress(this.extend(i,t));if(this.safeString(n,"message")!==void 0)throw new M7(this.id+" is generating "+e+" deposit address, call fetchDepositAddress or createDepositAddress one more time later to retrieve the generated address");return this.parseDepositAddress(n)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={amount:t};let o="privatePostWithdraws";e!=="KRW"?(o+="Coin",a.currency=r.id,a.address=s,i!==void 0&&(a.secondary_address=i)):o+="Krw";const d=await this[o](this.extend(a,n));return this.parseTransaction(d)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.implodeParams(this.urls.api[t],{hostname:this.hostname});a+="/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(s!=="POST"&&Object.keys(o).length&&(a+="?"+this.urlencode(o)),t==="private"){this.checkRequiredCredentials();const d=this.nonce(),c={access_key:this.apiKey,nonce:d};if(Object.keys(o).length){const h=this.urlencode(o),l=this.hash(this.encode(h),"sha512");c.query_hash=l,c.query_hash_alg="SHA512"}n={Authorization:"Bearer "+this.jwt(c,this.encode(this.secret))},s!=="GET"&&s!=="DELETE"&&(r=this.json(i),n["Content-Type"]="application/json")}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeValue(a,"error");if(c!==void 0){const u=this.safeString(c,"message"),h=this.safeString(c,"name"),l=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,l),this.throwExactlyMatchedException(this.exceptions.exact,h,l),this.throwBroadlyMatchedException(this.exceptions.broad,u,l),this.throwBroadlyMatchedException(this.exceptions.broad,h,l),new Gc(l)}}};const A7=me,{ArgumentsRequired:B7,AuthenticationError:Ii,InsufficientFunds:yh,InvalidOrder:Jr,AccountSuspended:N7,ExchangeError:$c,DuplicateOrderId:E7,OrderNotFound:V7,BadSymbol:q7,ExchangeNotAvailable:TT,BadRequest:bh}=oe,wh=ke;var L7=class extends A7{describe(){return this.deepExtend(super.describe(),{id:"wavesexchange",name:"Waves.Exchange",countries:["CH"],certified:!1,pro:!1,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchDepositAddress:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTransfer:!1,fetchTransfers:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,signIn:!0,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","3h":"3h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/84547058-5fb27d80-ad0b-11ea-8711-78ac8b3c7f31.jpg",test:{matcher:"https://matcher-testnet.waves.exchange",node:"https://nodes-testnet.wavesnodes.com",public:"https://api-testnet.wavesplatform.com/v0",private:"https://api-testnet.waves.exchange/v1",forward:"https://testnet.waves.exchange/api/v1/forward/matcher",market:"https://testnet.waves.exchange/api/v1/forward/marketdata/api/v1"},api:{matcher:"https://matcher.waves.exchange",node:"https://nodes.waves.exchange",public:"https://api.wavesplatform.com/v0",private:"https://api.waves.exchange/v1",forward:"https://waves.exchange/api/v1/forward/matcher",market:"https://waves.exchange/api/v1/forward/marketdata/api/v1"},doc:"https://docs.waves.exchange",www:"https://waves.exchange"},api:{matcher:{get:["matcher","matcher/settings","matcher/settings/rates","matcher/balance/reserved/{publicKey}","matcher/debug/allSnashotOffsets","matcher/debug/currentOffset","matcher/debug/lastOffset","matcher/debug/oldestSnapshotOffset","matcher/orderbook","matcher/orderbook/{amountAsset}/{priceAsset}","matcher/orderbook/{baseId}/{quoteId}/publicKey/{publicKey}","matcher/orderbook/{baseId}/{quoteId}/{orderId}","matcher/orderbook/{baseId}/{quoteId}/info","matcher/orderbook/{baseId}/{quoteId}/status","matcher/orderbook/{baseId}/{quoteId}/tradeableBalance/{address}","matcher/orderbook/{publicKey}","matcher/orderbook/{publicKey}/{orderId}","matcher/orders/{address}","matcher/orders/{address}/{orderId}","matcher/transactions/{orderId}"],post:["matcher/orderbook","matcher/orderbook/market","matcher/orderbook/cancel","matcher/orderbook/{baseId}/{quoteId}/cancel","matcher/orderbook/{amountAsset}/{priceAsset}/calculateFee","matcher/debug/saveSnapshots","matcher/orders/{address}/cancel","matcher/orders/cancel/{orderId}"],delete:["matcher/orderbook/{baseId}/{quoteId}","matcher/settings/rates/{assetId}"],put:["matcher/settings/rates/{assetId}"]},node:{get:["addresses","addresses/balance/{address}","addresses/balance/{address}/{confirmations}","addresses/balance/details/{address}","addresses/data/{address}","addresses/data/{address}/{key}","addresses/effectiveBalance/{address}","addresses/effectiveBalance/{address}/{confirmations}","addresses/publicKey/{publicKey}","addresses/scriptInfo/{address}","addresses/scriptInfo/{address}/meta","addresses/seed/{address}","addresses/seq/{from}/{to}","addresses/validate/{address}","alias/by-address/{address}","alias/by-alias/{alias}","assets/{assetId}/distribution/{height}/{limit}","assets/balance/{address}","assets/balance/{address}/{assetId}","assets/details/{assetId}","assets/nft/{address}/limit/{limit}","blockchain/rewards","blockchain/rewards/height","blocks/address/{address}/{from}/{to}/","blocks/at/{height}","blocks/delay/{signature}/{blockNum}","blocks/first","blocks/headers/last","blocks/headers/seq/{from}/{to}","blocks/height","blocks/height/{signature}","blocks/last","blocks/seq/{from}/{to}","blocks/signature/{signature}","consensus/algo","consensus/basetarget","consensus/basetarget/{blockId}","consensus/{generatingbalance}/address","consensus/generationsignature","consensus/generationsignature/{blockId}","debug/balances/history/{address}","debug/blocks/{howMany}","debug/configInfo","debug/historyInfo","debug/info","debug/minerInfo","debug/portfolios/{address}","debug/state","debug/stateChanges/address/{address}","debug/stateChanges/info/{id}","debug/stateWaves/{height}","leasing/active/{address}","node/state","node/version","peers/all","peers/blacklisted","peers/connected","peers/suspended","transactions/address/{address}/limit/{limit}","transactions/info/{id}","transactions/status","transactions/unconfirmed","transactions/unconfirmed/info/{id}","transactions/unconfirmed/size","utils/seed","utils/seed/{length}","utils/time","wallet/seed"],post:["addresses","addresses/data/{address}","addresses/sign/{address}","addresses/signText/{address}","addresses/verify/{address}","addresses/verifyText/{address}","debug/blacklist","debug/print","debug/rollback","debug/validate","node/stop","peers/clearblacklist","peers/connect","transactions/broadcast","transactions/calculateFee","tranasctions/sign","transactions/sign/{signerAddress}","tranasctions/status","utils/hash/fast","utils/hash/secure","utils/script/compileCode","utils/script/compileWithImports","utils/script/decompile","utils/script/estimate","utils/sign/{privateKey}","utils/transactionsSerialize"],delete:["addresses/{address}","debug/rollback-to/{signature}"]},public:{get:["assets","pairs","candles/{baseId}/{quoteId}","transactions/exchange"]},private:{get:["deposit/addresses/{currency}","deposit/addresses/{currency}/{platform}","platforms","deposit/currencies","withdraw/currencies","withdraw/addresses/{currency}/{address}"],post:["oauth2/token"]},forward:{get:["matcher/orders/{address}","matcher/orders/{address}/{orderId}"],post:["matcher/orders/{wavesAddress}/cancel"]},market:{get:["tickers"]}},currencies:{WX:{id:"EMAMLxDnv3xiz8RXg8Btj33jcEw3wLczL3JKYYmuubpc",numericId:void 0,code:"WX",precision:8}},options:{allowedCandles:1440,accessToken:void 0,createMarketBuyOrderRequiresPrice:!0,matcherPublicKey:void 0,quotes:void 0,createOrderDefaultExpiry:24192e5,wavesAddress:void 0,withdrawFeeUSDN:7420,withdrawFeeWAVES:1e5,wavesPrecision:8,messagePrefix:"W",networks:{ERC20:"ETH",BEP20:"BSC"},reverseNetworks:{ETH:"ERC20",BSC:"BEP20"}},commonCurrencies:{EGG:"Waves Ducks"},requiresEddsa:!0,exceptions:{3147270:yh,112:yh,4:$c,13:TT,14:TT,3145733:N7,3148040:E7,3148801:Ii,9440512:Ii,9440771:q7,9441026:Jr,9441282:Jr,9441286:Jr,9441295:Jr,9441540:Jr,9441542:Jr,106954752:Ii,106954769:Ii,106957828:Ii,106960131:Ii,106981137:Ii,9437184:bh,9437193:V7,1048577:bh,1051904:Ii}})}setSandboxMode(e){return this.options.messagePrefix=e?"T":"W",super.setSandboxMode(e)}async getFeesForAsset(e,t,s,i,n={}){await this.loadMarkets();const r=this.market(e);s=this.amountToPrecision(e,s),i=this.priceToPrecision(e,i);const a=this.extend({amountAsset:r.baseId,priceAsset:r.quoteId,orderType:t,amount:s,price:i},n);return await this.matcherPostMatcherOrderbookAmountAssetPriceAssetCalculateFee(a)}async calculateFee(e,t,s,i,n,r="taker",a={}){const o=await this.getFeesForAsset(e,s,i,n),d=this.safeValue(a,"isDiscountFee",!1);let c;d?c=this.safeValue(o,"discount"):c=this.safeValue(o,"base");const u=this.safeString(c,"matcherFee"),h=this.safeString(c,"feeAssetId"),l=this.safeCurrencyCode(h),p=this.currencyFromPrecision(l,u),m=this.numberToString(i),g=this.numberToString(n),y=this.feeToPrecision(e,this.parseNumber(p)),b=wh.stringDiv(p,wh.stringMul(m,g));return{type:r,currency:l,rate:this.parseNumber(b),cost:this.parseNumber(y)}}async getQuotes(){let e=this.safeValue(this.options,"quotes");if(e)return e;{const t=await this.matcherGetMatcherSettings();e={};const s=this.safeValue(t,"priceAssets");for(let i=0;i<s.length;i++)e[s[i]]=!0;return this.options.quotes=e,e}}async fetchMarkets(e={}){const t=await this.marketGetTickers(),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"amountAssetID"),a=this.safeString(n,"priceAssetID"),o=r+"/"+a,d=this.safeString(n,"symbol");let[c,u]=d.split("/");c=this.safeCurrencyCode(c),u=this.safeCurrencyCode(u);const h=c+"/"+u;s.push({id:o,symbol:h,base:c,quote:u,settle:void 0,baseId:r,quoteId:a,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeInteger(n,"amountAssetDecimals"),price:this.safeInteger(n,"priceAssetDecimals")},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:n})}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n=this.extend({amountAsset:i.baseId,priceAsset:i.quoteId},s),r=await this.matcherGetMatcherOrderbookAmountAssetPriceAsset(n),a=this.safeInteger(r,"timestamp"),o=this.parseOrderBookSide(this.safeValue(r,"bids"),i,t),d=this.parseOrderBookSide(this.safeValue(r,"asks"),i,t);return{symbol:e,bids:o,asks:d,timestamp:a,datetime:this.iso8601(a),nonce:void 0}}parseOrderBookSide(e,t=void 0,s=void 0){const i=t.precision,n=this.safeInteger(this.options,"wavesPrecision",8),r=Math.pow(10,i.amount),a=i.amount-i.price,o=Math.pow(10,n-a),d=[];for(let c=0;c<e.length;c++){const u=e[c],h=this.safeInteger(u,"price",0)/o,l=this.safeInteger(u,"amount",0)/r;if(s!==void 0&&c>s)break;d.push([h,l])}return d}checkRequiredKeys(){if(this.apiKey===void 0)throw new Ii(this.id+" requires apiKey credential");if(this.secret===void 0)throw new Ii(this.id+" requires secret credential");let e,t;try{e=this.base58ToBinary(this.apiKey)}catch{throw new Ii(this.id+" apiKey must be a base58 encoded public key")}try{t=this.base58ToBinary(this.secret)}catch{throw new Ii(this.id+" secret must be a base58 encoded private key")}const s=this.binaryToBase16(e),i=this.binaryToBase16(t);if(s.length!==64)throw new Ii(this.id+" apiKey must be a base58 encoded public key");if(i.length!==64)throw new Ii(this.id+" secret must be a base58 encoded private key")}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.omit(i,this.extractParams(e)),o=e==="matcher/orders/{wavesAddress}/cancel";e=this.implodeParams(e,i);let d=this.urls.api[t]+"/"+e,c=this.urlencodeWithArrayRepeat(a);if(t==="private"||t==="forward"){n={Accept:"application/json"};const u=this.safeString(this.options,"accessToken");u&&(n.Authorization="Bearer "+u),s==="POST"?n["content-type"]="application/json":n["content-type"]="application/x-www-form-urlencoded",o&&(r=this.json([a.orderId]),c=""),c.length>0&&(d+="?"+c)}else t==="matcher"?s==="POST"?(n={Accept:"application/json","Content-Type":"application/json"},r=this.json(a)):n=a:s==="POST"?(n={"content-type":"application/json"},r=this.json(a)):(n={"content-type":"application/x-www-form-urlencoded"},c.length>0&&(d+="?"+c));return{url:d,method:s,body:r,headers:n}}async signIn(e={}){if(!this.safeString(this.options,"accessToken")){const t="ffffff01";let i=this.sum(this.seconds(),604800);i=i.toString();const n="waves.exchange",a=this.safeString(this.options,"messagePrefix","W")+":"+n+":"+i,o=this.binaryToBase16(this.stringToBinary(this.encode(a))),d=t+o,c=this.binaryToBase16(this.base58ToBinary(this.secret)),u=this.eddsa(d,c,"ed25519"),h={grant_type:"password",scope:"general",username:this.apiKey,password:i+":"+u,client_id:n},l=await this.privatePostOauth2Token(h);return this.options.accessToken=this.safeString(l,"access_token"),this.options.accessToken}}parseTicker(e,t=void 0){const i=this.safeString(e,"amountAsset"),n=this.safeString(e,"priceAsset");let r;if(i!==void 0&&n!==void 0){const m=i+"/"+n;t=this.safeMarket(m,t,"/"),r=t.symbol}const a=this.safeValue(e,"data",{}),o=this.safeString(a,"lastPrice"),d=this.safeString(a,"low"),c=this.safeString(a,"high"),u=this.safeString(a,"weightedAveragePrice"),h=this.safeString(a,"volume"),l=this.safeString(a,"quoteVolume"),p=this.safeString(a,"firstPrice");return this.safeTicker({symbol:r,timestamp:void 0,datetime:this.iso8601(void 0),high:c,low:d,bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:u,open:p,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:h,quoteVolume:l,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pairs:s.id},n=await this.publicGetPairs(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0,{});return this.parseTicker(a,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetPairs(t),i=this.safeValue(s,"data",[]);return this.parseTickers(i,e)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={baseId:r.baseId,quoteId:r.quoteId,interval:this.timeframes[t]},o=this.safeInteger(this.options,"allowedCandles",1440);i===void 0&&(i=o),i=Math.min(o,i);const d=this.parseTimeframe(t)*1e3;if(s===void 0){const m=parseInt(this.milliseconds()/d)*d,g=(i-1)*d,y=m-g;a.timeStart=y.toString()}else{a.timeStart=s.toString();const m=this.sum(s,d*i);a.timeEnd=m.toString()}const c=await this.publicGetCandlesBaseIdQuoteId(this.extend(a,n)),u=this.safeValue(c,"data",[]);let h=this.parseOHLCVs(u,r,t,s,i);h=this.filterFutureCandles(h);let l;const p=h.length;for(let m=0;m<h.length;m++){const g=p-m-1,y=h[g];y[1]===void 0&&(y[1]=l,y[2]=l,y[3]=l,y[4]=l,h[g]=y),l=y[4]}return h}filterFutureCandles(e){const t=[],s=this.milliseconds();for(let i=0;i<e.length&&!(e[i][0]>s);i++)t.push(e[i]);return t}parseOHLCV(e,t=void 0){const s=this.safeValue(e,"data",{});return[this.parse8601(this.safeString(s,"time")),this.safeNumber(s,"open"),this.safeNumber(s,"high"),this.safeNumber(s,"low"),this.safeNumber(s,"close"),this.safeNumber(s,"volume",0)]}async fetchDepositAddress(e,t={}){await this.signIn();const s=this.safeValue(this.options,"networks",{}),i=this.safeStringUpper(t,"network"),n=this.safeString(s,i,i);t=this.omit(t,["network"]);const r=await this.privateGetPlatforms(),a={},o={},d=this.safeValue(r,"items",[]);for(let y=0;y<d.length;y++){const b=d[y],w=this.safeString(b,"id"),S=this.safeValue(b,"currencies",[]);for(let k=0;k<S.length;k++){const T=this.safeString(S,k);a[T]=!0,T in o||(o[T]={}),o[T][w]=!0}}if(!(e in a)){const y=Object.keys(a);throw new $c(this.id+" fetchDepositAddress() "+e+" not supported. Currency code must be one of "+y.join(", "))}let c;if(n===void 0){const y={currency:e};c=await this.privateGetDepositAddressesCurrency(this.extend(y,t))}else{const y=o[e];if(!(n in y)){const b=Object.keys(y);throw new $c(this.id+" "+n+" network "+e+" deposit address not supported. Network must be one of "+b.join(", "))}if(n==="WAVES"){const b={publicKey:this.apiKey},w=await this.nodeGetAddressesPublicKeyPublicKey(this.extend(b,b));return{address:this.safeString(w,"address"),code:e,currency:e,network:n,tag:void 0,info:w}}else{const b={currency:e,platform:n};c=await this.privateGetDepositAddressesCurrencyPlatform(this.extend(b,t))}}const u=this.safeValue(c,"currency"),h=this.safeString(u,"platform_id"),l=this.safeValue(this.options,"reverseNetworks",{}),p=this.safeString(l,h,h),m=this.safeValue(c,"deposit_addresses");return{address:this.safeString(m,0),code:e,currency:e,tag:void 0,network:p,info:c}}async getMatcherPublicKey(){const e=this.safeString(this.options,"matcherPublicKey");if(e)return e;{const t=await this.matcherGetMatcher();return this.options.matcherPublicKey=t.slice(1,t.length-1),this.options.matcherPublicKey}}getAssetBytes(e){return e==="WAVES"?this.numberToBE(0,1):this.binaryConcat(this.numberToBE(1,1),this.base58ToBinary(e))}getAssetId(e){return e==="WAVES"?"":e}priceToPrecision(e,t){const s=this.markets[e],i=this.safeInteger(this.options,"wavesPrecision",8),n=s.precision.amount-s.precision.price;return parseInt(parseFloat(this.toPrecision(t,i-n)))}amountToPrecision(e,t){return parseInt(parseFloat(this.toPrecision(t,this.markets[e].precision.amount)))}currencyToPrecision(e,t,s=void 0){return parseInt(parseFloat(this.toPrecision(t,this.currencies[e].precision)))}fromPrecision(e,t){if(e===void 0)return;const s=new wh(e);return s.decimals=this.sum(s.decimals,t),s.reduce(),s.toString()}toPrecision(e,t){const s=e.toString(),i=new wh(s);return i.decimals=i.decimals-t,i.reduce(),i.toString()}currencyFromPrecision(e,t){const s=this.currencies[e].precision;return this.fromPrecision(t,s)}priceFromPrecision(e,t){const s=this.markets[e],i=this.safeInteger(this.options,"wavesPrecision",8),n=this.sum(i,s.precision.price)-s.precision.amount;return this.fromPrecision(t,n)}safeGetDynamic(e){const t=this.safeValue(e,"orderFee");return"dynamic"in t?this.safeValue(t,"dynamic"):this.safeValue(t.composite.default,"dynamic")}safeGetRates(e){const t=this.safeValue(e,"rates");return t===void 0?{WAVES:1}:t}async createOrder(e,t,s,i,n=void 0,r={}){this.checkRequiredDependencies(),this.checkRequiredKeys(),await this.loadMarkets();const a=this.market(e),o=await this.getMatcherPublicKey(),d=this.getAssetId(a.baseId),c=this.getAssetId(a.quoteId),u=t==="market";if(u&&n===void 0)throw new Jr(this.id+" createOrder() requires a price argument for "+t+" orders to determine the max price for buy and the min price for sell");const h=s==="buy"?0:1,l=this.milliseconds(),p=this.safeInteger(this.options,"createOrderDefaultExpiry",24192e5),m=this.sum(l,p),g=await this.getFeesForAsset(e,s,i,n),y=this.safeValue(g,"base"),b=this.safeString(y,"feeAssetId"),w=this.safeCurrencyCode(b),S=this.safeString(y,"matcherFee"),k=this.safeValue(g,"discount"),T=this.safeString(k,"feeAssetId"),I=this.safeCurrencyCode(T),_=this.safeString(k,"matcherFee");let N,M;if("feeAsset"in r||"feeAsset"in this.options){const R=this.safeString(r,"feeAsset",this.safeString(this.options,"feeAsset")),H=this.currency(R);N=this.safeString(H,"id")}const x=await this.fetchBalance();if(N!==void 0){if(b!==N&&T!==N)throw new Jr(this.id+" asset fee must be "+w+" or "+I);const R=this.safeCurrencyCode(N),H=N===b?S:_,F=parseFloat(this.currencyFromPrecision(R,H));if(R in x&&x[R].free>=F)M=parseInt(H);else throw new yh(this.id+" not enough funds of the selected asset fee")}if(N===void 0){const R=parseFloat(this.currencyFromPrecision(w,S));if(w in x&&x[w].free>=R)N=b,M=parseInt(S);else{const H=parseFloat(this.currencyFromPrecision(I,_));I in x&&x[I].free>=H&&(N=T,M=parseInt(_))}}if(N===void 0)throw new yh(this.id+" not enough funds on none of the eligible asset fees");i=this.amountToPrecision(e,i),n=this.priceToPrecision(e,n);const v=[this.numberToBE(3,1),this.base58ToBinary(this.apiKey),this.base58ToBinary(o),this.getAssetBytes(a.baseId),this.getAssetBytes(a.quoteId),this.numberToBE(h,1),this.numberToBE(n,8),this.numberToBE(i,8),this.numberToBE(l,8),this.numberToBE(m,8),this.numberToBE(M,8),this.getAssetBytes(N)],O=this.binaryConcatArray(v),A=this.eddsa(this.binaryToBase16(O),this.binaryToBase16(this.base58ToBinary(this.secret)),"ed25519"),V={amountAsset:d,priceAsset:c},q={senderPublicKey:this.apiKey,matcherPublicKey:o,assetPair:V,orderType:s,price:n,amount:i,timestamp:l,expiration:m,matcherFee:parseInt(M),signature:A,version:3};if(N!=="WAVES"&&(q.matcherFeeAssetId=N),u){const R=await this.matcherPostMatcherOrderbookMarket(q),H=this.safeValue(R,"message");return this.parseOrder(H,a)}else{const R=await this.matcherPostMatcherOrderbook(q),H=this.safeValue(R,"message");return this.parseOrder(H,a)}}async cancelOrder(e,t=void 0,s={}){this.checkRequiredDependencies(),this.checkRequiredKeys(),await this.signIn();const i=await this.getWavesAddress(),n=await this.forwardPostMatcherOrdersWavesAddressCancel({wavesAddress:i,orderId:e}),r=this.safeValue(n,"message"),a=this.safeValue(r,0),o=this.safeValue(a,0),d=this.safeString(o,"orderId");return{info:n,id:d,clientOrderId:void 0,timestamp:void 0,datetime:void 0,lastTradeTimestamp:void 0,symbol:t,type:void 0,side:void 0,price:void 0,amount:void 0,cost:void 0,average:void 0,filled:void 0,remaining:void 0,status:void 0,fee:void 0,trades:void 0}}async fetchOrder(e,t=void 0,s={}){this.checkRequiredDependencies(),this.checkRequiredKeys(),await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));const n=this.milliseconds(),r=[this.base58ToBinary(this.apiKey),this.numberToBE(n,8)],a=this.binaryConcatArray(r),o=this.binaryToBase16(this.base58ToBinary(this.secret)),d=this.eddsa(this.binaryToBase16(a),o,"ed25519"),c={Timestamp:n.toString(),Signature:d,publicKey:this.apiKey,orderId:e},u=await this.matcherGetMatcherOrderbookPublicKeyOrderId(this.extend(c,s));return this.parseOrder(u,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(this.checkRequiredDependencies(),this.checkRequiredKeys(),e===void 0)throw new B7(this.id+" fetchOrders() requires symbol argument");await this.loadMarkets();const n=this.market(e),r=this.milliseconds(),a=[this.base58ToBinary(this.apiKey),this.numberToBE(r,8)],o=this.binaryConcatArray(a),d=this.binaryToBase16(this.base58ToBinary(this.secret)),c=this.eddsa(this.binaryToBase16(o),d,"ed25519"),u={Accept:"application/json",Timestamp:r.toString(),Signature:c,publicKey:this.apiKey,baseId:n.baseId,quoteId:n.quoteId},h=await this.matcherGetMatcherOrderbookBaseIdQuoteIdPublicKeyPublicKey(this.extend(u,i));return this.parseOrders(h,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.signIn();let n;e!==void 0&&(n=this.market(e));const a={address:await this.getWavesAddress(),activeOnly:!0},o=await this.forwardGetMatcherOrdersAddress(a);return this.parseOrders(o,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.signIn();let n;e!==void 0&&(n=this.market(e));const a={address:await this.getWavesAddress(),closedOnly:!0},o=await this.forwardGetMatcherOrdersAddress(a);return this.parseOrders(o,n,t,s)}parseOrderStatus(e){const t={Cancelled:"canceled",Accepted:"open",Filled:"closed",PartiallyFilled:"open"};return this.safeString(t,e,e)}getSymbolFromAssetPair(e){const t=this.safeString(e,"amountAsset","WAVES"),s=this.safeString(e,"priceAsset","WAVES");return this.safeCurrencyCode(t)+"/"+this.safeCurrencyCode(s)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString2(e,"type","orderType");let n="limit";"type"in e&&(n=this.safeString(e,"orderType",n));const r=this.safeString(e,"id"),a=this.safeString(e,"filled"),o=this.safeString(e,"price"),d=this.safeString(e,"amount"),c=this.safeValue(e,"assetPair");let u;c!==void 0?u=this.getSymbolFromAssetPair(c):t!==void 0&&(u=t.symbol);const h=this.safeCurrencyCode(this.safeString(c,"amountAsset","WAVES")),l=this.priceFromPrecision(u,o),p=this.currencyFromPrecision(h,d),m=this.currencyFromPrecision(h,a),g=this.priceFromPrecision(u,this.safeString(e,"avgWeighedPrice")),y=this.parseOrderStatus(this.safeString(e,"status"));let b;if("type"in e){const w=this.safeCurrencyCode(this.safeString(e,"feeAsset"));b={currency:w,fee:this.parseNumber(this.currencyFromPrecision(w,this.safeString(e,"filledFee")))}}else{const w=this.safeCurrencyCode(this.safeString(e,"matcherFeeAssetId","WAVES"));b={currency:w,fee:this.parseNumber(this.currencyFromPrecision(w,this.safeString(e,"matcherFee")))}}return this.safeOrder({info:e,id:r,clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,symbol:u,type:n,timeInForce:void 0,postOnly:void 0,side:i,price:l,stopPrice:void 0,amount:p,cost:void 0,average:g,filled:m,remaining:void 0,status:y,fee:b,trades:void 0},t)}async getWavesAddress(){const e=this.safeString(this.options,"wavesAddress");if(e===void 0){const t={publicKey:this.apiKey},s=await this.nodeGetAddressesPublicKeyPublicKey(t);return this.options.wavesAddress=this.safeString(s,"address"),this.options.wavesAddress}else return e}async fetchBalance(e={}){this.checkRequiredDependencies(),this.checkRequiredKeys(),await this.loadMarkets();const t=await this.getWavesAddress(),s={address:t},i=await this.nodeGetAssetsBalanceAddress(s),n=this.safeValue(i,"balances",[]),r={};let a;const o=[],d=[];for(let T=0;T<n.length;T++){const I=n[T],_=this.safeInteger(I,"timestamp");a=a===void 0?_:Math.max(a,_);const N=this.safeValue(I,"issueTransaction"),M=this.safeString(I,"assetId"),x=this.safeString(I,"balance");if(N===void 0){o.push(M),d.push(x);continue}const v=this.safeInteger(N,"decimals");let O;M in this.currencies_by_id&&(O=this.safeCurrencyCode(M),r[O]=this.account(),r[O].total=this.fromPrecision(x,v))}if(o.length){const T={ids:o},I=await this.publicGetAssets(T),_=this.safeValue(I,"data",[]);for(let N=0;N<_.length;N++){const M=_[N],x=d[N],v=this.safeValue(M,"data"),O=this.safeInteger(v,"precision"),A=this.safeString(v,"ticker"),V=this.safeCurrencyCode(A);r[V]=this.account(),r[V].total=this.fromPrecision(x,O)}}const u=this.milliseconds(),h=[this.base58ToBinary(this.apiKey),this.numberToBE(u,8)],l=this.binaryConcatArray(h),p=this.binaryToBase16(this.base58ToBinary(this.secret)),m=this.eddsa(this.binaryToBase16(l),p,"ed25519"),g={publicKey:this.apiKey,signature:m,timestamp:u.toString()},y=await this.matcherGetMatcherBalanceReservedPublicKey(g),b=Object.keys(y);for(let T=0;T<b.length;T++){const I=b[T],_=this.safeCurrencyCode(I);_ in r||(r[_]=this.account());const N=this.safeString(y,I);_ in this.currencies?r[_].used=this.currencyFromPrecision(_,N):r[_].used=N}const w={address:t},S=await this.nodeGetAddressesBalanceAddress(w);r.WAVES=this.safeValue(r,"WAVES",{}),r.WAVES.total=this.currencyFromPrecision("WAVES",this.safeString(S,"balance"));const k=Object.keys(r);for(let T=0;T<k.length;T++){const I=k[T];this.safeValue(r[I],"used")===void 0&&(r[I].used="0")}return r.timestamp=a,r.datetime=this.iso8601(a),this.safeBalance(r)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={sender:await this.getWavesAddress()};let a;e!==void 0&&(a=this.market(e),r.amountAsset=a.baseId,r.priceAsset=a.quoteId);const o=await this.publicGetTransactionsExchange(r),d=this.safeValue(o,"data");return this.parseTrades(d,a,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={amountAsset:n.baseId,priceAsset:n.quoteId};s!==void 0&&(r.limit=s),t!==void 0&&(r.timeStart=t);const a=await this.publicGetTransactionsExchange(r),o=this.safeValue(a,"data");return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){const s=this.safeValue(e,"data"),i=this.safeString(s,"timestamp"),n=this.parse8601(i),r=this.safeString(s,"id"),a=this.safeString(s,"price"),o=this.safeString(s,"amount"),d=this.safeValue(s,"order1"),c=this.safeValue(s,"order2");let u;this.safeString(d,"senderPublicKey")===this.apiKey?u=d:u=c;let h;const l=this.safeValue(u,"assetPair");l!==void 0?h=this.getSymbolFromAssetPair(l):t!==void 0&&(h=t.symbol);const p=this.safeString(u,"orderType"),m=this.safeString(u,"id"),g={cost:this.safeString(u,"matcherFee"),currency:this.safeCurrencyCode(this.safeString(u,"matcherFeeAssetId","WAVES"))};return this.safeTrade({info:e,timestamp:n,datetime:i,symbol:h,id:r,order:m,type:void 0,side:p,takerOrMaker:void 0,price:a,amount:o,cost:void 0,fee:g},t)}handleErrors(e,t,s,i,n,r,a,o,d){const c=this.safeString(a,"error"),u=this.safeValue(a,"success",!0),h=this.safeValue(this.exceptions,c);if(h!==void 0){const p=this.safeString(a,"message");throw new h(this.id+" "+p)}if(this.safeString(a,"message")==="Validation Error")throw new bh(this.id+" "+r);if(!u)throw new $c(this.id+" "+r)}async withdraw(e,t,s,i=void 0,n={}){if([i,n]=this.handleWithdrawTagAndParams(i,n),e!=="WAVES"){const N=await this.privateGetWithdrawCurrencies(),M={},x=this.safeValue(N,"items",[]);for(let v=0;v<x.length;v++){const O=x[v],A=this.safeString(O,"id");M[A]=!0}if(!(e in M)){const v=Object.keys(M);throw new $c(this.id+" withdraw() "+e+" not supported. Currency code must be one of "+v.toString())}}await this.loadMarkets();const r=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"],a={};for(let N=0;N<r.length;N++){const M=r[N];a[M]=!0}let o=!0;const c=this.remove0xPrefix(s).toLowerCase();for(let N=0;N<c.length;N++)if(!(c[N]in a)){o=!1;break}await this.signIn();let u;if(e==="WAVES"&&!o)u=s;else{const N={address:s,currency:e},M=await this.privateGetWithdrawAddressesCurrencyAddress(N),x=this.safeValue(M,"currency"),v=this.safeValue(x,"allowed_amount"),O=this.safeNumber(v,"min");if(t<=O)throw new bh(this.id+" "+e+" withdraw failed, amount "+t.toString()+" must be greater than the minimum allowed amount of "+O.toString());const A=this.safeValue(M,"proxy_addresses",[]);u=this.safeString(A,0)}const h=this.safeInteger(this.options,"withdrawFeeWAVES",1e5),l="WAVES",p=4,m=2,g=this.currencyToPrecision(e,t),y=this.currency(e),b=this.milliseconds(),w=[this.numberToBE(4,1),this.numberToBE(2,1),this.base58ToBinary(this.apiKey),this.getAssetBytes(y.id),this.getAssetBytes(l),this.numberToBE(b,8),this.numberToBE(g,8),this.numberToBE(h,8),this.base58ToBinary(u),this.numberToBE(0,2)],S=this.binaryConcatArray(w),k=this.binaryToBase16(this.base58ToBinary(this.secret)),T=this.eddsa(this.binaryToBase16(S),k,"ed25519"),I={senderPublicKey:this.apiKey,amount:g,fee:h,type:p,version:m,attachment:"",feeAssetId:this.getAssetId(l),proofs:[T],assetId:this.getAssetId(y.id),recipient:u,timestamp:b,signature:T},_=await this.nodePostTransactionsBroadcast(I);return this.parseTransaction(_,y)}parseTransaction(e,t=void 0){return t=this.safeCurrency(void 0,t),{id:void 0,txid:void 0,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0,info:e}}};const R7=me,{ExchangeError:lg,BadRequest:jc,RateLimitExceeded:F7,BadSymbol:D7,ArgumentsRequired:pg,PermissionDenied:H7,InsufficientFunds:G7,InvalidOrder:OT}=oe,{TICK_SIZE:U7}=pe,IT=ke;var X_=class extends R7{describe(){return this.deepExtend(super.describe(),{id:"wazirx",name:"WazirX",countries:["IN"],version:"v2",rateLimit:1e3,pro:!0,has:{CORS:!1,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchBidsAsks:!1,fetchClosedOrders:!1,fetchCurrencies:!1,fetchDepositAddress:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!1,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfers:!1,fetchWithdrawals:!1,transfer:!1,withdraw:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/148647666-c109c20b-f8ac-472f-91c3-5f658cb90f49.jpeg",api:{rest:"https://api.wazirx.com/sapi/v1"},www:"https://wazirx.com",doc:"https://docs.wazirx.com/#public-rest-api-for-wazirx",fees:"https://wazirx.com/fees",referral:"https://wazirx.com/invite/k7rrnks5"},api:{public:{get:{exchangeInfo:1,depth:1,ping:1,systemStatus:1,"tickers/24hr":1,"ticker/24hr":1,time:1,trades:1,klines:1}},private:{get:{account:1,allOrders:1,funds:1,historicalTrades:1,openOrders:1,order:1,myTrades:1},post:{order:1,"order/test":1},delete:{order:1,openOrders:1}}},fees:{WRX:{maker:this.parseNumber("0.0"),taker:this.parseNumber("0.0")}},precisionMode:U7,exceptions:{exact:{"-1121":D7,1999:jc,2002:G7,2005:jc,2078:H7,2098:jc,2031:OT,2113:jc,2115:jc,2136:F7,94001:OT}},timeframes:{"1m":"1m","5m":"5m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","1w":"1w"},options:{recvWindow:1e4}})}async fetchMarkets(e={}){const t=await this.publicGetExchangeInfo(e),s=this.safeValue(t,"symbols",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeString(r,"baseAsset"),d=this.safeString(r,"quoteAsset"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d),h=this.safeValue(r,"isSpotTradingAllowed"),l=this.safeValue(r,"filters");let p;for(let w=0;w<l.length;w++){const S=l[w];this.safeString(S,"filterType")==="PRICE_FILTER"&&(p=this.safeNumber(S,"minPrice"))}const m=this.safeValue(this.fees,u,{});let g=this.safeString(m,"taker","0.2");g=IT.stringDiv(g,"100");let y=this.safeString(m,"maker","0.2");y=IT.stringDiv(y,"100");const b=this.safeString(r,"status");i.push({id:a,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:h,margin:!1,swap:!1,future:!1,option:!1,active:b==="trading",contract:!1,linear:void 0,inverse:void 0,taker:this.parseNumber(g),maker:this.parseNumber(y),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"baseAssetPrecision"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"quoteAssetPrecision")))},limits:{leverage:{min:void 0,max:void 0},price:{min:p,max:void 0},amount:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,interval:this.timeframes[t]};i!==void 0&&(a.limit=i);const o=this.safeInteger(n,"until");n=this.omit(n,["until"]),s!==void 0&&(a.startTime=parseInt(s/1e3)),o!==void 0&&(a.endTime=o);const d=await this.publicGetKlines(this.extend(a,n));return this.parseOHLCVs(d,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={symbol:this.market(e).id};t!==void 0&&(n.limit=t);const r=await this.publicGetDepth(this.extend(n,s)),a=this.safeInteger(r,"timestamp");return this.parseOrderBook(r,e,a)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetTicker24hr(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickers24hr(),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.parseTicker(r),o=a.symbol;i[o]=a}return i}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s);const a=this.safeString(this.options,"fetchTradesMethod","publicGetTrades"),o=await this[a](this.extend(r,i));return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeInteger(e,"time"),n=this.iso8601(i);t=this.safeMarket(void 0,t);const a=this.safeValue(e,"isBuyerMaker")?"sell":"buy",o=this.safeNumber(e,"price"),d=this.safeNumber(e,"qty"),c=this.safeNumber(e,"quoteQty");return this.safeTrade({info:e,id:s,timestamp:i,datetime:n,symbol:t.symbol,order:s,type:void 0,side:a,takerOrMaker:void 0,price:o,amount:d,cost:c,fee:void 0},t)}async fetchStatus(e={}){const t=await this.publicGetSystemStatus(e);return{status:this.safeString(t,"status")==="normal"?"ok":"maintenance",updated:void 0,eta:void 0,url:void 0,info:t}}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeInteger(t,"serverTime")}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeString(e,"lastPrice"),r=this.safeString(e,"openPrice"),a=this.safeString(e,"highPrice"),o=this.safeString(e,"lowPrice"),d=this.safeString(e,"volume"),c=this.safeString(e,"bidPrice"),u=this.safeString(e,"askPrice"),h=this.safeInteger(e,"at");return this.safeTicker({symbol:i,timestamp:h,datetime:this.iso8601(h),high:a,low:o,bid:c,bidVolume:void 0,ask:u,askVolume:void 0,vwap:void 0,open:r,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:d,quoteVolume:void 0,info:e},t)}parseBalance(e){const t={};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"asset"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"free"),a.used=this.safeString(i,"locked"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetFunds(e);return this.parseBalance(t)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new pg(this.id+" fetchOrders() requires a `symbol` argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=s);const a=await this.privateGetAllOrders(this.extend(r,i));let o=this.parseOrders(a,n,t,s);return o=this.filterBy(o,"symbol",e),o}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id);const a=await this.privateGetOpenOrders(this.extend(n,i));return this.parseOrders(a,r,t,s)}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new pg(this.id+" cancelAllOrders() requires a `symbol` argument");await this.loadMarkets();const i={symbol:this.market(e).id};return await this.privateDeleteOpenOrders(this.extend(i,t))}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new pg(this.id+" cancelOrder() requires a `symbol` argument");await this.loadMarkets();const n={symbol:this.market(t).id,orderId:e},r=await this.privateDeleteOrder(this.extend(n,s));return this.parseOrder(r)}async createOrder(e,t,s,i,n=void 0,r={}){if(t=t.toLowerCase(),t!=="limit"&&t!=="stop_limit")throw new lg(this.id+" createOrder() supports limit and stop_limit orders only");if(n===void 0)throw new lg(this.id+" createOrder() requires a price argument");await this.loadMarkets();const a=this.market(e),o={symbol:a.id,side:s,quantity:i,type:"limit"};o.price=this.priceToPrecision(e,n),this.safeString(r,"stopPrice")!==void 0&&(o.type="stop_limit");const c=await this.privatePostOrder(this.extend(o,r));return this.parseOrder(c,a)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"createdTime"),i=this.safeInteger(e,"updatedTime"),n=this.safeString(e,"symbol"),r=this.safeSymbol(n,t),a=this.safeString(e,"quantity"),o=this.safeString(e,"executedQty"),d=this.parseOrderStatus(this.safeString(e,"status")),c=this.safeString(e,"id"),u=this.safeString(e,"price"),h=this.safeStringLower(e,"type"),l=this.safeStringLower(e,"side");return this.safeOrder({info:e,id:c,clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:i,status:d,symbol:r,type:h,timeInForce:void 0,postOnly:void 0,side:l,price:u,amount:a,filled:o,remaining:void 0,cost:void 0,fee:void 0,average:void 0,trades:[]},t)}parseOrderStatus(e){const t={wait:"open",done:"closed",cancel:"canceled"};return this.safeString(t,e,e)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+e;if(t==="public"&&Object.keys(i).length&&(a+="?"+this.urlencode(i)),t==="private"){this.checkRequiredCredentials();const o=this.milliseconds();let d=this.extend({recvWindow:this.options.recvWindow,timestamp:o},i);d=this.keysort(d);const c=this.hmac(this.encode(this.urlencode(d)),this.encode(this.secret),"sha256");a+="?"+this.urlencode(d),a+="&signature="+c,n={"Content-Type":"application/x-www-form-urlencoded","X-Api-Key":this.apiKey}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"code");if(c!==void 0){const u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),new lg(u)}}};const $7=me,{ExchangeNotAvailable:j7,ExchangeError:xT,DDoSProtection:W7,BadSymbol:_T,InvalidOrder:Wc,ArgumentsRequired:Wo,AuthenticationError:z7,OrderNotFound:CT,PermissionDenied:mg,InsufficientFunds:gg,BadRequest:yg,NotSupported:bg}=oe,{TICK_SIZE:K7}=pe,wg=ke;var Y_=class extends $7{describe(){return this.deepExtend(super.describe(),{id:"whitebit",name:"WhiteBit",version:"v2",countries:["EE"],rateLimit:500,has:{CORS:void 0,spot:!0,margin:!0,swap:!1,future:!1,option:!1,borrowMargin:!1,cancelAllOrders:!1,cancelOrder:!0,cancelOrders:!1,createDepositAddress:void 0,createLimitOrder:void 0,createMarketOrder:void 0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:void 0,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrderBook:!0,fetchOrderTrades:!0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFees:!0,repayMargin:!1,setLeverage:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/66732963-8eb7dd00-ee66-11e9-849b-10d9282bb9e0.jpg",api:{v1:{public:"https://whitebit.com/api/v1/public",private:"https://whitebit.com/api/v1"},v2:{public:"https://whitebit.com/api/v2/public"},v4:{public:"https://whitebit.com/api/v4/public",private:"https://whitebit.com/api/v4"}},www:"https://www.whitebit.com",doc:"https://github.com/whitebit-exchange/api-docs",fees:"https://whitebit.com/fee-schedule",referral:"https://whitebit.com/referral/d9bdf40e-28f2-4b52-b2f9-cd1415d82963"},api:{web:{get:["v1/healthcheck"]},v1:{public:{get:["markets","tickers","ticker","symbols","depth/result","history","kline"]},private:{post:["account/balance","order/new","order/cancel","orders","account/order_history","account/executed_history","account/executed_history/all","account/order"]}},v2:{public:{get:["markets","ticker","assets","fee","depth/{market}","trades/{market}"]}},v4:{public:{get:["assets","collateral/markets","fee","orderbook/{market}","ticker","trades/{market}","time","ping"]},private:{post:["collateral-account/balance","collateral-account/positions/history","collateral-account/leverage","collateral-account/positions/open","collateral-account/summary","main-account/address","main-account/balance","main-account/create-new-address","main-account/codes","main-account/codes/apply","main-account/codes/my","main-account/codes/history","main-account/fiat-deposit-url","main-account/history","main-account/withdraw","main-account/withdraw-pay","main-account/transfer","trade-account/balance","trade-account/executed-history","trade-account/order","trade-account/order/history","order/collateral/limit","order/collateral/market","order/collateral/trigger_market","order/new","order/market","order/stock_market","order/stop_limit","order/stop_market","order/cancel","orders","profile/websocket_token"]}}},fees:{trading:{tierBased:!1,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0.001")}},options:{fiatCurrencies:["EUR","USD","RUB","UAH"],accountsByType:{main:"main",spot:"spot",margin:"collateral",trade:"spot"}},precisionMode:K7,exceptions:{exact:{"Unauthorized request.":z7,"The market format is invalid.":_T,"Market is not available":_T,"Invalid payload.":yg,"Amount must be greater than 0":Wc,"Not enough balance.":gg,"The order id field is required.":Wc,"Not enough balance":gg,"This action is unauthorized.":mg,"This API Key is not authorized to perform this action.":mg,"Unexecuted order was not found.":CT,"The selected from is invalid.":yg,503:j7,422:CT},broad:{"Given amount is less than min amount":Wc,"Total is less than":Wc,"fee must be no less than":Wc,"Enable your key in API settings":mg,"You don't have such amount for transfer":gg}}})}async fetchMarkets(e={}){let t=[this.v4PublicGetCollateralMarkets(e),this.v2PublicGetMarkets(e)];t=await Promise.all(t);const s=t[0],i=t[1],n=this.safeValue(i,"result",[]),r=this.safeValue(s,"result",[]),a=[];for(let o=0;o<n.length;o++){const d=n[o],c=this.safeString(d,"name"),u=this.safeString(d,"stock"),h=this.safeString(d,"money"),l=this.safeCurrencyCode(u),p=this.safeCurrencyCode(h),m=l+"/"+p,g=this.safeValue(d,"tradesEnabled"),y=this.inArray(c,r),b={id:c,symbol:m,base:l,quote:p,settle:void 0,baseId:u,quoteId:h,settleId:void 0,type:"spot",spot:!0,margin:y,swap:!1,future:!1,option:!1,active:g,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(d,"makerFee"),maker:this.safeNumber(d,"takerFee"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(d,"stockPrec"))),price:this.parseNumber(this.parsePrecision(this.safeString(d,"moneyPrec")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(d,"minAmount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(d,"minTotal"),max:void 0}},info:d};a.push(b)}return a}async fetchCurrencies(e={}){const t=await this.v4PublicGetAssets(e),s=Object.keys(t),i={};for(let n=0;n<s.length;n++){const r=s[n],a=t[r],o=this.safeValue(a,"can_deposit",!0),d=this.safeValue(a,"can_withdraw",!0),c=o&&d,u=this.safeCurrencyCode(r);i[u]={id:r,code:u,info:a,name:void 0,active:c,deposit:o,withdraw:d,fee:void 0,precision:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.safeNumber(a,"min_withdraw"),max:this.safeNumber(a,"max_withdraw")}}}}return i}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.v4PublicGetFee(t),i=Object.keys(s),n={},r={};for(let a=0;a<i.length;a++){const o=i[a],d=s[o],c=this.safeCurrencyCode(o),u=this.safeValue(d,"withdraw",{});n[c]=this.safeString(u,"fixed");const h=this.safeValue(d,"deposit",{});r[c]=this.safeString(h,"fixed")}return{withdraw:n,deposit:r,info:s}}async fetchTradingFees(e={}){const t=await this.v4PublicGetAssets(e),s={};for(let i=0;i<this.symbols.length;i++){const n=this.symbols[i],r=this.market(n),a=this.safeValue(t,r.baseId,{});let o=this.safeString(a,"maker_fee"),d=this.safeString(a,"taker_fee");o=wg.stringDiv(o,"100"),d=wg.stringDiv(d,"100"),s[n]={info:a,symbol:r.symbol,percentage:!0,tierBased:!1,maker:this.parseNumber(o),taker:this.parseNumber(d)}}return s}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id},n=await this.v1PublicGetTicker(this.extend(i,t)),r=this.safeValue(n,"result",{});return this.parseTicker(r,s)}parseTicker(e,t=void 0){t=this.safeMarket(void 0,t);const s=this.safeString(e,"last_price");return this.safeTicker({symbol:t.symbol,timestamp:void 0,datetime:void 0,high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:s,last:s,previousClose:void 0,change:void 0,percentage:this.safeString(e,"change"),average:void 0,baseVolume:this.safeString2(e,"base_volume","volume"),quoteVolume:this.safeString2(e,"quote_volume","deal"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.v4PublicGetTicker(t),i=Object.keys(s),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeMarket(a),d=this.parseTicker(s[a],o),c=d.symbol;n[c]=d}return this.filterByArray(n,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={market:this.market(e).id};t!==void 0&&(n.depth=t);const r=await this.v4PublicGetOrderbookMarket(this.extend(n,s)),a=this.parseNumber(wg.stringMul(this.safeString(r,"timestamp"),"1000"));return this.parseOrderBook(r,e,a)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market:n.id},a=await this.v4PublicGetTradesMarket(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.market=n.id);const a=await this.v4PrivatePostTradeAccountExecutedHistory(this.extend(r,i));if(Array.isArray(a))return this.parseTrades(a,n,t,s);{let o=[];const d=Object.keys(a);for(let u=0;u<d.length;u++){const h=d[u],l=this.safeMarket(h,void 0,"_"),p=this.safeValue(a,h,[]),m=this.parseTrades(p,l,t,s);o=this.arrayConcat(o,m)}o=this.sortBy2(o,"timestamp","id");const c=t===void 0;return this.filterBySinceLimit(o,t,s,"timestamp",c)}}parseTrade(e,t=void 0){t=this.safeMarket(void 0,t);const s=this.safeTimestamp2(e,"time","trade_timestamp"),i=this.safeString2(e,"dealOrderId","orderId"),n=this.safeString(e,"deal"),r=this.safeString(e,"price"),a=this.safeString2(e,"amount","base_volume"),o=this.safeString2(e,"id","tradeID"),d=this.safeString2(e,"type","side"),c=t.symbol,u=this.safeInteger(e,"role");let h;u!==void 0&&(h=u===1?"maker":"taker");let l;const p=this.safeString(e,"fee");return p!==void 0&&(l={cost:p,currency:t.quote}),this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:c,id:o,order:i,type:void 0,takerOrMaker:h,side:d,price:r,amount:a,cost:n,fee:l},t)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={market:r.id,interval:this.timeframes[t]};if(s!==void 0){i===void 0&&(i=1440),i=Math.min(i,1440);const u=parseInt(s/1e3),h=this.parseTimeframe(t),l=this.sum(u,h*i);a.start=u,a.end=l}i!==void 0&&(a.limit=i);const o=await this.v1PublicGetKline(this.extend(a,n)),d=this.safeValue(o,"result",[]);return this.parseOHLCVs(d,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,5)]}async fetchStatus(e={}){const t=await this.v4PublicGetPing(e),s=this.safeString(t,0);return{status:s==="pong"?"ok":s,updated:void 0,eta:void 0,url:void 0,info:t}}async fetchTime(e={}){const t=await this.v4PublicGetTime(e);return this.safeInteger(t,"time")}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const o={market:this.market(e).id,side:s,amount:this.amountToPrecision(e,i)},d=t==="limit",c=t==="market",u=this.safeNumberN(r,["triggerPrice","stopPrice","activation_price"]),h=u!==void 0,l=this.isPostOnly(c,!1,r),[p,m]=this.handleMarginModeAndParams("createOrder",r);l&&(o.postOnly=!0);let g;if(h)o.activation_price=this.priceToPrecision(e,u),d?(g="v4PrivatePostOrderStopLimit",o.price=this.priceToPrecision(e,n)):g="v4PrivatePostOrderStopMarket";else if(d){if(g="v4PrivatePostOrderNew",p!==void 0){if(p!=="cross")throw new bg(this.id+" createOrder() is only available for cross margin");g="v4PrivatePostOrderCollateralLimit"}o.price=this.priceToPrecision(e,n)}else if(g="v4PrivatePostOrderStockMarket",p!==void 0){if(p!=="cross")throw new bg(this.id+" createOrder() is only available for cross margin");g="v4PrivatePostOrderCollateralMarket"}r=this.omit(m,["postOnly","triggerPrice","stopPrice"]);const y=await this[g](this.extend(o,r));return this.parseOrder(y)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Wo(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const n={market:this.market(t).id,orderId:parseInt(e)};return await this.v4PrivatePostOrderCancel(this.extend(n,s))}parseBalance(e){const t=Object.keys(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=e[n],a=this.safeCurrencyCode(n),o=this.account();o.free=this.safeString(r,"available"),o.used=this.safeString(r,"freeze"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.v4PrivatePostTradeAccountBalance(e);return this.parseBalance(t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Wo(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={market:n.id};s!==void 0&&(r.limit=s);const a=await this.v4PrivatePostOrders(this.extend(r,i));return this.parseOrders(a,n,t,s,{status:"open"})}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),e=r.symbol,n.market=r.id),s!==void 0&&(n.limit=s);const a=await this.v4PrivatePostTradeAccountOrderHistory(this.extend(n,i)),o=Object.keys(a);let d=[];for(let c=0;c<o.length;c++){const u=o[c],h=this.safeMarket(u,void 0,"_"),l=a[u];for(let p=0;p<l.length;p++){const m=this.parseOrder(l[p],h);d.push(this.extend(m,{status:"closed"}))}}return d=this.sortBy(d,"timestamp"),d=this.filterBySymbolSinceLimit(d,e,t,s),d}parseOrderType(e){const t={limit:"limit",market:"market","stop market":"market","stop limit":"limit","stock market":"market","margin limit":"limit","margin market":"market"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"market");t=this.safeMarket(s,t,"_");const i=t.symbol,n=this.safeString(e,"side"),r=this.safeString(e,"dealStock"),a=this.safeString(e,"left"),o=this.safeString(e,"clientOrderId"),d=this.safeString(e,"price"),c=this.safeNumber(e,"activation_price"),u=this.safeString2(e,"orderId","id"),h=this.safeString(e,"type");let l=this.safeString(e,"amount");const p=this.safeString(e,"dealMoney");n==="buy"&&(h==="market"||h==="stop market")&&(l=r);const m=this.safeString(e,"dealFee");let g;m!==void 0&&(g={cost:this.parseNumber(m),currency:t.quote});const y=this.safeTimestamp2(e,"ctime","timestamp"),b=this.safeTimestamp(e,"ftime");return this.safeOrder({info:e,id:u,symbol:i,clientOrderId:o,timestamp:y,datetime:this.iso8601(y),lastTradeTimestamp:b,timeInForce:void 0,postOnly:void 0,status:void 0,side:n,price:d,type:this.parseOrderType(h),stopPrice:c,amount:l,filled:r,remaining:a,average:void 0,cost:p,fee:g,trades:void 0},t)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={orderId:parseInt(e)};let a;t!==void 0&&(a=this.market(t),r.market=a.id),i!==void 0&&(r.limit=i);const o=await this.v4PrivatePostTradeAccountOrder(this.extend(r,n)),d=this.safeValue(o,"records",[]);return this.parseTrades(d,a)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={ticker:this.currency(e).id};let n="v4PrivatePostMainAccountAddress";if(this.isFiat(e)){n="v4PrivatePostMainAccountFiatDepositUrl";const u=this.safeNumber(t,"provider");if(u===void 0)throw new Wo(this.id+" fetchDepositAddress() requires a provider when the ticker is fiat");i.provider=u;const h=this.safeNumber(t,"amount");if(h===void 0)throw new Wo(this.id+" fetchDepositAddress() requires an amount when the ticker is fiat");if(i.amount=h,this.safeValue(t,"uniqueId")===void 0)throw new Wo(this.id+" fetchDepositAddress() requires an uniqueId when the ticker is fiat")}const r=await this[n](this.extend(i,t)),a=this.safeString(r,"url"),o=this.safeValue(r,"account",{}),d=this.safeString(o,"address",a),c=this.safeString(o,"memo");return this.checkAddress(d),{currency:e,address:d,tag:c,network:void 0,info:r}}async setLeverage(e,t=void 0,s={}){if(await this.loadMarkets(),t!==void 0)throw new bg(this.id+" setLeverage() does not allow to set per symbol");if(e<1||e>20)throw new yg(this.id+" setLeverage() leverage should be between 1 and 20");const i={leverage:e};return await this.v4PrivatePostCollateralAccountLeverage(this.extend(i,s))}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"accountsByType"),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c=t.toString(),u={ticker:r.id,amount:this.currencyToPrecision(e,c),from:o,to:d},h=await this.v4PrivatePostMainAccountTransfer(this.extend(u,n)),l=this.parseTransfer(h,r);return this.extend(l,{amount:this.currencyToPrecision(e,c),fromAccount:s,toAccount:i})}parseTransfer(e,t){return{info:e,id:void 0,timestamp:void 0,datetime:void 0,currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0}}async withdraw(e,t,s,i=void 0,n={}){await this.loadMarkets();const r=this.currency(e),a={ticker:r.id,amount:this.currencyToPrecision(e,t),address:s};let o=this.safeValue(n,"uniqueId");if(o===void 0&&(o=this.uuid22()),a.uniqueId=o,i!==void 0&&(a.memo=i),this.isFiat(e)){const c=this.safeValue(n,"provider");if(c===void 0)throw new Wo(this.id+" withdraw() requires a provider when the ticker is fiat");a.provider=c}const d=await this.v4PrivatePostMainAccountWithdraw(this.extend(a,n));return this.extend({id:o},this.parseTransaction(d,r))}parseTransaction(e,t=void 0){t=this.safeCurrency(void 0,t);const s=this.safeString(e,"address"),i=this.safeTimestamp(e,"createdAt"),n=this.safeString(e,"ticker"),r=this.safeString(e,"status"),a=this.safeString(e,"method");return{id:this.safeString(e,"uniqueId"),txid:this.safeString(e,"transactionHash"),timestamp:i,datetime:this.iso8601(i),network:this.safeString(e,"network"),addressFrom:a==="1"?s:void 0,address:s,addressTo:a==="2"?s:void 0,amount:this.safeNumber(e,"amount"),type:a==="1"?"deposit":"withdrawal",currency:this.safeCurrencyCode(n,t),status:this.parseTransactionStatus(r),updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:this.safeString(e,"description"),fee:{cost:this.safeNumber(e,"fee"),currency:this.safeCurrencyCode(n,t)},info:e}}parseTransactionStatus(e){const t={1:"pending",2:"pending",3:"ok",4:"canceled",5:"pending",6:"pending",7:"ok",9:"canceled",10:"pending",11:"pending",12:"pending",13:"pending",14:"pending",15:"pending",16:"pending",17:"pending"};return this.safeString(t,e,e)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();let i;const n={transactionMethod:1,uniqueId:e,limit:1,offset:0};t!==void 0&&(i=this.currency(t),n.ticker=i.id);const r=await this.v4PrivatePostMainAccountHistory(this.extend(n,s)),a=this.safeValue(r,"records",[]),o=this.safeValue(a,0,{});return this.parseTransaction(o,i)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={transactionMethod:1,limit:100,offset:0};e!==void 0&&(n=this.currency(e),r.ticker=n.id),s!==void 0&&(r.limit=s);const a=await this.v4PrivatePostMainAccountHistory(this.extend(r,i)),o=this.safeValue(a,"records",[]);return this.parseTransactions(o,n,t,s)}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a;t!==void 0&&(a=this.market(t),r.market=a.id);const o=await this.v4PrivatePostCollateralAccountPositionsOpen(this.extend(r,n)),d=this.parseBorrowInterests(o,a);return this.filterByCurrencySinceLimit(d,e,s,i)}parseBorrowInterest(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeSymbol(s,t,"_"),n=this.safeTimestamp(e,"modifyDate");return{symbol:i,marginMode:"cross",currency:"USDT",interest:this.safeNumber(e,"unrealizedFunding"),interestRate:98e-5,amountBorrowed:this.safeNumber(e,"amount"),timestamp:n,datetime:this.iso8601(n),info:e}}isFiat(e){const t=this.safeValue(this.options,"fiatCurrencies",[]);return this.inArray(e,t)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.omit(i,this.extractParams(e)),o=this.safeValue(t,0),d=this.safeValue(t,1),c="/"+this.implodeParams(e,i);let u=this.urls.api[o][d]+c;if(d==="public"&&Object.keys(a).length&&(u+="?"+this.urlencode(a)),d==="private"){this.checkRequiredCredentials();const h=this.nonce().toString(),l=this.stringToBinary(this.encode(this.secret)),p="/api/"+o+c;r=this.json(this.extend({request:p,nonce:h},i));const m=this.stringToBase64(r),g=this.hmac(m,l,"sha512");n={"Content-Type":"application/json","X-TXC-APIKEY":this.apiKey,"X-TXC-PAYLOAD":this.decode(m),"X-TXC-SIGNATURE":g}}return{url:u,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(e===418||e===429)throw new W7(this.id+" "+e.toString()+" "+t+" "+r);if(e===404)throw new xT(this.id+" "+e.toString()+" endpoint not found");if(a!==void 0){const c=this.safeString(a,"status"),u=this.safeString(a,"message"),h=this.safeInteger(a,"code"),l=c!==void 0&&c!=="200";if(l||h!==void 0){const p=this.id+" "+r;let m=u;if(l)m=c;else{const g=this.safeValue(a,"errors");if(g!==void 0){const y=Object.keys(g)[0],b=this.safeValue(g,y,[]);m=b.length>0?b[0]:r}}throw this.throwExactlyMatchedException(this.exceptions.exact,m,p),this.throwBroadlyMatchedException(this.exceptions.broad,r,p),new xT(p)}}}};const X7=me,{ArgumentsRequired:Sg,AuthenticationError:MT,RateLimitExceeded:Y7,BadRequest:In,ExchangeError:PT,InvalidOrder:ea}=oe,{TICK_SIZE:Q7}=pe,en=ke;var Z7=class extends X7{describe(){return this.deepExtend(super.describe(),{id:"woo",name:"WOO X",countries:["KY"],rateLimit:100,version:"v1",certified:!1,hostname:"woo.org",has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!1,option:!1,addMargin:!1,borrowMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelWithdraw:!1,createDepositAddress:!1,createMarketOrder:!1,createOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchAccounts:!0,fetchBalance:!0,fetchCanceledOrders:!1,fetchClosedOrder:!1,fetchClosedOrders:!1,fetchCurrencies:!0,fetchDepositAddress:!1,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!1,fetchOpenOrders:!1,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchStatus:!1,fetchTicker:!1,fetchTickers:!1,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:!0,fetchTransfers:!0,fetchWithdrawals:!0,reduceMargin:!1,repayMargin:!0,setLeverage:!0,setMargin:!1,transfer:!0,withdraw:!1},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","12h":"12h","1d":"1d","1w":"1w","1M":"1mon","1y":"1y"},urls:{logo:"https://user-images.githubusercontent.com/1294454/150730761-1a00e5e0-d28c-480f-9e65-089ce3e6ef3b.jpg",api:{pub:"https://api-pub.woo.org",public:"https://api.{hostname}",private:"https://api.{hostname}"},test:{pub:"https://api-pub.staging.woo.org",public:"https://api.staging.woo.org",private:"https://api.staging.woo.org"},www:"https://woo.org/",doc:["https://docs.woo.org/"],fees:["https://support.woo.org/hc/en-001/articles/4404611795353--Trading-Fees"],referral:"https://referral.woo.org/BAJS6oNmZb3vi3RGA"},api:{v1:{pub:{get:{"hist/kline":10}},public:{get:{info:1,"info/{symbol}":1,system_info:1,market_trades:1,token:1,token_network:1,funding_rates:1,"funding_rate/{symbol}":1,funding_rate_history:1,futures:1,"futures/{symbol}":1}},private:{get:{"client/token":1,"order/{oid}":1,"client/order/{client_order_id}":1,orders:1,"orderbook/{symbol}":1,kline:1,"client/trade/{tid}":1,"order/{oid}/trades":1,"client/trades":1,"client/info":60,"asset/deposit":120,"asset/history":60,"sub_account/all":60,"sub_account/assets":60,token_interest:60,"token_interest/{token}":60,"interest/history":60,"interest/repay":60,"funding_fee/history":30,positions:3.33,"position/{symbol}":3.33},post:{order:5,"asset/main_sub_transfer":30,"asset/withdraw":120,"interest/repay":60,"client/account_mode":120,"client/leverage":120},delete:{order:1,"client/order":1,orders:1,"asset/withdraw":120}}},v2:{private:{get:{"client/holding":1}}},v3:{private:{get:{"algo/order/{oid}":1,"algo/orders":1},post:{"algo/order":5},delete:{"algo/order/{oid}":1,"algo/orders/pending":1,"algo/orders/pending/{symbol}":1,"orders/pending":1}}}},fees:{trading:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.0002"),taker:this.parseNumber("0.0005")}},options:{createMarketBuyOrderRequiresPrice:!0,"network-aliases-for-tokens":{HT:"ERC20",OMG:"ERC20",UATOM:"ATOM",ZRX:"ZRX"},defaultNetworkCodeForCurrencies:{},transfer:{fillResponseFromRequest:!0}},commonCurrencies:{},exceptions:{exact:{"-1000":PT,"-1001":MT,"-1002":MT,"-1003":Y7,"-1004":In,"-1005":In,"-1006":In,"-1007":In,"-1008":ea,"-1009":In,"-1011":PT,"-1012":In,"-1101":ea,"-1102":ea,"-1103":ea,"-1104":ea,"-1105":ea},broad:{"symbol must not be blank":In,"The token is not supported":In,"Your order and symbol are not valid or already canceled":In,"Insufficient WOO. Please enable margin trading for leverage trading":In}},precisionMode:Q7})}async fetchMarkets(e={}){const t=await this.v1PublicGetInfo(e),s=[],i=this.safeValue(t,"rows",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"symbol"),o=a.split("_");let d=this.safeStringLower(o,0);const c=d==="spot",u=d==="perp",h=this.safeString(o,1),l=this.safeString(o,2),p=this.safeCurrencyCode(h),m=this.safeCurrencyCode(l);let g,y,b=p+"/"+m,w,S;u&&(g=this.safeString(o,2),y=this.safeCurrencyCode(g),b=p+"/"+m+":"+y,w=this.parseNumber("1"),d="swap",S=!0),s.push({id:a,symbol:b,base:p,quote:m,settle:y,baseId:h,quoteId:l,settleId:g,type:d,spot:c,margin:!0,swap:u,future:!1,option:!1,active:void 0,contract:u,linear:S,inverse:void 0,contractSize:w,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(r,"base_tick"),price:this.safeNumber(r,"quote_tick")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"base_min"),max:this.safeNumber(r,"base_max")},price:{min:this.safeNumber(r,"quote_min"),max:this.safeNumber(r,"quote_max")},cost:{min:this.safeNumber(r,"min_notional"),max:void 0}},info:r})}return s}async fetchTrades(e,t=void 0,s=void 0,i={}){if(e===void 0)throw new Sg(this.id+" fetchTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s);const a=await this.v1PublicGetMarketTrades(this.extend(r,i)),o=this.safeValue(a,"rows",{});return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){const s="id"in e,i=this.safeTimestamp(e,"executed_timestamp"),n=this.safeString(e,"symbol");t=this.safeMarket(n,t);const r=t.symbol,a=this.safeString(e,"executed_price"),o=this.safeString(e,"executed_quantity"),d=this.safeString(e,"order_id"),c=this.parseTokenAndFeeTemp(e,"fee_asset","fee"),u=en.stringMul(a,o),h=this.safeStringLower(e,"side"),l=this.safeString(e,"id");let p;return s&&(p=this.safeString(e,"is_maker")==="1"?"maker":"taker"),this.safeTrade({id:l,timestamp:i,datetime:this.iso8601(i),symbol:r,side:h,price:a,amount:o,cost:u,order:d,takerOrMaker:p,type:void 0,fee:c,info:e},t)}parseTokenAndFeeTemp(e,t,s){const i=this.safeString(e,s);let n;if(i!==void 0){const r=this.safeString(e,t),a=this.safeCurrencyCode(r);n={cost:i,currency:a}}return n}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.v1PrivateGetClientInfo(e),s=this.safeValue(t,"application",{}),i=this.safeString(s,"maker_fee_rate"),n=this.safeString(s,"taker_fee_rate"),r={};for(let a=0;a<this.symbols.length;a++){const o=this.symbols[a];r[o]={info:t,symbol:o,maker:this.parseNumber(en.stringDiv(i,"10000")),taker:this.parseNumber(en.stringDiv(n,"10000")),percentage:!0,tierBased:!0}}return r}async fetchCurrencies(e={}){const t={},s=await this.v1PublicGetToken(e),i=this.safeValue(s,"rows",[]),n=this.groupBy(i,"balance_token"),r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=n[o],c=this.safeCurrencyCode(o);let u,h;const l={};for(let p=0;p<d.length;p++){const m=d[p];u=this.safeString(m,"fullname");const g=this.safeString(m,"token"),b=g.split("_")[0],w=this.parsePrecision(this.safeString(m,"decimals"));w!==void 0&&(h=h===void 0?w:en.stringMin(w,h)),l[b]={id:g,network:b,limits:{withdraw:{min:void 0,max:void 0},deposit:{min:void 0,max:void 0}},active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,precision:this.parseNumber(w),info:m}}t[c]={id:o,name:u,code:c,precision:this.parseNumber(h),active:void 0,fee:void 0,networks:l,limits:{deposit:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}},info:d}}return t}async createOrder(e,t,s,i,n=void 0,r={}){const a=this.safeValue(r,"reduceOnly"),o=t.toUpperCase();if(a!==void 0&&o!=="LIMIT")throw new ea(this.id+" createOrder() only support reduceOnly for limit orders");await this.loadMarkets();const d=this.market(e),c=s.toUpperCase(),u={symbol:d.id,order_type:o,side:c};if(a&&(u.reduce_only=a),n!==void 0&&(u.order_price=this.priceToPrecision(e,n)),o==="MARKET")if(c==="BUY"){const p=this.safeNumber(r,"cost");if(this.safeValue(this.options,"createMarketBuyOrderRequiresPrice",!0))if(p===void 0){if(n===void 0)throw new ea(this.id+" createOrder() requires the price argument for market buy orders to calculate total order cost. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or alternatively, supply the total cost value in the 'order_amount' in  exchange-specific parameters");{const m=this.numberToString(i),g=this.numberToString(n),y=en.stringMul(m,g);u.order_amount=this.costToPrecision(e,y)}}else u.order_amount=this.costToPrecision(e,p)}else u.order_quantity=this.amountToPrecision(e,i);else u.order_quantity=this.amountToPrecision(e,i);const h=this.safeString2(r,"clOrdID","clientOrderId");h!==void 0&&(u.client_order_id=h),r=this.omit(r,["clOrdID","clientOrderId"]);const l=await this.v1PrivatePostOrder(this.extend(u,r));return this.extend(this.parseOrder(l,d),{type:t})}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Sg(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i={},n=this.safeString2(s,"clOrdID","clientOrderId"),r=this.safeString2(s,"client_order_id",n),a=r!==void 0;a?(i.client_order_id=r,s=this.omit(s,["clOrdID","clientOrderId","client_order_id"])):i.order_id=e;let o;t!==void 0&&(o=this.market(t)),i.symbol=o.id;const d=await this.v1PrivateDeleteOrder(this.extend(i,s)),c={symbol:t};return a?c.client_order_id=r:c.id=e,this.extend(this.parseOrder(d),c)}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new Sg(this.id+" canelOrders() requires a symbol argument");await this.loadMarkets();const i={symbol:this.market(e).id};return await this.v1PrivateDeleteOrders(this.extend(i,t))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=t!==void 0?this.market(t):void 0,n={},r=this.safeString2(s,"clOrdID","clientOrderId");let a;r?(a="v1PrivateGetClientOrderClientOrderId",n.client_order_id=r):(a="v1PrivateGetOrderOid",n.oid=e);const o=await this[a](this.extend(n,s));return this.parseOrder(o,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),t!==void 0&&(n.start_t=t);const a=await this.v1PrivateGetOrders(this.extend(n,i)),o=this.safeValue(a,"rows");return this.parseOrders(o,r,t,s,i)}parseOrder(e,t=void 0){const s=this.safeTimestamp2(e,"timestamp","created_time"),i=this.safeString(e,"order_id"),n=this.safeString(e,"client_order_id"),r=this.safeString(e,"symbol");t=this.safeMarket(r,t);const a=t.symbol,o=this.safeString2(e,"order_price","price"),d=this.safeString2(e,"order_quantity","quantity"),c=this.safeString2(e,"order_amount","amount"),u=this.safeStringLower2(e,"order_type","type"),h=this.safeValue(e,"status"),l=this.safeStringLower(e,"side"),p=this.safeValue(e,"executed"),m=en.stringSub(c,p),g=this.safeValue(e,"total_fee"),y=this.safeString(e,"fee_asset"),b=this.safeValue(e,"Transactions");return this.safeOrder({id:i,clientOrderId:n,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,status:this.parseOrderStatus(h),symbol:a,type:u,timeInForce:void 0,postOnly:void 0,reduceOnly:this.safeValue(e,"reduce_only"),side:l,price:o,stopPrice:void 0,average:void 0,amount:d,filled:p,remaining:m,cost:c,trades:b,fee:{cost:g,currency:y},info:e},t)}parseOrderStatus(e){if(e!==void 0){const t={NEW:"open",FILLED:"closed",CANCEL_SENT:"canceled",CANCEL_ALL_SENT:"canceled",CANCELLED:"canceled",PARTIAL_FILLED:"open",REJECTED:"rejected",INCOMPLETE:"open",COMPLETED:"closed"};return this.safeString(t,e,e)}return e}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={symbol:this.market(e).id};t!==void 0&&(t=Math.min(t,1e3),n.max_level=t);const r=await this.v1PrivateGetOrderbookSymbol(this.extend(n,s)),a=this.safeInteger(r,"timestamp");return this.parseOrderBook(r,e,a,"bids","asks","price","quantity")}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,type:this.timeframes[t]};i!==void 0&&(a.limit=Math.min(i,1e3));const o=await this.v1PrivateGetKline(this.extend(a,n)),d=this.safeValue(o,"rows",[]);return this.parseOHLCVs(d,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"start_timestamp"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;t!==void 0&&(r=this.market(t));const a={oid:e},o=await this.v1PrivateGetOrderOidTrades(this.extend(a,n)),d=this.safeValue(o,"rows",[]);return this.parseTrades(d,r,s,i,n)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),t!==void 0&&(n.start_t=t);const a=await this.v1PrivateGetClientTrades(this.extend(n,i)),o=this.safeValue(a,"rows",[]);return this.parseTrades(o,r,t,s,i)}async fetchAccounts(e={}){const t=await this.v1PrivateGetSubAccountAssets(e),s=this.safeValue(t,"rows",[]);return this.parseAccounts(s,e)}parseAccount(e){const t=this.safeString(e,"account");return{info:e,id:this.safeString(e,"application_id"),name:t,code:void 0,type:t==="Main"?"main":"subaccount"}}async fetchBalance(e={}){await this.loadMarkets();const t=await this.v2PrivateGetClientHolding(e);return this.parseBalance(t)}parseBalance(e){const t={info:e},s=this.safeValue(e,"holding",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeCurrencyCode(this.safeString(n,"token")),a=this.account();a.total=this.safeString(n,"holding");const o=this.safeString(n,"outstanding_holding");a.used=en.stringNeg(o),t[r]=a}return this.safeBalance(t)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i=this.defaultNetworkCodeForCurrency(e),n=this.safeString(t,"network",i);t=this.omit(t,"network");const a={token:n+"_"+s.code},o=await this.v1PrivateGetAssetDeposit(this.extend(a,t)),d=this.safeString(o,"extra"),c=this.safeString(o,"address");return this.checkAddress(c),{currency:e,address:c,tag:d,network:n,info:o}}async getAssetHistoryRows(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.balance_token=r.id),t!==void 0&&(n.start_t=t),s!==void 0&&(n.pageSize=s);const a=this.safeString(i,"type");i=this.omit(i,"type"),a!==void 0&&(n.type=a);const o=await this.v1PrivateGetAssetHistory(this.extend(n,i));return[r,this.safeValue(o,"rows",{})]}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){const[n,r]=await this.getAssetHistoryRows(e,t,s,i);return this.parseLedger(r,n,t,s,i)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"token"),n=this.getCurrencyFromChaincode(s,t).code,r=this.safeNumber(e,"amount"),o=this.safeString(e,"token_side")==="DEPOSIT"?"in":"out",d=this.safeTimestamp(e,"created_time"),c=this.parseTokenAndFeeTemp(e,"fee_token","fee_amount");return{id:this.safeString(e,"id"),currency:n,account:this.safeString(e,"account"),referenceAccount:void 0,referenceId:this.safeString(e,"tx_id"),status:this.parseTransactionStatus(this.safeString(e,"status")),amount:r,before:void 0,after:void 0,fee:c,direction:o,timestamp:d,datetime:this.iso8601(d),type:this.parseLedgerEntryType(this.safeString(e,"type")),info:e}}parseLedgerEntryType(e){const t={BALANCE:"transaction",COLLATERAL:"transfer"};return this.safeString(t,e,e)}getCurrencyFromChaincode(e,t){if(t!==void 0)return t;{const s=e.split("_"),i=s.length,n=this.safeString(s,0);let r=this.safeString(s,1,n);i>2&&(r+="_"+this.safeString(s,2)),t=this.safeCurrency(r)}return t}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){const n={token_side:"DEPOSIT"};return await this.fetchTransactions(e,t,s,this.extend(n,i))}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const n={token_side:"WITHDRAW"};return await this.fetchTransactions(e,t,s,this.extend(n,i))}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){const n={type:"BALANCE"},[r,a]=await this.getAssetHistoryRows(e,t,s,this.extend(n,i));return this.parseTransactions(a,r,t,s,i)}parseTransaction(e,t=void 0){const s=this.safeString(e,"token"),n=this.getCurrencyFromChaincode(s,t).code;let r=this.safeStringLower(e,"token_side");r==="withdraw"&&(r="withdrawal");const a=this.parseTokenAndFeeTemp(e,"fee_token","fee_amount");a.rate=void 0;const o=this.safeString(e,"target_address"),d=this.safeString(e,"source_address"),c=this.safeTimestamp(e,"created_time");return{id:this.safeString(e,"id"),txid:this.safeString(e,"tx_id"),timestamp:c,datetime:this.iso8601(c),address:void 0,addressFrom:d,addressTo:o,tag:this.safeString(e,"extra"),type:r,amount:this.safeNumber(e,"amount"),currency:n,status:this.parseTransactionStatus(this.safeString(e,"status")),updated:this.safeTimestamp(e,"updated_time"),fee:a,info:e}}parseTransactionStatus(e){const t={NEW:"pending",CONFIRMING:"pending",PROCESSING:"pending",COMPLETED:"ok",CANCELED:"canceled"};return this.safeString(t,e,e)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a={token:r.id,amount:this.parseNumber(t),from_application_id:s,to_application_id:i},o=await this.v1PrivatePostAssetMainSubTransfer(this.extend(a,n)),d=this.parseTransfer(o,r),c=this.safeValue(this.options,"transfer",{});return this.safeValue(c,"fillResponseFromRequest",!0)&&(d.amount=t,d.fromAccount=s,d.toAccount=i),d}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){const n={type:"COLLATERAL"},[r,a]=await this.getAssetHistoryRows(e,t,s,this.extend(n,i));return this.parseTransfers(a,r,t,s,i)}parseTransfer(e,t=void 0){const s=this.safeString(e,"token"),n=this.getCurrencyFromChaincode(s,t).code;let r=this.safeStringLower(e,"token_side");r==="withdraw"&&(r="withdrawal");let a,o;r==="withdraw"?(a=void 0,o="spot"):r==="deposit"&&(a="spot",o=void 0);const d=this.safeTimestamp(e,"created_time"),c=this.safeValue(e,"success");let u;return c!==void 0&&(u=c?"ok":"failed"),{id:this.safeString(e,"id"),timestamp:d,datetime:this.iso8601(d),currency:n,amount:this.safeNumber(e,"amount"),fromAccount:a,toAccount:o,status:this.parseTransferStatus(this.safeString(e,"status",u)),info:e}}parseTransferStatus(e){const t={NEW:"pending",CONFIRMING:"pending",PROCESSING:"pending",COMPLETED:"ok",CANCELED:"canceled"};return this.safeString(t,e,e)}async repayMargin(e,t,s=void 0,i={}){await this.loadMarkets();let n;s!==void 0&&(n=this.market(s),s=n.symbol);const r=this.currency(e),a={token:r.id,amount:this.currencyToPrecision(e,t)},o=await this.v1PrivatePostInterestRepay(this.extend(a,i)),d=this.parseMarginLoan(o,r);return this.extend(d,{amount:t,symbol:s})}parseMarginLoan(e,t=void 0){return{id:void 0,currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=t[0],o=t[1];let d=this.implodeHostname(this.urls.api[o]);if(d+="/"+a+"/",e=this.implodeParams(e,i),i=this.omit(i,this.extractParams(e)),i=this.keysort(i),o==="public")d+=o+"/"+e,Object.keys(i).length&&(d+="?"+this.urlencode(i));else{this.checkRequiredCredentials(),d+=e;const c=this.nonce().toString();let u=this.urlencode(i);a==="v3"&&s==="POST"?(r=u,u=c+s+"/"+a+"/"+e+r):(s==="POST"||s==="DELETE"?r=u:d+="?"+u,u+="|"+c);const h=this.hmac(this.encode(u),this.encode(this.secret),"sha256");n={"x-api-key":this.apiKey,"x-api-signature":h,"x-api-timestamp":c,"Content-Type":"application/x-www-form-urlencoded"}}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(!a)return;const c=this.safeValue(a,"success"),u=this.safeString(a,"code");if(!c){const h=this.id+" "+this.json(a);this.throwBroadlyMatchedException(this.exceptions.broad,r,h),this.throwExactlyMatchedException(this.exceptions.exact,u,h)}}parseIncome(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeNumber(e,"funding_fee"),r=this.safeCurrencyCode("USD"),a=this.safeString(e,"id"),o=this.safeTimestamp(e,"updated_time"),d=this.safe_number(e,"funding_rate");return{info:e,symbol:i,code:r,timestamp:o,datetime:this.iso8601(o),id:a,amount:n,rate:d}}parseIncomes(e,t=void 0,s=void 0,i=void 0){const n=[];for(let a=0;a<e.length;a++){const o=e[a],d=this.parseIncome(o,t);n.push(d)}const r=this.sortBy(n,"timestamp");return this.filterBySinceLimit(r,s,i,"timestamp")}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),t!==void 0&&(n.start_t=t);const a=await this.v1PrivateGetFundingFeeHistory(this.extend(n,i)),o=this.safeValue(a,"rows",[]);return this.parseIncomes(o,r,t,s)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"symbol");t=this.market(s);const i=this.safeInteger(e,"next_funding_time"),n=this.safeInteger(e,"est_funding_rate_timestamp"),r=this.safeInteger(e,"last_funding_rate_timestamp");return{info:e,symbol:t.symbol,markPrice:void 0,indexPrice:void 0,interestRate:this.parseNumber("0"),estimatedSettlePrice:void 0,timestamp:n,datetime:this.iso8601(n),fundingRate:this.safeNumber(e,"est_funding_rate"),fundingTimestamp:i,fundingDatetime:this.iso8601(i),nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:this.safeNumber(e,"last_funding_rate"),previousFundingTimestamp:r,previousFundingDatetime:this.iso8601(r)}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.v1PublicGetFundingRateSymbol(this.extend(i,t));return this.parseFundingRate(n,s)}async fetchFundingRates(e,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.v1PublicGetFundingRates(t),i=this.safeValue(s,"rows",{}),n=this.parseFundingRates(i);return this.filterByArray(n,"symbol",e)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};if(e!==void 0){const c=this.market(e);e=c.symbol,n.symbol=c.id}t!==void 0&&(n.start_t=parseInt(t/1e3));const r=await this.v1PublicGetFundingRateHistory(this.extend(n,i)),a=this.safeValue(r,"rows"),o=[];for(let c=0;c<a.length;c++){const u=a[c],h=this.safeString(u,"symbol"),l=this.safeInteger(u,"funding_rate_timestamp");o.push({info:u,symbol:this.safeSymbol(h),fundingRate:this.safeNumber(u,"funding_rate"),timestamp:l,datetime:this.iso8601(l)})}const d=this.sortBy(o,"timestamp");return this.filterBySymbolSinceLimit(d,e,t,s)}async fetchLeverage(e,t={}){await this.loadMarkets();const s=await this.v1PrivateGetClientInfo(t),i=this.safeValue(s,"application"),n=this.safeNumber(i,"leverage");return{info:s,leverage:n}}async setLeverage(e,t=void 0,s={}){if(await this.loadMarkets(),e<1||e>20)throw new In(this.id+" leverage should be between 1 and 20");const i={leverage:e};return await this.v1PrivatePostClientLeverage(this.extend(i,s))}async fetchPosition(e=void 0,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.v1PrivateGetPositionSymbol(this.extend(i,t));return this.parsePosition(n,s)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.v1PrivateGetPositions(t),i=this.safeValue(s,"positions",[]);return this.parsePositions(i,e)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);let i=this.safeString(e,"holding"),n;en.stringGt(i,"0")?n="long":n="short";const r=this.safeString(t,"contractSize"),a=this.safeString(e,"mark_price"),o=this.safeTimestamp(e,"timestamp"),d=this.safeString(e,"average_open_price"),c=en.stringSub(a,d),u=en.stringMul(c,i);i=en.stringAbs(i);const h=en.stringMul(i,a);return{info:e,id:void 0,symbol:this.safeString(t,"symbol"),timestamp:o,datetime:this.iso8601(o),initialMargin:void 0,initialMarginPercentage:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,entryPrice:this.parseNumber(d),notional:this.parseNumber(h),leverage:void 0,unrealizedPnl:this.parseNumber(u),contracts:this.parseNumber(i),contractSize:this.parseNumber(r),marginRatio:void 0,liquidationPrice:this.safeNumber(e,"est_liq_price"),markPrice:this.parseNumber(a),collateral:void 0,marginMode:"cross",marginType:void 0,side:n,percentage:void 0}}defaultNetworkCodeForCurrency(e){const s=this.currency(e).networks,i=Object.keys(s);for(let n=0;n<i.length;n++){const r=i[n];if(r==="ETH")return r}return this.safeValue(i,0)}};const J7=me,{ExchangeError:zo,ArgumentsRequired:kg,ExchangeNotAvailable:vg,InvalidNonce:eU,InsufficientFunds:Tg,OrderNotFound:tU,DDoSProtection:sU,InvalidOrder:xn,AuthenticationError:Sh,RateLimitExceeded:iU}=oe,{TICK_SIZE:nU}=pe,Og=ke;var rU=class extends J7{describe(){return this.deepExtend(super.describe(),{id:"yobit",name:"YoBit",countries:["RU"],rateLimit:2e3,version:"3",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createDepositAddress:!0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchDepositAddress:!0,fetchDeposits:void 0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:void 0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawals:void 0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766910-cdcbfdae-5eea-11e7-9859-03fea873272d.jpg",api:{public:"https://yobit.net/api",private:"https://yobit.net/tapi"},www:"https://www.yobit.net",doc:"https://www.yobit.net/en/api/",fees:"https://www.yobit.net/en/fees/"},api:{public:{get:{"depth/{pair}":1,info:1,"ticker/{pair}":1,"trades/{pair}":1}},private:{post:{ActiveOrders:1,CancelOrder:1,GetDepositAddress:1,getInfo:1,OrderInfo:1,Trade:1,TradeHistory:1,WithdrawCoinsToAddress:1}}},fees:{trading:{maker:.002,taker:.002},funding:{withdraw:{}}},commonCurrencies:{AIR:"AirCoin",ANI:"ANICoin",ANT:"AntsCoin",ATMCHA:"ATM",ASN:"Ascension",AST:"Astral",ATM:"Autumncoin",AUR:"AuroraCoin",BAB:"Babel",BAN:"BANcoin",BCC:"BCH",BCS:"BitcoinStake",BITS:"Bitstar",BLN:"Bulleon",BNS:"Benefit Bonus Coin",BOT:"BOTcoin",BON:"BONES",BPC:"BitcoinPremium",BST:"BitStone",BTS:"Bitshares2",CAT:"BitClave",CBC:"CryptoBossCoin",CMT:"CometCoin",COIN:"Coin.com",COV:"Coven Coin",COVX:"COV",CPC:"Capricoin",CREDIT:"Creditbit",CS:"CryptoSpots",DCT:"Discount",DFT:"DraftCoin",DGD:"DarkGoldCoin",DIRT:"DIRTY",DROP:"FaucetCoin",DSH:"DASH",EGC:"EverGreenCoin",EGG:"EggCoin",EKO:"EkoCoin",ENTER:"ENTRC",EPC:"ExperienceCoin",ESC:"EdwardSnowden",EUROPE:"EUROP",EXT:"LifeExtension",FUND:"FUNDChains",FUNK:"FUNKCoin",FX:"FCoin",GCC:"GlobalCryptocurrency",GEN:"Genstake",GENE:"Genesiscoin",GMR:"Gimmer",GOLD:"GoldMint",GOT:"Giotto Coin",GSX:"GlowShares",GT:"GTcoin",HTML5:"HTML",HYPERX:"HYPER",ICN:"iCoin",INSANE:"INSN",JNT:"JointCoin",JPC:"JupiterCoin",JWL:"Jewels",KNC:"KingN Coin",LBTCX:"LiteBitcoin",LIZI:"LiZi",LOC:"LocoCoin",LOCX:"LOC",LUNYR:"LUN",LUN:"LunarCoin",LUNA:"Luna Coin",MASK:"Yobit MASK",MDT:"Midnight",MEME:"Memez Token",MIS:"MIScoin",MM:"MasterMint",NAV:"NavajoCoin",NBT:"NiceBytes",OMG:"OMGame",ONX:"Onix",PAC:"$PAC",PLAY:"PlayCoin",PIVX:"Darknet",PRS:"PRE",PURE:"PurePOS",PUTIN:"PutinCoin",SPACE:"Spacecoin",STK:"StakeCoin",SUB:"Subscriptio",PAY:"EPAY",PLC:"Platin Coin",RAI:"RaiderCoin",RCN:"RCoin",REP:"Republicoin",RUR:"RUB",SBTC:"Super Bitcoin",SMC:"SmartCoin",SOLO:"SoloCoin",SOUL:"SoulCoin",STAR:"StarCoin",SUPER:"SuperCoin",TNS:"Transcodium",TTC:"TittieCoin",UNI:"Universe",UST:"Uservice",VOL:"VolumeCoin",XIN:"XINCoin",XMT:"SummitCoin",XRA:"Ratecoin"},options:{fetchOrdersRequiresSymbol:!0,fetchTickersMaxLength:512,networks:{ETH:"ERC20",TRX:"TRC20",BSC:"BEP20"}},precisionMode:nU,exceptions:{exact:{803:xn,804:xn,805:xn,806:xn,807:xn,831:Tg,832:Tg,833:tU},broad:{"Invalid pair name":zo,"invalid api key":Sh,"invalid sign":Sh,"api key dont have trade permission":Sh,"invalid parameter":xn,"invalid order":xn,"The given order has already been cancelled":xn,"Requests too often":sU,"not available":vg,"data unavailable":vg,"external service unavailable":vg,"Total transaction amount":xn,"The given order has already been closed and cannot be cancelled":xn,"Insufficient funds":Tg,"invalid key":Sh,"invalid nonce":eU,"Total order amount is less than minimal amount":xn,"Rate Limited":iU}},orders:{}})}parseBalance(e){const t=this.safeValue(e,"return",{}),s=this.safeInteger(t,"server_time"),i={info:e,timestamp:s,datetime:this.iso8601(s)},n=this.safeValue(t,"funds",{}),r=this.safeValue(t,"funds_incl_orders",{}),a=Object.keys(this.extend(n,r));for(let o=0;o<a.length;o++){const d=a[o],c=this.safeCurrencyCode(d),u=this.account();u.free=this.safeString(n,d),u.total=this.safeString(r,d),i[c]=u}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetInfo(e);return this.parseBalance(t)}async fetchMarkets(e={}){const t=await this.publicGetInfo(e),s=this.safeValue(t,"pairs",{}),i=Object.keys(s),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=s[a],[d,c]=a.split("_");let u=d.toUpperCase(),h=c.toUpperCase();u=this.safeCurrencyCode(u),h=this.safeCurrencyCode(h);const l=this.safeInteger(o,"hidden");let p=this.safeString(o,"fee");p=Og.stringDiv(p,"100"),n.push({id:a,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:l===0,contract:!1,linear:void 0,inverse:void 0,taker:this.parseNumber(p),maker:this.parseNumber(p),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(o,"decimal_places"))),price:this.parseNumber(this.parsePrecision(this.safeString(o,"decimal_places")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(o,"min_amount"),max:this.safeNumber(o,"max_amount")},price:{min:this.safeNumber(o,"min_price"),max:this.safeNumber(o,"max_price")},cost:{min:this.safeNumber(o,"min_total"),max:void 0}},info:o})}return n}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetDepthPair(this.extend(n,s));if(!(i.id in r))throw new zo(this.id+" "+i.symbol+" order book is empty or not available");const o=r[i.id];return this.parseOrderBook(o,e)}async fetchOrderBooks(e=void 0,t=void 0,s={}){await this.loadMarkets();let i;if(e===void 0){if(i=this.ids.join("-"),i.length>2048){const o=this.ids.length;throw new zo(this.id+" fetchOrderBooks() has "+o.toString()+" symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchOrderBooks")}}else i=this.marketIds(e),i=i.join("-");const n={pair:i};t!==void 0&&(n.limit=t);const r=await this.publicGetDepthPair(this.extend(n,s)),a={};i=Object.keys(r);for(let o=0;o<i.length;o++){const d=i[o],c=this.safeSymbol(d);a[c]=this.parseOrderBook(r[d],c)}return a}parseTicker(e,t=void 0){const s=this.safeTimestamp(e,"updated"),i=this.safeString(e,"last");return this.safeTicker({symbol:this.safeSymbol(void 0,t),timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:i,last:i,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeString(e,"avg"),baseVolume:this.safeString(e,"vol_cur"),quoteVolume:this.safeString(e,"vol"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s=this.ids;if(e===void 0){const o=s.length;s=s.join("-");const d=this.safeInteger(this.options,"fetchTickersMaxLength",2048);if(s.length>this.options.fetchTickersMaxLength)throw new kg(this.id+" fetchTickers() has "+o.toString()+" markets exceeding max URL length for this endpoint ("+d.toString()+" characters), please, specify a list of symbols of interest in the first argument to fetchTickers")}else s=this.marketIds(e),s=s.join("-");const i={pair:s},n=await this.publicGetTickerPair(this.extend(i,t)),r={},a=Object.keys(n);for(let o=0;o<a.length;o++){const d=a[o],c=n[d],u=this.safeMarket(d),h=u.symbol;r[h]=this.parseTicker(c,u)}return this.filterByArray(r,"symbol",e)}async fetchTicker(e,t={}){return(await this.fetchTickers([e],t))[e]}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"timestamp");let i=this.safeString(e,"type");i==="ask"?i="sell":i==="bid"&&(i="buy");const n=this.safeString2(e,"rate","price"),r=this.safeString2(e,"trade_id","tid"),a=this.safeString(e,"order_id"),o=this.safeString(e,"pair"),d=this.safeSymbol(o,t),c=this.safeString(e,"amount"),u=this.parseNumber(n),h=this.parseNumber(c),l="limit";let p;const m=this.safeNumber(e,"commission");if(m!==void 0){const y=this.safeString(e,"commissionCurrency"),b=this.safeCurrencyCode(y);p={cost:m,currency:b}}if(this.safeValue(e,"is_your_order")!==void 0&&p===void 0){const y=this.calculateFee(d,l,i,h,u,"taker");p={currency:this.safeString(y,"currency"),cost:this.safeString(y,"cost"),rate:this.safeString(y,"rate")}}return this.safeTrade({id:r,order:a,timestamp:s,datetime:this.iso8601(s),symbol:d,type:l,side:i,takerOrMaker:void 0,price:n,amount:c,cost:void 0,fee:p,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetTradesPair(this.extend(r,i));if(Array.isArray(a)&&a.length===0)return[];const o=this.safeValue(a,n.id,[]);return this.parseTrades(o,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetInfo(e),s=this.safeValue(t,"pairs",{}),i=Object.keys(s),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeValue(s,a,{}),d=this.safeSymbol(a,void 0,"_"),c=this.safeString(o,"fee_buyer"),u=this.safeString(o,"fee_seller"),h=this.parseNumber(Og.stringDiv(c,"100")),l=this.parseNumber(Og.stringDiv(u,"100"));n[d]={info:o,symbol:d,taker:h,maker:l,percentage:!0,tierBased:!1}}return n}async createOrder(e,t,s,i,n=void 0,r={}){if(t==="market")throw new zo(this.id+" createOrder() allows limit orders only");await this.loadMarkets();const a=this.market(e),o={pair:a.id,type:s,amount:this.amountToPrecision(e,i),rate:this.priceToPrecision(e,n)},d=await this.privatePostTrade(this.extend(o,r)),c=this.safeValue(d,"return");return this.parseOrder(c,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:parseInt(e)},n=await this.privatePostCancelOrder(this.extend(i,s)),r=this.safeValue(n,"return",{});return this.parseOrder(r)}parseOrderStatus(e){const t={0:"open",1:"closed",2:"canceled",3:"open"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){let s=this.safeString2(e,"id","order_id"),i=this.parseOrderStatus(this.safeString(e,"status","open"));s==="0"&&(s=this.safeString(e,"init_order_id"),i="closed");const n=this.safeTimestamp2(e,"timestamp_created","server_time"),r=this.safeString(e,"pair"),a=this.safeSymbol(r,t),o=this.safeString(e,"start_amount"),d=this.safeString2(e,"amount","remains"),c=this.safeString(e,"received","0.0"),u=this.safeString(e,"rate"),h=void 0,l="limit",p=this.safeString(e,"type");return this.safeOrder({info:e,id:s,clientOrderId:void 0,symbol:a,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,type:l,timeInForce:void 0,postOnly:void 0,side:p,price:u,stopPrice:void 0,cost:void 0,amount:o,remaining:d,filled:c,status:i,fee:h,average:void 0,trades:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:parseInt(e)},n=await this.privatePostOrderInfo(this.extend(i,s));e=e.toString();const r=this.safeValue(n,"return",{});return this.parseOrder(this.extend({id:e},r[e]))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new kg(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n={},r=void 0;if(e!==void 0){const d=this.market(e);n.pair=d.id}const a=await this.privatePostActiveOrders(this.extend(n,i)),o=this.safeValue(a,"return",{});return this.parseOrders(o,r,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new kg(this.id+" fetchMyTrades() requires a `symbol` argument");await this.loadMarkets();const n=this.market(e),r={pair:n.id};s!==void 0&&(r.count=parseInt(s)),t!==void 0&&(r.since=parseInt(t/1e3));const a=await this.privatePostTradeHistory(this.extend(r,i)),o=this.safeValue(a,"return",{}),d=Object.keys(o),c=[];for(let u=0;u<d.length;u++){const h=d[u],l=this.parseTrade(this.extend(o[h],{trade_id:h}),n);c.push(l)}return this.filterBySymbolSinceLimit(c,n.symbol,t,s)}async createDepositAddress(e,t={}){const s={need_new:1},i=await this.fetchDepositAddress(e,this.extend(s,t)),n=this.safeString(i,"address");return this.checkAddress(n),{currency:e,address:n,tag:void 0,info:i.info}}async fetchDepositAddress(e,t={}){await this.loadMarkets();let i=this.currency(e).id;const n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper(t,"network");r=this.safeString(n,r,r),r!==void 0&&(r!=="ERC20"&&(i=i+r.toLowerCase()),t=this.omit(t,"network"));const a={coinName:i,need_new:0},o=await this.privatePostGetDepositAddress(this.extend(a,t)),d=this.safeString(o.return,"address");return this.checkAddress(d),{currency:e,address:d,tag:void 0,network:void 0,info:o}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const a={coinName:this.currency(e).id,amount:t,address:s};if(i!==void 0)throw new zo(this.id+" withdraw() does not support the tag argument yet due to a lack of docs on withdrawing with tag/memo on behalf of the exchange.");return{info:await this.privatePostWithdrawCoinsToAddress(this.extend(a,n)),id:void 0}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t];const o=this.omit(i,this.extractParams(e));if(t==="private"){this.checkRequiredCredentials();const d=this.nonce();r=this.urlencode(this.extend({nonce:d,method:e},o));const c=this.hmac(this.encode(r),this.encode(this.secret),"sha512");n={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:c}}else t==="public"?(a+="/"+this.version+"/"+this.implodeParams(e,i),Object.keys(o).length&&(a+="?"+this.urlencode(o))):(a+="/"+this.implodeParams(e,i),s==="GET"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):Object.keys(o).length&&(r=this.json(o),n={"Content-Type":"application/json"}));return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&"success"in a){let c=this.safeValue(a,"success",!1);if(typeof c=="string"&&(c==="true"||c==="1"?c=!0:c=!1),!c){const u=this.safeString(a,"code"),h=this.safeString(a,"error"),l=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,l),this.throwExactlyMatchedException(this.exceptions.exact,h,l),this.throwBroadlyMatchedException(this.exceptions.broad,h,l),new zo(l)}}}};const aU=me,{ExchangeError:kh,BadRequest:oU}=oe,{TICK_SIZE:dU}=pe,cU=ke;var uU=class extends aU{describe(){return this.deepExtend(super.describe(),{id:"zaif",name:"Zaif",countries:["JP"],rateLimit:100,version:"1",has:{CORS:void 0,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelOrder:!0,createMarketOrder:void 0,createOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrderBook:!0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766927-39ca2ada-5eeb-11e7-972f-1b4199518ca6.jpg",api:{rest:"https://api.zaif.jp"},www:"https://zaif.jp",doc:["https://techbureau-api-document.readthedocs.io/ja/latest/index.html","https://corp.zaif.jp/api-docs","https://corp.zaif.jp/api-docs/api_links","https://www.npmjs.com/package/zaif.jp","https://github.com/you21979/node-zaif"],fees:"https://zaif.jp/fee?lang=en"},fees:{trading:{percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0")}},api:{public:{get:{"depth/{pair}":1,"currencies/{pair}":1,"currencies/all":1,"currency_pairs/{pair}":1,"currency_pairs/all":1,"last_price/{pair}":1,"ticker/{pair}":1,"trades/{pair}":1}},private:{post:{active_orders:5,cancel_order:5,deposit_history:5,get_id_info:5,get_info:10,get_info2:5,get_personal_info:5,trade:5,trade_history:50,withdraw:5,withdraw_history:5}},ecapi:{post:{createInvoice:1,getInvoice:1,getInvoiceIdsByOrderNumber:1,cancelInvoice:1}},tlapi:{post:{get_positions:66,position_history:66,active_positions:5,create_position:33,change_position:33,cancel_position:33}},fapi:{get:{"groups/{group_id}":1,"last_price/{group_id}/{pair}":1,"ticker/{group_id}/{pair}":1,"trades/{group_id}/{pair}":1,"depth/{group_id}/{pair}":1}}},options:{fees:{"BTC/JPY":{maker:this.parseNumber("0"),taker:this.parseNumber("0.001")},"BCH/JPY":{maker:this.parseNumber("0"),taker:this.parseNumber("0.003")},"BCH/BTC":{maker:this.parseNumber("0"),taker:this.parseNumber("0.003")},"PEPECASH/JPY":{maker:this.parseNumber("0"),taker:this.parseNumber("0.0001")},"PEPECASH/BT":{maker:this.parseNumber("0"),taker:this.parseNumber("0.0001")}}},precisionMode:dU,exceptions:{exact:{"unsupported currency_pair":oU},broad:{}}})}async fetchMarkets(e={}){const t=await this.publicGetCurrencyPairsAll(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency_pair"),a=this.safeString(n,"name"),[o,d]=a.split("/"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d),h=c+"/"+u,l=this.safeValue(this.options.fees,h,this.fees.trading);s.push({id:r,symbol:h,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:void 0,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,taker:l.taker,maker:l.maker,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(n,"item_unit_step"),price:this.parseNumber(this.parsePrecision(this.safeString(n,"aux_unit_point")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(n,"item_unit_min"),max:void 0},price:{min:this.safeNumber(n,"aux_unit_min"),max:void 0},cost:{min:void 0,max:void 0}},info:n})}return s}parseBalance(e){const t=this.safeValue(e,"return",{}),s=this.safeValue(t,"deposit"),i={info:e,timestamp:void 0,datetime:void 0},n=this.safeValue(t,"funds",{}),r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeCurrencyCode(o),c=this.safeString(n,o),u=this.account();u.free=c,u.total=c,s!==void 0&&o in s&&(u.total=this.safeString(s,o)),i[d]=u}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetInfo(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id},r=await this.publicGetDepthPair(this.extend(n,s));return this.parseOrderBook(r,i.symbol)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.milliseconds(),n=this.safeString(e,"vwap"),r=this.safeString(e,"volume"),a=cU.stringMul(r,n),o=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:n,open:void 0,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:a,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetTickerPair(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){let s=this.safeString(e,"trade_type");s=s==="bid"?"buy":"sell";const i=this.safeTimestamp(e,"date"),n=this.safeString2(e,"id","tid"),r=this.safeString(e,"price"),a=this.safeString(e,"amount"),o=this.safeString(e,"currency_pair"),d=this.safeSymbol(o,t,"_");return this.safeTrade({id:n,info:e,timestamp:i,datetime:this.iso8601(i),symbol:d,type:void 0,side:s,order:void 0,takerOrMaker:void 0,price:r,amount:a,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id};let a=await this.publicGetTradesPair(this.extend(r,i));if(a.length===1){const d=a[0];Object.keys(d).length||(a=[])}return this.parseTrades(a,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){if(await this.loadMarkets(),t!=="limit")throw new kh(this.id+" createOrder() allows limit orders only");const o={currency_pair:this.market(e).id,action:s==="buy"?"bid":"ask",amount:i,price:n},d=await this.privatePostTrade(this.extend(o,r));return{info:d,id:d.return.order_id.toString()}}async cancelOrder(e,t=void 0,s={}){const i={order_id:e};return await this.privatePostCancelOrder(this.extend(i,s))}parseOrder(e,t=void 0){let s=this.safeString(e,"action");s=s==="bid"?"buy":"sell";const i=this.safeTimestamp(e,"timestamp"),n=this.safeString(e,"currency_pair"),r=this.safeSymbol(n,t,"_"),a=this.safeString(e,"price"),o=this.safeString(e,"amount"),d=this.safeString(e,"id");return this.safeOrder({id:d,clientOrderId:void 0,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,status:"open",symbol:r,type:"limit",timeInForce:void 0,postOnly:void 0,side:s,price:a,stopPrice:void 0,cost:void 0,amount:o,filled:void 0,remaining:void 0,trades:void 0,fee:void 0,info:e,average:void 0},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.currency_pair=n.id);const a=await this.privatePostActiveOrders(this.extend(r,i));return this.parseOrders(a.return,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.currency_pair=n.id);const a=await this.privatePostTradeHistory(this.extend(r,i));return this.parseOrders(a.return,n,t,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e);if(e==="JPY")throw new kh(this.id+" withdraw() does not allow "+e+" withdrawals");const a={currency:r.id,amount:t,address:s};i!==void 0&&(a.message=i);const o=await this.privatePostWithdraw(this.extend(a,n)),d=this.safeValue(o,"return");return this.parseTransaction(d,r)}parseTransaction(e,t=void 0){t=this.safeCurrency(void 0,t);let s;const i=this.safeValue(e,"fee");return i!==void 0&&(s={cost:i,currency:t.code}),{id:this.safeString(e,"id"),txid:this.safeString(e,"txid"),timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:s,info:e}}nonce(){return parseFloat(this.milliseconds()/1e3).toFixed(8)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/";if(t==="public")a+="api/"+this.version+"/"+this.implodeParams(e,i);else if(t==="fapi")a+="fapi/"+this.version+"/"+this.implodeParams(e,i);else{this.checkRequiredCredentials(),t==="ecapi"?a+="ecapi":t==="tlapi"?a+="tlapi":a+="tapi";const o=this.nonce();r=this.urlencode(this.extend({method:e,nonce:o},i)),n={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:this.hmac(this.encode(r),this.encode(this.secret),"sha512")}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.id+" "+r,u=this.safeString(a,"error");if(u!==void 0)throw this.throwExactlyMatchedException(this.exceptions.exact,u,c),this.throwBroadlyMatchedException(this.exceptions.broad,u,c),new kh(c);if(!this.safeValue(a,"success",!0))throw new kh(c)}};const fU=me,{BadRequest:fi,BadSymbol:Ig,ExchangeError:Ee,ArgumentsRequired:Et,AuthenticationError:zt,InsufficientFunds:rs,NotSupported:vh,OrderNotFound:Xa,ExchangeNotAvailable:Ya,RateLimitExceeded:Ko,PermissionDenied:tn,InvalidOrder:Ge,InvalidAddress:hU,OnMaintenance:AT,RequestTimeout:Th,AccountSuspended:xg,NetworkError:BT,DDoSProtection:lU,DuplicateOrderId:pU,BadResponse:zc}=oe,{TICK_SIZE:mU}=pe,gU=ke;var Q_=class extends fU{describe(){return this.deepExtend(super.describe(),{id:"zb",name:"ZB",countries:["CN"],rateLimit:6,version:"v1",pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:void 0,option:void 0,addMargin:!0,borrowMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchBorrowRate:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!0,fetchCanceledOrders:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddresses:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!0,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!0,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchWithdrawals:!0,reduceMargin:!0,setLeverage:!0,setMarginMode:!1,setPositionMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","3d":"3d","5d":"5d","1w":"1w"},hostname:"zb.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/32859187-cd5214f0-ca5e-11e7-967d-96568e2e2bd1.jpg",api:{spot:{v1:{public:"https://api.{hostname}/data",private:"https://trade.{hostname}/api"}},contract:{v1:{public:"https://fapi.{hostname}/api/public"},v2:{public:"https://fapi.{hostname}/Server/api",private:"https://fapi.{hostname}/Server/api"}}},www:"https://www.zb.com",doc:"https://www.zb.com/i/developer",fees:"https://www.zb.com/i/rate",referral:{url:"https://www.zb.com/en/register?ref=4301lera",discount:.16}},api:{spot:{v1:{public:{get:{markets:16.667,ticker:16.667,allTicker:16.667,depth:16.667,trades:16.667,kline:166.667,getGroupMarkets:16.667,getFeeInfo:16.667}},private:{get:{order:1,orderMoreV2:1,cancelOrder:1,cancelAllOrdersAfter:1,getOrder:1,getOrders:1,getOrdersNew:16.667,getOrdersIgnoreTradeType:1,getUnfinishedOrdersIgnoreTradeType:1,getFinishedAndPartialOrders:1,getAccountInfo:16.667,getUserAddress:16.667,getPayinAddress:16.667,getWithdrawAddress:16.667,getWithdrawRecord:16.667,getChargeRecord:16.667,getCnyWithdrawRecord:16.667,getCnyChargeRecord:16.667,withdraw:16.667,addSubUser:16.667,getSubUserList:16.667,doTransferFunds:16.667,createSubUserKey:16.667,getLeverAssetsInfo:16.667,getLeverBills:16.667,transferInLever:16.667,transferOutLever:16.667,loan:16.667,cancelLoan:16.667,getLoans:16.667,getLoanRecords:16.667,borrow:16.667,autoBorrow:16.667,repay:16.667,doAllRepay:16.667,getRepayments:16.667,getFinanceRecords:16.667,changeInvestMark:16.667,changeLoop:16.667,getCrossAssets:16.667,getCrossBills:16.667,transferInCross:16.667,transferOutCross:16.667,doCrossLoan:16.667,doCrossRepay:16.667,getCrossRepayRecords:16.667}}}},contract:{v1:{public:{get:{depth:16.667,fundingRate:16.667,indexKline:16.667,indexPrice:16.667,kline:16.667,markKline:16.667,markPrice:16.667,ticker:16.667,trade:16.667}}},v2:{public:{get:{allForceOrders:3.334,"config/marketList":3.334,topLongShortAccountRatio:3.334,topLongShortPositionRatio:3.334,fundingRate:3.334,premiumIndex:3.334}},private:{get:{"Fund/balance":3.334,"Fund/getAccount":3.334,"Fund/getBill":3.334,"Fund/getBillTypeList":3.334,"Fund/marginHistory":3.334,"Positions/getPositions":3.334,"Positions/getNominalValue":3.334,"Positions/marginInfo":3.334,"setting/get":3.334,"trade/getAllOrders":3.334,"trade/getOrder":3.334,"trade/getOrderAlgos":3.334,"trade/getTradeList":3.334,"trade/getUndoneOrders":3.334,"trade/tradeHistory":3.334},post:{"activity/buyTicket":3.334,"Fund/transferFund":3.334,"Positions/setMarginCoins":3.334,"Positions/updateAppendUSDValue":3.334,"Positions/updateMargin":3.334,"setting/setLeverage":3.334,"setting/setPositionsMode":3.334,"trade/batchOrder":3.334,"trade/batchCancelOrder":3.334,"trade/cancelAlgos":3.334,"trade/cancelAllOrders":3.334,"trade/cancelOrder":3.334,"trade/order":3.334,"trade/orderAlgo":3.334,"trade/updateOrderAlgo":3.334}}}}},fees:{funding:{withdraw:{}},trading:{maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},commonCurrencies:{ANG:"Anagram",ENT:"ENTCash",BCHABC:"BCHABC",BCHSV:"BCHSV"},options:{timeframes:{spot:{"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","2h":"2hour","4h":"4hour","6h":"6hour","12h":"12hour","1d":"1day","3d":"3day","1w":"1week"},swap:{"1m":"1M","5m":"5M","15m":"15M","30m":"30M","1h":"1H","6h":"6H","1d":"1D","5d":"5D"}}},precisionMode:mU,exceptions:{ws:{1001:Ee,1002:Ee,1003:zt,1004:zt,1005:zt,1006:tn,1007:Ee,1009:AT,1010:Ya,1012:tn,1013:Ee,1014:Ee,2001:rs,2002:rs,2003:rs,2005:rs,2006:rs,2007:rs,2008:rs,2009:rs,3001:Xa,3002:Ge,3003:Ge,3004:zt,3005:fi,3006:tn,3007:Th,3008:Ee,3009:Ge,3010:tn,3011:Ge,3012:Ge,4001:xg,4002:Ko},exact:{10001:Ee,10002:tn,10003:zc,10004:zc,10005:tn,10006:fi,10007:Ee,10008:Ee,10009:Ee,1001:Ee,10010:zt,10011:zt,10012:xg,10013:zt,10014:zt,10015:zt,10016:zt,10017:tn,10018:xg,10019:Th,1002:Ee,10020:fi,10021:fi,10022:fi,10023:Ko,10024:zt,10025:Ee,10026:BT,10027:Th,10028:Ya,10029:lU,1003:zt,10030:fi,10031:fi,10032:fi,10033:fi,10034:fi,10035:fi,10036:fi,10037:Et,10038:fi,10039:zc,1004:zt,10040:zc,10041:zc,10042:Ee,10043:Ee,10044:Ee,10045:Ee,10046:Ee,10047:Ee,10048:Ee,10049:BT,1005:zt,1006:zt,1009:Ya,1010:Ya,10100:AT,1012:tn,1013:Ee,1014:Ee,11e3:Ee,11001:Ee,110011:Ee,11002:Ee,11003:Ee,11004:rs,11005:Ge,11006:rs,11007:Xa,11008:Ee,11009:Ee,110110:Ee,11012:rs,11013:Ee,11014:Ee,11015:zt,11016:zt,11017:Ee,11018:rs,11019:Ee,11021:rs,11023:Ee,11030:tn,11031:Ee,11032:Ee,11033:Et,11034:Ee,12e3:Ge,12001:Ge,12002:Ge,12003:Ge,12004:Ge,12005:Ge,12006:Ge,12007:Ge,12008:Ge,12009:Ge,12010:Ge,12011:Ge,12012:Xa,12013:Ge,12014:Ge,12015:Ge,12016:Ge,12017:Ge,12018:Ge,12019:Et,12020:Ee,12021:Ge,12022:Ge,12023:Xa,12024:Ge,12025:Ge,12026:pU,12027:Ya,12028:Ge,12029:Ge,12201:Ge,12202:Ge,12203:Ge,12204:Ge,12205:Ge,12206:Ge,12207:Ko,13001:zt,13002:tn,13003:Ge,13004:Ge,13005:Ko,13006:Ee,13007:Ee,13008:Ee,13009:Ee,14e3:Ee,14001:zt,14002:zt,14003:Ee,14100:Ee,14101:Ko,14200:Et,14300:Ee,14301:Ee,14302:Ee,14303:Ee,14305:Ee,14306:Ee,14307:Ge,14308:Ge,14309:Ee,14310:vh,14311:vh,14312:Ee,14313:tn,14314:Ee,2001:rs,2002:rs,2003:rs,2005:rs,2006:rs,2007:rs,2008:rs,2009:rs,3001:Xa,3002:Ge,3003:Ge,3004:zt,3005:fi,3006:zt,3007:zt,3008:Xa,3009:Ge,3010:tn,3011:Ge,3012:Ge,4001:Ya,4002:Ko,9999:Ee},broad:{"\u63D0\u5E01\u5730\u5740\u6709\u8BEF, \u8BF7\u5148\u6DFB\u52A0\u63D0\u5E01\u5730\u5740\u3002":hU,"\u8D44\u91D1\u4E0D\u8DB3,\u65E0\u6CD5\u5212\u8D26":rs,\u54CD\u5E94\u8D85\u65F6:Th}}})}async fetchMarkets(e={}){let t=[this.spotV1PublicGetMarkets(e),this.contractV2PublicGetConfigMarketList(e)];t=await Promise.all(t);const s=t[0],i=t[1],n=this.safeValue(i,"data",[]),r=this.indexBy(n,"marketName"),a=this.deepExtend(r,s),o=Object.keys(a),d=[];for(let c=0;c<o.length;c++){const u=o[c],h=a[u],[l,p]=u.split("_"),m=this.safeCurrencyCode(l),g=this.safeCurrencyCode(p),y=this.safeValue(h,"marginCurrencyName"),b=this.safeCurrencyCode(y),w=b===void 0,S=this.safeValue(h,"futures",!1),k=S?!0:void 0;let T=!0,I=m+"/"+g;S&&(T=this.safeString(h,"status")==="1",I=m+"/"+g+":"+b),d.push({id:u,symbol:I,base:m,quote:g,settle:b,baseId:l,quoteId:p,settleId:y,type:S?"swap":"spot",spot:w,margin:!1,swap:S,future:!1,option:!1,active:T,contract:S,linear:k,inverse:S?!k:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString2(h,"amountScale","amountDecimal"))),price:this.parseNumber(this.parsePrecision(this.safeString2(h,"priceScale","priceDecimal")))},limits:{leverage:{min:void 0,max:this.safeNumber(h,"maxLeverage")},amount:{min:this.safeNumber(h,"minAmount"),max:this.safeNumber(h,"maxAmount")},price:{min:void 0,max:void 0},cost:{min:this.safeNumber2(h,"minSize","minTradeMoney"),max:this.safeNumber(h,"maxTradeMoney")}},info:h})}return d}async fetchCurrencies(e={}){const t=await this.spotV1PublicGetGetFeeInfo(e),s=this.safeValue(t,"result",{}),i=Object.keys(s),n={};for(let r=0;r<i.length;r++){const a=i[r],o=s[a],d=this.safeCurrencyCode(a);let c=!0,u=!0;const h={};for(let p=0;p<o.length;p++){const m=o[p],g=this.safeString(m,"chainName"),y=this.safeNumber(m,"fee"),b=this.safeValue(m,"canDeposit"),w=this.safeValue(m,"canWithdraw");u=u||b,c=c||w,h[g]=y}const l=c&&u;n[d]={id:a,name:void 0,code:d,precision:void 0,info:o,active:l,deposit:u,withdraw:c,fee:void 0,fees:h,limits:this.limits}}return n}parseBalance(e){const t=this.safeValue(e.result,"coins"),s={info:e};for(let i=0;i<t.length;i++){const n=t[i],r=this.account(),a=this.safeString(n,"key"),o=this.safeCurrencyCode(a);r.free=this.safeString(n,"available"),r.used=this.safeString(n,"freez"),s[o]=r}return this.safeBalance(s)}parseSwapBalance(e){const t={info:e},s=this.safeValue(e,"data",{});for(let i=0;i<s.length;i++){const n=s[i],r=this.safeCurrencyCode(this.safeString(n,"currencyName")),a=this.account();a.total=this.safeString(n,"accountBalance"),a.free=this.safeString(n,"allowTransferOutAmount"),a.used=this.safeString(n,"freezeAmount"),t[r]=a}return this.safeBalance(t)}parseMarginBalance(e,t){const s={info:e};let i;if(t==="isolated"){const n=this.safeValue(e,"message",{}),r=this.safeValue(n,"datas",{});i=this.safeValue(r,"levers",[])}else{const n=this.safeValue(e,"result",{});i=this.safeValue(n,"list",[])}for(let n=0;n<i.length;n++){const r=i[n],a=this.account();if(t==="isolated"){const o=this.safeCurrencyCode(this.safeString(r,"fShowName"));a.total=this.safeString(r,"fAvailableUSD"),a.free=this.safeString(r,"couldTransferOutFiat"),a.used=this.safeString(r,"fFreeze"),s[o]=a}else{const o=this.safeCurrencyCode(this.safeString(r,"key"));a.total=this.safeString(r,"amount"),a.free=this.safeString(r,"canTransferOut"),a.used=this.safeString(r,"freeze"),s[o]=a}}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),[i,n]=this.handleMarginModeAndParams("fetchBalance",s),r=t==="swap",a=i==="cross"?"spotV1PrivateGetGetCrossAssets":"spotV1PrivateGetGetLeverAssetsInfo";let o=this.getSupportedMapping(t,{spot:"spotV1PrivateGetGetAccountInfo",swap:"contractV2PrivateGetFundBalance",margin:a});i==="isolated"?o="spotV1PrivateGetGetLeverAssetsInfo":i==="cross"&&(o="spotV1PrivateGetGetCrossAssets");const d={};r&&(d.futuresAccountType=1);const c=await this[o](this.extend(d,n));return r?this.parseSwapBalance(c):i!==void 0?this.parseMarginBalance(c,i):this.parseBalance(c)}parseDepositAddress(e,t=void 0){let s=this.safeString2(e,"key","address"),i;const n=this.safeString(e,"memo");if(n!==void 0)i=n;else if(s.indexOf("_")>=0){const o=s.split("_");s=o[0],i=o[1]}this.checkAddress(s);const r=this.safeString(e,"blockChain");return{currency:this.safeCurrencyCode(r,t),address:s,tag:i,network:void 0,info:e}}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s=await this.spotV1PrivateGetGetPayinAddress(t),i=this.safeValue(s,"message",{}),n=this.safeValue(i,"datas",[]);return this.parseDepositAddresses(n,e)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=await this.spotV1PrivateGetGetUserAddress(this.extend(i,t)),r=this.safeValue(n,"message",{}),a=this.safeValue(r,"datas",{});return this.parseDepositAddress(a,s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={},r=i.swap?"symbol":"market";n[r]=i.id;const a=this.getSupportedMapping(i.type,{spot:"spotV1PublicGetDepth",swap:"contractV1PublicGetDepth"});t!==void 0&&(n.size=t);const o=await this[a](this.extend(n,s));let d,c;return i.type==="swap"?(d=this.safeValue(o,"data"),c=this.safeInteger(d,"time")):(d=o,c=this.safeTimestamp(o,"timestamp")),this.parseOrderBook(d,e,c)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.spotV1PublicGetAllTicker(t),i={},n={},r=Object.keys(this.markets_by_id);for(let o=0;o<r.length;o++){const d=r[o].replace("_","");n[d]=this.markets_by_id[r[o]]}const a=Object.keys(s);for(let o=0;o<a.length;o++){const d=this.safeValue(n,a[o]);if(d!==void 0){const c=d.symbol,u=this.safeValue(s,a[o]);u!==void 0&&(i[c]=this.parseTicker(u,d))}}return this.filterByArray(i,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={},n=s.swap?"symbol":"market";i[n]=s.id;const r=this.getSupportedMapping(s.type,{spot:"spotV1PublicGetTicker",swap:"contractV1PublicGetTicker"}),a=await this[r](this.extend(i,t));let o;if(s.type==="swap"){o={};const d=this.safeValue(a,"data"),c=this.safeValue(d,s.id,[]);for(let u=0;u<c.length;u++)o.open=this.safeValue(c,0),o.high=this.safeValue(c,1),o.low=this.safeValue(c,2),o.last=this.safeValue(c,3),o.vol=this.safeValue(c,4),o.riseRate=this.safeValue(c,5)}else o=this.safeValue(a,"ticker",{}),o.date=this.safeValue(a,"date");return this.parseTicker(o,s)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"date",this.milliseconds()),i=this.safeString(e,"last");return this.safeTicker({symbol:this.safeSymbol(void 0,t),timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:i,last:i,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"vol"),quoteVolume:void 0,info:e},t)}parseOHLCV(e,t=void 0){return t.swap?e.length>5?[this.safeTimestamp(e,5),this.safeNumber(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4)]:[this.safeTimestamp(e,4),this.safeNumber(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),void 0]:[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=r.swap,o=r.spot,d=this.safeValue(this.options,"timeframes",{}),c=this.safeValue(d,r.type,{}),u=this.safeString(c,t);if(u===void 0)throw new vh(this.id+" fetchOHLCV() does not support "+t+" timeframe for "+r.type+" markets");i===void 0&&(i=1e3);const h={size:i},l=a?"symbol":"market";h[l]=r.id;const p=a?"period":"type";h[p]=u;const m=this.safeString(n,"price");n=this.omit(n,"price");let g=this.getSupportedMapping(r.type,{spot:"spotV1PublicGetKline",swap:"contractV1PublicGetKline"});a?m==="mark"?g="contractV1PublicGetMarkKline":m==="index"&&(g="contractV1PublicGetIndexKline"):o&&s!==void 0&&(h.since=s);const y=await this[g](this.extend(h,n)),b=this.safeValue(y,"data",[]);return this.parseOHLCVs(b,r,t,s,i)}parseTrade(e,t=void 0){const s=t.swap?"side":"trade_type";let i=this.safeString(e,s),n;const r=this.safeValue(e,"maker");r!==void 0&&(n=r?"maker":"taker"),t.spot?i=i==="bid"?"buy":"sell":i==="3"?i="sell":i==="4"||i==="1"?i="buy":i==="2"&&(i="sell");let a;t.swap?a=this.safeInteger(e,"createTime"):a=this.safeTimestamp(e,"date");const o=this.safeString(e,"price"),d=this.safeString(e,"amount");let c;const u=this.safeString(e,"feeAmount");if(u!==void 0){const h=this.safeString(e,"feeCurrency");c={cost:u,currency:this.safeCurrencyCode(h)}}return t=this.safeMarket(void 0,t),this.safeTrade({info:e,id:this.safeString(e,"tid"),timestamp:a,datetime:this.iso8601(a),symbol:t.symbol,type:void 0,side:i,order:this.safeString(e,"orderId"),takerOrMaker:n,price:o,amount:d,cost:void 0,fee:c},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){if(e===void 0)throw new Et(this.id+" fetchTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=n.swap,a={};s!==void 0&&(a.pageSize=s),t!==void 0&&(a.startTime=t);const o=r?"symbol":"market";a[o]=n.id,r&&i.pageNum===void 0&&(a.pageNum=1);const d=this.getSupportedMapping(n.type,{spot:"spotV1PublicGetTrades",swap:"contractV2PrivateGetTradeTradeHistory"});let c=await this[d](this.extend(a,i));if(r){const u=this.safeValue(c,"data");c=this.safeValue(u,"list")}return this.parseTrades(c,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),[o,d]=this.handleMarginModeAndParams("createOrder",r),c=a.swap,u=a.spot,h=this.safeString(r,"timeInForce");let l=this.safeValue(r,"reduceOnly");const p=this.safeValue2(r,"triggerPrice","stopPrice"),m=this.safeValue(r,"stopLossPrice"),g=this.safeValue(r,"takeProfitPrice"),y=m!==void 0,b=g!==void 0,w=p!==void 0;if(this.sum(y,b,w))throw new Ee(this.id+" createOrder() stopLossPrice and takeProfitPrice cannot both be defined");const S=y||b||w;if(S&&u)throw new Ee(this.id+" createOrder() it is not possible to make a stop order on spot markets");if(t==="market")throw new Ge(this.id+" createOrder() on "+a.type+" markets does not allow market orders");let k=this.getSupportedMapping(a.type,{spot:"spotV1PrivateGetOrder",margin:"spotV1PrivateGetOrder",swap:"contractV2PrivatePostTradeOrder"});const T={amount:this.amountToPrecision(e,i)};if(u){const N=this.safeInteger(r,"orderType",t)===1,M=this.isPostOnly(!1,N,r);T.tradeType=s==="buy"?1:0,T.currency=a.id,M?T.orderType=1:h==="IOC"&&(T.orderType=2),n!==void 0&&(T.price=this.priceToPrecision(e,n)),o!==void 0&&(o==="isolated"?T.acctType=1:o==="cross"&&(T.acctType=2))}else if(c){const N=this.safeInteger(r,"action",t)===4,M=this.isPostOnly(!1,N,r);(y||b)&&(l=!0),l?T.side=0:T.side=s==="buy"?5:6,S?(k="contractV2PrivatePostTradeOrderAlgo",y?(T.orderType=2,T.bizType=2,T.triggerPrice=this.priceToPrecision(e,m)):b?(T.orderType=2,T.bizType=1,T.triggerPrice=this.priceToPrecision(e,g)):w&&(T.orderType=1,T.triggerPrice=this.priceToPrecision(e,p)),T.algoPrice=this.priceToPrecision(e,n),T.pricetype=2):h==="IOC"?T.action=3:M?T.action=4:h==="FOK"?T.action=5:t==="limit"?T.action=1:T.action=t,n!==void 0&&(T.price=this.priceToPrecision(e,n)),T.symbol=a.id;const x=this.safeString(r,"clientOrderId");x!==void 0&&(T.clientOrderId=x);const v=this.safeValue(r,"extend",void 0);v!==void 0&&(T.extend=v)}r=this.omit(d,["takeProfitPrice","stopLossPrice","stopPrice","reduceOnly","orderType","triggerPrice","priceType","clientOrderId","extend"]);const I=await this[k](this.extend(T,r));let _=I;return c&&!S&&(_=this.safeValue(I,"data")),this.parseOrder(_,a)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Et(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=i.swap,r={},a=n?"symbol":"currency";r[a]=this.marketId(t);const o=n?"orderId":"id";r[o]=e.toString();const d=this.getSupportedMapping(i.type,{spot:"spotV1PrivateGetCancelOrder",swap:"contractV2PrivatePostTradeCancelOrder"}),c=await this[d](this.extend(r,s));return this.parseOrder(c,i)}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new Et(this.id+" cancelAllOrders() requires a symbol argument");await this.loadMarkets();const s=this.market(e),i=this.safeValue(t,"stop");if(s.spot)throw new vh(this.id+" cancelAllOrders() is not supported on "+s.type+" markets");const n={symbol:s.id};let r="contractV2PrivatePostTradeCancelAllOrders";i&&(r="contractV2PrivatePostTradeCancelAlgos");const a=this.omit(t,"stop");return await this[r](this.extend(n,a))}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Et(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t);if(this.safeInteger(s,"orderType")!==void 0)throw new Ee(this.id+" fetchOrder() it is not possible to fetch a single conditional order, use fetchOrders() instead");const r=i.swap,a={},o=r?"symbol":"currency";a[o]=this.marketId(t);const d=r?"orderId":"id";a[d]=e.toString();const c=this.getSupportedMapping(i.type,{spot:"spotV1PrivateGetGetOrder",swap:"contractV2PrivateGetTradeGetOrder"}),u=await this[c](this.extend(a,s));let h=u;return r&&(h=this.safeValue(u,"data")),this.parseOrder(h,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Et(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=this.safeInteger(i,"orderType"),a=n.swap,o={pageSize:s},d=n.swap?"symbol":"currency";o[d]=n.id;const c=n.swap?"pageNum":"pageIndex";o[c]=1,a&&(o.startTime=t);let u=this.getSupportedMapping(n.type,{spot:"spotV1PrivateGetGetOrdersIgnoreTradeType",swap:"contractV2PrivateGetTradeGetAllOrders"});"tradeType"in i&&(u="spotV1PrivateGetGetOrdersNew"),r!==void 0&&(u="contractV2PrivateGetTradeGetOrderAlgos");const h=await this[u](this.extend(o,i));let l=h;if(a){const p=this.safeValue(h,"data",{});l=this.safeValue(p,"list",[])}return this.parseOrders(l,n,t,s)}async fetchCanceledOrders(e=void 0,t=void 0,s=10,i={}){if(e===void 0)throw new Et(this.id+" fetchCanceledOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=this.safeValue(i,"reduceOnly"),a=this.safeValue(i,"stop"),o={pageSize:s},d=n.spot?"currency":"symbol";o[d]=n.id;const c=n.spot?"pageIndex":"pageNum";o[c]=1;let u="spotV1PrivateGetGetOrdersIgnoreTradeType";if(a){u="contractV2PrivateGetTradeGetOrderAlgos";const m=this.safeInteger(i,"orderType");if(m===void 0)throw new Et(this.id+" fetchCanceledOrders() requires an orderType parameter for stop orders");const g=this.safeValue(i,"side"),y=this.safeInteger(i,"bizType");g==="sell"&&r?o.side=3:g==="buy"&&r?o.side=4:g==="buy"?o.side=1:g==="sell"?o.side=2:g===5?o.side=5:g===6?o.side=6:g===0&&(o.side=0),m===1?o.orderType=1:(m===2||y)&&(o.orderType=2,o.bizType=y),o.status=2}"tradeType"in i&&(u="spotV1PrivateGetGetOrdersNew");let h;try{h=await this[u](this.extend(o,i))}catch(m){if(m instanceof Xa)return[];throw m}const l=this.omit(i,["reduceOnly","stop","side","orderType","bizType"]);if(h=await this[u](this.extend(o,l)),a){const m=this.safeValue(h,"data",{});h=this.safeValue(m,"list",[])}const p=[];if(n.type==="spot"){for(let m=0;m<h.length;m++){const g=h[m];this.safeString(g,"status")==="1"&&p.push(g)}h=p}return this.parseOrders(h,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=10,i={}){if(e===void 0)throw new Et(this.id+" fetchClosedOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=n.swap,a=this.safeInteger(i,"orderType"),o={pageSize:s},d=n.spot?"currency":"symbol";o[d]=n.id;const c=n.spot?"pageIndex":"pageNum";o[c]=1,r&&t!==void 0&&(o.startTime=t);const u=this.getSupportedMapping(n.type,{spot:"spotV1PrivateGetGetFinishedAndPartialOrders",swap:"contractV2PrivateGetTradeGetOrderAlgos"});if(r&&a===void 0)throw new Ee(this.id+" fetchClosedOrders() can not fetch swap orders, use fetchOrders instead");r&&(o.status=5);const h=await this[u](this.extend(o,i));let l=h;if(r){const p=this.safeValue(h,"data",{});l=this.safeValue(p,"list",[])}return this.parseOrders(l,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Et(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=this.safeInteger(i,"orderType"),a=n.swap,o={};s!==void 0&&(o.pageSize=s);const d=n.swap?"symbol":"currency";o[d]=n.id;const c=n.swap?"pageNum":"pageIndex";o[c]=1,a&&t!==void 0&&(o.startTime=t);let u=this.getSupportedMapping(n.type,{spot:"spotV1PrivateGetGetUnfinishedOrdersIgnoreTradeType",swap:"contractV2PrivateGetTradeGetUndoneOrders"});r!==void 0&&(u="contractV2PrivateGetTradeGetOrderAlgos",o.status=1),"tradeType"in i&&(u="spotV1PrivateGetGetOrdersNew");const h=await this[u](this.extend(o,i));let l=h;if(a){const p=this.safeValue(h,"data",{});l=this.safeValue(p,"list",[])}return this.parseOrders(l,n,t,s)}parseOrder(e,t=void 0){let s=t.swap?this.safeString2(e,"orderId","data"):this.safeString(e,"id");s===void 0&&(s=this.safeValue(e,"id"));let i=this.safeInteger2(e,"type","side");i===void 0?i=void 0:t.spot?i=i===1?"buy":"sell":t.swap&&(i===0?i=void 0:i===1||i===4||i===5?i="buy":(i===2||i===3||i===6)&&(i="sell"));let n=this.safeInteger(e,"trade_date");n===void 0&&(n=this.safeInteger(e,"createTime"));const r=this.safeString(e,"currency");t=this.safeMarket(r,t,"_");const a=this.safeString2(e,"price","algoPrice"),o=t.swap?this.safeString(e,"tradeAmount"):this.safeString(e,"trade_amount");let d=this.safeString(e,"total_amount");d===void 0&&(d=this.safeString(e,"amount"));const c=this.safeString(e,"trade_money"),u=this.parseOrderStatus(this.safeString(e,"status"),t),h=this.safeString(e,"timeInForce"),l=h==="PO",p=this.safeNumber(e,"fees");let m;if(p!==void 0){let g;this.safeValue(e,"useZbFee")===!0?g="ZB":g=i==="sell"?t.quote:t.base,m={cost:p,currency:g}}return this.safeOrder({info:e,id:s,clientOrderId:this.safeString(e,"userId"),timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,symbol:t.symbol,type:"limit",timeInForce:h,postOnly:l,side:i,price:a,stopPrice:this.safeNumber(e,"triggerPrice"),average:this.safeString(e,"avgPrice"),cost:c,amount:d,filled:o,remaining:void 0,status:u,fee:m,trades:void 0},t)}parseOrderStatus(e,t=void 0){let s={};return t.type==="spot"?s={0:"open",1:"canceled",2:"closed",3:"open"}:s={1:"open",2:"canceled",3:"open",4:"rejected",5:"closed"},this.safeString(s,e,e)}parseTransactionStatus(e){const t={0:"pending",1:"failed",2:"ok",3:"canceled",5:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"hash"),n=this.safeNumber(e,"amount");let r=this.parse8601(this.safeString(e,"submit_time"));r=this.safeInteger(e,"submitTime",r);let a=this.safeString2(e,"toAddress","address"),o;if(a!==void 0){const y=a.split("_");a=this.safeString(y,0),o=this.safeString(y,1)}const d=this.safeInteger(e,"confirmTimes"),c=this.safeInteger(e,"manageTime");let u;const h=this.safeString(e,"currency"),l=this.safeCurrencyCode(h,t);a!==void 0&&(u=d===void 0?"withdrawal":"deposit");const p=this.parseTransactionStatus(this.safeString(e,"status"));let m;const g=this.safeNumber(e,"fees");return g!==void 0&&(m={cost:g,currency:l}),{info:e,id:s,txid:i,timestamp:r,datetime:this.iso8601(r),network:void 0,addressFrom:void 0,address:a,addressTo:a,tagFrom:void 0,tag:o,tagTo:o,type:u,amount:n,currency:l,status:p,updated:c,fee:m}}async setLeverage(e,t=void 0,s={}){if(await this.loadMarkets(),t===void 0)throw new Et(this.id+" setLeverage() requires a symbol argument");if(e<1||e>125)throw new fi(this.id+" setLeverage() leverage should be between 1 and 125");const i=this.market(t);let n;if(i.swap)n=1;else throw new Ig(this.id+" setLeverage() supports swap contracts only");const r={symbol:i.id,leverage:e,futuresAccountType:n};return await this.contractV2PrivatePostSettingSetLeverage(this.extend(r,s))}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};if(e!==void 0){const u=this.market(e);e=u.symbol,n.symbol=u.id}t!==void 0&&(n.startTime=t);const r=this.safeInteger2(i,"until","till");i=this.omit(i,["endTime","till","until"]),r!==void 0&&(n.endTime=r),s!==void 0&&(n.limit=s);const a=await this.contractV2PublicGetFundingRate(this.extend(n,i)),o=this.safeValue(a,"data",[]),d=[];for(let u=0;u<o.length;u++){const h=o[u],l=this.safeString(h,"symbol"),p=this.safeSymbol(l),m=this.safeInteger(h,"fundingTime");d.push({info:h,symbol:p,fundingRate:this.safeNumber(h,"fundingRate"),timestamp:m,datetime:this.iso8601(m)})}const c=this.sortBy(d,"timestamp");return this.filterBySymbolSinceLimit(c,e,t,s)}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new Ig(this.id+" fetchFundingRate() does not supports contracts only");const i={symbol:s.id},n=await this.contractV1PublicGetFundingRate(this.extend(i,t)),r=this.safeValue(n,"data");return this.parseFundingRate(r,s)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeNumber2(e,"fundingRate","lastFundingRate"),r=this.parse8601(this.safeString(e,"nextCalculateTime")),a=this.safeInteger(e,"nextFundingTime");return{info:e,symbol:i,markPrice:this.safeString(e,"markPrice"),indexPrice:this.safeString(e,"indexPrice"),interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:n,fundingTimestamp:a,fundingDatetime:this.iso8601(a),nextFundingRate:void 0,nextFundingTimestamp:r,nextFundingDatetime:this.iso8601(r),previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.contractV2PublicGetPremiumIndex(t),i=this.safeValue(s,"data",[]),n=this.parseFundingRates(i);return this.filterByArray(n,"symbol",e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n);const r=this.safeString(n,"safePwd",this.password);if(r===void 0)throw new Et(this.id+" withdraw() requires exchange.password or a safePwd parameter");const a=this.safeNumber(n,"fees");if(a===void 0)throw new Et(this.id+" withdraw() requires a fees parameter");this.checkAddress(s),await this.loadMarkets();const o=this.currency(e);i!==void 0&&(s+="_"+i);const d={amount:this.currencyToPrecision(e,t),currency:o.id,fees:this.currencyToPrecision(e,a),method:"withdraw",receiveAddr:s,safePwd:r},c=await this.spotV1PrivateGetWithdraw(this.extend(d,n)),u=this.parseTransaction(c,o);return this.extend(u,{type:"withdrawal",address:s,addressTo:s,amount:t})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.pageSize=s);const a=await this.spotV1PrivateGetGetWithdrawRecord(this.extend(n,i)),o=this.safeValue(a,"message",{}),d=this.safeValue(o,"datas",{}),c=this.safeValue(d,"list",[]);return this.parseTransactions(c,r,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.pageSize=s);const a=await this.spotV1PrivateGetGetChargeRecord(this.extend(n,i)),o=this.safeValue(a,"message",{}),d=this.safeValue(o,"datas",{}),c=this.safeValue(d,"list",[]);return this.parseTransactions(c,r,t,s)}async fetchPosition(e,t={}){await this.loadMarkets();let s;e!==void 0&&(s=this.market(e));const i={futuresAccountType:1},n=await this.contractV2PrivateGetPositionsGetPositions(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0);return this.parsePosition(a,s)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s={futuresAccountType:1},i=await this.contractV2PrivateGetPositionsGetPositions(this.extend(s,t)),n=this.safeValue(i,"data",[]);return this.parsePositions(n,e)}parsePosition(e,t=void 0){const s=this.safeString(e,"marketName");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeString(e,"amount"),r=this.safeNumber(e,"avgPrice"),a=this.safeString(e,"margin"),d=this.safeString(e,"side")==="1"?"long":"short",u=this.safeString(e,"marginMode")==="1"?"isolated":"cross",h=this.safeString(e,"leverage"),l=this.safeNumber(e,"liquidatePrice"),p=this.safeNumber(e,"unrealizedPnl"),m=this.safeNumber(e,"maintainMargin"),g=this.safeNumber(e,"marginRate"),y=this.safeNumber(e,"nominalValue"),b=gU.stringMul(this.safeString(e,"returnRate"),"100"),w=this.safeNumber(e,"createTime");return{info:e,id:void 0,symbol:i,contracts:this.parseNumber(n),contractSize:void 0,entryPrice:r,collateral:void 0,side:d,unrealizedProfit:p,leverage:this.parseNumber(h),percentage:b,marginMode:u,notional:y,markPrice:void 0,liquidationPrice:l,initialMargin:this.parseNumber(a),initialMarginPercentage:void 0,maintenanceMargin:m,maintenanceMarginPercentage:void 0,marginRatio:g,timestamp:w,datetime:this.iso8601(w)}}parseLedgerEntryType(e){const t={1:"realized pnl",2:"commission",3:"funding fee subtract",4:"funding fee addition",5:"insurance clear",6:"transfer in",7:"transfer out",8:"margin addition",9:"margin subtraction",10:"commission addition",11:"bill type freeze",12:"bill type unfreeze",13:"system take over margin",14:"transfer",15:"realized pnl collection",16:"funding fee collection",17:"recommender return commission",18:"by level subtract positions",19:"system add",20:"system subtract",23:"trading competition take over fund",24:"trading contest tickets",25:"return of trading contest tickets",26:"experience expired recall",50:"test register gift",51:"register gift",52:"deposit gift",53:"trading volume gift",54:"awards gift",55:"trading volume gift",56:"awards gift expire",201:"open positions",202:"close positions",203:"take over positions",204:"trading competition take over positions",205:"one way open long",206:"one way open short",207:"one way close long",208:"one way close short",301:"coupon deduction service charge",302:"experience deduction",303:"experience expired"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeInteger(e,"createTime");let i;this.safeNumber(e,"isIn")===1?i="increase":i="reduce";let r;const a=this.safeNumber(e,"fee");return a!==void 0&&(r={cost:a,currency:this.safeCurrencyCode(this.safeString(e,"unit"))}),{id:this.safeString(e,"id"),info:e,timestamp:s,datetime:this.iso8601(s),direction:i,account:this.safeString(e,"userId"),referenceId:void 0,referenceAccount:void 0,type:this.parseLedgerEntryType(this.safeInteger(e,"type")),currency:this.safeCurrencyCode(this.safeString(e,"unit")),amount:this.safeNumber(e,"changeAmount"),before:this.safeNumber(e,"beforeAmount"),after:this.safeNumber(e,"available"),status:void 0,fee:r}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Et(this.id+" fetchLedger() requires a code argument");await this.loadMarkets();const n=this.currency(e),r={futuresAccountType:1};e!==void 0&&(r.currencyName=n.id),t!==void 0&&(r.startTime=t),s!==void 0&&(r.pageSize=s);const a=await this.contractV2PrivateGetFundGetBill(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"list",[]);return this.parseLedger(d,n,t,s)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const[r,a]=this.handleMarketTypeAndParams("transfer",void 0,n),[o,d]=this.handleMarginModeAndParams("transfer",a),c=this.currency(e),u=r==="swap",h=this.currencyToPrecision(e,t),l={amount:h};let p,m;if(u)p="contractV2PrivatePostFundTransferFund",s==="spot"||i==="future"?m=1:m=0,l.currencyName=c.id,l.clientId=this.safeString(n,"clientId"),l.side=m;else{if(o==="isolated"||i==="isolated"||s==="isolated"){s==="spot"||i==="isolated"?p="spotV1PrivateGetTransferInLever":p="spotV1PrivateGetTransferOutLever";const y=this.safeString2(n,"marketName","symbol");if(y===void 0)throw new Et(this.id+" transfer() requires a symbol argument for isolated margin");const b=this.market(y);l.marketName=this.safeSymbol(b.id,b,"_")}else(o==="cross"||i==="cross"||s==="cross")&&(s==="spot"||i==="cross"?p="spotV1PrivateGetTransferInCross":p="spotV1PrivateGetTransferOutCross");l.coin=c.id}const g=await this[p](this.extend(l,d));return this.extend(this.parseTransfer(g,c),{amount:this.parseNumber(h),fromAccount:s,toAccount:i})}parseTransfer(e,t=void 0){const s=this.milliseconds();return{id:this.safeString(e,"data"),timestamp:s,datetime:this.iso8601(s),currency:this.safeCurrencyCode(void 0,"currency"),amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0}}async modifyMarginHelper(e,t,s,i={}){if(i.positionsId===void 0)throw new Et(this.id+" modifyMarginHelper() requires a positionsId argument in the params");await this.loadMarkets();const n=this.market(e);t=this.amountToPrecision(e,t);const a={positionsId:this.safeString(i,"positionsId"),amount:t,type:s,futuresAccountType:1},o=await this.contractV2PrivatePostPositionsUpdateMargin(this.extend(a,i));return this.extend(this.parseMarginModification(o,n),{amount:this.parseNumber(t)})}parseMarginModification(e,t=void 0){const s=this.safeValue(e,"data",{}),n=this.safeInteger(s,"side")===1?"add":"reduce",a=this.safeInteger(s,"status")===1?"ok":"failed";return{info:e,type:n,amount:void 0,code:t.quote,symbol:t.symbol,status:a}}async addMargin(e,t,s={}){if(s.positionsId===void 0)throw new Et(this.id+" addMargin() requires a positionsId argument in the params");return await this.modifyMarginHelper(e,t,1,s)}async reduceMargin(e,t,s={}){if(s.positionsId===void 0)throw new Et(this.id+" reduceMargin() requires a positionsId argument in the params");return await this.modifyMarginHelper(e,t,0,s)}async fetchBorrowRate(e,t={}){await this.loadMarkets();const i={coin:this.currency(e).id},n=await this.spotV1PrivateGetGetLoans(this.extend(i,t)),r=this.milliseconds(),a=this.safeValue(n,"result",[]),o=this.safeValue(a,0,{});return{currency:this.safeCurrencyCode(this.safeString(o,"coinName")),rate:this.safeNumber(o,"interestRateOfDay"),period:this.safeNumber(o,"repaymentDay"),timestamp:r,datetime:this.iso8601(r),info:o}}async fetchBorrowRates(e={}){if(e.coin===void 0)throw new Et(this.id+" fetchBorrowRates() requires a coin argument in the params");await this.loadMarkets();const s={coin:this.currency(this.safeString(e,"coin")).id},i=await this.spotV1PrivateGetGetLoans(this.extend(s,e)),n=this.milliseconds(),r=this.safeValue(i,"result",[]),a=[];for(let o=0;o<r.length;o++){const d=r[o];a.push({currency:this.safeCurrencyCode(this.safeString(d,"coinName")),rate:this.safeNumber(d,"interestRateOfDay"),period:this.safeNumber(d,"repaymentDay"),timestamp:n,datetime:this.iso8601(n),info:d})}return a}async setPositionMode(e,t=void 0,s={}){if(await this.loadMarkets(),t===void 0)throw new Et(this.id+" setPositionMode() requires a symbol argument");const i=this.market(t);let n;if(i.swap)n=1;else throw new Ig(this.id+" setPositionMode() supports swap contracts only");const r={marketId:i.id,positionMode:e?2:1,futuresAccountType:n};return await this.contractV2PrivatePostSettingSetPositionsMode(this.extend(r,s))}async borrowMargin(e,t,s=void 0,i={}){await this.loadMarkets();let n;s!==void 0&&(n=this.market(s),s=n.symbol);let r;[r,i]=this.handleMarginModeAndParams("borrowMargin",i),r===void 0&&(s!==void 0?r="isolated":r="cross");const a=this.safeString(i,"safePwd",this.password),o=this.currency(e),d={coin:o.id,amount:this.currencyToPrecision(e,t),safePwd:a};let c;if(r==="isolated"){if(s===void 0)throw new Et(this.id+" borrowMargin() requires a symbol argument for isolated margin");const l=this.market(s);d.marketName=this.safeSymbol(l.id,l,"_"),c="spotV1PrivateGetBorrow"}else r==="cross"&&(c="spotV1PrivateGetDoCrossLoan");const u=await this[c](this.extend(d,i)),h=this.parseMarginLoan(u,o);return this.extend(h,{amount:t,symbol:s})}parseMarginLoan(e,t=void 0){return{id:void 0,currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const[a,o,d]=t;let c=this.implodeHostname(this.urls.api[a][o][d]);if(d==="public")e==="getFeeInfo"?c=this.implodeHostname(this.urls.api[a][o].private)+"/"+e:c+="/"+o+"/"+e,Object.keys(i).length&&(c+="?"+this.urlencode(i));else if(a==="contract"){const u=this.milliseconds(),h=this.iso8601(u);let l=h+s+"/Server/api/"+o+"/"+e;if(i=this.keysort(i),n={"ZB-APIKEY":this.apiKey,"ZB-TIMESTAMP":h},c+="/"+o+"/"+e,s==="POST")n["Content-Type"]="application/json",r=this.json(i),l+=this.urlencode(i);else if(Object.keys(i).length){const g=this.urlencode(i);c+="?"+g,l+=g}const p=this.hash(this.encode(this.secret),"sha1"),m=this.hmac(this.encode(l),this.encode(p),"sha256","base64");n["ZB-SIGN"]=m}else{let u=this.keysort(this.extend({method:e,accesskey:this.apiKey},i));const h=this.nonce();u=this.keysort(u);const l=this.rawencode(u),p=this.hash(this.encode(this.secret),"sha1"),g="sign="+this.hmac(this.encode(l),this.encode(p),"md5")+"&reqTime="+h.toString();c+="/"+e+"?"+l+"&"+g}return{url:c,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&r[0]==="{"){const c=this.id+" "+r;if(this.throwBroadlyMatchedException(this.exceptions.broad,r,c),"code"in a){const h=this.safeString(a,"code");if(this.throwExactlyMatchedException(this.exceptions.exact,h,c),h!=="1000"&&h!=="10000")throw new Ee(c)}const u=this.safeValue(a,"result");if(u!==void 0&&!u)throw this.safeString(a,"message")==="\u670D\u52A1\u7AEF\u5FD9\u788C"?new Ya(c):new Ee(c)}}};const yU=Hl;var bU=class extends yU{describe(){return this.deepExtend(super.describe(),{id:"zipmex",name:"Zipmex",countries:["AU","SG","TH","ID"],certified:!1,pro:!0,urls:{logo:"https://user-images.githubusercontent.com/1294454/146103275-c39a34d9-68a4-4cd2-b1f1-c684548d311b.jpg",test:void 0,api:{public:"https://apws.zipmex.com:8443/AP",private:"https://apws.zipmex.com:8443/AP"},www:"https://zipmex.com/",referral:"https://trade.zipmex.com/global/accounts/sign-up?aff=KLm7HyCsvN",fees:"https://zipmex.com/fee-schedule"},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.002"),maker:this.parseNumber("0.002")}}})}};class Z_ extends Array{constructor(e=void 0){super(),Object.defineProperty(this,"maxSize",{__proto__:null,value:e,writable:!0})}clear(){this.length=0}}class J_ extends Z_{constructor(e=void 0){super(e),Object.defineProperty(this,"nestedNewUpdatesBySymbol",{__proto__:null,value:!1,writable:!0}),Object.defineProperty(this,"newUpdatesBySymbol",{__proto__:null,value:{},writable:!0}),Object.defineProperty(this,"clearUpdatesBySymbol",{__proto__:null,value:{},writable:!0}),Object.defineProperty(this,"allNewUpdates",{__proto__:null,value:0,writable:!0}),Object.defineProperty(this,"clearAllUpdates",{__proto__:null,value:!1,writable:!0})}getLimit(e,t){let s;return e===void 0?(s=this.allNewUpdates,this.clearAllUpdates=!0):(s=this.newUpdatesBySymbol[e],s!==void 0&&this.nestedNewUpdatesBySymbol&&(s=s.size),this.clearUpdatesBySymbol[e]=!0),s===void 0?t:t!==void 0?Math.min(s,t):s}append(e){this.maxSize&&this.length===this.maxSize&&this.shift(),this.push(e),this.clearAllUpdates&&(this.clearAllUpdates=!1,this.clearUpdatesBySymbol={},this.allNewUpdates=0,this.newUpdatesBySymbol={}),this.clearUpdatesBySymbol[e.symbol]&&(this.clearUpdatesBySymbol[e.symbol]=!1,this.newUpdatesBySymbol[e.symbol]=0),this.newUpdatesBySymbol[e.symbol]=(this.newUpdatesBySymbol[e.symbol]||0)+1,this.allNewUpdates=(this.allNewUpdates||0)+1}}class wU extends Z_{constructor(e=void 0){super(e),Object.defineProperty(this,"hashmap",{__proto__:null,value:{},writable:!0}),Object.defineProperty(this,"sizeTracker",{__proto__:null,value:new Set,writable:!0}),Object.defineProperty(this,"newUpdates",{__proto__:null,value:0,writable:!0}),Object.defineProperty(this,"clearUpdates",{__proto__:null,value:!1,writable:!0})}getLimit(e,t){return this.clearUpdates=!0,t===void 0?this.newUpdates:Math.min(this.newUpdates,t)}append(e){if(e[0]in this.hashmap){const t=this.hashmap[e[0]];if(t!==e)for(const s in e)t[s]=e[s]}else{if(this.hashmap[e[0]]=e,this.maxSize&&this.length===this.maxSize){const t=this.shift();delete this.hashmap[t[0]]}this.push(e)}this.clearUpdates&&(this.clearUpdates=!1,this.sizeTracker.clear()),this.sizeTracker.add(e[0]),this.newUpdates=this.sizeTracker.size}}class SU extends J_{constructor(e=void 0){super(e),this.nestedNewUpdatesBySymbol=!0,Object.defineProperty(this,"hashmap",{__proto__:null,value:{},writable:!0})}append(e){const t=this.hashmap[e.symbol]=this.hashmap[e.symbol]||{};if(e.id in t){const r=t[e.id];if(r!==e)for(const o in e)r[o]=e[o];e=r;const a=this.findIndex(o=>o.id===e.id);this.splice(a,1)}else t[e.id]=e;if(this.maxSize&&this.length===this.maxSize){const r=this.shift();delete this.hashmap[r.symbol][r.id]}this.push(e),this.clearAllUpdates&&(this.clearAllUpdates=!1,this.clearUpdatesBySymbol={},this.allNewUpdates=0,this.newUpdatesBySymbol={}),this.newUpdatesBySymbol[e.symbol]===void 0&&(this.newUpdatesBySymbol[e.symbol]=new Set),this.clearUpdatesBySymbol[e.symbol]&&(this.clearUpdatesBySymbol[e.symbol]=!1,this.newUpdatesBySymbol[e.symbol].clear());const s=this.newUpdatesBySymbol[e.symbol],i=s.size;s.add(e.id);const n=s.size;this.allNewUpdates=(this.allNewUpdates||0)+(n-i)}}var et={ArrayCache:J_,ArrayCacheByTimestamp:wU,ArrayCacheBySymbolById:SU};const kU=w_,{ArrayCache:vU,ArrayCacheByTimestamp:TU,ArrayCacheBySymbolById:OU,NotSupported:IU,AuthenticationError:xU}=et;var _U=class extends kU{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOHLCV:!0,watchOrderBook:!0,watchTicker:!0,watchTrades:!0,watchBalance:!0,watchOrders:!0},urls:{api:{ws:{public:"wss://realtime.aax.com/marketdata/v2/",private:"wss://stream.aax.com/notification/v2/"}}},options:{OHLCVLimit:1e3,tradesLimit:1e3,ordersLimit:1e3,myTradesLimit:1e3}})}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r="candles",a=this.market(e);e=a.symbol;const o=this.timeframes[t],d=a.id+"@"+o+"_"+r,c=this.urls.api.ws.public,u={e:"subscribe",stream:d},h=this.deepExtend(u,n),l=await this.watch(c,d,h,d);return this.newUpdates&&(i=l.getLimit(e,i)),this.filterBySinceLimit(l,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"e"),i=s.split("@"),n=this.safeString(i,0),r=this.safeString(i,1),o=this.safeMarket(n).symbol,d=[this.safeTimestamp(t,"s"),this.safeNumber(t,"o"),this.safeNumber(t,"h"),this.safeNumber(t,"l"),this.safeNumber(t,"c"),this.safeNumber(t,"v")],c=r.split("_"),u=this.safeString(c,0),h=this.findTimeframe(u);this.ohlcvs[o]=this.safeValue(this.ohlcvs,o,{});let l=this.safeValue(this.ohlcvs[o],h);if(l===void 0){const p=this.safeInteger(this.options,"OHLCVLimit",1e3);l=new TU(p),this.ohlcvs[o][h]=l}l.append(d),e.resolve(l,s)}async watchTicker(e,t={}){const s="tickers";await this.loadMarkets();const n=this.market(e).id+"@"+s,r=this.urls.api.ws.public,a={e:"subscribe",stream:s},o=this.extend(a,t);return await this.watch(r,n,o,s)}handleTickers(e,t){const s=this.safeString(t,"e"),i=this.safeInteger(t,"t"),n={timestamp:i,datetime:this.iso8601(i)},r=this.parseTickers(this.safeValue(t,"tickers",[]),void 0,n),a=Object.keys(r);for(let o=0;o<a.length;o++){const d=a[o];if(d in this.markets){const c=this.market(d),u=r[d];this.tickers[d]=u;const h=c.id+"@"+s;e.resolve(u,h)}}}async watchTrades(e,t=void 0,s=void 0,i={}){const n="trade";await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=r.id+"@"+n,o=this.urls.api.ws.public,d={e:"subscribe",stream:a},c=this.extend(d,i),u=await this.watch(o,a,c,a);return this.newUpdates&&(s=u.getLimit(e,s)),this.filterBySinceLimit(u,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeString(t,"e"),i=s.split("@"),n=this.safeString(i,0),r=this.safeMarket(n),a=r.symbol,o=this.parseTrade(t,r);let d=this.safeValue(this.trades,a);if(d===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);d=new vU(c),this.trades[a]=d}d.append(o),e.resolve(d,s)}async watchOrderBook(e,t=void 0,s={}){const i="book";await this.loadMarkets();const n=this.market(e);if(t=t===void 0?20:t,t!==20&&t!==50)throw new IU(this.id+" watchOrderBook() accepts limit values of 20 or 50 only");const r=n.id+"@"+i+"_"+t.toString(),a=this.urls.api.ws.public,o={e:"subscribe",stream:r},d=this.extend(o,s);return(await this.watch(a,r,d,r)).limit()}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBook(e,t){const s=this.safeString(t,"e"),[i,n]=s.split("@"),r=n.split("_"),o=this.safeMarket(i).symbol,d=this.safeString(r,1),c=parseInt(d),u=this.safeInteger(t,"t"),h=this.parseOrderBook(t,o,u);let l;o in this.orderbooks?(l=this.orderbooks[o],l.reset(h)):(l=this.orderBook(h,c),this.orderbooks[o]=l),e.resolve(l,s)}requestId(){const e=this.sum(this.safeInteger(this.options,"reqid",0),1);return this.options.reqid=e,e}async handshake(e={}){const t=this.urls.api.ws.private,s=this.client(t),i="handshake",n=s.future(i);if(this.safeValue(s.subscriptions,i)===void 0){const a=this.requestId(),o={event:"#"+i,data:{},cid:a},d=this.extend(o,e),c=a.toString(),u=await this.watch(t,c,d,i);n.resolve(u)}return await n}async authenticate(e={}){const t=this.urls.api.ws.private,s=this.client(t),i="login",n=s.future(i);if(this.safeValue(s.subscriptions,i)===void 0){const a=this.milliseconds(),o=a.toString()+":"+this.apiKey,d=this.hmac(this.encode(o),this.encode(this.secret)),c=this.requestId(),u={event:i,data:{apiKey:this.apiKey,nonce:a,signature:d},cid:c},h=this.extend(u,e),l=c.toString(),p=await this.watch(t,l,h,i),m=this.safeValue(p,"data",{});if(this.safeValue(m,"isAuthenticated",!1))n.resolve(p);else throw new xU(this.id+" "+this.json(p))}return await n}async watchBalance(e={}){await this.loadMarkets(),await this.handshake(e);const t=await this.authenticate(e),s=this.safeValue(t,"data",{}),i=this.safeString(s,"uid"),n=this.urls.api.ws.private,r=this.safeString2(this.options,"userId","userID",i),a=this.safeString2(e,"userId","userID",r),o=this.safeString2(this.options,"watchBalance","defaultType","spot"),d=this.safeString(e,"type",o),c=this.omit(e,["userId","userID","type"]),u="user/"+a,h=d+":balance",l=this.requestId(),p={event:"#subscribe",data:{channel:u},cid:l},m=this.deepExtend(p,c);return await this.watch(n,h,m,u)}handleBalance(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(s,"purseType"),n=this.safeValue(this.options,"accountsById",{}),r=this.safeString(n,i),a=r+":balance",o=this.safeString(s,"currency"),d=this.safeCurrencyCode(o),c=this.account();c.free=this.safeString(s,"available"),c.used=this.safeString(s,"unavailable"),r in this.balance||(this.balance[r]={}),this.balance[r][d]=c,this.balance[r]=this.safeBalance(this.balance[r]),e.resolve(this.balance[r],a)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.handshake(i);const n=await this.authenticate(i),r=this.safeValue(n,"data",{}),a=this.safeString(r,"uid"),o=this.urls.api.ws.private,d=this.safeString2(this.options,"userId","userID",a),c=this.safeString2(i,"userId","userID",d),u=this.omit(i,["userId","userID"]),h="user/"+c;let l="orders";e!==void 0&&(e=this.symbol(e),l+=":"+e);const p=this.requestId(),m={event:"#subscribe",data:{channel:h},cid:p},g=this.deepExtend(m,u),y=await this.watch(o,l,g,l);return this.newUpdates&&(s=y.getLimit(e,s)),this.filterBySymbolSinceLimit(y,e,t,s,!0)}handleOrder(e,t){const s="orders",i=this.safeValue(t,"data"),n=this.safeValue(i,"order"),r=n===void 0?this.parseOrder(i):this.parseOrder(n),a=this.safeString(r,"symbol"),o=this.safeString(r,"id");if(a!==void 0){if(this.orders===void 0){const l=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new OU(l)}const d=this.orders,c=this.safeValue(d.hashmap,a,{}),u=this.safeValue(c,o);if(u!==void 0){const l=this.safeValue(u,"fee");l!==void 0&&(r.fee=l);const p=this.safeValue(u,"fees");p!==void 0&&(r.fees=p),r.trades=this.safeValue(u,"trades"),r.timestamp=this.safeInteger(u,"timestamp"),r.datetime=this.safeString(u,"datetime")}d.append(r),e.resolve(this.orders,s);const h=s+":"+a;e.resolve(this.orders,h)}}handleSystemStatus(e,t){return t}handleSubscriptionStatus(e,t){const s=this.safeString(t,"rid");return e.resolve(t,s),t}async pong(e,t){const s="#2";await e.send(s)}handlePing(e,t){this.spawn(this.pong,e,t)}handleNotification(e,t){const s=this.safeValue(t,"event"),i={USER_FUNDS:this.handleBalance,USER_BALANCE:this.handleBalance,SPOT:this.handleOrder,FUTURES:this.handleOrder},n=this.safeValue(i,s);if(n!==void 0)return n.call(this,e,t)}handleMessage(e,t){if(typeof t=="string")t==="#1"&&this.handlePing(e,t);else{const s=this.safeString(t,"event"),i=this.safeString(t,"e");if(s==="#publish"){const n=this.safeValue(t,"data",{}),r=this.safeValue(n,"data",{});this.handleNotification(e,r)}else if(i===void 0)this.safeString(t,"rid")!==void 0&&this.handleSubscriptionStatus(e,t);else{const n=i.split("@"),r=n.length,a={reply:this.handleSubscriptionStatus,system:this.handleSystemStatus,book:this.handleOrderBook,trade:this.handleTrades,empty:void 0,tickers:this.handleTickers,candles:this.handleOHLCV,done:this.handleOrder};let o;if(r>1){const c=this.safeString(n,1).split("_"),u=this.safeString(c,0),h=this.safeString(c,1);o=this.safeValue2(a,u,h)}else{const d=this.safeString(n,0);o=this.safeValue(a,d)}if(o!==void 0)return o.call(this,e,t)}}}};const CU=S_,{AuthenticationError:MU}=oe,{ArrayCache:PU,ArrayCacheByTimestamp:AU,ArrayCacheBySymbolById:BU}=et;var NU=class extends CU{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!1,watchTrades:!0},urls:{api:{ws:{public:"wss://ascendex.com:443/api/pro/v2/stream",private:"wss://ascendex.com:443/{accountGroup}/api/pro/v2/stream"}},test:{ws:{public:"wss://api-test.ascendex-sandbox.com:443/api/pro/v2/stream",private:"wss://api-test.ascendex-sandbox.com:443/{accountGroup}/api/pro/v2/stream"}}},options:{tradesLimit:1e3,ordersLimit:1e3,OHLCVLimit:1e3,categoriesAccount:{cash:"spot",futures:"swap",margin:"margin"}}})}async watchPublic(e,t={}){const s=this.urls.api.ws.public,n={id:this.nonce().toString(),op:"sub"},r=this.extend(n,t);return await this.watch(s,e,r,e)}async watchPrivate(e,t,s={}){await this.loadAccounts();const i=this.safeString(this.options,"account-group");let n=this.urls.api.ws.private;n=this.implodeParams(n,{accountGroup:i});const a={id:this.nonce().toString(),op:"sub",ch:e},o=this.extend(a,s);return await this.authenticate(n,s),await this.watch(n,t,o,e)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol,(i===void 0||i>1440)&&(i=100);const o="bar:"+this.timeframes[t]+":"+r.id;n={ch:o};const d=await this.watchPublic(o,n);return this.newUpdates&&(i=d.getLimit(e,i)),this.filterBySinceLimit(d,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"s"),i=this.safeSymbol(s),n=this.safeString(t,"m"),r=this.safeValue(t,"data",{}),a=this.safeString(r,"i"),o=n+":"+a+":"+s,d=this.findTimeframe(a),c=this.market(i),u=this.parseOHLCV(t,c);this.ohlcvs[i]=this.safeValue(this.ohlcvs,i,{});let h=this.safeValue(this.ohlcvs[i],d);if(h===void 0){const l=this.safeInteger(this.options,"OHLCVLimit",1e3);h=new AU(l),this.ohlcvs[i][d]=h}return h.append(u),e.resolve(h,o),t}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="trades:"+n.id;i=this.extend(i,{ch:r});const a=await this.watchPublic(r,i);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySinceLimit(a,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeString(t,"symbol"),i=this.safeSymbol(s),r=this.safeString(t,"m")+":"+s,a=this.market(i);let o=this.safeValue(t,"data");o===void 0&&(o=[]);const d=this.parseTrades(o,a);let c=this.safeValue(this.trades,i);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new PU(u)}for(let u=0;u<d.length;u++)c.append(d[u]);this.trades[i]=c,e.resolve(c,r)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n="depth-realtime:"+this.market(e).id;return s=this.extend(s,{ch:n}),(await this.watchPublic(n,s)).limit()}async watchOrderBookSnapshot(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n="depth-snapshot-realtime",r=n+":"+i.id;return s=this.extend(s,{action:n,args:{symbol:i.id},op:"req"}),(await this.watchPublic(r,s)).limit()}handleOrderBookSnapshot(e,t){const s=this.safeString(t,"symbol"),i=this.safeSymbol(s),r=this.safeString(t,"m")+":"+i,a=this.orderbooks[i],o=this.safeValue(t,"data"),d=this.parseOrderBook(o,i);d.nonce=this.safeInteger(o,"seqnum"),a.reset(d);const c=a.cache;for(let u=0;u<c.length;u++){const h=c[u];this.handleOrderBookMessage(e,h,a)}this.orderbooks[i]=a,e.resolve(a,r)}handleOrderBook(e,t){const s=this.safeString(t,"m"),i=this.safeString(t,"symbol"),n=this.safeSymbol(i),r=s+":"+i;let a=this.safeValue(this.orderbooks,n);a===void 0&&(a=this.orderBook({})),a.nonce===void 0?a.cache.push(t):(this.handleOrderBookMessage(e,t,a),e.resolve(a,r))}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s){const i=this.safeValue(t,"data",{}),n=this.safeInteger(i,"seqnum");if(n>s.nonce){const r=this.safeValue(i,"asks",[]),a=this.safeValue(i,"bids",[]);this.handleDeltas(s.asks,r),this.handleDeltas(s.bids,a),s.nonce=n;const o=this.safeInteger(i,"ts");s.timestamp=o,s.datetime=this.iso8601(o)}return s}async watchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("watchBalance",void 0,e);let i,n;if(t==="spot"||t==="margin"){const r=this.safeValue(this.options,"accountCategories",{});let a=this.safeString(r,t,"cash");a=a.toUpperCase(),i="order:"+a,n="balance:"+t}else i="futures-account-update",n="balance:swap";return await this.watchPrivate(i,n,s)}handleBalance(e,t){const s=this.safeString(t,"m");let i,n;if(s==="order"||s==="futures-order"){const a=this.safeValue(t,"data"),o=this.safeString(a,"s"),d=this.safeMarket(o),c=this.account();c.free=this.safeString(a,"bab"),c.total=this.safeString(a,"btb");const u=this.account();u.free=this.safeString(a,"qab"),u.total=this.safeString(a,"qtb"),d.contract?(n="swap",i=this.safeValue(this.balance,n,{})):(n=d.type,i=this.safeValue(this.balance,n,{})),i[d.base]=c,i[d.quote]=u}else{const a=this.safeStringLower2(t,"ac","at"),o=this.safeValue(this.options,"categoriesAccount");n=this.safeString(o,a,"spot"),i=this.safeValue(this.balance,n,{});const d=this.safeValue(t,"data");let c;d===void 0?c=this.safeValue(t,"col"):c=[d];for(let u=0;u<c.length;u++){const h=c[u],l=this.safeCurrencyCode(this.safeString(h,"a")),p=this.account();p.free=this.safeString(h,"ab"),p.total=this.safeString2(h,"tb","b"),i[l]=p}}const r="balance:"+n;e.resolve(this.safeBalance(i),r)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e),e=n.symbol);const[r,a]=this.handleMarketTypeAndParams("watchOrders",n,i);let o,d;if(r!=="spot")d="futures-order",o="order:FUTURES";else{const u=this.safeValue(this.options,"accountCategories",{});let h=this.safeString(u,r,"cash");h=h.toUpperCase(),o="order:"+h,d=o}e!==void 0&&(o=o+":"+e);const c=await this.watchPrivate(d,o,a);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}handleOrder(e,t){const i="order:"+this.safeString(t,"ac"),n=this.safeValue(t,"data",t),r=this.parseWsOrder(n);if(this.orders===void 0){const d=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new BU(d)}const a=this.orders;a.append(r);const o=i+":"+r.symbol;e.resolve(a,o),e.resolve(a,i)}parseWsOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString(e,"st")),i=this.safeString(e,"s"),n=this.safeInteger(e,"t"),r=this.safeSymbol(i,t,"/"),a=this.safeInteger(e,"t"),o=this.safeString(e,"p"),d=this.safeString(e,"q"),c=this.safeString(e,"ap"),u=this.safeString(e,"cfq"),h=this.safeString(e,"orderId"),l=this.safeStringLower(e,"ot"),p=this.safeStringLower(e,"sd"),m=this.safeNumber(e,"cf");let g;if(m!==void 0){const b=this.safeString(e,"fa"),w=this.safeCurrencyCode(b);g={cost:m,currency:w}}const y=this.parseNumber(this.omitZero(this.safeString(e,"sp")));return this.safeOrder({info:e,id:h,clientOrderId:void 0,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:a,symbol:r,type:l,timeInForce:void 0,postOnly:void 0,side:p,price:o,stopPrice:y,amount:d,cost:void 0,average:c,filled:u,remaining:void 0,status:s,fee:g,trades:void 0},t)}handleErrorMessage(e,t){const s=this.safeInteger(t,"code");try{if(s!==void 0){const i=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,i);const n=this.safeValue(t,"message");n!==void 0&&this.throwBroadlyMatchedException(this.exceptions.broad,n,i)}}catch(i){if(i instanceof MU){e.reject(i,"authenticated");const n="auth";return n in e.subscriptions&&delete e.subscriptions[n],!1}else e.reject(i)}return t}handleAuthenticate(e,t){return e.futures.authenticated.resolve(1),t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;const s=this.safeString(t,"m"),i={ping:this.handlePing,auth:this.handleAuthenticate,sub:this.handleSubscriptionStatus,"depth-realtime":this.handleOrderBook,"depth-snapshot-realtime":this.handleOrderBookSnapshot,trades:this.handleTrades,bar:this.handleOHLCV,balance:this.handleBalance,"futures-account-update":this.handleBalance},n=this.safeValue(i,s);return n!==void 0&&n.call(this,e,t),(s==="order"||s==="futures-order")&&(this.handleOrder(e,t),s==="order"&&this.handleBalance(e,t)),t}handleSubscriptionStatus(e,t){return this.safeString(t,"ch","").indexOf("depth-realtime")>-1&&this.handleOrderBookSubscription(e,t),t}handleOrderBookSubscription(e,t){const n=this.safeString(t,"ch").split(":")[1],r=this.safeSymbol(n);r in this.orderbooks&&delete this.orderbooks[r],this.orderbooks[r]=this.orderBook({}),this.spawn(this.watchOrderBookSnapshot,r)}async pong(e,t){await e.send({op:"pong",hp:this.safeInteger(t,"hp")})}handlePing(e,t){this.spawn(this.pong,e,t)}async authenticate(e,t={}){this.checkRequiredCredentials();const s="authenticated",i=this.client(e);let n=this.safeValue(i.futures,s);if(n===void 0){n=i.future("authenticated"),i.future(s);const r=this.milliseconds().toString(),a=e.split("/"),o=a.length,d=this.safeString(a,o-1),c=this.safeString(a,o-2),u=r+"+"+c+"/"+d,h=this.base64ToBinary(this.secret),l=this.hmac(this.encode(u),h,"sha256","base64"),p={op:"auth",id:this.nonce().toString(),t:r,key:this.apiKey,sig:l};this.spawn(this.watch,e,s,this.extend(p,t))}return await n}};const EU=Dl,{ArrayCache:VU,ArrayCacheByTimestamp:qU}=et;var _b=class extends EU{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchOrderBook:!0,watchBalance:!1,watchOHLCV:!0},urls:{api:{ws:"wss://api.hitbtc.com/api/2/ws"}},options:{tradesLimit:1e3,methods:{orderbook:"subscribeOrderbook",ticker:"subscribeTicker",trades:"subscribeTrades",ohlcv:"subscribeCandles"}}})}async watchPublic(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.marketId(e),r=this.urls.api.ws;let a=t+":"+n;s!==void 0&&(a+=":"+s);const o=this.safeValue(this.options,"methods",{}),d=this.safeString(o,t,t),c=this.nonce(),u={method:d,params:{symbol:n},id:c},h=this.deepExtend(u,i);return await this.watch(r,a,h,a)}async watchOrderBook(e,t=void 0,s={}){return(await this.watchPublic(e,"orderbook",void 0,s)).limit()}handleOrderBookSnapshot(e,t){const s=this.safeValue(t,"params",{}),i=this.safeString(s,"symbol"),r=this.safeMarket(i).symbol,a=this.parse8601(this.safeString(s,"timestamp")),o=this.safeInteger(s,"sequence");r in this.orderbooks&&delete this.orderbooks[r];const d=this.parseOrderBook(s,r,a,"bid","ask","price","size"),c=this.orderBook(d);c.nonce=o,this.orderbooks[r]=c;const u="orderbook:"+i;e.resolve(c,u)}handleOrderBookUpdate(e,t){const s=this.safeValue(t,"params",{}),i=this.safeString(s,"symbol"),r=this.safeMarket(i).symbol;if(r in this.orderbooks){const a=this.parse8601(this.safeString(s,"timestamp")),o=this.safeInteger(s,"sequence"),d=this.orderbooks[r],c=this.safeValue(s,"ask",[]),u=this.safeValue(s,"bid",[]);this.handleDeltas(d.asks,c),this.handleDeltas(d.bids,u),d.timestamp=a,d.datetime=this.iso8601(a),d.nonce=o,this.orderbooks[r]=d;const h="orderbook:"+i;e.resolve(d,h)}}handleDelta(e,t){const s=this.safeFloat(t,"price"),i=this.safeFloat(t,"size");e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchTicker(e,t={}){return await this.watchPublic(e,"ticker",void 0,t)}handleTicker(e,t){const s=this.safeValue(t,"params"),i=this.safeValue(s,"symbol"),n=this.safeMarket(i),r=n.symbol,a=this.parseTicker(s,n);this.tickers[r]=a;const d=this.safeValue(t,"method")+":"+i;e.resolve(a,d)}async watchTrades(e,t=void 0,s=void 0,i={}){const n=await this.watchPublic(e,"trades",void 0,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"params",{}),i=this.safeValue(s,"data",[]),n=this.safeString(s,"symbol"),r=this.safeMarket(n),a=r.symbol,o="trades:"+n,d=this.safeInteger(this.options,"tradesLimit",1e3);let c=this.safeValue(this.trades,a);if(c===void 0&&(c=new VU(d),this.trades[a]=c),Array.isArray(i)){const u=this.parseTrades(i,r);for(let h=0;h<u.length;h++)c.append(u[h])}else{const u=this.parseTrade(t,r);c.append(u)}return e.resolve(c,o),t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){const r=this.timeframes[t],a={params:{period:r}},o=this.deepExtend(a,n),d=await this.watchPublic(e,"ohlcv",r,o);return this.newUpdates&&(i=d.getLimit(e,i)),this.filterBySinceLimit(d,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"params",{}),i=this.safeValue(s,"data",[]),n=this.safeString(s,"symbol"),r=this.safeMarket(n),a=r.symbol,o=this.safeString(s,"period"),d=this.findTimeframe(o),c="ohlcv:"+n+":"+o;for(let u=0;u<i.length;u++){const h=i[u],l=this.parseOHLCV(h,r);this.ohlcvs[a]=this.safeValue(this.ohlcvs,a,{});let p=this.safeValue(this.ohlcvs[a],d);if(p===void 0){const m=this.safeInteger(this.options,"OHLCVLimit",1e3);p=new qU(m),this.ohlcvs[a][d]=p}p.append(l),e.resolve(p,c)}return t}handleNotification(e,t){return t}handleMessage(e,t){const s={snapshotOrderbook:this.handleOrderBookSnapshot,updateOrderbook:this.handleOrderBookUpdate,ticker:this.handleTicker,snapshotTrades:this.handleTrades,updateTrades:this.handleTrades,snapshotCandles:this.handleOHLCV,updateCandles:this.handleOHLCV},i=this.safeString(t,"method"),n=this.safeValue(s,i);n===void 0?this.handleNotification(e,t):n.call(this,e,t)}};const LU=_b;var RU=class extends LU{describe(){return this.deepExtend(super.describe(),{id:"bequant",name:"Bequant",countries:["MT"],pro:!0,urls:{logo:"https://user-images.githubusercontent.com/1294454/55248342-a75dfe00-525a-11e9-8aa2-05e9dca943c6.jpg",api:{public:"https://api.bequant.io",private:"https://api.bequant.io"},www:"https://bequant.io",doc:["https://api.bequant.io/"],fees:["https://bequant.io/fees-and-limits"],referral:"https://bequant.io"}})}};const FU=Eu,DU=ke,{ExchangeError:_g}=oe,{ArrayCache:HU,ArrayCacheByTimestamp:GU,ArrayCacheBySymbolById:NT}=et;var Gl=class extends FU{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0},urls:{test:{ws:{spot:"wss://testnet.binance.vision/ws",margin:"wss://testnet.binance.vision/ws",future:"wss://stream.binancefuture.com/ws",delivery:"wss://dstream.binancefuture.com/ws"}},api:{ws:{spot:"wss://stream.binance.com:9443/ws",margin:"wss://stream.binance.com:9443/ws",future:"wss://fstream.binance.com/ws",delivery:"wss://dstream.binance.com/ws"}}},options:{streamLimits:{spot:1024,margin:1024,future:200,delivery:200},streamBySubscriptionsHash:{},streamIndex:-1,watchOrderBookRate:100,tradesLimit:1e3,ordersLimit:1e3,OHLCVLimit:1e3,requestId:{},watchOrderBookLimit:1e3,watchTrades:{name:"trade"},watchTicker:{name:"ticker"},watchBalance:{fetchBalanceSnapshot:!1,awaitBalanceSnapshot:!0},wallet:"wb",listenKeyRefreshRate:12e5,ws:{cost:5}}})}requestId(e){const t=this.safeValue(this.options,"requestId",{}),s=this.safeInteger(t,e,0),i=this.sum(s,1);return this.options.requestId[e]=i,i}stream(e,t){const s=this.safeValue(this.options,"streamBySubscriptionsHash",{});let i=this.safeString(s,t);if(i===void 0){let n=this.safeInteger(this.options,"streamIndex",-1);const r=this.safeValue(this.options,"streamLimits"),a=this.safeInteger(r,e);n=n+1,n===a&&(n=0),this.options.streamIndex=n,i=this.numberToString(n),s[t]=i}return i}onError(e,t){this.options.streamBySubscriptionsHash={},this.options.streamIndex=-1,super.onError(e,t)}onClose(e,t){this.options.streamBySubscriptionsHash={},this.options.streamIndex=-1,super.onClose(e,t)}async watchOrderBook(e,t=void 0,s={}){if(t!==void 0&&t!==5&&t!==10&&t!==20&&t!==50&&t!==100&&t!==500&&t!==1e3)throw new _g(this.id+" watchOrderBook limit argument must be undefined, 5, 10, 20, 50, 100, 500 or 1000");await this.loadMarkets();const i=this.safeString2(this.options,"watchOrderBook","defaultType","spot"),n=this.safeString(s,"type",i),r=this.omit(s,"type"),a=this.market(e),o="depth",d=a.lowercaseId+"@"+o,c=this.urls.api.ws[n]+"/"+this.stream(n,d),u=this.requestId(c),h=this.safeString(this.options,"watchOrderBookRate","100"),l={method:"SUBSCRIBE",params:[d+"@"+h+"ms"],id:u},p={id:u.toString(),messageHash:d,name:o,symbol:a.symbol,method:this.handleOrderBookSubscription,limit:t,type:n,params:s},m=this.extend(l,r);return(await this.watch(c,d,m,d,p)).limit()}async fetchOrderBookSnapshot(e,t,s){const i=this.safeInteger(this.options,"watchOrderBookLimit",1e3),n=this.safeValue(s,"type"),r=this.safeString(s,"symbol"),a=this.safeString(s,"messageHash"),o=this.safeInteger(s,"limit",i),d=this.safeValue(s,"params"),c=await this.fetchOrderBook(r,o,d),u=this.safeValue(this.orderbooks,r);if(u===void 0)return;u.reset(c);const h=u.cache;for(let l=0;l<h.length;l++){const p=h[l],m=this.safeInteger(p,"U"),g=this.safeInteger(p,"u"),y=this.safeInteger(p,"pu");if(n==="future"){if(g<u.nonce)continue;(m<=u.nonce&&g>=u.nonce||y===u.nonce)&&this.handleOrderBookMessage(e,p,u)}else{if(g<=u.nonce)continue;m-1<=u.nonce&&g-1>=u.nonce&&this.handleOrderBookMessage(e,p,u)}}this.orderbooks[r]=u,e.resolve(u,a)}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s){const i=this.safeInteger(t,"u");this.handleDeltas(s.asks,this.safeValue(t,"a",[])),this.handleDeltas(s.bids,this.safeValue(t,"b",[])),s.nonce=i;const n=this.safeInteger(t,"E");return s.timestamp=n,s.datetime=this.iso8601(n),s}handleOrderBook(e,t){const s=this.safeString(t,"s"),i=this.safeMarket(s),n=i.symbol,r="depth",a=i.lowercaseId+"@"+r,o=this.safeValue(this.orderbooks,n);if(o===void 0)return;const d=this.safeInteger(o,"nonce");if(d===void 0)o.cache.push(t);else try{const c=this.safeInteger(t,"U"),u=this.safeInteger(t,"u"),h=this.safeInteger(t,"pu");if(h===void 0){if(u>o.nonce){const l=this.safeInteger(o,"timestamp");let p;if(l===void 0?p=c-1<=o.nonce&&u-1>=o.nonce:p=c-1===o.nonce,p)this.handleOrderBookMessage(e,t,o),d<o.nonce&&e.resolve(o,a);else throw new _g(this.id+" handleOrderBook received an out-of-order nonce")}}else if(u>=o.nonce)if(c<=o.nonce||h===o.nonce)this.handleOrderBookMessage(e,t,o),d<=o.nonce&&e.resolve(o,a);else throw new _g(this.id+" handleOrderBook received an out-of-order nonce")}catch(c){delete this.orderbooks[n],delete e.subscriptions[a],e.reject(c,a)}}handleOrderBookSubscription(e,t,s){const i=this.safeInteger(this.options,"watchOrderBookLimit",1e3),n=this.safeString(s,"symbol"),r=this.safeInteger(s,"limit",i);n in this.orderbooks&&delete this.orderbooks[n],this.orderbooks[n]=this.orderBook({},r),this.spawn(this.fetchOrderBookSnapshot,e,t,s)}handleSubscriptionStatus(e,t){const s=this.safeString(t,"id"),i=this.indexBy(e.subscriptions,"id"),n=this.safeValue(i,s,{}),r=this.safeValue(n,"method");return r!==void 0&&r.call(this,e,t,n),t}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r=this.safeValue(this.options,"watchTrades",{}),a=this.safeString(r,"name","trade"),o=n.lowercaseId+"@"+a,d=this.safeString(this.options,"defaultType","spot"),c=this.safeString2(r,"type","defaultType",d),u=this.safeString(i,"type",c),h=this.omit(i,"type"),l=this.urls.api.ws[u]+"/"+this.stream(u,o),p=this.requestId(l),m={method:"SUBSCRIBE",params:[o],id:p},g={id:p},y=await this.watch(l,o,this.extend(m,h),o,g);return this.newUpdates&&(s=y.getLimit(e,s)),this.filterBySinceLimit(y,t,s,"timestamp",!0)}parseTrade(e,t=void 0){const i=this.safeString(e,"x")==="TRADE";if(!i)return super.parseTrade(e,t);const n=this.safeString2(e,"t","a"),r=this.safeInteger(e,"T"),a=this.safeFloat2(e,"L","p");let o=this.safeFloat(e,"q");i&&(o=this.safeFloat(e,"l",o));let d=this.safeFloat(e,"Y");d===void 0&&a!==void 0&&o!==void 0&&(d=a*o);const c=this.safeString(e,"s"),u=this.safeSymbol(c);let h=this.safeStringLower(e,"S"),l;const p=this.safeString(e,"i");"m"in e&&(h===void 0&&(h=e.m?"sell":"buy"),l=e.m?"maker":"taker");let m;const g=this.safeFloat(e,"n");if(g!==void 0){const b=this.safeString(e,"N"),w=this.safeCurrencyCode(b);m={cost:g,currency:w}}const y=this.safeStringLower(e,"o");return{info:e,timestamp:r,datetime:this.iso8601(r),symbol:u,id:n,order:p,type:y,takerOrMaker:l,side:h,price:a,amount:o,cost:d,fee:m}}handleTrade(e,t){const s=this.safeString(t,"s"),i=this.safeMarket(s),n=i.symbol,r=this.safeStringLower(t,"s"),a=this.safeString(t,"e"),o=r+"@"+a,d=this.parseTrade(t,i);let c=this.safeValue(this.trades,n);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new HU(u)}c.append(d),this.trades[n]=c,e.resolve(c,o)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const a=this.market(e).lowercaseId,o=this.timeframes[t],d="kline",c=a+"@"+d+"_"+o,u=this.safeValue(this.options,"watchOHLCV",{}),h=this.safeString(this.options,"defaultType","spot"),l=this.safeString2(u,"type","defaultType",h),p=this.safeString(n,"type",l),m=this.omit(n,"type"),g=this.urls.api.ws[p]+"/"+this.stream(p,c),y=this.requestId(g),b={method:"SUBSCRIBE",params:[c],id:y},w={id:y},S=await this.watch(g,c,this.extend(b,m),c,w);return this.newUpdates&&(i=S.getLimit(e,i)),this.filterBySinceLimit(S,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"s"),i=this.safeStringLower(t,"s"),n=this.safeString(t,"e"),r=this.safeValue(t,"k"),a=this.safeString(r,"i"),o=this.findTimeframe(a),d=i+"@"+n+"_"+a,c=[this.safeInteger(r,"t"),this.safeFloat(r,"o"),this.safeFloat(r,"h"),this.safeFloat(r,"l"),this.safeFloat(r,"c"),this.safeFloat(r,"v")],u=this.safeSymbol(s);this.ohlcvs[u]=this.safeValue(this.ohlcvs,u,{});let h=this.safeValue(this.ohlcvs[u],o);if(h===void 0){const l=this.safeInteger(this.options,"OHLCVLimit",1e3);h=new GU(l),this.ohlcvs[u][o]=h}h.append(c),e.resolve(h,d)}async watchTicker(e,t={}){await this.loadMarkets();const i=this.market(e).lowercaseId,n=this.safeValue(this.options,"watchTicker",{}),r=this.safeString(n,"name","ticker"),a=i+"@"+r,o=this.safeString2(this.options,"defaultType","spot"),d=this.safeString2(n,"type","defaultType",o),c=this.safeString(t,"type",d),u=this.omit(t,"type"),h=this.urls.api.ws[c]+"/"+this.stream(c,a),l=this.requestId(h),p={method:"SUBSCRIBE",params:[a],id:l},m={id:l};return await this.watch(h,a,this.extend(p,u),a,m)}handleTicker(e,t){let s=this.safeString(t,"e","bookTicker");s==="24hrTicker"&&(s="ticker");const n=this.safeStringLower(t,"s")+"@"+s;let r;const a=this.milliseconds();s==="bookTicker"?r=this.safeInteger(t,"E",a):r=this.safeInteger(t,"C",a);const o=this.safeString(t,"s"),d=this.safeSymbol(o),c=this.safeFloat(t,"c"),u={symbol:d,timestamp:r,datetime:this.iso8601(r),high:this.safeFloat(t,"h"),low:this.safeFloat(t,"l"),bid:this.safeFloat(t,"b"),bidVolume:this.safeFloat(t,"B"),ask:this.safeFloat(t,"a"),askVolume:this.safeFloat(t,"A"),vwap:this.safeFloat(t,"w"),open:this.safeFloat(t,"o"),close:c,last:c,previousClose:this.safeFloat(t,"x"),change:this.safeFloat(t,"p"),percentage:this.safeFloat(t,"P"),average:void 0,baseVolume:this.safeFloat(t,"v"),quoteVolume:this.safeFloat(t,"q"),info:t};this.tickers[d]=u,e.resolve(u,n)}async authenticate(e={}){const t=this.milliseconds();let s=this.safeString2(this.options,"defaultType","authenticate","spot");s=this.safeString(e,"type",s);const i=this.safeValue(this.options,s,{}),n=this.safeInteger(i,"lastAuthenticatedTime",0),r=this.safeInteger(this.options,"listenKeyRefreshRate",12e5),a=this.sum(r,1e4);if(t-n>a){let o="publicPostUserDataStream";s==="future"?o="fapiPrivatePostListenKey":s==="delivery"?o="dapiPrivatePostListenKey":s==="margin"&&(o="sapiPostUserDataStream");const d=await this[o]();this.options[s]=this.extend(i,{listenKey:this.safeString(d,"listenKey"),lastAuthenticatedTime:t}),this.delay(r,this.keepAliveListenKey,e)}}async keepAliveListenKey(e={}){let t=this.safeString2(this.options,"defaultType","authenticate","spot");t=this.safeString(e,"type",t);const s=this.safeValue(this.options,t,{}),i=this.safeString(s,"listenKey");if(i===void 0)return;let n="publicPutUserDataStream";t==="future"?n="fapiPrivatePutListenKey":t==="delivery"?n="dapiPrivatePutListenKey":t==="margin"&&(n="sapiPutUserDataStream");const r={listenKey:i},a=this.milliseconds(),o=this.omit(e,"type");try{await this[n](this.extend(r,o))}catch(u){const h=this.urls.api.ws[t]+"/"+this.options[t].listenKey,l=this.client(h),p=Object.keys(l.futures);for(let m=0;m<p.length;m++){const g=p[m];l.reject(u,g)}this.options[t]=this.extend(s,{listenKey:void 0,lastAuthenticatedTime:0});return}this.options[t]=this.extend(s,{listenKey:i,lastAuthenticatedTime:a});const d=Object.values(this.clients),c=this.safeInteger(this.options,"listenKeyRefreshRate",12e5);for(let u=0;u<d.length;u++){const h=d[u],l=Object.keys(h.subscriptions);for(let p=0;p<l.length;p++)if(l[p]===t)return this.delay(c,this.keepAliveListenKey,e)}}setBalanceCache(e,t){if(t in e.subscriptions)return;const s=this.safeValue(this.options,"watchBalance");if(this.safeValue(s,"fetchBalanceSnapshot",!1)){const n=t+":fetchBalanceSnapshot";n in e.futures||(e.future(n),this.spawn(this.loadBalanceSnapshot,e,n,t))}else this.balance[t]={}}async loadBalanceSnapshot(e,t,s){const i=await this.fetchBalance({type:s});this.balance[s]=this.extend(i,this.safeValue(this.balance,s,{})),e.futures[t].resolve(),e.resolve(this.balance[s],s+":balance")}async watchBalance(e={}){await this.loadMarkets(),await this.authenticate(e);const t=this.safeString(this.options,"defaultType","spot"),s=this.safeString(e,"type",t),i=this.urls.api.ws[s]+"/"+this.options[s].listenKey,n=this.client(i);this.setBalanceCache(n,s);const r=this.safeValue(this.options,"watchBalance"),a=this.safeValue(r,"fetchBalanceSnapshot",!1),o=this.safeValue(r,"awaitBalanceSnapshot",!0);a&&o&&await n.future(s+":fetchBalanceSnapshot");const d=s+":balance",c=void 0;return await this.watch(i,d,c,s)}handleBalance(e,t){const s=this.safeValue(this.options,"wallet","wb"),n=Object.keys(e.subscriptions)[0],r=n+":balance";if(this.balance[n].info=t,this.safeString(t,"e")==="balanceUpdate"){const d=this.safeString(t,"a"),c=this.safeCurrencyCode(d),u=this.account(),h=this.safeString(t,"d");if(c in this.balance[n]){let l=this.balance[n][c].free;typeof l!="string"&&(l=this.numberToString(l)),u.free=DU.stringAdd(l,h)}else u.free=h;this.balance[n][c]=u}else{t=this.safeValue(t,"a",t);const d=this.safeValue(t,"B");for(let c=0;c<d.length;c++){const u=d[c],h=this.safeString(u,"a"),l=this.safeCurrencyCode(h),p=this.account();p.free=this.safeString(u,"f"),p.used=this.safeString(u,"l"),p.total=this.safeString(u,s),this.balance[n][l]=p}}const o=this.safeInteger(t,"E");this.balance[n].timestamp=o,this.balance[n].datetime=this.iso8601(o),this.balance[n]=this.safeBalance(this.balance[n]),e.resolve(this.balance[n],r)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate(i);let n="orders",r;e!==void 0&&(r=this.market(e),e=r.symbol,n+=":"+e);let a;[a,i]=this.handleMarketTypeAndParams("watchOrders",r,i);const o=this.urls.api.ws[a]+"/"+this.options[a].listenKey,d=this.client(o);this.setBalanceCache(d,a);const c=void 0,u=await this.watch(o,n,c,a);return this.newUpdates&&(s=u.getLimit(e,s)),this.filterBySymbolSinceLimit(u,e,t,s,!0)}parseWsOrder(e,t=void 0){const s=this.safeString(e,"x"),i=this.safeString(e,"i"),n=this.safeString(e,"s"),r=this.safeSymbol(n);let a=this.safeInteger(e,"O");const o=this.safeInteger(e,"T");let d;s==="NEW"?a===void 0&&(a=o):s==="TRADE"&&(d=o);let c;const u=this.safeFloat(e,"n");if(u!==void 0&&u>0){const x=this.safeString(e,"N"),v=this.safeCurrencyCode(x);c={cost:u,currency:v}}const h=this.safeFloat(e,"p"),l=this.safeFloat(e,"q"),p=this.safeStringLower(e,"S"),m=this.safeStringLower(e,"o"),g=this.safeFloat(e,"z"),y=this.safeFloat(e,"Z");let b=l,w=this.safeFloat(e,"ap"),S=y;g!==void 0&&(S===void 0&&h!==void 0&&(S=g*h),l!==void 0&&(b=Math.max(l-g,0)),w===void 0&&y!==void 0&&g>0&&(w=y/g));const k=this.safeString(e,"X"),T=this.parseOrderStatus(k),I=void 0;let _=this.safeString(e,"C");(_===void 0||_.length===0)&&(_=this.safeString(e,"c"));const N=this.safeFloat2(e,"P","sp");let M=this.safeString(e,"f");return M==="GTX"&&(M="PO"),{info:e,symbol:r,id:i,clientOrderId:_,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:d,type:m,timeInForce:M,postOnly:void 0,side:p,price:h,stopPrice:N,amount:l,cost:S,average:w,filled:g,remaining:b,status:T,fee:c,trades:I}}handleOrderUpdate(e,t){this.safeString(t,"e")==="ORDER_TRADE_UPDATE"&&(t=this.safeValue(t,"o",t)),this.handleMyTrade(e,t),this.handleOrder(e,t)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate(i);const n=this.safeString2(this.options,"watchMyTrades","defaultType","spot"),r=this.safeString(i,"type",n),a=this.urls.api.ws[r]+"/"+this.options[r].listenKey;let o="myTrades";e!==void 0&&(o+=":"+e);const d=this.client(a);this.setBalanceCache(d,r);const c=void 0,u=await this.watch(a,o,c,r);return this.newUpdates&&(s=u.getLimit(e,s)),this.filterBySymbolSinceLimit(u,e,t,s,!0)}handleMyTrade(e,t){const s="myTrades";if(this.safeString(t,"x")==="TRADE"){const n=this.parseTrade(t),r=this.safeString(n,"order"),a=this.safeValue(n,"fee"),o=this.safeString(n,"symbol");if(r!==void 0&&a!==void 0&&o!==void 0){const u=this.orders;if(u!==void 0){const h=this.safeValue(u.hashmap,o,{}),l=this.safeValue(h,r);if(l!==void 0){const p=this.safeValue(l,"fees"),m=this.safeValue(l,"fee");if(p!==void 0){let y=!0;for(let b=0;b<p.length;b++){const w=p[b];if(w.currency===a.currency){const S=this.sum(a.cost,w.cost);l.fees[b].cost=parseFloat(this.currencyToPrecision(a.currency,S)),y=!1;break}}y&&l.fees.push(a)}else if(m!==void 0)if(m.currency===a.currency){const y=this.sum(m.cost,a.cost);l.fee.cost=parseFloat(this.currencyToPrecision(a.currency,y))}else m.currency===void 0?l.fee=a:(l.fees=[m,a],l.fee=void 0);else l.fee=a;const g=this.safeValue(l,"trades",[]);g.push(n),l.trades=g}}}if(this.myTrades===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new NT(u)}this.myTrades.append(n),e.resolve(this.myTrades,s);const c=s+":"+o;e.resolve(this.myTrades,c)}}handleOrder(e,t){const s="orders",i=this.parseWsOrder(t),n=this.safeString(i,"symbol"),r=this.safeString(i,"id");if(n!==void 0){if(this.orders===void 0){const u=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new NT(u)}const a=this.orders,o=this.safeValue(a.hashmap,n,{}),d=this.safeValue(o,r);if(d!==void 0){const u=this.safeValue(d,"fee");u!==void 0&&(i.fee=u);const h=this.safeValue(d,"fees");h!==void 0&&(i.fees=h),i.trades=this.safeValue(d,"trades"),i.timestamp=this.safeInteger(d,"timestamp"),i.datetime=this.safeString(d,"datetime")}a.append(i),e.resolve(this.orders,s);const c=s+":"+n;e.resolve(this.orders,c)}}handleMessage(e,t){const s={depthUpdate:this.handleOrderBook,trade:this.handleTrade,aggTrade:this.handleTrade,kline:this.handleOHLCV,"24hrTicker":this.handleTicker,bookTicker:this.handleTicker,outboundAccountPosition:this.handleBalance,balanceUpdate:this.handleBalance,ACCOUNT_UPDATE:this.handleBalance,executionReport:this.handleOrderUpdate,ORDER_TRADE_UPDATE:this.handleOrderUpdate},i=this.safeString(t,"e"),n=this.safeValue(s,i);if(n===void 0){if(this.safeString(t,"id")!==void 0)return this.handleSubscriptionStatus(e,t);i===void 0&&this.handleTicker(e,t)}else return n.call(this,e,t)}};const UU=Gl;var $U=class extends UU{describe(){return this.deepExtend(super.describe(),{id:"binancecoinm",name:"Binance COIN-M",urls:{logo:"https://user-images.githubusercontent.com/1294454/117738721-668c8d80-b205-11eb-8c49-3fad84c4a07f.jpg"},options:{defaultType:"delivery"}})}};const jU=Gl;var WU=class extends jU{describe(){return this.deepExtend(super.describe(),{id:"binanceus",name:"Binance US",countries:["US"],certified:!1,urls:{logo:"https://user-images.githubusercontent.com/1294454/65177307-217b7c80-da5f-11e9-876e-0b748ba0a358.jpg",api:{ws:{spot:"wss://stream.binance.us:9443/ws"},web:"https://www.binance.us",wapi:"https://api.binance.us/wapi/v3",public:"https://api.binance.us/api/v1",private:"https://api.binance.us/api/v3",v3:"https://api.binance.us/api/v3",v1:"https://api.binance.us/api/v1"},www:"https://www.binance.us",referral:"https://www.binance.us/?ref=35005074",doc:"https://github.com/binance-us/binance-official-api-docs",fees:"https://www.binance.us/en/fee/schedule"},options:{fetchCurrencies:!1,quoteOrderQty:!1},fees:{trading:{tierBased:!1,percentage:!0,taker:0,maker:0}}})}};const zU=Gl;var KU=class extends zU{describe(){return this.deepExtend(super.describe(),{id:"binanceusdm",name:"Binance USD\u24C8-M",urls:{logo:"https://user-images.githubusercontent.com/1294454/117738721-668c8d80-b205-11eb-8c49-3fad84c4a07f.jpg"},options:{defaultType:"future"}})}};const XU=_b;var YU=class extends XU{describe(){return this.deepExtend(super.describe(),{id:"bitcoincom",name:"bitcoin.com",countries:["KN"],urls:{logo:"https://user-images.githubusercontent.com/1294454/97296144-514fa300-1861-11eb-952b-3d55d492200b.jpg",api:{ws:"wss://api.fmfw.io/api/2/ws"}},fees:{trading:{maker:.15/100,taker:.2/100}}})}};const QU=T_,{ExchangeError:ZU,AuthenticationError:JU}=oe,{ArrayCache:e$,ArrayCacheBySymbolById:t$}=et;var s$=class extends QU{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchTickers:!1,watchOrderBook:!0,watchTrades:!0,watchBalance:!1,watchOHLCV:!1},urls:{api:{ws:{public:"wss://api-pub.bitfinex.com/ws/1",private:"wss://api.bitfinex.com/ws/1"}}},options:{watchOrderBook:{prec:"P0",freq:"F0"},ordersLimit:1e3}})}async subscribe(e,t,s={}){await this.loadMarkets();const n=this.market(t).id,r=this.urls.api.ws.public,a=e+":"+n,o={event:"subscribe",channel:e,symbol:n,messageHash:a};return await this.watch(r,a,this.deepExtend(o,s),a)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.subscribe("trades",e,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}async watchTicker(e,t={}){return await this.subscribe("ticker",e,t)}handleTrades(e,t,s){const i=this.safeValue(s,"channel"),n=this.safeString(s,"pair"),r=i+":"+n,a=this.safeInteger(this.options,"tradesLimit",1e3);if(n in this.markets_by_id){const o=this.markets_by_id[n],d=o.symbol,c=this.safeValue(t,1);let u=this.safeValue(this.trades,d);if(u===void 0&&(u=new e$(a),this.trades[d]=u),Array.isArray(c)){const h=this.parseTrades(c,o);for(let l=0;l<h.length;l++)u.append(h[l])}else{if(this.safeString(t,1)!=="tu")return;const l=this.parseTrade(t,o);u.append(l)}e.resolve(u,r)}return t}parseTrade(e,t=void 0){if(!Array.isArray(e))return super.parseTrade(e,t);const s=e.length,i=this.safeString(e,1);let n;i==="tu"&&(n=this.safeString(e,s-4));const r=this.safeTimestamp(e,s-3),a=this.safeFloat(e,s-2);let o=this.safeFloat(e,s-1),d;o!==void 0&&(d=o>0?"buy":"sell",o=Math.abs(o));let c;a!==void 0&&o!==void 0&&(c=a*o);const h=this.safeString(e,2).split("-");let l=this.safeString(h,1);l!==void 0&&(l=l.replace("t",""));const p=this.safeSymbol(l,t),m=void 0,g=void 0;return{info:e,timestamp:r,datetime:this.iso8601(r),symbol:p,id:n,order:g,type:void 0,takerOrMaker:m,side:d,price:a,amount:o,cost:c,fee:void 0}}handleTicker(e,t,s){const i=this.milliseconds(),n=this.safeString(s,"pair"),r=this.safeSymbol(n),o="ticker"+":"+n,d=this.safeFloat(t,7),c=this.safeFloat(t,5);let u;d!==void 0&&c!==void 0&&(u=d-c);const h={symbol:r,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(t,9),low:this.safeFloat(t,10),bid:this.safeFloat(t,1),bidVolume:void 0,ask:this.safeFloat(t,3),askVolume:void 0,vwap:void 0,open:u,close:d,last:d,previousClose:void 0,change:c,percentage:this.safeFloat(t,6),average:void 0,baseVolume:this.safeFloat(t,8),quoteVolume:void 0,info:t};this.tickers[r]=h,e.resolve(h,o)}async watchOrderBook(e,t=void 0,s={}){if(t!==void 0&&t!==25&&t!==100)throw new ZU(this.id+" watchOrderBook limit argument must be undefined, 25 or 100");const i=this.safeValue(this.options,"watchOrderBook",{}),n=this.safeString(i,"prec","P0"),r=this.safeString(i,"freq","F0"),a={prec:n,freq:r,len:t};return(await this.subscribe("book",e,this.deepExtend(a,s))).limit()}handleOrderBook(e,t,s){const i=this.safeString(s,"pair"),n=this.safeSymbol(i),a="book"+":"+i,d=this.safeString(s,"prec","P0")==="R0";if(Array.isArray(t[1])){const c=this.safeInteger(s,"len");d?this.orderbooks[n]=this.indexedOrderBook({},c):this.orderbooks[n]=this.countedOrderBook({},c);const u=this.orderbooks[n];if(d){const h=t[1];for(let l=0;l<h.length;l++){const p=h[l],m=this.safeString(p,0),g=this.safeFloat(p,1),y=p[2]<0?-p[2]:p[2],b=p[2]<0?"asks":"bids";u[b].store(g,y,m)}}else{const h=t[1];for(let l=0;l<h.length;l++){const p=h[l],m=p[2]<0?-p[2]:p[2],g=p[2]<0?"asks":"bids";u[g].store(p[0],m,p[1])}}e.resolve(u,a)}else{const c=this.orderbooks[n];if(d){const u=this.safeString(t,1),h=this.safeFloat(t,2),l=t[3]<0?-t[3]:t[3],p=t[3]<0?"asks":"bids",m=c[p],g=h>0?l:0;m.store(h,g,u)}else{const u=t[3]<0?-t[3]:t[3],h=t[3]<0?"asks":"bids";c[h].store(t[1],u,t[2])}e.resolve(c,a)}}handleHeartbeat(e,t){const s=this.safeString(t,"event");e.resolve(t,s)}handleSystemStatus(e,t){return t}handleSubscriptionStatus(e,t){const s=this.safeString(t,"chanId");return e.subscriptions[s]=t,t}async authenticate(e={}){const t=this.urls.api.ws.private,s=this.client(t),i=s.future("authenticated"),n="auth";if(this.safeValue(s.subscriptions,n)===void 0){const a=this.milliseconds(),o="AUTH"+a.toString(),d=this.hmac(this.encode(o),this.encode(this.secret),"sha384","hex"),c={apiKey:this.apiKey,authSig:d,authNonce:a,authPayload:o,event:n,filter:["trading","wallet"]};this.spawn(this.watch,t,n,c,1)}return await i}handleAuthenticationMessage(e,t){if(this.safeString(t,"status")==="OK")this.safeValue(e.futures,"authenticated").resolve(!0);else{const i=new JU(this.json(t));e.reject(i,"authenticated");const n=this.safeString(t,"event");n in e.subscriptions&&delete e.subscriptions[n]}}async watchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.urls.api.ws.private;return await this.authenticate(),await this.watch(i,e,void 0,1)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate(),e!==void 0&&(e=this.symbol(e));const n=this.urls.api.ws.private,r=await this.watch(n,"os",void 0,1);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySymbolSinceLimit(r,e,t,s,!0)}handleOrders(e,t,s){const i=this.safeValue(t,2,[]);if(this.safeString(t,1)==="os")for(let r=0;r<i.length;r++){const a=i[r];this.handleOrder(e,a)}else this.handleOrder(e,i);this.orders!==void 0&&e.resolve(this.orders,"os")}parseWsOrderStatus(e){const t={ACTIVE:"open",CANCELED:"canceled"};return this.safeString(t,e,e)}handleOrder(e,t){const s=this.safeString(t,0),i=this.safeString(t,1),n=this.safeSymbol(i);let r=this.safeFloat(t,2),a=this.safeFloat(t,3),o="buy";r<0&&(r=Math.abs(r),a=Math.abs(a),o="sell");let d=this.safeString(t,4);d.indexOf("LIMIT")>-1?d="limit":d.indexOf("MARKET")>-1&&(d="market");const c=this.parseWsOrderStatus(this.safeString(t,5)),u=this.safeFloat(t,6),h=this.safeString(t,8),l=this.parse8601(h),p={info:t,id:s,clientOrderId:void 0,timestamp:l,datetime:this.iso8601(l),lastTradeTimestamp:void 0,symbol:n,type:d,side:o,price:u,stopPrice:void 0,average:void 0,amount:r,remaining:a,filled:r-a,status:c,fee:void 0,cost:void 0,trades:void 0};if(this.orders===void 0){const g=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new t$(g)}return this.orders.append(p),e.resolve(p,s),p}handleMessage(e,t){if(Array.isArray(t)){const s=this.safeString(t,0);if(t[1]==="hb")return t;const i=this.safeValue(e.subscriptions,s,{}),n=this.safeString(i,"channel"),r=this.safeString(t,1),a={book:this.handleOrderBook,ticker:this.handleTicker,trades:this.handleTrades,os:this.handleOrders,on:this.handleOrders,oc:this.handleOrders},o=this.safeValue2(a,n,r);return o===void 0?t:o.call(this,e,t,i)}else{const s=this.safeString(t,"event");if(s!==void 0){const i={info:this.handleSystemStatus,subscribed:this.handleSubscriptionStatus,auth:this.handleAuthenticationMessage},n=this.safeValue(i,s);return n===void 0?t:n.call(this,e,t)}}}};const i$=O_,Cg=ke,{ExchangeError:n$,AuthenticationError:r$,InvalidNonce:a$}=oe,{ArrayCache:o$,ArrayCacheBySymbolById:ET,ArrayCacheByTimestamp:d$}=et;var c$=class extends i${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchTickers:!1,watchOrderBook:!0,watchTrades:!0,watchMyTrades:!0,watchBalance:!0,watchOHLCV:!0,watchOrders:!0},urls:{api:{ws:{public:"wss://api-pub.bitfinex.com/ws/2",private:"wss://api.bitfinex.com/ws/2"}}},options:{watchOrderBook:{prec:"P0",freq:"F0"},ordersLimit:1e3,checksum:!0}})}async subscribe(e,t,s={}){await this.loadMarkets();const n=this.market(t).id,r=this.urls.api.ws.public,a=this.client(r),o=e+":"+n,d={event:"subscribe",channel:e,symbol:n},c=await this.watch(r,o,this.deepExtend(d,s),o,{checksum:!1});return this.safeValue(this.options,"checksum",!0)&&!a.subscriptions[o].checksum&&e==="book"&&(a.subscriptions[o].checksum=!0,a.send({event:"conf",flags:131072})),c}async subscribePrivate(e){await this.loadMarkets(),await this.authenticate();const t=this.urls.api.ws.private;return await this.watch(t,e,void 0,1)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=this.timeframes[t],o="candles",d="trade:"+a+":"+r.id,c=o+":"+a+":"+r.id,u={event:"subscribe",channel:o,key:d},h=this.urls.api.ws.public,l=await this.watch(h,c,this.deepExtend(u,n),c);return this.newUpdates&&(i=l.getLimit(e,i)),this.filterBySinceLimit(l,s,i,0,!0)}handleOHLCV(e,t,s){const i=this.safeValue(t,1,[]);let n;const r=this.safeValue(i,0);Array.isArray(r)?n=i:n=[i];const a=this.safeValue(s,"channel"),o=this.safeString(s,"key"),d=o.split(":"),c=this.safeString(d,1);let u=o;u=u.replace("trade:",""),u=u.replace(c+":","");const h=this.safeMarket(u),l=this.findTimeframe(c),p=h.symbol,m=a+":"+c+":"+u;this.ohlcvs[p]=this.safeValue(this.ohlcvs,p,{});let g=this.safeValue(this.ohlcvs[p],l);if(g===void 0){const b=this.safeInteger(this.options,"OHLCVLimit",1e3);g=new d$(b),this.ohlcvs[p][l]=g}const y=n.length;for(let b=0;b<y;b++){const w=n[y-b-1],S=this.parseOHLCV(w,h);g.append(S)}e.resolve(g,m)}async watchTrades(e,t=void 0,s=void 0,i={}){const n=await this.subscribe("trades",e,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n="myTrade";if(e!==void 0){const a=this.market(e);n+=":"+a.id}const r=await this.subscribePrivate(n);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySymbolSinceLimit(r,e,t,s,!0)}async watchTicker(e,t={}){return await this.subscribe("ticker",e,t)}handleMyTrade(e,t){const s="myTrade",i=this.safeValue(t,2),n=this.parseWsTrade(i,!1),r=n.symbol,a=this.market(r),o=s+":"+a.id;if(this.myTrades===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new ET(c)}const d=this.myTrades;d.append(n),this.myTrades=d,e.resolve(d,s),e.resolve(d,o)}handleTrades(e,t,s){const i=this.safeValue(s,"channel"),n=this.safeString(s,"symbol"),r=this.safeMarket(n),a=i+":"+n,o=this.safeInteger(this.options,"tradesLimit",1e3),d=r.symbol;let c=this.safeValue(this.trades,d);c===void 0&&(c=new o$(o),this.trades[d]=c);const u=!0;if(t.length===2){const l=this.safeValue(t,1,[]);for(let p=0;p<l.length;p++){const m=this.parseWsTrade(l[p],u,r);c.append(m)}}else{if(this.safeString(t,1)==="tu")return;const p=this.safeValue(t,2,[]),m=this.parseWsTrade(p,u,r);c.append(m)}return e.resolve(c,a),t}parseWsTrade(e,t=!1,s=void 0){let i=t?void 0:this.safeString(e,1);s=this.safeMarket(i,s);const n=t?1:2,r=t?3:5,a=t?2:4;i=s.id;let o=this.safeString(e,6);o!==void 0&&(o.indexOf("LIMIT")>-1?o="limit":o.indexOf("MARKET")>-1&&(o="market"));const d=t?void 0:this.safeString(e,3),c=this.safeString(e,0),u=this.safeInteger(e,n),h=this.safeString(e,r),l=this.safeString(e,a),p=this.parseNumber(Cg.stringAbs(l));let m;p!==void 0&&(m=Cg.stringGt(l,"0")?"buy":"sell");const g=this.safeSymbol(i,s),y=this.safeString(e,9);let b;if(y!==void 0){const k=this.safeString(e,10),T=this.safeCurrencyCode(k);b={cost:y,currency:T}}const w=this.safeInteger(e,8);let S;return w!==void 0&&(S=w===-1?"taker":"maker"),this.safeTrade({info:e,timestamp:u,datetime:this.iso8601(u),symbol:g,id:c,order:d,type:o,takerOrMaker:S,side:m,price:h,amount:p,cost:void 0,fee:b},s)}handleTicker(e,t,s){const i=this.safeValue(t,1),n=this.safeString(s,"symbol"),r=this.safeMarket(n),a=this.safeSymbol(n),o=this.parseWsTicker(i,r),c="ticker"+":"+n;this.tickers[a]=o,e.resolve(o,c)}parseWsTicker(e,t=void 0){t=this.safeMarket(void 0,t);const s=t.symbol,i=this.safeString(e,6),n=this.safeString(e,4);return this.safeTicker({symbol:s,timestamp:void 0,datetime:void 0,high:this.safeString(e,8),low:this.safeString(e,9),bid:this.safeString(e,0),bidVolume:this.safeString(e,1),ask:this.safeString(e,2),askVolume:this.safeString(e,3),vwap:void 0,open:void 0,close:i,last:i,previousClose:void 0,change:n,percentage:this.safeString(e,5),average:void 0,baseVolume:this.safeString(e,7),quoteVolume:void 0,info:e},t)}async watchOrderBook(e,t=void 0,s={}){if(t!==void 0&&t!==25&&t!==100)throw new n$(this.id+" watchOrderBook limit argument must be undefined, 25 or 100");const i=this.safeValue(this.options,"watchOrderBook",{}),n=this.safeString(i,"prec","P0"),r=this.safeString(i,"freq","F0"),a={prec:n,freq:r};return t!==void 0&&(a.len=t),(await this.subscribe("book",e,this.deepExtend(a,s))).limit()}handleOrderBook(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeSymbol(i),a="book"+":"+i,d=this.safeString(s,"prec","P0")==="R0",c=this.safeString(t,0);let u=this.safeValue(this.orderbooks,n);if(u===void 0){const h=this.safeInteger(s,"len");if(d?this.orderbooks[n]=this.indexedOrderBook({},h):this.orderbooks[n]=this.countedOrderBook({},h),u=this.orderbooks[n],d){const l=t[1];for(let p=0;p<l.length;p++){const m=l[p],g=m[2]<0?-m[2]:m[2],y=m[2]<0?"asks":"bids",b=u[y],w=this.safeString(m,0),S=this.safeFloat(m,1);b.store(S,g,w)}}else{const l=t[1];for(let p=0;p<l.length;p++){const m=l[p],g=this.safeNumber(m,2),y=this.safeNumber(m,1),b=this.safeNumber(m,0),w=g<0?-g:g,S=g<0?"asks":"bids";u[S].store(b,w,y)}}e.resolve(u,a)}else{const h=t[1],l=this.orderbooks[n];if(d){const p=this.safeFloat(h,1),m=h[2]<0?-h[2]:h[2],g=h[2]<0?"asks":"bids",y=l[g],b=p>0?m:0;y.store(p,b,c)}else{const p=this.safeNumber(h,2),m=this.safeNumber(h,1),g=this.safeNumber(h,0),y=p<0?-p:p,b=p<0?"asks":"bids";l[b].store(g,y,m)}e.resolve(l,a)}}handleChecksum(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeSymbol(i),a="book"+":"+i,o=this.safeValue(this.orderbooks,n);if(o===void 0)return;const d=this.safeInteger(s,"len"),c=[],u=o.bids,h=o.asks;for(let g=0;g<d;g++)c.push(u[g][0]),c.push(u[g][1]),c.push(h[g][0]),c.push(-h[g][1]);const l=c.join(":"),p=this.crc32(l,!0);if(this.safeInteger(t,2)!==p){const g=new a$(this.id+" invalid checksum");e.reject(g,a)}}async watchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"wallet","exchange");e=this.omit(e,"wallet");const s="balance:"+t;return await this.subscribePrivate(s)}handleBalance(e,t,s){const i=this.safeValue(t,1);let n;i==="ws"?n=this.safeValue(t,2):n=[this.safeValue(t,2)];const r={};for(let o=0;o<n.length;o++){const d=n[o],c=this.safeString(d,1),u=this.safeCurrencyCode(c),h=this.parseWsBalance(d),l=this.safeString(d,0),p=this.safeValue(this.balance,l,{});p[u]=h,p.info=t,this.balance[l]=this.safeBalance(p),r[l]=!0}const a=Object.keys(r);for(let o=0;o<a.length;o++){const d=a[o],c="balance:"+d;e.resolve(this.balance[d],c)}}parseWsBalance(e){const t=this.safeString(e,2),s=this.safeString(e,4),i=this.account();return s!==void 0&&(i.free=s),i.total=t,i}handleSystemStatus(e,t){return t}handleSubscriptionStatus(e,t){const s=this.safeString(t,"chanId");return e.subscriptions[s]=t,t}async authenticate(e={}){const t=this.urls.api.ws.private,s=this.client(t),i=s.future("authenticated"),n="auth";if(this.safeValue(s.subscriptions,n)===void 0){const a=this.milliseconds(),o="AUTH"+a.toString(),d=this.hmac(this.encode(o),this.encode(this.secret),"sha384","hex"),c={apiKey:this.apiKey,authSig:d,authNonce:a,authPayload:o,event:n};this.spawn(this.watch,t,n,c,1)}return await i}handleAuthenticationMessage(e,t){if(this.safeString(t,"status")==="OK")this.safeValue(e.futures,"authenticated").resolve(!0);else{const i=new r$(this.json(t));e.reject(i,"authenticated");const n=this.safeString(t,"event");n in e.subscriptions&&delete e.subscriptions[n]}}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n="orders";if(e!==void 0){const a=this.market(e);n+=":"+a.id}const r=await this.subscribePrivate(n);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySymbolSinceLimit(r,e,t,s,!0)}handleOrders(e,t,s){const i=this.safeValue(t,2,[]),n=this.safeString(t,1);if(this.orders===void 0){const c=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new ET(c)}const r=this.orders,a={};if(n==="os"){if(i.length===0)return;for(let u=0;u<i.length;u++){const h=i[u],l=this.parseWsOrder(h),p=l.symbol;a[p]=!0,r.append(l)}}else{const c=this.parseWsOrder(i);r.append(c)}const o="orders";e.resolve(this.orders,o);const d=Object.keys(a);for(let c=0;c<d.length;c++){const u=d[c],h=this.safeMarket(u),l=o+":"+h.id;e.resolve(this.orders,l)}}parseWsOrderStatus(e){const t={ACTIVE:"open",CANCELED:"canceled",EXECUTED:"closed","PARTIALLY FILLED":"open"};return this.safeString(t,e,e)}parseWsOrder(e,t=void 0){const s=this.safeString(e,0),i=this.safeString(e,1),n=this.safeString(e,3),r=this.safeSymbol(n);t=this.safeMarket(r);let a=this.safeNumber(e,7),o="buy";a<0&&(a=Math.abs(a),o="sell");const d=Cg.stringAbs(this.safeString(e,6));let c=this.safeString(e,8);c.indexOf("LIMIT")>-1?c="limit":c.indexOf("MARKET")>-1&&(c="market");const h=this.safeString(e,13).split(" "),l=this.safeString(h,0),p=this.parseWsOrderStatus(l),m=this.safeString(e,16),g=this.safeInteger(e,4),y=this.safeString(e,17),b=this.omitZero(this.safeString(e,18));return this.safeOrder({info:e,id:s,clientOrderId:i,timestamp:g,datetime:this.iso8601(g),lastTradeTimestamp:void 0,symbol:r,type:c,side:o,price:m,stopPrice:b,average:y,amount:a,remaining:d,filled:void 0,status:p,fee:void 0,cost:void 0,trades:void 0},t)}handleMessage(e,t){const s=this.safeString(t,0);if(Array.isArray(t)){if(t[1]==="hb")return t;const i=this.safeValue(e.subscriptions,s,{}),n=this.safeString(i,"channel"),r=this.safeString(t,1),a={book:this.handleOrderBook,cs:this.handleChecksum,candles:this.handleOHLCV,ticker:this.handleTicker,trades:this.handleTrades},o={os:this.handleOrders,ou:this.handleOrders,on:this.handleOrders,oc:this.handleOrders,wu:this.handleBalance,ws:this.handleBalance,tu:this.handleMyTrade};let d;return s==="0"?d=this.safeValue(o,r):d=this.safeValue2(a,r,n),d===void 0?t:d.call(this,e,t,i)}else{const i=this.safeString(t,"event");if(i!==void 0){const n={info:this.handleSystemStatus,subscribed:this.handleSubscriptionStatus,auth:this.handleAuthenticationMessage},r=this.safeValue(n,i);return r===void 0?t:r.call(this,e,t)}}}};const u$=I_,{ArgumentsRequired:VT,AuthenticationError:f$}=oe,{ArrayCache:h$,ArrayCacheByTimestamp:l$,ArrayCacheBySymbolById:p$}=et;var m$=class extends u${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchOrderBook:!0,watchOrders:!0,watchTrades:!0,watchOHLCV:!0},urls:{api:{ws:{public:"wss://ws-manager-compress.{hostname}/api?protocol=1.1",private:"wss://ws-manager-compress.{hostname}/user?protocol=1.1"}}},options:{defaultType:"spot",watchOrderBook:{depth:"depth5"},ws:{inflate:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","45m":"45m","1h":"1H","2h":"2H","3h":"3H","4h":"4H","1d":"1D","1w":"1W","1M":"1M"}},streaming:{keepAlive:15e3}})}async subscribe(e,t,s={}){await this.loadMarkets();const i=this.market(t),n=this.implodeHostname(this.urls.api.ws.public),r=i.type+"/"+e+":"+i.id,a={op:"subscribe",args:[r]};return await this.watch(n,r,this.deepExtend(a,s),r)}async subscribePrivate(e,t,s={}){await this.loadMarkets();const i=this.market(t),n=this.implodeHostname(this.urls.api.ws.private),r=e+":"+i.id;await this.authenticate();const a={op:"subscribe",args:[r]};return await this.watch(n,r,this.deepExtend(a,s),r)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.subscribe("trade",e,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}async watchTicker(e,t={}){return await this.subscribe("ticker",e,t)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new VT(this.id+" watchOrders requires a symbol argument");await this.loadMarkets();const n=this.market(e);if(e=n.symbol,n.type!=="spot")throw new VT(this.id+" watchOrders supports spot markets only");const r="spot/user/order",a=await this.subscribePrivate(r,e,i);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySymbolSinceLimit(a,e,t,s,!0)}handleOrders(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]);if(i.length>0){const r=this.safeInteger(this.options,"ordersLimit",1e3);this.orders===void 0&&(this.orders=new p$(r));const a=this.orders,o=[];for(let d=0;d<i.length;d++){const c=this.parseWsOrder(i[d]);a.append(c);const u=c.symbol,h=this.market(u);o.push(h.id)}for(let d=0;d<o.length;d++){const c=s+":"+o[d];e.resolve(this.orders,c)}}}parseWsOrder(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeString(e,"order_id"),n=this.safeString(e,"clientOid"),r=this.safeString(e,"price"),a=this.safeString(e,"filled_size"),o=this.safeString(e,"size"),d=this.safeString(e,"type"),c=this.safeString(e,"state"),u=this.parseOrderStatusByType(t.type,c),h=this.safeInteger(e,"ms_t"),l=t.symbol,p=this.safeStringLower(e,"side");return this.safeOrder({info:e,symbol:l,id:i,clientOrderId:n,timestamp:void 0,datetime:void 0,lastTradeTimestamp:h,type:d,timeInForce:void 0,postOnly:void 0,side:p,price:r,stopPrice:void 0,amount:o,cost:void 0,average:void 0,filled:a,remaining:void 0,status:u,fee:void 0,trades:void 0},t)}handleTrade(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]),n=this.safeInteger(this.options,"tradesLimit",1e3);for(let r=0;r<i.length;r++){const a=this.parseTrade(i[r]),o=a.symbol,d=this.safeString(a.info,"symbol"),c=s+":"+d;let u=this.safeValue(this.trades,o);u===void 0&&(u=new h$(n),this.trades[o]=u),u.append(a),e.resolve(u,c)}return t}handleTicker(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]);for(let n=0;n<i.length;n++){const r=this.parseTicker(i[n]),a=r.symbol,o=this.safeString(r.info,"symbol"),d=s+":"+o;this.tickers[a]=r,e.resolve(r,d)}return t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets(),e=this.symbol(e);const r=this.safeValue(this.options,"timeframes",{}),o="kline"+this.safeString(r,t),d=await this.subscribe(o,e,n);return this.newUpdates&&(i=d.getLimit(e,i)),this.filterBySinceLimit(d,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]),n=s.split("/"),a=this.safeString(n,1).replace("kline",""),o=this.safeValue(this.options,"timeframes",{}),d=this.findTimeframe(a,o),u=this.parseTimeframe(d)*1e3;for(let h=0;h<i.length;h++){const l=this.safeString(i[h],"symbol"),p=this.safeValue(i[h],"candle"),m=this.safeMarket(l),g=m.symbol,y=this.parseOHLCV(p,m);y[0]=parseInt(y[0]/u)*u,this.ohlcvs[g]=this.safeValue(this.ohlcvs,g,{});let b=this.safeValue(this.ohlcvs[g],d);if(b===void 0){const S=this.safeInteger(this.options,"OHLCVLimit",1e3);b=new l$(S),this.ohlcvs[g][d]=b}b.append(y);const w=s+":"+l;e.resolve(b,w)}}async watchOrderBook(e,t=void 0,s={}){const i=this.safeValue(this.options,"watchOrderBook",{}),n=this.safeString(i,"depth","depth400");return(await this.subscribe(n,e,s)).limit()}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s){const i=this.safeValue(t,"asks",[]),n=this.safeValue(t,"bids",[]);this.handleDeltas(s.asks,i),this.handleDeltas(s.bids,n);const r=this.safeInteger(t,"ms_t"),a=this.safeString(t,"symbol"),o=this.safeSymbol(a);return s.symbol=o,s.timestamp=r,s.datetime=this.iso8601(r),s}handleOrderBook(e,t){const s=this.safeValue(t,"data",[]),i=this.safeString(t,"table"),n=i.split("/"),a=this.safeString(n,1).replace("depth",""),o=parseInt(a);for(let d=0;d<s.length;d++){const c=s[d],u=this.safeString(c,"symbol"),h=this.safeSymbol(u);let l=this.safeValue(this.orderbooks,h);l===void 0&&(l=this.orderBook({},o),this.orderbooks[h]=l),l.reset({}),this.handleOrderBookMessage(e,c,l);const p=i+":"+u;e.resolve(l,p)}return t}async authenticate(e={}){this.checkRequiredCredentials();const t=this.implodeHostname(this.urls.api.ws.private),s="login",i=this.client(t);let n=this.safeValue(i.subscriptions,s);if(n===void 0){n=i.future("authenticated");const r=this.milliseconds().toString(),a=this.uid,o="bitmart.WebSocket",d=r+"#"+a+"#"+o,c=this.hmac(this.encode(d),this.encode(this.secret),"sha256"),u={op:s,args:[this.apiKey,r,c]};this.spawn(this.watch,t,s,u,s,n)}return await n}handleSubscriptionStatus(e,t){return t}handleAuthenticate(e,t){return e.resolve(t,"authenticated"),t}handleErrorMessage(e,t){const s=this.safeString(t,"errorCode");try{if(s!==void 0){const i=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,i);const n=this.safeValue(t,"message");n!==void 0&&this.throwBroadlyMatchedException(this.exceptions.broad,n,i)}}catch(i){if(i instanceof f$){e.reject(i,"authenticated");const n="login";return n in e.subscriptions&&delete e.subscriptions[n],!1}}return t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;const s=this.safeString(t,"table");if(s===void 0){const i=this.safeString(t,"event");if(i!==void 0){const n={login:this.handleAuthenticate,subscribe:this.handleSubscriptionStatus},r=this.safeValue(n,i);return r===void 0?t:r.call(this,e,t)}}else{const i=s.split("/"),n=this.safeString(i,1),r={depth:this.handleOrderBook,depth5:this.handleOrderBook,depth400:this.handleOrderBook,ticker:this.handleTicker,trade:this.handleTrade};let a=this.safeValue(r,n);return n.indexOf("kline")>=0&&(a=this.handleOHLCV),this.safeString(i,2)==="order"&&(a=this.handleOrders),a===void 0?t:a.call(this,e,t)}}};const g$=x_,{AuthenticationError:y$,ExchangeError:qT,RateLimitExceeded:b$}=oe,{ArrayCache:w$,ArrayCacheByTimestamp:S$,ArrayCacheBySymbolById:LT}=et;var k$=class extends g${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0},urls:{test:{ws:"wss://testnet.bitmex.com/realtime"},api:{ws:"wss://www.bitmex.com/realtime"}},versions:{ws:"0.2.0"},options:{watchOrderBookLevel:"orderBookL2",tradesLimit:1e3,OHLCVLimit:1e3},exceptions:{ws:{exact:{},broad:{"Rate limit exceeded":b$}}}})}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),n="instrument"+":"+s.id,r=this.urls.api.ws,a={op:"subscribe",args:[n]};return await this.watch(r,n,this.extend(a,t),n)}handleTicker(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeValue(r,"symbol"),o=this.safeMarket(a),d=o.symbol,c=s+":"+a;let u=this.safeValue(this.tickers,d,{});const h=this.safeValue(u,"info",{});u=this.parseTicker(this.extend(h,r),o),this.tickers[d]=u,e.resolve(u,c)}return t}async watchBalance(e={}){await this.loadMarkets(),await this.authenticate();const t="margin",s=this.urls.api.ws,i={op:"subscribe",args:[t]};return await this.watch(s,t,this.extend(i,e),t)}handleBalance(e,t){const s=this.safeValue(t,"data"),i=this.parseBalance(s);this.balance=this.extend(this.balance,i);const n=this.safeString(t,"table");e.resolve(this.balance,n)}handleTrades(e,t){const s="trade",i=this.safeValue(t,"data",[]),n=this.groupBy(i,"symbol"),r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeMarket(o),c=s+":"+o,u=d.symbol,h=this.parseTrades(n[o],d);let l=this.safeValue(this.trades,u);if(l===void 0){const p=this.safeInteger(this.options,"tradesLimit",1e3);l=new w$(p),this.trades[u]=l}for(let p=0;p<h.length;p++)l.append(h[p]);e.resolve(l,c)}}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const a="trade"+":"+n.id,o=this.urls.api.ws,d={op:"subscribe",args:[a]},c=await this.watch(o,a,this.extend(d,i),a);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySinceLimit(c,t,s,"timestamp",!0)}async authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i=s.future("authenticated"),n="authKeyExpires";if(this.safeValue(s.subscriptions,n)===void 0)try{this.checkRequiredCredentials();const a=this.milliseconds(),o="GET/realtime"+a.toString(),d=this.hmac(this.encode(o),this.encode(this.secret)),c={op:n,args:[this.apiKey,a,d]};this.spawn(this.watch,t,n,c,n)}catch(a){s.reject(a,"authenticated"),n in s.subscriptions&&delete s.subscriptions[n]}return await i}handleAuthenticationMessage(e,t){if(this.safeValue(t,"success",!1))this.safeValue(e.futures,"authenticated").resolve(!0);else{const i=new y$(this.json(t));e.reject(i,"authenticated");const n="authKeyExpires";n in e.subscriptions&&delete e.subscriptions[n]}}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate();const n="order",r=n;let a=n;e!==void 0&&(e=this.symbol(e),a+=":"+e);const o=this.urls.api.ws,d={op:"subscribe",args:[r]},c=await this.watch(o,a,d,r);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}handleOrders(e,t){const s=this.safeValue(t,"data",[]),i="order",n=s.length;if(n>0){if(this.orders===void 0){const d=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new LT(d)}const r=this.orders,a={};for(let d=0;d<n;d++){const c=s[d],u=this.safeString(c,"orderID"),h=this.safeValue(r.hashmap,u);let l=c;h!==void 0&&(l=this.extend(h.info,c));const p=this.parseOrder(l);r.append(p);const m=p.symbol;a[m]=!0}e.resolve(this.orders,i);const o=Object.keys(a);for(let d=0;d<o.length;d++){const c=o[d];e.resolve(this.orders,i+":"+c)}}}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate();const n="execution",r=n;let a=n;e!==void 0&&(e=this.symbol(e),a+=":"+e);const o=this.urls.api.ws,d={op:"subscribe",args:[r]},c=await this.watch(o,a,d,r);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}handleMyTrades(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]),n=this.groupBy(i,"execType"),r=this.safeValue(n,"Trade",[]),a=this.parseTrades(r);if(this.myTrades===void 0){const h=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new LT(h)}const o=this.myTrades,d={};for(let h=0;h<a.length;h++){const l=a[h],p=l.symbol;o.append(l),d[p]=l}a.length>0&&e.resolve(o,s);const u=Object.keys(d);for(let h=0;h<u.length;h++)e.resolve(o,s+":"+u[h])}async watchOrderBook(e,t=void 0,s={}){let i;if(t===void 0)i=this.safeString(this.options,"watchOrderBookLevel","orderBookL2");else if(t===25)i="orderBookL2_25";else if(t===10)i="orderBookL10";else throw new qT(this.id+" watchOrderBook limit argument must be undefined (L2), 25 (L2) or 10 (L3)");await this.loadMarkets();const n=this.market(e),r=i+":"+n.id,a=this.urls.api.ws,o={op:"subscribe",args:[r]};return(await this.watch(a,r,this.deepExtend(o,s),r)).limit()}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const o="tradeBin"+this.timeframes[t]+":"+r.id,d=this.urls.api.ws,c={op:"subscribe",args:[o]},u=await this.watch(d,o,this.extend(c,n),o);return this.newUpdates&&(i=u.getLimit(e,i)),this.filterBySinceLimit(u,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"table"),i=s.replace("tradeBin",""),n=this.findTimeframe(i),r=this.parseTimeframe(n),a=this.safeValue(t,"data",[]),o={};for(let c=0;c<a.length;c++){const u=a[c],h=this.safeString(u,"symbol"),l=this.safeMarket(h),p=l.symbol,m=s+":"+l.id,g=[this.parse8601(this.safeString(u,"timestamp"))-r*1e3,this.safeFloat(u,"open"),this.safeFloat(u,"high"),this.safeFloat(u,"low"),this.safeFloat(u,"close"),this.safeFloat(u,"volume")];this.ohlcvs[p]=this.safeValue(this.ohlcvs,p,{});let y=this.safeValue(this.ohlcvs[p],n);if(y===void 0){const b=this.safeInteger(this.options,"OHLCVLimit",1e3);y=new S$(b),this.ohlcvs[p][n]=y}y.append(g),o[m]=y}const d=Object.keys(o);for(let c=0;c<d.length;c++){const u=d[c];e.resolve(o[u],u)}}async watchHeartbeat(e={}){await this.loadMarkets();const t="heartbeat",s=this.urls.api.ws;return await this.watch(s,t)}handleOrderBook(e,t){const s=this.safeString(t,"action"),i=this.safeString(t,"table"),n=this.safeValue(t,"data",[]);if(s==="partial"){const r=this.safeValue(t,"filter",{}),a=this.safeValue(r,"symbol"),d=this.safeMarket(a).symbol;i==="orderBookL2"?this.orderbooks[d]=this.indexedOrderBook():i==="orderBookL2_25"?this.orderbooks[d]=this.indexedOrderBook({},25):i==="orderBook10"&&(this.orderbooks[d]=this.indexedOrderBook({},10));const c=this.orderbooks[d];for(let h=0;h<n.length;h++){const l=this.safeFloat(n[h],"price"),p=this.safeFloat(n[h],"size"),m=this.safeString(n[h],"id");let g=this.safeString(n[h],"side");g=g==="Buy"?"bids":"asks",c[g].store(l,p,m)}const u=i+":"+a;e.resolve(c,u)}else{const r={};for(let o=0;o<n.length;o++){const d=this.safeValue(n[o],"symbol");d in r||(r[d]=0),r[d]=this.sum(r,1);const u=this.safeMarket(d).symbol,h=this.orderbooks[u],l=this.safeFloat(n[o],"price"),p=this.safeFloat(n[o],"size",0),m=this.safeString(n[o],"id");let g=this.safeString(n[o],"side");g=g==="Buy"?"bids":"asks",h[g].store(l,p,m)}const a=Object.keys(r);for(let o=0;o<a.length;o++){const d=a[o],c=i+":"+d,h=this.safeMarket(d).symbol,l=this.orderbooks[h];e.resolve(l,c)}}}handleSystemStatus(e,t){return t}handleSubscriptionStatus(e,t){return t}handleErrorMessage(e,t){const s=this.safeValue(t,"error");if(s!==void 0){const i=this.safeValue(t,"request",{}),n=this.safeString(i,"args",[]);if(n.length>0){const a=n[0],o=this.exceptions.ws.broad,d=this.findBroadlyMatchedKey(o,s);let c;return d===void 0?c=new qT(s):c=new o[d](s),e.reject(c,a),!1}}return!0}handleMessage(e,t){if(this.handleErrorMessage(e,t)){const s=this.safeString(t,"table"),i={orderBookL2:this.handleOrderBook,orderBookL2_25:this.handleOrderBook,orderBook10:this.handleOrderBook,instrument:this.handleTicker,trade:this.handleTrades,tradeBin1m:this.handleOHLCV,tradeBin5m:this.handleOHLCV,tradeBin1h:this.handleOHLCV,tradeBin1d:this.handleOHLCV,order:this.handleOrders,execution:this.handleMyTrades,margin:this.handleBalance},n=this.safeValue(i,s);if(n===void 0){const r=this.safeValue(t,"request",{});return this.safeValue(r,"op")==="authKeyExpires"?this.handleAuthenticationMessage.call(this,e,t):t}else return n.call(this,e,t)}}};const v$=__,{ExchangeError:T$}=oe,{ArrayCache:O$}=et;var I$=class extends v${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!1,watchOHLCV:!1,watchOrderBook:!0,watchOrders:!1,watchTicker:!0,watchTickers:!1,watchTrades:!0},urls:{ws:{public:"wss://stream.bitopro.com:9443/ws/v1/pub",private:"wss://stream.bitopro.com:9443/ws/v1/pub/auth"}},requiredCredentials:{apiKey:!0,secret:!0,login:!0},options:{tradesLimit:1e3,ordersLimit:1e3,ws:{options:{headers:{}}}}})}async watchPublic(e,t,s){const i=this.urls.ws.public+"/"+e+"/"+s;return await this.watch(i,t,void 0,t)}async watchOrderBook(e,t=void 0,s={}){if(t!==void 0&&t!==5&&t!==10&&t!==20&&t!==50&&t!==100&&t!==500&&t!==1e3)throw new T$(this.id+" watchOrderBook limit argument must be undefined, 5, 10, 20, 50, 100, 500 or 1000");await this.loadMarkets();const i=this.market(e);e=i.symbol;const n="ORDER_BOOK:"+e;let r;return t===void 0?r=i.id:r=i.id+":"+t,(await this.watchPublic("order-books",n,r)).limit()}handleOrderBook(e,t){const s=this.safeString(t,"pair"),n=this.safeMarket(s,void 0,"_").symbol,a=this.safeString(t,"event")+":"+n;let o=this.safeValue(this.orderbooks,n);o===void 0&&(o=this.orderBook({}));const d=this.safeInteger(t,"timestamp"),c=this.parseOrderBook(t,n,d,"bids","asks","price","amount");o.reset(c),e.resolve(o,a)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="TRADE:"+e,a=await this.watchPublic("trades",r,n.id,s);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySinceLimit(a,t,s,"timestamp",!0)}handleTrade(e,t){const s=this.safeString(t,"pair"),i=this.safeMarket(s,void 0,"_"),n=i.symbol,a=this.safeString(t,"event")+":"+n,o=this.safeValue(t,"data",[]),d=this.parseTrades(o,i);let c=this.safeValue(this.trades,n);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new O$(u)}for(let u=0;u<d.length;u++)c.append(d[u]);this.trades[n]=c,e.resolve(c,a)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i="TICKER:"+e;return await this.watchPublic("tickers",i,s.id)}handleTicker(e,t){const s=this.safeString(t,"pair"),n=this.safeMarket(s,void 0,"_").symbol,a=this.safeString(t,"event")+":"+n,o=this.parseTicker(t),d=this.safeInteger(t,"timestamp"),c=this.safeString(t,"datetime");o.timestamp=d,o.datetime=c,this.tickers[n]=o,e.resolve(o,a)}authenticate(e){if(this.clients!==void 0&&e in this.clients)return;this.checkRequiredCredentials();const t=this.milliseconds(),s=this.json({nonce:t,identity:this.login}),i=this.stringToBase64(s),n=this.hmac(i,this.encode(this.secret),"sha384"),r={ws:{options:{headers:{}}}};this.options=this.extend(r,this.options);const a=this.options.ws.options.headers;this.options.ws.options.headers={"X-BITOPRO-API":"ccxt","X-BITOPRO-APIKEY":this.apiKey,"X-BITOPRO-PAYLOAD":i,"X-BITOPRO-SIGNATURE":n},this.client(e),this.options.ws.options.headers=a}async watchBalance(e={}){this.checkRequiredCredentials(),await this.loadMarkets();const t="ACCOUNT_BALANCE",s=this.urls.ws.private+"/account-balance";return this.authenticate(s),await this.watch(s,t,void 0,t)}handleBalance(e,t){const s=this.safeString(t,"event"),i=this.safeValue(t,"data"),n=Object.keys(i),r={};for(let a=0;a<n.length;a++){const o=this.safeString(n,a),d=this.safeValue(i,o),c=this.safeString(d,"currency"),u=this.safeCurrencyCode(c),h=this.account();h.free=this.safeString(d,"available"),h.total=this.safeString(d,"amount"),r[u]=h}this.balance=this.safeBalance(r),e.resolve(this.balance,s)}handleMessage(e,t){const s={TRADE:this.handleTrade,TICKER:this.handleTicker,ORDER_BOOK:this.handleOrderBook,ACCOUNT_BALANCE:this.handleBalance},i=this.safeString(t,"event"),n=this.safeValue(s,i);return n===void 0?t:n.call(this,e,t)}};const x$=C_,{ArgumentsRequired:_$,AuthenticationError:C$}=oe,{ArrayCache:M$,ArrayCacheBySymbolById:P$}=et;var A$=class extends x${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchOrders:!0,watchTrades:!0,watchOHLCV:!1,watchTicker:!1,watchTickers:!1},urls:{api:{ws:"wss://ws.bitstamp.net"}},options:{expiresIn:"",userId:"",wsSessionToken:"",watchOrderBook:{type:"order_book"},tradesLimit:1e3,OHLCVLimit:1e3},exceptions:{exact:{4009:C$}}})}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n=this.safeValue(this.options,"watchOrderBook",{}),r=this.safeString(n,"type","order_book"),a=r+"_"+i.id,o=this.urls.api.ws,d={event:"bts:subscribe",data:{channel:a}},c={messageHash:a,type:r,symbol:e,method:this.handleOrderBookSubscription,limit:t,params:s},u=this.extend(d,s);return(await this.watch(o,a,u,a,c)).limit()}async fetchOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit"),r=this.safeValue(s,"params"),a=this.safeString(s,"messageHash"),o=await this.fetchOrderBook(i,n,r),d=this.safeValue(this.orderbooks,i);if(d!==void 0){d.reset(o);const c=d.cache;for(let u=0;u<c.length;u++){const h=c[u];this.handleOrderBookMessage(e,h,d)}this.orderbooks[i]=d,e.resolve(d,a)}}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1),n=this.safeString(t,2);n===void 0?e.store(s,i):e.store(s,i,n)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s,i=void 0){const n=this.safeValue(t,"data",{}),r=this.safeInteger(n,"microtimestamp");if(i!==void 0&&r<=i)return s;this.handleDeltas(s.asks,this.safeValue(n,"asks",[])),this.handleDeltas(s.bids,this.safeValue(n,"bids",[])),s.nonce=r;const a=parseInt(r/1e3);return s.timestamp=a,s.datetime=this.iso8601(a),s}handleOrderBook(e,t){const s=this.safeString(t,"channel"),i=this.safeValue(e.subscriptions,s),n=this.safeString(i,"symbol"),r=this.safeString(i,"type"),a=this.safeValue(this.orderbooks,n);if(a===void 0)return t;if(r==="order_book")a.reset({}),this.handleOrderBookMessage(e,t,a),e.resolve(a,s);else if(r==="detail_order_book")a.reset({}),this.handleOrderBookMessage(e,t,a),e.resolve(a,s);else if(r==="diff_order_book"){const o=this.safeInteger(a,"nonce");if(o===void 0)a.cache.push(t);else try{this.handleOrderBookMessage(e,t,a,o),e.resolve(a,s)}catch(d){n in this.orderbooks&&delete this.orderbooks[n],s in e.subscriptions&&delete e.subscriptions[s],e.reject(d,s)}}}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r=this.safeValue(this.options,"watchTrades",{}),a=this.safeString(r,"type","live_trades"),o=a+"_"+n.id,d=this.urls.api.ws,c={event:"bts:subscribe",data:{channel:o}},u={messageHash:o,type:a,symbol:e,limit:s,params:i},h=this.extend(c,i),l=await this.watch(d,o,h,o,u);return this.newUpdates&&(s=l.getLimit(e,s)),this.filterBySinceLimit(l,t,s,"timestamp",!0)}parseTrade(e,t=void 0){const s=this.safeInteger(e,"microtimestamp");if(s===void 0)return super.parseTrade(e,t);const i=this.safeString(e,"id"),n=parseInt(s/1e3),r=this.safeFloat(e,"price"),a=this.safeFloat(e,"amount");let o;r!==void 0&&a!==void 0&&(o=r*a);let d;const c=this.safeString(e,"s");c in this.markets_by_id&&(t=this.markets_by_id[c]),d===void 0&&t!==void 0&&(d=t.symbol);let u=this.safeInteger(e,"type");return u=u===0?"buy":"sell",{info:e,timestamp:n,datetime:this.iso8601(n),symbol:d,id:i,order:void 0,type:void 0,takerOrMaker:void 0,side:u,price:r,amount:a,cost:o,fee:void 0}}handleTrade(e,t){const s=this.safeString(t,"channel"),i=this.safeValue(t,"data"),n=this.safeValue(e.subscriptions,s),r=this.safeString(n,"symbol"),a=this.market(r),o=this.parseTrade(i,a);let d=this.safeValue(this.trades,r);if(d===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);d=new M$(c),this.trades[r]=d}d.append(o),e.resolve(d,s)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new _$(this.id+" watchOrders requires a symbol argument");await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="private-my_orders",a=r+"_"+n.id,o={symbol:e,limit:s,type:r,params:i},d=await this.subscribePrivate(o,a,i);return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySinceLimit(d,t,s,"timestamp",!0)}handleOrders(e,t){const s=this.safeString(t,"channel"),i=this.safeValue(t,"data",{}),n=this.safeInteger(this.options,"ordersLimit",1e3);this.orders===void 0&&(this.orders=new P$(n));const r=this.orders,a=this.safeValue(e.subscriptions,s),o=this.safeString(a,"symbol"),d=this.market(o),c=this.parseWsOrder(i,d);r.append(c),e.resolve(this.orders,s)}parseWsOrder(e,t=void 0){const s=this.safeString(e,"id_str"),i=this.safeStringLower(e,"order_type"),n=this.safeString(e,"price_str"),r=this.safeString(e,"amount_str"),a=i==="1"?"sell":"buy",o=this.safeIntegerProduct(e,"datetime",1e3);t=this.safeMarket(void 0,t);const d=t.symbol;return this.safeOrder({info:e,symbol:d,id:s,clientOrderId:void 0,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:void 0,type:void 0,timeInForce:void 0,postOnly:void 0,side:a,price:n,stopPrice:void 0,amount:r,cost:void 0,average:void 0,filled:void 0,remaining:void 0,status:void 0,fee:void 0,trades:void 0},t)}handleOrderBookSubscription(e,t,s){const i=this.safeString(s,"type"),n=this.safeString(s,"symbol");if(n in this.orderbooks&&delete this.orderbooks[n],i==="order_book"){const r=this.safeInteger(s,"limit",100);this.orderbooks[n]=this.orderBook({},r)}else if(i==="detail_order_book"){const r=this.safeInteger(s,"limit",100);this.orderbooks[n]=this.indexedOrderBook({},r)}else if(i==="diff_order_book"){const r=this.safeInteger(s,"limit");this.orderbooks[n]=this.orderBook({},r),this.spawn(this.fetchOrderBookSnapshot,e,t,s)}}handleSubscriptionStatus(e,t){const s=this.safeString(t,"channel"),i=this.safeValue(e.subscriptions,s,{}),n=this.safeValue(i,"method");return n!==void 0&&n.call(this,e,t,i),t}handleSubject(e,t){const s=this.safeString(t,"channel"),i=this.safeValue(e.subscriptions,s),n=this.safeString(i,"type"),r={live_trades:this.handleTrade,order_book:this.handleOrderBook,detail_order_book:this.handleOrderBook,diff_order_book:this.handleOrderBook,"private-my_orders":this.handleOrders},a=this.safeValue(r,n);return a===void 0?t:a.call(this,e,t)}handleErrorMessage(e,t){if(this.safeString(t,"event")==="bts:error"){const i=this.id+" "+this.json(t),n=this.safeValue(t,"data",{}),r=this.safeNumber(n,"code");this.throwExactlyMatchedException(this.exceptions.exact,r,i)}return t}handleMessage(e,t){return this.handleErrorMessage(e,t)?this.safeString(t,"event")==="bts:subscription_succeeded"?this.handleSubscriptionStatus(e,t):this.handleSubject(e,t):void 0}async authenticate(e={}){this.checkRequiredCredentials();const t=this.milliseconds(),s=this.safeInteger(this.options,"expiresIn");if(t>s){const i=await this.privatePostWebsocketsToken(e),n=this.safeString(i,"token");if(n!==void 0){const r=this.safeNumber(i,"user_id"),a=this.safeIntegerProduct(i,"valid_sec",1e3);return this.options.expiresIn=this.sum(t,a),this.options.userId=r,this.options.wsSessionToken=n,i}}}async subscribePrivate(e,t,s={}){const i=this.urls.api.ws;await this.authenticate(),t+="-"+this.options.userId;const n={event:"bts:subscribe",data:{channel:t,auth:this.options.wsSessionToken}};return e.messageHash=t,await this.watch(i,t,this.extend(n,s),t,e)}};const B$=M_,{InvalidNonce:N$,BadRequest:E$}=oe,{ArrayCache:V$,ArrayCacheByTimestamp:q$,ArrayCacheBySymbolById:RT}=et;var L$=class extends B${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchHeartbeat:!0,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0},urls:{api:{ws:"wss://socket-v3.bittrex.com/signalr/connect",signalr:"https://socket-v3.bittrex.com/signalr"}},api:{signalr:{get:["negotiate","start"]}},options:{tradesLimit:1e3,hub:"c3",I:this.milliseconds()}})}getSignalRUrl(e){const t=this.safeString(e.response,"ConnectionToken"),s=this.extend(e.request,{connectionToken:t});return this.urls.api.ws+"?"+this.urlencode(s)}makeRequest(e,t,s){return{H:this.safeString(this.options,"hub","c3"),M:t,A:s,I:e}}makeRequestToSubscribe(e,t){const s="Subscribe";return this.makeRequest(e,s,t)}makeRequestToAuthenticate(e){const t=this.milliseconds(),s=this.uuid(),i=t.toString()+s,n=this.hmac(this.encode(i),this.encode(this.secret),"sha512"),r=[this.apiKey,t,s,n],a="Authenticate";return this.makeRequest(e,a,r)}requestId(){const e=this.sum(this.safeInteger(this.options,"I",0),1);return this.options.I=e,e}async sendRequestToSubscribe(e,t,s,i={}){const n=[t],r=this.requestId().toString(),a=this.makeRequestToSubscribe(r,[n]);s=this.extend({id:r,negotiation:e},s);const o=this.getSignalRUrl(e);return await this.watch(o,t,a,t,s)}async authenticate(e={}){await this.loadMarkets();const t=await this.negotiate();return await this.sendRequestToAuthenticate(t,!1,e)}async sendRequestToAuthenticate(e,t=!1,s={}){const i=this.getSignalRUrl(e),n=this.client(i),r="authenticate";let a=this.safeValue(n.subscriptions,r);if(a===void 0||t){a=n.future(r),n.subscriptions[r]=a;const o=this.requestId().toString(),d=this.makeRequestToAuthenticate(o),c={id:o,params:s,negotiation:e,method:this.handleAuthenticate};this.spawn(this.watch,i,r,d,o,c)}return await a}async sendAuthenticatedRequestToSubscribe(e,t,s={}){const i=this.safeValue(e,"negotiation"),n={params:s};return await this.sendRequestToSubscribe(i,t,n,s)}handleAuthenticate(e,t,s){const i=this.safeString(s,"id");i in e.subscriptions&&delete e.subscriptions[i],e.resolve(s,"authenticate")}async handleAuthenticationExpiringHelper(){const e=await this.negotiate();return await this.sendRequestToAuthenticate(e,!0)}handleAuthenticationExpiring(e,t){this.spawn(this.handleAuthenticationExpiringHelper)}createSignalRQuery(e={}){const s=[{name:this.safeString(this.options,"hub","c3")}],i=this.milliseconds();return this.extend({transport:"webSockets",connectionData:this.json(s),clientProtocol:1.5,_:i,tid:this.sum(i%10,1)},e)}async negotiate(e={}){const t=this.client(this.urls.api.ws),s="negotiate";let i=this.safeValue(t.subscriptions,s);if(i===void 0){i=t.future(s),t.subscriptions[s]=i;const n=this.createSignalRQuery(e),r=await this.signalrGetNegotiate(this.extend(n,e)),a={request:n,response:r};t.resolve(a,s)}return await i}async start(e,t={}){const s=this.safeString(e.response,"ConnectionToken"),i=this.createSignalRQuery(this.extend(e.request,{connectionToken:s}));return await this.signalrGetStart(i)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),e!==void 0&&(e=this.symbol(e));const n=await this.authenticate(),r=await this.subscribeToOrders(n,i);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySymbolSinceLimit(r,e,t,s,!0)}async subscribeToOrders(e,t={}){const s="order";return await this.sendAuthenticatedRequestToSubscribe(e,s,t)}handleOrder(e,t){const s=this.safeValue(t,"delta",{}),i=this.parseOrder(s);if(this.orders===void 0){const a=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new RT(a)}this.orders.append(i);const r="order";e.resolve(this.orders,r)}async watchBalance(e={}){await this.loadMarkets();const t=await this.authenticate();return await this.subscribeToBalance(t,e)}async subscribeToBalance(e,t={}){const s="balance";return await this.sendAuthenticatedRequestToSubscribe(e,s,t)}handleBalance(e,t){const s=this.safeValue(t,"delta",{}),i=this.safeString(s,"currencySymbol"),n=this.safeCurrencyCode(i),r=this.account();r.free=this.safeString(s,"available"),r.total=this.safeString(s,"total"),this.balance[n]=r,this.balance=this.safeBalance(this.balance);const a="balance";e.resolve(this.balance,a)}async watchHeartbeat(e={}){await this.loadMarkets();const t=await this.negotiate();return await this.subscribeToHeartbeat(t,e)}async subscribeToHeartbeat(e,t={}){await this.loadMarkets();const s=this.getSignalRUrl(e),i=this.milliseconds().toString(),n="heartbeat",r=[n],a=this.makeRequestToSubscribe(i,[r]),o={id:i,params:t,negotiation:e};return await this.watch(s,n,a,n,o)}handleHeartbeat(e,t){e.resolve(t,"heartbeat")}async watchTicker(e,t={}){await this.loadMarkets();const s=await this.negotiate();return await this.subscribeToTicker(s,e,t)}async subscribeToTicker(e,t,s={}){await this.loadMarkets();const i=this.market(t);t=i.symbol;const r="ticker"+"_"+i.id,a={marketId:i.id,symbol:t,params:s};return await this.sendRequestToSubscribe(e,r,a)}handleTicker(e,t){const s=this.parseTicker(t),i=s.symbol,n=this.market(i);this.tickers[i]=s;const a="ticker"+"_"+n.id;e.resolve(s,a)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets(),e=this.symbol(e);const r=await this.negotiate(),a=await this.subscribeToOHLCV(r,e,t,n);return this.newUpdates&&(i=a.getLimit(e,i)),this.filterBySinceLimit(a,s,i,0,!0)}async subscribeToOHLCV(e,t,s="1m",i={}){await this.loadMarkets();const n=this.market(t),r=this.timeframes[s],o="candle"+"_"+n.id+"_"+r,d={symbol:t,timeframe:s,messageHash:o,params:i};return await this.sendRequestToSubscribe(e,o,d)}handleOHLCV(e,t){const s="candle",i=this.safeString(t,"marketSymbol"),n=this.safeSymbol(i,void 0,"-"),r=this.safeString(t,"interval"),a=s+"_"+i+"_"+r,o=this.findTimeframe(r),d=this.safeValue(t,"delta",{}),c=this.parseOHLCV(d);this.ohlcvs[n]=this.safeValue(this.ohlcvs,n,{});let u=this.safeValue(this.ohlcvs[n],o);if(u===void 0){const h=this.safeInteger(this.options,"OHLCVLimit",1e3);u=new q$(h),this.ohlcvs[n][o]=u}u.append(c),e.resolve(u,a)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.negotiate(),r=await this.subscribeToTrades(n,e,i);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySinceLimit(r,t,s,"timestamp",!0)}async subscribeToTrades(e,t,s={}){await this.loadMarkets();const i=this.market(t),r="trade"+"_"+i.id,a={symbol:t,messageHash:r,params:s};return await this.sendRequestToSubscribe(e,r,a)}handleTrades(e,t){const s=this.safeValue(t,"deltas",[]),i=this.safeString(t,"marketSymbol"),n=this.safeSymbol(i,void 0,"-"),r=this.market(n),o="trade"+"_"+i;let d=this.safeValue(this.trades,n);if(d===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);d=new V$(u)}const c=this.parseTrades(s,r);for(let u=0;u<c.length;u++)d.append(c[u]);this.trades[n]=d,e.resolve(d,o)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.authenticate(),r=await this.subscribeToMyTrades(n,i);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySymbolSinceLimit(r,e,t,s,!0)}async subscribeToMyTrades(e,t={}){const s="execution";return await this.sendAuthenticatedRequestToSubscribe(e,s,t)}handleMyTrades(e,t){const s=this.safeValue(t,"deltas",{}),i=this.parseTrades(s);let n=this.myTrades;if(n===void 0){const a=this.safeInteger(this.options,"tradesLimit",1e3);n=new RT(a),this.myTrades=n}for(let a=0;a<i.length;a++)n.append(i[a]);const r="execution";e.resolve(n,r)}async watchOrderBook(e,t=void 0,s={}){if(t=t===void 0?25:t,t!==1&&t!==25&&t!==500)throw new E$(this.id+" watchOrderBook() limit argument must be undefined, 1, 25 or 500, default is 25");await this.loadMarkets(),e=this.symbol(e);const i=await this.negotiate();return(await this.subscribeToOrderBook(i,e,t,s)).limit()}async subscribeToOrderBook(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.market(t),a="orderbook"+"_"+n.id+"_"+s.toString(),o={symbol:t,messageHash:a,method:this.handleSubscribeToOrderBook,limit:s,params:i};return await this.sendRequestToSubscribe(e,a,o)}async fetchOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit"),r=this.safeString(s,"messageHash");try{const a=await this.fetchOrderBook(i,n),o=this.orderbooks[i],d=o.cache,c=this.safeValue(d,0,{}),u=this.safeInteger(c,"sequence"),h=this.safeInteger(a,"nonce");if(u!==void 0&&h<u){const l=this.safeValue(this.options,"fetchOrderBookSnapshot",{}),p=this.safeInteger(l,"maxAttempts",3);let m=this.safeInteger(s,"numAttempts",0);if(m<p)r in e.subscriptions&&(m=this.sum(m,1),s.numAttempts=m,e.subscriptions[r]=s,this.spawn(this.fetchOrderBookSnapshot,e,t,s));else throw new N$(this.id+" failed to synchronize WebSocket feed with the snapshot for symbol "+i+" in "+p.toString()+" attempts")}else{o.reset(a);for(let l=0;l<d.length;l++){const p=d[l];this.handleOrderBookMessage(e,p,o)}this.orderbooks[i]=o,e.resolve(o,r)}}catch(a){e.reject(a,r)}}handleSubscribeToOrderBook(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit");i in this.orderbooks&&delete this.orderbooks[i],this.orderbooks[i]=this.orderBook({},n),this.spawn(this.fetchOrderBookSnapshot,e,t,s)}handleDelta(e,t){const s=this.safeFloat(t,"rate"),i=this.safeFloat(t,"quantity");e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBook(e,t){const s=this.safeString(t,"marketSymbol"),i=this.safeSymbol(s,void 0,"-"),n=this.safeInteger(t,"depth");let r=this.safeValue(this.orderbooks,i);r===void 0&&(r=this.orderBook({},n)),r.nonce!==void 0?this.handleOrderBookMessage(e,t,r):r.cache.push(t)}handleOrderBookMessage(e,t,s){const i=this.safeString(t,"marketSymbol"),n=this.safeString(t,"depth"),a="orderbook"+"_"+i+"_"+n,o=this.safeInteger(t,"sequence");return o>s.nonce&&(this.handleDeltas(s.asks,this.safeValue(t,"askDeltas",[])),this.handleDeltas(s.bids,this.safeValue(t,"bidDeltas",[])),s.nonce=o,e.resolve(s,a)),s}async handleSystemStatusHelper(){const e=await this.negotiate();await this.start(e)}handleSystemStatus(e,t){return this.spawn(this.handleSystemStatusHelper),t}handleSubscriptionStatus(e,t){const s=this.safeString(t,"I");let i=this.safeValue(e.subscriptions,s);if(i===void 0){const r=this.indexBy(e.subscriptions,"id");i=this.safeValue(r,s,{})}else delete e.subscriptions[s];const n=this.safeValue(i,"method");return n===void 0?e.resolve(t,s):n.call(this,e,t,i),t}handleMessage(e,t){const s={authenticationExpiring:this.handleAuthenticationExpiring,order:this.handleOrder,balance:this.handleBalance,trade:this.handleTrades,candle:this.handleOHLCV,orderBook:this.handleOrderBook,heartbeat:this.handleHeartbeat,ticker:this.handleTicker,execution:this.handleMyTrades},i=this.safeValue(t,"M",[]);for(let a=0;a<i.length;a++){const o=this.safeValue(i[a],"M"),d=this.safeValue(s,o);if(d!==void 0)if(o==="heartbeat")d.call(this,e,t);else if(o==="authenticationExpiring")d.call(this,e,t);else{const c=this.safeValue(i[a],"A",[]);for(let u=0;u<c.length;u++){const h=this.inflate64(c[u]),l=JSON.parse(h);d.call(this,e,l)}}}"I"in t&&this.handleSubscriptionStatus(e,t),"S"in t&&this.handleSystemStatus(e,t),Object.keys(t).length<1&&this.handleHeartbeat(e,t)}};const R$=P_,{AuthenticationError:F$,ArgumentsRequired:FT}=oe,{ArrayCache:DT,ArrayCacheByTimestamp:D$,ArrayCacheBySymbolById:H$}=et;var G$=class extends R${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTrades:!0,watchTicker:!0,watchOHLCV:!0,watchOrders:!0,watchMyTrades:!0},urls:{api:{ws:"wss://ws.bitvavo.com/v2"}},options:{tradesLimit:1e3,ordersLimit:1e3,OHLCVLimit:1e3}})}async watchPublic(e,t,s={}){await this.loadMarkets();const i=this.market(t),n=e+"@"+i.id,r=this.urls.api.ws,a={action:"subscribe",channels:[{name:e,markets:[i.id]}]},o=this.extend(a,s);return await this.watch(r,n,o,n)}async watchTicker(e,t={}){return await this.watchPublic("ticker24h",e,t)}handleTicker(e,t){const s=this.safeString(t,"event"),i=this.safeValue(t,"data",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"market"),o=this.safeMarket(a,void 0,"-"),d=s+"@"+a,c=this.parseTicker(r,o),u=c.symbol;this.tickers[u]=c,e.resolve(c,d)}return t}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.watchPublic("trades",e,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}handleTrade(e,t){const s=this.safeString(t,"market"),i=this.safeMarket(s,void 0,"-"),n=i.symbol,a="trades"+"@"+s,o=this.parseTrade(t,i);let d=this.safeValue(this.trades,n);if(d===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);d=new DT(c)}d.append(o),this.trades[n]=d,e.resolve(d,a)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a="candles",o=r.id,d=this.timeframes[t],c=a+"@"+o+"_"+d,u=this.urls.api.ws,h={action:"subscribe",channels:[{name:"candles",interval:[d],markets:[o]}]},l=this.extend(h,n),p=await this.watch(u,c,l,c);return this.newUpdates&&(i=p.getLimit(e,i)),this.filterBySinceLimit(p,s,i,0,!0)}handleOHLCV(e,t){const s="candles",i=this.safeString(t,"market"),n=this.safeMarket(i,void 0,"-"),r=n.symbol,a=this.safeString(t,"interval"),o=this.findTimeframe(a),d=s+"@"+i+"_"+a,c=this.safeValue(t,"candle");this.ohlcvs[r]=this.safeValue(this.ohlcvs,r,{});let u=this.safeValue(this.ohlcvs[r],o);if(u===void 0){const h=this.safeInteger(this.options,"OHLCVLimit",1e3);u=new D$(h),this.ohlcvs[r][o]=u}for(let h=0;h<c.length;h++){const l=c[h],p=this.parseOHLCV(l,n);u.append(p)}e.resolve(u,d)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n="book",r=n+"@"+i.id,a=this.urls.api.ws,o={action:"subscribe",channels:[{name:n,markets:[i.id]}]},d={messageHash:r,name:n,symbol:e,marketId:i.id,method:this.handleOrderBookSubscription,limit:t,params:s},c=this.extend(o,s);return(await this.watch(a,r,c,r,d)).limit()}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s){const i=this.safeInteger(t,"nonce");return i>s.nonce&&(this.handleDeltas(s.asks,this.safeValue(t,"asks",[])),this.handleDeltas(s.bids,this.safeValue(t,"bids",[])),s.nonce=i),s}handleOrderBook(e,t){const s=this.safeString(t,"event"),i=this.safeString(t,"market"),n=this.safeMarket(i,void 0,"-"),r=n.symbol,a=s+"@"+n.id,o=this.safeValue(this.orderbooks,r);if(o!==void 0)if(o.nonce===void 0){const d=this.safeValue(e.subscriptions,a,{});if(this.safeValue(d,"watchingOrderBookSnapshot")===void 0){d.watchingOrderBookSnapshot=!0,e.subscriptions[a]=d;const u=this.safeValue(this.options,"watchOrderBookSnapshot",{}),h=this.safeInteger(u,"delay",this.rateLimit);this.delay(h,this.watchOrderBookSnapshot,e,t,d)}o.cache.push(t)}else this.handleOrderBookMessage(e,t,o),e.resolve(o,a)}async watchOrderBookSnapshot(e,t,s){const i=this.safeValue(s,"params"),n=this.safeString(s,"marketId"),r="getBook",a=r+"@"+n,o=this.urls.api.ws,d={action:r,market:n};return(await this.watch(o,a,this.extend(d,i),a,s)).limit()}handleOrderBookSnapshot(e,t){const s=this.safeValue(t,"response");if(s===void 0)return t;const i=this.safeString(s,"market");let n;i in this.markets_by_id&&(n=this.markets_by_id[i].symbol);const a="book"+"@"+i,o=this.orderbooks[n],d=this.parseOrderBook(s,n);d.nonce=this.safeInteger(s,"nonce"),o.reset(d);const c=o.cache;for(let u=0;u<c.length;u++){const h=c[u];this.handleOrderBookMessage(e,h,o)}this.orderbooks[n]=o,e.resolve(o,a)}handleOrderBookSubscription(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit");i in this.orderbooks&&delete this.orderbooks[i],this.orderbooks[i]=this.orderBook({},n)}handleOrderBookSubscriptions(e,t,s){const i="book";for(let n=0;n<s.length;n++){const r=this.safeString(s,n);if(r in this.markets_by_id){const o=this.markets_by_id[r].symbol,d=i+"@"+r;if(!(o in this.orderbooks)){const c=this.safeValue(e.subscriptions,d),u=this.safeValue(c,"method");u!==void 0&&u.call(this,e,t,c)}}}}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new FT(this.id+" watchOrders requires a symbol argument");await this.loadMarkets(),await this.authenticate();const n=this.market(e);e=n.symbol;const r=n.id,a=this.urls.api.ws,o="account",d=o+"@"+r,c=d+"_order",u={action:"subscribe",channels:[{name:o,markets:[r]}]},h=await this.watch(a,c,u,d);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySymbolSinceLimit(h,e,t,s,!0)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new FT(this.id+" watchMyTrades requires a symbol argument");await this.loadMarkets(),await this.authenticate();const n=this.market(e);e=n.symbol;const r=n.id,a=this.urls.api.ws,o="account",d=o+"@"+r,c=d+"_fill",u={action:"subscribe",channels:[{name:o,markets:[r]}]},h=await this.watch(a,c,u,d);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySymbolSinceLimit(h,e,t,s,!0)}handleOrder(e,t){const s="account",i=this.safeString(t,"event"),n=this.safeString(t,"market","-"),r=s+"@"+n+"_"+i;if(n in this.markets_by_id){const a=this.markets_by_id[n],o=this.parseOrder(t,a);if(this.orders===void 0){const c=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new H$(c)}this.orders.append(o),e.resolve(this.orders,r)}}handleMyTrade(e,t){const s="account",i=this.safeString(t,"event"),n=this.safeString(t,"market"),r=s+"@"+n+"_"+i,a=this.safeMarket(n,void 0,"-"),o=this.parseTrade(t,a);if(this.myTrades===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new DT(c)}const d=this.myTrades;d.append(o),this.myTrades=d,e.resolve(d,r)}handleSubscriptionStatus(e,t){const s=this.safeValue(t,"subscriptions",{}),i={book:this.handleOrderBookSubscriptions},n=Object.keys(s);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeValue(i,a);if(o!==void 0){const d=this.safeValue(s,a);o.call(this,e,t,d)}}return t}async authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i=s.future("authenticated"),n="authenticate";if(this.safeValue(s.subscriptions,n)===void 0)try{this.checkRequiredCredentials();const a=this.milliseconds(),d=a.toString()+"GET/"+this.version+"/websocket",c=this.hmac(this.encode(d),this.encode(this.secret)),u={action:n,key:this.apiKey,signature:c,timestamp:a};this.spawn(this.watch,t,n,u,n)}catch(a){s.reject(a,"authenticated"),n in s.subscriptions&&delete s.subscriptions[n]}return await i}handleAuthenticationMessage(e,t){if(this.safeValue(t,"authenticated",!1))this.safeValue(e.futures,"authenticated").resolve(!0);else{const i=new F$(this.json(t));e.reject(i,"authenticated");const n=this.safeValue(t,"event");n in e.subscriptions&&delete e.subscriptions[n]}}handleMessage(e,t){const s={subscribed:this.handleSubscriptionStatus,book:this.handleOrderBook,getBook:this.handleOrderBookSnapshot,trade:this.handleTrade,candle:this.handleOHLCV,ticker24h:this.handleTicker,authenticate:this.handleAuthenticationMessage,order:this.handleOrder,fill:this.handleMyTrade},i=this.safeString(t,"event");let n=this.safeValue(s,i);if(n===void 0){const r=this.safeString(t,"action");return n=this.safeValue(s,r),n===void 0?t:n.call(this,e,t)}else return n.call(this,e,t)}};const Oh=ke,U$=A_,{AuthenticationError:HT,BadRequest:$$,NotSupported:j$}=oe,{ArrayCache:W$,ArrayCacheBySymbolById:GT,ArrayCacheByTimestamp:UT}=et;var z$=class extends U${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0},urls:{api:{ws:{inverse:{public:"wss://stream.{hostname}/realtime",private:"wss://stream.{hostname}/realtime"},linear:{public:"wss://stream.{hostname}/realtime_public",private:"wss://stream.{hostname}/realtime_private"},spot:{public:"wss://stream.{hostname}/spot/quote/ws/v2",private:"wss://stream.{hostname}/spot/ws"},usdc:{option:{public:"wss://stream.{hostname}/trade/option/usdc/public/v1",private:"wss://stream.{hostname}/trade/option/usdc/private/v1"},swap:{public:"wss://stream.{hostname}/perpetual/ws/v1/realtime_public",private:"wss://stream.{hostname}/trade/option/usdc/private/v1"}}}},test:{ws:{inverse:{public:"wss://stream-testnet.{hostname}/realtime",private:"wss://stream-testnet.{hostname}/realtime"},linear:{public:"wss://stream-testnet.{hostname}/realtime_public",private:"wss://stream-testnet.{hostname}/realtime_private"},spot:{public:"wss://stream-testnet.{hostname}/spot/quote/ws/v2",private:"wss://stream-testnet.{hostname}/spot/ws"},usdc:{option:{public:"wss://stream-testnet.{hostname}/trade/option/usdc/public/v1",private:"wss://stream-testnet.{hostname}/trade/option/usdc/private/v1"},swap:{public:"wss://stream-testnet.{hostname}/perpetual/ws/v1/realtime_public",private:"wss://stream-testnet.{hostname}/trade/option/usdc/private/v1"}}}}},options:{watchTicker:{name:"realtimes"}},streaming:{ping:this.ping,keepAlive:2e4},exceptions:{ws:{exact:{}}}})}getUrlByMarketType(e=void 0,t=!1,s=void 0,i={}){const n=t?"private":"public";let r,a,o,d,c,u=this.urls.api.ws;if(e!==void 0)c=this.market(e),r=c.settle==="USDC",a=c.spot,o=c.type,d=c.linear;else{[o,i]=this.handleMarketTypeAndParams(s,void 0,i);const h=this.safeString(this.options,"defaultSubType","linear"),l=this.safeString(i,"subType",h);let p=this.safeString(this.options,"defaultSettle");p=this.safeString2(i,"settle","defaultSettle",p),r=p==="USDC",a=o==="spot",d=l==="linear"}return a?u=u.spot[n]:r?u=u.usdc[o][n]:d?u=u.linear[n]:u=u.inverse[n],u=this.implodeHostname(u),u}cleanParams(e){return e=this.omit(e,["type","subType","settle","defaultSettle"]),e}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i="ticker:"+s.symbol,n=this.getUrlByMarketType(e,!1,t);if(t=this.cleanParams(t),s.spot){const r=this.safeValue(this.options,"watchTicker",{}),a=this.safeString(r,"name","realtimes"),o={symbol:s.id};return await this.watchSpotPublic(n,a,i,o,t)}else{const a=["instrument_info.100ms."+s.id];return await this.watchContractPublic(n,i,a,t)}}handleTicker(e,t){const s=this.safeString(t,"topic","");if(s==="realtimes"||s==="bookTicker"){const o=this.safeValue(t,"data"),d=this.parseWsTicker(o),c=d.symbol;this.tickers[c]=d;const u="ticker:"+c;e.resolve(d,u);return}const i=this.safeString(t,"type",""),n=this.safeValue(t,"data",{});let r;if(i==="snapshot"){const o=this.parseWsTicker(n);r=o.symbol,this.tickers[r]=o}if(i==="delta"){const o=s.split("."),d=o.length,c=this.safeString(o,d-1);r=this.market(c).symbol;const h=this.safeValue(n,"update",[]);let l=this.safeValue(this.tickers,r,{});for(let p=0;p<h.length;p++){const m=h[p];l=this.updateTicker(l,m)}this.tickers[r]=l}const a="ticker:"+r;e.resolve(this.tickers[r],a)}updateTicker(e,t){const s=e.info,i=Object.keys(t);if(i.length>0){for(let a=0;a<i.length;a++){const o=i[a];o in s&&(s[o]=t[o])}return this.parseWsTicker(s)}return e}parseWsTicker(e,t=void 0){let s=this.safeInteger2(e,"time","t");if(s===void 0&&(s=this.parse8601(this.safeString2(e,"updated_at","updatedAt")),s===void 0)){const g=this.safeString(e,"updated_at_e9");s=Oh.stringDiv(g,"1000000"),s=this.parseNumber(s),s=s!==void 0?parseInt(s):void 0}const i=this.safeString2(e,"symbol","s"),n=this.safeSymbol(i,t),r=this.safeStringN(e,["c","last_price","lastPrice"]),a=this.safeStringN(e,["prev_price_24h","o","prevPrice24h"]);let o=this.safeStringN(e,["v","turnover24h"]);o===void 0&&(o=this.safeString2(e,"turnover_24h_e8","turnover24hE8"),o=Oh.stringDiv(o,"100000000"));let d=this.safeStringN(e,["qv","volume24h","volume_24h"]);d===void 0&&(d=this.safeString2(e,"volume_24h_e8","volume24hE8"),d=Oh.stringDiv(d,"100000000"));const c=this.safeStringN(e,["bidPrice","bid1_price","bid1Price"]),u=this.safeStringN(e,["askPrice","ask1_price","ask1Price"]),h=this.safeStringN(e,["high_price_24h","high24h","h","highPrice24h"]),l=this.safeStringN(e,["low_price_24h","low24h","l","lowPrice24h"]);let p=this.safeString(e,"m");p===void 0&&(p=this.safeString2(e,"price_24h_pcnt_e6","price24hPcntE6"),p=Oh.stringDiv(p,"1000000"));const m=this.safeString(e,"change24h");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:h,low:l,bid:c,bidVolume:this.safeString2(e,"bidSize","bidQty"),ask:u,askVolume:this.safeString2(e,"askSize","askQty"),vwap:void 0,open:a,close:r,last:r,previousClose:void 0,change:m,percentage:p,average:void 0,baseVolume:d,quoteVolume:o,info:e},t)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=this.timeframes[t],o=this.getUrlByMarketType(e,!1,n);n=this.cleanParams(n);const d="kline:"+t+":"+e;let c;if(r.spot){const u="kline",h={symbol:r.id,klineType:t};c=await this.watchSpotPublic(o,u,d,h,n)}else{const l=[(r.linear?"candle":"klineV2")+"."+a+"."+r.id];c=await this.watchContractPublic(o,d,l,n)}return this.newUpdates&&(i=c.getLimit(e,i)),this.filterBySinceLimit(c,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(t,"topic");if(Array.isArray(s)){const n=i.split("."),r=n.length,a=this.safeString(n,r-1),o=this.safeString(n,r-2),d={};for(let u=0;u<s.length;u++){const h=s[u],l=this.market(a),p=l.symbol,m=this.parseWsOHLCV(h,l);let g=this.safeValue(this.ohlcvs,p);if(g===void 0){const y=this.safeInteger(this.options,"OHLCVLimit",1e3);g=new UT(y),this.ohlcvs[p]=g}g.append(m),d[p]=o}const c=Object.keys(d);for(let u=0;u<c.length;u++){const h=c[u],l=d[h],m="kline:"+this.findTimeframe(l)+":"+h,g=this.safeValue(this.ohlcvs,h);e.resolve(g,m)}}else{const n=this.safeValue(t,"params",{}),r=this.safeValue(t,"data"),a=this.safeString(n,"symbol"),o=this.safeString(n,"klineType"),d=this.market(a),c=this.parseWsOHLCV(r,d),u=d.symbol;let h=this.safeValue(this.ohlcvs,u);if(h===void 0){const p=this.safeInteger(this.options,"OHLCVLimit",1e3);h=new UT(p),this.ohlcvs[u]=h}h.append(c);const l="kline:"+o+":"+u;e.resolve(h,l)}}parseWsOHLCV(e,t=void 0){let s=this.safeInteger(e,"t");return s===void 0&&(s=this.safeTimestamp(e,"start")),[s,this.safeNumber2(e,"open","o"),this.safeNumber2(e,"high","h"),this.safeNumber2(e,"low","l"),this.safeNumber2(e,"close","c"),this.safeNumber2(e,"volume","v")]}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n=this.getUrlByMarketType(e,!1,s);s=this.cleanParams(s);const r="orderbook:"+e;let a;if(i.spot){const o="depth",d={symbol:i.id};a=await this.watchSpotPublic(n,o,r,d,s)}else{let o;if(i.option)o="delta.orderbook100."+i.marketId;else{if(t!==void 0){if(t!==25&&t!==200)throw new $$(this.id+" watchOrderBook limit argument must be either 25 or 200")}else t=25;o=(t===25?"orderBookL2_25":"orderBook_200.100ms")+"."+i.id}const d=[o];a=await this.watchContractPublic(n,r,d,s)}return a.limit()}handleOrderBook(e,t){const s=this.safeString(t,"topic",""),i=this.safeValue(t,"data",{});if(s==="depth"){const n=this.safeString(i,"s"),a=this.market(n).symbol,o=this.safeInteger(i,"t"),d=this.parseOrderBook(i,a,o,"b","a");let c;a in this.orderbooks?(c=this.orderbooks[a],c.reset(d)):(c=this.orderBook(d),this.orderbooks[a]=c);const u="orderbook:"+a;e.resolve(c,u);return}if(s.indexOf("orderBook")>=0){const n=this.safeString(t,"type"),r=s.split("."),a=r.length,o=this.safeString(r,a-1),c=this.market(o).symbol,u="orderbook:"+c,h=this.safeInteger2(t,"cross_seq","crossSeq"),l=this.safeIntegerProduct2(t,"timestamp_e6","timestampE6",.001);if(n==="snapshot"){const p=this.safeValue2(i,"order_book","orderBook",i),m=this.parseOrderBook(p,c,l,"Buy","Sell","price","size");m.nonce=h;let g;c in this.orderbooks?(g=this.orderbooks[c],g.reset(m)):(g=this.orderBook(m),this.orderbooks[c]=g)}else if(n==="delta"){const p=this.safeValue(i,"delete",[]),m=this.safeValue(i,"update",[]),g=this.safeValue(i,"insert",[]),y=[];for(let S=0;S<p.length;S++){const k=p[S];k.size=0,y.push(k)}let b=y;b=this.arrayConcat(b,m),b=this.arrayConcat(b,g);const w=this.safeValue(this.orderbooks,c);w.nonce=h,w.timestamp=l,w.datetime=this.iso8601(l),this.handleDeltas(w,b)}e.resolve(this.orderbooks[c],u)}}handleDeltas(e,t){for(let s=0;s<t.length;s++){const i=t[s];this.safeString(i,"side")==="Buy"?this.handleDelta(e.bids,t[s]):this.handleDelta(e.asks,t[s])}}handleDelta(e,t){const s=this.safeNumber(t,"price"),i=this.safeNumber(t,"size");e.store(s,i)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="trade",a=this.getUrlByMarketType(e,!1,i);i=this.cleanParams(i);const o=r+":"+e;let d;if(n.spot){const c={symbol:n.id};d=await this.watchSpotPublic(a,r,o,c,i)}else{let c;n.option?c="recenttrades."+n.baseId:c=r+"."+n.id;const u=[c];d=await this.watchContractPublic(a,o,u,i)}return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySinceLimit(d,t,s,"timestamp",!0)}handleTrades(e,t){let s;const i=this.safeValue(t,"data",[]),n=this.safeString(t,"topic");let r;if(Array.isArray(i)){const u=n.split(".");s=this.safeString(u,1),r=i}else{const u=this.safeValue(t,"params",{});s=this.safeString(u,"symbol"),i.symbol=s,r=[i]}const a=this.safeMarket(s),o=a.symbol;let d=this.safeValue(this.trades,o);if(d===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);d=new W$(u),this.trades[o]=d}for(let u=0;u<r.length;u++){const h=this.parseWsTrade(r[u],a);d.append(h)}const c="trade:"+o;e.resolve(d,c)}parseWsTrade(e,t=void 0){const s=this.safeStringN(e,["trade_id","v","tradeId","T","exec_id"]),i=this.safeString2(e,"symbol","s");t=this.safeMarket(i,t);const n=t.symbol,r=this.safeStringN(e,["p","price","execPrice"]),a=this.safeStringN(e,["q","size","exec_qty","execQty"]),o=this.safeString2(e,"exec_value","execValue");let d=this.safeIntegerN(e,["trade_time_ms","t","tradeTime","tradeTimeMs"]);d===void 0&&(d=this.parse8601(this.safeString(e,"trade_time")));const c=this.safeStringLower(e,"side");let u=this.safeValue2(e,"m","is_maker");u===void 0&&(u=this.safeString(e,"lastLiquidityInd")==="MAKER");const h=u?"maker":"taker",l=this.safeStringN(e,["o","order_id","tradeTime"]);let p;if(this.safeValue(t,"contract")){const g=this.safeString2(e,"exec_fee","execFee");if(g!==void 0){const y=t.linear?t.quote:t.base;p={cost:g,currency:y}}}return this.safeTrade({id:s,info:e,timestamp:d,datetime:this.iso8601(d),symbol:n,order:l,type:void 0,side:c,takerOrMaker:h,price:r,amount:a,cost:o,fee:p},t)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){const n="watchMyTrades";let r="usertrade";await this.loadMarkets();let a,o,d;const c=this.getUrlByMarketType(e,!0,n,i);if(e!==void 0)a=this.market(e),e=a.symbol,r+=":"+e,o=a.type,d=a.settle==="USDC";else{[o,i]=this.handleMarketTypeAndParams(n,void 0,i);let h=this.safeString(this.options,"defaultSettle");h=this.safeString2(i,"settle","defaultSettle",h),d=h==="USDC"}i=this.cleanParams(i);let u;if(o==="spot")u=await this.watchSpotPrivate(c,r,i);else{let h;d?h=o==="option"?"user.openapi.option.trade":"user.openapi.perp.trade":h="execution";const l=[h];r+=":"+h,u=await this.watchContractPrivate(c,r,l,i)}return this.newUpdates&&(s=u.getLimit(e,s)),this.filterBySinceLimit(u,t,s,"timestamp",!0)}handleMyTrades(e,t){const s=this.safeString(t,"topic","");let i=[];if(Array.isArray(t)?i=t:(i=this.safeValue(t,"data",[]),"result"in i&&(i=i.result)),this.myTrades===void 0){const d=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new GT(d)}const n=this.myTrades,r={};for(let d=0;d<i.length;d++){const c=i[d],u=this.parseWsTrade(c),h=u.symbol;r[h]=!0,n.append(u)}const a=Object.keys(r);for(let d=0;d<a.length;d++){let u="usertrade:"+a[d];s&&(u+=":"+s),e.resolve(n,u)}let o="usertrade";s&&(o+=":"+s),e.resolve(n,o)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){const n="watchOrders";let r="order";await this.loadMarkets();let a,o,d;const c=this.getUrlByMarketType(e,!0,n,i);if(e!==void 0)a=this.market(e),e=a.symbol,r+=":"+e,o=a.type,d=a.settle==="USDC";else{[o,i]=this.handleMarketTypeAndParams(n,void 0,i);let h=this.safeString(this.options,"defaultSettle");h=this.safeString2(i,"settle","defaultSettle",h),d=h==="USDC"}i=this.cleanParams(i);let u;if(o==="spot")u=await this.watchSpotPrivate(c,r,i);else{let h;if(d)h=o==="option"?"user.openapi.option.order":"user.openapi.perp.order";else{const p=this.safeString(i,"orderType"),g=this.safeValue(i,"stop",!1)||p==="stop"||p==="conditional";i=this.omit(i,["stop","orderType"]),h=g?"stop_order":"order"}const l=[h];r+=":"+h,u=await this.watchContractPrivate(c,r,l,i)}return this.newUpdates&&(s=u.getLimit(e,s)),this.filterBySymbolSinceLimit(u,e,t,s,!0)}handleOrder(e,t,s=void 0){const i=this.safeString(t,"topic","");let n=[],r=!1;if(Array.isArray(t)?(n=t,r=!0):(n=this.safeValue(t,"data",[]),"result"in n&&(n=n.result)),n.length===0)return;if(this.orders===void 0){const h=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new GT(h)}const o=this.orders,d={};for(let h=0;h<n.length;h++){const l=n[h];let p;r?p=this.parseWsOrder(l):p=this.parseOrder(l);const m=p.symbol;d[m]=!0,o.append(p)}const c=Object.keys(d);for(let h=0;h<c.length;h++){let p="order:"+c[h];i&&(p+=":"+i),e.resolve(o,p)}let u="order";i&&(u+=":"+i),e.resolve(o,u)}parseWsOrder(e,t=void 0){const s=this.safeString(e,"i"),i=this.safeString(e,"s"),n=this.safeSymbol(i,t),r=this.safeInteger(e,"O");let a=this.safeString(e,"p");a==="0"&&(a=void 0);const o=this.safeString(e,"q"),d=this.safeString(e,"z"),c=this.parseOrderStatus(this.safeString(e,"X")),u=this.safeStringLower(e,"S"),h=this.safeString(e,"E"),l=this.safeString(e,"f");let p=this.safeStringLower(e,"o");p.indexOf("market")>=0&&(p="market");let m;const g=this.safeString(e,"n");if(g!==void 0&&g!=="0"){const y=this.safeString(e,"N"),b=this.safeCurrencyCode(y);m={cost:g,currency:b}}return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:h,symbol:n,type:p,timeInForce:l,postOnly:void 0,side:u,price:a,stopPrice:void 0,amount:o,cost:void 0,average:void 0,filled:d,remaining:void 0,status:c,fee:m,trades:void 0},t)}async watchBalance(e={}){const t="watchBalance";let s;if([s,e]=this.handleMarketTypeAndParams(t,void 0,e),s!=="spot"&&s!=="swap")throw new j$(this.id+" watchBalance does not support "+s+" type");const i="balance:"+s,n=this.getUrlByMarketType(void 0,!0,t,e);if(e=this.cleanParams(e),s==="spot")return await this.watchSpotPrivate(n,i,e);{const r=["wallet"];return await this.watchContractPrivate(n,i,r,e)}}handleBalance(e,t){const s=this.safeString(t,"topic");let i="balance";if(s==="wallet"){const n=this.safeValue(t,"data",[]);for(let r=0;r<n.length;r++){const a=this.account(),o=n[r],d=this.safeString(o,"coin","USDT"),c=this.safeCurrencyCode(d);a.free=this.safeString(o,"available_balance"),a.total=this.safeString(o,"wallet_balance"),this.balance[c]=a,this.balance=this.safeBalance(this.balance)}i+=":swap",e.resolve(this.balance,i);return}if(Array.isArray(t)){for(let n=0;n<t.length;n++){const r=this.safeValue(t[n],"B",[]);for(let a=0;a<r.length;a++){const o=r[a],d=this.account(),c=this.safeCurrencyCode(this.safeString(o,"a"));d.free=this.safeString(o,"f"),d.used=this.safeString(o,"l"),this.balance[c]=d,this.balance=this.safeBalance(this.balance)}}i+=":spot",e.resolve(this.balance,i)}}async watchContractPublic(e,t,s={},i={}){const n={op:"subscribe",args:s},r=this.extend(n,i);return await this.watch(e,t,r,t)}async watchSpotPublic(e,t,s,i={},n={}){i=this.extend(i,{binary:!1});const r={topic:t,event:"sub",params:i},a=this.extend(r,n);return await this.watch(e,s,a,s)}async watchSpotPrivate(e,t,s={}){const i="private";this.checkRequiredCredentials();let n=this.milliseconds()+1e4;n=n.toString();const a="GET/realtime"+n,o=this.hmac(this.encode(a),this.encode(this.secret),"sha256","hex"),d={op:"auth",args:[this.apiKey,n,o]};return await this.watch(e,t,d,i)}async watchContractPrivate(e,t,s,i={}){return await this.authenticateContract(e,i),await this.watchContractPublic(e,t,s,i)}async authenticateContract(e,t={}){this.checkRequiredCredentials();const s="login",i=this.client(e);let n=this.safeValue(i.subscriptions,s);if(n===void 0){n=i.future("authenticated");let r=this.milliseconds()+1e4;r=r.toString();const o="GET/realtime"+r,d=this.hmac(this.encode(o),this.encode(this.secret),"sha256","hex"),c={op:"auth",args:[this.apiKey,r,d]};this.spawn(this.watch,e,s,c,s,n)}return await n}handleErrorMessage(e,t){const s=this.safeInteger(t,"code");try{if(s!==void 0){const n=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,n)}if(!this.safeValue(t,"success",!1)){const n=this.safeString(t,"ret_msg"),r=this.safeValue(t,"request",{});if(this.safeString(r,"op")==="auth")throw new HT("Authentication failed: "+n)}}catch(i){if(i instanceof HT){e.reject(i,"authenticated");const n="login";return n in e.subscriptions&&delete e.subscriptions[n],!1}}return t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;if(this.safeString(t,"ret_msg")==="pong"){this.handlePong(e,t);return}if(this.safeInteger(t,"pong")!==void 0){this.handlePong(e,t);return}if(this.safeString(t,"op")==="pong"){this.handlePong(e,t);return}if(this.safeString(t,"event")==="sub"){this.handleSubscriptionStatus(e,t);return}const a=this.safeString(t,"topic","");if(a.indexOf("kline")>=0||a.indexOf("candle")>=0){this.handleOHLCV(e,t);return}if(a.indexOf("realtimes")>=0||a.indexOf("instrument_info")>=0){this.handleTicker(e,t);return}if(a.indexOf("trade")>=0){if(a.indexOf("user")>=0){this.handleMyTrades(e,t);return}this.handleTrades(e,t)}if(a.indexOf("orderBook")>=0){this.handleOrderBook(e,t);return}if(a.indexOf("order")>=0){this.handleOrder(e,t);return}const o={realtimes:this.handleTicker,bookTicker:this.handleTicker,depth:this.handleOrderBook,wallet:this.handleBalance,execution:this.handleMyTrades},d=this.safeValue(o,a);d!==void 0&&d.call(this,e,t);const c=this.safeValue(t,"request",{});if(this.safeString(c,"op")==="auth"&&this.handleAuthenticate(e,t),this.safeString(t,"type")==="AUTH_RESP"&&this.handleAuthenticate(e,t),Array.isArray(t)){const l=this.safeValue(t,0),p=this.safeString(l,"e");p==="outboundAccountInfo"&&this.handleBalance(e,t),p==="executionReport"&&this.handleOrder(e,t),p==="ticketInfo"&&this.handleMyTrades(e,t)}}ping(e){const t=e.url,s=this.milliseconds();return t.indexOf("spot")>=0?{ping:s}:{op:"ping"}}handlePong(e,t){return e.lastPong=this.safeInteger(t,"pong"),t}handleAuthenticate(e,t){return e.resolve(t,"authenticated"),t}handleSubscriptionStatus(e,t){return t}};const{ExchangeError:Mg,ArgumentsRequired:$T}=oe,jT=ke,K$=B_,{ArrayCacheBySymbolById:WT,ArrayCacheByTimestamp:X$,ArrayCache:Y$}=et;var Q$=class extends K${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!0,watchTrades:!0,watchMyTrades:!0,watchOrders:!0,watchOrderBook:!0,watchOHLCV:!0,watchPosition:void 0},urls:{api:{ws:"wss://ws.cex.io/ws"}},options:{orderbook:{}},streaming:{},exceptions:{}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}async watchBalance(e={}){await this.authenticate(e);const t="balance",s=this.urls.api.ws,i={e:"get-balance",data:{},oid:this.requestId()},n=this.deepExtend(i,e);return await this.watch(s,t,n,t,n)}handleBalance(e,t){const s=this.safeValue(t,"data",{}),i=this.safeValue(s,"balance",{}),n=this.safeValue(s,"obalance",{}),r={},a=Object.keys(i);for(let o=0;o<a.length;o++){const d=a[o],c=this.account();c.free=this.safeString(i,d),c.used=this.safeString(n,d);const u=this.safeCurrencyCode(d);r[u]=c}this.balance=this.safeBalance(r),e.resolve(this.balance,"balance")}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r=this.urls.api.ws,a="trades",o="old:"+e,d=this.safeValue(this.clients,r);if(d!==void 0){const l=Object.keys(d.subscriptions);for(let p=0;p<l.length;p++){let m=l[p];if(m!==o&&(m=m.slice(0,3),m==="old"))throw new Mg(this.id+" watchTrades() only supports watching one symbol at a time.")}}const c={e:"subscribe",rooms:["pair-"+n.base+"-"+n.quote]},u=this.deepExtend(c,i),h=await this.watch(r,a,u,o);for(let l=0;l<h.length;l++)h[l].symbol=e;return this.filterBySinceLimit(h,t,s,"timestamp",!0)}handleTradesSnapshot(e,t){const s=this.safeValue(t,"data",[]),i=this.safeInteger(this.options,"tradesLimit",1e3),n=new Y$(i);for(let a=0;a<s.length;a++){const o=s[a],d=this.parseWsOldTrade(o);n.append(d)}const r="trades";this.trades=n,e.resolve(this.trades,r)}parseWsOldTrade(e,t=void 0){Array.isArray(e)||(e=e.split(":"));const s=this.safeString(e,0),i=this.safeNumber(e,1),n=this.safeString(e,2),r=this.safeString(e,3),a=this.safeString(e,4);return this.safeTrade({info:e,id:a,timestamp:i,datetime:this.iso8601(i),symbol:void 0,type:void 0,side:s,order:void 0,takerOrMaker:void 0,price:r,amount:n,cost:void 0,fee:void 0},t)}handleTrade(e,t){const s=this.safeValue(t,"data",[]),i=this.trades;for(let r=0;r<s.length;r++){const a=s[r],o=this.parseWsOldTrade(a);i.append(o)}const n="trades";this.trades=i,e.resolve(this.trades,n)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i=this.urls.api.ws,n="ticker:"+e,r=this.safeString(t,"method","private");let a={e:"subscribe",rooms:["tickers"]},o="tickers";r==="private"&&(await this.authenticate(),a={e:"ticker",data:[s.baseId,s.quoteId],oid:this.requestId()},o="ticker:"+e);const d=this.deepExtend(a,t);return await this.watch(i,n,d,o)}async watchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.urls.api.ws,i="tickers",n={e:"subscribe",rooms:["tickers"]},r=this.deepExtend(n,t),a=await this.watch(s,i,r,i),o=a.symbol;if(e!==void 0&&!this.inArray(e,o))return await this.watchTickers(e,t);if(this.newUpdates){const d={};return d[o]=a,d}return this.filterByArray(this.tickers,"symbol",e)}handleTicker(e,t){const s=this.safeValue(t,"data",{}),i=this.parseWsTicker(s),n=i.symbol,r="ticker:"+n;this.tickers[n]=i,e.resolve(i,r),e.resolve(i,"tickers")}parseWsTicker(e,t=void 0){const s=this.safeValue(e,"pair",[]);let i=this.safeString(e,"symbol1");i===void 0&&(i=this.safeString(s,0));let n=this.safeString(e,"symbol2");n===void 0&&(n=this.safeString(s,1));const r=this.safeCurrencyCode(i),a=this.safeCurrencyCode(n),o=r+"/"+a;let d=this.safeInteger(e,"timestamp");return d!==void 0&&(d=d*1e3),this.safeTicker({symbol:o,timestamp:d,datetime:this.iso8601(d),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open24"),close:void 0,last:this.safeString2(e,"price","last"),previousClose:void 0,change:this.safeString(e,"priceChange"),percentage:this.safeString(e,"priceChangePercentage"),average:void 0,baseVolume:void 0,quoteVolume:this.safeString(e,"volume"),info:e},t)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new $T(this.id+" watchOrders requires a symbol argument");await this.loadMarkets(),await this.authenticate(i);const n=this.urls.api.ws,r=this.market(e);e=r.symbol;const a="orders:"+e,o={e:"open-orders",data:{pair:[r.baseId,r.quoteId]},oid:e},d=this.deepExtend(o,i),c=await this.watch(n,a,d,a,d);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new $T(this.id+" watchOrders requires a symbol argument");await this.loadMarkets(),await this.authenticate(i);const n=this.urls.api.ws,r=this.market(e),a="myTrades:"+r.symbol,o="orders:"+r.symbol,d={e:"open-orders",data:{pair:[r.baseId,r.quoteId]},oid:r.symbol},c=this.deepExtend(d,i),u=await this.watch(n,a,c,o,c);return this.filterBySymbolSinceLimit(u,r.symbol,t,s,!0)}handleTransaction(e,t){const s=this.safeValue(t,"data");this.safeString(s,"symbol2")!==void 0&&(this.handleOrderUpdate(e,t),this.handleMyTrades(e,t))}handleMyTrades(e,t){const s=this.safeValue(t,"data",{});let i=this.myTrades;if(i===void 0){const a=this.safeInteger(this.options,"tradesLimit",1e3);i=new WT(a),this.myTrades=i}const n=this.parseWsTrade(s);i.append(n);const r="myTrades:"+n.symbol;e.resolve(i,r)}parseWsTrade(e,t=void 0){const s=this.safeString(e,"type"),i=this.safeString(e,"price"),n=this.safeString(e,"time"),r=this.safeString(e,"symbol"),a=this.safeString(e,"symbol2"),o=this.safeCurrencyCode(r),d=this.safeCurrencyCode(a);let c=o+"/"+d,u=this.safeString(e,"amount");s==="sell"&&(c=d+"/"+o,u=jT.stringDiv(u,i));const h={id:this.safeString(e,"id"),order:this.safeString(e,"order"),info:e,timestamp:this.parse8601(n),datetime:n,symbol:c,type:void 0,side:s,takerOrMaker:void 0,price:i,cost:void 0,amount:u,fee:void 0},l=this.safeString(e,"fee_amount");return l!==void 0&&(h.fee={cost:l,currency:d,rate:void 0}),this.safeTrade(h,t)}handleOrderUpdate(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(t,"e")==="tx",n=this.safeString2(s,"id","order");let r=this.safeString(s,"remains"),a=this.safeString(s,"symbol"),o=this.safeString(s,"symbol2");const d=this.safeValue(s,"pair");d!==void 0&&(a=this.safeString(d,"symbol1"),o=this.safeString(d,"symbol2"));const c=this.safeCurrencyCode(a),u=this.safeCurrencyCode(o),h=c+"/"+u,l=this.safeMarket(h);r=this.currencyFromPrecision(c,r);const p=this.safeValue(this.orders.hashmap,h,{});let m=this.safeValue(p,n);m===void 0&&(m=this.parseWsOrderUpdate(s,l)),m.remaining=r,this.safeValue(s,"cancel",!1)&&(m.status="canceled"),i&&(m.status="closed");const y=this.safeNumber(s,"fee");y!==void 0&&(m.fee={cost:y,currency:u,rate:void 0});const b=this.safeInteger(s,"time",this.milliseconds());m.timestamp=b,m.datetime=this.iso8601(b),m=this.safeOrder(m);const w=this.orders;w.append(m);const S="orders:"+h;e.resolve(w,S)}parseWsOrderUpdate(e,t=void 0){const s=this.safeValue(e,"d")!==void 0,i=this.safeString(e,"remains");let n;i!==void 0&&(n=this.currencyFromPrecision(t.base,i));const r=this.safeString(e,"amount");s||this.currencyFromPrecision(t.base,r);let a=this.safeString(e,"symbol"),o=this.safeString(e,"symbol2");this.safeValue(e,"pair")!==void 0&&(a=this.safeString(e,"symbol1"),o=this.safeString(e,"symbol2"));const c=this.safeCurrencyCode(a),u=this.safeCurrencyCode(o),h=c+"/"+u;t=this.safeMarket(h,t);const l=this.safeInteger(e,"time",this.milliseconds());let p=l;s&&(p=this.parse8601(l));const m=this.safeValue(e,"cancel",!1);let g="open";m?g="canceled":s&&(g="closed");const y={id:this.safeString2(e,"id","order"),clientOrderId:void 0,info:e,timestamp:p,datetime:this.iso8601(p),lastTradeTimestamp:void 0,status:g,symbol:h,type:void 0,timeInForce:void 0,postOnly:void 0,side:this.safeString(e,"type"),price:this.safeNumber(e,"price"),stopPrice:void 0,average:void 0,cost:void 0,amount:r,filled:void 0,remaining:n,fee:{cost:this.safeNumber2(e,"fee","fee_amount"),currency:u,rate:void 0},trades:void 0};return s&&(y.trades=this.parseWsTrade(e,t)),this.safeOrder(y,t)}fromPrecision(e,t){if(e===void 0)return;const s=new jT(e);return s.decimals=this.sum(s.decimals,t),s.reduce(),s.toString()}currencyFromPrecision(e,t){const s=this.safeInteger(this.currencies[e],"precision",0);return this.fromPrecision(t,s)}handleOrdersSnapshot(e,t){const s=this.safeString(t,"oid"),i=this.safeValue(t,"data",[]);let n=this.orders;if(this.orders===void 0){const a=this.safeInteger(this.options,"ordersLimit",1e3);n=new WT(a)}for(let a=0;a<i.length;a++){const o=i[a],d=this.safeMarket(s),c=this.parseOrder(o,d);c.status="open",n.append(c)}this.orders=n;const r="orders:"+s;e.resolve(n,r)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets(),await this.authenticate();const i=this.market(e);e=i.symbol;const n=this.urls.api.ws,r="orderbook:"+e,a=t===void 0?0:t,o={e:"order-book-subscribe",data:{pair:[i.baseId,i.quoteId],subscribe:!0,depth:a},oid:this.requestId()},d=this.deepExtend(o,s);return(await this.watch(n,r,d,r)).limit(t)}handleOrderBookSnapshot(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(s,"pair"),n=this.pairToSymbol(i),r="orderbook:"+n,a=this.safeInteger2(s,"timestamp_ms","timestamp"),o=this.safeNumber(s,"id"),d=this.orderBook({}),c=this.parseOrderBook(s,n,a,"bids","asks");c.nonce=o,d.reset(c),this.options.orderbook[n]={incrementalId:o},this.orderbooks[n]=d,e.resolve(d,r)}pairToSymbol(e){const t=e.split(":"),s=this.safeString(t,0),i=this.safeString(t,1),n=this.safeCurrencyCode(s),r=this.safeCurrencyCode(i);return n+"/"+r}handleOrderBookUpdate(e,t){const s=this.safeValue(t,"data",{}),i=this.safeNumber(s,"id"),n=this.safeString(s,"pair",""),r=this.pairToSymbol(n),a=this.safeValue(this.orderbooks,r);if(i!==a.nonce+1)throw new Mg(this.id+" watchOrderBook() skipped a message");const o="orderbook:"+r,d=this.safeInteger(s,"time"),c=this.safeValue(s,"asks",[]),u=this.safeValue(s,"bids",[]);this.handleDeltas(a.asks,c),this.handleDeltas(a.bids,u),a.timestamp=d,a.datetime=this.iso8601(d),a.nonce=i,e.resolve(a,o)}handleDelta(e,t){const s=this.parseBidAsk(t,0,1);e.storeArray(s)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a="ohlcv:"+e,o=this.urls.api.ws,d={e:"init-ohlcv",i:t,rooms:["pair-"+r.baseId+"-"+r.quoteId]},c=await this.watch(o,a,this.extend(d,n),a);return this.newUpdates&&(i=c.getLimit(e,i)),this.filterBySinceLimit(c,s,i,0,!0)}handleInitOHLCV(e,t){const i=this.safeString(t,"pair").split(":"),n=this.safeString(i,0),r=this.safeString(i,1),a=this.safeCurrencyCode(n),o=this.safeCurrencyCode(r),d=a+"/"+o,c=this.safeMarket(d),u="ohlcv:"+d,h=this.safeValue(t,"data",[]),l=this.safeInteger(this.options,"OHLCVLimit",1e3),p=new X$(l),m=this.sortBy(h,0);for(let g=0;g<m.length;g++)p.append(this.parseOHLCV(m[g],c));this.ohlcvs[d]=p,e.resolve(p,u)}handleOHLCV24(e,t){return t}handleOHLCV1m(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(s,"pair"),n=this.pairToSymbol(i),r="ohlcv:"+n,a=[this.safeTimestamp(s,"time"),this.safeNumber(s,"o"),this.safeNumber(s,"h"),this.safeNumber(s,"l"),this.safeNumber(s,"c"),this.safeNumber(s,"v")],o=this.safeValue(this.ohlcvs,n);o.append(a),e.resolve(o,r)}handleOHLCV(e,t){const s=this.safeValue(t,"data",[]),i=this.safeString(t,"pair"),n=this.pairToSymbol(i),r="ohlcv:"+n,a=this.safeValue(this.ohlcvs,n);for(let o=0;o<s.length;o++){const d=[this.safeTimestamp(s[o],0),this.safeNumber(s[o],1),this.safeNumber(s[o],2),this.safeNumber(s[o],3),this.safeNumber(s[o],4),this.safeNumber(s[o],5)];a.append(d)}s.length>0&&e.resolve(a,r)}handleConnected(e,t){return t}handleErrorMessage(e,t){throw new Mg(this.id+" "+this.json(t))}handleMessage(e,t){if(this.safeString(t,"ok")==="error")return this.handleErrorMessage(e,t);const i=this.safeString(t,"e"),n={auth:this.handleAuthenticationMessage,connected:this.handleConnected,tick:this.handleTicker,ticker:this.handleTicker,"init-ohlcv-data":this.handleInitOHLCV,ohlcv24:this.handleOHLCV24,ohlcv1m:this.handleOHLCV1m,ohlcv:this.handleOHLCV,"get-balance":this.handleBalance,"order-book-subscribe":this.handleOrderBookSnapshot,md_update:this.handleOrderBookUpdate,"open-orders":this.handleOrdersSnapshot,order:this.handleOrderUpdate,"history-update":this.handleTrade,history:this.handleTradesSnapshot,tx:this.handleTransaction},r=this.safeValue(n,i);return r!==void 0?r.call(this,e,t):t}handleAuthenticationMessage(e,t){const s=this.safeValue(e.futures,"authenticated");s!==void 0&&s.resolve(!0)}async authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i="authenticated",n=s.future("authenticated");if(this.safeValue(s.subscriptions,i)===void 0){this.checkRequiredCredentials();const a=this.seconds().toString(),o=a+this.apiKey,d=this.hmac(this.encode(o),this.encode(this.secret)),c={e:"auth",auth:{key:this.apiKey,signature:d.toUpperCase(),timestamp:a}};this.spawn(this.watch,t,i,this.extend(c,e),i)}return await n}};const Z$=vb,{BadSymbol:zT}=oe,{ArrayCache:J$,ArrayCacheBySymbolById:KT}=et;var eC=class extends Z${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOHLCV:!1,watchOrderBook:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchBalance:!1,watchStatus:!1,watchOrders:!0,watchMyTrades:!0},urls:{api:{ws:"wss://ws-feed.pro.coinbase.com"}},options:{tradesLimit:1e3,ordersLimit:1e3,myTradesLimit:1e3}})}authenticate(){this.checkRequiredCredentials();const e="/users/self/verify",t=this.nonce(),s=t.toString()+"GET"+e,i=this.hmac(this.encode(s),this.base64ToBinary(this.secret),"sha256","base64");return{timestamp:t,key:this.apiKey,signature:i,passphrase:this.password}}async subscribe(e,t,s,i={}){await this.loadMarkets();const n=this.market(t),r=s+":"+n.id;let a=this.urls.api.ws;"signature"in i&&(a=a+"?");const o={type:"subscribe",product_ids:[n.id],channels:[e]},d=this.extend(o,i);return await this.watch(a,r,d,r)}async watchTicker(e,t={}){const s="ticker";return await this.subscribe(s,e,s,t)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n="matches",r=await this.subscribe(n,e,n,i);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySinceLimit(r,t,s,"timestamp",!0)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new zT(this.id+" watchMyTrades requires a symbol");await this.loadMarkets(),e=this.symbol(e);const n="user",r="myTrades",a=this.authenticate(),o=await this.subscribe(n,e,r,this.extend(i,a));return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new zT(this.id+" watchMyTrades requires a symbol");await this.loadMarkets(),e=this.symbol(e);const n="user",r="orders",a=this.authenticate(),o=await this.subscribe(n,e,r,this.extend(i,a));return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}async watchOrderBook(e,t=void 0,s={}){const i="level2";await this.loadMarkets();const n=this.market(e);e=n.symbol;const r=i+":"+n.id,a=this.urls.api.ws,o={type:"subscribe",product_ids:[n.id],channels:[i]},d=this.extend(o,s),c={messageHash:r,symbol:e,marketId:n.id,limit:t};return(await this.watch(a,r,d,r,c)).limit()}handleTrade(e,t){const s=this.safeString(t,"product_id");if(s!==void 0){const i=this.parseWsTrade(t),n=i.symbol,a="matches"+":"+s;let o=this.safeValue(this.trades,n);if(o===void 0){const d=this.safeInteger(this.options,"tradesLimit",1e3);o=new J$(d),this.trades[n]=o}o.append(i),e.resolve(o,a)}return t}handleMyTrade(e,t){const s=this.safeString(t,"product_id");if(s!==void 0){const i=this.parseWsTrade(t),r="myTrades"+":"+s;let a=this.myTrades;if(a===void 0){const o=this.safeInteger(this.options,"myTradesLimit",1e3);a=new KT(o),this.myTrades=a}a.append(i),e.resolve(a,r)}return t}parseWsTrade(e){const t=super.parseTrade(e);let s;"maker_fee_rate"in e?(t.takerOrMaker="maker",s=this.safeNumber(e,"maker_fee_rate")):(t.takerOrMaker="taker",s=this.safeNumber(e,"taker_fee_rate"));const n=this.market(t.symbol).quote;let r;return t.cost!==void 0&&s!==void 0&&(r=t.cost*s),t.fee={rate:s,cost:r,currency:n},t}parseWsOrderStatus(e){const t={filled:"closed",canceled:"canceled"};return this.safeString(t,e,"open")}handleOrder(e,t){let s=this.orders;if(s===void 0){const r=this.safeInteger(this.options,"ordersLimit",1e3);s=new KT(r),this.orders=s}const i=this.safeString(t,"type"),n=this.safeString(t,"product_id");if(n!==void 0){const r="orders:"+n,a=this.safeSymbol(n),o=this.safeString(t,"order_id"),d=this.safeString(t,"maker_order_id"),c=this.safeString(t,"taker_order_id"),u=this.orders,h=this.safeValue(u.hashmap,a,{});let l=this.safeValue(h,o);if(l===void 0&&(l=this.safeValue2(h,d,c)),l===void 0){const p=this.parseWsOrder(t);u.append(p),e.resolve(u,r)}else{const p=this.safeInteger(t,"sequence"),m=this.safeValue(l,"info",{}),g=this.safeInteger(m,"sequence");if(g===void 0||p>g){if(i==="match"){const y=this.parseWsTrade(t);l.trades===void 0&&(l.trades=[]),l.trades.push(y),l.lastTradeTimestamp=y.timestamp;let b=0,w=0;const S=l.trades;for(let k=0;k<S.length;k++){const T=S[k];b=this.sum(b,T.cost),w=this.sum(w,T.amount)}w>0&&(l.average=b/w),l.cost=b,l.filled!==void 0&&(l.filled+=y.amount,l.amount!==void 0&&(l.remaining=l.amount-l.filled)),l.fee===void 0&&(l.fee={cost:0,currency:y.fee.currency}),l.fee.cost!==void 0&&y.fee.cost!==void 0&&(l.fee.cost=this.sum(l.fee.cost,y.fee.cost)),u.append(l),e.resolve(u,r)}else if(i==="received"||i==="done"){const y=this.extend(l.info,t),b=this.parseWsOrder(y),w=Object.keys(b);for(let S=0;S<w.length;S++){const k=w[S];b[k]!==void 0&&(l[k]=b[k])}u.append(l),e.resolve(u,r)}}}}}parseWsOrder(e){const t=this.safeString(e,"order_id"),s=this.safeString(e,"client_oid"),i=this.safeString(e,"product_id"),n=this.safeSymbol(i),r=this.safeString(e,"side"),a=this.safeNumber(e,"price"),o=this.safeNumber2(e,"size","funds"),d=this.safeString(e,"time"),c=this.parse8601(d),u=this.safeString(e,"reason"),h=this.parseWsOrderStatus(u),l=this.safeString(e,"order_type");let p=this.safeNumber(e,"remaining_size");const m=this.safeString(e,"type");let g;o!==void 0&&p!==void 0?g=o-p:m==="received"&&(g=0,o!==void 0&&(p=o-g));let y;return a!==void 0&&o!==void 0&&(y=a*o),{info:e,symbol:n,id:t,clientOrderId:s,timestamp:c,datetime:this.iso8601(c),lastTradeTimestamp:void 0,type:l,timeInForce:void 0,postOnly:void 0,side:r,price:a,stopPrice:void 0,amount:o,cost:y,average:void 0,filled:g,remaining:p,status:h,fee:void 0,trades:void 0}}handleTicker(e,t){const s=this.safeString(t,"product_id");if(s!==void 0){const i=this.parseTicker(t),n=i.symbol;this.tickers[n]=i;const a=this.safeString(t,"type")+":"+s;e.resolve(i,a)}return t}parseTicker(e,t=void 0){if(this.safeString(e,"type")===void 0)return super.parseTicker(e,t);const i=this.safeString(e,"product_id"),n=this.safeSymbol(i,t,"-"),r=this.parse8601(this.safeString(e,"time")),a=this.safeNumber(e,"price");return{symbol:n,timestamp:r,datetime:this.iso8601(r),high:this.safeNumber(e,"high_24h"),low:this.safeNumber(e,"low_24h"),bid:this.safeNumber(e,"best_bid"),bidVolume:void 0,ask:this.safeNumber(e,"best_ask"),askVolume:void 0,vwap:void 0,open:this.safeNumber(e,"open_24h"),close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeNumber(e,"volume_24h"),quoteVolume:void 0,info:e}}handleDelta(e,t){const s=this.safeNumber(t,0),i=this.safeNumber(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBook(e,t){const s=this.safeString(t,"type"),i=this.safeString(t,"product_id"),r=this.safeMarket(i,void 0,"-").symbol,o="level2"+":"+i,d=this.safeValue(e.subscriptions,o,{}),c=this.safeInteger(d,"limit");if(s==="snapshot"){this.orderbooks[r]=this.orderBook({},c);const u=this.orderbooks[r];this.handleDeltas(u.asks,this.safeValue(t,"asks",[])),this.handleDeltas(u.bids,this.safeValue(t,"bids",[])),u.timestamp=void 0,u.datetime=void 0,e.resolve(u,o)}else if(s==="l2update"){const u=this.orderbooks[r],h=this.parse8601(this.safeString(t,"time")),l=this.safeValue(t,"changes",[]),p={sell:"asks",buy:"bids"};for(let m=0;m<l.length;m++){const g=l[m],y=this.safeString(g,0),b=this.safeString(p,y),w=this.safeNumber(g,1),S=this.safeNumber(g,2);u[b].store(w,S)}u.timestamp=h,u.datetime=this.iso8601(h),e.resolve(u,o)}}handleSubscriptionStatus(e,t){return t}handleMessage(e,t){const s=this.safeString(t,"type"),i={snapshot:this.handleOrderBook,l2update:this.handleOrderBook,subscribe:this.handleSubscriptionStatus,ticker:this.handleTicker,received:this.handleOrder,open:this.handleOrder,change:this.handleOrder,done:this.handleOrder},n=e.url.length-0,r=e.url[n-1]==="?",a=this.safeValue(i,s);if(a===void 0)s==="match"&&(r?(this.handleMyTrade(e,t),this.handleOrder(e,t)):this.handleTrade(e,t));else return a.call(this,e,t)}};const ej=eC;var tj=class extends ej{describe(){return this.deepExtend(super.describe(),{id:"coinbaseprime",name:"Coinbase Prime",has:{ws:!0,watchOrderBook:!0},urls:{test:{ws:"wss://ws-feed-public.sandbox.exchange.coinbase.com"},logo:"https://user-images.githubusercontent.com/1294454/44539184-29f26e00-a70c-11e8-868f-e907fc236a7c.jpg",api:{ws:"wss://ws-feed.exchange.coinbase.com"},www:"https://exchange.coinbase.com",doc:"https://docs.exchange.coinbase.com/",fees:"https://pro.coinbase.com/fees"}})}};const Pg=ke,sj=N_,{AuthenticationError:ij,BadRequest:nj,ExchangeNotAvailable:rj,NotSupported:Ih,RequestTimeout:aj,ExchangeError:Ag}=oe,{ArrayCache:oj,ArrayCacheByTimestamp:dj,ArrayCacheBySymbolById:cj}=et;var uj=class extends sj{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchMyTrades:!1,watchOrders:!0,watchOrderBook:!0,watchOHLCV:!1},urls:{api:{ws:{spot:"wss://socket.coinex.com/",swap:"wss://perpetual.coinex.com/"}}},options:{account:"spot",watchOrderBook:{limits:[5,10,20,50],defaultLimit:50,aggregations:["10","1","0","0.1","0.01"],defaultAggregation:"0"}},streaming:{},exceptions:{codes:{1:nj,2:Ag,3:rj,4:Ih,5:aj,6:ij}},timeframes:{"1m":60,"3m":180,"5m":300,"15m":900,"30m":1800,"1h":3600,"2h":7200,"4h":14400,"6h":21600,"12h":43200,"1d":86400,"3d":259200,"1w":604800}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}handleTicker(e,t){const s=this.safeValue(t,"params",[]),i=this.safeValue(s,0,{}),n=Object.keys(i),r=this.safeString(n,0),a=this.safeSymbol(r),o=this.safeValue(i,r,{}),d=this.safeMarket(r),c=this.parseWSTicker(o,d),u="ticker:"+a;this.tickers[a]=c,e.resolve(c,u)}parseWSTicker(e,t=void 0){return this.safeTicker({symbol:this.safeSymbol(void 0,t),timestamp:void 0,datetime:void 0,high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:this.safeString(e,"buy_total"),ask:void 0,askVolume:this.safeString(e,"sell_total"),vwap:void 0,open:this.safeString(e,"open"),close:this.safeString(e,"close"),last:this.safeString(e,"last"),previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:this.safeString(e,"deal"),info:e},t)}async watchBalance(e={}){await this.loadMarkets(),await this.authenticate(e);const t="balance";let s;[s,e]=this.handleMarketTypeAndParams("watchBalance",void 0,e);const i=this.urls.api.ws[s],r={method:"asset.subscribe",params:Object.keys(this.currencies_by_id),id:this.requestId()},a=this.deepExtend(r,e);return await this.watch(i,t,a,t)}handleBalance(e,t){const s=this.safeValue(t,"params",[]),i=this.safeValue(s,0,{}),n=Object.keys(i);for(let a=0;a<n.length;a++){const o=n[a],d=this.safeCurrencyCode(o),c=this.safeString(i[o],"available"),u=this.safeString(i[o],"frozen"),h=Pg.stringAdd(c,u),l=this.account();l.free=this.parseNumber(c),l.used=this.parseNumber(u),l.total=this.parseNumber(h),this.balance[d]=l,this.balance=this.safeBalance(this.balance)}const r="balance";e.resolve(this.balance,r)}handleTrades(e,t){const s=this.safeValue(t,"params",[]),i=this.safeString(s,0),n=this.safeValue(s,1,[]),r=this.safeMarket(i),a=this.safeSymbol(i),o="trades:"+a;let d=this.safeValue(this.trades,a);if(d===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);d=new oj(c),this.trades[a]=d}for(let c=0;c<n.length;c++){const u=n[c],h=this.parseWSTrade(u,r);d.append(h)}this.trades[a]=d,e.resolve(this.trades[a],o)}parseWSTrade(e,t=void 0){const s=this.safeTimestamp(e,"time");return this.safeTrade({id:this.safeString(e,"id"),info:e,timestamp:s,datetime:this.iso8601(s),symbol:this.safeSymbol(void 0,t),order:void 0,type:void 0,side:this.safeString(e,"type"),takerOrMaker:void 0,price:this.safeString(e,"price"),amount:this.safeString(e,"amount"),cost:void 0,fee:void 0},t)}handleOHLCV(e,t){const s=this.safeValue(t,"params",[]),i="ohlcv",n=this.parseOHLCVs(s);if(Object.keys(this.ohlcvs).length===0){const r=this.safeInteger(this.options,"OHLCVLimit",1e3);this.ohlcvs=new dj(r)}for(let r=0;r<n.length;r++){const a=n[r];this.ohlcvs.append(a)}e.resolve(this.ohlcvs,i)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);let i;[i,t]=this.handleMarketTypeAndParams("watchTicker",s,t);const n=this.urls.api.ws[i],r="ticker:"+e,a={method:"state.subscribe",id:this.requestId(),params:[s.id]},o=this.deepExtend(a,t);return await this.watch(n,r,o,r,o)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;let r;[r,i]=this.handleMarketTypeAndParams("watchTrades",n,i);const a=this.urls.api.ws[r],o="trades:"+e,d={method:"deals.subscribe",params:[n.id],id:this.requestId()},c=this.deepExtend(d,i),u=await this.watch(a,o,c,o,c);return this.filterBySinceLimit(u,t,s,"timestamp",!0)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;let n;[n,s]=this.handleMarketTypeAndParams("watchOrderBook",i,s);const r=this.urls.api.ws[n],o="orderbook"+":"+e,d=this.safeValue(this.options,"watchOrderBook",{}),c=this.safeValue(d,"limits",[]);if(t===void 0&&(t=this.safeValue(d,"defaultLimit",50)),!this.inArray(t,c))throw new Ih(this.id+" watchOrderBook() limit must be one of "+c.join(", "));const u=this.safeString(d,"defaultAggregation","0"),h=this.safeValue(d,"aggregations",[]),l=this.safeString(s,"aggregation",u);if(!this.inArray(l,h))throw new Ih(this.id+" watchOrderBook() aggregation must be one of "+h.join(", "));s=this.omit(s,"aggregation");const p={method:"depth.subscribe",id:this.requestId(),params:[i.id,t,l,!0]},m=this.deepExtend(p,s);return(await this.watch(r,o,m,o)).limit()}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a="ohlcv";let o;if([o,n]=this.handleMarketTypeAndParams("watchOHLCV",r,n),o!=="swap")throw new Ih(this.id+" watchOHLCV() is only supported for swap markets");const d=this.urls.api.ws[o],c={method:"kline.subscribe",id:this.requestId(),params:[r.id,this.safeInteger(this.timeframes,t,t)]},u=this.deepExtend(c,n),h=await this.watch(d,a,u,a);return this.newUpdates&&(i=h.getLimit(e,i)),this.filterBySinceLimit(h,s,i,0,!0)}handleDelta(e,t){const s=this.parseBidAsk(t,0,1);e.storeArray(s)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBook(e,t){const s=this.safeValue(t,"params",[]),i=this.safeValue(s,0);let n=this.safeValue(s,1);const r=this.safeString(s,2),o=this.safeMarket(r).symbol,c="orderbook"+":"+o,u=this.safeNumber(n,"time"),h=this.safeValue(this.orderbooks,o);if(i){const l=this.parseOrderBook(n,o,u);h===void 0?(n=this.orderBook(l),this.orderbooks[o]=n):(n=this.orderbooks[o],n.reset(l))}else{const l=this.safeValue(n,"asks",[]),p=this.safeValue(n,"bids",[]);this.handleDeltas(h.asks,l),this.handleDeltas(h.bids,p),h.nonce=u,h.timestamp=u,h.datetime=this.iso8601(u),this.orderbooks[o]=h}e.resolve(this.orderbooks[o],c)}checkOrderBookChecksum(e){const t=this.safeValue(e,"asks",[]),s=this.safeValue(e,"bids",[]);let i="";const n=s.length;for(let d=0;d<n;d++){const c=s[d];d!==0&&(i+=":"),i+=c[0]+":"+c[1]}const r=t.length;for(let d=0;d<r;d++){const c=t[d];n!==0&&(i+=":"),i+=c[0]+":"+c[1]}const a=this.hash(i,"cr32","hex");if(this.safeString(e,"checksum")!==a)throw new Ag(this.id+" watchOrderBook () checksum failed")}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate(i);let n="orders",r;const[a,o]=this.handleMarketTypeAndParams("watchOrders",r,i),d={method:"order.subscribe",id:this.requestId()};if(e!==void 0)r=this.market(e),e=r.symbol,d.params=[r.id],n+=":"+e;else{const l=Object.keys(this.markets_by_id);d.params=l}const c=this.urls.api.ws[a],u=this.deepExtend(d,o),h=await this.watch(c,n,u,n,u);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySymbolSinceLimit(h,e,t,s,!0)}handleOrders(e,t){const s=this.safeValue(t,"params",[]),i=this.safeValue(s,1,{}),n=this.parseWSOrder(i);if(this.orders===void 0){const a=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new cj(a)}this.orders.append(n);let r="orders";e.resolve(this.orders,r),r+=":"+n.symbol,e.resolve(this.orders,r)}parseWSOrder(e){const t=this.safeTimestamp2(e,"update_time","mtime"),s=this.safeString(e,"market"),i=this.safeString(e,"type"),n=this.safeString({1:"limit",2:"market"},i),r=this.safeString(e,"side"),a=this.safeString({1:"sell",2:"buy"},r),o=this.safeString(e,"left"),d=this.safeString(e,"amount"),c=this.safeString(e,"status"),u=this.safeMarket(s);let h=this.safeString(e,"deal_money"),l=this.safeString(e,"deal_stock"),p;if(u.swap){const y=this.safeString(e,"leverage");h=Pg.stringDiv(l,y),p=Pg.stringDiv(l,d),l=void 0}let m;const g=this.omitZero(this.safeString(e,"money_fee"));if(g!==void 0){const y=this.safeString(e,"fee_asset",u.quote);m={currency:this.safeCurrencyCode(y),cost:g}}return this.safeOrder({info:e,id:this.safeString2(e,"order_id","id"),clientOrderId:this.safeString(e,"client_id"),datetime:this.iso8601(t),timestamp:t,lastTradeTimestamp:this.safeTimestamp(e,"last_deal_time"),symbol:u.symbol,type:n===1?"limit":"market",timeInForce:void 0,postOnly:void 0,side:a,price:this.safeString(e,"price"),stopPrice:this.safeString(e,"stop_price"),amount:d,filled:l,remaining:o,cost:h,average:p,status:this.parseWSOrderStatus(c),fee:m,trades:void 0},u)}parseWSOrderStatus(e){const t={0:"pending",1:"ok"};return this.safeString(t,e,e)}handleMessage(e,t){const s=this.safeValue(t,"error");if(s!==void 0)throw new Ag(this.id+" "+this.json(s));const i=this.safeString(t,"method"),n={"state.update":this.handleTicker,"asset.update":this.handleBalance,"deals.update":this.handleTrades,"depth.update":this.handleOrderBook,"order.update":this.handleOrders,"kline.update":this.handleOHLCV,"order.update_stop":this.handleOrders},r=this.safeValue(n,i);return r!==void 0?r.call(this,e,t):this.handleSubscriptionStatus(e,t)}handleAuthenticationMessage(e,t){const s=this.safeValue(e.futures,"authenticated");return s!==void 0&&s.resolve(!0),t}handleSubscriptionStatus(e,t){const s=this.safeString(t,"id"),i=this.safeValue(e.subscriptions,s);if(i!==void 0){const n=this.safeString(i,"future"),r=this.safeValue(e.futures,n);r!==void 0&&r.resolve(!0),delete e.subscriptions[s]}}authenticate(e={}){let t;[t,e]=this.handleMarketTypeAndParams("authenticate",void 0,e);const s=this.urls.api.ws[t],i=this.client(s),n=this.milliseconds();if(t==="spot"){const r="authenticated:spot";if(this.safeValue(i.futures,r)!==void 0)return;const o=i.future(r),d=this.requestId(),c={id:d,future:"authenticated:spot"},u="access_id="+this.apiKey+"&tonce="+this.numberToString(n)+"&secret_key="+this.secret,h=this.hash(this.encode(u),"md5"),l={method:"server.sign",params:[this.apiKey,h.toUpperCase(),n],id:d};return this.spawn(this.watch,s,r,l,d,c),o}else{const r="authenticated:swap";if(this.safeValue(i.futures,r)!==void 0)return;const o=i.future("authenticated:swap"),d=this.requestId(),c={id:d,future:"authenticated:swap"},u="access_id="+this.apiKey+"&timestamp="+this.numberToString(n)+"&secret_key="+this.secret,h=this.hash(this.encode(u),"sha256","hex"),l={method:"server.sign",params:[this.apiKey,h.toLowerCase(),n],id:d};return this.spawn(this.watch,s,r,l,d,c),o}}};const fj=E_,{AuthenticationError:hj,NotSupported:xh}=oe,{ArrayCache:lj,ArrayCacheByTimestamp:pj,ArrayCacheBySymbolById:mj}=et;var gj=class extends fj{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!1,watchMyTrades:!0,watchTrades:!0,watchOrderBook:!0,watchOrders:!0,watchOHLCV:!0},urls:{api:{ws:{public:"wss://stream.crypto.com/v2/market",private:"wss://stream.crypto.com/v2/user"}},test:{public:"wss://uat-stream.3ona.co/v2/market",private:"wss://uat-stream.3ona.co/v2/user"}},options:{},streaming:{}})}async pong(e,t){await e.send({id:this.safeInteger(t,"id"),method:"public/respond-heartbeat"})}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);if(!i.spot)throw new xh(this.id+" watchOrderBook() supports spot markets only");const n="book."+i.id;return(await this.watchPublic(n,s)).limit()}handleOrderBookSnapshot(e,t){const s=this.safeString(t,"subscription"),i=this.safeString(t,"instrument_name"),r=this.safeMarket(i).symbol;let a=this.safeValue(t,"data");a=this.safeValue(a,0);const o=this.safeInteger(a,"t"),d=this.parseOrderBook(a,r,o);d.nonce=this.safeInteger(a,"s");let c=this.safeValue(this.orderbooks,r);if(c===void 0){const u=this.safeInteger(t,"depth");c=this.orderBook({},u)}c.reset(d),this.orderbooks[r]=c,e.resolve(c,s)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);if(e=n.symbol,!n.spot)throw new xh(this.id+" watchTrades() supports spot markets only");const r="trade."+n.id,a=await this.watchPublic(r,i);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySinceLimit(a,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeString(t,"channel"),i=this.safeString(t,"instrument_name"),n=this.safeString(t,"subscription"),r=this.safeMarket(i),a=r.symbol;let o=this.safeValue(this.trades,a);if(o===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);o=new lj(u),this.trades[a]=o}const d=this.safeValue(t,"data",[]),c=this.parseTrades(d,r);for(let u=0;u<c.length;u++)o.append(c[u]);e.resolve(o,n),e.resolve(o,s)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e),e=n.symbol);let a=this.safeString(this.options,"defaultType","spot")==="margin"?"user.margin.trade":"user.trade";a=n!==void 0?a+"."+n.id:a;const o=await this.watchPrivate(a,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.spot)throw new xh(this.id+" watchTicker() supports spot markets only");const i="ticker."+s.id;return await this.watchPublic(i,t)}handleTicker(e,t){const s=this.safeString(t,"subscription"),i=this.safeString(t,"instrument_name"),n=this.safeMarket(i),r=this.safeValue(t,"data",[]);for(let a=0;a<r.length;a++){const o=r[a],d=this.parseTicker(o,n),c=d.symbol;this.tickers[c]=d,e.resolve(d,s)}}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);if(e=r.symbol,!r.spot)throw new xh(this.id+" watchOHLCV() supports spot markets only");const o="candlestick."+this.timeframes[t]+"."+r.id,d=await this.watchPublic(o,n);return this.newUpdates&&(i=d.getLimit(e,i)),this.filterBySinceLimit(d,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"subscription"),i=this.safeString(t,"instrument_name"),n=this.safeMarket(i),r=n.symbol,a=this.safeString(t,"interval"),o=this.findTimeframe(a);this.ohlcvs[r]=this.safeValue(this.ohlcvs,r,{});let d=this.safeValue(this.ohlcvs[r],o);if(d===void 0){const u=this.safeInteger(this.options,"OHLCVLimit",1e3);d=new pj(u),this.ohlcvs[r][o]=d}const c=this.safeValue(t,"data");for(let u=0;u<c.length;u++){const h=c[u],l=this.parseOHLCV(h,n);d.append(l)}e.resolve(d,s)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e),e=n.symbol);let a=this.safeString(this.options,"defaultType","spot")==="margin"?"user.margin.order":"user.order";a=n!==void 0?a+"."+n.id:a;const o=await this.watchPrivate(a,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleOrders(e,t,s=void 0){const i=this.safeString(t,"channel"),n=this.safeString(t,"subscription"),r=this.safeValue(t,"data",[]);if(r.length>0){if(this.orders===void 0){const c=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new mj(c)}const o=this.orders,d=this.parseOrders(r);for(let c=0;c<d.length;c++)o.append(d[c]);e.resolve(o,n),e.resolve(o,i)}}async watchBalance(e={}){const s=this.safeString(this.options,"defaultType","spot")==="margin"?"user.margin.balance":"user.balance";return await this.watchPrivate(s,e)}handleBalance(e,t){const s=this.safeString(t,"subscription"),i=this.safeValue(t,"data");for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.account();d.free=this.safeString(r,"available"),d.total=this.safeString(r,"balance"),this.balance[o]=d,this.balance=this.safeBalance(this.balance)}e.resolve(this.balance,s)}async watchPublic(e,t={}){const s=this.urls.api.ws.public,i=this.nonce(),n={method:"subscribe",params:{channels:[e]},nonce:i},r=this.extend(n,t);return await this.watch(s,e,r,e)}async watchPrivate(e,t={}){await this.authenticate();const s=this.urls.api.ws.private,i=this.nonce(),n={method:"subscribe",params:{channels:[e]},nonce:i},r=this.extend(n,t);return await this.watch(s,e,r,e)}handleErrorMessage(e,t){const s=this.safeInteger(t,"code");try{if(s!==void 0&&s!==0){const i=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,i);const n=this.safeValue(t,"message");n!==void 0&&this.throwBroadlyMatchedException(this.exceptions.broad,n,i)}}catch(i){if(i instanceof hj)return e.reject(i,"authenticated"),"public/auth"in e.subscriptions&&delete e.subscriptions["public/auth"],!1;e.reject(i)}return t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;const s=this.safeString(t,"method");if(s==="public/heartbeat"){this.handlePing(e,t);return}if(s==="public/auth"){this.handleAuthenticate(e,t);return}const i={candlestick:this.handleOHLCV,ticker:this.handleTicker,trade:this.handleTrades,book:this.handleOrderBookSnapshot,"user.order":this.handleOrders,"user.margin.order":this.handleOrders,"user.trade":this.handleTrades,"user.margin.trade":this.handleTrades,"user.balance":this.handleBalance,"user.margin.balance":this.handleBalance},n=this.safeValue2(t,"result","info"),r=this.safeString(n,"channel"),a=this.safeValue(i,r);a!==void 0&&a.call(this,e,n)}async authenticate(e={}){const t=this.urls.api.ws.private;this.checkRequiredCredentials();const s=this.client(t),i=s.future("authenticated"),n="public/auth";if(this.safeValue(s.subscriptions,n)===void 0){const a=this.nonce().toString(),o=n+a+this.apiKey+a,d=this.hmac(this.encode(o),this.encode(this.secret),"sha256"),c={id:a,nonce:a,method:n,api_key:this.apiKey,sig:d};this.spawn(this.watch,t,n,this.extend(c,e),n)}return await i}handlePing(e,t){this.spawn(this.pong,e,t)}handleAuthenticate(e,t){return e.futures.authenticated.resolve(1),e.resolve(1,"public/auth"),t}};const yj=V_,bj=ke,{ArrayCache:wj,ArrayCacheByTimestamp:Sj}=et;var kj=class extends yj{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchOrderBook:!0,watchOHLCV:!0},urls:{api:{ws:"wss://api-adapter.backend.currency.com/connect"}},options:{tradesLimit:1e3,OHLCVLimit:1e3,timeframes:{"1m":"M1","3m":"M3","5m":"M5","15m":"M15","30m":"M30","1h":"H1","4h":"H4","1d":"D1","1w":"W1"}},streaming:{ping:this.ping,keepAlive:2e4}})}ping(e){return{destination:"ping",correlationId:this.requestId().toString(),payload:{}}}handlePong(e,t){return e.lastPong=this.milliseconds(),t}handleBalance(e,t,s){const i=this.safeValue(t,"payload"),n=this.parseBalance(i);this.balance=this.extend(this.balance,n);const r=this.safeString(s,"messageHash");e.resolve(this.balance,r),r in e.subscriptions&&delete e.subscriptions[r]}handleTicker(e,t,s){const i="/api/v1/ticker/24hr",n=this.safeValue(t,"payload"),r=this.safeValue(n,"tickers",[]);for(let a=0;a<r.length;a++){const o=this.parseTicker(r[a]),d=o.symbol;this.tickers[d]=o;const c=i+":"+d;e.resolve(o,c),c in e.subscriptions&&delete e.subscriptions[c]}}handleTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,void 0,"/"),n=this.safeInteger(e,"ts"),r=this.safeString(e,"price"),a=this.safeString(e,"size"),o=this.parseNumber(bj.stringMul(r,a)),d=this.parseNumber(r),c=this.parseNumber(a),u=this.safeString2(e,"id"),h=this.safeString(e,"orderId"),p=this.safeValue(e,"buyer")?"buy":"sell";return{info:e,timestamp:n,datetime:this.iso8601(n),symbol:i,id:u,order:h,type:void 0,takerOrMaker:void 0,side:p,price:d,amount:c,cost:o,fee:void 0}}handleTrades(e,t,s){const i=this.safeValue(t,"payload"),n=this.handleTrade(i),r=n.symbol,o="trades.subscribe"+":"+r;let d=this.safeValue(this.trades,r);if(d===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);d=new wj(c),this.trades[r]=d}d.append(n),e.resolve(d,o)}findTimeframe(e){const t=this.safeValue(this.options,"timeframes"),s=Object.keys(t);for(let i=0;i<s.length;i++){const n=s[i];if(t[n]===e)return n}}handleOHLCV(e,t){const s="OHLCMarketData.subscribe",i=this.safeValue(t,"payload",{}),n=this.safeString(i,"interval"),r=this.findTimeframe(n),a=this.safeString(i,"symbol"),d=this.safeMarket(a).symbol,c=s+":"+r+":"+d,u=[this.safeInteger(i,"t"),this.safeNumber(i,"o"),this.safeNumber(i,"h"),this.safeNumber(i,"l"),this.safeNumber(i,"c"),void 0];this.ohlcvs[d]=this.safeValue(this.ohlcvs,d,{});let h=this.safeValue(this.ohlcvs[d],r);if(h===void 0){const l=this.safeInteger(this.options,"OHLCVLimit",1e3);h=new Sj(l),this.ohlcvs[d][r]=h}h.append(u),e.resolve(h,c)}requestId(){const e=this.sum(this.safeInteger(this.options,"correlationId",0),1);return this.options.correlationId=e,e}async watchPublic(e,t,s={}){await this.loadMarkets();const i=this.market(t);t=i.symbol;const n=e+":"+t,r=this.urls.api.ws,a=this.requestId().toString(),o=this.deepExtend({destination:e,correlationId:a,payload:{symbols:[i.id]}},s),d=this.extend(o,{messageHash:n,symbol:t});return await this.watch(r,n,o,n,d)}async watchPrivate(e,t={}){await this.loadMarkets();const s="/api/v1/account",i=this.urls.api.ws,n=this.requestId().toString(),r={timestamp:this.milliseconds(),apiKey:this.apiKey},a=this.urlencode(this.keysort(r)),o=this.deepExtend({destination:e,correlationId:n,payload:r},t);o.payload.signature=this.hmac(this.encode(a),this.encode(this.secret));const d=this.extend(o,{messageHash:s});return await this.watch(i,s,o,s,d)}async watchBalance(e={}){return await this.loadMarkets(),await this.watchPrivate("/api/v1/account",e)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i="/api/v1/ticker/24hr",n=i+":"+e,r=this.urls.api.ws,a=this.requestId().toString(),o=this.deepExtend({destination:i,correlationId:a,payload:{symbol:s.id}},t),d=this.extend(o,{messageHash:n,symbol:e});return await this.watch(r,n,o,n,d)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.watchPublic("trades.subscribe",e,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}async watchOrderBook(e,t=void 0,s={}){return await this.loadMarkets(),e=this.symbol(e),(await this.watchPublic("depthMarketData.subscribe",e,s)).limit()}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets(),e=this.symbol(e);const r="OHLCMarketData.subscribe",a=r+":"+t,o=this.safeValue(this.options,"timeframes"),d={destination:r,payload:{intervals:[o[t]]}},c=await this.watchPublic(a,e,this.extend(d,n));return this.newUpdates&&(i=c.getLimit(e,i)),this.filterBySinceLimit(c,s,i,0,!0)}handleDeltas(e,t){const s=Object.keys(t);for(let i=0;i<s.length;i++){const n=s[i],r=t[n];e.store(parseFloat(n),parseFloat(r))}}handleOrderBook(e,t){const s=this.safeValue(t,"payload",{}),i=this.safeValue(s,"data",{}),n=this.safeString(s,"symbol"),r=this.safeSymbol(n,void 0,"/"),o="depthMarketData.subscribe"+":"+r,d=this.safeInteger(i,"ts");let c=this.safeValue(this.orderbooks,r);c===void 0&&(c=this.orderBook()),c.reset({timestamp:d,datetime:this.iso8601(d)});const u=this.safeValue(i,"bid",{}),h=this.safeValue(i,"ofr",{});this.handleDeltas(c.bids,u),this.handleDeltas(c.asks,h),this.orderbooks[r]=c,e.resolve(c,o)}handleMessage(e,t){const s=this.safeString(t,"correlationId");if(s!==void 0){const n=this.indexBy(e.subscriptions,"correlationId"),r=this.safeString(t,"status"),a=this.safeValue(n,s);if(a!==void 0&&r==="OK"){const o=this.safeString(a,"destination");if(o!==void 0){const d={"/api/v1/ticker/24hr":this.handleTicker,"/api/v1/account":this.handleBalance},c=this.safeValue(d,o);return c===void 0?t:c.call(this,e,t,a)}}}const i=this.safeString(t,"destination");if(i!==void 0){const n={"marketdepth.event":this.handleOrderBook,"internal.trade":this.handleTrades,"ohlc.event":this.handleOHLCV,ping:this.handlePong},r=this.safeValue(n,i);return r===void 0?t:r.call(this,e,t)}}};const vj=q_,{NotSupported:XT,ExchangeError:Tj}=oe,{ArrayCache:Oj,ArrayCacheBySymbolById:YT,ArrayCacheByTimestamp:Ij}=et;var xj=class extends vj{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchMyTrades:!0,watchOrders:!0,watchOrderBook:!0,watchOHLCV:!0},urls:{test:{ws:"wss://test.deribit.com/ws/api/v2"},api:{ws:"wss://www.deribit.com/ws/api/v2"}},options:{timeframes:{"1m":1,"3m":3,"5m":5,"15m":15,"30m":30,"1h":60,"2h":120,"4h":180,"6h":360,"12h":720,"1d":"1D"},currencies:["BTC","ETH","SOL","USDC"]},streaming:{},exceptions:{}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}async watchBalance(e={}){await this.authenticate(e);const t="balance",s=this.urls.api.ws,i=this.safeValue(this.options,"currencies",[]),n=[];for(let o=0;o<i.length;o++){const d=i[o];n.push("user.portfolio."+d)}const r={jsonrpc:"2.0",method:"private/subscribe",params:{channels:n},id:this.requestId()},a=this.deepExtend(r,e);return await this.watch(s,t,a,t,a)}handleBalance(e,t){const s=this.safeValue(t,"params",{}),i=this.safeValue(s,"data",{}),n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.parseBalance(i);this.balance[r]=a;const o="balance";e.resolve(this.balance,o)}async watchTicker(e,t={}){const s=this.market(e),i=this.urls.api.ws,n=this.safeString(t,"interval","100ms");t=this.omit(t,"interval"),await this.loadMarkets(),n==="raw"&&await this.authenticate();const r="ticker."+s.id+"."+n,a={jsonrpc:"2.0",method:"public/subscribe",params:{channels:["ticker."+s.id+"."+n]},id:this.requestId()},o=this.deepExtend(a,t);return await this.watch(i,r,o,r,o)}handleTicker(e,t){const s=this.safeValue(t,"params",{}),i=this.safeValue(s,"data",{}),n=this.safeString(i,"instrument_name"),r=this.safeSymbol(n),a=this.parseTicker(i),o=this.safeString(s,"channel");this.tickers[r]=a,e.resolve(a,o)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r=this.urls.api.ws,a=this.safeString(i,"interval","100ms");i=this.omit(i,"interval");const o="trades."+n.id+"."+a;a==="raw"&&await this.authenticate();const d={jsonrpc:"2.0",method:"public/subscribe",params:{channels:[o]},id:this.requestId()},c=this.deepExtend(d,i),u=await this.watch(r,o,c,o,c);return this.filterBySinceLimit(u,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"params",{}),i=this.safeString(s,"channel",""),n=i.split("."),r=this.safeString(n,1),a=this.safeSymbol(r),o=this.safeMarket(r),d=this.safeValue(s,"data",[]);let c=this.safeValue(this.trades,a);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new Oj(u),this.trades[a]=c}for(let u=0;u<d.length;u++){const h=d[u],l=this.parseTrade(h,o);c.append(l)}this.trades[a]=c,e.resolve(this.trades[a],i)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.authenticate(i),e!==void 0&&(await this.loadMarkets(),e=this.symbol(e));const n=this.urls.api.ws,r=this.safeString(i,"interval","raw");i=this.omit(i,"interval");const a="user.trades.any.any."+r,o={jsonrpc:"2.0",method:"private/subscribe",params:{channels:[a]},id:this.requestId()},d=this.deepExtend(o,i),c=await this.watch(n,a,d,a,d);return this.filterBySymbolSinceLimit(c,e,t,s,!0)}handleMyTrades(e,t){const s=this.safeValue(t,"params",{}),i=this.safeString(s,"channel",""),n=this.safeValue(s,"data",[]);let r=this.myTrades;if(r===void 0){const o=this.safeInteger(this.options,"tradesLimit",1e3);r=new YT(o)}const a=this.parseTrades(n);for(let o=0;o<a.length;o++){const d=a[o];r.append(d),d.symbol}e.resolve(r,i)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n=this.urls.api.ws,r=this.safeString(s,"interval","100ms");s=this.omit(s,"interval"),r==="raw"&&await this.authenticate();const a="book."+i.id+"."+r,o={jsonrpc:"2.0",method:"public/subscribe",params:{channels:[a]},id:this.requestId()},d=this.deepExtend(o,s);return(await this.watch(n,a,d,a)).limit()}handleOrderBook(e,t){const s=this.safeValue(t,"params",{}),i=this.safeValue(s,"data",{}),n=this.safeString(s,"channel"),r=this.safeString(i,"instrument_name"),a=this.safeSymbol(r),o=this.safeNumber(i,"timestamp");let d=this.safeValue(this.orderbooks,a);d===void 0&&(d=this.countedOrderBook());const c=this.safeValue(i,"asks",[]),u=this.safeValue(i,"bids",[]);this.handleDeltas(d.asks,c),this.handleDeltas(d.bids,u),d.nonce=o,d.timestamp=o,d.datetime=this.iso8601(o),d.symbol=a,this.orderbooks[a]=d,e.resolve(d,n)}cleanOrderBook(e){const t=this.safeValue(e,"bids",[]),s=this.safeValue(e,"asks",[]),i=[];for(let r=0;r<t.length;r++)i.push([t[r][1],t[r][2]]);const n=[];for(let r=0;r<s.length;r++)n.push([s[r][1],s[r][2]]);return e.bids=i,e.asks=n,e}handleDelta(e,t){const s=t[1],i=t[2];t[0]==="new"||t[0]==="change"?e.store(s,i,1):t[0]==="delete"&&e.store(s,i,0)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate(i),e!==void 0&&(e=this.symbol(e));const n=this.urls.api.ws,r=this.safeString(i,"currency","any"),a=this.safeString(i,"interval","raw"),o=this.safeString(i,"kind","any");i=this.omit(i,"interval","currency","kind");const d="user.orders."+o+"."+r+"."+a,c={jsonrpc:"2.0",method:"private/subscribe",params:{channels:[d]},id:this.requestId()},u=this.deepExtend(c,i),h=await this.watch(n,d,u,d,u);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySymbolSinceLimit(h,e,t,s,!0)}handleOrders(e,t){if(this.orders===void 0){const a=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new YT(a)}const s=this.safeValue(t,"params",{}),i=this.safeString(s,"channel",""),n=this.safeValue(s,"data",{});let r=[];this.isArray(n)?r=this.parseOrders(n):r=[this.parseOrder(n)];for(let a=0;a<r.length;a++)this.orders.append(r[a]);e.resolve(this.orders,i)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.urls.api.ws,o=this.safeValue(this.options,"timeframes",{}),d=this.safeString(o,t);if(d===void 0)throw new XT(this.id+" this interval is not supported, please provide one of the supported timeframes");const c="chart.trades."+r.id+"."+d,u={jsonrpc:"2.0",method:"public/subscribe",params:{channels:[c]},id:this.requestId()},h=this.deepExtend(u,n),l=await this.watch(a,c,h,c,h);return this.newUpdates&&(i=l.getLimit(r.symbol,i)),this.filterBySinceLimit(l,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"params",{}),i=this.safeString(s,"channel",""),n=i.split("."),r=this.safeString(n,2),a=this.safeSymbol(r),o=this.safeValue(s,"data",{}),d=[this.safeNumber(o,"tick"),this.safeNumber(o,"open"),this.safeNumber(o,"high"),this.safeNumber(o,"low"),this.safeNumber(o,"close"),this.safeNumber(o,"volume")];let c=this.safeValue(this.ohlcvs,a);if(c===void 0){const u=this.safeInteger(this.options,"OHLCVLimit",1e3);c=new Ij(u)}c.append(d),this.ohlcvs[a]=c,e.resolve(c,i)}handleMessage(e,t){const s=this.safeValue(t,"error");if(s!==void 0)throw new Tj(this.id+" "+this.json(s));const i=this.safeValue(t,"params"),n=this.safeString(i,"channel");if(n!==void 0){const o=n.split("."),d=this.safeString(o,0),c={trades:this.handleMyTrades,portfolio:this.handleBalance,orders:this.handleOrders},u={ticker:this.handleTicker,book:this.handleOrderBook,trades:this.handleTrades,chart:this.handleOHLCV,user:this.safeValue(c,this.safeString(o,1))},h=this.safeValue(u,d);if(h!==void 0)return h.call(this,e,t);throw new XT(this.id+" no handler found for this message "+this.json(t))}const r=this.safeValue(t,"result",{});return this.safeString(r,"access_token")!==void 0?this.handleAuthenticationMessage(e,t):t}handleAuthenticationMessage(e,t){const s=this.safeValue(e.futures,"authenticated");return s!==void 0&&s.resolve(!0),t}async authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i=this.milliseconds(),n=this.numberToString(i),r=n,a="authenticated",o=s.future("authenticated");if(this.safeValue(s.subscriptions,a)===void 0){this.checkRequiredCredentials();const c=this.requestId(),u=this.hmac(this.encode(n+`
`+r+`
`),this.encode(this.secret),"sha256"),h={jsonrpc:"2.0",id:c,method:"public/auth",params:{grant_type:"client_signature",client_id:this.apiKey,timestamp:i,signature:u,nonce:r,data:""}};this.spawn(this.watch,t,a,this.extend(h,e),a)}return await o}};const _j=L_,{NotSupported:Cj}=oe,{ArrayCache:Mj,ArrayCacheBySymbolById:Pj}=et;var Aj=class extends _j{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchMyTrades:!0,watchOrders:!1,watchOrderBook:!0,watchOHLCV:!1},urls:{api:{ws:{public:"wss://ws-api.exmo.com:443/v1/public",spot:"wss://ws-api.exmo.com:443/v1/private",margin:"wss://ws-api.exmo.com:443/v1/margin/private"}}},options:{},streaming:{},exceptions:{}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}async watchBalance(e={}){await this.authenticate(e);const[t,s]=this.handleMarketTypeAndParams("watchBalance",void 0,e),i="balance:"+t,n=this.urls.api.ws[t],r={method:"subscribe",topics:[t+"/wallet"],id:this.requestId()},a=this.deepExtend(r,s);return await this.watch(n,i,a,i,a)}handleBalance(e,t){const i=this.safeString(t,"topic").split("/"),n=this.safeString(i,0);n==="spot"?this.parseSpotBalance(t):n==="margin"&&this.parseMarginBalance(t);const r="balance:"+n;e.resolve(this.balance,r)}parseSpotBalance(e){const t=this.safeString(e,"event"),s=this.safeValue(e,"data");if(t==="snapshot"){const i=this.safeValue(s,"balances",{}),n=this.safeValue(s,"reserved",{}),r=Object.keys(i);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeCurrencyCode(o),c=i[o],u=n[o],h=this.account();h.free=this.parseNumber(c),h.used=this.parseNumber(u),this.balance[d]=h}}else if(t==="update"){const i=this.safeString(s,"currency"),n=this.safeCurrencyCode(i),r=this.account();r.free=this.safeNumber(s,"balance"),r.used=this.safeNumber(s,"reserved"),this.balance[n]=r}this.balance=this.safeBalance(this.balance)}parseMarginBalance(e){const t=this.safeValue(e,"data"),s=Object.keys(t);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeCurrencyCode(n),a=this.safeValue(t,n),o=this.account();o.free=this.safeNumber(a,"free"),o.used=this.safeNumber(a,"used"),o.total=this.safeNumber(a,"balance"),this.balance[r]=o,this.balance=this.safeBalance(this.balance)}}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i=this.urls.api.ws.public,n="ticker:"+e,r={method:"subscribe",topics:["spot/ticker:"+s.id],id:this.requestId()},a=this.deepExtend(r,t);return await this.watch(i,n,a,n,a)}handleTicker(e,t){const i=this.safeString(t,"topic").split(":"),n=this.safeString(i,1),r=this.safeSymbol(n),a=this.safeValue(t,"data",{}),o=this.safeMarket(n),d=this.parseTicker(a,o),c="ticker:"+r;this.tickers[r]=d,e.resolve(d,c)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r=this.urls.api.ws.public,a="trades:"+e,o={method:"subscribe",topics:["spot/trades:"+n.id],id:this.requestId()},d=this.deepExtend(o,i),c=await this.watch(r,a,d,a,d);return this.filterBySinceLimit(c,t,s,"timestamp",!0)}handleTrades(e,t){const i=this.safeString(t,"topic").split(":"),n=this.safeString(i,1),r=this.safeSymbol(n),a=this.safeMarket(n),o=this.safeValue(t,"data",[]),d="trades:"+r;let c=this.safeValue(this.trades,r);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new Mj(u),this.trades[r]=c}for(let u=0;u<o.length;u++){const h=o[u],l=this.parseTrade(h,a);c.append(l)}this.trades[r]=c,e.resolve(this.trades[r],d)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate(i);const[n,r]=this.handleMarketTypeAndParams("watchMyTrades",void 0,i),a=this.urls.api.ws[n];let o;if(e===void 0)o="myTrades:"+n;else{const h=this.market(e);e=h.symbol,o="myTrades:"+h.symbol}const d={method:"subscribe",topics:[n+"/user_trades"],id:this.requestId()},c=this.deepExtend(d,r),u=await this.watch(a,o,c,o,c);return this.filterBySymbolSinceLimit(u,e,t,s,!0)}handleMyTrades(e,t){const i=this.safeString(t,"topic").split("/"),r="myTrades:"+this.safeString(i,0),a=this.safeString(t,"event");let o=[],d;if(this.myTrades===void 0){const l=this.safeInteger(this.options,"tradesLimit",1e3);d=new Pj(l),this.myTrades=d}else d=this.myTrades;a==="snapshot"?o=this.safeValue(t,"data",[]):a==="update"&&(o=[this.safeValue(t,"data",{})]);const c=this.parseTrades(o),u={};for(let l=0;l<c.length;l++){const p=c[l];d.append(p),u[p.symbol]=!0}const h=Object.keys(u);for(let l=0;l<h.length;l++){const m="myTrades:"+h[l];e.resolve(d,m)}e.resolve(d,r)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n=this.urls.api.ws.public,r="orderbook:"+e;s=this.omit(s,"aggregation");const a={method:"subscribe",id:this.requestId(),topics:["spot/order_book_updates:"+i.id]},o=this.deepExtend(a,s);return(await this.watch(n,r,o,r)).limit()}handleOrderBook(e,t){const i=this.safeString(t,"topic").split(":"),n=this.safeString(i,1),r=this.safeSymbol(n),a=this.safeValue(t,"data",{}),o="orderbook:"+r,d=this.safeNumber(t,"ts");let c=this.safeValue(this.orderbooks,r);if(c===void 0&&(c=this.orderBook({}),this.orderbooks[r]=c),this.safeString(t,"event")==="snapshot"){const h=this.parseOrderBook(a,r,d,"bid","ask");c.reset(h)}else{const h=this.safeValue(a,"ask",[]),l=this.safeValue(a,"bid",[]);this.handleDeltas(c.asks,h),this.handleDeltas(c.bids,l),c.timestamp=d,c.datetime=this.iso8601(d)}e.resolve(c,o)}handleDelta(e,t){const s=this.parseBidAsk(t,0,1);e.storeArray(s)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleMessage(e,t){const s=this.safeString(t,"event");if(s==="logged_in")return this.handleAuthenticationMessage(e,t);if(s==="update"||s==="snapshot"){const i=this.safeString(t,"topic");if(i!==void 0){const n=i.split(":"),r=this.safeString(n,0),a={"spot/ticker":this.handleTicker,"spot/wallet":this.handleBalance,"margin/wallet":this.handleBalance,"margin/wallets":this.handleBalance,"spot/trades":this.handleTrades,"margin/trades":this.handleTrades,"spot/order_book_updates":this.handleOrderBook,"spot/user_trades":this.handleMyTrades,"margin/user_trades":this.handleMyTrades},o=this.safeValue(a,r);if(o!==void 0)return o.call(this,e,t)}}if(s==="info")return this.handleInfo(e,t);if(s==="subscribed")return this.handleSubscribed(e,t);throw new Cj(this.id+" received an unsupported message: "+this.json(t))}handleSubscribed(e,t){return t}handleInfo(e,t){return t}handleAuthenticationMessage(e,t){const s=this.safeValue(e.futures,"authenticated");s!==void 0&&s.resolve(!0)}async authenticate(e={}){const[t,s]=this.handleMarketTypeAndParams("authenticate",void 0,e),i=this.urls.api.ws[t],n=this.client(i),r=this.milliseconds(),a="authenticated",o=n.future("authenticated");if(this.safeValue(n.subscriptions,a)===void 0){this.checkRequiredCredentials();const c=this.requestId(),u=this.apiKey+r.toString(),h=this.hmac(this.encode(u),this.encode(this.secret),"sha512","base64"),l={method:"login",id:c,api_key:this.apiKey,sign:h,nonce:r};this.spawn(this.watch,i,a,this.extend(l,s),a)}return await o}};const Bj=Tb,{AuthenticationError:_h,BadRequest:Nj,ArgumentsRequired:Ej,NotSupported:Vj,InvalidNonce:qj}=oe,{ArrayCache:Lj,ArrayCacheByTimestamp:Rj,ArrayCacheBySymbolById:QT}=et;var tC=class extends Bj{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchMyTrades:!0,watchOHLCV:!0,watchBalance:!0,watchOrders:!0},urls:{api:{ws:"wss://ws.gate.io/v4",spot:"wss://api.gateio.ws/ws/v4/",swap:{usdt:"wss://fx-ws.gateio.ws/v4/ws/usdt",btc:"wss://fx-ws.gateio.ws/v4/ws/btc"},future:{usdt:"wss://fx-ws.gateio.ws/v4/ws/delivery/usdt",btc:"wss://fx-ws.gateio.ws/v4/ws/delivery/btc"},option:"wss://op-ws.gateio.live/v4/ws"},test:{swap:{usdt:"wss://fx-ws-testnet.gateio.ws/v4/ws/usdt",btc:"wss://fx-ws-testnet.gateio.ws/v4/ws/btc"},future:{usdt:"wss://fx-ws-testnet.gateio.ws/v4/ws/usdt",btc:"wss://fx-ws-testnet.gateio.ws/v4/ws/btc"},option:"wss://op-ws-testnet.gateio.live/v4/ws"}},options:{tradesLimit:1e3,OHLCVLimit:1e3,watchTradesSubscriptions:{},watchTickerSubscriptions:{},watchOrderBookSubscriptions:{},watchOrderBook:{interval:"100ms"},watchBalance:{settle:"usdt",spot:"spot.balances"}},exceptions:{ws:{exact:{2:Nj,4:_h,6:_h,11:_h}}}})}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n=i.id,r=this.safeValue(this.options,"watchOrderBook",{}),a=this.safeInteger(r,"limit",20);t||(t=a);const o=this.safeString(r,"interval","100ms"),d=this.safeString(s,"interval",o),c=i.type,h=this.getUniformType(c)+".order_book_update",l=h+":"+i.symbol,p=this.getUrlByMarketType(c,i.inverse),m=[n,d];if(c!=="spot"){const b=t.toString();m.push(b)}const g={method:this.handleOrderBookSubscription,symbol:e,limit:t};return(await this.subscribePublic(p,h,l,m,g)).limit()}handleOrderBookSubscription(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit");i in this.orderbooks&&delete this.orderbooks[i],this.orderbooks[i]=this.orderBook({},n);const r=this.safeValue(this.options,"handleOrderBookSubscription",{});if(this.safeValue(r,"fetchOrderBookSnapshot",!1)){const o="fetchingOrderBookSnapshot";s[o]=!0;const d=s.messageHash;e.subscriptions[d]=s,this.spawn(this.fetchOrderBookSnapshot,e,t,s)}}async fetchOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit"),r=this.safeString(s,"messageHash");try{const a=await this.fetchOrderBook(i,n),o=this.orderbooks[i],d=o.cache,c=this.safeValue(d,0,{}),u=this.safeValue(c,"result"),h=this.safeInteger(u,"U"),l=this.safeInteger(a,"nonce");if(h===void 0||l<h){const p=this.safeInteger(this.options,"maxOrderBookSyncAttempts",3);let m=this.safeInteger(s,"numAttempts",0);if(m<p)r in e.subscriptions&&(m=this.sum(m,1),s.numAttempts=m,e.subscriptions[r]=s,this.spawn(this.fetchOrderBookSnapshot,e,t,s));else throw delete e.subscriptions[r],new qj(this.id+" failed to synchronize WebSocket feed with the snapshot for symbol "+i+" in "+p.toString()+" attempts")}else{o.reset(a);for(let p=0;p<d.length;p++){const m=d[p];this.handleOrderBookMessage(e,m,o)}this.orderbooks[i]=o,e.resolve(o,r)}}catch(a){e.reject(a,r)}}handleOrderBook(e,t){const s=this.safeString(t,"channel"),i=this.safeValue(t,"result"),n=this.safeString(i,"s"),r=this.safeSymbol(n);let a=this.safeValue(this.orderbooks,r);a===void 0&&(a=this.orderBook({}),this.orderbooks[r]=a);const o=s+":"+r,d=this.safeValue(e.subscriptions,o,{}),c="fetchingOrderBookSnapshot";if(this.safeValue(d,c,!1)||(d[c]=!0,e.subscriptions[o]=d,this.spawn(this.fetchOrderBookSnapshot,e,t,d)),a.nonce===void 0)a.cache.push(t);else{const h=s+":"+r;this.handleOrderBookMessage(e,t,a,h)}}handleOrderBookMessage(e,t,s,i=void 0){const n=this.safeValue(t,"result"),r=this.safeInteger(n,"u"),a=s.nonce;if(r>=a){const o=this.safeValue(n,"a",[]),d=this.safeValue(n,"b",[]);this.handleDeltas(s.asks,o),this.handleDeltas(s.bids,d),s.nonce=r;const c=this.safeInteger(n,"t");s.timestamp=c,s.datetime=this.iso8601(c),i!==void 0&&e.resolve(s,i)}return s}handleDelta(e,t){let s,i;Array.isArray(t)?(s=this.safeFloat(t,0),i=this.safeFloat(t,1)):(s=this.safeFloat(t,"p"),i=this.safeFloat(t,"s")),e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=s.id,n=s.type,a=this.getUniformType(n)+".tickers",o=a+"."+s.symbol,d=[i],c=this.getUrlByMarketType(n,s.inverse);return await this.subscribePublic(c,a,o,d)}handleTicker(e,t){const s=this.safeString(t,"channel");let i=this.safeValue(t,"result");Array.isArray(i)||(i=[i]);for(let n=0;n<i.length;n++){const r=i[n],a=this.parseTicker(r),o=a.symbol;this.tickers[o]=a;const d=s+"."+o;e.resolve(this.tickers[o],d)}}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r=n.id,a=n.type,d=this.getUniformType(a)+".trades";let c=d;e!==void 0&&(c+=":"+n.symbol);const u=this.getUrlByMarketType(a,n.inverse),h=[r],l=await this.subscribePublic(u,d,c,h);return this.newUpdates&&(s=l.getLimit(e,s)),this.filterBySinceLimit(l,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeString(t,"channel");let i=this.safeValue(t,"result");Array.isArray(i)||(i=[i]);const n=this.parseTrades(i),r={};for(let o=0;o<n.length;o++){const d=n[o],c=d.symbol;let u=this.safeValue(this.trades,c);if(u===void 0){const h=this.safeInteger(this.options,"tradesLimit",1e3);u=new Lj(h),this.trades[c]=u}u.append(d),r[c]=!0}const a=Object.keys(r);for(let o=0;o<a.length;o++){const d=a[o],c=s+":"+d,u=this.safeValue(this.trades,d);e.resolve(u,c)}e.resolve(this.trades,s)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=r.id,o=r.type,d=this.timeframes[t],u=this.getUniformType(o)+".candlesticks",h=u+":"+d+":"+r.symbol,l=this.getUrlByMarketType(o,r.inverse),p=[d,a],m=await this.subscribePublic(l,u,h,p);return this.newUpdates&&(i=m.getLimit(e,i)),this.filterBySinceLimit(m,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"channel");let i=this.safeValue(t,"result");Array.isArray(i)||(i=[i]);const r={};for(let o=0;o<i.length;o++){const d=i[o],c=this.safeString(d,"n",""),u=c.split("_"),h=this.safeString(u,0),l=h+"_",p=c.replace(l,""),m=this.safeSymbol(p,void 0,"_"),g=this.parseOHLCV(d);let y=this.safeValue(this.ohlcvs,m);if(y===void 0){const b=this.safeInteger(this.options,"OHLCVLimit",1e3);y=new Rj(b),this.ohlcvs[m]=y}y.append(g),r[m]=h}const a=Object.keys(r);for(let o=0;o<a.length;o++){const d=a[o],c=r[d],u=this.timeframes[c],h=s+":"+u+":"+d,l=this.safeValue(this.ohlcvs,d);e.resolve(l,h)}}async authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i=s.future("authenticated"),n="server.sign";if(this.safeValue(s.subscriptions,n)===void 0){const a=this.milliseconds(),o=a.toString(),d=this.hmac(this.encode(o),this.encode(this.secret),"sha512","hex"),c={id:a,method:n,params:[this.apiKey,d,a]},u={id:a,method:this.handleAuthenticationMessage};this.spawn(this.watch,t,a,c,n,u)}return await i}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r,a="!all";if(e!==void 0){const g=this.market(e);e=g.symbol,r=g.type,a=g.id}else if([r,i]=this.handleMarketTypeAndParams("watchMyTrades",void 0,i),r!=="spot"){const g=this.safeValue(this.options,"watchMyTrades",{});n=this.safeValue(g,"subType","linear"),n=this.safeValue(i,"subType",n),i=this.omit(i,"subType")}const d=this.getUniformType(r)+".usertrades";let c=d;e!==void 0&&(c+=":"+e);const u=n==="inverse",h=this.getUrlByMarketType(r,u),l=[a],p=r!=="spot",m=await this.subscribePrivate(h,d,c,l,p);return this.newUpdates&&(s=m.getLimit(e,s)),this.filterBySymbolSinceLimit(m,e,t,s,!0)}handleMyTrades(e,t){const s=this.safeValue(t,"result",[]),i=this.safeString(t,"channel");if(s.length===0)return;let r=this.myTrades;if(r===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);r=new QT(c),this.myTrades=r}const a=this.parseTrades(s),o={};for(let c=0;c<a.length;c++){const u=a[c];r.append(u);const h=u.symbol;o[h]=!0}const d=Object.keys(o);for(let c=0;c<d.length;c++){const u=d[c],h=i+":"+u;e.resolve(r,h)}e.resolve(r,i)}async watchBalance(e={}){await this.loadMarkets();let t;[t,e]=this.handleMarketTypeAndParams("watchBalance",void 0,e);const s=this.safeValue(this.options,"watchBalance",{});let i=this.safeValue(s,"subType","linear");i=this.safeValue(e,"subType",i),e=this.omit(e,"subType");const n=i==="inverse",r=this.getUrlByMarketType(t,n),a=t!=="spot";let o="spot";t==="future"||t==="swap"?o="futures":t==="option"&&(o="options");let d;if(t==="spot"){const c=this.safeValue(this.options,"watchTicker",{});d=this.safeString(c,"spot","spot.balances")}else d=o+".balances";return await this.subscribePrivate(r,d,d,void 0,a)}handleBalance(e,t){const s=t.method,i=t.params[0];this.handleBalanceMessage(e,s,i)}handleBalanceMessage(e,t){const s=this.safeString(t,"channel"),i=this.safeValue(t,"result",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.account(),o=this.safeString(r,"currency","USDT"),d=this.safeCurrencyCode(o);a.free=this.safeString(r,"available"),a.total=this.safeString2(r,"total","balance"),this.balance[d]=a}this.balance=this.safeBalance(this.balance),e.resolve(this.balance,s)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e),e=n.symbol);let r,a;[r,a]=this.handleMarketTypeAndParams("watchOrders",n,i);const d=this.getSupportedMapping(r,{spot:"spot",margin:"spot",future:"futures",swap:"futures",option:"options"})+".orders";let c=d,u=["!all"];e!==void 0&&(c=d+":"+n.id,u=[n.id]);let h;[h,a]=this.handleSubTypeAndParams("watchOrders",n,a);const l=h==="inverse",p=this.getUrlByMarketType(r,l),m=r!=="spot",g=await this.subscribePrivate(p,d,c,u,m);return this.newUpdates&&(s=g.getLimit(e,s)),this.filterBySinceLimit(g,t,s,"timestamp",!0)}handleOrder(e,t){const s=this.safeValue(t,"result",[]),i=this.safeString(t,"channel");if(s.length>0){const r=this.safeInteger(this.options,"ordersLimit",1e3);this.orders===void 0&&(this.orders=new QT(r));const a=this.orders,o={},d=this.parseOrders(s);for(let u=0;u<d.length;u++){const h=d[u],l=this.safeValue(h,"info"),p=this.safeString(l,"event");p==="put"?h.status="open":p==="finish"&&(h.status="closed"),a.append(h);const m=h.symbol,g=this.market(m);o[g.id]=!0}const c=Object.keys(o);for(let u=0;u<c.length;u++){const h=i+":"+c[u];e.resolve(this.orders,h)}e.resolve(this.orders,i)}}handleAuthenticationMessage(e,t,s){const i=this.safeValue(t,"result");if(this.safeString(i,"status")==="success"){const r=this.safeValue(e.futures,"authenticated");r!==void 0&&r.resolve(!0)}else{const r=new _h(this.id+" handleAuthenticationMessage() error");e.reject(r,"authenticated"),"server.sign"in e.subscriptions&&delete e.subscriptions["server.sign"]}}handleErrorMessage(e,t){const s=this.safeValue(t,"error",{}),i=this.safeInteger(s,"code");if(i!==void 0){const n=this.safeString(t,"id"),r=this.indexBy(e.subscriptions,"id"),a=this.safeValue(r,n);if(a!==void 0)try{this.throwExactlyMatchedException(this.exceptions.ws.exact,i,this.json(t))}catch(o){const d=this.safeString(a,"messageHash");e.reject(o,d),e.reject(o,n),n in e.subscriptions&&delete e.subscriptions[n]}}}handleBalanceSubscription(e,t){this.spawn(this.fetchBalanceSnapshot,e,t)}async fetchBalanceSnapshot(e,t){await this.loadMarkets();const s=this.safeString(t,"channel",""),i=s.split("."),n=this.safeString(i,0);let r=n;n==="futures"?r="future":r==="options"&&(r="option");const a={type:r};if(r==="future"||r==="swap"){const d=this.safeValue(this.options,"watchTicker",{}),c=this.safeString(d,"settle","usdt");a.settle=c}const o=await this.fetchBalance(a);this.balance=o,e.resolve(this.balance,s)}handleSubscriptionStatus(e,t){this.safeString(t,"channel","").indexOf("balance")>=0&&this.handleBalanceSubscription(e,t)}handleMessage(e,t){if(this.handleErrorMessage(e,t),this.safeString(t,"event")==="subscribe"){this.handleSubscriptionStatus(e,t);return}const n=this.safeString(t,"channel","").split("."),r=this.safeValue(n,1),a={usertrades:this.handleMyTrades,candlesticks:this.handleOHLCV,orders:this.handleOrder,tickers:this.handleTicker,trades:this.handleTrades,order_book_update:this.handleOrderBook,balances:this.handleBalanceMessage},o=this.safeValue(a,r);o!==void 0&&o.call(this,e,t)}getUniformType(e){let t="spot";return e==="future"||e==="swap"?t="futures":e==="option"&&(t="options"),t}getUrlByMarketType(e,t=!1){if(e==="spot"){const s=this.urls.api.spot;if(s===void 0)throw new Vj(this.id+" does not have a testnet for the "+e+" market type.");return s}if(e==="swap"){const s=this.urls.api.swap;return t?s.btc:s.usdt}if(e==="future"){const s=this.urls.api.future;return t?s.btc:s.usdt}if(e==="option")return this.urls.api.option}requestId(){const e=this.sum(this.safeInteger(this.options,"reqid",0),1);return this.options.reqid=e,e}async subscribePublic(e,t,s,i,n={}){const r=this.requestId(),a=this.seconds(),o={id:r,time:a,channel:t,event:"subscribe",payload:i};let d={id:r,messageHash:s};return d=this.extend(d,n),await this.watch(e,s,o,s,d)}async subscribePrivate(e,t,s,i=void 0,n=!1){if(this.checkRequiredCredentials(),n){if(this.uid===void 0||this.uid.length===0)throw new Ej(this.id+" requires uid to subscribe");const p=[this.uid];i===void 0?i=p:i=this.arrayConcat(p,i)}const r=this.seconds(),a="subscribe",o="channel="+t+"&event="+a+"&time="+r.toString(),d=this.hmac(this.encode(o),this.encode(this.secret),"sha512","hex"),c={method:"api_key",KEY:this.apiKey,SIGN:d},u=this.requestId(),h={id:u,time:r,channel:t,event:"subscribe",auth:c};i!==void 0&&(h.payload=i);const l={id:u,messageHash:s};return await this.watch(e,s,h,s,l)}};const Fj=tC;var Dj=class extends Fj{describe(){return this.deepExtend(super.describe(),{alias:!0,id:"gateio"})}};const Hj=R_,{AuthenticationError:Gj,BadSymbol:Uj,BadRequest:$j}=oe,{ArrayCache:ZT,ArrayCacheBySymbolById:jj}=et;var Wj=class extends Hj{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!1,watchOHLCV:!1,watchOrderBook:!0,watchOrders:!0,watchTicker:!1,watchTickers:!1,watchTrades:!0},urls:{api:{ws:"wss://api.hollaex.com/stream"},test:{ws:"wss://api.sandbox.hollaex.com/stream"}},options:{watchBalance:{},watchOrders:{}},streaming:{ping:this.ping},exceptions:{ws:{exact:{"Bearer or HMAC authentication required":Uj,"Error: wrong input":$j}}}})}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n="orderbook:"+this.market(e).id;return(await this.watchPublic(n,s)).limit()}handleOrderBook(e,t){const s=this.safeString(t,"symbol"),i=this.safeString(t,"topic"),r=this.safeMarket(s).symbol,a=this.safeValue(t,"data");let o=this.safeString(a,"timestamp");o=this.parse8601(o);const d=this.parseOrderBook(a,r,o);let c;r in this.orderbooks?(c=this.orderbooks[r],c.reset(d)):(c=this.orderBook(d),this.orderbooks[r]=c);const u=i+":"+s;e.resolve(c,u)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="trade:"+n.id,a=await this.watchPublic(r,i);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySinceLimit(a,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeString(t,"topic"),i=this.safeString(t,"symbol"),n=this.safeMarket(i),r=n.symbol;let a=this.safeValue(this.trades,r);if(a===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);a=new ZT(u),this.trades[r]=a}const o=this.safeValue(t,"data",[]),d=this.parseTrades(o,n);for(let u=0;u<d.length;u++)a.append(d[u]);const c=s+":"+i;e.resolve(a,c),e.resolve(a,s)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n="usertrade",r;e!==void 0&&(r=this.market(e),e=r.symbol,n+=":"+r.id);const a=await this.watchPrivate(n,i);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySymbolSinceLimit(a,e,t,s,!0)}handleMyTrades(e,t,s=void 0){const i=this.safeString(t,"topic"),n=this.safeValue(t,"data");if(n.length===0)return 0;if(this.myTrades===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new ZT(c)}const a=this.myTrades,o={};for(let c=0;c<n.length;c++){const u=n[c],h=this.parseTrade(u);a.append(h);const l=u.symbol,m=this.market(l).id;o[m]=!0}e.resolve(this.myTrades,i);const d=Object.keys(o);for(let c=0;c<d.length;c++){const u=d[c],h=i+":"+u;e.resolve(this.myTrades,h)}}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n="order",r;e!==void 0&&(r=this.market(e),e=r.symbol,n+=":"+r.id);const a=await this.watchPrivate(n,i);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySymbolSinceLimit(a,e,t,s,!0)}handleOrder(e,t,s=void 0){const i=this.safeString(t,"topic"),n=this.safeValue(t,"data",{});if(n.length===0)return 0;if(this.orders===void 0){const u=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new jj(u)}const a=this.orders;let o;Array.isArray(n)?o=n:o=[n];const d={};for(let u=0;u<o.length;u++){const h=o[u],l=this.parseOrder(h);a.append(l);const p=h.symbol,g=this.market(p).id;d[g]=!0}e.resolve(this.orders,i);const c=Object.keys(d);for(let u=0;u<c.length;u++){const h=c[u],l=i+":"+h;e.resolve(this.orders,l)}}async watchBalance(e={}){const t="wallet";return await this.watchPrivate(t,e)}handleBalance(e,t){const s=this.safeString(t,"topic"),i=this.safeValue(t,"data"),n=Object.keys(i);for(let r=0;r<n.length;r++){const a=n[r],o=a.split("_"),d=this.safeString(o,0),c=this.safeCurrencyCode(d),u=c in this.balance?this.balance[c]:this.account(),l=this.safeString(o,1)==="available"?"free":"total";u[l]=this.safeString(i,a),this.balance[c]=u}this.balance=this.safeBalance(this.balance),e.resolve(this.balance,s)}async watchPublic(e,t={}){const s=this.urls.api.ws,i={op:"subscribe",args:[e]},n=this.extend(i,t);return await this.watch(s,e,n,e)}async watchPrivate(e,t={}){this.checkRequiredCredentials();let s=this.safeString(this.options,"ws-expires");if(s===void 0){const u=parseInt(this.timeout/1e3);s=this.sum(this.seconds(),u),s=s.toString(),this.options["ws-expires"]=s}const i=this.urls.api.ws,n="CONNECT/stream"+s,r=this.hmac(this.encode(n),this.encode(this.secret)),a={"api-key":this.apiKey,"api-signature":r,"api-expires":s},o=i+"?"+this.urlencode(a),d={op:"subscribe",args:[e]},c=this.extend(d,t);return await this.watch(o,e,c,e)}handleErrorMessage(e,t){const s=this.safeInteger(t,"error");try{if(s!==void 0){const i=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.ws.exact,s,i)}}catch(i){if(i instanceof Gj)return!1}return t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;if(this.safeString(t,"message")==="pong"){this.handlePong(e,t);return}const i={trade:this.handleTrades,orderbook:this.handleOrderBook,order:this.handleOrder,wallet:this.handleBalance,usertrade:this.handleMyTrades},n=this.safeValue(t,"topic"),r=this.safeValue(i,n);r!==void 0&&r.call(this,e,t)}ping(e){return{op:"ping"}}handlePong(e,t){return e.lastPong=this.milliseconds(),t}onError(e,t){this.options["ws-expires"]=void 0,super.onError(e,t)}onClose(e,t){this.options["ws-expires"]=void 0,super.onClose(e,t)}};const zj=Ob,{ExchangeError:JT,InvalidNonce:Kj,ArgumentsRequired:Xj,BadRequest:Bg,BadSymbol:eO,AuthenticationError:tO}=oe,{ArrayCache:Yj,ArrayCacheByTimestamp:Qj,ArrayCacheBySymbolById:sO}=et;var sC=class extends zj{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchOrders:!0,watchTickers:!1,watchTicker:!0,watchTrades:!0,watchMyTrades:!0,watchBalance:!0,watchOHLCV:!0},urls:{api:{ws:{api:{spot:{public:"wss://{hostname}/ws",private:"wss://{hostname}/ws/v2"},future:{linear:{public:"wss://api.hbdm.com/linear-swap-ws",private:"wss://api.hbdm.com/linear-swap-notification"},inverse:{public:"wss://api.hbdm.com/ws",private:"wss://api.hbdm.com/notification"}},swap:{inverse:{public:"wss://api.hbdm.com/swap-ws",private:"wss://api.hbdm.com/swap-notification"},linear:{public:"wss://api.hbdm.com/linear-swap-ws",private:"wss://api.hbdm.com/linear-swap-notification"}}},"api-aws":{spot:{public:"wss://api-aws.huobi.pro/ws",private:"wss://api-aws.huobi.pro/ws/v2"},future:{linear:{public:"wss://api.hbdm.vn/linear-swap-ws",private:"wss://api.hbdm.vn/linear-swap-notification"},inverse:{public:"wss://api.hbdm.vn/ws",private:"wss://api.hbdm.vn/notification"}},swap:{inverse:{public:"wss://api.hbdm.vn/swap-ws",private:"wss://api.hbdm.vn/swap-notification"},linear:{public:"wss://api.hbdm.vn/linear-swap-ws",private:"wss://api.hbdm.vn/linear-swap-notification"}}}}}},options:{tradesLimit:1e3,OHLCVLimit:1e3,api:"api",maxOrderBookSyncAttempts:3,ws:{gunzip:!0}},exceptions:{ws:{exact:{"bad-request":Bg,2002:tO,2021:Bg,2001:eO,2011:eO,2040:Bg}}}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e.toString()}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i="market."+s.id+".detail",n=this.getUrlByMarketType(s.type,s.linear);return await this.subscribePublic(n,e,i,void 0,t)}handleTicker(e,t){const s=this.safeValue(t,"tick",{}),i=this.safeString(t,"ch"),n=i.split("."),r=this.safeString(n,1),a=this.safeMarket(r),o=this.parseTicker(s,a),d=this.safeValue(t,"ts");o.timestamp=d,o.datetime=this.iso8601(d);const c=o.symbol;return this.tickers[c]=o,e.resolve(o,i),t}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="market."+n.id+".trade.detail",a=this.getUrlByMarketType(n.type,n.linear),o=await this.subscribePublic(a,e,r,void 0,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"tick",{}),i=this.safeValue(s,"data",{}),n=this.safeString(t,"ch"),r=n.split("."),a=this.safeString(r,1),o=this.safeMarket(a),d=o.symbol;let c=this.safeValue(this.trades,d);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new Yj(u),this.trades[d]=c}for(let u=0;u<i.length;u++){const h=this.parseTrade(i[u],o);c.append(h)}return e.resolve(c,n),t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=this.timeframes[t],o="market."+r.id+".kline."+a,d=this.getUrlByMarketType(r.type,r.linear),c=await this.subscribePublic(d,e,o,void 0,n);return this.newUpdates&&(i=c.getLimit(e,i)),this.filterBySinceLimit(c,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"ch"),i=s.split("."),n=this.safeString(i,1),r=this.safeMarket(n),a=r.symbol,o=this.safeString(i,3),d=this.findTimeframe(o);this.ohlcvs[a]=this.safeValue(this.ohlcvs,a,{});let c=this.safeValue(this.ohlcvs[a],d);if(c===void 0){const l=this.safeInteger(this.options,"OHLCVLimit",1e3);c=new Qj(l),this.ohlcvs[a][d]=c}const u=this.safeValue(t,"tick"),h=this.parseOHLCV(u,r);c.append(h),e.resolve(c,s)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n=[150],r=[20,150];if(t=t===void 0?150:t,i.spot&&!this.inArray(t,n))throw new JT(this.id+" watchOrderBook spot market accepts limits of 150 only");if(!i.spot&&!this.inArray(t,r))throw new JT(this.id+" watchOrderBook swap market accepts limits of 20 and 150 only");let a;i.spot?a="market."+i.id+".mbp."+t.toString():a="market."+i.id+".depth.size_"+t.toString()+".high_freq";const o=this.getUrlByMarketType(i.type,i.linear);let d=this.handleOrderBookSubscription;return i.spot||(s.data_type="incremental",d=void 0),(await this.subscribePublic(o,e,a,d,s)).limit()}handleOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeString(s,"messageHash");try{const r=this.orderbooks[i],a=this.safeValue(t,"data"),o=r.cache,d=this.safeValue(o,0,{}),c=this.parseOrderBook(a,i),u=this.safeValue(d,"tick"),h=this.safeInteger(u,"seqNum"),l=this.safeInteger(a,"seqNum");if(c.nonce=l,h!==void 0&&l<h){const p=this.safeInteger(this.options,"maxOrderBookSyncAttempts",3);let m=this.safeInteger(s,"numAttempts",0);if(m<p)n in e.subscriptions&&(m=this.sum(m,1),s.numAttempts=m,e.subscriptions[n]=s,this.spawn(this.watchOrderBookSnapshot,e,t,s));else throw new Kj(this.id+" failed to synchronize WebSocket feed with the snapshot for symbol "+i+" in "+p.toString()+" attempts")}else{r.reset(c);for(let p=0;p<o.length;p++){const m=o[p];this.handleOrderBookMessage(e,m,r)}this.orderbooks[i]=r,e.resolve(r,n)}}catch(r){e.reject(r,n)}}async watchOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit"),r=this.safeValue(s,"params"),a=this.safeInteger(s,"numAttempts",0),o=this.safeString(s,"messageHash"),d=this.market(i),c=this.getUrlByMarketType(d.type,d.linear),u=this.requestId(),h={req:o,id:u},l={id:u,messageHash:o,symbol:i,limit:n,params:r,numAttempts:a,method:this.handleOrderBookSnapshot};return(await this.watch(c,u,h,u,l)).limit()}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s){const n=this.safeValue(t,"ch").split("."),r=this.safeString(n,1),a=this.safeSymbol(r),o=this.safeValue(t,"tick",{}),d=this.safeInteger2(o,"seqNum","version"),c=this.safeInteger(o,"prevSeqNum"),u=this.safeString(o,"event"),h=this.safeInteger(t,"ts");if(u==="snapshot"){const l=this.parseOrderBook(o,a,h);s.reset(l),s.nonce=d}if((c===void 0||c<=s.nonce)&&d>s.nonce){const l=this.safeValue(o,"asks",[]),p=this.safeValue(o,"bids",[]);this.handleDeltas(s.asks,l),this.handleDeltas(s.bids,p),s.nonce=d,s.timestamp=h,s.datetime=this.iso8601(h)}return s}handleOrderBook(e,t){const s=this.safeValue(t,"tick",{}),i=this.safeString(s,"event"),n=this.safeString(t,"ch"),a=this.safeValue(t,"ch").split("."),o=this.safeString(a,1),d=this.safeSymbol(o);let c=this.safeValue(this.orderbooks,d);if(c===void 0){const h=this.safeString(a,3).split("_"),l=this.safeInteger(h,1);c=this.orderBook({},l)}c.nonce===void 0&&c.cache.push(t),(i!==void 0||c.nonce!==void 0)&&(this.orderbooks[d]=this.handleOrderBookMessage(e,t,c),e.resolve(c,n))}handleOrderBookSubscription(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit");i in this.orderbooks&&delete this.orderbooks[i],this.orderbooks[i]=this.orderBook({},n),this.markets[i].spot===!0&&this.spawn(this.watchOrderBookSnapshot,e,t,s)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){this.checkRequiredCredentials();let n,r="*",a,o,d,c,u;if(e!==void 0?(await this.loadMarkets(),a=this.market(e),e=a.symbol,n=a.type,u=a.linear?"linear":"inverse",r=a.lowercaseId):(n=this.safeString(this.options,"defaultType","spot"),n=this.safeString(i,"type",n),u=this.safeString2(this.options,"subType","defaultSubType","linear"),u=this.safeString(i,"subType",u),i=this.omit(i,["type","subType"])),n==="spot"){let h;h===void 0&&(h=this.safeString2(this.options,"watchMyTrades","mode","0"),h=this.safeString(i,"mode",h),i=this.omit(i,"mode")),o="trade.clearing#"+r+"#"+h,d=o}else{const h=this.getOrderChannelAndMessageHash(n,u,a,i);d=this.safeString(h,0),o=this.safeString(h,1)+":trade"}return c=await this.subscribePrivate(d,o,n,u,i),this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}getOrderChannelAndMessageHash(e,t,s=void 0,i={}){let n,r,a=this.safeString(this.options,"orderType","orders");a=this.safeString(i,"orderType",a),i=this.omit(i,"orderType");const o=s!==void 0?s.lowercaseId:void 0,d=s!==void 0?s.lowercaseBaseId:void 0,c=a;if(n=c,t==="linear"){const h=this.safeString(i,"margin","cross")==="cross"?c+"_cross":c;n=h,o!==void 0?(n+="."+o,r=n):r=h+".*"}else e==="future"?d!==void 0?(r=c+"."+d,n=r):r=c+".*":o!==void 0?(r=c+"."+o,n=r):r=c+".*";return[r,n]}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r,a,o="*";e!==void 0?(a=this.market(e),e=a.symbol,n=a.type,o=a.lowercaseId,r=a.linear?"linear":"inverse"):(n=this.safeString(this.options,"defaultType","spot"),n=this.safeString(i,"type",n),r=this.safeString2(this.options,"subType","defaultSubType","linear"),r=this.safeString(i,"subType",r),i=this.omit(i,["type","subType"]));let d,c;if(n==="spot")d="orders#"+o,c=d;else{const h=this.getOrderChannelAndMessageHash(n,r,a,i);c=this.safeString(h,0),d=this.safeString(h,1)}const u=await this.subscribePrivate(c,d,n,r,i);return this.newUpdates&&(s=u.getLimit(e,s)),this.filterBySinceLimit(u,t,s,"timestamp",!0)}handleOrder(e,t){const s=this.safeString2(t,"ch","topic"),i=this.safeValue(t,"data");let n=this.safeString(t,"contract_code");n===void 0&&(n=this.safeString(i,"symbol"));const r=this.safeMarket(n);let a;if(i!==void 0)if(this.safeString(i,"eventType")==="trade"){const u=this.parseOrderTrade(i,r);a={id:this.safeString(u,"order"),trades:[u],status:"closed",symbol:r.symbol}}else a=this.parseWsOrder(i,r);else{a=this.parseWsOrder(t,r);const c=this.safeValue(t,"trade",[]);if(c.length>0){const h={trades:c,ch:s,symbol:n},l={order:this.safeString(a,"id"),type:this.safeString(a,"type"),side:this.safeString(a,"side")};this.handleMyTrade(e,h,l)}}if(this.orders===void 0){const c=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new sO(c)}this.orders.append(a),e.resolve(this.orders,s);let d=s.replace("."+r.lowercaseId,"");d=d.replace("."+r.lowercaseBaseId,""),e.resolve(this.orders,d)}parseWsOrder(e,t=void 0){const s=this.safeInteger2(e,"lastActTime","ts"),i=this.safeInteger(e,"orderCreateTime"),n=this.safeString2(e,"contract_code","symbol");t=this.safeMarket(n,t);const r=this.safeSymbol(n,t),a=this.safeString2(e,"orderSize","volume"),o=this.parseOrderStatus(this.safeString2(e,"orderStatus","status")),d=this.safeString2(e,"orderId","order_id"),c=this.safeString2(e,"clientOrderId","client_order_id"),u=this.safeString2(e,"orderPrice","price"),h=this.safeString(e,"execAmt");let l=this.safeString(e,"type");const p=this.safeString(e,"fee");let m;if(p!==void 0){const k=this.safeString(e,"fee_asset");m={cost:p,currency:this.safeCurrencyCode(k)}}const g=this.safeString(e,"trade_avg_price"),y=this.safeValue(e,"trade");l!==void 0&&(l=l.split("-"));let b=this.safeStringLower(l,1);b===void 0&&(b=this.safeString(e,"order_price_type"));let w=this.safeStringLower(l,0);w===void 0&&(w=this.safeString(e,"direction"));const S=this.safeString(e,"orderValue");return this.safeOrder({info:e,id:d,clientOrderId:c,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:s,status:o,symbol:r,type:b,timeInForce:void 0,postOnly:void 0,side:w,price:u,amount:a,filled:h,remaining:void 0,cost:S,fee:m,average:g,trades:y},t)}parseOrderTrade(e,t=void 0){t=this.safeMarket(void 0,t);const s=t.symbol,i=this.safeString(e,"tradeId"),n=this.safeString(e,"tradePrice"),r=this.safeString(e,"tradeVolume"),a=this.safeString(e,"orderId"),o=this.safeInteger(e,"tradeTime");let d=this.safeString(e,"type"),c;if(d!==void 0){const l=d.split("-");c=l[0],d=l[1]}const u=this.safeValue(e,"aggressor");let h;return u!==void 0&&(h=u?"taker":"maker"),this.safeTrade({info:e,timestamp:o,datetime:this.iso8601(o),symbol:s,id:i,order:a,type:d,takerOrMaker:h,side:c,price:n,amount:r,cost:void 0,fee:void 0},t)}async watchBalance(e={}){let t=this.safeString2(this.options,"watchBalance","defaultType","spot");t=this.safeString(e,"type",t);let s=this.safeString2(this.options,"watchBalance","subType","linear");s=this.safeString(e,"subType",s),e=this.omit(e,["type","subType"]),e=this.omit(e,"type"),await this.loadMarkets();let i,n,r;if(t==="spot"){let o=this.safeString2(this.options,"watchBalance","mode","2");o=this.safeString(e,"mode",o),i="accounts.update#"+o,n=i}else{const o=this.safeString(e,"symbol"),d=this.safeString(e,"currency"),c=o!==void 0?this.market(o):void 0,u=d!==void 0?this.currency(d):void 0;r=this.safeString(e,"margin","cross"),e=this.omit(e,["currency","symbol","margin"]);let h="accounts";i=h,s==="linear"?(h=r==="cross"?h+"_cross":h,i=h,r==="isolated"?o!==void 0?(i+="."+c.id,n=i):n=h+".*":u!==void 0?(n=h+"."+u.id,i=n):n=h+".*"):t==="future"?u!==void 0?(i+="."+u.id,n=i):n=h+".*":c!==void 0?(i+="."+c.id,n=i):n=h+".*"}const a={type:t,subType:s,margin:r};return await this.subscribePrivate(n,i,t,s,e,a)}handleBalance(e,t){const s=this.safeString(t,"ch");if(s!==void 0){const i=this.safeValue(t,"data",{}),n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"available"),a.total=this.safeString(i,"balance"),this.balance[r]=a,this.balance=this.safeBalance(this.balance),e.resolve(this.balance,s)}else{const i=this.safeValue(t,"data",[]);if(i.length===0)return;const r=this.safeValue(i,0,{});let a=this.safeString(t,"topic"),o=this.safeValue2(e.subscriptions,a,a+".*");if(o===void 0){const u=this.safeString(r,"margin_asset");a+="."+u.toLowerCase(),o=this.safeValue(e.subscriptions,a)}const d=this.safeString(o,"type");if(this.safeString(o,"subType")==="linear")if(this.safeString(o,"margin")==="cross"){const h=d==="future"?"futures_contract_detail":"contract_detail",l=this.safeValue(r,h,[]);if(l.length>0)for(let m=0;m<l.length;m++){const g=l[m],y=this.safeString2(g,"contract_code","margin_account"),b=this.safeMarket(y),w=this.safeString(g,"margin_asset"),S=this.safeCurrency(w),k=this.safeString(b,"settle",S.code);if(k!==void 0){const T=this.account();T.free=this.safeString2(g,"margin_balance","margin_available"),T.used=this.safeString(g,"margin_frozen");const I={};I[k]=T;const _=b.symbol;this.balance[_]=this.safeBalance(I)}}}else for(let h=0;h<i.length;h++){const l=i[h],p=this.account();p.free=this.safeString(l,"margin_balance","margin_available"),p.used=this.safeString(l,"margin_frozen");const m=this.safeString2(l,"margin_asset","symbol"),g=this.safeCurrencyCode(m);this.balance[g]=p,this.balance=this.safeBalance(this.balance)}else for(let u=0;u<i.length;u++){const h=i[u],l=this.safeString(h,"symbol"),p=this.safeCurrencyCode(l),m=this.account();m.free=this.safeString(h,"margin_available"),m.used=this.safeString(h,"margin_frozen"),this.balance[p]=m,this.balance=this.safeBalance(this.balance)}e.resolve(this.balance,a)}}handleSubscriptionStatus(e,t){const s=this.safeString(t,"id"),i=this.indexBy(e.subscriptions,"id"),n=this.safeValue(i,s);if(n!==void 0){const r=this.safeValue(n,"method");if(r!==void 0)return r.call(this,e,t,n);s in e.subscriptions&&delete e.subscriptions[s]}return t}handleSystemStatus(e,t){return t}handleSubject(e,t){const s=this.safeValue(t,"ch",""),i=s.split(".");if(this.safeString(i,0)==="market"){const d=this.safeString(i,2),c={depth:this.handleOrderBook,mbp:this.handleOrderBook,detail:this.handleTicker,trade:this.handleTrades,kline:this.handleOHLCV},u=this.safeValue(c,d);return u===void 0?t:u.call(this,e,t)}const r=s.split("#"),a=this.safeString(r,0,"");if(a==="trade.clearing"){this.handleMyTrade(e,t);return}if(a.indexOf("accounts.update")!==-1){this.handleBalance(e,t);return}if(a==="orders"){this.handleOrder(e,t);return}if(this.safeString(t,"op")==="notify"){const d=this.safeString(t,"topic","");d.indexOf("orders")!==-1&&this.handleOrder(e,t),d.indexOf("account")!==-1&&this.handleBalance(e,t)}}async pong(e,t){const s=this.safeInteger(t,"ping");if(s!==void 0){await e.send({pong:s});return}if(this.safeString(t,"action")==="ping"){const r=this.safeValue(t,"data"),a=this.safeInteger(r,"ts");await e.send({action:"pong",data:{ts:a}});return}if(this.safeString(t,"op")==="ping"){const r=this.safeInteger(t,"ts");await e.send({op:"pong",ts:r})}}handlePing(e,t){this.spawn(this.pong,e,t)}handleAuthenticate(e,t){return e.resolve(t,"auth"),t}handleErrorMessage(e,t){if(this.safeString(t,"status")==="error"){const n=this.safeString(t,"id"),r=this.indexBy(e.subscriptions,"id"),a=this.safeValue(r,n);if(a!==void 0){const o=this.safeString(t,"err-code");try{this.throwExactlyMatchedException(this.exceptions.ws.exact,o,this.json(t))}catch(d){const c=this.safeString(a,"messageHash");e.reject(d,c),e.reject(d,n),n in e.subscriptions&&delete e.subscriptions[n]}}return!1}const i=this.safeInteger(t,"code");if(i!==void 0&&i!==200){const n=this.id+" "+this.json(t);try{this.throwExactlyMatchedException(this.exceptions.ws.exact,i,n)}catch(r){if(r instanceof tO){e.reject(r,"auth");const a="auth";return a in e.subscriptions&&delete e.subscriptions[a],!1}else e.reject(r)}}return t}handleMessage(e,t){if(this.handleErrorMessage(e,t)){if("id"in t){this.handleSubscriptionStatus(e,t);return}if("action"in t){const s=this.safeString(t,"action");if(s==="ping"){this.handlePing(e,t);return}if(s==="sub"){this.handleSubscriptionStatus(e,t);return}}if("ch"in t)if(t.ch==="auth"){this.handleAuthenticate(e,t);return}else{this.handleSubject(e,t);return}if("op"in t){const s=this.safeString(t,"op");if(s==="ping"){this.handlePing(e,t);return}if(s==="auth"){this.handleAuthenticate(e,t);return}if(s==="sub"){this.handleSubscriptionStatus(e,t);return}if(s==="notify"){this.handleSubject(e,t);return}}"ping"in t&&this.handlePing(e,t)}}handleMyTrade(e,t,s={}){if(this.myTrades===void 0){const r=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new sO(r)}const i=this.myTrades,n=this.safeString(t,"ch");if(n!==void 0){const r=this.safeValue(t,"data");if(r!==void 0){const a=this.parseWsTrade(r);this.safeString(a,"symbol")!==void 0&&(i.append(a),e.resolve(this.myTrades,n))}else{const a=this.safeValue(t,"trades",[]),o=this.safeValue(t,"symbol"),d=this.market(o);for(let l=0;l<a.length;l++){const p=a[l];let m=this.parseTrade(p,d);m=this.extend(m,s),i.append(m)}const c=n+":trade";e.resolve(this.myTrades,c);let u=n.replace("."+d.lowercaseId,"");u=u.replace("."+d.lowercaseBaseId,"");const h=u+":trade";e.resolve(this.myTrades,h)}}}parseWsTrade(e){const t=this.safeSymbol(this.safeString(e,"symbol")),s=this.safeString2(e,"side","orderSide"),i=this.safeString(e,"tradeId"),n=this.safeString(e,"tradePrice"),r=this.safeString(e,"tradeVolume"),a=this.safeString(e,"orderId"),o=this.safeInteger(e,"tradeTime"),d=this.market(t);let c=this.safeString(e,"orderType");const u=this.safeValue(e,"aggressor");let h;u!==void 0&&(h=u?"taker":"maker");let l;c!==void 0&&(c=c.split("-"),l=this.safeString(c,1));let p;const m=this.safeCurrencyCode(this.safeString(e,"feeCurrency"));return m!==void 0&&(p={cost:this.safeString(e,"transactFee"),currency:m}),this.safeTrade({info:e,timestamp:o,datetime:this.iso8601(o),symbol:t,id:i,order:a,type:l,takerOrMaker:h,side:s,price:n,amount:r,cost:void 0,fee:p},d)}getUrlByMarketType(e,t=!0,s=!1){const i=this.safeString(this.options,"api","api"),n={hostname:this.hostname};let r,a;if(e==="spot")s?r=this.urls.api.ws[i].spot.private:r=this.urls.api.ws[i].spot.public,a=this.implodeParams(r,n);else{const o=this.urls.api.ws[i][e],d=t?o.linear:o.inverse;a=s?d.private:d.public}return a}async subscribePublic(e,t,s,i=void 0,n={}){const r=this.requestId(),a={sub:s,id:r},o={id:r,messageHash:s,symbol:t,params:n};return i!==void 0&&(o.method=i),await this.watch(e,s,this.extend(a,n),s,o)}async subscribePrivate(e,t,s,i,n={},r={}){const a=this.nonce(),o={id:a,messageHash:t,params:n},d=this.extend(o,r);let c;s==="spot"?c={action:"sub",ch:e}:c={op:"sub",topic:e,cid:a};const u=i==="linear",h=this.getUrlByMarketType(s,u,!0),l=s==="spot"?this.urls.hostnames.spot:this.urls.hostnames.contract,p={type:s,url:h,hostname:l};return s==="spot"&&(this.options.ws.gunzip=!1),await this.authenticate(p),await this.watch(h,t,this.extend(c,n),e,d)}async authenticate(e={}){const t=this.safeString(e,"url"),s=this.safeString(e,"hostname"),i=this.safeString(e,"type");if(t===void 0||s===void 0||i===void 0)throw new Xj(this.id+" authenticate requires a url, hostname and type argument");this.checkRequiredCredentials();const n="auth",r=t.replace("wss://"+s,""),a=this.client(t);let o=this.safeValue(a.subscriptions,n);if(o===void 0){o=a.future(n);const d=this.ymdhms(this.milliseconds(),"T");let c;i==="spot"?c={accessKey:this.apiKey,signatureMethod:"HmacSHA256",signatureVersion:"2.1",timestamp:d}:c={AccessKeyId:this.apiKey,SignatureMethod:"HmacSHA256",SignatureVersion:"2",Timestamp:d},c=this.keysort(c);const u=this.urlencode(c),h=["GET",s,r,u].join(`
`),l=this.hmac(this.encode(h),this.encode(this.secret),"sha256","base64");let p;i==="spot"?p={params:{authType:"api",accessKey:this.apiKey,signatureMethod:"HmacSHA256",signatureVersion:"2.1",timestamp:d,signature:l},action:"req",ch:n}:p={op:n,type:"api",AccessKeyId:this.apiKey,SignatureMethod:"HmacSHA256",SignatureVersion:"2",Timestamp:d,Signature:l},await this.watch(t,n,p,n,o)}return await o}};const Zj=F_,{ExchangeError:Jj}=oe,{ArrayCache:eW,ArrayCacheByTimestamp:tW}=et;var sW=class extends Zj{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTickers:!1,watchTicker:!0,watchTrades:!0,watchBalance:!1,watchOHLCV:!0},urls:{api:{ws:{api:{public:"wss://{hostname}/ws",private:"wss://{hostname}/ws/v2"}}}},options:{tradesLimit:1e3,OHLCVLimit:1e3,api:"api",ws:{gunzip:!0}}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e.toString()}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i="market."+s.id+".detail",n=this.safeString(this.options,"api","api"),r={hostname:this.hostname},a=this.implodeParams(this.urls.api.ws[n].public,r),o=this.requestId(),d={sub:i,id:o},c={id:o,messageHash:i,symbol:e,params:t};return await this.watch(a,i,this.extend(d,t),i,c)}handleTicker(e,t){const s=this.safeValue(t,"tick",{}),i=this.safeString(t,"ch"),n=i.split("."),r=this.safeString(n,1),a=this.safeMarket(r),o=this.parseTicker(s,a),d=this.safeValue(t,"ts");o.timestamp=d,o.datetime=this.iso8601(d);const c=o.symbol;return this.tickers[c]=o,e.resolve(o,i),t}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="market."+n.id+".trade.detail",a=this.safeString(this.options,"api","api"),o={hostname:this.hostname},d=this.implodeParams(this.urls.api.ws[a].public,o),c=this.requestId(),u={sub:r,id:c},h={id:c,messageHash:r,symbol:e,params:i},l=await this.watch(d,r,this.extend(u,i),r,h);return this.newUpdates&&(s=l.getLimit(e,s)),this.filterBySinceLimit(l,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"tick",{}),i=this.safeValue(s,"data",{}),n=this.safeString(t,"ch"),r=n.split("."),a=this.safeString(r,1),o=this.safeMarket(a),d=o.symbol;let c=this.safeValue(this.trades,d);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new eW(u),this.trades[d]=c}for(let u=0;u<i.length;u++){const h=this.parseTrade(i[u],o);c.append(h)}return e.resolve(c,n),t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=this.timeframes[t],o="market."+r.id+".kline."+a,d=this.safeString(this.options,"api","api"),c={hostname:this.hostname},u=this.implodeParams(this.urls.api.ws[d].public,c),h=this.requestId(),l={sub:o,id:h},p={id:h,messageHash:o,symbol:e,timeframe:t,params:n},m=await this.watch(u,o,this.extend(l,n),o,p);return this.newUpdates&&(i=m.getLimit(e,i)),this.filterBySinceLimit(m,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"ch"),i=s.split("."),n=this.safeString(i,1),r=this.safeMarket(n),a=r.symbol,o=this.safeString(i,3),d=this.findTimeframe(o);this.ohlcvs[a]=this.safeValue(this.ohlcvs,a,{});let c=this.safeValue(this.ohlcvs[a],d);if(c===void 0){const l=this.safeInteger(this.options,"OHLCVLimit",1e3);c=new tW(l),this.ohlcvs[a][d]=c}const u=this.safeValue(t,"tick"),h=this.parseOHLCV(u,r);c.append(h),e.resolve(c,s)}async watchOrderBook(e,t=void 0,s={}){if(t!==void 0&&t!==150)throw new Jj(this.id+" watchOrderBook accepts limit = 150 only");await this.loadMarkets();const i=this.market(e);e=i.symbol,t=t===void 0?150:t;const n="market."+i.id+".mbp."+t.toString(),r=this.safeString(this.options,"api","api"),a={hostname:this.hostname},o=this.implodeParams(this.urls.api.ws[r].public,a),d=this.requestId(),c={sub:n,id:d},u={id:d,messageHash:n,symbol:e,limit:t,params:s,method:this.handleOrderBookSubscription};return(await this.watch(o,n,this.extend(c,s),n,u)).limit()}handleOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeString(s,"messageHash"),r=this.orderbooks[i],a=this.safeValue(t,"data"),o=this.parseOrderBook(a,i);o.nonce=this.safeInteger(a,"seqNum"),r.reset(o);const d=r.cache;for(let c=0;c<d.length;c++){const u=d[c];this.handleOrderBookMessage(e,u,r)}this.orderbooks[i]=r,e.resolve(r,n)}async watchOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit"),r=this.safeValue(s,"params"),a=this.safeString(s,"messageHash"),o=this.safeString(this.options,"api","api"),d={hostname:this.hostname},c=this.implodeParams(this.urls.api.ws[o].public,d),u=this.requestId(),h={req:a,id:u},l={id:u,messageHash:a,symbol:i,limit:n,params:r,method:this.handleOrderBookSnapshot};return(await this.watch(c,u,h,u,l)).limit()}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s){const i=this.safeValue(t,"tick",{}),n=this.safeInteger(i,"seqNum");if(this.safeInteger(i,"prevSeqNum")<=s.nonce&&n>s.nonce){const a=this.safeValue(i,"asks",[]),o=this.safeValue(i,"bids",[]);this.handleDeltas(s.asks,a),this.handleDeltas(s.bids,o),s.nonce=n;const d=this.safeInteger(t,"ts");s.timestamp=d,s.datetime=this.iso8601(d)}return s}handleOrderBook(e,t){const s=this.safeString(t,"ch"),n=this.safeValue(t,"ch").split("."),r=this.safeString(n,1),a=this.safeSymbol(r),o=this.orderbooks[a];o.nonce===void 0?o.cache.push(t):(this.handleOrderBookMessage(e,t,o),e.resolve(o,s))}handleOrderBookSubscription(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit");i in this.orderbooks&&delete this.orderbooks[i],this.orderbooks[i]=this.orderBook({},n),this.spawn(this.watchOrderBookSnapshot,e,t,s)}handleSubscriptionStatus(e,t){const s=this.safeString(t,"id"),i=this.indexBy(e.subscriptions,"id"),n=this.safeValue(i,s);if(n!==void 0){const r=this.safeValue(n,"method");if(r!==void 0)return r.call(this,e,t,n);s in e.subscriptions&&delete e.subscriptions[s]}return t}handleSystemStatus(e,t){return t}handleSubject(e,t){const i=this.safeValue(t,"ch").split(".");if(this.safeString(i,0)==="market"){const r=this.safeString(i,2),a={mbp:this.handleOrderBook,detail:this.handleTicker,trade:this.handleTrades,kline:this.handleOHLCV},o=this.safeValue(a,r);return o===void 0?t:o.call(this,e,t)}}async pong(e,t){await e.send({pong:this.safeInteger(t,"ping")})}handlePing(e,t){this.spawn(this.pong,e,t)}handleErrorMessage(e,t){if(this.safeString(t,"status")==="error"){const i=this.safeString(t,"id"),n=this.indexBy(e.subscriptions,"id"),r=this.safeValue(n,i);if(r!==void 0){const a=this.safeString(t,"err-code");try{this.throwExactlyMatchedException(this.exceptions.exact,a,this.json(t))}catch(o){const d=this.safeString(r,"messageHash");e.reject(o,d),e.reject(o,i),i in e.subscriptions&&delete e.subscriptions[i]}}return!1}return t}handleMessage(e,t){this.handleErrorMessage(e,t)&&("id"in t?this.handleSubscriptionStatus(e,t):"ch"in t?this.handleSubject(e,t):"ping"in t&&this.handlePing(e,t))}};const iW=sC;var nW=class extends iW{describe(){return this.deepExtend(super.describe(),{alias:!0,id:"huobipro"})}};const rW=D_,{InvalidNonce:aW}=oe,{ArrayCache:oW,ArrayCacheByTimestamp:dW,ArrayCacheBySymbolById:iO}=et;var cW=class extends rW{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTrades:!0,watchOHLCV:!0,watchTicker:!0,watchTickers:!1,watchOrders:!0,watchTransactions:!0},urls:{test:{ws:"wss://websocket-matic.idex.io/v1"},api:{}},options:{tradesLimit:1e3,ordersLimit:1e3,OHLCVLimit:1e3,watchOrderBookLimit:1e3,orderBookSubscriptions:{},token:void 0,fetchOrderBookSnapshotMaxAttempts:10,fetchOrderBookSnapshotMaxDelay:1e4}})}async subscribe(e,t,s=!0){const i=this.urls.test.ws,n={method:"subscribe",subscriptions:[e]};return await this.watch(i,t,n,t,s)}async subscribePrivate(e,t){const s=await this.authenticate(),i=this.urls.test.ws,n={method:"subscribe",token:s,subscriptions:[e]};return await this.watch(i,t,n,t)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i="tickers",n={name:i,markets:[s.id]},r=i+":"+s.id;return await this.subscribe(this.extend(n,t),r)}handleTicker(e,t){const s=this.safeString(t,"type"),i=this.safeValue(t,"data"),n=this.safeString(i,"m"),r=this.safeSymbol(n),a=s+":"+n,o=this.safeInteger(i,"t"),d=this.safeFloat(i,"c"),c=this.safeFloat(i,"P");let u;c!==void 0&&d!==void 0&&(u=d*c);const h={symbol:r,timestamp:o,datetime:this.iso8601(o),high:this.safeFloat(i,"h"),low:this.safeFloat(i,"l"),bid:this.safeFloat(i,"b"),bidVolume:void 0,ask:this.safeFloat(i,"a"),askVolume:void 0,vwap:void 0,open:this.safeFloat(i,"o"),close:d,last:d,previousClose:void 0,change:u,percentage:c,average:void 0,baseVolume:this.safeFloat(i,"v"),quoteVolume:this.safeFloat(i,"q"),info:t};e.resolve(h,a)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="trades",a={name:r,markets:[n.id]},o=r+":"+n.id,d=await this.subscribe(a,o);return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySinceLimit(d,t,s,"timestamp",!0)}handleTrade(e,t){const s=this.safeString(t,"type"),i=this.safeValue(t,"data"),n=this.safeString(i,"m"),r=s+":"+n,a=this.parseWsTrade(i);if(Object.keys(this.trades).length===0){const u=this.safeInteger(this.options,"tradesLimit");this.trades=new iO(u)}const c=this.trades;c.append(a),e.resolve(c,r)}parseWsTrade(e){const t=this.safeString(e,"m"),s=this.safeSymbol(t),i=this.safeString(e,"i"),n=this.safeFloat(e,"p"),r=this.safeFloat(e,"q"),a=this.safeFloat(e,"Q"),o=this.safeInteger(e,"t"),d=this.safeString(e,"s"),c={currency:this.safeString(e,"a"),cost:this.safeFloat(e,"f")},u=this.safeString(e,"l");return{info:e,timestamp:o,datetime:this.iso8601(o),symbol:s,id:i,order:void 0,type:void 0,takerOrMaker:u,side:d,price:n,amount:r,cost:a,fee:c}}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a="candles",o=this.timeframes[t],d={name:a,markets:[r.id],interval:o},c=a+":"+r.id,u=await this.subscribe(d,c);return this.newUpdates&&(i=u.getLimit(e,i)),this.filterBySinceLimit(u,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"type"),i=this.safeValue(t,"data"),n=this.safeString(i,"m"),r=s+":"+n,a=[this.safeInteger(i,"s"),this.safeFloat(i,"o"),this.safeFloat(i,"h"),this.safeFloat(i,"l"),this.safeFloat(i,"c"),this.safeFloat(i,"v")],o=this.safeSymbol(n),d=this.safeString(i,"i"),c=this.findTimeframe(d);this.ohlcvs[o]=this.safeValue(this.ohlcvs,o,{});let u=this.safeValue(this.ohlcvs[o],c);if(u===void 0){const h=this.safeInteger(this.options,"OHLCVLimit",1e3);u=new dW(h),this.ohlcvs[o][c]=u}u.append(a),e.resolve(u,r)}handleSubscribeMessage(e,t){const s=this.safeValue(t,"subscriptions");for(let i=0;i<s.length;i++){const n=s[i];if(this.safeString(n,"name")==="l2orderbook"){const a=this.safeValue(n,"markets");for(let o=0;o<a.length;o++){const d=a[o],c=this.safeValue(this.options,"orderBookSubscriptions",{});if(!(d in c)){const u=this.safeSymbol(d);if(!(u in this.orderbooks)){const h=this.countedOrderBook({});h.cache=[],this.orderbooks[u]=h}this.spawn(this.fetchOrderBookSnapshot,e,u)}}break}}}async fetchOrderBookSnapshot(e,t,s={}){const i=this.orderbooks[t],r="l2orderbook:"+this.market(t).id,a=e.subscriptions[r];a.fetchingOrderBookSnapshot||(a.startTime=this.milliseconds()),a.fetchingOrderBookSnapshot=!0;const o=this.safeInteger(this.options,"fetchOrderBookSnapshotMaxAttempts",10),d=this.safeInteger(this.options,"fetchOrderBookSnapshotMaxDelay",1e4);try{const c=this.safeInteger(a,"limit",0),u=await this.fetchOrderBook(t,c),h=this.safeValue(i.cache,0),l=this.safeValue(h,"data"),p=this.safeInteger(l,"u"),m=i.cache.length,g=this.safeValue(i.cache,m-1),y=this.safeValue(g,"data"),b=this.safeInteger(y,"u");if(p!==void 0&&b!==void 0&&p<=u.nonce+1&&b>u.nonce){i.reset(u);for(let S=0;S<i.cache.length;S++){const k=i.cache[S],T=this.safeValue(k,"data");this.safeInteger(T,"u")>i.nonce&&this.handleOrderBookMessage(e,k,i)}a.fetchingOrderBookSnapshot=!1,e.resolve(i,r)}else{a.numAttempts=a.numAttempts+1;const S=this.milliseconds()-a.startTime,k=a.numAttempts<o,T=S<d;if(k&&T)this.delay(this.rateLimit,this.fetchOrderBookSnapshot,e,t);else{const I=k?" after "+d.toString()+" milliseconds":" in "+o.toString()+" attempts";throw new aW(this.id+" failed to synchronize WebSocket feed with the snapshot for symbol "+t+I)}}}catch(c){a.fetchingOrderBookSnapshot=!1,e.reject(c,r)}}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n="l2orderbook",r={name:n,markets:[i.id]},a=n+":"+i.id,o={fetchingOrderBookSnapshot:!1,numAttempts:0,startTime:void 0};return t===void 0?o.limit=1e3:o.limit=t,(await this.subscribe(r,a,o)).limit()}handleOrderBook(e,t){const s=this.safeValue(t,"data"),i=this.safeString(s,"m"),n=this.safeSymbol(i),r=this.orderbooks[n];r.nonce===void 0?r.cache.push(t):this.handleOrderBookMessage(e,t,r)}handleOrderBookMessage(e,t,s){const i=this.safeString(t,"type"),n=this.safeValue(t,"data"),r=this.safeString(n,"m"),a=i+":"+r,o=this.safeInteger(n,"u"),d=this.safeInteger(n,"t"),c=this.safeValue(n,"b"),u=this.safeValue(n,"a");this.handleDeltas(s.bids,c),this.handleDeltas(s.asks,u),s.nonce=o,s.timestamp=d,s.datetime=this.iso8601(d),e.resolve(s,a)}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1),n=this.safeInteger(t,2);e.store(s,i,n)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async authenticate(e={}){const t=this.seconds(),s=this.safeInteger(this.options,"lastAuthenticatedTime",0);if(t-s>900){const i={wallet:this.walletAddress,nonce:this.uuidv1()},n=await this.privateGetWsToken(this.extend(i,e));this.options.lastAuthenticatedTime=t,this.options.token=this.safeString(n,"token")}return this.options.token}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n="orders",r={name:n};let a=n;if(e!==void 0){e=this.symbol(e);const d=this.marketId(e);r.markets=[d],a=n+":"+d}const o=await this.subscribePrivate(r,a);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}handleOrder(e,t){const s=this.safeString(t,"type"),i=this.safeValue(t,"data"),n=this.safeString(i,"m"),r=this.safeSymbol(n),a=this.safeInteger(i,"t"),o=this.safeValue(i,"F"),d=[];for(let x=0;x<o.length;x++)d.push(this.parseWsTrade(o[x]));const c=this.safeString(i,"i"),u=this.safeString(i,"s"),h=this.safeString(i,"o"),l=this.safeFloat(i,"q"),p=this.safeFloat(i,"z");let m;l!==void 0&&p!==void 0&&(m=l-p);const g=this.safeFloat(i,"v"),y=this.safeFloat(i,"price",g);let b;l!==void 0&&y!==void 0&&(b=l*y);const w=this.safeString(i,"X"),S=this.parseOrderStatus(w),k={currency:void 0,cost:void 0};let T;for(let x=0;x<d.length;x++)T=d[x],k.currency=T.fee.currency,k.cost=this.sum(k.cost,T.fee.cost);const I=this.safeInteger(T,"timestamp"),_={info:t,id:c,clientOrderId:void 0,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:I,symbol:r,type:h,side:u,price:y,stopPrice:void 0,amount:l,cost:b,average:g,filled:p,remaining:m,status:S,fee:k,trades:d};if(this.orders===void 0){const x=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new iO(x)}const N=this.orders;N.append(_);const M=s+":"+n;e.resolve(N,M),e.resolve(N,s)}async watchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n="balances",r={name:n};let a=n;e!==void 0&&(a=n+":"+e);const o=await this.subscribePrivate(r,a);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}handleTransaction(e,t){const s=this.safeString(t,"type"),i=this.safeValue(t,"data"),n=this.safeString(i,"a"),r=s+":"+n,a=this.safeCurrencyCode(n),o=this.safeString(i,"w"),d={info:t,id:void 0,currency:a,amount:void 0,address:o,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,status:"ok",type:void 0,updated:void 0,txid:void 0,timestamp:void 0,datetime:void 0,fee:void 0};if(!(a in this.transactions)){const u=this.safeInteger(this.options,"transactionsLimit",1e3);this.transactions[a]=new oW(u)}const c=this.transactions[a];c.append(d),e.resolve(c,r),e.resolve(c,s)}handleMessage(e,t){const s=this.safeString(t,"type"),i={tickers:this.handleTicker,trades:this.handleTrade,subscriptions:this.handleSubscribeMessage,candles:this.handleOHLCV,l2orderbook:this.handleOrderBook,balances:this.handleTransaction,orders:this.handleOrder};s in i&&i[s].call(this,e,t)}};const uW=H_,{BadSymbol:fW,BadRequest:hW,ExchangeError:lW,NotSupported:pW,InvalidNonce:mW}=oe,{ArrayCache:nO,ArrayCacheByTimestamp:gW,ArrayCacheBySymbolById:yW}=et;var bW=class extends uW{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!1,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0},urls:{api:{ws:{public:"wss://ws.kraken.com",private:"wss://ws-auth.kraken.com",beta:"wss://beta-ws.kraken.com"}}},versions:{ws:"0.2.0"},options:{tradesLimit:1e3,OHLCVLimit:1e3,ordersLimit:1e3,symbolsByOrderId:{},checksum:!0},exceptions:{ws:{exact:{"Event(s) not found":hW},broad:{"Currency pair not in ISO 4217-A3 format":fW}}}})}handleTicker(e,t,s){const i=t[3],r="ticker"+":"+i,o=this.safeValue(this.options.marketsByWsName,i).symbol,d=t[1],c=this.safeFloat(d.p,0);let u;const h=this.safeFloat(d.v,0);h!==void 0&&c!==void 0&&(u=h*c);const l=this.safeFloat(d.c,0),p=this.milliseconds(),m={symbol:o,timestamp:p,datetime:this.iso8601(p),high:this.safeFloat(d.h,0),low:this.safeFloat(d.l,0),bid:this.safeFloat(d.b,0),bidVolume:this.safeFloat(d.b,2),ask:this.safeFloat(d.a,0),askVolume:this.safeFloat(d.a,2),vwap:c,open:this.safeFloat(d.o,0),close:l,last:l,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:h,quoteVolume:u,info:d};this.tickers[o]=m,e.resolve(m,r)}handleTrades(e,t,s){const i=this.safeString(t,3),r=this.safeString(t,2)+":"+i,a=this.safeValue(this.options.marketsByWsName,i),o=a.symbol;let d=this.safeValue(this.trades,o);if(d===void 0){const h=this.safeInteger(this.options,"tradesLimit",1e3);d=new nO(h),this.trades[o]=d}const c=this.safeValue(t,1,[]),u=this.parseTrades(c,a);for(let h=0;h<u.length;h++)d.append(u[h]);e.resolve(d,r)}handleOHLCV(e,t,s){const i=this.safeValue(s,"subscription",{}),n=this.safeInteger(i,"interval"),r=this.safeString(i,"name"),a=this.safeString(t,3),d=this.safeValue(this.options.marketsByWsName,a).symbol,c=this.findTimeframe(n),u=this.parseTimeframe(c);if(c!==void 0){const h=this.safeValue(t,1),l=r+":"+c+":"+a;let p=this.safeFloat(h,1);p-=u;const m=[parseInt(p*1e3),this.safeFloat(h,2),this.safeFloat(h,3),this.safeFloat(h,4),this.safeFloat(h,5),this.safeFloat(h,7)];this.ohlcvs[d]=this.safeValue(this.ohlcvs,d,{});let g=this.safeValue(this.ohlcvs[d],c);if(g===void 0){const y=this.safeInteger(this.options,"OHLCVLimit",1e3);g=new gW(y),this.ohlcvs[d][c]=g}g.append(m),e.resolve(g,l)}}requestId(){const e=this.sum(this.safeInteger(this.options,"reqid",0),1);return this.options.reqid=e,e}async watchPublic(e,t,s={}){await this.loadMarkets();const i=this.market(t),n=this.safeValue(i.info,"wsname"),r=e+":"+n,a=this.urls.api.ws.public,d={event:"subscribe",reqid:this.requestId(),pair:[n],subscription:{name:e}},c=this.deepExtend(d,s);return await this.watch(a,r,c,r)}async watchTicker(e,t={}){return await this.watchPublic("ticker",e,t)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n="trade",r=await this.watchPublic(n,e,i);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySinceLimit(r,t,s,"timestamp",!0)}async watchOrderBook(e,t=void 0,s={}){const i="book",n={};if(t!==void 0)if(t===10||t===25||t===100||t===500||t===1e3)n.subscription={depth:t};else throw new pW(this.id+" watchOrderBook accepts limit values of 10, 25, 100, 500 and 1000 only");return(await this.watchPublic(i,e,this.extend(n,s))).limit()}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r="ohlc",a=this.market(e);e=a.symbol;const o=this.safeValue(a.info,"wsname"),d=r+":"+t+":"+o,c=this.urls.api.ws.public,h={event:"subscribe",reqid:this.requestId(),pair:[o],subscription:{name:r,interval:this.timeframes[t]}},l=this.deepExtend(h,n),p=await this.watch(c,d,l,d);return this.newUpdates&&(i=p.getLimit(e,i)),this.filterBySinceLimit(p,s,i,0,!0)}async loadMarkets(e=!1,t={}){const s=await super.loadMarkets(e,t);let i=this.safeValue(this.options,"marketsByWsName");if(i===void 0||e){i={};for(let n=0;n<this.symbols.length;n++){const r=this.symbols[n],a=this.markets[r];if(a.darkpool){const o=this.safeValue(a,"info",{}),d=this.safeString(o,"altname"),c=d.slice(0,3)+"/"+d.slice(3);i[c]=a}else{const o=this.safeValue(a,"info",{}),d=this.safeString(o,"wsname");i[d]=a}}this.options.marketsByWsName=i}return s}async watchHeartbeat(e={}){await this.loadMarkets();const t="heartbeat",s=this.urls.api.ws.public;return await this.watch(s,t)}handleHeartbeat(e,t){const s=this.safeString(t,"event");e.resolve(t,s)}handleOrderBook(e,t,s){const i=t.length,n=t[i-1],a=t[i-2].split("-"),o=this.safeInteger(a,1,10),c=this.safeValue(this.options.marketsByWsName,n).symbol;let u;const h="book:"+n;if("as"in t[1]){this.orderbooks[c]=this.orderBook({},o);const l=this.orderbooks[c],p={as:"asks",bs:"bids"},m=Object.keys(p);for(let g=0;g<m.length;g++){const y=m[g],b=p[y],w=l[b],S=this.safeValue(t[1],y,[]);u=this.handleDeltas(w,S,u)}l.symbol=c,l.timestamp=u,l.datetime=this.iso8601(u),e.resolve(l,h)}else{const l=this.orderbooks[c];let p,m,g;i===5?(p=this.safeValue(t[1],"a",[]),m=this.safeValue(t[2],"b",[]),g=this.safeInteger(t[1],"c"),g=this.safeInteger(t[2],"c",g)):(g=this.safeInteger(t[1],"c"),"a"in t[1]?p=this.safeValue(t[1],"a",[]):m=this.safeValue(t[1],"b",[]));const y=l.asks,b=l.bids;let w;if(p!==void 0&&(u=this.handleDeltas(y,p,u),w=this.safeValue(p,0)),m!==void 0&&(u=this.handleDeltas(b,m,u),w=this.safeValue(m,0)),l.limit(),this.safeValue(this.options,"checksum",!0)){const k=this.safeString(w,0),T=this.safeString(w,1),I=k.split("."),_=T.split("."),N=I[1].length-0,M=_[1].length-0,x=[];if(g!==void 0){for(let A=0;A<10;A++){const V=this.formatNumber(y[A][0],N)+this.formatNumber(y[A][1],M);x.push(V)}for(let A=0;A<10;A++){const V=this.formatNumber(b[A][0],N)+this.formatNumber(b[A][1],M);x.push(V)}}const v=x.join("");if(this.crc32(v,!1)!==g){const A=new mW(this.id+" invalid checksum");e.reject(A,h)}}l.symbol=c,l.timestamp=u,l.datetime=this.iso8601(u),e.resolve(l,h)}}formatNumber(e,t){const i=this.numberToString(e).split("."),n=this.safeString(i,0),a=this.safeString(i,1,"").padEnd(t,"0"),o=n+a;let d=0;for(;o[d]==="0";)d+=1;return d>0?o.slice(d):o}handleDeltas(e,t,s){for(let i=0;i<t.length;i++){const n=t[i],r=parseFloat(n[0]),a=parseFloat(n[1]);s=Math.max(s||0,parseInt(parseFloat(n[2])*1e3)),e.store(r,a)}return s}handleSystemStatus(e,t){return t}async authenticate(e={}){const t=this.urls.api.ws.private,s=this.client(t),i="authenticated";let n=this.safeValue(s.subscriptions,i);if(n===void 0){const r=await this.privatePostGetWebSocketsToken(e);n=this.safeValue(r,"result"),s.subscriptions[i]=n}return this.safeString(n,"token")}async watchPrivate(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r=await this.authenticate(),a=e;let o=e;t!==void 0&&(t=this.symbol(t),o+=":"+t);const d=this.urls.api.ws.private,u={event:"subscribe",reqid:this.requestId(),subscription:{name:e,token:r}},h=this.deepExtend(u,n),l=await this.watch(d,o,h,a);return this.newUpdates&&(i=l.getLimit(t,i)),this.filterBySymbolSinceLimit(l,t,s,i,!0)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){return await this.watchPrivate("ownTrades",e,t,s,i)}handleMyTrades(e,t,s=void 0){const i=this.safeValue(t,0,[]);if(i.length>0){if(this.myTrades===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new nO(c)}const r=this.myTrades,a={};for(let c=0;c<i.length;c++){const u=this.safeValue(i,c,{}),h=Object.keys(u);for(let l=0;l<h.length;l++){const p=h[l],m=u[p],g=this.parseWsTrade(this.extend({id:p},m));r.append(g);const y=g.symbol;a[y]=!0}}const o="ownTrades";e.resolve(this.myTrades,o);const d=Object.keys(a);for(let c=0;c<d.length;c++){const u=o+":"+d[c];e.resolve(this.myTrades,u)}}}parseWsTrade(e,t=void 0){const s=this.safeString(e,"pair");t=this.safeValue(this.options.marketsByWsName,s,t);let i;const n=this.safeString(e,"ordertxid"),r=this.safeString2(e,"id","postxid"),a=this.safeTimestamp(e,"time"),o=this.safeString(e,"type"),d=this.safeString(e,"ordertype"),c=this.safeFloat(e,"price"),u=this.safeFloat(e,"vol");let h,l;if("fee"in e){let p;t!==void 0&&(p=t.quote),l={cost:this.safeFloat(e,"fee"),currency:p}}return t!==void 0&&(i=t.symbol),c!==void 0&&u!==void 0&&(h=c*u),{id:r,order:n,info:e,timestamp:a,datetime:this.iso8601(a),symbol:i,type:d,side:o,takerOrMaker:void 0,price:c,amount:u,cost:h,fee:l}}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.watchPrivate("openOrders",e,t,s,i)}handleOrders(e,t,s=void 0){const i=this.safeValue(t,0,[]);if(i.length>0){const r=this.safeInteger(this.options,"ordersLimit",1e3);this.orders===void 0&&(this.orders=new yW(r));const a=this.orders,o={};for(let u=0;u<i.length;u++){const h=this.safeValue(i,u,{}),l=Object.keys(h);for(let p=0;p<l.length;p++){const m=l[p],g=h[m],y=this.parseWsOrder(g);y.id=m;let b;const w=this.safeValue(this.options,"symbolsByOrderId",{});y.symbol!==void 0?(b=y.symbol,w[m]=b,this.options.symbolsByOrderId=w):b=this.safeString(w,m);const S=this.safeValue(a.hashmap,b),k=this.safeValue(S,m);let T=y;if(k!==void 0){const _=this.extend(k.info,T.info);T=this.parseWsOrder(_),T.id=m}if(a.length===r&&k===void 0){const _=a[0];_.id in w&&delete w[_.id]}a.append(T),o[b]=!0}}const d="openOrders";e.resolve(this.orders,d);const c=Object.keys(o);for(let u=0;u<c.length;u++){const h=d+":"+c[u];e.resolve(this.orders,h)}}}parseWsOrder(e,t=void 0){const s=this.safeValue(e,"descr",{}),i=this.safeString(s,"order");let n,r,a,o,d;if(i!==void 0){const I=i.split(" ");n=this.safeString(I,0),d=this.safeFloat(I,1),a=this.safeString(I,2),r=this.safeString(I,4),o=this.safeFloat(I,5)}n=this.safeString(s,"type",n),r=this.safeString(s,"ordertype",r),a=this.safeString(s,"pair",a),t=this.safeValue(this.options.marketsByWsName,a,t);let c;const u=this.safeTimestamp(e,"opentm");d=this.safeFloat(e,"vol",d);const h=this.safeFloat(e,"vol_exec");let l;d!==void 0&&h!==void 0&&(l=d-h);let p;const m=this.safeFloat(e,"cost");o=this.safeFloat(s,"price",o),(o===void 0||o===0)&&(o=this.safeFloat(s,"price2")),(o===void 0||o===0)&&(o=this.safeFloat(e,"price",o));const g=this.safeFloat2(e,"avg_price","price");if(t!==void 0&&(c=t.symbol,"fee"in e)){const I=e.oflags;p={cost:this.safeFloat(e,"fee"),rate:void 0},I.indexOf("fciq")>=0?p.currency=t.quote:I.indexOf("fcib")>=0&&(p.currency=t.base)}const y=this.parseOrderStatus(this.safeString(e,"status"));let b=this.safeString(e,"id");if(b===void 0){const I=this.safeValue(e,"txid");b=this.safeString(I,0)}const w=this.safeString(e,"userref"),S=this.safeValue(e,"trades");let k;S!==void 0&&(k=this.parseTrades(S,t,void 0,void 0,{order:b}));const T=this.safeFloat(e,"stopprice");return{id:b,clientOrderId:w,info:e,timestamp:u,datetime:this.iso8601(u),lastTradeTimestamp:void 0,status:y,symbol:c,type:r,timeInForce:void 0,postOnly:void 0,side:n,price:o,stopPrice:T,cost:m,amount:d,filled:h,average:g,remaining:l,fee:p,trades:k}}handleSubscriptionStatus(e,t){const s=this.safeString(t,"channelID");s!==void 0&&(e.subscriptions[s]=t)}handleErrorMessage(e,t){const s=this.safeValue(t,"errorMessage");if(s!==void 0){const i=this.safeValue(t,"reqid");if(i!==void 0){const n=this.exceptions.ws.broad,r=this.findBroadlyMatchedKey(n,s);let a;return r===void 0?a=new lW(s):a=new n[r](s),e.reject(a,i),!1}}return!0}handleMessage(e,t){if(Array.isArray(t)){const s=this.safeString(t,0),i=this.safeValue(e.subscriptions,s,{}),n=this.safeValue(i,"subscription",{}),r=t.length,a=this.safeString(t,r-2),o=this.safeString(n,"name"),d={book:this.handleOrderBook,ohlc:this.handleOHLCV,ticker:this.handleTicker,trade:this.handleTrades,openOrders:this.handleOrders,ownTrades:this.handleMyTrades},c=this.safeValue2(d,o,a);return c===void 0?t:c.call(this,e,t,i)}else if(this.handleErrorMessage(e,t)){const s=this.safeString(t,"event"),i={heartbeat:this.handleHeartbeat,systemStatus:this.handleSystemStatus,subscriptionStatus:this.handleSubscriptionStatus},n=this.safeValue(i,s);return n===void 0?t:n.call(this,e,t)}}};const wW=Ib,{ExchangeError:rO,InvalidNonce:SW,NetworkError:kW}=oe,{ArrayCache:vW,ArrayCacheByTimestamp:TW,ArrayCacheBySymbolById:aO}=et;var OW=class extends wW{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchOrders:!0,watchMyTrades:!0,watchTickers:!1,watchTicker:!0,watchTrades:!0,watchBalance:!0,watchOHLCV:!0},options:{tradesLimit:1e3,watchOrderBookRate:100,fetchOrderBookSnapshot:{maxAttempts:3,delay:1e3},watchTicker:{topic:"market/snapshot"}},streaming:{ping:this.ping}})}async negotiate(e={}){const t=this.client("ws"),s="negotiate";let i=this.safeValue(t.subscriptions,s);if(i===void 0){i=t.future(s),t.subscriptions[s]=i;let n;const r=!1;this.checkRequiredCredentials(r)?n=await this.privatePostBulletPrivate():n=await this.publicPostBulletPublic(),t.resolve(n,s)}return await i}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}async subscribe(e,t,s,i,n,r={}){await this.loadMarkets();const a=this.safeValue(e,"data",{}),o=this.safeValue(a,"instanceServers",[]),d=this.safeValue(o,0,{}),c=this.safeString(d,"endpoint"),u=this.safeString(a,"token"),h=this.requestId(),l={token:u,acceptUserMessage:"true"},p=c+"?"+this.urlencode(l),m={id:h,type:"subscribe",topic:t,response:!0},g={id:h.toString(),symbol:n,topic:t,messageHash:s,method:i},y=this.extend(m,r),b=t;return await this.watch(p,s,y,b,g)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i=await this.negotiate(),n=this.safeValue(this.options,"watchTicker",{}),a="/"+this.safeString(n,"topic","market/snapshot")+":"+s.id,o=a;return await this.subscribe(i,a,o,void 0,e,t)}handleTicker(e,t){const s=this.safeString(t,"topic");let i;if(s!==void 0){const c=s.split(":"),u=this.safeString(c,1);i=this.safeMarket(u,i,"-")}const n=this.safeValue(t,"data",{}),r=this.safeValue(n,"data",n),a=this.parseTicker(r,i),o=a.symbol;this.tickers[o]=a;const d=this.safeString(t,"topic");return d!==void 0&&e.resolve(a,d),t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=await this.negotiate(),a=this.market(e);e=a.symbol;const o=this.timeframes[t],d="/market/candles:"+a.id+"_"+o,c=d,u=await this.subscribe(r,d,c,void 0,e,n);return this.newUpdates&&(i=u.getLimit(e,i)),this.filterBySinceLimit(u,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(s,"symbol"),n=this.safeValue(s,"candles",[]),r=this.safeString(t,"topic"),a=r.split("_"),o=this.safeString(a,1),d=this.findTimeframe(o),c=this.safeSymbol(i),u=this.market(c);this.ohlcvs[c]=this.safeValue(this.ohlcvs,c,{});let h=this.safeValue(this.ohlcvs[c],d);if(h===void 0){const p=this.safeInteger(this.options,"OHLCVLimit",1e3);h=new TW(p),this.ohlcvs[c][d]=h}const l=this.parseOHLCV(n,u);h.append(l),e.resolve(h,r)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=await this.negotiate(),r=this.market(e);e=r.symbol;const a="/market/match:"+r.id,o=a,d=await this.subscribe(n,a,o,void 0,e,i);return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySinceLimit(d,t,s,"timestamp",!0)}handleTrade(e,t){const s=this.safeValue(t,"data",{}),i=this.parseTrade(s),n=this.safeString(t,"topic"),r=i.symbol;let a=this.safeValue(this.trades,r);if(a===void 0){const o=this.safeInteger(this.options,"tradesLimit",1e3);a=new vW(o),this.trades[r]=a}return a.append(i),e.resolve(a,n),t}async watchOrderBook(e,t=void 0,s={}){if(t!==void 0&&t!==20&&t!==100)throw new rO(this.id+" watchOrderBook 'limit' argument must be undefined, 20 or 100");await this.loadMarkets();const i=await this.negotiate(),n=this.market(e);e=n.symbol;const r="/market/level2:"+n.id,a=r;return(await this.subscribe(i,r,a,this.handleOrderBookSubscription,e,s)).limit()}retryFetchOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeString(s,"messageHash"),r=this.safeValue(this.options,"fetchOrderBookSnapshot",{}),a=this.safeInteger(r,"maxAttempts",3);let o=this.safeInteger(s,"numAttempts",0);if(o<a)n in e.subscriptions&&(o=this.sum(o,1),s.numAttempts=o,e.subscriptions[n]=s,this.spawn(this.fetchOrderBookSnapshot,e,t,s));else{n in e.subscriptions&&(s.fetchingOrderBookSnapshot=!1,s.numAttempts=0,e.subscriptions[n]=s);const d=new SW(this.id+" failed to synchronize WebSocket feed with the snapshot for symbol "+i+" in "+a.toString()+" attempts");e.reject(d,n)}}async fetchOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit"),r=this.safeString(s,"messageHash");try{const a=await this.fetchOrderBook(i,n),o=this.orderbooks[i],d=o.cache,c=this.safeValue(d,0,{}),u=this.safeValue(c,"data",{}),h=this.safeInteger(u,"sequenceStart"),l=this.safeInteger(a,"nonce"),p=h-1;if(l<p)this.retryFetchOrderBookSnapshot(e,t,s);else{o.reset(a);for(let m=0;m<d.length;m++){const g=d[m];this.handleOrderBookMessage(e,g,o)}this.orderbooks[i]=o,e.resolve(o,r)}}catch(a){a instanceof kW?this.retryFetchOrderBookSnapshot(e,t,s):e.reject(a,r)}}handleDelta(e,t,s){const i=this.safeFloat(t,0);if(i>0&&this.safeInteger(t,2)>s){const r=this.safeFloat(t,1);e.store(i,r)}}handleDeltas(e,t,s){for(let i=0;i<t.length;i++)this.handleDelta(e,t[i],s)}handleOrderBookMessage(e,t,s){const i=this.safeValue(t,"data",{}),n=this.safeInteger(i,"sequenceEnd");if(n>s.nonce){const r=this.safeInteger(t,"sequenceStart");if(r!==void 0&&r-1>s.nonce)throw new rO(this.id+" handleOrderBook received an out-of-order nonce");const a=this.safeValue(i,"changes",{});let o=this.safeValue(a,"asks",[]),d=this.safeValue(a,"bids",[]);o=this.sortBy(o,2),d=this.sortBy(d,2),this.handleDeltas(s.asks,o,s.nonce),this.handleDeltas(s.bids,d,s.nonce),s.nonce=n,s.timestamp=void 0,s.datetime=void 0}return s}handleOrderBook(e,t){const s=this.safeString(t,"topic"),i=this.safeValue(t,"data"),n=this.safeString(i,"symbol"),r=this.safeSymbol(n,void 0,"-"),a=this.orderbooks[r];if(a.nonce===void 0){const o=this.safeValue(e.subscriptions,s);if(this.safeValue(o,"fetchingOrderBookSnapshot")===void 0){o.fetchingOrderBookSnapshot=!0,e.subscriptions[s]=o;const c=this.safeValue(this.options,"fetchOrderBookSnapshot",{}),u=this.safeInteger(c,"delay",this.rateLimit);this.delay(u,this.fetchOrderBookSnapshot,e,t,o)}a.cache.push(t)}else this.handleOrderBookMessage(e,t,a),e.resolve(a,s)}handleOrderBookSubscription(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeString(s,"limit");i in this.orderbooks&&delete this.orderbooks[i],this.orderbooks[i]=this.orderBook({},n)}handleSubscriptionStatus(e,t){const s=this.safeString(t,"id"),i=this.indexBy(e.subscriptions,"id"),n=this.safeValue(i,s,{}),r=this.safeValue(n,"method");return r!==void 0&&r.call(this,e,t,n),t}handleSystemStatus(e,t){return t}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=await this.negotiate(),r="/spotMarket/tradeOrders",a={privateChannel:!0};let o=r;if(e!==void 0){const c=this.market(e);e=c.symbol,o=o+":"+c.symbol}const d=await this.subscribe(n,r,o,void 0,void 0,this.extend(a,i));return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySymbolSinceLimit(d,e,t,s,!0)}parseWsOrderStatus(e){const t={open:"open",filled:"closed",match:"open",update:"open",canceled:"canceled"};return this.safeString(t,e,e)}parseWsOrder(e,t=void 0){const s=this.safeString(e,"orderId"),i=this.safeString(e,"clientOid"),n=this.safeStringLower(e,"orderType"),r=this.safeString(e,"price"),a=this.safeString(e,"filledSize"),o=this.safeString(e,"size"),d=this.safeString(e,"type"),c=this.parseWsOrderStatus(d),u=this.safeIntegerProduct(e,"orderTime",1e-6),h=this.safeString(e,"symbol");t=this.safeMarket(h,t);const l=t.symbol,p=this.safeStringLower(e,"side");return this.safeOrder({info:e,symbol:l,id:s,clientOrderId:i,timestamp:u,datetime:this.iso8601(u),lastTradeTimestamp:void 0,type:n,timeInForce:void 0,postOnly:void 0,side:p,price:r,stopPrice:void 0,amount:o,cost:void 0,average:void 0,filled:a,remaining:void 0,status:c,fee:void 0,trades:void 0},t)}handleOrder(e,t){const s="/spotMarket/tradeOrders",i=this.safeValue(t,"data"),n=this.parseWsOrder(i),r=this.safeString(n,"symbol"),a=this.safeString(n,"id");if(r!==void 0){if(this.orders===void 0){const h=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new aO(h)}const o=this.orders,d=this.safeValue(o.hashmap,r,{}),c=this.safeValue(d,a);if(c!==void 0){const h=this.safeValue(c,"stopPrice");h!==void 0&&(n.stopPrice=h),c.status==="closed"&&(n.status="closed")}o.append(n),e.resolve(this.orders,s);const u=s+":"+r;e.resolve(this.orders,u)}}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=await this.negotiate(),r="/spot/tradeFills",a={privateChannel:!0};let o=r;if(e!==void 0){const c=this.market(e);e=c.symbol,o=o+":"+c.symbol}const d=await this.subscribe(n,r,o,void 0,void 0,this.extend(a,i));return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySymbolSinceLimit(d,e,t,s)}handleMyTrade(e,t){let s=this.myTrades;if(s===void 0){const o=this.safeInteger(this.options,"tradesLimit",1e3);s=new aO(o)}const i=this.safeValue(t,"data"),n=this.parseWsTrade(i);s.append(n);const r="/spot/tradeFills";e.resolve(s,r);const a=r+":"+n.symbol;e.resolve(s,a)}parseWsTrade(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,"-");const i=t.symbol,n=this.safeString(e,"orderType"),r=this.safeString(e,"side"),a=this.safeString(e,"tradeId"),o=this.safeString(e,"price"),d=this.safeString(e,"size"),c=this.safeString(e,"orderId"),u=this.safeIntegerProduct(e,"time",1e-6),h=t.quote,p={cost:void 0,rate:this.safeString(e,"feeRate"),currency:h};return this.safeTrade({info:e,timestamp:u,datetime:this.iso8601(u),symbol:i,id:a,order:c,type:n,takerOrMaker:void 0,side:r,price:o,amount:d,cost:void 0,fee:p},t)}async watchBalance(e={}){await this.loadMarkets();const t=await this.negotiate(),s="/account/balance",i={privateChannel:!0},n=s;return await this.subscribe(t,s,n,this.handleBalanceSubscription,void 0,this.extend(i,e))}handleBalance(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(t,"topic"),n=this.safeString(s,"currency"),r=this.safeString(s,"relationEvent");let a;if(r!==void 0){const l=r.split(".");a=this.safeString(l,0)}const o=this.safeString2(this.options,"watchBalance","defaultType","trade"),d=this.safeValue(this.options,"accountsByType"),c=this.safeString(d,a,"trade");c in this.balance||(this.balance[c]={});const u=this.safeCurrencyCode(n),h=this.account();h.free=this.safeString(s,"available"),h.used=this.safeString(s,"hold"),h.total=this.safeString(s,"total"),this.balance[c][u]=h,this.balance[c]=this.safeBalance(this.balance[c]),c===o&&e.resolve(this.balance[c],i)}handleBalanceSubscription(e,t,s){this.spawn(this.fetchBalanceSnapshot,e,t)}async fetchBalanceSnapshot(e,t){await this.loadMarkets(),this.checkRequiredCredentials();const s="/account/balance",n={type:this.safeString2(this.options,"watchBalance","defaultType","spot")},r=await this.fetchBalance(n),a=this.safeValue(r.info,"data",[]);if(a.length>0){const o=this.safeString2(this.options,"watchBalance","defaultType","trade");for(let d=0;d<a.length;d++){const c=a[d],u=this.safeString(c,"type"),h=this.safeValue(this.options,"accountsByType"),l=this.safeString(h,u,"trade");l in this.balance||(this.balance[l]={});const p=this.safeString(c,"currency"),m=this.safeCurrencyCode(p),g=this.account();g.free=this.safeString(c,"available"),g.used=this.safeString(c,"holds"),g.total=this.safeString(c,"total"),this.balance[o][m]=g,this.balance[o]=this.safeBalance(this.balance[o])}e.resolve(this.balance[o],s)}}handleSubject(e,t){const s=this.safeString(t,"subject"),i={"trade.l2update":this.handleOrderBook,"trade.ticker":this.handleTicker,"trade.snapshot":this.handleTicker,"trade.l3match":this.handleTrade,"trade.candles.update":this.handleOHLCV,"account.balance":this.handleBalance,"/spot/tradeFills":this.handleMyTrade,orderChange:this.handleOrder},n=this.safeValue(i,s);return n===void 0?t:n.call(this,e,t)}ping(e){return{id:this.requestId().toString(),type:"ping"}}handlePong(e,t){return e.lastPong=this.milliseconds(),t}handleErrorMessage(e,t){return t}handleMessage(e,t){if(this.handleErrorMessage(e,t)){const s=this.safeString(t,"type"),i={welcome:this.handleSystemStatus,ack:this.handleSubscriptionStatus,message:this.handleSubject,pong:this.handlePong},n=this.safeValue(i,s);return n===void 0?t:n.call(this,e,t)}}};const IW=G_,{ArrayCache:xW}=et;var _W=class extends IW{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!1,watchTickers:!1,watchTrades:!0,watchMyTrades:!1,watchOrders:void 0,watchOrderBook:!0,watchOHLCV:!1},urls:{api:{ws:"wss://ws.luno.com/api/1"}},options:{sequenceNumbers:{}},streaming:{},exceptions:{}})}async watchTrades(e,t=void 0,s=void 0,i={}){await this.checkRequiredCredentials(),await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="/stream/"+n.id,a={symbol:e},o=this.urls.api.ws+r,d="trades:"+e,c={api_key_id:this.apiKey,api_key_secret:this.secret},u=this.deepExtend(c,i),h=await this.watch(o,d,u,r,a);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySinceLimit(h,t,s,"timestamp",!0)}handleTrades(e,t,s){const i=this.safeValue(t,"trade_updates",[]);if(i.length===0)return;const r=s.symbol,a=this.market(r),o="trades:"+r;let d=this.safeValue(this.trades,r);if(d===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);d=new xW(c),this.trades[r]=d}for(let c=0;c<i.length;c++){const u=i[c],h=this.parseTrade(u,a);d.append(h)}this.trades[r]=d,e.resolve(this.trades[r],o)}parseTrade(e,t){return this.safeTrade({info:e,id:void 0,timestamp:void 0,datetime:void 0,symbol:t.symbol,order:void 0,type:void 0,side:void 0,takerOrMaker:void 0,price:void 0,amount:this.safeString(e,"base"),cost:this.safeString(e,"counter"),fee:void 0},t)}async watchOrderBook(e,t=void 0,s={}){await this.checkRequiredCredentials(),await this.loadMarkets();const i=this.market(e);e=i.symbol;const n="/stream/"+i.id,r={symbol:e},a=this.urls.api.ws+n,o="orderbook:"+e,d={api_key_id:this.apiKey,api_key_secret:this.secret},c=this.deepExtend(d,s);return(await this.watch(a,o,c,n,r)).limit(t)}handleOrderBook(e,t,s){const i=s.symbol,n="orderbook:"+i,r=this.safeString(t,"timestamp");let a=this.safeValue(this.orderbooks,i);if(a===void 0&&(a=this.indexedOrderBook({}),this.orderbooks[i]=a),this.safeValue(t,"asks")!==void 0){const c=this.parseOrderBook(t,i,r,"bids","asks","price","volume","id");a.reset(c)}else this.handleDelta(a,t),a.timestamp=r,a.datetime=this.iso8601(r);const d=this.safeInteger(t,"sequence");a.nonce=d,e.resolve(a,n)}parseOrderBook(e,t,s=void 0,i="bids",n="asks",r=0,a=1,o=void 0){const d=this.parseBidsAsks(this.safeValue(e,i,[]),r,a,o),c=this.parseBidsAsks(this.safeValue(e,n,[]),r,a,o);return{symbol:t,bids:this.sortBy(d,0,!0),asks:this.sortBy(c,0),timestamp:s,datetime:this.iso8601(s),nonce:void 0}}parseBidsAsks(e,t=0,s=1,i=void 0){e=this.toArray(e);const n=[];for(let r=0;r<e.length;r++)n.push(this.parseBidAsk(e[r],t,s,i));return n}parseBidAsk(e,t=0,s=1,i=void 0){const n=this.safeNumber(e,t),r=this.safeNumber(e,s),a=[n,r];if(i!==void 0){const o=this.safeString(e,i);a.push(o)}return a}handleDelta(e,t){const s=this.safeValue(t,"create_update"),i=e.asks,n=e.bids;if(s!==void 0){const a=this.parseBidAsk(s,"price","volume","order_id"),o=this.safeString(s,"type");o==="ASK"?i.storeArray(a):o==="BID"&&n.storeArray(a)}const r=this.safeValue(t,"delete_update");if(r!==void 0){const a=this.safeString(r,"order_id");i.storeArray(0,0,a),n.storeArray(0,0,a)}return t}handleMessage(e,t){if(t==="")return;const s=Object.values(e.subscriptions),i=[this.handleOrderBook,this.handleTrades];for(let n=0;n<i.length;n++)i[n].call(this,e,t,s[0]);return t}};const CW=U_,{AuthenticationError:oO,BadSymbol:MW,BadRequest:PW,NotSupported:Ng}=oe,{ArrayCache:AW,ArrayCacheBySymbolById:dO,ArrayCacheByTimestamp:BW}=et;var NW=class extends CW{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0},urls:{api:{ws:{spot:"wss://wbs.mexc.com/raw/ws",swap:"wss://contract.mexc.com/ws"}}},options:{timeframes:{"1m":"Min1","5m":"Min5","15m":"Min15","30m":"Min30","1h":"Min60","4h":"Hour4","8h":"Hour8","1d":"Day1","1w":"Week1","1M":"Month1"}},streaming:{ping:this.ping,keepAlive:1e4},exceptions:{ws:{exact:{"signature validation failed":oO},broad:{"Contract not exists":MW}}}})}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i="sub.ticker",n="ticker:"+e,r={symbol:s.id};if(s.type==="spot")throw new Ng(this.id+" watchTicker does not support spot markets");return await this.watchSwapPublic(n,i,r,t)}handleTicker(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(t,"symbol"),n=this.safeMarket(i),r=n.symbol,a=this.parseTicker(s,n);this.tickers[r]=a;const o="ticker:"+r;return e.resolve(a,o),t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={};e=r.symbol;const o=r.type,d=this.safeValue(this.options,"timeframes",{}),c=this.safeString(d,t),u="sub.kline",h="kline:"+c+":"+e;a.symbol=r.id,a.interval=c,s!==void 0&&(a.start=s);let l;return o==="spot"?l=await this.watchSpotPublic(h,u,a,n):l=await this.watchSwapPublic(h,u,a,n),this.newUpdates&&(i=l.getLimit(e,i)),this.filterBySinceLimit(l,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"symbol"),i=this.safeMarket(s),n=i.symbol,r=this.safeValue(t,"data",{}),a=this.safeString(r,"interval"),o="kline:"+a+":"+n,d=this.safeValue(this.options,"timeframes",{}),c=this.findTimeframe(a,d),u=this.parseWsOHLCV(r,i);this.ohlcvs[n]=this.safeValue(this.ohlcvs,n,{});let h=this.safeValue(this.ohlcvs[n],c);if(h===void 0){const l=this.safeInteger(this.options,"OHLCVLimit",1e3);h=new BW(l),this.ohlcvs[n][c]=h}return h.append(u),e.resolve(h,o),t}parseWsOHLCV(e,t=void 0){return[this.safeIntegerProduct(e,"t",1e3),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber2(e,"v","q")]}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n="orderbook:"+e,r={symbol:i.id};if(t!==void 0){if(t!==5&&t!==10&&t!==20)throw new PW(this.id+" watchOrderBook limit parameter cannot be different from 5, 10 or 20")}else t=20;let a;if(i.type==="swap"){const o="sub.depth";r.compress=!0,r.limit=t,a=await this.watchSwapPublic(n,o,r,s)}else{const o="sub.limit.depth";r.depth=t,a=await this.watchSpotPublic(n,o,r,s)}return a.limit()}handleOrderBook(e,t){const s=this.safeString(t,"symbol"),i=this.safeMarket(s),n=i.symbol,r=this.safeValue(t,"data"),a=this.safeInteger(t,"ts"),o=this.parseOrderBook(r,n,a);let d=this.safeNumber(r,"end");d===void 0&&(d=this.safeNumber(t,"version")),o.nonce=d;let c=this.safeValue(this.orderbooks,n);c===void 0?(c=this.orderBook(o),this.orderbooks[n]=c):i.type==="spot"?c.reset(o):this.handleOrderBookMessage(e,t,c);const u="orderbook:"+n;e.resolve(c,u)}handleOrderBookMessage(e,t,s){const i=this.safeValue(t,"data",{}),n=this.safeNumber(i,"end"),r=this.safeValue(i,"asks",[]),a=this.safeValue(i,"bids",[]);this.handleDeltas(s.asks,r),this.handleDeltas(s.bids,a);const o=this.safeInteger(t,"ts"),d=this.safeString(t,"symbol"),c=this.safeSymbol(d);return s.nonce=n,s.symbol=c,s.timestamp=o,s.datetime=this.iso8601(o),s}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="sub.deal",a="trades:"+e,o={symbol:n.id};let d;return n.type==="spot"?d=await this.watchSpotPublic(a,r,o,i):d=await this.watchSwapPublic(a,r,o,i),this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySinceLimit(d,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeString(t,"symbol"),i=this.safeMarket(s),n=i.symbol;let r=this.safeValue(this.trades,n);if(r===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);r=new AW(c),this.trades[n]=r}const a=this.safeValue(t,"data",{});let o;"deals"in a?o=this.safeValue(a,"deals",[]):o=[a];for(let c=0;c<o.length;c++){const u=this.parseWsTrade(o[c],i);r.append(u)}const d="trades:"+n;e.resolve(r,d)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n="trade",r;e!==void 0&&(r=this.market(e),e=r.symbol,n+=":"+r.symbol);let a;[a,i]=this.handleMarketTypeAndParams("watchMyTrades",r,i);let o;if(a==="spot")throw new Ng(this.id+" watchMyTrades does not support spot markets");return o=await this.watchSwapPrivate(n,i),this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleMyTrade(e,t,s=void 0){const i=this.safeValue(t,"data",{}),n=this.safeString(i,"symbol"),r=this.safeMarket(n),a=this.parseWsTrade(i,r);if(this.myTrades===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new dO(c)}const o=this.myTrades;o.append(a);let d="trade";e.resolve(o,d),d+=":"+r.symbol,e.resolve(o,d)}parseWsTrade(e,t=void 0){const s=this.safeInteger2(e,"timestamp","t"),i=this.safeString(e,"symbol");t=this.safeMarket(i,t,"_");const n=t.symbol,r=this.safeString2(e,"price","p");let a=this.safeString2(e,"vol","q");a===void 0&&(a=this.safeString(e,"v"));let o=this.safeString(e,"T"),d;o===void 0?(o=this.safeString(e,"side"),d=this.parseSwapSide(o)):d=o==="1"?"buy":"sell";let c=this.safeString(e,"id");c===void 0&&(c=s.toString()+"-"+t.id+"-"+a);const u=this.safeString(e,"fee");let h;if(u!==void 0){const g=this.safeString(e,"feeCurrency"),y=this.safeCurrencyCode(g);h={cost:u,currency:y}}const l=this.safeString(e,"orderId"),m=this.safeValue(e,"taker",!0)?"taker":"maker";return this.safeTrade({info:e,id:c,order:l,timestamp:s,datetime:this.iso8601(s),symbol:n,type:void 0,side:d,takerOrMaker:m,price:r,amount:a,cost:void 0,fee:h},t)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n="order",r;e!==void 0&&(r=this.market(e),e=r.symbol,n+=":"+r.symbol);let a;[a,i]=this.handleMarketTypeAndParams("watchOrders",r,i);let o;return a==="spot"?o=await this.watchSpotPrivate(n,i):o=await this.watchSwapPrivate(n,i),this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleOrder(e,t,s=void 0){const i=this.safeValue(t,"data",{});let n=this.safeString(t,"symbol");n===void 0&&(n=this.safeString(i,"symbol"));const r=this.safeMarket(n),a=this.parseWSOrder(i,r);if(this.orders===void 0){const c=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new dO(c)}const o=this.orders;o.append(a);let d="order";e.resolve(o,d),d+=":"+r.symbol,e.resolve(o,d)}parseWSOrder(e,t=void 0){const s=this.safeString2(e,"orderId","id"),i=this.safeString2(e,"state","status"),n=this.safeInteger(e,"createTime"),r=this.safeString(e,"price"),a=this.safeString2(e,"quantity","vol"),o=this.safeString(e,"remainQuantity"),d=this.safeString(e,"dealVol"),c=this.safeString(e,"amount"),u=this.safeString(e,"dealAvgPrice"),h=this.safeString2(e,"symbol","symbolDisplay"),l=this.safeSymbol(h,t,"_"),p=this.safeString(e,"side");let m=this.parseSwapSide(p);if(m===void 0){const k=this.safeStringLower(e,"tradeType");k==="ask"||k==="2"?m="sell":k==="bid"||k==="1"?m="buy":m=k}const g=this.parseWsOrderStatus(i,t);let y=this.safeString2(e,"client_order_id","orderId");y===""&&(y=void 0);const b=this.safeString(e,"orderType"),S=b==="3"||b==="5"?"market":"limit";return this.safeOrder({id:s,clientOrderId:y,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:this.safeInteger(e,"updateTime"),status:g,symbol:l,type:S,timeInForce:void 0,side:m,price:r,stopPrice:void 0,average:u,amount:a,cost:c,filled:d,remaining:o,fee:void 0,trades:void 0,info:e},t)}parseSwapSide(e){const t={1:"open long",2:"close short",3:"open short",4:"close long"};return this.safeString(t,e)}parseWsOrderStatus(e,t=void 0){let s={};return t.type==="spot"?s={1:"open",2:"closed",3:"open",4:"canceled",5:"open",NEW:"open",FILLED:"closed",PARTIALLY_FILLED:"open",CANCELED:"canceled",PARTIALLY_CANCELED:"canceled"}:s={2:"open",3:"closed",4:"canceled"},this.safeString(s,e,e)}async watchBalance(e={}){await this.loadMarkets();const t="balance";let s;if([s,e]=this.handleMarketTypeAndParams("watchBalance",void 0,e),s==="spot")throw new Ng(this.id+" watchBalance does not support spot markets");return this.watchSwapPrivate(t,e)}handleBalance(e,t){const s=this.safeValue(t,"data"),i=this.safeString(s,"currency"),n=this.safeCurrencyCode(i),r=this.account();r.free=this.safeString(s,"availableBalance"),r.used=this.safeString(s,"frozenBalance"),this.balance[n]=r,this.balance=this.safeBalance(this.balance);const a="balance";e.resolve(this.balance,a)}async watchSwapPublic(e,t,s,i={}){const n=this.urls.api.ws.swap,r={method:t,param:s},a=this.extend(r,i);return await this.watch(n,e,a,e)}async watchSpotPublic(e,t,s,i={}){const n=this.urls.api.ws.spot,r={op:t},a=this.extend(r,s),o=this.extend(a,i);return await this.watch(n,e,o,e)}async watchSpotPrivate(e,t={}){this.checkRequiredCredentials();const s="sub.personal",i=this.urls.api.ws.spot,n=this.milliseconds().toString(),r={op:s,api_key:this.apiKey,req_time:n},a=this.keysort(r);a.api_secret=this.secret;const o=this.urlencode(a),d=this.hash(this.encode(o),"md5");r.sign=d;const c=this.extend(r,t);return await this.watch(i,e,c,s)}async watchSwapPrivate(e,t={}){this.checkRequiredCredentials();const s="login",i=this.urls.api.ws.swap,n=this.milliseconds().toString(),r=this.apiKey+n,a=this.hmac(this.encode(r),this.encode(this.secret),"sha256"),o={method:s,param:{apiKey:this.apiKey,signature:a,reqTime:n}},d=this.extend(o,t),c=this.extend(d,t);return await this.watch(i,e,c,s)}handleErrorMessage(e,t){const s=this.safeString(t,"channel");try{const i=this.id+" "+this.json(t);if(s.indexOf("error")>=0){const n=this.safeValue(t,"data");typeof n=="string"&&(this.throwExactlyMatchedException(this.exceptions.ws.exact,n,i),this.throwBroadlyMatchedException(this.exceptions.ws.broad,n,i))}if(s==="sub.personal"){const n=this.safeString(t,"msg");this.throwExactlyMatchedException(this.exceptions.ws.exact,n,i)}}catch(i){if(i instanceof oO)return!1}return t}handleAuthenticate(e,t){return t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;if(t==="pong"){this.handlePong(e,t);return}const s=this.safeString(t,"channel"),i={pong:this.handlePong,"rs.login":this.handleAuthenticate,"push.deal":this.handleTrades,orderbook:this.handleOrderBook,"push.kline":this.handleOHLCV,"push.ticker":this.handleTicker,"push.depth":this.handleOrderBook,"push.limit.depth":this.handleOrderBook,"push.personal.order":this.handleOrder,"push.personal.trigger.order":this.handleOrder,"push.personal.plan.order":this.handleOrder,"push.personal.order.deal":this.handleMyTrade,"push.personal.asset":this.handleBalance},n=this.safeValue(i,s);n!==void 0&&n.call(this,e,t)}ping(e){return this.safeString(this.options,"defaultType","spot")==="spot"?"ping":{method:"ping"}}handlePong(e,t){return e.lastPong=this.milliseconds(),t}};const EW=Hl,{ArrayCache:VW}=et;var iC=class extends EW{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTrades:!0,watchTicker:!0,watchOHLCV:!0},urls:{test:{ws:"wss://ndaxmarginstaging.cdnhop.net:10456/WSAdminGatewa/"},api:{ws:"wss://api.ndax.io/WSGateway"}}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}async watchTicker(e,t={}){const s=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const i=this.market(e),n="SubscribeLevel1",r=n+":"+i.id,a=this.urls.api.ws,o=this.requestId(),d={OMSId:s,InstrumentId:parseInt(i.id)},c={m:0,i:o,n,o:this.json(d)},u=this.extend(c,t);return await this.watch(a,r,u,r)}handleTicker(e,t){const s=this.safeValue(t,"o",{}),i=this.parseTicker(s),n=i.symbol,r=this.market(n);this.tickers[n]=i;const o="SubscribeLevel1"+":"+r.id;e.resolve(i,o)}async watchTrades(e,t=void 0,s=void 0,i={}){const n=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const r=this.market(e);e=r.symbol;const a="SubscribeTrades",o=a+":"+r.id,d=this.urls.api.ws,c=this.requestId(),u={OMSId:n,InstrumentId:parseInt(r.id),IncludeLastCount:100},h={m:0,i:c,n:a,o:this.json(u)},l=this.extend(h,i),p=await this.watch(d,o,l,o);return this.newUpdates&&(s=p.getLimit(e,s)),this.filterBySinceLimit(p,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"o",[]),i="SubscribeTrades",n={};for(let a=0;a<s.length;a++){const o=this.parseTrade(s[a]),d=o.symbol;let c=this.safeValue(this.trades,d);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new VW(u)}c.append(o),this.trades[d]=c,n[d]=!0}const r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=this.market(o),c=i+":"+d.id,u=this.safeValue(this.trades,o);e.resolve(u,c)}}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){const r=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const a=this.market(e);e=a.symbol;const o="SubscribeTicker",d=o+":"+t+":"+a.id,c=this.urls.api.ws,u=this.requestId(),h={OMSId:r,InstrumentId:parseInt(a.id),Interval:parseInt(this.timeframes[t]),IncludeLastCount:100},l={m:0,i:u,n:o,o:this.json(h)},p=this.extend(l,n),m=await this.watch(c,d,p,d);return this.newUpdates&&(i=m.getLimit(e,i)),this.filterBySinceLimit(m,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"o",[]),i={};for(let a=0;a<s.length;a++){const o=s[a],d=this.safeString(o,8),u=this.safeMarket(d).symbol;i[d]={},this.ohlcvs[u]=this.safeValue(this.ohlcvs,u,{});const h=Object.keys(this.timeframes);for(let l=0;l<h.length;l++){const p=h[l],m=this.timeframes[p],g=parseInt(m)*1e3,y=this.safeInteger(o,0),b=[parseInt(y/g)*g,this.safeFloat(o,3),this.safeFloat(o,1),this.safeFloat(o,2),this.safeFloat(o,4),this.safeFloat(o,5)],w=this.safeValue(this.ohlcvs[u],p,[]),S=w.length;if(S&&b[0]===w[S-1][0]){const k=w[S-1];w[S-1]=[b[0],k[1],Math.max(b[1],k[1]),Math.min(b[2],k[2]),b[4],this.sum(b[5],k[5])],i[d][p]=!0}else{if(S&&b[0]<w[S-1][0])continue;{w.push(b);const k=this.safeInteger(this.options,"OHLCVLimit",1e3);S>=k&&w.shift(),i[d][p]=!0}}this.ohlcvs[u][p]=w}}const n="SubscribeTicker",r=Object.keys(i);for(let a=0;a<r.length;a++){const o=r[a],d=Object.keys(i[o]);for(let c=0;c<d.length;c++){const u=d[c],h=n+":"+u+":"+o,p=this.safeMarket(o).symbol,m=this.safeValue(this.ohlcvs[p],u,[]);e.resolve(m,h)}}}async watchOrderBook(e,t=void 0,s={}){const i=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="SubscribeLevel2",a=r+":"+n.id,o=this.urls.api.ws,d=this.requestId();t=t===void 0?100:t;const c={OMSId:i,InstrumentId:parseInt(n.id),Depth:t},u={m:0,i:d,n:r,o:this.json(c)},h={id:d,messageHash:a,name:r,symbol:e,marketId:n.id,method:this.handleOrderBookSubscription,limit:t,params:s},l=this.extend(u,s);return(await this.watch(o,a,l,a,h)).limit()}handleOrderBook(e,t){const s=this.safeValue(t,"o",[]),i=this.safeValue(s,0,[]),n=this.safeString(i,7);if(n===void 0)return t;const a=this.safeMarket(n).symbol,o=this.safeValue(this.orderbooks,a);if(o===void 0)return t;let d,c;for(let l=0;l<s.length;l++){const p=s[l];if(d===void 0)d=this.safeInteger(p,2);else{const S=this.safeInteger(p,2);d=Math.max(d,S)}if(c===void 0)c=this.safeInteger(p,0);else{const S=this.safeInteger(p,0);c=Math.max(c,S)}const m=this.safeInteger(p,3),g=this.safeFloat(p,6),y=this.safeFloat(p,8),w=this.safeInteger(p,9)===0?o.bids:o.asks;m===0||m===1?w.store(g,y):m===2&&w.store(g,0)}o.nonce=c,o.timestamp=d,o.datetime=this.iso8601(d);const h="SubscribeLevel2"+":"+n;this.orderbooks[a]=o,e.resolve(o,h)}handleOrderBookSubscription(e,t,s){const i=this.safeValue(t,"o",[]),n=this.safeString(s,"symbol"),r=this.parseOrderBook(i,n),a=this.safeInteger(s,"limit"),o=this.orderBook(r,a);this.orderbooks[n]=o;const d=this.safeString(s,"messageHash");e.resolve(o,d)}handleSubscriptionStatus(e,t){const s=this.indexBy(e.subscriptions,"id"),i=this.safeInteger(t,"i"),n=this.safeValue(s,i);if(n!==void 0){const r=this.safeValue(n,"method");return r===void 0?t:r.call(this,e,t,n)}}handleMessage(e,t){const s=this.safeString(t,"o");if(s===void 0)return t;t.o=JSON.parse(s);const i={SubscribeLevel2:this.handleSubscriptionStatus,SubscribeLevel1:this.handleTicker,Level2UpdateEvent:this.handleOrderBook,Level1UpdateEvent:this.handleTicker,SubscribeTrades:this.handleTrades,TradeDataUpdateEvent:this.handleTrades,SubscribeTicker:this.handleOHLCV,TickerDataUpdateEvent:this.handleOHLCV},n=this.safeString(t,"n"),r=this.safeValue(i,n);return r===void 0?t:r.call(this,e,t)}};const qW=$_,{ArgumentsRequired:Kc,AuthenticationError:LW}=oe,{ArrayCache:RW,ArrayCacheByTimestamp:FW,ArrayCacheBySymbolById:DW}=et;var HW=class extends qW{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchTickers:!1,watchOrderBook:!0,watchOrders:!0,watchTrades:!0,watchBalance:!0,watchOHLCV:!0},urls:{api:{ws:"wss://real.okcoin.com:8443/ws/v3"},logo:"https://user-images.githubusercontent.com/1294454/27766791-89ffb502-5ee5-11e7-8a5b-c5950b68ac65.jpg",www:"https://www.okcoin.com",doc:"https://www.okcoin.com/docs/en/",fees:"https://www.okcoin.com/coin-fees",referral:"https://www.okcoin.com/account/register?flag=activity&channelId=600001513"},options:{fetchMarkets:["spot"],watchOrders:"order",watchOrderBook:{limit:400,type:"spot",depth:"depth_l2_tbt"},watchBalance:"spot",ws:{inflate:!0}},streaming:{ping:this.ping,keepAlive:2e4}})}async subscribe(e,t,s={}){await this.loadMarkets();const i=this.market(t),n=this.urls.api.ws,r=i.type+"/"+e+":"+i.id,a={op:"subscribe",args:[r]};return await this.watch(n,r,this.deepExtend(a,s),r)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.subscribe("trade",e,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate(),e!==void 0&&(e=this.symbol(e));const n=this.safeString(this.options,"watchOrders","order"),r=await this.subscribe(n,e,i);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySinceLimit(r,t,s,"timestamp",!0)}handleOrders(e,t,s=void 0){const i=this.safeString(t,"table"),n=this.safeValue(t,"data",[]);if(n.length>0){const a=this.safeInteger(this.options,"ordersLimit",1e3);this.orders===void 0&&(this.orders=new DW(a));const o=this.orders,d={},c=this.parseOrders(n);for(let h=0;h<c.length;h++){const l=c[h];o.append(l);const p=l.symbol,m=this.market(p);d[m.id]=!0}const u=Object.keys(d);for(let h=0;h<u.length;h++){const l=i+":"+u[h];e.resolve(this.orders,l)}}}async watchTicker(e,t={}){return await this.subscribe("ticker",e,t)}handleTrade(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]),n=this.safeInteger(this.options,"tradesLimit",1e3);for(let r=0;r<i.length;r++){const a=this.parseTrade(i[r]),o=a.symbol,d=this.safeString(a.info,"instrument_id"),c=s+":"+d;let u=this.safeValue(this.trades,o);u===void 0&&(u=new RW(n),this.trades[o]=u),u.append(a),e.resolve(u,c)}return t}handleTicker(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]);for(let n=0;n<i.length;n++){const r=this.parseTicker(i[n]),a=r.symbol,o=this.safeString(r.info,"instrument_id"),d=s+":"+o;this.tickers[a]=r,e.resolve(r,d)}return t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets(),e=this.symbol(e);const a="candle"+this.timeframes[t]+"s",o=await this.subscribe(a,e,n);return this.newUpdates&&(i=o.getLimit(e,i)),this.filterBySinceLimit(o,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]),n=s.split("/");let a=this.safeString(n,1).replace("candle","");a=a.replace("s","");const o=this.findTimeframe(a);for(let d=0;d<i.length;d++){const c=this.safeString(i[d],"instrument_id"),u=this.safeValue(i[d],"candle"),h=this.safeMarket(c),l=h.symbol,p=this.parseOHLCV(u,h);this.ohlcvs[l]=this.safeValue(this.ohlcvs,l,{});let m=this.safeValue(this.ohlcvs[l],o);if(m===void 0){const y=this.safeInteger(this.options,"OHLCVLimit",1e3);m=new FW(y),this.ohlcvs[l][o]=m}m.append(p);const g=s+":"+c;e.resolve(m,g)}}async watchOrderBook(e,t=void 0,s={}){const i=this.safeValue(this.options,"watchOrderBook",{}),n=this.safeString(i,"depth","depth_l2_tbt");return(await this.subscribe(n,e,s)).limit()}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s){const i=this.safeValue(t,"asks",[]),n=this.safeValue(t,"bids",[]);this.handleDeltas(s.asks,i),this.handleDeltas(s.bids,n);const r=this.parse8601(this.safeString(t,"timestamp"));return s.timestamp=r,s.datetime=this.iso8601(r),s}handleOrderBook(e,t){const s=this.safeString(t,"action"),i=this.safeValue(t,"data",[]),n=this.safeString(t,"table");if(s==="partial")for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"instrument_id"),c=this.safeMarket(o).symbol,u=this.safeValue(this.options,"watchOrderBook",{}),h=this.safeInteger(u,"limit",400),l=this.orderBook({},h);this.orderbooks[c]=l,this.handleOrderBookMessage(e,a,l);const p=n+":"+o;e.resolve(l,p)}else for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"instrument_id"),c=this.safeMarket(o).symbol;if(c in this.orderbooks){const u=this.orderbooks[c];this.handleOrderBookMessage(e,a,u);const h=n+":"+o;e.resolve(u,h)}}return t}async authenticate(e={}){this.checkRequiredCredentials();const t=this.urls.api.ws,s="login",i=this.client(t);let n=this.safeValue(i.subscriptions,s);if(n===void 0){n=i.future("authenticated");const r=this.seconds().toString(),a="GET",o="/users/self/verify",d=r+a+o,c=this.hmac(this.encode(d),this.encode(this.secret),"sha256","base64"),u={op:s,args:[this.apiKey,this.password,r,c]};this.spawn(this.watch,t,s,u,s,n)}return await n}async watchBalance(e={}){const t=this.safeString2(this.options,"watchBalance","defaultType");if(this.safeString(e,"type",t)===void 0)throw new Kc(this.id+" watchBalance requires a type parameter (one of 'spot', 'margin', 'futures', 'swap')");const i=await this.authenticate();return await this.subscribeToUserAccount(i,e)}async subscribeToUserAccount(e,t={}){const s=this.safeString2(this.options,"watchBalance","defaultType"),i=this.safeString(t,"type",s);if(i===void 0)throw new Kc(this.id+" watchBalance requires a type parameter (one of 'spot', 'margin', 'futures', 'swap')");await this.loadMarkets();const n=this.safeString(t,"currency"),r=this.safeString(t,"code",this.safeCurrencyCode(n));let a;r!==void 0&&(a=this.currency(r));const o=this.safeString(t,"instrument_id"),d=this.safeString(t,"symbol");let c;d!==void 0?c=this.market(d):o!==void 0&&o in this.markets_by_id&&(c=this.markets_by_id[o]);const u=c===void 0,h=a===void 0;if(i==="spot"){if(h)throw new Kc(this.id+" watchBalance requires a 'currency' (id) or a unified 'code' parameter for "+i+" accounts")}else if(i==="margin"||i==="swap"||i==="option"){if(u)throw new Kc(this.id+" watchBalance requires a 'instrument_id' (id) or a unified 'symbol' parameter for "+i+" accounts")}else if(i==="futures"&&h&&u)throw new Kc(this.id+" watchBalance requires a 'currency' (id), or unified 'code', or 'instrument_id' (id), or unified 'symbol' parameter for "+i+" accounts");let l;h?u||(l=c.id):l=a.id;const p=i==="margin"?"spot":i,m=i==="margin"?"margin_account":"account",g=p+"/"+m,y=g+":"+l,b=this.urls.api.ws,w={op:"subscribe",args:[y]},S=this.omit(t,["currency","code","instrument_id","symbol","type"]);return await this.watch(b,g,this.deepExtend(w,S),y)}handleBalance(e,t){const s=this.safeString(t,"table"),i=s.split("/");let n=this.safeString(i,0);n==="spot"&&this.safeString(i,1)==="margin_account"&&(n="margin");const r=this.safeValue(t,"data",[]);for(let a=0;a<r.length;a++){const o=this.parseBalanceByType(n,r),d=this.safeValue(this.balance,n,{}),c=this.deepExtend(d,o);this.balance[n]=this.safeBalance(c),e.resolve(this.balance[n],s)}}handleSubscriptionStatus(e,t){return t}handleAuthenticate(e,t){return e.resolve(t,"authenticated"),t}ping(e){return"ping"}handlePong(e,t){return e.lastPong=this.milliseconds(),t}handleErrorMessage(e,t){const s=this.safeString(t,"errorCode");try{if(s!==void 0){const i=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,i);const n=this.safeValue(t,"message");n!==void 0&&this.throwBroadlyMatchedException(this.exceptions.broad,n,i)}}catch(i){if(i instanceof LW){e.reject(i,"authenticated");const n="login";return n in e.subscriptions&&delete e.subscriptions[n],!1}}return t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;if(t==="pong")return this.handlePong(e,t);const s=this.safeString(t,"table");if(s===void 0){const i=this.safeString(t,"event");if(i!==void 0){const n={login:this.handleAuthenticate,subscribe:this.handleSubscriptionStatus},r=this.safeValue(n,i);return r===void 0?t:r.call(this,e,t)}}else{const i=s.split("/"),n=this.safeString(i,1),r={depth:this.handleOrderBook,depth5:this.handleOrderBook,depth_l2_tbt:this.handleOrderBook,ticker:this.handleTicker,trade:this.handleTrade,account:this.handleBalance,margin_account:this.handleBalance,order:this.handleOrders};let a=this.safeValue(r,n);return n.indexOf("candle")>=0&&(a=this.handleOHLCV),a===void 0?t:a.call(this,e,t)}}};const GW=xb,{AuthenticationError:UW,InvalidNonce:$W}=oe,{ArrayCache:jW,ArrayCacheByTimestamp:WW,ArrayCacheBySymbolById:zW}=et;var nC=class extends GW{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchOrderBook:!0,watchTrades:!0,watchBalance:!0,watchOHLCV:!0,watchOrders:!0},urls:{api:{ws:{public:"wss://ws.okx.com:8443/ws/v5/public",private:"wss://ws.okx.com:8443/ws/v5/private"}},test:{ws:{public:"wss://wspap.okx.com:8443/ws/v5/public?brokerId=9999",private:"wss://wspap.okx.com:8443/ws/v5/private?brokerId=9999"}}},options:{watchOrderBook:{depth:"books"},watchBalance:"spot",ws:{},checksum:!0},streaming:{ping:this.ping,keepAlive:2e4}})}async subscribe(e,t,s,i={}){await this.loadMarkets();const n=this.urls.api.ws[e];let r=t;const a={channel:t};if(s!==void 0){const d=this.market(s);r+=":"+d.id,a.instId=d.id}const o={op:"subscribe",args:[this.deepExtend(a,i)]};return await this.watch(n,r,o,r)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.subscribe("public","trades",e,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"arg",{}),i=this.safeString(s,"channel"),n=this.safeValue(t,"data",[]),r=this.safeInteger(this.options,"tradesLimit",1e3);for(let a=0;a<n.length;a++){const o=this.parseTrade(n[a]),d=o.symbol,c=this.safeString(o.info,"instId"),u=i+":"+c;let h=this.safeValue(this.trades,d);h===void 0&&(h=new jW(r),this.trades[d]=h),h.append(o),e.resolve(h,u)}return t}async watchTicker(e,t={}){return await this.subscribe("public","tickers",e,t)}handleTicker(e,t){const s=this.safeValue(t,"arg",{}),i=this.safeString(s,"channel"),n=this.safeValue(t,"data",[]);for(let r=0;r<n.length;r++){const a=this.parseTicker(n[r]),o=a.symbol,d=this.safeString(a.info,"instId"),c=i+":"+d;this.tickers[o]=a,e.resolve(a,c)}return t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets(),e=this.symbol(e);const a="candle"+this.timeframes[t],o=await this.subscribe("public",a,e,n);return this.newUpdates&&(i=o.getLimit(e,i)),this.filterBySinceLimit(o,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"arg",{}),i=this.safeString(s,"channel"),n=this.safeValue(t,"data",[]),r=this.safeString(s,"instId"),a=this.safeMarket(r),o=a.id,d=i.replace("candle",""),c=this.findTimeframe(d);for(let u=0;u<n.length;u++){const h=this.parseOHLCV(n[u],a);this.ohlcvs[o]=this.safeValue(this.ohlcvs,o,{});let l=this.safeValue(this.ohlcvs[o],c);if(l===void 0){const m=this.safeInteger(this.options,"OHLCVLimit",1e3);l=new WW(m),this.ohlcvs[o][c]=l}l.append(h);const p=i+":"+r;e.resolve(l,p)}}async watchOrderBook(e,t=void 0,s={}){const i=this.safeValue(this.options,"watchOrderBook",{}),n=this.safeString(i,"depth","books");return(await this.subscribe("public",n,e,s)).limit()}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s,i){const n=this.safeValue(t,"asks",[]),r=this.safeValue(t,"bids",[]),a=s.asks,o=s.bids;if(this.handleDeltas(a,n),this.handleDeltas(o,r),this.safeValue(this.options,"checksum",!0)){const u=a.length,h=o.length,l=[];for(let y=0;y<25;y++)y<h&&(l.push(this.numberToString(o[y][0])),l.push(this.numberToString(o[y][1]))),y<u&&(l.push(this.numberToString(a[y][0])),l.push(this.numberToString(a[y][1])));const p=l.join(":"),m=this.safeInteger(t,"checksum"),g=this.crc32(p,!0);if(m!==g){const y=new $W(this.id+" invalid checksum");e.reject(y,i)}}const c=this.safeInteger(t,"ts");return s.timestamp=c,s.datetime=this.iso8601(c),s}handleOrderBook(e,t){const s=this.safeValue(t,"arg",{}),i=this.safeString(s,"channel"),n=this.safeString(t,"action"),r=this.safeValue(t,"data",[]),a=this.safeString(s,"instId"),d=this.safeMarket(a).symbol,c={"bbo-tbt":1,books:400,books5:5,"books-l2-tbt":400,"books50-l2-tbt":50},u=this.safeInteger(c,i),h=i+":"+a;if(n==="snapshot")for(let l=0;l<r.length;l++){const p=r[l],m=this.orderBook({},u);this.orderbooks[d]=m,this.handleOrderBookMessage(e,p,m,h),e.resolve(m,h)}else if(n==="update"){if(d in this.orderbooks){const l=this.orderbooks[d];for(let p=0;p<r.length;p++){const m=r[p];this.handleOrderBookMessage(e,m,l,h),e.resolve(l,h)}}}else if(i==="books5"||i==="bbo-tbt"){let l=this.safeValue(this.orderbooks,d);l===void 0&&(l=this.orderBook({},u)),this.orderbooks[d]=l;for(let p=0;p<r.length;p++){const m=r[p],g=this.safeInteger(m,"ts"),y=this.parseOrderBook(m,d,g,"bids","asks",0,1);l.reset(y),e.resolve(l,h)}}return t}async authenticate(e={}){this.checkRequiredCredentials();const t=this.urls.api.ws.private,s="login",i=this.client(t);let n=this.safeValue(i.subscriptions,s);if(n===void 0){n=i.future("authenticated");const r=this.seconds().toString(),a="GET",o="/users/self/verify",d=r+a+o,c=this.hmac(this.encode(d),this.encode(this.secret),"sha256","base64"),u={op:s,args:[{apiKey:this.apiKey,passphrase:this.password,timestamp:r,sign:c}]};this.spawn(this.watch,t,s,u,s,n)}return await n}async watchBalance(e={}){return await this.loadMarkets(),await this.authenticate(),await this.subscribe("private","account",void 0,e)}handleBalance(e,t){const s=this.safeValue(t,"arg",{}),i=this.safeString(s,"channel"),n="spot",r=this.parseTradingBalance(t),a=this.safeValue(this.balance,n,{}),o=this.deepExtend(a,r);this.balance[n]=this.safeBalance(o),e.resolve(this.balance[n],i)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate();const n=this.safeValue(this.options,"watchOrders",{});let r=this.safeString(n,"type","ANY");r=this.safeString(i,"type",r);const a=this.safeValue(i,"stop",!1);i=this.omit(i,["type","stop"]);let o;e!==void 0&&(o=this.market(e),e=o.symbol,r=o.type),r==="future"&&(r="futures");const c={instType:r.toUpperCase()},u=a?"orders-algo":"orders",h=await this.subscribe("private",u,e,this.extend(c,i));return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySymbolSinceLimit(h,e,t,s,!0)}handleOrders(e,t,s=void 0){const i=this.safeValue(t,"arg",{}),n=this.safeString(i,"channel"),r=this.safeValue(t,"data",[]);if(r.length>0){const o=this.safeInteger(this.options,"ordersLimit",1e3);this.orders===void 0&&(this.orders=new zW(o));const d=this.orders,c=[],u=this.parseOrders(r);for(let h=0;h<u.length;h++){const l=u[h];d.append(l);const p=l.symbol,m=this.market(p);c.push(m.id)}e.resolve(this.orders,n);for(let h=0;h<c.length;h++){const l=n+":"+c[h];e.resolve(this.orders,l)}}}handleSubscriptionStatus(e,t){return t}handleAuthenticate(e,t){return e.resolve(t,"authenticated"),t}ping(e){return"ping"}handlePong(e,t){return e.lastPong=this.milliseconds(),t}handleErrorMessage(e,t){const s=this.safeString(t,"errorCode");try{if(s!==void 0){const i=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,i);const n=this.safeValue(t,"message");n!==void 0&&this.throwBroadlyMatchedException(this.exceptions.broad,n,i)}}catch(i){if(i instanceof UW){e.reject(i,"authenticated");const n="login";return n in e.subscriptions&&delete e.subscriptions[n],!1}}return t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;if(t==="pong")return this.handlePong(e,t);const s=this.safeString(t,"event");if(s!==void 0){const i={login:this.handleAuthenticate,subscribe:this.handleSubscriptionStatus},n=this.safeValue(i,s);return n===void 0?t:n.call(this,e,t)}else{const i=this.safeValue(t,"arg",{}),n=this.safeString(i,"channel"),r={"bbo-tbt":this.handleOrderBook,books:this.handleOrderBook,books5:this.handleOrderBook,"books50-l2-tbt":this.handleOrderBook,"books-l2-tbt":this.handleOrderBook,tickers:this.handleTicker,trades:this.handleTrades,account:this.handleBalance,orders:this.handleOrders,"orders-algo":this.handleOrders},a=this.safeValue(r,n);if(a===void 0)if(n.indexOf("candle")===0)this.handleOHLCV(e,t);else return t;else return a.call(this,e,t)}}};const KW=nC;var XW=class extends KW{describe(){return this.deepExtend(super.describe(),{alias:!0,id:"okex"})}};const YW=W_,ta=ke,{ArrayCache:QW,ArrayCacheByTimestamp:ZW,ArrayCacheBySymbolById:cO}=et;var JW=class extends YW{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchMyTrades:!0,watchOrders:!0,watchOrderBook:!0,watchOHLCV:!0},urls:{test:{ws:"wss://testnet.phemex.com/ws"},api:{ws:"wss://phemex.com/ws"}},options:{tradesLimit:1e3,OHLCVLimit:1e3},streaming:{keepAlive:2e4}})}fromEn(e,t){if(e===void 0)return;const s=new ta(e);return s.decimals=this.sum(s.decimals,t),s.reduce(),s.toString()}fromEp(e,t=void 0){return e===void 0||t===void 0?e:this.fromEn(e,this.safeInteger(t,"priceScale"))}fromEv(e,t=void 0){return e===void 0||t===void 0?e:this.fromEn(e,this.safeInteger(t,"valueScale"))}fromEr(e,t=void 0){return e===void 0||t===void 0?e:this.fromEn(e,this.safeInteger(t,"ratioScale"))}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}parseSwapTicker(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeIntegerProduct(e,"timestamp",1e-6),r=this.fromEp(this.safeString(e,"close"),t),a=this.parseNumber(r),o=this.parseNumber(this.fromEv(this.safeString(e,"turnover"),t)),d=this.parseNumber(this.fromEv(this.safeString(e,"volume"),t));let c,u,h;const l=this.omitZero(this.fromEp(this.safeString(e,"open"),t)),p=this.parseNumber(l);return l!==void 0&&r!==void 0&&(c=this.parseNumber(ta.stringSub(r,l)),h=this.parseNumber(ta.stringDiv(ta.stringAdd(r,l),"2")),u=this.parseNumber(ta.stringMul(ta.stringSub(ta.stringDiv(r,l),"1"),"100"))),{symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.parseNumber(this.fromEp(this.safeString(e,"high"),t)),low:this.parseNumber(this.fromEp(this.safeString(e,"low"),t)),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:p,close:a,last:a,previousClose:void 0,change:c,percentage:u,average:h,baseVolume:d,quoteVolume:o,info:e}}handleTicker(e,t){let s="market24h",i=this.safeValue(t,s),n;i===void 0?(s="spot_market24h",i=this.safeValue(t,s),n=this.parseTicker(i)):n=this.parseSwapTicker(i);const r=n.symbol,a=s+":"+r,o=this.safeIntegerProduct(t,"timestamp",1e-6);n.timestamp=o,n.datetime=this.iso8601(o),this.tickers[r]=n,e.resolve(n,a)}async watchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("watchBalance",void 0,e),i=t+":balance";return await this.subscribePrivate(t,i,s)}handleBalance(e,t,s){for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.safeValue(this.currencies,o,{}),c=this.safeInteger(d,"valueScale",8),u=this.account();let h=this.safeString(r,"totalUsedBalanceEv");if(h===void 0){const p=this.safeString(r,"lockedTradingBalanceEv"),m=this.safeString(r,"lockedWithdrawEv");h=ta.stringAdd(p,m)}const l=this.safeString2(r,"accountBalanceEv","balanceEv");u.used=this.fromEn(h,c),u.total=this.fromEn(l,c),this.balance[o]=u,this.balance=this.safeBalance(this.balance)}const i=e+":balance";t.resolve(this.balance,i)}handleTrades(e,t){const s="trade",i=this.safeString(t,"symbol"),n=this.safeMarket(i),r=n.symbol,a=s+":"+r;let o=this.safeValue(this.trades,r);if(o===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);o=new QW(u),this.trades[r]=o}const d=this.safeValue(t,"trades",[]),c=this.parseTrades(d,n);for(let u=0;u<c.length;u++)o.append(c[u]);e.resolve(o,a)}handleOHLCV(e,t){const s="kline",i=this.safeString(t,"symbol"),n=this.safeMarket(i),r=n.symbol,a=this.safeValue(t,s,[]),o=this.safeValue(a,0,[]),d=this.safeString(o,1),c=this.findTimeframe(d);if(c!==void 0){const u=s+":"+c+":"+r,h=this.parseOHLCVs(a,n);this.ohlcvs[r]=this.safeValue(this.ohlcvs,r,{});let l=this.safeValue(this.ohlcvs[r],c);if(l===void 0){const p=this.safeInteger(this.options,"OHLCVLimit",1e3);l=new ZW(p),this.ohlcvs[r][c]=l}for(let p=0;p<h.length;p++){const m=h[p];l.append(m)}e.resolve(l,u)}}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i=s.spot?"spot_market24h":"market24h",n=this.urls.api.ws,r=this.requestId(),a=i+".subscribe",o=i+":"+e,d={method:a,id:r,params:[]},c=this.deepExtend(d,t);return await this.watch(n,o,c,a)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r=this.urls.api.ws,a=this.requestId(),o="trade",d=o+":"+e,u={method:o+".subscribe",id:a,params:[n.id]},h=this.deepExtend(u,i),l=await this.watch(r,d,h,d);return this.newUpdates&&(s=l.getLimit(e,s)),this.filterBySinceLimit(l,t,s,"timestamp",!0)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n=this.urls.api.ws,r=this.requestId(),a="orderbook",o=a+":"+e,c={method:a+".subscribe",id:r,params:[i.id]},u=this.deepExtend(c,s);return(await this.watch(n,o,u,o)).limit()}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=this.urls.api.ws,o=this.requestId(),d="kline",c=d+":"+t+":"+e,h={method:d+".subscribe",id:o,params:[r.id,this.safeInteger(this.timeframes,t)]},l=this.deepExtend(h,n),p=await this.watch(a,c,l,c);return this.newUpdates&&(i=p.getLimit(e,i)),this.filterBySinceLimit(p,s,i,0,!0)}handleDelta(e,t,s=void 0){const i=this.parseBidAsk(t,0,1,s);e.storeArray(i)}handleDeltas(e,t,s=void 0){for(let i=0;i<t.length;i++)this.handleDelta(e,t[i],s)}handleOrderBook(e,t){const s=this.safeString(t,"symbol"),i=this.safeMarket(s),n=i.symbol,r=this.safeString(t,"type"),a=this.safeInteger(t,"depth"),d="orderbook"+":"+n,c=this.safeInteger(t,"sequence"),u=this.safeIntegerProduct(t,"timestamp",1e-6);if(r==="snapshot"){const h=this.safeValue(t,"book",{}),l=this.parseOrderBook(h,n,u,"bids","asks",0,1,i);l.nonce=c;const p=this.orderBook(l,a);this.orderbooks[n]=p,e.resolve(p,d)}else{const h=this.safeValue(this.orderbooks,n);if(h!==void 0){const l=this.safeValue(t,"book",{}),p=this.safeValue(l,"asks",[]),m=this.safeValue(l,"bids",[]);this.handleDeltas(h.asks,p,i),this.handleDeltas(h.bids,m,i),h.nonce=c,h.timestamp=u,h.datetime=this.iso8601(u),this.orderbooks[n]=h,e.resolve(h,d)}}}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n="trades",r,a;e!==void 0&&(r=this.market(e),e=r.symbol,n=n+":"+r.symbol),[a,i]=this.handleMarketTypeAndParams("watchMyTrades",r,i),e===void 0&&(n=n+":"+a);const o=await this.subscribePrivate(a,n,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleMyTrades(e,t){const s="trades";if(t.length===0)return;let n=this.myTrades;if(n===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);n=new cO(c)}const r={};let a;for(let c=0;c<t.length;c++){const u=t[c];if(this.safeString(u,"symbol")in this.markets_by_id){const l=this.parseTrade(u);n.append(l);const p=l.symbol,m=this.market(p);a===void 0&&(a=m.type),r[p]=!0}}const o=Object.keys(r);for(let c=0;c<o.length;c++){const u=o[c],h=s+":"+u;e.resolve(n,h)}const d=s+":"+a;e.resolve(n,d)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n="orders",r,a;e!==void 0&&(r=this.market(e),e=r.symbol,n=n+":"+r.symbol),[a,i]=this.handleMarketTypeAndParams("watchOrders",r,i),e===void 0&&(n=n+":"+a);const o=await this.subscribePrivate(a,n,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleOrders(e,t){let s=[];const i=[];if("closed"in t||"fills"in t||"open"in t){const u=this.safeValue(t,"closed",[]),h=this.safeValue(t,"open",[]),l=this.arrayConcat(h,u);if(l.length===0)return;s=this.safeValue(t,"fills",[]);for(let g=0;g<l.length;g++){const y=l[g];if(this.safeString(y,"symbol")in this.markets_by_id){const w=this.parseOrder(y);i.push(w)}}}else for(let u=0;u<t.length;u++){const h=t[u];if(this.safeString(h,"symbol")in this.markets_by_id){const p=this.safeString(h,"action");p!==void 0&&p!=="Cancel"&&s.push(h);const m=this.parseWSSwapOrder(h);i.push(m)}}this.handleMyTrades(e,s);const n=this.safeInteger(this.options,"ordersLimit",1e3),r={};this.orders===void 0&&(this.orders=new cO(n));let a;const o=this.orders;for(let u=0;u<i.length;u++){const h=i[u];o.append(h);const l=h.symbol,p=this.market(l);a===void 0&&(a=p.type),r[l]=!0}const d=Object.keys(r);for(let u=0;u<d.length;u++){const h="orders:"+d[u];e.resolve(this.orders,h)}const c="orders:"+a;e.resolve(this.orders,c)}parseWSSwapOrder(e,t=void 0){const s=this.safeString(e,"orderID");let i=this.safeString(e,"clOrdID");i!==void 0&&i.length<1&&(i=void 0);const n=this.safeString(e,"symbol");t=this.safeMarket(n,t);const r=t.symbol,a=this.parseOrderStatus(this.safeString(e,"ordStatus")),o=this.safeStringLower(e,"side"),d=this.parseOrderType(this.safeString(e,"ordType")),c=this.parseNumber(this.fromEp(this.safeString(e,"priceEp"),t)),u=this.safeString(e,"orderQty"),h=this.safeString(e,"cumQty"),l=this.safeString(e,"leavesQty"),p=this.safeIntegerProduct(e,"actionTimeNs",1e-6),m=this.safeString(e,"cumValueEv"),g=this.fromEv(m,t);let y=this.safeIntegerProduct(e,"transactTimeNs",1e-6);y===0&&(y=void 0);const b=this.parseTimeInForce(this.safeString(e,"timeInForce")),w=this.safeString(e,"stopPx"),S=b==="PO";return this.safeOrder({info:e,id:s,clientOrderId:i,datetime:this.iso8601(p),timestamp:p,lastTradeTimestamp:y,symbol:r,type:d,timeInForce:b,postOnly:S,side:o,price:c,stopPrice:w,amount:u,filled:h,remaining:l,cost:g,average:void 0,status:a,fee:void 0,trades:void 0},t)}handleMessage(e,t){const s=this.safeInteger(t,"id");if(s!==void 0){const i=e.subscriptions,n=Object.values(i);for(let r=0;r<n.length;r++){const a=n[r];if(a!==!0){const o=this.safeInteger(a,"id");if(o!==void 0&&o===s){const d=this.safeValue(a,"method");if(d!==void 0){d.call(this,e,t);return}}}}}if("market24h"in t||"spot_market24h"in t)return this.handleTicker(e,t);if("trades"in t)return this.handleTrades(e,t);if("kline"in t)return this.handleOHLCV(e,t);if("book"in t)return this.handleOrderBook(e,t);if("orders"in t){const i=this.safeValue(t,"orders",{});this.handleOrders(e,i)}if("accounts"in t||"wallets"in t){const i="accounts"in t?"swap":"spot",n=this.safeValue2(t,"accounts","wallets",[]);this.handleBalance(i,e,n)}}handleAuthenticate(e,t){return e.futures.authenticated.resolve(1),t}async subscribePrivate(e,t,s={}){await this.loadMarkets(),await this.authenticate();const i=this.urls.api.ws,n=this.seconds(),r=e==="spot"?"wo.subscribe":"aop.subscribe";let a={id:n,method:r,params:[]};a=this.extend(a,s);const o={id:n,messageHash:t};return await this.watch(i,t,a,r,o)}async authenticate(e={}){this.checkRequiredCredentials();const t=this.urls.api.ws,s=this.client(t),i=this.seconds(),n="authenticated",r=s.future(n);if(this.safeValue(s.subscriptions,n)===void 0){const o=this.safeInteger(this.options,"expires",120),d=this.seconds()+o,c=this.apiKey+d.toString(),u=this.hmac(this.encode(c),this.encode(this.secret),"sha256"),h={method:"user.auth",params:["API",this.apiKey,u,d],id:i},l={id:i,method:this.handleAuthenticate};this.spawn(this.watch,t,n,h,n,l)}return await r}};const ez=z_,{ArrayCache:tz}=et;var sz=class extends ez{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTrades:!0,watchTicker:!0},urls:{api:{ws:"wss://api.exchange.ripio.com/ws/v2/consumer/non-persistent/public/default/"}},options:{tradesLimit:1e3,uuid:this.uuid()}})}async watchTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="trades",a=r+"_"+n.id.toLowerCase(),o=this.urls.api.ws+a+"/"+this.options.uuid,d={name:r,symbol:e,messageHash:a,method:this.handleTrade},c=await this.watch(o,a,void 0,a,d);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySinceLimit(c,t,s,"timestamp",!0)}handleTrade(e,t,s){const i=this.safeString(t,"payload");if(i===void 0)return t;const n=JSON.parse(this.base64ToString(i)),r=this.safeString(s,"symbol"),a=this.safeString(s,"messageHash"),o=this.market(r),d=this.parseTrade(n,o);let c=this.safeValue(this.trades,r);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new tz(u),this.trades[r]=c}c.append(d),e.resolve(c,a)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i="rate",n=i+"_"+s.id.toLowerCase(),r=this.urls.api.ws+n+"/"+this.options.uuid,a={name:i,symbol:e,messageHash:n,method:this.handleTicker};return await this.watch(r,n,void 0,n,a)}handleTicker(e,t,s){const i=this.safeString(t,"payload");if(i===void 0)return t;const n=JSON.parse(this.base64ToString(i)),r=this.parseTicker(n),a=this.parse8601(this.safeString(t,"publishTime"));r.timestamp=a,r.datetime=this.iso8601(a);const o=r.symbol;this.tickers[o]=r;const d=this.safeString(s,"messageHash");return d!==void 0&&e.resolve(r,d),t}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n="orderbook",r=n+"_"+i.id.toLowerCase(),a=this.urls.api.ws+r+"/"+this.options.uuid,o=this.client(a),d={name:n,symbol:e,messageHash:r,method:this.handleOrderBook};if(!(r in o.subscriptions)){this.orderbooks[e]=this.orderBook({}),o.subscriptions[r]=d;const u=this.safeValue(this.options,"fetchOrderBookSnapshot",{}),h=this.safeInteger(u,"delay",this.rateLimit);this.delay(h,this.fetchOrderBookSnapshot,o,d)}return(await this.watch(a,r,void 0,r,d)).limit()}async fetchOrderBookSnapshot(e,t){const s=this.safeString(t,"symbol"),i=this.safeString(t,"messageHash");try{const n=await this.fetchOrderBook(s),r=this.orderbooks[s],a=r.cache;r.reset(n);for(let o=0;o<a.length;o++){const d=a[o];this.handleOrderBookMessage(e,d,r)}this.orderbooks[s]=r,e.resolve(r,i)}catch(n){e.reject(n,i)}}handleOrderBook(e,t,s){const i=this.safeString(s,"messageHash"),n=this.safeString(s,"symbol"),r=this.safeValue(this.orderbooks,n);return r===void 0||(r.nonce===void 0?r.cache.push(t):(this.handleOrderBookMessage(e,t,r),e.resolve(r,i))),t}handleOrderBookMessage(e,t,s){const i=this.safeString(t,"payload");if(i===void 0)return t;const n=JSON.parse(this.base64ToString(i)),r=this.safeInteger(n,"updated_id");if(r>s.nonce){const a=this.safeValue(n,"sell",[]),o=this.safeValue(n,"buy",[]);this.handleDeltas(s.asks,a,s.nonce),this.handleDeltas(s.bids,o,s.nonce),s.nonce=r;const d=this.parse8601(this.safeString(t,"publishTime"));s.timestamp=d,s.datetime=this.iso8601(d)}return s}handleDelta(e,t){const s=this.safeFloat(t,"price"),i=this.safeFloat(t,"amount");e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async ack(e,t){await e.send({messageId:t})}handleMessage(e,t){const s=this.safeString(t,"messageId");s!==void 0&&this.spawn(this.ack,e,s);const i=Object.keys(e.subscriptions),n=this.safeString(i,0),r=this.safeValue(e.subscriptions,n,{}),a=this.safeValue(r,"method");return a!==void 0?a.call(this,e,t,r):t}};const iz=K_,{ArrayCache:nz}=et;var rz=class extends iz{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTicker:!0,watchTrades:!0},urls:{api:{ws:"wss://api.upbit.com/websocket/v1"}},options:{tradesLimit:1e3}})}async watchPublic(e,t,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n=i.id,r=this.urls.api.ws;this.options[t]=this.safeValue(this.options,t,{}),this.options[t][e]=!0;const a=Object.keys(this.options[t]),o=this.marketIds(a),d=[{ticket:this.uuid()},{type:t,codes:o}],c=t+":"+n;return await this.watch(r,c,d,c)}async watchTicker(e,t={}){return await this.watchPublic(e,"ticker")}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.watchPublic(e,"trade");return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}async watchOrderBook(e,t=void 0,s={}){return(await this.watchPublic(e,"orderbook")).limit()}handleTicker(e,t){const i="ticker:"+this.safeString(t,"code"),n=this.parseTicker(t),r=n.symbol;this.tickers[r]=n,e.resolve(n,i)}handleOrderBook(e,t){const s=this.safeString(t,"code"),i=this.safeSymbol(s,void 0,"-"),n=this.safeString(t,"stream_type"),r=this.safeValue(this.options,"watchOrderBook",{}),a=this.safeInteger(r,"limit",15);n==="SNAPSHOT"&&(this.orderbooks[i]=this.orderBook({},a));const o=this.orderbooks[i];o.reset({}),o.symbol=i;const d=o.bids,c=o.asks,u=this.safeValue(t,"orderbook_units",[]);for(let m=0;m<u.length;m++){const g=u[m],y=this.safeFloat(g,"ask_price"),b=this.safeFloat(g,"ask_size"),w=this.safeFloat(g,"bid_price"),S=this.safeFloat(g,"bid_size");c.store(y,b),d.store(w,S)}const h=this.safeInteger(t,"timestamp"),l=this.iso8601(h);o.timestamp=h,o.datetime=l;const p="orderbook:"+s;e.resolve(o,p)}handleTrades(e,t){const s=this.parseTrade(t),i=s.symbol;let n=this.safeValue(this.trades,i);if(n===void 0){const o=this.safeInteger(this.options,"tradesLimit",1e3);n=new nz(o),this.trades[i]=n}n.append(s);const a="trade:"+this.safeString(t,"code");e.resolve(n,a)}handleMessage(e,t){const s={ticker:this.handleTicker,orderbook:this.handleOrderBook,trade:this.handleTrades},i=this.safeString(t,"type"),n=this.safeValue(s,i);n&&n.call(this,e,t)}};const az=X_,{NotSupported:oz,ExchangeError:dz}=oe,{ArrayCacheBySymbolById:uO,ArrayCacheByTimestamp:cz}=et;var uz=class extends az{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!0,watchTrades:!1,watchMyTrades:!0,watchOrders:!0,watchOrderBook:!0,watchOHLCV:!0},urls:{api:{ws:"wss://stream.wazirx.com/stream"}},options:{},streaming:{},exceptions:{},api:{private:{post:{create_auth_token:1}}}})}async watchBalance(e={}){await this.loadMarkets();const t=await this.authenticate(e),s="balance",i=this.urls.api.ws,n={event:"subscribe",streams:["outboundAccountPosition"],auth_key:t},r=this.deepExtend(n,e);return await this.watch(i,s,r,s)}handleBalance(e,t){const s=this.safeValue(t,"data",{}),i=this.safeValue(s,"B",[]);for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"a"),d=this.safeCurrencyCode(o),c=this.safeNumber(a,"b"),u=this.safeNumber(a,"l"),h=this.account();h.free=c,h.used=u,this.balance[d]=h}this.balance=this.safeBalance(this.balance);const n="balance";e.resolve(this.balance,n)}parseWSTrade(e,t=void 0){const s=this.safeInteger(e,"E"),i=this.safeString(e,"s");t=this.safeMarket(i,t);const n=this.safeString(e,"U");return this.safeTrade({id:this.safeString(e,"t"),info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:this.safeString(e,"o"),type:void 0,side:void 0,takerOrMaker:this.safeValue(e,"m"),price:this.safeString(e,"p"),amount:this.safeString(e,"q"),cost:void 0,fee:{cost:this.safeString(e,"f"),currency:this.safeCurrencyCode(n),rate:void 0}},t)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=this.urls.api.ws,n="ticker:"+s.symbol,r="tickers",o={event:"subscribe",streams:["!ticker@arr"]},d=this.deepExtend(o,t);return await this.watch(i,n,d,r)}async watchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.urls.api.ws,i="tickers",r={event:"subscribe",streams:["!ticker@arr"]},a=this.deepExtend(r,t),o=await this.watch(s,i,a,i);return this.filterByArray(o,"symbol",e,!1)}handleTicker(e,t){const s=this.safeValue(t,"data",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.parseWSTicker(n),a=r.symbol;this.tickers[a]=r;const o="ticker:"+a;e.resolve(r,o)}e.resolve(this.tickers,"tickers")}parseWSTicker(e,t=void 0){const s=this.safeString(e,"s"),i=this.safeInteger(e,"E");return this.safeTicker({symbol:this.safeSymbol(s,t),timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"h"),low:this.safeString(e,"l"),bid:this.safeNumber(e,"b"),bidVolume:void 0,ask:this.safeNumber(e,"a"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"o"),close:void 0,last:this.safeString(e,"l"),previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:this.safeString(e,"q"),info:e},t)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=await this.authenticate(i);e!==void 0&&(e=this.market(e).symbol);const r=this.urls.api.ws,a="myTrades",o={event:"subscribe",streams:["ownTrade"],auth_key:n},d=this.deepExtend(o,i),c=await this.watch(r,a,d,a);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=this.urls.api.ws,o="ohlcv:"+e+":"+t,c={event:"subscribe",streams:[r.id+"@kline_"+t]},u=this.deepExtend(c,n),h=await this.watch(a,o,u,o);return this.newUpdates&&(i=h.getLimit(e,i)),this.filterBySinceLimit(h,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(s,"s"),n=this.safeMarket(i),r=this.safeSymbol(i,n),a=this.safeString(s,"i");this.ohlcvs[r]=this.safeValue(this.ohlcvs,r,{});let o=this.safeValue(this.ohlcvs[r],a);if(o===void 0){const u=this.safeInteger(this.options,"OHLCVLimit",1e3);o=new cz(u),this.ohlcvs[r][a]=o}const d=this.parseWsOHLCV(s,n);o.append(d);const c="ohlcv:"+r+":"+a;e.resolve(o,c)}parseWsOHLCV(e,t=void 0){return[this.safeInteger(e,"t"),this.safeNumber(e,"o"),this.safeNumber(e,"c"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"v")]}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n=this.urls.api.ws,r="orderbook:"+e,o={event:"subscribe",streams:[i.id+"@depth"]},d=this.deepExtend(o,s);return(await this.watch(n,r,d,r)).limit()}handleDelta(e,t){const s=this.parseBidAsk(t,0,1);e.storeArray(s)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBook(e,t){const s=this.safeValue(t,"data",{}),i=this.safeInteger(s,"E"),n=this.safeString(s,"s"),a=this.safeMarket(n).symbol,o="orderbook:"+a,d=this.safeValue(this.orderbooks,a);if(d===void 0){const c=this.parseOrderBook(s,a,i,"b","a"),u=this.orderBook(c);this.orderbooks[a]=u}else{const c=this.safeValue(s,"a",[]),u=this.safeValue(s,"b",[]);this.handleDeltas(d.asks,c),this.handleDeltas(d.bids,u),d.nonce=i,d.timestamp=i,d.datetime=this.iso8601(i),this.orderbooks[a]=d}e.resolve(this.orderbooks[a],o)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),e!==void 0&&(e=this.market(e).symbol);const n=await this.authenticate(i),r="orders",a={event:"subscribe",streams:["orderUpdate"],auth_key:n},o=this.urls.api.ws,d=this.deepExtend(a,i),c=await this.watch(o,r,d,r,d);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}handleOrder(e,t){const s=this.safeValue(t,"data",{}),i=this.parseWSOrder(s);if(this.orders===void 0){const r=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new uO(r)}this.orders.append(i);let n="orders";e.resolve(this.orders,n),n+=":"+i.symbol,e.resolve(this.orders,n)}parseWSOrder(e){const t=this.safeInteger(e,"O"),s=this.safeString(e,"s"),i=this.safeString(e,"X"),n=this.safeMarket(s);return this.safeOrder({info:e,id:this.safeString(e,"i"),clientOrderId:this.safeString(e,"c"),datetime:this.iso8601(t),timestamp:t,lastTradeTimestamp:void 0,symbol:n.symbol,type:this.safeValue(e,"m")?"limit":"market",timeInForce:void 0,postOnly:void 0,side:this.safeString(e,"o"),price:this.safeString(e,"p"),stopPrice:void 0,amount:this.safeString(e,"V"),filled:void 0,remaining:this.safeString(e,"q"),cost:void 0,average:this.safeString(e,"v"),status:this.parseOrderStatus(i),fee:void 0,trades:void 0},n)}handleMyTrades(e,t){const s=this.safeValue(t,"data",{}),i="myTrades";let n;if(this.myTrades===void 0){const a=this.safeInteger(this.options,"tradesLimit",1e3);n=new uO(a),this.myTrades=n}else n=this.myTrades;const r=this.parseWSTrade(s);n.append(r),e.resolve(n,i)}handleConnected(e,t){return t}handleSubscribed(e,t){return t}handleError(e,t){throw new dz(this.id+" "+this.json(t))}handleMessage(e,t){const s=this.safeString(t,"event"),i={error:this.handleError,connected:this.handleConnected,subscribed:this.handleSubscribed},n=this.safeValue(i,s);if(n!==void 0)return n.call(this,e,t);const r=this.safeString(t,"stream",""),a={"ticker@arr":this.handleTicker,"@depth":this.handleOrderBook,"@kline":this.handleOHLCV,outboundAccountPosition:this.handleBalance,orderUpdate:this.handleOrder,ownTrade:this.handleMyTrades},o=Object.keys(a);for(let d=0;d<o.length;d++)if(this.inArray(o[d],r))return a[o[d]].call(this,e,t);throw new oz(this.id+" this message type is not supported yet. Message: "+this.json(t))}async authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i="authenticated",n=this.milliseconds();let r=this.safeValue(s.subscriptions,i);const a=this.safeNumber(r,"expires");return(r===void 0||n>a)&&(r=await this.privatePostCreateAuthToken(),r.expires=n+this.safeNumber(r,"timeout_duration")*1e3,s.subscriptions[i]=r),this.safeString(r,"auth_key")}};const fz=Y_,hz=ke,{AuthenticationError:fO,BadRequest:Eg,ArgumentsRequired:hO}=oe,{ArrayCache:lO,ArrayCacheBySymbolById:lz,ArrayCacheByTimestamp:pz}=et;var mz=class extends fz{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTrades:!0},urls:{api:{ws:"wss://api.whitebit.com/ws"}},options:{timeframes:{"1m":"60","5m":"300","15m":"900","30m":"1800","1h":"3600","4h":"14400","8h":"28800","1d":"86400","1w":"604800"},watchOrderBook:{priceInterval:0}},streaming:{ping:this.ping},exceptions:{ws:{exact:{1:Eg,2:Eg,4:Eg,6:fO}}}})}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=this.safeValue(this.options,"timeframes",{}),o=this.safeInteger(a,t),d=r.id,c="candles:"+e,u=[d,o],h="candles_subscribe",l=await this.watchPublic(c,h,u,n);return this.newUpdates&&(i=l.getLimit(e,i)),this.filterBySinceLimit(l,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"params",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeString(n,7),a=this.safeMarket(r),o=a.symbol,d="candles:"+o,c=this.parseOHLCV(n,a);this.ohlcvs[o]=this.safeValue(this.ohlcvs,o);let u=this.ohlcvs[o];if(u===void 0){const h=this.safeInteger(this.options,"OHLCVLimit",1e3);u=new pz(h),this.ohlcvs[o]=u}u.append(c),e.resolve(u,d)}return t}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);t===void 0&&(t=10);const n="orderbook:"+i.symbol,r="depth_subscribe",a=this.safeValue(this.options,"watchOrderBook",{}),o=this.safeString(a,"priceInterval","0"),d=this.safeString(s,"priceInterval",o);s=this.omit(s,"priceInterval");const c=[i.id,t,d,!0];return(await this.watchPublic(n,r,c,s)).limit()}handleOrderBook(e,t){const s=this.safeValue(t,"params",[]),i=this.safeValue(s,0),n=this.safeString(s,2),a=this.safeMarket(n).symbol,o=this.safeValue(s,1);let d;if(a in this.orderbooks?d=this.orderbooks[a]:(d=this.orderBook(),this.orderbooks[a]=d),i){const u=this.parseOrderBook(o,a);d.reset(u)}else{const u=this.safeValue(o,"asks",[]),h=this.safeValue(o,"bids",[]);this.handleDeltas(d.asks,u),this.handleDeltas(d.bids,h)}const c="orderbook:"+a;e.resolve(d,c)}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchTicker(e,t={}){await this.loadMarkets(),e=this.market(e).symbol;const i="market_subscribe",n="ticker:"+e;return await this.watchMultipleSubscription(n,i,e,!1,t)}handleTicker(e,t){const s=this.safeValue(t,"params",[]),i=this.safeString(s,0),n=this.safeMarket(i,void 0),r=n.symbol,a=this.safeValue(s,1,{}),o="ticker:"+r,d=this.parseTicker(a,n);this.tickers[r]=d,e.resolve(d,o);const c=Object.keys(e.futures);for(let u=0;u<c.length;u++){const h=c[u];h.indexOf("tickers")>=0&&h.indexOf(r)>=0&&e.resolve(d,h)}return t}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.market(e).symbol;const r="trades:"+e,a="trades_subscribe",o=await this.watchMultipleSubscription(r,a,e,!1,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"params",[]),i=this.safeString(s,0),n=this.safeMarket(i),r=n.symbol;let a=this.safeValue(this.trades,r);if(a===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);a=new lO(u),this.trades[r]=a}const o=this.safeValue(s,1,[]),d=this.parseTrades(o,n);for(let u=0;u<d.length;u++)a.append(d[u]);const c="trades:"+n.symbol;e.resolve(a,c)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new hO(this.id+" watchMyTrades requires a symbol argument");await this.loadMarkets(),await this.authenticate(),e=this.market(e).symbol;const r="myTrades:"+e,a="deals_subscribe",o=await this.watchMultipleSubscription(r,a,e,!0,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleMyTrades(e,t,s=void 0){const i=this.safeValue(t,"params");if(this.myTrades===void 0){const d=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new lO(d)}const n=this.myTrades,r=this.parseWsTrade(i);n.append(r);const o="myTrades:"+r.symbol;e.resolve(n,o)}parseWsTrade(e,t=void 0){const s=this.safeString(e,3),i=this.safeTimestamp(e,1),n=this.safeString(e,0),r=this.safeString(e,4),a=this.safeString(e,5),o=this.safeString(e,2);t=this.safeMarket(o,t);let d;const c=this.safeString(e,6);return c!==void 0&&(d={cost:c,currency:t.quote}),this.safeTrade({id:n,info:e,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,order:s,type:void 0,side:void 0,takerOrMaker:void 0,price:r,amount:a,cost:void 0,fee:d},t)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new hO(this.id+" watchOrders requires a symbol argument");await this.loadMarkets(),await this.authenticate(),e=this.market(e).symbol;const r="orders:"+e,a="ordersPending_subscribe",o=await this.watchMultipleSubscription(r,a,e,!1,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleOrder(e,t,s=void 0){const i=this.safeValue(t,"params",[]),n=this.safeValue(i,1);if(this.orders===void 0){const u=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new lz(u)}const r=this.orders,a=this.safeInteger(i,0),o=this.parseWsOrder(n,a);r.append(o);const c="orders:"+o.symbol;e.resolve(this.orders,c)}parseWsOrder(e,t,s=void 0){const i=this.safeString(e,"market");s=this.safeMarket(i,s);const n=this.safeString(e,"id"),r=this.omitZero(this.safeString(e,"client_order_id")),a=this.safeString(e,"price"),o=this.safeString(e,"deal_stock"),d=this.safeString(e,"deal_money"),c=this.safeString(e,"activation_price"),u=this.safeString(e,"type"),h=this.parseWsOrderType(u);let l,p;h==="market"?(l=this.safeString(e,"deal_stock"),p="0"):(p=this.safeString(e,"left"),l=this.safeString(e,"amount"));const m=this.safeTimestamp(e,"ctime"),g=this.safeTimestamp(e,"mtime"),y=s.symbol,w=this.safeInteger(e,"side")===1?"sell":"buy",S=this.safeString(e,"deal_fee");let k;return S!==void 0&&(k={cost:this.parseNumber(S),currency:s.quote}),t===1||t===2?t="open":hz.stringEquals(p,"0")?t="closed":t="canceled",this.safeOrder({info:e,symbol:y,id:n,clientOrderId:r,timestamp:m,datetime:this.iso8601(m),lastTradeTimestamp:g,type:h,timeInForce:void 0,postOnly:void 0,side:w,price:a,stopPrice:c,amount:l,cost:d,average:void 0,filled:o,remaining:p,status:t,fee:k,trades:void 0},s)}parseWsOrderType(e){const t={1:"limit",2:"market",202:"market",3:"limit",4:"market",5:"limit",6:"market",8:"limit",10:"market"};return this.safeString(t,e,e)}async watchBalance(e={}){await this.loadMarkets();let t;[t,e]=this.handleMarketTypeAndParams("watchBalance",void 0,e);let s="wallet:",i;t==="spot"?(i="balanceSpot_subscribe",s+="spot"):(i="balanceMargin_subscribe",s+="margin");const n=Object.keys(this.currencies);return await this.watchPrivate(s,i,n,e)}handleBalance(e,t){const s=this.safeString(t,"method"),i=this.safeValue(t,"params"),n=this.safeValue(i,0),r=Object.keys(n),a=this.safeValue(r,0),o=this.safeValue(n,a),d=this.safeCurrencyCode(a),c=this.account();c.free=this.safeString(o,"available"),c.used=this.safeString(o,"freeze"),this.balance[d]=c,this.balance=this.safeBalance(this.balance);let u="wallet:";s.indexOf("Spot")>=0?u+="spot":u+="margin",e.resolve(this.balance,u)}async watchPublic(e,t,s=[],i={}){const n=this.urls.api.ws,a={id:this.nonce(),method:t,params:s},o=this.extend(a,i);return await this.watch(n,e,o,e)}async watchMultipleSubscription(e,t,s,i=!1,n={}){await this.loadMarkets();const r=this.urls.api.ws,a=this.nonce(),o=this.safeValue(this.clients,r);let d;if(o===void 0){const c={},h=this.market(s).id;c[h]=!0;let l=[h];i&&(l=[l]),d={id:a,method:t,params:l};const p=this.extend(d,n);return await this.watch(r,e,p,t,c)}else{const c=this.safeValue(o.subscriptions,t,{});let u=!0;const l=this.market(s).id;if(this.safeValue(c,l,!1)||(c[l]=!0,u=!1),u)return await this.watch(r,e,d,t,c);{let m=Object.keys(c);i&&(m=[m]);const g={id:a,method:t,params:m};return t in o.subscriptions&&delete o.subscriptions[t],await this.watch(r,e,g,t,c)}}}async watchPrivate(e,t,s=[],i={}){this.checkRequiredCredentials(),await this.authenticate();const n=this.urls.api.ws,a={id:this.nonce(),method:t,params:s},o=this.extend(a,i);return await this.watch(n,e,o,e)}async authenticate(e={}){this.checkRequiredCredentials();const t=this.urls.api.ws,s="login",i=this.client(t),n=i.future("authenticated");if(this.safeValue(i.subscriptions,s)===void 0){const a=await this.v4PrivatePostProfileWebsocketToken(),o=this.safeString(a,"websocket_token"),d=this.nonce(),c={id:d,method:"authorize",params:[o,"public"]},u={id:d,method:this.handleAuthenticate};this.spawn(this.watch,t,s,c,s,u)}return await n}handleAuthenticate(e,t){return e.futures.authenticated.resolve(1),t}handleErrorMessage(e,t){const s=this.safeValue(t,"error");try{if(s!==void 0){const i=this.safeString(t,"code"),n=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.ws.exact,i,n)}}catch(i){if(i instanceof fO)return e.reject(i,"authenticated"),"login"in e.subscriptions&&delete e.subscriptions.login,!1}return t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;const s=this.safeValue(t,"result",{});if(s!==void 0&&s==="pong"){this.handlePong(e,t);return}const i=this.safeInteger(t,"id");if(i!==void 0){this.handleSubscriptionStatus(e,t,i);return}const n={market_update:this.handleTicker,trades_update:this.handleTrades,depth_update:this.handleOrderBook,candles_update:this.handleOHLCV,ordersPending_update:this.handleOrder,ordersExecuted_update:this.handleOrder,balanceSpot_update:this.handleBalance,balanceMargin_update:this.handleBalance,deals_update:this.handleMyTrades},r=this.safeValue(t,"method"),a=this.safeValue(n,r);a!==void 0&&a.call(this,e,t)}handleSubscriptionStatus(e,t,s){const i=e.subscriptions,n=Object.values(i);for(let r=0;r<n.length;r++){const a=n[r];if(a!==!0){const o=this.safeInteger(a,"id");if(o!==void 0&&o===s){const d=this.safeValue(a,"method");if(d!==void 0){d.call(this,e,t);return}}}}}handlePong(e,t){return e.lastPong=this.milliseconds(),t}ping(e){return{id:0,method:"ping",params:[]}}};const gz=Q_,{ExchangeError:yz}=oe,{ArrayCache:bz}=et;var wz=class extends gz{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTicker:!0,watchTrades:!0},urls:{api:{ws:"wss://api.{hostname}/websocket"}},options:{tradesLimit:1e3,ordersLimit:1e3,OHLCVLimit:1e3}})}async watchPublic(e,t,s,i={}){await this.loadMarkets();const n=this.market(t);t=n.symbol;const r=n.baseId+n.quoteId+"_"+e,a=this.implodeHostname(this.urls.api.ws),o={event:"addChannel",channel:r},d=this.extend(o,i),c={name:e,symbol:t,marketId:n.id,messageHash:r,method:s};return await this.watch(a,r,d,r,c)}async watchTicker(e,t={}){return await this.watchPublic("ticker",e,this.handleTicker,t)}handleTicker(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeString(t,"channel"),r=this.market(i),a=this.safeValue(t,"ticker");a.date=this.safeValue(t,"date");const o=this.parseTicker(a,r);return o.symbol=i,this.tickers[i]=o,e.resolve(o,n),t}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.watchPublic("trades",e,this.handleTrades,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}handleTrades(e,t,s){const i=this.safeValue(t,"channel"),n=this.safeString(s,"symbol"),r=this.market(n),a=this.safeValue(t,"data"),o=this.parseTrades(a,r);let d=this.safeValue(this.trades,n);if(d===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);d=new bz(c)}for(let c=0;c<o.length;c++)d.append(o[c]);this.trades[n]=d,e.resolve(d,i)}async watchOrderBook(e,t=void 0,s={}){if(t!==void 0){if(t!==5&&t!==10&&t!==20)throw new yz(this.id+" watchOrderBook limit argument must be undefined, 5, 10 or 20")}else t=5;await this.loadMarkets();const i=this.market(e);e=i.symbol;const n="quick_depth",r=i.baseId+i.quoteId+"_"+n,a=this.implodeHostname(this.urls.api.ws)+"/"+i.baseId,o={event:"addChannel",channel:r,length:t},d=this.extend(o,s),c={name:n,symbol:e,marketId:i.id,messageHash:r,method:this.handleOrderBook};return(await this.watch(a,r,d,r,c)).limit()}handleOrderBook(e,t,s){const i=this.safeString(t,"channel"),n=this.safeInteger(s,"limit"),r=this.safeString(s,"symbol");let a=this.safeValue(this.orderbooks,r);a===void 0&&(a=this.orderBook({},n),this.orderbooks[r]=a);const o=this.safeInteger(t,"lastTime"),d=this.parseOrderBook(t,r,o,"listDown","listUp");a.reset(d),a.symbol=r,e.resolve(a,i)}handleMessage(e,t){if(this.safeString(t,"dataType")!==void 0){const i=this.safeString(t,"channel"),n=this.safeValue(e.subscriptions,i);if(n!==void 0){const r=this.safeValue(n,"method");if(r!==void 0)return r.call(this,e,t,n)}return t}}};const Sz=iC;var kz=class extends Sz{describe(){return this.deepExtend(super.describe(),{id:"zipmex",name:"Zipmex",countries:["AU","SG","TH","ID"],urls:{logo:"https://user-images.githubusercontent.com/1294454/146103275-c39a34d9-68a4-4cd2-b1f1-c684548d311b.jpg",test:void 0,api:{public:"https://apws.zipmex.com:8443/AP",private:"https://apws.zipmex.com:8443/AP",ws:"wss://apws.zipmex.com/WSGateway"},www:"https://zipmex.com/",referral:"https://trade.zipmex.com/global/accounts/sign-up?aff=KLm7HyCsvN",fees:"https://zipmex.com/fee-schedule"},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.002"),maker:this.parseNumber("0.002")}}})}};const rC=me,pO=Cq,vz=ke,Tz=Au,Oz=oe,aC="2.2.30";rC.ccxtVersion=aC;const hy={aax:w_,alpaca:Dq,ascendex:S_,bequant:Zq,bibox:o4,bigone:f4,binance:Eu,binancecoinm:w4,binanceus:k4,binanceusdm:T4,bit2c:A4,bitbank:L4,bitbay:K4,bitbns:s5,bitcoincom:r5,bitfinex:T_,bitfinex2:O_,bitflyer:C5,bitforex:V5,bitget:D5,bithumb:X5,bitmart:I_,bitmex:x_,bitopro:__,bitpanda:h6,bitrue:w6,bitso:C6,bitstamp:C_,bitstamp1:U6,bittrex:M_,bitvavo:P_,bkex:cL,bl3p:hL,blockchaincom:SL,btcalpha:CL,btcbox:LL,btcex:HL,btcmarkets:KL,btctradeua:ZL,btcturk:i8,buda:c8,bybit:A_,bytetrade:b8,cex:B_,coinbase:A8,coinbaseprime:D8,coinbasepro:vb,coincheck:j8,coinex:N_,coinfalcon:aR,coinmate:pR,coinone:kR,coinspot:xR,crex24:VR,cryptocom:E_,currencycom:V_,delta:nF,deribit:q_,digifinex:bF,exmo:L_,flowbtc:MF,fmfwio:v_,gate:Tb,gateio:qF,gemini:HF,hitbtc:Dl,hitbtc3:YF,hollaex:R_,huobi:Ob,huobijp:F_,huobipro:gD,idex:D_,independentreserve:BD,indodax:RD,itbit:UD,kraken:H_,kucoin:Ib,kucoinfutures:uH,kuna:mH,latoken:TH,lbank:MH,lbank2:LH,liquid:zH,luno:G_,lykke:s9,mercado:o9,mexc:U_,mexc3:S9,ndax:Hl,novadax:N9,oceanex:F9,okcoin:$_,okex:j_,okex5:eG,okx:xb,paymium:nG,phemex:W_,poloniex:bG,probit:_G,qtrade:VG,ripio:z_,stex:QG,therock:t7,tidex:d7,timex:p7,tokocrypto:O7,upbit:K_,wavesexchange:L7,wazirx:X_,whitebit:Y_,woo:Z7,yobit:rU,zaif:uU,zb:Q_,zipmex:bU,zonda:k_},Jh={aax:_U,ascendex:NU,bequant:RU,binance:Gl,binancecoinm:$U,binanceus:WU,binanceusdm:KU,bitcoincom:YU,bitfinex:s$,bitfinex2:c$,bitmart:m$,bitmex:k$,bitopro:I$,bitstamp:A$,bittrex:L$,bitvavo:G$,bybit:z$,cex:Q$,coinbaseprime:tj,coinbasepro:eC,coinex:uj,cryptocom:gj,currencycom:kj,deribit:xj,exmo:Aj,gate:tC,gateio:Dj,hitbtc:_b,hollaex:Wj,huobi:sC,huobijp:sW,huobipro:nW,idex:cW,kraken:bW,kucoin:OW,luno:_W,mexc:NW,ndax:iC,okcoin:HW,okex:XW,okx:nC,phemex:JW,ripio:sz,upbit:rz,wazirx:uz,whitebit:mz,zb:wz,zipmex:kz};for(const f in Jh){const e=hy[f];Object.getPrototypeOf(e).name==="Exchange"&&(Object.setPrototypeOf(e,pO),Object.setPrototypeOf(e.prototype,pO.prototype))}Jh.exchanges=Object.keys(Jh);var mO=Object.assign({version:aC,Exchange:rC,Precise:vz,exchanges:Object.keys(hy),pro:Jh},hy,Tz,Oz);window.Buffer=ul.Buffer;const Iz=mO.exchanges.filter(f=>new mO[f]().hasFetchPositions);const os=typeof window<"u",Cb=os&&"IntersectionObserver"in window,xz=os&&("ontouchstart"in window||window.navigator.maxTouchPoints>0),ly=os&&typeof CSS<"u"&&CSS.supports("selector(:focus-visible)");function oC(f){const e=be(),t=be();if(os){const s=new ResizeObserver(i=>{f==null||f(i,s),i.length&&(t.value=i[0].contentRect)});hn(()=>{s.disconnect()}),Je(e,(i,n)=>{n&&(s.unobserve(n),t.value=void 0),i&&s.observe(i)},{flush:"post"})}return{resizeRef:e,contentRect:Iu(t)}}function gO(f,e,t){_z(f,e),e.set(f,t)}function _z(f,e){if(e.has(f))throw new TypeError("Cannot initialize the same private elements twice on an object")}function Cz(f,e,t){var s=dC(f,e,"set");return Mz(f,s,t),t}function Mz(f,e,t){if(e.set)e.set.call(f,t);else{if(!e.writable)throw new TypeError("attempted to set read only private field");e.value=t}}function Qa(f,e){var t=dC(f,e,"get");return Pz(f,t)}function dC(f,e,t){if(!e.has(f))throw new TypeError("attempted to "+t+" private field on non-instance");return e.get(f)}function Pz(f,e){return e.get?e.get.call(f):e.value}function cC(f,e,t){const s=e.length-1;if(s<0)return f===void 0?t:f;for(let i=0;i<s;i++){if(f==null)return t;f=f[e[i]]}return f==null||f[e[s]]===void 0?t:f[e[s]]}function Ul(f,e){if(f===e)return!0;if(f instanceof Date&&e instanceof Date&&f.getTime()!==e.getTime()||f!==Object(f)||e!==Object(e))return!1;const t=Object.keys(f);return t.length!==Object.keys(e).length?!1:t.every(s=>Ul(f[s],e[s]))}function py(f,e,t){return f==null||!e||typeof e!="string"?t:f[e]!==void 0?f[e]:(e=e.replace(/\[(\w+)\]/g,".$1"),e=e.replace(/^\./,""),cC(f,e.split("."),t))}function Kn(f,e,t){if(e==null)return f===void 0?t:f;if(f!==Object(f)){if(typeof e!="function")return t;const i=e(f,t);return typeof i>"u"?t:i}if(typeof e=="string")return py(f,e,t);if(Array.isArray(e))return cC(f,e,t);if(typeof e!="function")return t;const s=e(f,t);return typeof s>"u"?t:s}function Az(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0;return Array.from({length:f},(t,s)=>e+s)}function We(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"px";if(!(f==null||f===""))return isNaN(+f)?String(f):isFinite(+f)?`${Number(f)}${e}`:void 0}function my(f){return f!==null&&typeof f=="object"&&!Array.isArray(f)}function Bz(f){return f==null?void 0:f.$el}const yO=Object.freeze({enter:13,tab:9,delete:46,esc:27,space:32,up:38,down:40,left:37,right:39,end:35,home:36,del:46,backspace:8,insert:45,pageup:33,pagedown:34,shift:16});Object.freeze({enter:"Enter",tab:"Tab",delete:"Delete",esc:"Escape",space:"Space",up:"ArrowUp",down:"ArrowDown",left:"ArrowLeft",right:"ArrowRight",end:"End",home:"Home",del:"Delete",backspace:"Backspace",insert:"Insert",pageup:"PageUp",pagedown:"PageDown",shift:"Shift"});function vr(f,e){const t=Object.create(null),s=Object.create(null);for(const i in f)e.some(n=>n instanceof RegExp?n.test(i):n===i)?t[i]=f[i]:s[i]=f[i];return[t,s]}function Mb(f,e){const t={...f};return e.forEach(s=>delete t[s]),t}function Pb(f){return vr(f,["class","style","id",/^data-/])}function Xn(f){return f==null?[]:Array.isArray(f)?f:[f]}function gy(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,t=arguments.length>2&&arguments[2]!==void 0?arguments[2]:1;return Math.max(e,Math.min(t,f))}function yr(){let f=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},t=arguments.length>2?arguments[2]:void 0;const s={};for(const i in f)s[i]=f[i];for(const i in e){const n=f[i],r=e[i];if(my(n)&&my(r)){s[i]=yr(n,r,t);continue}if(Array.isArray(n)&&Array.isArray(r)&&t){s[i]=t(n,r);continue}s[i]=r}return s}function uC(f){return f.map(e=>e.type===Vt?uC(e.children):e).flat()}function $l(){return(arguments.length>0&&arguments[0]!==void 0?arguments[0]:"").replace(/[^a-z]/gi,"-").replace(/\B([A-Z])/g,"-$1").toLowerCase()}function du(f,e){if(!e||typeof e!="object")return[];if(Array.isArray(e))return e.map(t=>du(f,t)).flat(1);if(Array.isArray(e.children))return e.children.map(t=>du(f,t)).flat(1);if(e.component){if(Object.getOwnPropertySymbols(e.component.provides).includes(f))return[e.component];if(e.component.subTree)return du(f,e.component.subTree).flat(1)}return[]}var Ch=new WeakMap,Xo=new WeakMap;class Nz{constructor(e){gO(this,Ch,{writable:!0,value:[]}),gO(this,Xo,{writable:!0,value:0}),this.size=e}push(e){Qa(this,Ch)[Qa(this,Xo)]=e,Cz(this,Xo,(Qa(this,Xo)+1)%this.size)}values(){return Qa(this,Ch).slice(Qa(this,Xo)).concat(Qa(this,Ch).slice(0,Qa(this,Xo)))}}function Ab(f){const e=Js({}),t=te(f);return wr(()=>{for(const s in t.value)e[s]=t.value[s]},{flush:"sync"}),Wy(e)}function el(f,e){return f.includes(e)}const Ez=/^on[^a-z]/,fC=f=>Ez.test(f),co=[Function,Array];function bO(f,e){return e="on"+br(e),!!(f[e]||f[`${e}Once`]||f[`${e}Capture`]||f[`${e}OnceCapture`]||f[`${e}CaptureOnce`])}function Vz(f){for(var e=arguments.length,t=new Array(e>1?e-1:0),s=1;s<e;s++)t[s-1]=arguments[s];if(Array.isArray(f))for(const i of f)i(...t);else typeof f=="function"&&f(...t)}const hC=["top","bottom"],qz=["start","end","left","right"];function yy(f,e){let[t,s]=f.split(" ");return s||(s=el(hC,t)?"start":el(qz,t)?"top":"center"),{side:by(t,e),align:by(s,e)}}function by(f,e){return f==="start"?e?"right":"left":f==="end"?e?"left":"right":f}function Vg(f){return{side:{center:"center",top:"bottom",bottom:"top",left:"right",right:"left"}[f.side],align:f.align}}function qg(f){return{side:f.side,align:{center:"center",top:"bottom",bottom:"top",left:"right",right:"left"}[f.align]}}function wO(f){return{side:f.align,align:f.side}}function SO(f){return el(hC,f.side)?"y":"x"}class fd{constructor(e){let{x:t,y:s,width:i,height:n}=e;this.x=t,this.y=s,this.width=i,this.height=n}get top(){return this.y}get bottom(){return this.y+this.height}get left(){return this.x}get right(){return this.x+this.width}}function kO(f,e){return{x:{before:Math.max(0,e.left-f.left),after:Math.max(0,f.right-e.right)},y:{before:Math.max(0,e.top-f.top),after:Math.max(0,f.bottom-e.bottom)}}}function Bb(f){const e=f.getBoundingClientRect(),t=getComputedStyle(f),s=t.transform;if(s){let i,n,r,a,o;if(s.startsWith("matrix3d("))i=s.slice(9,-1).split(/, /),n=+i[0],r=+i[5],a=+i[12],o=+i[13];else if(s.startsWith("matrix("))i=s.slice(7,-1).split(/, /),n=+i[0],r=+i[3],a=+i[4],o=+i[5];else return new fd(e);const d=t.transformOrigin,c=e.x-a-(1-n)*parseFloat(d),u=e.y-o-(1-r)*parseFloat(d.slice(d.indexOf(" ")+1)),h=n?e.width/n:f.offsetWidth+1,l=r?e.height/r:f.offsetHeight+1;return new fd({x:c,y:u,width:h,height:l})}else return new fd(e)}function rd(f,e,t){if(typeof f.animate>"u")return{finished:Promise.resolve()};const s=f.animate(e,t);return typeof s.finished>"u"&&(s.finished=new Promise(i=>{s.onfinish=()=>{i(s)}})),s}function lC(f,e,t){if(t&&(e={_isVue:!0,$parent:t,$options:e}),e){if(e.$_alreadyWarned=e.$_alreadyWarned||[],e.$_alreadyWarned.includes(f))return;e.$_alreadyWarned.push(f)}return`[Vuetify] ${f}`+(e?Fz(e):"")}function hd(f,e,t){const s=lC(f,e,t);s!=null&&console.warn(s)}function wy(f,e,t){const s=lC(f,e,t);s!=null&&console.error(s)}const Lz=/(?:^|[-_])(\w)/g,Rz=f=>f.replace(Lz,e=>e.toUpperCase()).replace(/[-_]/g,"");function Lg(f,e){if(f.$root===f)return"<Root>";const t=typeof f=="function"&&f.cid!=null?f.options:f._isVue?f.$options||f.constructor.options:f||{};let s=t.name||t._componentTag;const i=t.__file;if(!s&&i){const n=i.match(/([^/\\]+)\.vue$/);s=n==null?void 0:n[1]}return(s?`<${Rz(s)}>`:"<Anonymous>")+(i&&e!==!1?` at ${i}`:"")}function Fz(f){if(f._isVue&&f.$parent){const e=[];let t=0;for(;f;){if(e.length>0){const s=e[e.length-1];if(s.constructor===f.constructor){t++,f=f.$parent;continue}else t>0&&(e[e.length-1]=[s,t],t=0)}e.push(f),f=f.$parent}return`

found in

`+e.map((s,i)=>`${i===0?"---> ":" ".repeat(5+i*2)}${Array.isArray(s)?`${Lg(s[0])}... (${s[1]} recursive calls)`:Lg(s)}`).join(`
`)}else return`

(found in ${Lg(f)})`}const Dz=[[3.2406,-1.5372,-.4986],[-.9689,1.8758,.0415],[.0557,-.204,1.057]],Hz=f=>f<=.0031308?f*12.92:1.055*f**(1/2.4)-.055,Gz=[[.4124,.3576,.1805],[.2126,.7152,.0722],[.0193,.1192,.9505]],Uz=f=>f<=.04045?f/12.92:((f+.055)/1.055)**2.4;function pC(f){const e=Array(3),t=Hz,s=Dz;for(let i=0;i<3;++i)e[i]=Math.round(gy(t(s[i][0]*f[0]+s[i][1]*f[1]+s[i][2]*f[2]))*255);return(e[0]<<16)+(e[1]<<8)+(e[2]<<0)}function Nb(f){const e=[0,0,0],t=Uz,s=Gz,i=t((f>>16&255)/255),n=t((f>>8&255)/255),r=t((f>>0&255)/255);for(let a=0;a<3;++a)e[a]=s[a][0]*i+s[a][1]*n+s[a][2]*r;return e}const tl=.20689655172413793,$z=f=>f>tl**3?Math.cbrt(f):f/(3*tl**2)+4/29,jz=f=>f>tl?f**3:3*tl**2*(f-4/29);function mC(f){const e=$z,t=e(f[1]);return[116*t-16,500*(e(f[0]/.95047)-t),200*(t-e(f[2]/1.08883))]}function gC(f){const e=jz,t=(f[0]+16)/116;return[e(t+f[1]/500)*.95047,e(t),e(t-f[2]/200)*1.08883]}function vO(f){return!!f&&/^(#|var\(--|(rgb|hsl)a?\()/.test(f)}function sl(f){let e;if(typeof f=="number")e=f;else if(typeof f=="string"){let t=f.startsWith("#")?f.substring(1):f;t.length===3&&(t=t.split("").map(s=>s+s).join("")),t.length!==6&&t.length!==8&&hd(`'${f}' is not a valid rgb color`),e=parseInt(t,16)}else throw new TypeError(`Colors can only be numbers or strings, recieved ${f==null?f:f.constructor.name} instead`);return e<0?(hd(`Colors cannot be negative: '${f}'`),e=0):(e>4294967295||isNaN(e))&&(hd(`'${f}' is not a valid rgb color`),e=16777215),e}function Wz(f){let e=f.toString(16);return e.length<6&&(e="0".repeat(6-e.length)+e),"#"+e}function yC(f){const e=sl(f);return{r:(e&16711680)>>16,g:(e&65280)>>8,b:e&255}}function zz(f,e){const t=mC(Nb(f));return t[0]=t[0]+e*10,pC(gC(t))}function Kz(f,e){const t=mC(Nb(f));return t[0]=t[0]-e*10,pC(gC(t))}function Xz(f){const e=sl(f);return Nb(e)[1]}function ti(f,e){const t=Ol();if(!t)throw new Error(`[Vuetify] ${f} ${e||"must be called from inside a setup function"}`);return t}function Tr(){let f=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"composables";const e=ti(f).type;return $l((e==null?void 0:e.aliasName)||(e==null?void 0:e.name))}let bC=0,$h=new WeakMap;function ln(){const f=ti("getUid");if($h.has(f))return $h.get(f);{const e=bC++;return $h.set(f,e),e}}ln.reset=()=>{bC=0,$h=new WeakMap};function Yz(f){const{provides:e}=ti("injectSelf");if(e&&f in e)return e[f]}const ku=Symbol.for("vuetify:defaults");function Qz(f){return be(f!=null?f:{})}function wC(){const f=Yt(ku);if(!f)throw new Error("[Vuetify] Could not find defaults instance");return f}function la(f,e){const t=wC(),s=be(f),i=te(()=>{const n=rn(e==null?void 0:e.scoped),r=rn(e==null?void 0:e.reset),a=rn(e==null?void 0:e.root);let o=yr(s.value,{prev:t.value});if(n)return o;if(r||a){const d=Number(r||1/0);for(let c=0;c<=d&&o.prev;c++)o=o.prev;return o}return yr(o.prev,o)});return Mi(ku,i),i}function bd(f,e){let t;Je(f,s=>{if(s&&!t)t=ml(),t.run(e);else if(!s){var i;(i=t)==null||i.stop(),t=void 0}},{immediate:!0}),Zn(()=>{var s;(s=t)==null||s.stop()})}function Ke(f,e){return t=>Object.keys(f).reduce((s,i)=>{const r=typeof f[i]=="object"&&f[i]!=null&&!Array.isArray(f[i])?f[i]:{type:f[i]};return t&&i in t?s[i]={...r,default:t[i]}:s[i]=r,e&&!s[i].source&&(s[i].source=e),s},{})}function Zz(f,e){var t,s;return((t=f.props)==null?void 0:t.hasOwnProperty(e))||((s=f.props)==null?void 0:s.hasOwnProperty($l(e)))}const Ye=function(e){var t,s;return e._setup=(t=e._setup)!=null?t:e.setup,e.name?(e._setup&&(e.props=(s=e.props)!=null?s:{},e.props=Ke(e.props,$l(e.name))(),e.props._as=String,e.setup=function(n,r){const a=Ol(),o=wC(),d=GM(),c=yI({...ut(n)});wr(()=>{var p,m,g;const h=o.value.global,l=o.value[(p=n._as)!=null?p:e.name];if(l){const y=Object.entries(l).filter(b=>{let[w]=b;return w.startsWith(w[0].toUpperCase())});y.length&&(d.value=Object.fromEntries(y))}for(const y of Object.keys(n)){let b=n[y];Zz(a.vnode,y)||(b=(g=(m=l==null?void 0:l[y])!=null?m:h==null?void 0:h[y])!=null?g:n[y]),c[y]!==b&&(c[y]=b)}});const u=e._setup(c,r);return bd(d,()=>{var l;var h;la(yr((l=(h=Yz(ku))==null?void 0:h.value)!=null?l:{},d.value))}),u}),e):(hd("The component is missing an explicit name, unable to generate default prop value"),e)};function Pi(){let f=arguments.length>0&&arguments[0]!==void 0?arguments[0]:!0;return e=>(f?Ye:Qy)(e)}function Vu(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"div",t=arguments.length>2?arguments[2]:void 0;return Ye({name:t!=null?t:br(fn(f.replace(/__/g,"-"))),props:{tag:{type:String,default:e}},setup(s,i){let{slots:n}=i;return()=>{var r;return ha(s.tag,{class:f},(r=n.default)==null?void 0:r.call(n))}}})}function SC(f){if(typeof f.getRootNode!="function"){for(;f.parentNode;)f=f.parentNode;return f!==document?null:document}const e=f.getRootNode();return e!==document&&e.getRootNode({composed:!0})!==document?null:e}const il="cubic-bezier(0.4, 0, 0.2, 1)",Jz="cubic-bezier(0.0, 0, 0.2, 1)",eK="cubic-bezier(0.4, 0, 1, 1)";function tK(f){for(;f;){if(Eb(f))return f;f=f.parentElement}return document.scrollingElement}function nl(f,e){const t=[];if(e&&f&&!e.contains(f))return t;for(;f&&(Eb(f)&&t.push(f),f!==e);)f=f.parentElement;return t}function Eb(f){if(!f||f.nodeType!==Node.ELEMENT_NODE)return!1;const e=window.getComputedStyle(f);return e.overflowY==="scroll"||e.overflowY==="auto"&&f.scrollHeight>f.clientHeight}function sK(f){for(;f;){if(window.getComputedStyle(f).position==="fixed")return!0;f=f.offsetParent}return!1}function tt(f){const e=ti("useRender");e.render=f}const rl=Symbol.for("vuetify:layout"),kC=Symbol.for("vuetify:layout-item"),TO=1e3,iK=Ke({overlaps:{type:Array,default:()=>[]},fullHeight:Boolean},"layout"),nK=Ke({name:{type:String},order:{type:[Number,String],default:0},absolute:Boolean},"layout-item");function rK(){const f=Yt(rl);if(!f)throw new Error("[Vuetify] Could not find injected layout");return{getLayoutItem:f.getLayoutItem,mainRect:f.mainRect,mainStyles:f.mainStyles}}function aK(f){var a;const e=Yt(rl);if(!e)throw new Error("[Vuetify] Could not find injected layout");const t=(a=f.id)!=null?a:`layout-item-${ln()}`,s=ti("useLayoutItem");Mi(kC,{id:t});const i=be(!1);LI(()=>i.value=!0),qI(()=>i.value=!1);const{layoutItemStyles:n,layoutItemScrimStyles:r}=e.register(s,{...f,active:te(()=>i.value?!1:f.active.value),id:t});return hn(()=>e.unregister(t)),{layoutItemStyles:n,layoutRect:e.layoutRect,layoutItemScrimStyles:r}}const oK=(f,e,t,s)=>{let i={top:0,left:0,right:0,bottom:0};const n=[{id:"",layer:{...i}}];for(const r of f){const a=e.get(r),o=t.get(r),d=s.get(r);if(!a||!o||!d)continue;const c={...i,[a.value]:parseInt(i[a.value],10)+(d.value?parseInt(o.value,10):0)};n.push({id:r,layer:c}),i=c}return n};function dK(f){const e=Yt(rl,null),t=te(()=>e?e.rootZIndex.value-100:TO),s=be([]),i=Js(new Map),n=Js(new Map),r=Js(new Map),a=Js(new Map),o=Js(new Map),{resizeRef:d,contentRect:c}=oC(),u=te(()=>{var _;const T=new Map,I=(_=f.overlaps)!=null?_:[];for(const N of I.filter(M=>M.includes(":"))){const[M,x]=N.split(":");if(!s.value.includes(M)||!s.value.includes(x))continue;const v=i.get(M),O=i.get(x),A=n.get(M),V=n.get(x);!v||!O||!A||!V||(T.set(x,{position:v.value,amount:parseInt(A.value,10)}),T.set(M,{position:O.value,amount:-parseInt(V.value,10)}))}return T}),h=te(()=>{const T=[...new Set([...r.values()].map(_=>_.value))].sort((_,N)=>_-N),I=[];for(const _ of T){const N=s.value.filter(M=>{var x;return((x=r.get(M))==null?void 0:x.value)===_});I.push(...N)}return oK(I,i,n,a)}),l=te(()=>!Array.from(o.values()).some(T=>T.value)),p=te(()=>h.value[h.value.length-1].layer),m=te(()=>({"--v-layout-left":We(p.value.left),"--v-layout-right":We(p.value.right),"--v-layout-top":We(p.value.top),"--v-layout-bottom":We(p.value.bottom),...l.value?void 0:{transition:"none"}})),g=te(()=>h.value.slice(1).map((T,I)=>{let{id:_}=T;const{layer:N}=h.value[I],M=n.get(_),x=i.get(_);return{id:_,...N,size:Number(M.value),position:x.value}})),y=T=>g.value.find(I=>I.id===T),b=ti("createLayout"),w=be(!1);Jn(()=>{w.value=!0}),Mi(rl,{register:(T,I)=>{let{id:_,order:N,position:M,layoutSize:x,elementSize:v,active:O,disableTransitions:A,absolute:V}=I;r.set(_,N),i.set(_,M),n.set(_,x),a.set(_,O),A&&o.set(_,A);const R=du(kC,b==null?void 0:b.vnode).indexOf(T);R>-1?s.value.splice(R,0,_):s.value.push(_);const H=te(()=>g.value.findIndex(j=>j.id===_)),F=te(()=>t.value+h.value.length*2-H.value*2),P=te(()=>{const j=M.value==="left"||M.value==="right",X=M.value==="right",Q=M.value==="bottom",Se={[M.value]:0,zIndex:F.value,transform:`translate${j?"X":"Y"}(${(O.value?0:-110)*(X||Q?-1:1)}%)`,position:V.value||t.value!==TO?"absolute":"fixed",...l.value?void 0:{transition:"none"}};if(!w.value)return Se;const he=g.value[H.value];if(!he)throw new Error(`[Vuetify] Could not find layout item "${_}"`);const xe=u.value.get(_);return xe&&(he[xe.position]+=xe.amount),{...Se,height:j?`calc(100% - ${he.top}px - ${he.bottom}px)`:v.value?`${v.value}px`:void 0,left:X?void 0:`${he.left}px`,right:X?`${he.right}px`:void 0,top:M.value!=="bottom"?`${he.top}px`:void 0,bottom:M.value!=="top"?`${he.bottom}px`:void 0,width:j?v.value?`${v.value}px`:void 0:`calc(100% - ${he.left}px - ${he.right}px)`}}),E=te(()=>({zIndex:F.value-1}));return{layoutItemStyles:P,layoutItemScrimStyles:E,zIndex:F}},unregister:T=>{r.delete(T),i.delete(T),n.delete(T),a.delete(T),o.delete(T),s.value=s.value.filter(I=>I!==T)},mainRect:p,mainStyles:m,getLayoutItem:y,items:g,layoutRect:c,rootZIndex:t});const S=te(()=>["v-layout",{"v-layout--full-height":f.fullHeight}]),k=te(()=>({zIndex:t.value,position:e?"relative":void 0,overflow:e?"hidden":void 0}));return{layoutClasses:S,layoutStyles:k,getLayoutItem:y,items:g,layoutRect:c,layoutRef:d}}const Yo=2.4,OO=.2126729,IO=.7151522,xO=.072175,cK=.55,uK=.58,fK=.57,hK=.62,Mh=.03,_O=1.45,lK=5e-4,pK=1.25,mK=1.25,CO=.078,MO=12.82051282051282,Ph=.06,PO=.001;function AO(f,e){const t=((f>>16&255)/255)**Yo,s=((f>>8&255)/255)**Yo,i=((f>>0&255)/255)**Yo,n=((e>>16&255)/255)**Yo,r=((e>>8&255)/255)**Yo,a=((e>>0&255)/255)**Yo;let o=t*OO+s*IO+i*xO,d=n*OO+r*IO+a*xO;if(o<=Mh&&(o+=(Mh-o)**_O),d<=Mh&&(d+=(Mh-d)**_O),Math.abs(d-o)<lK)return 0;let c;if(d>o){const u=(d**cK-o**uK)*pK;c=u<PO?0:u<CO?u-u*MO*Ph:u-Ph}else{const u=(d**hK-o**fK)*mK;c=u>-PO?0:u>-CO?u-u*MO*Ph:u+Ph}return c*100}const al=Symbol.for("vuetify:theme"),Ws=Ke({theme:String},"theme"),Xc={defaultTheme:"light",variations:{colors:[],lighten:0,darken:0},themes:{light:{dark:!1,colors:{background:"#FFFFFF",surface:"#FFFFFF","surface-variant":"#424242","on-surface-variant":"#EEEEEE",primary:"#6200EE","primary-darken-1":"#3700B3",secondary:"#03DAC6","secondary-darken-1":"#018786",error:"#B00020",info:"#2196F3",success:"#4CAF50",warning:"#FB8C00"},variables:{"border-color":"#000000","border-opacity":.12,"high-emphasis-opacity":.87,"medium-emphasis-opacity":.6,"disabled-opacity":.38,"idle-opacity":.04,"hover-opacity":.04,"focus-opacity":.12,"selected-opacity":.08,"activated-opacity":.12,"pressed-opacity":.12,"dragged-opacity":.08,"theme-kbd":"#212529","theme-on-kbd":"#FFFFFF","theme-code":"#F5F5F5","theme-on-code":"#000000"}},dark:{dark:!0,colors:{background:"#121212",surface:"#212121","surface-variant":"#BDBDBD","on-surface-variant":"#424242",primary:"#BB86FC","primary-darken-1":"#3700B3",secondary:"#03DAC5","secondary-darken-1":"#03DAC5",error:"#CF6679",info:"#2196F3",success:"#4CAF50",warning:"#FB8C00"},variables:{"border-color":"#FFFFFF","border-opacity":.12,"high-emphasis-opacity":.87,"medium-emphasis-opacity":.6,"disabled-opacity":.38,"idle-opacity":.1,"hover-opacity":.04,"focus-opacity":.12,"selected-opacity":.08,"activated-opacity":.12,"pressed-opacity":.16,"dragged-opacity":.08,"theme-kbd":"#212529","theme-on-kbd":"#FFFFFF","theme-code":"#343434","theme-on-code":"#CCCCCC"}}}};function gK(){var i;let f=arguments.length>0&&arguments[0]!==void 0?arguments[0]:Xc;if(!f)return{...Xc,isDisabled:!0};const e={};for(const[n,r]of Object.entries((i=f.themes)!=null?i:{})){var t,s;const a=r.dark||n==="dark"?(t=Xc.themes)==null?void 0:t.dark:(s=Xc.themes)==null?void 0:s.light;e[n]=yr(a,r)}return yr(Xc,{...f,themes:e})}function yK(f){const e=Js(gK(f)),t=be(e.defaultTheme),s=be(e.themes),i=te(()=>{const d={};for(const[c,u]of Object.entries(s.value)){const h=d[c]={...u,colors:{...u.colors}};if(e.variations)for(const l of e.variations.colors){const p=h.colors[l];if(!!p)for(const m of["lighten","darken"]){const g=m==="lighten"?zz:Kz;for(const y of Az(e.variations[m],1))h.colors[`${l}-${m}-${y}`]=Wz(g(sl(p),y))}}for(const l of Object.keys(h.colors)){if(/^on-[a-z]/.test(l)||h.colors[`on-${l}`])continue;const p=`on-${l}`,m=sl(h.colors[l]),g=Math.abs(AO(0,m)),y=Math.abs(AO(16777215,m));h.colors[p]=y>Math.min(g,50)?"#fff":"#000"}}return d}),n=te(()=>i.value[t.value]),r=te(()=>{const d=[];n.value.dark&&Qo(d,":root",["color-scheme: dark"]);for(const[l,p]of Object.entries(i.value)){const{variables:m,dark:g}=p;Qo(d,`.v-theme--${l}`,[`color-scheme: ${g?"dark":"normal"}`,...bK(p),...Object.keys(m).map(y=>{const b=m[y],w=typeof b=="string"&&b.startsWith("#")?yC(b):void 0,S=w?`${w.r}, ${w.g}, ${w.b}`:void 0;return`--v-${y}: ${S!=null?S:b}`})])}const c=[],u=[],h=new Set(Object.values(i.value).flatMap(l=>Object.keys(l.colors)));for(const l of h)/^on-[a-z]/.test(l)?Qo(u,`.${l}`,[`color: rgb(var(--v-theme-${l})) !important`]):(Qo(c,`.bg-${l}`,[`--v-theme-overlay-multiplier: var(--v-theme-${l}-overlay-multiplier)`,`background: rgb(var(--v-theme-${l})) !important`,`color: rgb(var(--v-theme-on-${l})) !important`]),Qo(u,`.text-${l}`,[`color: rgb(var(--v-theme-${l})) !important`]),Qo(u,`.border-${l}`,[`--v-border-color: var(--v-theme-${l})`]));return d.push(...c,...u),d.map((l,p)=>p===0?l:`    ${l}`).join("")});function a(d){const c=d._context.provides.usehead;if(c)c.addHeadObjs(te(()=>{const h={children:r.value,type:"text/css",id:"vuetify-theme-stylesheet"};return e.cspNonce&&(h.nonce=e.cspNonce),{style:[h]}})),os&&wr(()=>c.updateDOM());else{let l=function(){if(!e.isDisabled){if(typeof document<"u"&&!h){const p=document.createElement("style");p.type="text/css",p.id="vuetify-theme-stylesheet",e.cspNonce&&p.setAttribute("nonce",e.cspNonce),h=p,document.head.appendChild(h)}h&&(h.innerHTML=r.value)}};var u=l;let h=os?document.getElementById("vuetify-theme-stylesheet"):null;Je(r,l,{immediate:!0})}}const o=te(()=>e.isDisabled?void 0:`v-theme--${t.value}`);return{install:a,isDisabled:e.isDisabled,name:t,themes:s,current:n,computedThemes:i,themeClasses:o,styles:r,global:{name:t,current:n}}}function pi(f){ti("provideTheme");const e=Yt(al,null);if(!e)throw new Error("Could not find Vuetify theme injection");const t=te(()=>{var n;return(n=f.theme)!=null?n:e==null?void 0:e.name.value}),s=te(()=>e.isDisabled?void 0:`v-theme--${t.value}`),i={...e,name:t,themeClasses:s};return Mi(al,i),i}function Qo(f,e,t){f.push(`${e} {
`,...t.map(s=>`  ${s};
`),`}
`)}function bK(f){const e=f.dark?2:1,t=f.dark?1:2,s=[];for(const[i,n]of Object.entries(f.colors)){const r=yC(n);s.push(`--v-theme-${i}: ${r.r},${r.g},${r.b}`),i.startsWith("on-")||s.push(`--v-theme-${i}-overlay-multiplier: ${Xz(n)>.18?e:t}`)}return s}function ds(f,e,t){let s=arguments.length>3&&arguments[3]!==void 0?arguments[3]:u=>u,i=arguments.length>4&&arguments[4]!==void 0?arguments[4]:u=>u;const n=ti("useProxiedModel"),r=be(f[e]!==void 0?f[e]:t),a=$l(e),d=te(a!==e?()=>{var u,h,l,p;return f[e],!!(((u=n.vnode.props)!=null&&u.hasOwnProperty(e)||(h=n.vnode.props)!=null&&h.hasOwnProperty(a))&&((l=n.vnode.props)!=null&&l.hasOwnProperty(`onUpdate:${e}`)||(p=n.vnode.props)!=null&&p.hasOwnProperty(`onUpdate:${a}`)))}:()=>{var u,h;return f[e],!!((u=n.vnode.props)!=null&&u.hasOwnProperty(e)&&(h=n.vnode.props)!=null&&h.hasOwnProperty(`onUpdate:${e}`))});bd(()=>!d.value,()=>{Je(()=>f[e],u=>{r.value=u})});const c=te({get(){return s(d.value?f[e]:r.value)},set(u){const h=i(u);(d.value?f[e]:r.value)===h||s(d.value?f[e]:r.value)===u||(r.value=h,n==null||n.emit(`update:${e}`,h))}});return Object.defineProperty(c,"externalValue",{get:()=>d.value?f[e]:r.value}),c}const wK={badge:"Badge",close:"Close",dataIterator:{noResultsText:"No matching records found",loadingText:"Loading items..."},dataTable:{itemsPerPageText:"Rows per page:",ariaLabel:{sortDescending:"Sorted descending.",sortAscending:"Sorted ascending.",sortNone:"Not sorted.",activateNone:"Activate to remove sorting.",activateDescending:"Activate to sort descending.",activateAscending:"Activate to sort ascending."},sortBy:"Sort by"},dataFooter:{itemsPerPageText:"Items per page:",itemsPerPageAll:"All",nextPage:"Next page",prevPage:"Previous page",firstPage:"First page",lastPage:"Last page",pageText:"{0}-{1} of {2}"},datePicker:{itemsSelected:"{0} selected",nextMonthAriaLabel:"Next month",nextYearAriaLabel:"Next year",prevMonthAriaLabel:"Previous month",prevYearAriaLabel:"Previous year"},noDataText:"No data available",carousel:{prev:"Previous visual",next:"Next visual",ariaLabel:{delimiter:"Carousel slide {0} of {1}"}},calendar:{moreEvents:"{0} more"},input:{clear:"Clear {0}",prependAction:"{0} prepended action",appendAction:"{0} appended action"},fileInput:{counter:"{0} files",counterSize:"{0} files ({1} in total)"},timePicker:{am:"AM",pm:"PM"},pagination:{ariaLabel:{root:"Pagination Navigation",next:"Next page",previous:"Previous page",page:"Goto Page {0}",currentPage:"Page {0}, Current Page",first:"First page",last:"Last page"}},rating:{ariaLabel:{item:"Rating {0} of {1}"}}},BO="$vuetify.",NO=(f,e)=>f.replace(/\{(\d+)\}/g,(t,s)=>String(e[+s])),vC=(f,e,t)=>function(s){for(var i=arguments.length,n=new Array(i>1?i-1:0),r=1;r<i;r++)n[r-1]=arguments[r];if(!s.startsWith(BO))return NO(s,n);const a=s.replace(BO,""),o=f.value&&t.value[f.value],d=e.value&&t.value[e.value];let c=py(o,a,null);return c||(hd(`Translation key "${s}" not found in "${f.value}", trying fallback locale`),c=py(d,a,null)),c||(wy(`Translation key "${s}" not found in fallback`),c=s),typeof c!="string"&&(wy(`Translation key "${s}" has a non-string value`),c=s),NO(c,n)};function TC(f,e){return(t,s)=>new Intl.NumberFormat([f.value,e.value],s).format(t)}function Rg(f,e,t){var i,n;const s=ds(f,e,(i=f[e])!=null?i:t.value);return s.value=(n=f[e])!=null?n:t.value,Je(t,r=>{f[e]==null&&(s.value=t.value)}),s}function OC(f){return e=>{const t=Rg(e,"locale",f.current),s=Rg(e,"fallback",f.fallback),i=Rg(e,"messages",f.messages);return{name:"vuetify",current:t,fallback:s,messages:i,t:vC(t,s,i),n:TC(t,s),provide:OC({current:t,fallback:s,messages:i})}}}function SK(f){var i,n;const e=be((i=f==null?void 0:f.locale)!=null?i:"en"),t=be((n=f==null?void 0:f.fallback)!=null?n:"en"),s=be({en:wK,...f==null?void 0:f.messages});return{name:"vuetify",current:e,fallback:t,messages:s,t:vC(e,t,s),n:TC(e,t),provide:OC({current:e,fallback:t,messages:s})}}const kK={af:!1,ar:!0,bg:!1,ca:!1,ckb:!1,cs:!1,de:!1,el:!1,en:!1,es:!1,et:!1,fa:!1,fi:!1,fr:!1,hr:!1,hu:!1,he:!0,id:!1,it:!1,ja:!1,ko:!1,lv:!1,lt:!1,nl:!1,no:!1,pl:!1,pt:!1,ro:!1,ru:!1,sk:!1,sl:!1,srCyrl:!1,srLatn:!1,sv:!1,th:!1,tr:!1,az:!1,uk:!1,vi:!1,zhHans:!1,zhHant:!1},ol=Symbol.for("vuetify:locale");function vK(f){return f.name!=null}function TK(f){const e=f!=null&&f.adapter&&vK(f==null?void 0:f.adapter)?f==null?void 0:f.adapter:SK(f),t=OK(e,f);return{...e,...t}}function Vb(){const f=Yt(ol);if(!f)throw new Error("[Vuetify] Could not find injected locale instance");return f}function OK(f,e){var i;const t=be((i=e==null?void 0:e.rtl)!=null?i:kK),s=te(()=>{var n;return(n=t.value[f.current.value])!=null?n:!1});return{isRtl:s,rtl:t,rtlClasses:te(()=>`v-locale--is-${s.value?"rtl":"ltr"}`)}}function qu(){const f=Yt(ol);if(!f)throw new Error("[Vuetify] Could not find injected rtl instance");return{isRtl:f.isRtl,rtlClasses:f.rtlClasses}}const IK=Ye({name:"VApp",props:{...iK({fullHeight:!0}),...Ws()},setup(f,e){let{slots:t}=e;const s=pi(f),{layoutClasses:i,layoutStyles:n,getLayoutItem:r,items:a,layoutRef:o}=dK(f),{rtlClasses:d}=qu();return tt(()=>{var c;return K("div",{ref:o,class:["v-application",s.themeClasses.value,i.value,d.value],style:n.value},[K("div",{class:"v-application__wrap"},[(c=t.default)==null?void 0:c.call(t)])])}),{getLayoutItem:r,items:a,theme:s}}});function Di(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"top center 0",t=arguments.length>2?arguments[2]:void 0;return Ye({name:f,props:{group:Boolean,hideOnLeave:Boolean,leaveAbsolute:Boolean,mode:{type:String,default:t},origin:{type:String,default:e}},setup(s,i){let{slots:n}=i;return()=>{const r=s.group?bA:Yn;return ha(r,{name:f,mode:s.mode,onBeforeEnter(a){a.style.transformOrigin=s.origin},onLeave(a){if(s.leaveAbsolute){const{offsetTop:o,offsetLeft:d,offsetWidth:c,offsetHeight:u}=a;a._transitionInitialStyles={position:a.style.position,top:a.style.top,left:a.style.left,width:a.style.width,height:a.style.height},a.style.position="absolute",a.style.top=`${o}px`,a.style.left=`${d}px`,a.style.width=`${c}px`,a.style.height=`${u}px`}s.hideOnLeave&&a.style.setProperty("display","none","important")},onAfterLeave(a){if(s.leaveAbsolute&&a!=null&&a._transitionInitialStyles){const{position:o,top:d,left:c,width:u,height:h}=a._transitionInitialStyles;delete a._transitionInitialStyles,a.style.position=o||"",a.style.top=d||"",a.style.left=c||"",a.style.width=u||"",a.style.height=h||""}}},n.default)}}})}function IC(f,e){let t=arguments.length>2&&arguments[2]!==void 0?arguments[2]:"in-out";return Ye({name:f,props:{mode:{type:String,default:t}},setup(s,i){let{slots:n}=i;return()=>ha(Yn,{name:f,...e},n.default)}})}function xC(){let f=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"";const t=(arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1)?"width":"height",s=fn(`offset-${t}`);return{onBeforeEnter(r){r._parent=r.parentNode,r._initialStyle={transition:r.style.transition,overflow:r.style.overflow,[t]:r.style[t]}},onEnter(r){const a=r._initialStyle;r.style.setProperty("transition","none","important"),r.style.overflow="hidden";const o=`${r[s]}px`;r.style[t]="0",r.offsetHeight,r.style.transition=a.transition,f&&r._parent&&r._parent.classList.add(f),requestAnimationFrame(()=>{r.style[t]=o})},onAfterEnter:n,onEnterCancelled:n,onLeave(r){r._initialStyle={transition:"",overflow:r.style.overflow,[t]:r.style[t]},r.style.overflow="hidden",r.style[t]=`${r[s]}px`,r.offsetHeight,requestAnimationFrame(()=>r.style[t]="0")},onAfterLeave:i,onLeaveCancelled:i};function i(r){f&&r._parent&&r._parent.classList.remove(f),n(r)}function n(r){const a=r._initialStyle[t];r.style.overflow=r._initialStyle.overflow,a!=null&&(r.style[t]=a),delete r._initialStyle}}const qb=Ye({name:"VDialogTransition",props:{target:Object},setup(f,e){let{slots:t}=e;const s={onBeforeEnter(i){i.style.pointerEvents="none",i.style.visibility="hidden"},async onEnter(i,n){var r;await new Promise(l=>requestAnimationFrame(l)),await new Promise(l=>requestAnimationFrame(l)),i.style.visibility="";const{x:a,y:o,sx:d,sy:c,speed:u}=VO(f.target,i),h=rd(i,[{transform:`translate(${a}px, ${o}px) scale(${d}, ${c})`,opacity:0},{transform:""}],{duration:225*u,easing:Jz});(r=EO(i))==null||r.forEach(l=>{rd(l,[{opacity:0},{opacity:0,offset:.33},{opacity:1}],{duration:225*2*u,easing:il})}),h.finished.then(()=>n())},onAfterEnter(i){i.style.removeProperty("pointer-events")},onBeforeLeave(i){i.style.pointerEvents="none"},async onLeave(i,n){var r;await new Promise(l=>requestAnimationFrame(l));const{x:a,y:o,sx:d,sy:c,speed:u}=VO(f.target,i);rd(i,[{transform:""},{transform:`translate(${a}px, ${o}px) scale(${d}, ${c})`,opacity:0}],{duration:125*u,easing:eK}).finished.then(()=>n()),(r=EO(i))==null||r.forEach(l=>{rd(l,[{},{opacity:0,offset:.2},{opacity:0}],{duration:125*2*u,easing:il})})},onAfterLeave(i){i.style.removeProperty("pointer-events")}};return()=>f.target?K(Yn,ct({name:"dialog-transition"},s,{css:!1}),t):K(Yn,{name:"dialog-transition"},t)}});function EO(f){var e;const t=(e=f.querySelector(":scope > .v-card, :scope > .v-sheet, :scope > .v-list"))==null?void 0:e.children;return t&&[...t]}function VO(f,e){const t=f.getBoundingClientRect(),s=Bb(e),[i,n]=getComputedStyle(e).transformOrigin.split(" ").map(y=>parseFloat(y)),[r,a]=getComputedStyle(e).getPropertyValue("--v-overlay-anchor-origin").split(" ");let o=t.left+t.width/2;r==="left"||a==="left"?o-=t.width/2:(r==="right"||a==="right")&&(o+=t.width/2);let d=t.top+t.height/2;r==="top"||a==="top"?d-=t.height/2:(r==="bottom"||a==="bottom")&&(d+=t.height/2);const c=t.width/s.width,u=t.height/s.height,h=Math.max(1,c,u),l=c/h,p=u/h,m=s.width*s.height/(window.innerWidth*window.innerHeight),g=m>.12?Math.min(1.5,(m-.12)*10+1):1;return{x:o-(i+s.left),y:d-(n+s.top),sx:l,sy:p,speed:g}}Di("fab-transition","center center","out-in");Di("dialog-bottom-transition");Di("dialog-top-transition");Di("fade-transition");Di("scale-transition");Di("scroll-x-transition");Di("scroll-x-reverse-transition");Di("scroll-y-transition");Di("scroll-y-reverse-transition");Di("slide-x-transition");Di("slide-x-reverse-transition");const _C=Di("slide-y-transition");Di("slide-y-reverse-transition");const xK=IC("expand-transition",xC()),CC=IC("expand-x-transition",xC("",!0));const _K={collapse:"mdi-chevron-up",complete:"mdi-check",cancel:"mdi-close-circle",close:"mdi-close",delete:"mdi-close-circle",clear:"mdi-close-circle",success:"mdi-check-circle",info:"mdi-information",warning:"mdi-alert-circle",error:"mdi-close-circle",prev:"mdi-chevron-left",next:"mdi-chevron-right",checkboxOn:"mdi-checkbox-marked",checkboxOff:"mdi-checkbox-blank-outline",checkboxIndeterminate:"mdi-minus-box",delimiter:"mdi-circle",sort:"mdi-arrow-up",expand:"mdi-chevron-down",menu:"mdi-menu",subgroup:"mdi-menu-down",dropdown:"mdi-menu-down",radioOn:"mdi-radiobox-marked",radioOff:"mdi-radiobox-blank",edit:"mdi-pencil",ratingEmpty:"mdi-star-outline",ratingFull:"mdi-star",ratingHalf:"mdi-star-half-full",loading:"mdi-cached",first:"mdi-page-first",last:"mdi-page-last",unfold:"mdi-unfold-more-horizontal",file:"mdi-paperclip",plus:"mdi-plus",minus:"mdi-minus"},CK={component:f=>ha(MC,{...f,class:"mdi"})},Ot=[String,Function,Object],Sy=Symbol.for("vuetify:icons"),jl=Ke({icon:{type:Ot,required:!0},tag:{type:String,required:!0}},"icon"),MK=Ye({name:"VComponentIcon",props:jl(),setup(f){return()=>K(f.tag,null,{default:()=>[K(f.icon,null,null)]})}}),PK=Ye({name:"VSvgIcon",inheritAttrs:!1,props:jl(),setup(f,e){let{attrs:t}=e;return()=>K(f.tag,ct(t,{style:null}),{default:()=>[K("svg",{class:"v-icon__svg",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",role:"img","aria-hidden":"true"},[K("path",{d:f.icon},null)])]})}});Ye({name:"VLigatureIcon",props:jl(),setup(f){return()=>K(f.tag,null,{default:()=>[f.icon]})}});const MC=Ye({name:"VClassIcon",props:jl(),setup(f){return()=>K(f.tag,{class:f.icon},null)}}),AK={svg:{component:PK},class:{component:MC}};function BK(f){return yr({defaultSet:"mdi",sets:{...AK,mdi:CK},aliases:_K},f)}const NK=f=>{const e=Yt(Sy);if(!e)throw new Error("Missing Vuetify Icons provide!");return{iconData:te(()=>{const s=Xt(f)?f.value:f.icon;if(!s)throw new Error("Icon value is undefined or null");let i=s;if(typeof i=="string"&&(i=i.trim(),i.startsWith("$"))){var n;i=(n=e.aliases)==null?void 0:n[i.slice(1)]}if(!i)throw new Error(`Could not find aliased icon "${s}"`);if(typeof i!="string")return{component:MK,icon:i};const r=Object.keys(e.sets).find(d=>typeof i=="string"&&i.startsWith(`${d}:`)),a=r?i.slice(r.length+1):i;return{component:e.sets[r!=null?r:e.defaultSet].component,icon:a}})}},EK=["x-small","small","default","large","x-large"],Lu=Ke({size:{type:[String,Number],default:"default"}},"size");function Ru(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Tr();return Ab(()=>{let t,s;return el(EK,f.size)?t=`${e}--size-${f.size}`:f.size&&(s={width:We(f.size),height:We(f.size)}),{sizeClasses:t,sizeStyles:s}})}const Vs=Ke({tag:{type:String,default:"div"}},"tag");function Lb(f){return Ab(()=>{const e=[],t={};return f.value.background&&(vO(f.value.background)?t.backgroundColor=f.value.background:e.push(`bg-${f.value.background}`)),f.value.text&&(vO(f.value.text)?(t.color=f.value.text,t.caretColor=f.value.text):e.push(`text-${f.value.text}`)),{colorClasses:e,colorStyles:t}})}function ca(f,e){const t=te(()=>({text:Xt(f)?f.value:e?f[e]:null})),{colorClasses:s,colorStyles:i}=Lb(t);return{textColorClasses:s,textColorStyles:i}}function ua(f,e){const t=te(()=>({background:Xt(f)?f.value:e?f[e]:null})),{colorClasses:s,colorStyles:i}=Lb(t);return{backgroundColorClasses:s,backgroundColorStyles:i}}const VK=Ke({color:String,start:Boolean,end:Boolean,icon:Ot,...Lu(),...Vs({tag:"i"}),...Ws()},"v-icon"),dn=Ye({name:"VIcon",props:VK(),setup(f,e){let{attrs:t,slots:s}=e,i;s.default&&(i=te(()=>{var c,u;const h=(c=s.default)==null?void 0:c.call(s);if(!!h)return(u=uC(h).filter(l=>l.children&&typeof l.children=="string")[0])==null?void 0:u.children}));const{themeClasses:n}=pi(f),{iconData:r}=NK(i||f),{sizeClasses:a}=Ru(f),{textColorClasses:o,textColorStyles:d}=ca(Xe(f,"color"));return tt(()=>K(r.value.component,{tag:f.tag,icon:r.value.icon,class:["v-icon","notranslate",n.value,a.value,o.value,{"v-icon--clickable":!!t.onClick,"v-icon--start":f.start,"v-icon--end":f.end}],style:[a.value?void 0:{fontSize:We(f.size),height:We(f.size),width:We(f.size)},d.value],role:t.onClick?"button":void 0,"aria-hidden":!t.onClick},null)),{}}});function PC(f){const{t:e}=Vb();function t(s){var o;let{name:i}=s;const n={prepend:"prependAction",prependInner:"prependAction",append:"appendAction",appendInner:"appendAction",clear:"clear"}[i],r=f[`onClick:${i}`],a=r&&n?e(`$vuetify.input.${n}`,(o=f.label)!=null?o:""):void 0;return K(dn,{icon:f[`${i}Icon`],"aria-label":a,onClick:r},null)}return{InputIcon:t}}const AC=Ye({name:"VLabel",props:{text:String,clickable:Boolean,...Ws()},setup(f,e){let{slots:t}=e;return tt(()=>{var s;return K("label",{class:["v-label",{"v-label--clickable":f.clickable}]},[f.text,(s=t.default)==null?void 0:s.call(t)])}),{}}}),Ah=Ye({name:"VFieldLabel",props:{floating:Boolean},setup(f,e){let{slots:t}=e;return tt(()=>K(AC,{class:["v-field-label",{"v-field-label--floating":f.floating}],"aria-hidden":f.floating||void 0},t)),{}}});const Or=Ke({rounded:{type:[Boolean,Number,String],default:void 0}},"rounded");function Ir(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Tr();return{roundedClasses:te(()=>{const s=Xt(f)?f.value:f.rounded,i=[];if(s===!0||s==="")i.push(`${e}--rounded`);else if(typeof s=="string"||s===0)for(const n of String(s).split(" "))i.push(`rounded-${n}`);return i})}}function BC(f){const e=be(),t=be(!1);if(Cb){const s=new IntersectionObserver(i=>{f==null||f(i,s),t.value=!!i.find(n=>n.isIntersecting)});hn(()=>{s.disconnect()}),Je(e,(i,n)=>{n&&(s.unobserve(n),t.value=!1),i&&s.observe(i)},{flush:"post"})}return{intersectionRef:e,isIntersecting:t}}const qK=Ye({name:"VProgressLinear",props:{active:{type:Boolean,default:!0},bgColor:String,bgOpacity:[Number,String],bufferValue:{type:[Number,String],default:0},clickable:Boolean,color:String,height:{type:[Number,String],default:4},indeterminate:Boolean,max:{type:[Number,String],default:100},modelValue:{type:[Number,String],default:0},reverse:Boolean,stream:Boolean,striped:Boolean,roundedBar:Boolean,...Or(),...Vs(),...Ws()},emits:{"update:modelValue":f=>!0},setup(f,e){let{slots:t}=e;const s=ds(f,"modelValue"),{isRtl:i}=qu(),{themeClasses:n}=pi(f),{textColorClasses:r,textColorStyles:a}=ca(f,"color"),{backgroundColorClasses:o,backgroundColorStyles:d}=ua(te(()=>f.bgColor||f.color)),{backgroundColorClasses:c,backgroundColorStyles:u}=ua(f,"color"),{roundedClasses:h}=Ir(f),{intersectionRef:l,isIntersecting:p}=BC(),m=te(()=>parseInt(f.max,10)),g=te(()=>parseInt(f.height,10)),y=te(()=>parseFloat(f.bufferValue)/m.value*100),b=te(()=>parseFloat(s.value)/m.value*100),w=te(()=>i.value!==f.reverse),S=te(()=>f.indeterminate?"fade-transition":"slide-x-transition"),k=te(()=>f.bgOpacity==null?f.bgOpacity:parseFloat(f.bgOpacity));function T(I){if(!l.value)return;const{left:_,right:N,width:M}=l.value.getBoundingClientRect(),x=w.value?M-I.clientX+(N-M):I.clientX-_;s.value=Math.round(x/M*m.value)}return tt(()=>K(f.tag,{ref:l,class:["v-progress-linear",{"v-progress-linear--active":f.active&&p.value,"v-progress-linear--reverse":w.value,"v-progress-linear--rounded":f.rounded,"v-progress-linear--rounded-bar":f.roundedBar,"v-progress-linear--striped":f.striped},h.value,n.value],style:{height:f.active?We(g.value):0,"--v-progress-linear-height":We(g.value)},role:"progressbar","aria-hidden":f.active?"false":"true","aria-valuemin":"0","aria-valuemax":f.max,"aria-valuenow":f.indeterminate?void 0:b.value,onClick:f.clickable&&T},{default:()=>[f.stream&&K("div",{key:"stream",class:["v-progress-linear__stream",r.value],style:{...a.value,[w.value?"left":"right"]:We(-g.value),borderTop:`${We(g.value/2)} dotted`,opacity:k.value,top:`calc(50% - ${We(g.value/4)})`,width:We(100-y.value,"%"),"--v-progress-linear-stream-to":We(g.value*(w.value?1:-1))}},null),K("div",{class:["v-progress-linear__background",o.value],style:[d.value,{opacity:k.value,width:We(f.stream?y.value:100,"%")}]},null),K(Yn,{name:S.value},{default:()=>[f.indeterminate?K("div",{class:"v-progress-linear__indeterminate"},[["long","short"].map(I=>K("div",{key:I,class:["v-progress-linear__indeterminate",I,c.value],style:u.value},null))]):K("div",{class:["v-progress-linear__determinate",c.value],style:[u.value,{width:We(b.value,"%")}]},null)]}),t.default&&K("div",{class:"v-progress-linear__content"},[t.default({value:b.value,buffer:y.value})])]})),{}}}),Rb=Ke({loading:Boolean},"loader");function Fb(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Tr();return{loaderClasses:te(()=>({[`${e}--loading`]:f.loading}))}}function NC(f,e){var t;let{slots:s}=e;return K("div",{class:`${f.name}__loader`},[((t=s.default)==null?void 0:t.call(s,{color:f.color,isActive:f.active}))||K(qK,{active:f.active,color:f.color,height:"2",indeterminate:!0},null)])}const EC=Ke({focused:Boolean},"focus");function Db(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Tr();const t=ds(f,"focused"),s=te(()=>({[`${e}--focused`]:t.value}));function i(){t.value=!0}function n(){t.value=!1}return{focusClasses:s,isFocused:t,focus:i,blur:n}}const LK=["underlined","outlined","filled","solo","plain"],VC=Ke({appendInnerIcon:Ot,bgColor:String,clearable:Boolean,clearIcon:{type:Ot,default:"$clear"},active:Boolean,color:String,dirty:Boolean,disabled:Boolean,error:Boolean,label:String,persistentClear:Boolean,prependInnerIcon:Ot,reverse:Boolean,singleLine:Boolean,variant:{type:String,default:"filled",validator:f=>LK.includes(f)},"onClick:clear":co,"onClick:appendInner":co,"onClick:prependInner":co,...Ws(),...Rb()},"v-field"),qC=Pi()({name:"VField",inheritAttrs:!1,props:{id:String,...EC(),...VC()},emits:{"click:control":f=>!0,"update:focused":f=>!0,"update:modelValue":f=>!0},setup(f,e){let{attrs:t,emit:s,slots:i}=e;const{themeClasses:n}=pi(f),{loaderClasses:r}=Fb(f),{focusClasses:a,isFocused:o,focus:d,blur:c}=Db(f),{InputIcon:u}=PC(f),h=te(()=>f.dirty||f.active),l=te(()=>!f.singleLine&&!!(f.label||i.label)),p=ln(),m=te(()=>f.id||`input-${p}`),g=be(),y=be(),b=be(),{backgroundColorClasses:w,backgroundColorStyles:S}=ua(Xe(f,"bgColor")),{textColorClasses:k,textColorStyles:T}=ca(te(()=>h.value&&o.value&&!f.error&&!f.disabled?f.color:void 0));Je(h,N=>{if(l.value){const M=g.value.$el,x=y.value.$el,v=Bb(M),O=x.getBoundingClientRect(),A=O.x-v.x,V=O.y-v.y-(v.height/2-O.height/2),q=O.width/.75,R=Math.abs(q-v.width)>1?{maxWidth:We(q)}:void 0,H=getComputedStyle(M),F=getComputedStyle(x),P=parseFloat(H.transitionDuration)*1e3||150,E=parseFloat(F.getPropertyValue("--v-field-label-scale")),j=F.getPropertyValue("color");M.style.visibility="visible",x.style.visibility="hidden",rd(M,{transform:`translate(${A}px, ${V}px) scale(${E})`,color:j,...R},{duration:P,easing:il,direction:N?"normal":"reverse"}).finished.then(()=>{M.style.removeProperty("visibility"),x.style.removeProperty("visibility")})}},{flush:"post"});const I=te(()=>({isActive:h,isFocused:o,controlRef:b,blur:c,focus:d}));function _(N){N.target!==document.activeElement&&N.preventDefault(),s("click:control",N)}return tt(()=>{var N,M,x;const v=f.variant==="outlined",O=i["prepend-inner"]||f.prependInnerIcon,A=!!(f.clearable||i.clear),V=!!(i["append-inner"]||f.appendInnerIcon||A),q=i.label?i.label({label:f.label,props:{for:m.value}}):f.label;return K("div",ct({class:["v-field",{"v-field--active":h.value,"v-field--appended":V,"v-field--disabled":f.disabled,"v-field--dirty":f.dirty,"v-field--error":f.error,"v-field--has-background":!!f.bgColor,"v-field--persistent-clear":f.persistentClear,"v-field--prepended":O,"v-field--reverse":f.reverse,"v-field--single-line":f.singleLine,"v-field--no-label":!q,[`v-field--variant-${f.variant}`]:!0},n.value,w.value,a.value,r.value],style:[S.value,T.value],onClick:_},t),[K("div",{class:"v-field__overlay"},null),K(NC,{name:"v-field",active:f.loading,color:f.error?"error":f.color},{default:i.loader}),O&&K("div",{key:"prepend",class:"v-field__prepend-inner"},[f.prependInnerIcon&&K(u,{key:"prepend-icon",name:"prependInner"},null),(N=i["prepend-inner"])==null?void 0:N.call(i,I.value)]),K("div",{class:"v-field__field","data-no-activator":""},[["solo","filled"].includes(f.variant)&&l.value&&K(Ah,{key:"floating-label",ref:y,class:[k.value],floating:!0,for:m.value},{default:()=>[q]}),K(Ah,{ref:g,for:m.value},{default:()=>[q]}),(M=i.default)==null?void 0:M.call(i,{...I.value,props:{id:m.value,class:"v-field__input"},focus:d,blur:c})]),A&&K(CC,{key:"clear"},{default:()=>[Ri(K("div",{class:"v-field__clearable"},[i.clear?i.clear():K(u,{name:"clear"},null)]),[[Td,f.dirty]])]}),V&&K("div",{key:"append",class:"v-field__append-inner"},[(x=i["append-inner"])==null?void 0:x.call(i,I.value),f.appendInnerIcon&&K(u,{key:"append-icon",name:"appendInner"},null)]),K("div",{class:["v-field__outline",k.value]},[v&&K(Vt,null,[K("div",{class:"v-field__outline__start"},null),l.value&&K("div",{class:"v-field__outline__notch"},[K(Ah,{ref:y,floating:!0,for:m.value},{default:()=>[q]})]),K("div",{class:"v-field__outline__end"},null)]),["plain","underlined"].includes(f.variant)&&l.value&&K(Ah,{ref:y,floating:!0,for:m.value},{default:()=>[q]})])])}),{controlRef:b}}});function RK(f){const e=Object.keys(qC.props).filter(t=>!fC(t));return vr(f,e)}const Ed=Ke({transition:{type:[Boolean,String,Object],default:"fade-transition",validator:f=>f!==!0}},"transition"),no=(f,e)=>{let{slots:t}=e;const{transition:s,...i}=f,{component:n=Yn,...r}=typeof s=="object"?s:{};return ha(n,ct(typeof s=="string"?{name:s}:r,i),t)},FK=Ye({name:"VMessages",props:{active:Boolean,color:String,messages:{type:[Array,String],default:()=>[]},...Ed({transition:{component:_C,leaveAbsolute:!0,group:!0}})},setup(f,e){let{slots:t}=e;const s=te(()=>Xn(f.messages)),{textColorClasses:i,textColorStyles:n}=ca(te(()=>f.color));return tt(()=>K(no,{transition:f.transition,tag:"div",class:["v-messages",i.value],style:n.value},{default:()=>[f.active&&s.value.map((r,a)=>K("div",{class:"v-messages__message",key:`${a}-${s.value}`},[t.message?t.message({message:r}):r]))]})),{}}}),DK=[null,"default","comfortable","compact"],er=Ke({density:{type:String,default:"default",validator:f=>DK.includes(f)}},"density");function xr(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Tr();return{densityClasses:te(()=>`${e}--density-${f.density}`)}}const HK=Symbol.for("vuetify:form");function GK(){return Yt(HK,null)}const UK=Ke({disabled:Boolean,error:Boolean,errorMessages:{type:[Array,String],default:()=>[]},maxErrors:{type:[Number,String],default:1},name:String,label:String,readonly:Boolean,rules:{type:Array,default:()=>[]},modelValue:null,validateOn:String,validationValue:null,...EC()},"validation");function $K(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Tr(),t=arguments.length>2&&arguments[2]!==void 0?arguments[2]:ln();const s=ds(f,"modelValue"),i=te(()=>f.validationValue===void 0?s.value:f.validationValue),n=GK(),r=be([]),a=be(!0),o=te(()=>!!(Xn(s.value===""?null:s.value).length||Xn(i.value===""?null:i.value).length)),d=te(()=>!!(f.disabled||n!=null&&n.isDisabled.value)),c=te(()=>!!(f.readonly||n!=null&&n.isReadonly.value)),u=te(()=>f.errorMessages.length?Xn(f.errorMessages):r.value),h=te(()=>f.error||u.value.length?!1:f.rules.length&&a.value?null:!0),l=be(!1),p=te(()=>({[`${e}--error`]:h.value===!1,[`${e}--dirty`]:o.value,[`${e}--disabled`]:d.value,[`${e}--readonly`]:c.value})),m=te(()=>{var S;return(S=f.name)!=null?S:rn(t)});kl(()=>{n==null||n.register({id:m.value,validate:w,reset:y,resetValidation:b})}),hn(()=>{n==null||n.unregister(m.value)});const g=te(()=>f.validateOn||(n==null?void 0:n.validateOn.value)||"input");Jn(()=>n==null?void 0:n.update(m.value,h.value,u.value)),bd(()=>g.value==="input",()=>{Je(i,()=>{if(i.value!=null)w();else if(f.focused){const S=Je(()=>f.focused,k=>{k||w(),S()})}})}),bd(()=>g.value==="blur",()=>{Je(()=>f.focused,S=>{S||w()})}),Je(h,()=>{n==null||n.update(m.value,h.value,u.value)});function y(){b(),s.value=null}function b(){a.value=!0,r.value=[]}async function w(){const S=[];l.value=!0;for(const k of f.rules){if(S.length>=(f.maxErrors||1))break;const I=await(typeof k=="function"?k:()=>k)(i.value);if(I!==!0){if(typeof I!="string"){console.warn(`${I} is not a valid value. Rule functions must return boolean true or a string.`);continue}S.push(I)}}return r.value=S,l.value=!1,a.value=!1,r.value}return{errorMessages:u,isDirty:o,isDisabled:d,isReadonly:c,isPristine:a,isValid:h,isValidating:l,reset:y,resetValidation:b,validate:w,validationClasses:p}}const Hb=Ke({id:String,appendIcon:Ot,prependIcon:Ot,hideDetails:[Boolean,String],messages:{type:[Array,String],default:()=>[]},direction:{type:String,default:"horizontal",validator:f=>["horizontal","vertical"].includes(f)},"onClick:prepend":co,"onClick:append":co,...er(),...UK()},"v-input"),Gb=Pi()({name:"VInput",props:{...Hb()},emits:{"update:modelValue":f=>!0},setup(f,e){let{attrs:t,slots:s,emit:i}=e;const{densityClasses:n}=xr(f),{InputIcon:r}=PC(f),a=ln(),o=te(()=>f.id||`input-${a}`),{errorMessages:d,isDirty:c,isDisabled:u,isReadonly:h,isPristine:l,isValid:p,isValidating:m,reset:g,resetValidation:y,validate:b,validationClasses:w}=$K(f,"v-input",o),S=te(()=>({id:o,isDirty:c,isDisabled:u,isReadonly:h,isPristine:l,isValid:p,isValidating:m,reset:g,resetValidation:y,validate:b}));return tt(()=>{var k,T,I,_,N;const M=!!(s.prepend||f.prependIcon),x=!!(s.append||f.appendIcon),v=!!((k=f.messages)!=null&&k.length||d.value.length),O=!f.hideDetails||f.hideDetails==="auto"&&(v||!!s.details);return K("div",{class:["v-input",`v-input--${f.direction}`,n.value,w.value]},[M&&K("div",{key:"prepend",class:"v-input__prepend"},[(T=s.prepend)==null?void 0:T.call(s,S.value),f.prependIcon&&K(r,{key:"prepend-icon",name:"prepend"},null)]),s.default&&K("div",{class:"v-input__control"},[(I=s.default)==null?void 0:I.call(s,S.value)]),x&&K("div",{key:"append",class:"v-input__append"},[f.appendIcon&&K(r,{key:"append-icon",name:"append"},null),(_=s.append)==null?void 0:_.call(s,S.value)]),O&&K("div",{class:"v-input__details"},[K(FK,{active:v,messages:d.value.length>0?d.value:f.messages},{message:s.message}),(N=s.details)==null?void 0:N.call(s,S.value)])])}),{reset:g,resetValidation:y,validate:b}}});function LC(f){const e=Object.keys(Gb.props).filter(t=>!fC(t));return vr(f,e)}const jK=Ye({name:"VCounter",functional:!0,props:{active:Boolean,max:[Number,String],value:{type:[Number,String],default:0},...Ed({transition:{component:_C}})},setup(f,e){let{slots:t}=e;const s=te(()=>f.max?`${f.value} / ${f.max}`:String(f.value));return tt(()=>K(no,{transition:f.transition},{default:()=>[Ri(K("div",{class:"v-counter"},[t.default?t.default({counter:s.value,max:f.max,value:f.value}):s.value]),[[Td,f.active]])]})),{}}});function WK(f,e){if(!Cb)return;const t=e.modifiers||{},s=e.value,{handler:i,options:n}=typeof s=="object"?s:{handler:s,options:{}},r=new IntersectionObserver(function(){var a;let o=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[],d=arguments.length>1?arguments[1]:void 0;const c=(a=f._observe)==null?void 0:a[e.instance.$.uid];if(!c)return;const u=o.some(h=>h.isIntersecting);i&&(!t.quiet||c.init)&&(!t.once||u||c.init)&&i(u,o,d),u&&t.once?RC(f,e):c.init=!0},n);f._observe=Object(f._observe),f._observe[e.instance.$.uid]={init:!1,observer:r},r.observe(f)}function RC(f,e){var t;const s=(t=f._observe)==null?void 0:t[e.instance.$.uid];!s||(s.observer.unobserve(f),delete f._observe[e.instance.$.uid])}const zK={mounted:WK,unmounted:RC},FC=zK,Fg=Symbol("Forwarded refs");function Fu(f){for(var e=arguments.length,t=new Array(e>1?e-1:0),s=1;s<e;s++)t[s-1]=arguments[s];return f[Fg]=t,new Proxy(f,{get(i,n){if(Reflect.has(i,n))return Reflect.get(i,n);for(const r of t)if(r.value&&Reflect.has(r.value,n)){const a=Reflect.get(r.value,n);return typeof a=="function"?a.bind(r.value):a}},getOwnPropertyDescriptor(i,n){const r=Reflect.getOwnPropertyDescriptor(i,n);if(r)return r;if(!(typeof n=="symbol"||n.startsWith("__"))){for(const a of t){if(!a.value)continue;const o=Reflect.getOwnPropertyDescriptor(a.value,n);if(o)return o;if("_"in a.value&&"setupState"in a.value._){const d=Reflect.getOwnPropertyDescriptor(a.value._.setupState,n);if(d)return d}}for(const a of t){let o=a.value&&Object.getPrototypeOf(a.value);for(;o;){const d=Reflect.getOwnPropertyDescriptor(o,n);if(d)return d;o=Object.getPrototypeOf(o)}}for(const a of t){const o=a.value&&a.value[Fg];if(!o)continue;const d=o.slice();for(;d.length;){const c=d.shift(),u=Reflect.getOwnPropertyDescriptor(c.value,n);if(u)return u;const h=c.value&&c.value[Fg];h&&d.push(...h)}}}}})}const KK=["color","file","time","date","datetime-local","week","month"],Ub=Ke({autofocus:Boolean,counter:[Boolean,Number,String],counterValue:Function,hint:String,persistentHint:Boolean,prefix:String,placeholder:String,persistentPlaceholder:Boolean,persistentCounter:Boolean,suffix:String,type:{type:String,default:"text"},...Hb(),...VC()},"v-text-field"),lr=Pi()({name:"VTextField",directives:{Intersect:FC},inheritAttrs:!1,props:Ub(),emits:{"click:control":f=>!0,"click:input":f=>!0,"update:focused":f=>!0,"update:modelValue":f=>!0},setup(f,e){let{attrs:t,emit:s,slots:i}=e;const n=ds(f,"modelValue"),{isFocused:r,focus:a,blur:o}=Db(f),d=te(()=>{var k;return typeof f.counterValue=="function"?f.counterValue(n.value):((k=n.value)!=null?k:"").toString().length}),c=te(()=>{if(t.maxlength)return t.maxlength;if(!(!f.counter||typeof f.counter!="number"&&typeof f.counter!="string"))return f.counter});function u(k,T){var I,_;!f.autofocus||!k||(I=T[0].target)==null||(_=I.focus)==null||_.call(I)}const h=be(),l=be(),p=be(),m=te(()=>KK.includes(f.type)||f.persistentPlaceholder||r.value),g=te(()=>f.messages.length?f.messages:r.value||f.persistentHint?f.hint:"");function y(){if(p.value!==document.activeElement){var k;(k=p.value)==null||k.focus()}r.value||a()}function b(k){y(),s("click:control",k)}function w(k){k.stopPropagation(),y(),_i(()=>{n.value=null,Vz(f["onClick:clear"],k)})}function S(k){n.value=k.target.value}return tt(()=>{const k=!!(i.counter||f.counter||f.counterValue),T=!!(k||i.details),[I,_]=Pb(t),[{modelValue:N,...M}]=LC(f),[x]=RK(f);return K(Gb,ct({ref:h,modelValue:n.value,"onUpdate:modelValue":v=>n.value=v,class:["v-text-field",{"v-text-field--prefixed":f.prefix,"v-text-field--suffixed":f.suffix,"v-text-field--flush-details":["plain","underlined"].includes(f.variant)}],"onClick:prepend":f["onClick:prepend"],"onClick:append":f["onClick:append"]},I,M,{focused:r.value,messages:g.value}),{...i,default:v=>{let{id:O,isDisabled:A,isDirty:V,isReadonly:q,isValid:R}=v;return K(qC,ct({ref:l,onMousedown:H=>{H.target!==p.value&&H.preventDefault()},"onClick:control":b,"onClick:clear":w,"onClick:prependInner":f["onClick:prependInner"],"onClick:appendInner":f["onClick:appendInner"],role:"textbox"},x,{id:O.value,active:m.value||V.value,dirty:V.value||f.dirty,focused:r.value,error:R.value===!1}),{...i,default:H=>{let{props:{class:F,...P}}=H;const E=Ri(K("input",ct({ref:p,value:n.value,onInput:S,autofocus:f.autofocus,readonly:q.value,disabled:A.value,name:f.name,placeholder:f.placeholder,size:1,type:f.type,onFocus:y,onBlur:o},P,_),null),[[fa("intersect"),{handler:u},null,{once:!0}]]);return K(Vt,null,[f.prefix&&K("span",{class:"v-text-field__prefix"},[f.prefix]),i.default?K("div",{class:F,onClick:j=>s("click:input",j),"data-no-activator":""},[i.default(),E]):gr(E,{class:F}),f.suffix&&K("span",{class:"v-text-field__suffix"},[f.suffix])])}})},details:T?v=>{var O;return K(Vt,null,[(O=i.details)==null?void 0:O.call(i,v),k&&K(Vt,null,[K("span",null,null),K(jK,{active:f.persistentCounter||r.value,value:d.value,max:c.value},i.counter)])])}:void 0})}),Fu({},h,l,p)}});function DC(f){return vr(f,Object.keys(lr.props))}const HC=Symbol.for("vuetify:selection-control-group"),GC=Ke({color:String,disabled:Boolean,error:Boolean,id:String,inline:Boolean,falseIcon:Ot,trueIcon:Ot,ripple:{type:Boolean,default:!0},multiple:{type:Boolean,default:null},name:String,readonly:Boolean,modelValue:null,type:String,valueComparator:{type:Function,default:Ul},...Ws(),...er()},"v-selection-control-group");Ye({name:"VSelectionControlGroup",props:{defaultsTarget:{type:String,default:"VSelectionControl"},...GC()},emits:{"update:modelValue":f=>!0},setup(f,e){let{slots:t}=e;const s=ds(f,"modelValue"),i=ln(),n=te(()=>f.id||`v-selection-control-group-${i}`),r=te(()=>f.name||n.value);return Mi(HC,{modelValue:s}),la({[f.defaultsTarget]:{color:Xe(f,"color"),disabled:Xe(f,"disabled"),density:Xe(f,"density"),error:Xe(f,"error"),inline:Xe(f,"inline"),modelValue:s,multiple:te(()=>!!f.multiple||f.multiple==null&&Array.isArray(s.value)),name:r,falseIcon:Xe(f,"falseIcon"),trueIcon:Xe(f,"trueIcon"),readonly:Xe(f,"readonly"),ripple:Xe(f,"ripple"),type:Xe(f,"type"),valueComparator:Xe(f,"valueComparator")}}),tt(()=>{var a;return K("div",{class:["v-selection-control-group",{"v-selection-control-group--inline":f.inline}],"aria-labelled-by":f.type==="radio"?n.value:void 0,role:f.type==="radio"?"radiogroup":void 0},[(a=t.default)==null?void 0:a.call(t)])}),{}}});const ky=Symbol("rippleStop"),XK=80;function qO(f,e){f.style.transform=e,f.style.webkitTransform=e}function Dg(f,e){f.style.opacity=`calc(${e} * var(--v-theme-overlay-multiplier))`}function vy(f){return f.constructor.name==="TouchEvent"}function UC(f){return f.constructor.name==="KeyboardEvent"}const YK=function(f,e){var t;let s=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},i=0,n=0;if(!UC(f)){const h=e.getBoundingClientRect(),l=vy(f)?f.touches[f.touches.length-1]:f;i=l.clientX-h.left,n=l.clientY-h.top}let r=0,a=.3;(t=e._ripple)!=null&&t.circle?(a=.15,r=e.clientWidth/2,r=s.center?r:r+Math.sqrt((i-r)**2+(n-r)**2)/4):r=Math.sqrt(e.clientWidth**2+e.clientHeight**2)/2;const o=`${(e.clientWidth-r*2)/2}px`,d=`${(e.clientHeight-r*2)/2}px`,c=s.center?o:`${i-r}px`,u=s.center?d:`${n-r}px`;return{radius:r,scale:a,x:c,y:u,centerX:o,centerY:d}},dl={show(f,e){var t;let s=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};if(!(e!=null&&(t=e._ripple)!=null&&t.enabled))return;const i=document.createElement("span"),n=document.createElement("span");i.appendChild(n),i.className="v-ripple__container",s.class&&(i.className+=` ${s.class}`);const{radius:r,scale:a,x:o,y:d,centerX:c,centerY:u}=YK(f,e,s),h=`${r*2}px`;n.className="v-ripple__animation",n.style.width=h,n.style.height=h,e.appendChild(i);const l=window.getComputedStyle(e);l&&l.position==="static"&&(e.style.position="relative",e.dataset.previousPosition="static"),n.classList.add("v-ripple__animation--enter"),n.classList.add("v-ripple__animation--visible"),qO(n,`translate(${o}, ${d}) scale3d(${a},${a},${a})`),Dg(n,0),n.dataset.activated=String(performance.now()),setTimeout(()=>{n.classList.remove("v-ripple__animation--enter"),n.classList.add("v-ripple__animation--in"),qO(n,`translate(${c}, ${u}) scale3d(1,1,1)`),Dg(n,.08)},0)},hide(f){var e;if(!(f!=null&&(e=f._ripple)!=null&&e.enabled))return;const t=f.getElementsByClassName("v-ripple__animation");if(t.length===0)return;const s=t[t.length-1];if(s.dataset.isHiding)return;s.dataset.isHiding="true";const i=performance.now()-Number(s.dataset.activated),n=Math.max(250-i,0);setTimeout(()=>{s.classList.remove("v-ripple__animation--in"),s.classList.add("v-ripple__animation--out"),Dg(s,0),setTimeout(()=>{f.getElementsByClassName("v-ripple__animation").length===1&&f.dataset.previousPosition&&(f.style.position=f.dataset.previousPosition,delete f.dataset.previousPosition),s.parentNode&&f.removeChild(s.parentNode)},300)},n)}};function $C(f){return typeof f>"u"||!!f}function vu(f){const e={},t=f.currentTarget;if(!(!(t!=null&&t._ripple)||t._ripple.touched||f[ky])){if(f[ky]=!0,vy(f))t._ripple.touched=!0,t._ripple.isTouch=!0;else if(t._ripple.isTouch)return;if(e.center=t._ripple.centered||UC(f),t._ripple.class&&(e.class=t._ripple.class),vy(f)){if(t._ripple.showTimerCommit)return;t._ripple.showTimerCommit=()=>{dl.show(f,t,e)},t._ripple.showTimer=window.setTimeout(()=>{var s;t!=null&&(s=t._ripple)!=null&&s.showTimerCommit&&(t._ripple.showTimerCommit(),t._ripple.showTimerCommit=null)},XK)}else dl.show(f,t,e)}}function LO(f){f[ky]=!0}function Vi(f){const e=f.currentTarget;if(!(!e||!e._ripple)){if(window.clearTimeout(e._ripple.showTimer),f.type==="touchend"&&e._ripple.showTimerCommit){e._ripple.showTimerCommit(),e._ripple.showTimerCommit=null,e._ripple.showTimer=window.setTimeout(()=>{Vi(f)});return}window.setTimeout(()=>{e._ripple&&(e._ripple.touched=!1)}),dl.hide(e)}}function jC(f){const e=f.currentTarget;!e||!e._ripple||(e._ripple.showTimerCommit&&(e._ripple.showTimerCommit=null),window.clearTimeout(e._ripple.showTimer))}let Tu=!1;function WC(f){!Tu&&(f.keyCode===yO.enter||f.keyCode===yO.space)&&(Tu=!0,vu(f))}function zC(f){Tu=!1,Vi(f)}function KC(f){Tu&&(Tu=!1,Vi(f))}function XC(f,e,t){var r;const{value:s,modifiers:i}=e,n=$C(s);if(n||dl.hide(f),f._ripple=(r=f._ripple)!=null?r:{},f._ripple.enabled=n,f._ripple.centered=i.center,f._ripple.circle=i.circle,my(s)&&s.class&&(f._ripple.class=s.class),n&&!t){if(i.stop){f.addEventListener("touchstart",LO,{passive:!0}),f.addEventListener("mousedown",LO);return}f.addEventListener("touchstart",vu,{passive:!0}),f.addEventListener("touchend",Vi,{passive:!0}),f.addEventListener("touchmove",jC,{passive:!0}),f.addEventListener("touchcancel",Vi),f.addEventListener("mousedown",vu),f.addEventListener("mouseup",Vi),f.addEventListener("mouseleave",Vi),f.addEventListener("keydown",WC),f.addEventListener("keyup",zC),f.addEventListener("blur",KC),f.addEventListener("dragstart",Vi,{passive:!0})}else!n&&t&&YC(f)}function YC(f){f.removeEventListener("mousedown",vu),f.removeEventListener("touchstart",vu),f.removeEventListener("touchend",Vi),f.removeEventListener("touchmove",jC),f.removeEventListener("touchcancel",Vi),f.removeEventListener("mouseup",Vi),f.removeEventListener("mouseleave",Vi),f.removeEventListener("keydown",WC),f.removeEventListener("keyup",zC),f.removeEventListener("dragstart",Vi),f.removeEventListener("blur",KC)}function QK(f,e){XC(f,e,!1)}function ZK(f){delete f._ripple,YC(f)}function JK(f,e){if(e.value===e.oldValue)return;const t=$C(e.oldValue);XC(f,e,t)}const Du={mounted:QK,unmounted:ZK,updated:JK},QC=Ke({label:String,trueValue:null,falseValue:null,value:null,...GC()},"v-selection-control");function eX(f){const e=Yt(HC,void 0),{densityClasses:t}=xr(f),s=ds(f,"modelValue"),i=te(()=>f.trueValue!==void 0?f.trueValue:f.value!==void 0?f.value:!0),n=te(()=>f.falseValue!==void 0?f.falseValue:!1),r=te(()=>!!f.multiple||f.multiple==null&&Array.isArray(s.value)),a=te({get(){const u=e?e.modelValue.value:s.value;return r.value?u.some(h=>f.valueComparator(h,i.value)):f.valueComparator(u,i.value)},set(u){if(f.readonly)return;const h=u?i.value:n.value;let l=h;r.value&&(l=u?[...Xn(s.value),h]:Xn(s.value).filter(p=>!f.valueComparator(p,i.value))),e?e.modelValue.value=l:s.value=l}}),{textColorClasses:o,textColorStyles:d}=ca(te(()=>a.value&&!f.error&&!f.disabled?f.color:void 0)),c=te(()=>a.value?f.trueIcon:f.falseIcon);return{group:e,densityClasses:t,trueValue:i,falseValue:n,model:a,textColorClasses:o,textColorStyles:d,icon:c}}const tX=Pi()({name:"VSelectionControl",directives:{Ripple:Du},inheritAttrs:!1,props:QC(),emits:{"update:modelValue":f=>!0},setup(f,e){let{attrs:t,slots:s}=e;const{densityClasses:i,icon:n,model:r,textColorClasses:a,textColorStyles:o,trueValue:d}=eX(f),c=ln(),u=te(()=>f.id||`input-${c}`),h=be(!1),l=be(!1),p=be();function m(b){h.value=!0,(!ly||ly&&b.target.matches(":focus-visible"))&&(l.value=!0)}function g(){h.value=!1,l.value=!1}function y(b){r.value=b.target.checked}return tt(()=>{var b,w;const S=s.label?s.label({label:f.label,props:{for:u.value}}):f.label,[k,T]=Pb(t);return K("div",ct({class:["v-selection-control",{"v-selection-control--dirty":r.value,"v-selection-control--disabled":f.disabled,"v-selection-control--error":f.error,"v-selection-control--focused":h.value,"v-selection-control--focus-visible":l.value,"v-selection-control--inline":f.inline},i.value]},k),[K("div",{class:["v-selection-control__wrapper",a.value],style:o.value},[(b=s.default)==null?void 0:b.call(s),Ri(K("div",{class:["v-selection-control__input"]},[n.value&&K(dn,{key:"icon",icon:n.value},null),K("input",ct({ref:p,checked:r.value,disabled:f.disabled,id:u.value,onBlur:g,onFocus:m,onInput:y,"aria-readonly":f.readonly,type:f.type,value:d.value,name:f.name,"aria-checked":f.type==="checkbox"?r.value:void 0},T),null),(w=s.input)==null?void 0:w.call(s,{model:r,textColorClasses:a,textColorStyles:o,props:{onFocus:m,onBlur:g,id:u.value}})]),[[fa("ripple"),f.ripple&&[!f.disabled&&!f.readonly,null,["center","circle"]]]])]),S&&K(AC,{for:u.value,clickable:!0},{default:()=>[S]})])}),{isFocused:h,input:p}}}),ZC=Ke({indeterminate:Boolean,indeterminateIcon:{type:Ot,default:"$checkboxIndeterminate"},...QC({falseIcon:"$checkboxOff",trueIcon:"$checkboxOn"})},"v-checkbox-btn"),Wl=Ye({name:"VCheckboxBtn",props:ZC(),emits:{"update:modelValue":f=>!0,"update:indeterminate":f=>!0},setup(f,e){let{slots:t}=e;const s=ds(f,"indeterminate"),i=ds(f,"modelValue");function n(o){s.value&&(s.value=!1)}const r=te(()=>f.indeterminate?f.indeterminateIcon:f.falseIcon),a=te(()=>f.indeterminate?f.indeterminateIcon:f.trueIcon);return tt(()=>K(tX,ct(f,{modelValue:i.value,"onUpdate:modelValue":[o=>i.value=o,n],class:"v-checkbox-btn",type:"checkbox",inline:!0,falseIcon:r.value,trueIcon:a.value,"aria-checked":f.indeterminate?"mixed":void 0}),t)),{}}});function sX(f){return vr(f,Object.keys(Wl.props))}const Bh=Ye({name:"VCheckbox",inheritAttrs:!1,props:{...Hb(),...ZC()},emits:{"update:focused":f=>!0},setup(f,e){let{attrs:t,slots:s}=e;const{isFocused:i,focus:n,blur:r}=Db(f),a=ln(),o=te(()=>f.id||`checkbox-${a}`);return tt(()=>{const[d,c]=Pb(t),[u,h]=LC(f),[l,p]=sX(f);return K(Gb,ct({class:"v-checkbox"},d,u,{id:o.value,focused:i.value}),{...s,default:m=>{let{id:g,isDisabled:y,isReadonly:b}=m;return K(Wl,ct(l,{id:g.value,disabled:y.value,readonly:b.value},c,{onFocus:n,onBlur:r}),s)}})}),{}}});const Vd=Ke({height:[Number,String],maxHeight:[Number,String],maxWidth:[Number,String],minHeight:[Number,String],minWidth:[Number,String],width:[Number,String]},"dimension");function qd(f){return{dimensionStyles:te(()=>({height:We(f.height),maxHeight:We(f.maxHeight),maxWidth:We(f.maxWidth),minHeight:We(f.minHeight),minWidth:We(f.minWidth),width:We(f.width)}))}}function iX(f){return{aspectStyles:te(()=>{const e=Number(f.aspectRatio);return e?{paddingBottom:String(1/e*100)+"%"}:void 0})}}const JC=Ye({name:"VResponsive",props:{aspectRatio:[String,Number],contentClass:String,...Vd()},setup(f,e){let{slots:t}=e;const{aspectStyles:s}=iX(f),{dimensionStyles:i}=qd(f);return tt(()=>{var n;return K("div",{class:"v-responsive",style:i.value},[K("div",{class:"v-responsive__sizer",style:s.value},null),(n=t.additional)==null?void 0:n.call(t),t.default&&K("div",{class:["v-responsive__content",f.contentClass]},[t.default()])])}),{}}}),e2=Ye({name:"VImg",directives:{intersect:FC},props:{aspectRatio:[String,Number],alt:String,cover:Boolean,eager:Boolean,gradient:String,lazySrc:String,options:{type:Object,default:()=>({root:void 0,rootMargin:void 0,threshold:void 0})},sizes:String,src:{type:[String,Object],default:""},srcset:String,width:[String,Number],...Ed()},emits:{loadstart:f=>!0,load:f=>!0,error:f=>!0},setup(f,e){let{emit:t,slots:s}=e;const i=be(""),n=be(),r=be(f.eager?"loading":"idle"),a=be(),o=be(),d=te(()=>f.src&&typeof f.src=="object"?{src:f.src.src,srcset:f.srcset||f.src.srcset,lazySrc:f.lazySrc||f.src.lazySrc,aspect:Number(f.aspectRatio||f.src.aspect)}:{src:f.src,srcset:f.srcset,lazySrc:f.lazySrc,aspect:Number(f.aspectRatio||0)}),c=te(()=>d.value.aspect||a.value/o.value||0);Je(()=>f.src,()=>{u(r.value!=="idle")}),kl(()=>u());function u(I){if(!(f.eager&&I)&&!(Cb&&!I&&!f.eager)){if(r.value="loading",d.value.lazySrc){const _=new Image;_.src=d.value.lazySrc,m(_,null)}!d.value.src||_i(()=>{var _,N;if(t("loadstart",((_=n.value)==null?void 0:_.currentSrc)||d.value.src),(N=n.value)!=null&&N.complete){if(n.value.naturalWidth||l(),r.value==="error")return;c.value||m(n.value,null),h()}else c.value||m(n.value),p()})}}function h(){var I;p(),r.value="loaded",t("load",((I=n.value)==null?void 0:I.currentSrc)||d.value.src)}function l(){var I;r.value="error",t("error",((I=n.value)==null?void 0:I.currentSrc)||d.value.src)}function p(){const I=n.value;I&&(i.value=I.currentSrc||I.src)}function m(I){let _=arguments.length>1&&arguments[1]!==void 0?arguments[1]:100;const N=()=>{const{naturalHeight:M,naturalWidth:x}=I;M||x?(a.value=x,o.value=M):!I.complete&&r.value==="loading"&&_!=null?setTimeout(N,_):(I.currentSrc.endsWith(".svg")||I.currentSrc.startsWith("data:image/svg+xml"))&&(a.value=1,o.value=1)};N()}const g=te(()=>({"v-img__img--cover":f.cover,"v-img__img--contain":!f.cover})),y=()=>{var I;if(!d.value.src||r.value==="idle")return null;const _=K("img",{class:["v-img__img",g.value],src:d.value.src,srcset:d.value.srcset,alt:"",sizes:f.sizes,ref:n,onLoad:h,onError:l},null),N=(I=s.sources)==null?void 0:I.call(s);return K(no,{transition:f.transition,appear:!0},{default:()=>[Ri(N?K("picture",{class:"v-img__picture"},[N,_]):_,[[Td,r.value==="loaded"]])]})},b=()=>K(no,{transition:f.transition},{default:()=>[d.value.lazySrc&&r.value!=="loaded"&&K("img",{class:["v-img__img","v-img__img--preload",g.value],src:d.value.lazySrc,alt:""},null)]}),w=()=>s.placeholder?K(no,{transition:f.transition,appear:!0},{default:()=>[(r.value==="loading"||r.value==="error"&&!s.error)&&K("div",{class:"v-img__placeholder"},[s.placeholder()])]}):null,S=()=>s.error?K(no,{transition:f.transition,appear:!0},{default:()=>[r.value==="error"&&K("div",{class:"v-img__error"},[s.error()])]}):null,k=()=>f.gradient?K("div",{class:"v-img__gradient",style:{backgroundImage:`linear-gradient(${f.gradient})`}},null):null,T=be(!1);{const I=Je(c,_=>{_&&(requestAnimationFrame(()=>{requestAnimationFrame(()=>{T.value=!0})}),I())})}return tt(()=>Ri(K(JC,{class:["v-img",{"v-img--booting":!T.value}],style:{width:We(f.width==="auto"?a.value:f.width)},aspectRatio:c.value,"aria-label":f.alt,role:f.alt?"img":void 0},{additional:()=>K(Vt,null,[K(y,null,null),K(b,null,null),K(k,null,null),K(w,null,null),K(S,null,null)]),default:s.default}),[[fa("intersect"),{handler:u,options:f.options},null,{once:!0}]])),{currentSrc:i,image:n,state:r,naturalWidth:a,naturalHeight:o}}}),nX=["elevated","flat","tonal","outlined","text","plain"];function Hu(f,e){return K(Vt,null,[f&&K("span",{key:"overlay",class:`${e}__overlay`},null),K("span",{key:"underlay",class:`${e}__underlay`},null)])}const pa=Ke({color:String,variant:{type:String,default:"elevated",validator:f=>nX.includes(f)}},"variant");function Gu(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Tr();const t=te(()=>{const{variant:n}=rn(f);return`${e}--variant-${n}`}),{colorClasses:s,colorStyles:i}=Lb(te(()=>{const{variant:n,color:r}=rn(f);return{[["elevated","flat"].includes(n)?"background":"text"]:r}}));return{colorClasses:s,colorStyles:i,variantClasses:t}}const rX=Ke({start:Boolean,end:Boolean,icon:Ot,image:String,...er(),...Or(),...Lu(),...Vs(),...pa({variant:"flat"})},"v-avatar"),uo=Ye({name:"VAvatar",props:rX(),setup(f,e){let{slots:t}=e;const{colorClasses:s,colorStyles:i,variantClasses:n}=Gu(f),{densityClasses:r}=xr(f),{roundedClasses:a}=Ir(f),{sizeClasses:o,sizeStyles:d}=Ru(f);return tt(()=>{var c;return K(f.tag,{class:["v-avatar",{"v-avatar--start":f.start,"v-avatar--end":f.end},s.value,r.value,a.value,o.value,n.value],style:[i.value,d.value]},{default:()=>[f.image?K(e2,{key:"image",src:f.image,alt:""},null):f.icon?K(dn,{key:"icon",icon:f.icon},null):(c=t.default)==null?void 0:c.call(t),Hu(!1,"v-avatar")]})}),{}}});const t2=Ke({modelValue:{type:null,default:void 0},multiple:Boolean,mandatory:[Boolean,String],max:Number,selectedClass:String,disabled:Boolean},"group"),s2=Ke({value:null,disabled:Boolean,selectedClass:String},"group-item");function i2(f,e){let t=arguments.length>2&&arguments[2]!==void 0?arguments[2]:!0;const s=ti("useGroupItem");if(!s)throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");const i=ln();Mi(Symbol.for(`${e.description}:id`),i);const n=Yt(e,null);if(!n){if(!t)return n;throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${e.description}`)}const r=Xe(f,"value"),a=te(()=>n.disabled.value||f.disabled);n.register({id:i,value:r,disabled:a},s),hn(()=>{n.unregister(i)});const o=te(()=>n.isSelected(i)),d=te(()=>o.value&&[n.selectedClass.value,f.selectedClass]);return Je(o,c=>{s.emit("group:selected",{value:c})}),{id:i,isSelected:o,toggle:()=>n.select(i,!o.value),select:c=>n.select(i,c),selectedClass:d,value:r,disabled:a,group:n}}function n2(f,e){let t=!1;const s=Js([]),i=ds(f,"modelValue",[],h=>h==null?[]:r2(s,Xn(h)),h=>{const l=oX(s,h);return f.multiple?l:l[0]}),n=ti("useGroup");function r(h,l){const p=h,m=Symbol.for(`${e.description}:id`),y=du(m,n==null?void 0:n.vnode).indexOf(l);y>-1?s.splice(y,0,p):s.push(p)}function a(h){if(t)return;o();const l=s.findIndex(p=>p.id===h);s.splice(l,1)}function o(){const h=s.find(l=>!l.disabled);h&&f.mandatory==="force"&&!i.value.length&&(i.value=[h.id])}Jn(()=>{o()}),hn(()=>{t=!0});function d(h,l){const p=s.find(m=>m.id===h);if(!(l&&p!=null&&p.disabled))if(f.multiple){const m=i.value.slice(),g=m.findIndex(b=>b===h),y=~g;if(l=l!=null?l:!y,y&&f.mandatory&&m.length<=1||!y&&f.max!=null&&m.length+1>f.max)return;g<0&&l?m.push(h):g>=0&&!l&&m.splice(g,1),i.value=m}else{const m=i.value.includes(h);if(f.mandatory&&m)return;i.value=(l!=null?l:!m)?[h]:[]}}function c(h){if(f.multiple&&hd('This method is not supported when using "multiple" prop'),i.value.length){const l=i.value[0],p=s.findIndex(y=>y.id===l);let m=(p+h)%s.length,g=s[m];for(;g.disabled&&m!==p;)m=(m+h)%s.length,g=s[m];if(g.disabled)return;i.value=[s[m].id]}else{const l=s.find(p=>!p.disabled);l&&(i.value=[l.id])}}const u={register:r,unregister:a,selected:i,select:d,disabled:Xe(f,"disabled"),prev:()=>c(s.length-1),next:()=>c(1),isSelected:h=>i.value.includes(h),selectedClass:te(()=>f.selectedClass),items:te(()=>s),getItemIndex:h=>aX(s,h)};return Mi(e,u),u}function aX(f,e){const t=r2(f,[e]);return t.length?f.findIndex(s=>s.id===t[0]):-1}function r2(f,e){const t=[];for(let s=0;s<f.length;s++){const i=f[s];i.value!=null?e.find(n=>Ul(n,i.value))!=null&&t.push(i.id):e.includes(s)&&t.push(i.id)}return t}function oX(f,e){const t=[];for(let s=0;s<f.length;s++){const i=f[s];e.includes(i.id)&&t.push(i.value!=null?i.value:s)}return t}const a2=Symbol.for("vuetify:v-chip-group");Ye({name:"VChipGroup",props:{column:Boolean,filter:Boolean,valueComparator:{type:Function,default:Ul},...t2({selectedClass:"v-chip--selected"}),...Vs(),...Ws(),...pa({variant:"tonal"})},emits:{"update:modelValue":f=>!0},setup(f,e){let{slots:t}=e;const{themeClasses:s}=pi(f),{isSelected:i,select:n,next:r,prev:a,selected:o}=n2(f,a2);return la({VChip:{color:Xe(f,"color"),filter:Xe(f,"filter"),variant:Xe(f,"variant")}}),tt(()=>{var d;return K(f.tag,{class:["v-chip-group",{"v-chip-group--column":f.column},s.value]},{default:()=>[(d=t.default)==null?void 0:d.call(t,{isSelected:i,select:n,next:r,prev:a,selected:o.value})]})}),{}}});const js=Qy({name:"VDefaultsProvider",props:{defaults:Object,reset:[Number,String],root:Boolean,scoped:Boolean},setup(f,e){let{slots:t}=e;const{defaults:s,reset:i,root:n,scoped:r}=Wy(f);return la(s,{reset:i,root:n,scoped:r}),()=>{var a;return(a=t.default)==null?void 0:a.call(t)}}}),po=Ke({border:[Boolean,Number,String]},"border");function mo(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Tr();return{borderClasses:te(()=>{const s=Xt(f)?f.value:f.border,i=[];if(s===!0||s==="")i.push(`${e}--border`);else if(typeof s=="string"||s===0)for(const n of String(s).split(" "))i.push(`border-${n}`);return i})}}const go=Ke({elevation:{type:[Number,String],validator(f){const e=parseInt(f);return!isNaN(e)&&e>=0&&e<=24}}},"elevation");function yo(f){return{elevationClasses:te(()=>{const t=Xt(f)?f.value:f.elevation,s=[];return t==null||s.push(`elevation-${t}`),s})}}function o2(){var f,e;return(f=ti("useRouter"))==null||(e=f.proxy)==null?void 0:e.$router}function zl(f,e){const t=pP("RouterLink"),s=te(()=>!!(f.href||f.to)),i=te(()=>(s==null?void 0:s.value)||bO(e,"click")||bO(f,"click"));if(typeof t=="string")return{isLink:s,isClickable:i,href:Xe(f,"href")};const n=f.to?t.useLink(f):void 0;return{isLink:s,isClickable:i,route:n==null?void 0:n.route,navigate:n==null?void 0:n.navigate,isActive:n&&te(()=>{var r,a;return f.exact?(r=n.isExactActive)==null?void 0:r.value:(a=n.isActive)==null?void 0:a.value}),href:te(()=>f.to?n==null?void 0:n.route.value.href:f.href)}}const Kl=Ke({href:String,replace:Boolean,to:[String,Object],exact:Boolean},"router");let Hg=!1;function dX(f,e){let t=!1,s,i;os&&(_i(()=>{window.addEventListener("popstate",n),s=f==null?void 0:f.beforeEach((r,a,o)=>{Hg?t?e(o):o():setTimeout(()=>t?e(o):o()),Hg=!0}),i=f==null?void 0:f.afterEach(()=>{Hg=!1})}),Zn(()=>{var r,a;window.removeEventListener("popstate",n),(r=s)==null||r(),(a=i)==null||a()}));function n(r){var a;(a=r.state)!=null&&a.replaced||(t=!0,setTimeout(()=>t=!1))}}const d2=Ye({name:"VChip",directives:{Ripple:Du},props:{activeClass:String,appendAvatar:String,appendIcon:Ot,closable:Boolean,closeIcon:{type:Ot,default:"$delete"},closeLabel:{type:String,default:"$vuetify.close"},draggable:Boolean,filter:Boolean,filterIcon:{type:String,default:"$complete"},label:Boolean,link:Boolean,pill:Boolean,prependAvatar:String,prependIcon:Ot,ripple:{type:Boolean,default:!0},text:String,modelValue:{type:Boolean,default:!0},...po(),...er(),...go(),...s2(),...Or(),...Kl(),...Lu(),...Vs({tag:"span"}),...Ws(),...pa({variant:"tonal"})},emits:{"click:close":f=>!0,"update:modelValue":f=>!0,"group:selected":f=>!0},setup(f,e){let{attrs:t,emit:s,slots:i}=e;const{borderClasses:n}=mo(f),{colorClasses:r,colorStyles:a,variantClasses:o}=Gu(f),{densityClasses:d}=xr(f),{elevationClasses:c}=yo(f),{roundedClasses:u}=Ir(f),{sizeClasses:h}=Ru(f),{themeClasses:l}=pi(f),p=ds(f,"modelValue"),m=i2(f,a2,!1),g=zl(f,t);function y(b){p.value=!1,s("click:close",b)}return()=>{var b;const w=g.isLink.value?"a":f.tag,S=!!(i.append||f.appendIcon||f.appendAvatar),k=!!(i.close||f.closable),T=!!(i.filter||f.filter)&&m,I=!!(i.prepend||f.prependIcon||f.prependAvatar),_=!m||m.isSelected.value,N=!f.disabled&&(!!m||g.isClickable.value||f.link),M=f.link?f.link:m==null?void 0:m.toggle;return p.value&&Ri(K(w,{class:["v-chip",{"v-chip--disabled":f.disabled,"v-chip--label":f.label,"v-chip--link":N,"v-chip--filter":T,"v-chip--pill":f.pill},l.value,n.value,_?r.value:void 0,d.value,c.value,u.value,h.value,o.value,m==null?void 0:m.selectedClass.value],style:[_?a.value:void 0],disabled:f.disabled||void 0,draggable:f.draggable,href:g.href.value,onClick:N&&M},{default:()=>{var x;return[Hu(N,"v-chip"),T&&K(js,{key:"filter",defaults:{VIcon:{icon:f.filterIcon}}},{default:()=>[K(CC,null,{default:()=>[Ri(K("div",{class:"v-chip__filter"},[i.filter?i.filter():K(dn,null,null)]),[[Td,m.isSelected.value]])]})]}),I&&K(js,{key:"prepend",defaults:{VAvatar:{image:f.prependAvatar},VIcon:{icon:f.prependIcon}}},{default:()=>[i.prepend?K("div",{class:"v-chip__prepend"},[i.prepend()]):f.prependAvatar?K(uo,{start:!0},null):f.prependIcon?K(dn,{start:!0},null):void 0]}),(x=(b=i.default)==null?void 0:b.call(i,{isSelected:m==null?void 0:m.isSelected.value,selectedClass:m==null?void 0:m.selectedClass.value,select:m==null?void 0:m.select,toggle:m==null?void 0:m.toggle,value:m==null?void 0:m.value.value,disabled:f.disabled}))!=null?x:f.text,S&&K(js,{key:"append",defaults:{VAvatar:{image:f.appendAvatar},VIcon:{icon:f.appendIcon}}},{default:()=>[i.append?K("div",{class:"v-chip__append"},[i.append()]):f.appendAvatar?K(uo,{end:!0},null):f.appendIcon?K(dn,{end:!0},null):void 0]}),k&&K(js,{key:"close",defaults:{VIcon:{icon:f.closeIcon,size:"x-small"}}},{default:()=>[K("div",{class:"v-chip__close",onClick:y},[i.close?i.close():K(dn,null,null)])]})]}}),[[fa("ripple"),N&&f.ripple,null]])}}});const id=Ye({name:"VDivider",props:{color:String,inset:Boolean,length:[Number,String],thickness:[Number,String],vertical:Boolean,...Ws()},setup(f,e){let{attrs:t}=e;const{themeClasses:s}=pi(f),{backgroundColorClasses:i,backgroundColorStyles:n}=ua(Xe(f,"color")),r=te(()=>{const a={};return f.length&&(a[f.vertical?"maxHeight":"maxWidth"]=We(f.length)),f.thickness&&(a[f.vertical?"borderRightWidth":"borderTopWidth"]=We(f.thickness)),a});return tt(()=>K("hr",{class:[{"v-divider":!0,"v-divider--inset":f.inset,"v-divider--vertical":f.vertical},s.value,i.value],style:[r.value,n.value],"aria-orientation":!t.role||t.role==="separator"?f.vertical?"vertical":"horizontal":void 0,role:`${t.role||"separator"}`},null)),{}}}),Ty=Symbol.for("vuetify:list");function c2(){const f=Yt(Ty,{hasPrepend:be(!1),updateHasPrepend:()=>null}),e={hasPrepend:be(!1),updateHasPrepend:t=>{t&&(e.hasPrepend.value=t)}};return Mi(Ty,e),f}function u2(){return Yt(Ty,null)}const cX={open:f=>{let{id:e,value:t,opened:s,parents:i}=f;if(t){const n=new Set;n.add(e);let r=i.get(e);for(;r!=null;)n.add(r),r=i.get(r);return n}else return s.delete(e),s},select:()=>null},f2={open:f=>{let{id:e,value:t,opened:s,parents:i}=f;if(t){let n=i.get(e);for(s.add(e);n!=null&&n!==e;)s.add(n),n=i.get(n);return s}else s.delete(e);return s},select:()=>null},uX={open:f2.open,select:f=>{let{id:e,value:t,opened:s,parents:i}=f;if(!t)return s;const n=[];let r=i.get(e);for(;r!=null;)n.push(r),r=i.get(r);return new Set(n)}},$b=f=>{const e={select:t=>{let{id:s,value:i,selected:n}=t;if(f&&!i){const r=Array.from(n.entries()).reduce((a,o)=>{let[d,c]=o;return c==="on"?[...a,d]:a},[]);if(r.length===1&&r[0]===s)return n}return n.set(s,i?"on":"off"),n},in:(t,s,i)=>{let n=new Map;for(const r of t||[])n=e.select({id:r,value:!0,selected:new Map(n),children:s,parents:i});return n},out:t=>{const s=[];for(const[i,n]of t.entries())n==="on"&&s.push(i);return s}};return e},h2=f=>{const e=$b(f);return{select:s=>{let{selected:i,id:n,...r}=s;const a=i.has(n)?new Map([[n,i.get(n)]]):new Map;return e.select({...r,id:n,selected:a})},in:(s,i,n)=>{let r=new Map;return s!=null&&s.length&&(r=e.in(s.slice(0,1),i,n)),r},out:(s,i,n)=>e.out(s,i,n)}},fX=f=>{const e=$b(f);return{select:s=>{let{id:i,selected:n,children:r,...a}=s;return r.has(i)?n:e.select({id:i,selected:n,children:r,...a})},in:e.in,out:e.out}},hX=f=>{const e=h2(f);return{select:s=>{let{id:i,selected:n,children:r,...a}=s;return r.has(i)?n:e.select({id:i,selected:n,children:r,...a})},in:e.in,out:e.out}},lX=f=>{const e={select:t=>{let{id:s,value:i,selected:n,children:r,parents:a}=t;const o=new Map(n),d=[s];for(;d.length;){const u=d.shift();n.set(u,i?"on":"off"),r.has(u)&&d.push(...r.get(u))}let c=a.get(s);for(;c;){const u=r.get(c),h=u.every(p=>n.get(p)==="on"),l=u.every(p=>!n.has(p)||n.get(p)==="off");n.set(c,h?"on":l?"off":"indeterminate"),c=a.get(c)}return f&&!i&&Array.from(n.entries()).reduce((h,l)=>{let[p,m]=l;return m==="on"?[...h,p]:h},[]).length===0?o:n},in:(t,s,i)=>{let n=new Map;for(const r of t||[])n=e.select({id:r,value:!0,selected:new Map(n),children:s,parents:i});return n},out:(t,s)=>{const i=[];for(const[n,r]of t.entries())r==="on"&&!s.has(n)&&i.push(n);return i}};return e},Ou=Symbol.for("vuetify:nested"),l2={id:be(),root:{register:()=>null,unregister:()=>null,parents:be(new Map),children:be(new Map),open:()=>null,openOnSelect:()=>null,select:()=>null,opened:be(new Set),selected:be(new Map),selectedValues:be([])}},pX=Ke({selectStrategy:[String,Function],openStrategy:[String,Object],opened:Array,selected:Array,mandatory:Boolean},"nested"),mX=f=>{let e=!1;const t=be(new Map),s=be(new Map),i=ds(f,"opened",f.opened,u=>new Set(u),u=>[...u.values()]),n=te(()=>{if(typeof f.selectStrategy=="object")return f.selectStrategy;switch(f.selectStrategy){case"single-leaf":return hX(f.mandatory);case"leaf":return fX(f.mandatory);case"independent":return $b(f.mandatory);case"single-independent":return h2(f.mandatory);case"classic":default:return lX(f.mandatory)}}),r=te(()=>{if(typeof f.openStrategy=="object")return f.openStrategy;switch(f.openStrategy){case"list":return uX;case"single":return cX;case"multiple":default:return f2}}),a=ds(f,"selected",f.selected,u=>n.value.in(u,t.value,s.value),u=>n.value.out(u,t.value,s.value));hn(()=>{e=!0});function o(u){const h=[];let l=u;for(;l!=null;)h.unshift(l),l=s.value.get(l);return h}const d=ti("nested"),c={id:be(),root:{opened:i,selected:a,selectedValues:te(()=>{const u=[];for(const[h,l]of a.value.entries())l==="on"&&u.push(h);return u}),register:(u,h,l)=>{h&&u!==h&&s.value.set(u,h),l&&t.value.set(u,[]),h!=null&&t.value.set(h,[...t.value.get(h)||[],u])},unregister:u=>{var l;if(e)return;t.value.delete(u);const h=s.value.get(u);if(h){const p=(l=t.value.get(h))!=null?l:[];t.value.set(h,p.filter(m=>m!==u))}s.value.delete(u),i.value.delete(u)},open:(u,h,l)=>{d.emit("click:open",{id:u,value:h,path:o(u),event:l});const p=r.value.open({id:u,value:h,opened:new Set(i.value),children:t.value,parents:s.value,event:l});p&&(i.value=p)},openOnSelect:(u,h,l)=>{const p=r.value.select({id:u,value:h,selected:new Map(a.value),opened:new Set(i.value),children:t.value,parents:s.value,event:l});p&&(i.value=p)},select:(u,h,l)=>{d.emit("click:select",{id:u,value:h,path:o(u),event:l});const p=n.value.select({id:u,value:h,selected:new Map(a.value),children:t.value,parents:s.value,event:l});p&&(a.value=p),c.root.openOnSelect(u,h,l)},children:t,parents:s}};return Mi(Ou,c),c.root},p2=(f,e)=>{const t=Yt(Ou,l2),s=te(()=>{var n;return(n=f.value)!=null?n:Symbol(ln())}),i={...t,id:s,open:(n,r)=>t.root.open(s.value,n,r),openOnSelect:(n,r)=>t.root.openOnSelect(s.value,n,r),isOpen:te(()=>t.root.opened.value.has(s.value)),parent:te(()=>t.root.parents.value.get(s.value)),select:(n,r)=>t.root.select(s.value,n,r),isSelected:te(()=>t.root.selected.value.get(s.value)==="on"),isIndeterminate:te(()=>t.root.selected.value.get(s.value)==="indeterminate"),isLeaf:te(()=>!t.root.children.value.get(s.value)),isGroupActivator:t.isGroupActivator};return!t.isGroupActivator&&t.root.register(s.value,t.id.value,e),hn(()=>{!t.isGroupActivator&&t.root.unregister(s.value)}),e&&Mi(Ou,i),i},gX=()=>{const f=Yt(Ou,l2);Mi(Ou,{...f,isGroupActivator:!0})},yX=Ye({name:"VListGroupActivator",setup(f,e){let{slots:t}=e;return gX(),()=>{var s;return(s=t.default)==null?void 0:s.call(t)}}}),bX=Ke({activeColor:String,color:String,collapseIcon:{type:Ot,default:"$collapse"},expandIcon:{type:Ot,default:"$expand"},prependIcon:Ot,appendIcon:Ot,fluid:Boolean,subgroup:Boolean,value:null,...Vs()},"v-list-group"),m2=Pi()({name:"VListGroup",props:{title:String,...bX()},setup(f,e){let{slots:t}=e;const{isOpen:s,open:i,id:n}=p2(Xe(f,"value"),!0),r=te(()=>`v-list-group--id-${String(n.value)}`),a=u2();function o(u){i(!s.value,u)}const d=te(()=>({onClick:o,class:"v-list-group__header",id:r.value})),c=te(()=>s.value?f.collapseIcon:f.expandIcon);return tt(()=>{var u;return K(f.tag,{class:["v-list-group",{"v-list-group--prepend":a==null?void 0:a.hasPrepend.value,"v-list-group--fluid":f.fluid,"v-list-group--subgroup":f.subgroup}]},{default:()=>[t.activator&&K(js,{defaults:{VListItem:{active:s.value,activeColor:f.activeColor,color:f.color,prependIcon:f.prependIcon||f.subgroup&&c.value,appendIcon:f.appendIcon||!f.subgroup&&c.value,title:f.title,value:f.value}}},{default:()=>[K(yX,null,{default:()=>[t.activator({props:d.value,isOpen:s})]})]}),K(xK,null,{default:()=>[Ri(K("div",{class:"v-list-group__items",role:"group","aria-labelledby":r.value},[(u=t.default)==null?void 0:u.call(t)]),[[Td,s.value]])]})]})}),{}}});function wX(f){return vr(f,Object.keys(m2.props))}const SX=Vu("v-list-item-subtitle"),kX=Vu("v-list-item-title"),wd=Pi()({name:"VListItem",directives:{Ripple:Du},props:{active:{type:Boolean,default:void 0},activeClass:String,activeColor:String,appendAvatar:String,appendIcon:Ot,disabled:Boolean,lines:String,link:{type:Boolean,default:void 0},nav:Boolean,prependAvatar:String,prependIcon:Ot,subtitle:[String,Number,Boolean],title:[String,Number,Boolean],value:null,onClick:co,onClickOnce:co,...po(),...er(),...Vd(),...go(),...Or(),...Kl(),...Vs(),...Ws(),...pa({variant:"text"})},emits:{click:f=>!0},setup(f,e){let{attrs:t,slots:s,emit:i}=e;const n=zl(f,t),r=te(()=>{var R;return(R=f.value)!=null?R:n.href.value}),{select:a,isSelected:o,isIndeterminate:d,isGroupActivator:c,root:u,parent:h,openOnSelect:l}=p2(r,!1),p=u2(),m=te(()=>{var R;return f.active!==!1&&(f.active||((R=n.isActive)==null?void 0:R.value)||o.value)}),g=te(()=>f.link!==!1&&n.isLink.value),y=te(()=>!f.disabled&&f.link!==!1&&(f.link||n.isClickable.value||f.value!=null&&!!p)),b=te(()=>f.rounded||f.nav),w=te(()=>{var R;return{color:m.value&&(R=f.activeColor)!=null?R:f.color,variant:f.variant}});Je(()=>{var R;return(R=n.isActive)==null?void 0:R.value},R=>{R&&h.value!=null&&u.open(h.value,!0),R&&l(R)},{immediate:!0});const{themeClasses:S}=pi(f),{borderClasses:k}=mo(f),{colorClasses:T,colorStyles:I,variantClasses:_}=Gu(w),{densityClasses:N}=xr(f),{dimensionStyles:M}=qd(f),{elevationClasses:x}=yo(f),{roundedClasses:v}=Ir(b),O=te(()=>f.lines?`v-list-item--${f.lines}-line`:void 0),A=te(()=>({isActive:m.value,select:a,isSelected:o.value,isIndeterminate:d.value}));function V(R){var H;i("click",R),!(c||!y.value)&&((H=n.navigate)==null||H.call(n,R),f.value!=null&&a(!o.value,R))}function q(R){(R.key==="Enter"||R.key===" ")&&(R.preventDefault(),V(R))}return tt(()=>{var R,H,F,P,E;const j=g.value?"a":f.tag,X=!p||o.value||m.value,Q=s.title||f.title,Se=s.subtitle||f.subtitle,he=!!(s.append||f.appendAvatar||f.appendIcon),xe=!!(s.prepend||f.prependAvatar||f.prependIcon);return p==null||p.updateHasPrepend(xe),Ri(K(j,{class:["v-list-item",{"v-list-item--active":m.value,"v-list-item--disabled":f.disabled,"v-list-item--link":y.value,"v-list-item--nav":f.nav,"v-list-item--prepend":!xe&&(p==null?void 0:p.hasPrepend.value),[`${f.activeClass}`]:f.activeClass&&m.value},S.value,k.value,X?T.value:void 0,N.value,x.value,O.value,v.value,_.value],style:[X?I.value:void 0,M.value],href:n.href.value,tabindex:y.value?0:void 0,onClick:V,onKeydown:y.value&&!g.value&&q},{default:()=>[Hu(y.value||m.value,"v-list-item"),xe&&K(js,{key:"prepend",defaults:{VAvatar:{density:f.density,image:f.prependAvatar},VIcon:{density:f.density,icon:f.prependIcon},VListItemAction:{start:!0}}},{default:()=>[K("div",{class:"v-list-item__prepend"},[f.prependAvatar&&K(uo,{key:"prepend-avatar"},null),f.prependIcon&&K(dn,{key:"prepend-icon"},null),(R=s.prepend)==null?void 0:R.call(s,A.value)])]}),K("div",{class:"v-list-item__content"},[Q&&K(kX,{key:"title"},{default:()=>{var Ae;return[(Ae=(H=s.title)==null?void 0:H.call(s,{title:f.title}))!=null?Ae:f.title]}}),Se&&K(SX,{key:"subtitle"},{default:()=>{var Ae;return[(Ae=(F=s.subtitle)==null?void 0:F.call(s,{subtitle:f.subtitle}))!=null?Ae:f.subtitle]}}),(P=s.default)==null?void 0:P.call(s,A.value)]),he&&K(js,{key:"append",defaults:{VAvatar:{density:f.density,image:f.appendAvatar},VIcon:{density:f.density,icon:f.appendIcon},VListItemAction:{end:!0}}},{default:()=>[K("div",{class:"v-list-item__append"},[(E=s.append)==null?void 0:E.call(s,A.value),f.appendIcon&&K(dn,{key:"append-icon"},null),f.appendAvatar&&K(uo,{key:"append-avatar"},null)])]})]}),[[fa("ripple"),y.value]])}),{}}}),vX=Ye({name:"VListSubheader",props:{color:String,inset:Boolean,sticky:Boolean,title:String,...Vs()},setup(f,e){let{slots:t}=e;const{textColorClasses:s,textColorStyles:i}=ca(Xe(f,"color"));return tt(()=>{var n;const r=!!(t.default||f.title);return K(f.tag,{class:["v-list-subheader",{"v-list-subheader--inset":f.inset,"v-list-subheader--sticky":f.sticky},s.value],style:{textColorStyles:i}},{default:()=>{var a;return[r&&K("div",{class:"v-list-subheader__text"},[(a=(n=t.default)==null?void 0:n.call(t))!=null?a:f.title])]}})}),{}}}),g2=Pi()({name:"VListChildren",props:{items:Array},setup(f,e){let{slots:t}=e;return c2(),()=>{var n;var s,i;return(n=(s=t.default)==null?void 0:s.call(t))!=null?n:(i=f.items)==null?void 0:i.map(r=>{var g,y;let{children:a,props:o,type:d,raw:c}=r;if(d==="divider"){var u;return(g=(u=t.divider)==null?void 0:u.call(t,{props:o}))!=null?g:K(id,o,null)}if(d==="subheader"){var h;return(y=(h=t.subheader)==null?void 0:h.call(t,{props:o}))!=null?y:K(vX,o,{default:t.subheader})}const l={subtitle:t.subtitle?b=>{var w;return(w=t.subtitle)==null?void 0:w.call(t,{...b,item:c})}:void 0,prepend:t.prepend?b=>{var w;return(w=t.prepend)==null?void 0:w.call(t,{...b,item:c})}:void 0,append:t.append?b=>{var w;return(w=t.append)==null?void 0:w.call(t,{...b,item:c})}:void 0,default:t.default?b=>{var w;return(w=t.default)==null?void 0:w.call(t,{...b,item:c})}:void 0,title:t.title?b=>{var w;return(w=t.title)==null?void 0:w.call(t,{...b,item:c})}:void 0},[p,m]=wX(o);return a?K(m2,ct({value:o==null?void 0:o.value},p),{activator:b=>{let{props:w}=b;return t.header?t.header({...o,...w}):K(wd,ct(o,w),l)},default:()=>K(g2,{items:a},t)}):t.item?t.item(o):K(wd,o,l)})}}}),y2=Ke({items:{type:Array,default:()=>[]},itemTitle:{type:[String,Array,Function],default:"title"},itemValue:{type:[String,Array,Function],default:"value"},itemChildren:{type:[Boolean,String,Array,Function],default:"children"},itemProps:{type:[Boolean,String,Array,Function],default:"props"},returnObject:Boolean},"item");function b2(f,e){var a;const t=Kn(e,f.itemTitle,e),s=f.returnObject?e:Kn(e,f.itemValue,t),i=Kn(e,f.itemChildren),n=f.itemProps===!0?typeof e=="object"&&e!=null&&!Array.isArray(e)?"children"in e?vr(e,["children"])[1]:e:void 0:Kn(e,f.itemProps),r={title:t,value:s,...n};return{title:String((a=r.title)!=null?a:""),value:r.value,props:r,children:Array.isArray(i)?w2(f,i):void 0,raw:e}}function w2(f,e){const t=[];for(const s of e)t.push(b2(f,s));return t}function S2(f){const e=te(()=>w2(f,f.items));function t(i){return i.map(n=>b2(f,n))}function s(i){return i.map(n=>{let{props:r}=n;return r.value})}return{items:e,transformIn:t,transformOut:s}}function TX(f,e){const t=Kn(e,f.itemType,"item"),s=typeof e=="string"?e:Kn(e,f.itemTitle),i=Kn(e,f.itemValue,void 0),n=Kn(e,f.itemChildren),r=f.itemProps===!0?vr(e,["children"])[1]:Kn(e,f.itemProps),a={title:s,value:i,...r};return{type:t,title:a.title,value:a.value,props:a,children:t==="item"&&n?k2(f,n):void 0,raw:e}}function k2(f,e){const t=[];for(const s of e)t.push(TX(f,s));return t}function OX(f){return{items:te(()=>k2(f,f.items))}}const v2=Pi()({name:"VList",props:{activeColor:String,activeClass:String,bgColor:String,disabled:Boolean,lines:{type:[Boolean,String],default:"one"},nav:Boolean,...pX({selectStrategy:"single-leaf",openStrategy:"list"}),...po(),...er(),...Vd(),...go(),itemType:{type:String,default:"type"},...y2(),...Or(),...Vs(),...Ws(),...pa({variant:"text"})},emits:{"update:selected":f=>!0,"update:opened":f=>!0,"click:open":f=>!0,"click:select":f=>!0},setup(f,e){let{slots:t}=e;const{items:s}=OX(f),{themeClasses:i}=pi(f),{backgroundColorClasses:n,backgroundColorStyles:r}=ua(Xe(f,"bgColor")),{borderClasses:a}=mo(f),{densityClasses:o}=xr(f),{dimensionStyles:d}=qd(f),{elevationClasses:c}=yo(f),{roundedClasses:u}=Ir(f),{open:h,select:l}=mX(f),p=te(()=>f.lines?`v-list--${f.lines}-line`:void 0),m=Xe(f,"activeColor"),g=Xe(f,"color");c2(),la({VListGroup:{activeColor:m,color:g},VListItem:{activeClass:Xe(f,"activeClass"),activeColor:m,color:g,density:Xe(f,"density"),disabled:Xe(f,"disabled"),lines:Xe(f,"lines"),nav:Xe(f,"nav"),variant:Xe(f,"variant")}});const y=be(!1),b=be();function w(_){y.value=!0}function S(_){y.value=!1}function k(_){var N;!y.value&&!(_.relatedTarget&&(N=b.value)!=null&&N.contains(_.relatedTarget))&&I()}function T(_){if(!!b.value){if(_.key==="ArrowDown")I("next");else if(_.key==="ArrowUp")I("prev");else if(_.key==="Home")I("first");else if(_.key==="End")I("last");else return;_.preventDefault()}}function I(_){if(!b.value)return;const N=[...b.value.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])')].filter(A=>!A.hasAttribute("disabled")),M=N.indexOf(document.activeElement);if(_)if(_==="first"){var v;(v=N[0])==null||v.focus()}else if(_==="last"){var O;(O=N.at(-1))==null||O.focus()}else{let A,V=M;const q=_==="next"?1:-1;do V+=q,A=N[V];while((!A||A.offsetParent==null)&&V<N.length&&V>=0);A?A.focus():I(_==="next"?"first":"last")}else{var x;(x=N[0])==null||x.focus()}}return tt(()=>K(f.tag,{ref:b,class:["v-list",{"v-list--disabled":f.disabled,"v-list--nav":f.nav},i.value,n.value,a.value,o.value,c.value,p.value,u.value],style:[r.value,d.value],role:"listbox","aria-activedescendant":void 0,onFocusin:w,onFocusout:S,onFocus:k,onKeydown:T},{default:()=>[K(g2,{items:s.value},t)]})),{open:h,select:l,focus:I}}});const IX=Ke({closeDelay:[Number,String],openDelay:[Number,String]},"delay");function xX(f,e){const t={},s=i=>()=>{if(!os)return Promise.resolve(!0);const n=i==="openDelay";return t.closeDelay&&window.clearTimeout(t.closeDelay),delete t.closeDelay,t.openDelay&&window.clearTimeout(t.openDelay),delete t.openDelay,new Promise(r=>{var o;const a=parseInt((o=f[i])!=null?o:0,10);t[i]=window.setTimeout(()=>{e==null||e(n),r(n)},a)})};return{runCloseDelay:s("closeDelay"),runOpenDelay:s("openDelay")}}const Oy=Symbol.for("vuetify:v-menu"),_X=Ke({activator:[String,Object],activatorProps:{type:Object,default:()=>({})},openOnClick:{type:Boolean,default:void 0},openOnHover:Boolean,openOnFocus:{type:Boolean,default:void 0},closeOnContentClick:Boolean,...IX()},"v-overlay-activator");function CX(f,e){let{isActive:t,isTop:s}=e;const i=be();let n=!1,r=!1,a=!0;const o=te(()=>f.openOnFocus||f.openOnFocus==null&&f.openOnHover),d=te(()=>f.openOnClick||f.openOnClick==null&&!f.openOnHover&&!o.value),{runOpenDelay:c,runCloseDelay:u}=xX(f,w=>{w===(f.openOnHover&&n||o.value&&r)&&!(f.openOnHover&&t.value&&!s.value)&&(t.value!==w&&(a=!0),t.value=w)}),h={click:w=>{w.stopPropagation(),i.value=w.currentTarget||w.target,t.value=!t.value},mouseenter:w=>{n=!0,i.value=w.currentTarget||w.target,c()},mouseleave:w=>{n=!1,u()},focus:w=>{ly&&!w.target.matches(":focus-visible")||(r=!0,w.stopPropagation(),i.value=w.currentTarget||w.target,c())},blur:w=>{r=!1,w.stopPropagation(),u()}},l=te(()=>{const w={};return d.value&&(w.click=h.click),f.openOnHover&&(w.mouseenter=h.mouseenter,w.mouseleave=h.mouseleave),o.value&&(w.focus=h.focus,w.blur=h.blur),w}),p=te(()=>{const w={};if(f.openOnHover&&(w.mouseenter=()=>{n=!0,c()},w.mouseleave=()=>{n=!1,u()}),f.closeOnContentClick){const S=Yt(Oy,null);w.click=()=>{t.value=!1,S==null||S.closeParents()}}return w}),m=te(()=>{const w={};return f.openOnHover&&(w.mouseenter=()=>{a&&(n=!0,a=!1,c())},w.mouseleave=()=>{n=!1,u()}),w});Je(s,w=>{w&&(f.openOnHover&&!n&&(!o.value||!r)||o.value&&!r&&(!f.openOnHover||!n))&&(t.value=!1)});const g=be();wr(()=>{!g.value||_i(()=>{const w=g.value;i.value=Bz(w)?w.$el:w})});const y=ti("useActivator");let b;return Je(()=>!!f.activator,w=>{w&&os?(b=ml(),b.run(()=>{MX(f,y,{activatorEl:i,activatorEvents:l})})):b&&b.stop()},{flush:"post",immediate:!0}),Zn(()=>{var w;(w=b)==null||w.stop()}),{activatorEl:i,activatorRef:g,activatorEvents:l,contentEvents:p,scrimEvents:m}}function MX(f,e,t){let{activatorEl:s,activatorEvents:i}=t;Je(()=>f.activator,(o,d)=>{if(d&&o!==d){const c=a(d);c&&r(c)}o&&_i(()=>n())},{immediate:!0}),Je(()=>f.activatorProps,()=>{n()}),Zn(()=>{r()});function n(){let o=arguments.length>0&&arguments[0]!==void 0?arguments[0]:a(),d=arguments.length>1&&arguments[1]!==void 0?arguments[1]:f.activatorProps;!o||(Object.entries(i.value).forEach(c=>{let[u,h]=c;o.addEventListener(u,h)}),Object.keys(d).forEach(c=>{d[c]==null?o.removeAttribute(c):o.setAttribute(c,d[c])}))}function r(){let o=arguments.length>0&&arguments[0]!==void 0?arguments[0]:a(),d=arguments.length>1&&arguments[1]!==void 0?arguments[1]:f.activatorProps;!o||(Object.entries(i.value).forEach(c=>{let[u,h]=c;o.removeEventListener(u,h)}),Object.keys(d).forEach(c=>{o.removeAttribute(c)}))}function a(){var o;let d=arguments.length>0&&arguments[0]!==void 0?arguments[0]:f.activator,c;if(d)if(d==="parent"){var u,h;let l=e==null||(u=e.proxy)==null||(h=u.$el)==null?void 0:h.parentNode;for(;l.hasAttribute("data-no-activator");)l=l.parentNode;c=l}else typeof d=="string"?c=document.querySelector(d):"$el"in d?c=d.$el:c=d;return s.value=((o=c)==null?void 0:o.nodeType)===Node.ELEMENT_NODE?c:null,s.value}}const PX=Ke({eager:Boolean},"lazy");function AX(f,e){const t=be(!1),s=te(()=>t.value||f.eager||e.value);Je(e,()=>t.value=!0);function i(){f.eager||(t.value=!1)}return{isBooted:t,hasContent:s,onAfterLeave:i}}function Gg(f,e){return{x:f.x+e.x,y:f.y+e.y}}function BX(f,e){return{x:f.x-e.x,y:f.y-e.y}}function RO(f,e){if(f.side==="top"||f.side==="bottom"){const{side:t,align:s}=f,i=s==="left"?0:s==="center"?e.width/2:s==="right"?e.width:s,n=t==="top"?0:t==="bottom"?e.height:t;return Gg({x:i,y:n},e)}else if(f.side==="left"||f.side==="right"){const{side:t,align:s}=f,i=t==="left"?0:t==="right"?e.width:t,n=s==="top"?0:s==="center"?e.height/2:s==="bottom"?e.height:s;return Gg({x:i,y:n},e)}return Gg({x:e.width/2,y:e.height/2},e)}const T2={static:VX,connected:LX},NX=Ke({locationStrategy:{type:[String,Function],default:"static",validator:f=>typeof f=="function"||f in T2},location:{type:String,default:"bottom"},origin:{type:String,default:"auto"},offset:[Number,String,Array]},"v-overlay-location-strategies");function EX(f,e){const t=be({}),s=be();let i;wr(async()=>{var r;(r=i)==null||r.stop(),s.value=void 0,os&&e.isActive.value&&f.locationStrategy&&(i=ml(),await _i(),i.run(()=>{if(typeof f.locationStrategy=="function"){var a;s.value=(a=f.locationStrategy(e,f,t))==null?void 0:a.updateLocation}else{var o;s.value=(o=T2[f.locationStrategy](e,f,t))==null?void 0:o.updateLocation}}))}),os&&window.addEventListener("resize",n,{passive:!0}),Zn(()=>{var r;os&&window.removeEventListener("resize",n),s.value=void 0,(r=i)==null||r.stop()});function n(r){var a;(a=s.value)==null||a.call(s,r)}return{contentStyles:t,updateLocation:s}}function VX(){}function qX(f){const e=Bb(f);return e.x-=parseFloat(f.style.left||0),e.y-=parseFloat(f.style.top||0),e}function LX(f,e,t){const s=sK(f.activatorEl.value);s&&Object.assign(t.value,{position:"fixed"});const{preferredAnchor:i,preferredOrigin:n}=Ab(()=>{const p=yy(e.location,f.isRtl.value),m=e.origin==="overlap"?p:e.origin==="auto"?Vg(p):yy(e.origin,f.isRtl.value);return p.side===m.side&&p.align===qg(m).align?{preferredAnchor:wO(p),preferredOrigin:wO(m)}:{preferredAnchor:p,preferredOrigin:m}}),[r,a,o,d]=["minWidth","minHeight","maxWidth","maxHeight"].map(p=>te(()=>{const m=parseFloat(e[p]);return isNaN(m)?1/0:m})),c=te(()=>{if(Array.isArray(e.offset))return e.offset;if(typeof e.offset=="string"){const p=e.offset.split(" ").map(parseFloat);return p.length<2&&p.push(0),p}return typeof e.offset=="number"?[e.offset,0]:[0,0]});let u=!1;const h=new ResizeObserver(()=>{u&&l()});Je([f.activatorEl,f.contentEl],(p,m)=>{let[g,y]=p,[b,w]=m;b&&h.unobserve(b),g&&h.observe(g),w&&h.unobserve(w),y&&h.observe(y)},{immediate:!0}),Zn(()=>{h.disconnect()});function l(){if(u=!1,requestAnimationFrame(()=>{requestAnimationFrame(()=>u=!0)}),!f.activatorEl.value||!f.contentEl.value)return;const p=f.activatorEl.value.getBoundingClientRect(),m=qX(f.contentEl.value),g=nl(f.contentEl.value),y=12;g.length||(g.push(document.documentElement),f.contentEl.value.style.top&&f.contentEl.value.style.left||(m.x+=parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-x")||0),m.y+=parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-y")||0)));const b=g.reduce((x,v)=>{const O=v.getBoundingClientRect(),A=new fd({x:v===document.documentElement?0:O.x,y:v===document.documentElement?0:O.y,width:v.clientWidth,height:v.clientHeight});return x?new fd({x:Math.max(x.left,A.left),y:Math.max(x.top,A.top),width:Math.min(x.right,A.right)-Math.max(x.left,A.left),height:Math.min(x.bottom,A.bottom)-Math.max(x.top,A.top)}):A},void 0);b.x+=y,b.y+=y,b.width-=y*2,b.height-=y*2;let w={anchor:i.value,origin:n.value};function S(x){const v=new fd(m),O=RO(x.anchor,p),A=RO(x.origin,v);let{x:V,y:q}=BX(O,A);switch(x.anchor.side){case"top":q-=c.value[0];break;case"bottom":q+=c.value[0];break;case"left":V-=c.value[0];break;case"right":V+=c.value[0];break}switch(x.anchor.align){case"top":q-=c.value[1];break;case"bottom":q+=c.value[1];break;case"left":V-=c.value[1];break;case"right":V+=c.value[1];break}return v.x+=V,v.y+=q,v.width=Math.min(v.width,o.value),v.height=Math.min(v.height,d.value),{overflows:kO(v,b),x:V,y:q}}let k=0,T=0;const I={x:0,y:0},_={x:!1,y:!1};let N=-1;for(;;){if(N++>10){wy("Infinite loop detected in connectedLocationStrategy");break}const{x,y:v,overflows:O}=S(w);k+=x,T+=v,m.x+=x,m.y+=v;{const A=SO(w.anchor),V=O.x.before||O.x.after,q=O.y.before||O.y.after;let R=!1;if(["x","y"].forEach(H=>{if(H==="x"&&V&&!_.x||H==="y"&&q&&!_.y){const F={anchor:{...w.anchor},origin:{...w.origin}},P=H==="x"?A==="y"?qg:Vg:A==="y"?Vg:qg;F.anchor=P(F.anchor),F.origin=P(F.origin);const{overflows:E}=S(F);(E[H].before<=O[H].before&&E[H].after<=O[H].after||E[H].before+E[H].after<(O[H].before+O[H].after)/2)&&(w=F,R=_[H]=!0)}}),R)continue}O.x.before&&(k+=O.x.before,m.x+=O.x.before),O.x.after&&(k-=O.x.after,m.x-=O.x.after),O.y.before&&(T+=O.y.before,m.y+=O.y.before),O.y.after&&(T-=O.y.after,m.y-=O.y.after);{const A=kO(m,b);I.x=b.width-A.x.before-A.x.after,I.y=b.height-A.y.before-A.y.after,k+=A.x.before,m.x+=A.x.before,T+=A.y.before,m.y+=A.y.before}break}const M=SO(w.anchor);Object.assign(t.value,{"--v-overlay-anchor-origin":`${w.anchor.side} ${w.anchor.align}`,transformOrigin:`${w.origin.side} ${w.origin.align}`,top:We(FO(T)),left:We(FO(k)),minWidth:We(M==="y"?Math.min(r.value,p.width):r.value),maxWidth:We(DO(gy(I.x,r.value===1/0?0:r.value,o.value))),maxHeight:We(DO(gy(I.y,a.value===1/0?0:a.value,d.value)))})}return Je(()=>[i.value,n.value,e.offset,e.minWidth,e.minHeight,e.maxWidth,e.maxHeight],()=>l(),{immediate:!s}),s&&_i(()=>l()),requestAnimationFrame(()=>{t.value.maxHeight&&l()}),{updateLocation:l}}function FO(f){return Math.round(f*devicePixelRatio)/devicePixelRatio}function DO(f){return Math.ceil(f*devicePixelRatio)/devicePixelRatio}let Iy=!0;const cl=[];function RX(f){!Iy||cl.length?(cl.push(f),xy()):(Iy=!1,f(),xy())}let HO=-1;function xy(){cancelAnimationFrame(HO),HO=requestAnimationFrame(()=>{const f=cl.shift();f&&f(),cl.length?xy():Iy=!0})}const _y={none:null,close:HX,block:GX,reposition:UX},FX=Ke({scrollStrategy:{type:[String,Function],default:"block",validator:f=>typeof f=="function"||f in _y}},"v-overlay-scroll-strategies");function DX(f,e){if(!os)return;let t;wr(async()=>{var s;(s=t)==null||s.stop(),e.isActive.value&&f.scrollStrategy&&(t=ml(),await _i(),t.run(()=>{if(typeof f.scrollStrategy=="function")f.scrollStrategy(e,f);else{var i;(i=_y[f.scrollStrategy])==null||i.call(_y,e,f)}}))}),Zn(()=>{var s;(s=t)==null||s.stop()})}function HX(f){var t;function e(s){f.isActive.value=!1}O2((t=f.activatorEl.value)!=null?t:f.contentEl.value,e)}function GX(f,e){var t;const s=(t=f.root.value)==null?void 0:t.offsetParent,i=[...new Set([...nl(f.activatorEl.value,e.contained?s:void 0),...nl(f.contentEl.value,e.contained?s:void 0)])].filter(a=>!a.classList.contains("v-overlay-scroll-blocked")),n=window.innerWidth-document.documentElement.offsetWidth,r=(a=>Eb(a)&&a)(s||document.documentElement);r&&f.root.value.classList.add("v-overlay--scroll-blocked"),i.forEach((a,o)=>{a.style.setProperty("--v-body-scroll-x",We(-a.scrollLeft)),a.style.setProperty("--v-body-scroll-y",We(-a.scrollTop)),a.style.setProperty("--v-scrollbar-offset",We(n)),a.classList.add("v-overlay-scroll-blocked")}),Zn(()=>{i.forEach((a,o)=>{const d=parseFloat(a.style.getPropertyValue("--v-body-scroll-x")),c=parseFloat(a.style.getPropertyValue("--v-body-scroll-y"));a.style.removeProperty("--v-body-scroll-x"),a.style.removeProperty("--v-body-scroll-y"),a.style.removeProperty("--v-scrollbar-offset"),a.classList.remove("v-overlay-scroll-blocked"),a.scrollLeft=-d,a.scrollTop=-c}),r&&f.root.value.classList.remove("v-overlay--scroll-blocked")})}function UX(f){var i;let e=!1,t=-1;function s(n){RX(()=>{var r,a;const o=performance.now();(r=(a=f.updateLocation).value)==null||r.call(a,n),e=(performance.now()-o)/(1e3/60)>2})}O2((i=f.activatorEl.value)!=null?i:f.contentEl.value,n=>{e?(cancelAnimationFrame(t),t=requestAnimationFrame(()=>{t=requestAnimationFrame(()=>{s(n)})})):s(n)})}function O2(f,e){const t=[document,...nl(f)];t.forEach(s=>{s.addEventListener("scroll",e,{passive:!0})}),Zn(()=>{t.forEach(s=>{s.removeEventListener("scroll",e)})})}function $X(){var f,e,t;if(!os)return be(!1);const s=ti("useHydration"),i=s==null||(f=s.root)==null||(e=f.appContext)==null||(t=e.app)==null?void 0:t._container,n=be(!!(i!=null&&i.__vue_app__));return n.value||Jn(()=>n.value=!0),n}const GO=Symbol.for("vuetify:stack"),Yc=Js([]);function jX(f,e){const t=ti("useStack"),s=Yt(GO,void 0),i=Js({activeChildren:new Set});Mi(GO,i);const n=be(+e.value);bd(f,()=>{var o;const d=(o=Yc.at(-1))==null?void 0:o[1];n.value=d?d+10:+e.value,Yc.push([t.uid,n.value]),s==null||s.activeChildren.add(t.uid),Zn(()=>{const c=Yc.findIndex(u=>u[0]===t.uid);Yc.splice(c,1),s==null||s.activeChildren.delete(t.uid)})});const r=be(!0);wr(()=>{var o;const d=((o=Yc.at(-1))==null?void 0:o[0])===t.uid;setTimeout(()=>r.value=d)});const a=te(()=>!i.activeChildren.size);return{globalTop:Iu(r),localTop:a,stackStyles:te(()=>({zIndex:n.value}))}}function cu(f){return{teleportTarget:te(()=>{const t=f.value;if(t===!0||!os)return;const s=t===!1?document.body:typeof t=="string"?document.querySelector(t):t;if(s!=null){if(!cu.cache.has(s)){const i=document.createElement("div");i.className="v-overlay-container",s.appendChild(i),cu.cache.set(s,i)}return cu.cache.get(s)}})}}cu.cache=new WeakMap;function WX(){return!0}function I2(f,e,t){if(!f||x2(f,t)===!1)return!1;const s=SC(e);if(typeof ShadowRoot<"u"&&s instanceof ShadowRoot&&s.host===f.target)return!1;const i=(typeof t.value=="object"&&t.value.include||(()=>[]))();return i.push(e),!i.some(n=>n==null?void 0:n.contains(f.target))}function x2(f,e){return(typeof e.value=="object"&&e.value.closeConditional||WX)(f)}function zX(f,e,t){const s=typeof t.value=="function"?t.value:t.value.handler;e._clickOutside.lastMousedownWasOutside&&I2(f,e,t)&&setTimeout(()=>{x2(f,t)&&s&&s(f)},0)}function UO(f,e){const t=SC(f);e(document),typeof ShadowRoot<"u"&&t instanceof ShadowRoot&&e(t)}const KX={mounted(f,e){const t=i=>zX(i,f,e),s=i=>{f._clickOutside.lastMousedownWasOutside=I2(i,f,e)};UO(f,i=>{i.addEventListener("click",t,!0),i.addEventListener("mousedown",s,!0)}),f._clickOutside||(f._clickOutside={lastMousedownWasOutside:!0}),f._clickOutside[e.instance.$.uid]={onClick:t,onMousedown:s}},unmounted(f,e){!f._clickOutside||(UO(f,t=>{var s;if(!t||!((s=f._clickOutside)!=null&&s[e.instance.$.uid]))return;const{onClick:i,onMousedown:n}=f._clickOutside[e.instance.$.uid];t.removeEventListener("click",i,!0),t.removeEventListener("mousedown",n,!0)}),delete f._clickOutside[e.instance.$.uid])}};function XX(f){const{modelValue:e,color:t,...s}=f;return K(Yn,{name:"fade-transition",appear:!0},{default:()=>[f.modelValue&&K("div",ct({class:["v-overlay__scrim",f.color.backgroundColorClasses.value],style:f.color.backgroundColorStyles.value},s),null)]})}const jb=Ke({absolute:Boolean,attach:[Boolean,String,Object],closeOnBack:{type:Boolean,default:!0},contained:Boolean,contentClass:null,contentProps:null,disabled:Boolean,noClickAnimation:Boolean,modelValue:Boolean,persistent:Boolean,scrim:{type:[String,Boolean],default:!0},zIndex:{type:[Number,String],default:2e3},..._X(),...Vd(),...PX(),...NX(),...FX(),...Ws(),...Ed()},"v-overlay"),Wb=Pi()({name:"VOverlay",directives:{ClickOutside:KX},inheritAttrs:!1,props:jb(),emits:{"click:outside":f=>!0,"update:modelValue":f=>!0,afterLeave:()=>!0},setup(f,e){let{slots:t,attrs:s,emit:i}=e;const n=ds(f,"modelValue"),r=te({get:()=>n.value,set:H=>{H&&f.disabled||(n.value=H)}}),{teleportTarget:a}=cu(te(()=>f.attach||f.contained)),{themeClasses:o}=pi(f),{rtlClasses:d,isRtl:c}=qu(),{hasContent:u,onAfterLeave:h}=AX(f,r),l=ua(te(()=>typeof f.scrim=="string"?f.scrim:null)),{globalTop:p,localTop:m,stackStyles:g}=jX(r,Xe(f,"zIndex")),{activatorEl:y,activatorRef:b,activatorEvents:w,contentEvents:S,scrimEvents:k}=CX(f,{isActive:r,isTop:m}),{dimensionStyles:T}=qd(f),I=$X();Je(()=>f.disabled,H=>{H&&(r.value=!1)});const _=be(),N=be(),{contentStyles:M,updateLocation:x}=EX(f,{isRtl:c,contentEl:N,activatorEl:y,isActive:r});DX(f,{root:_,contentEl:N,activatorEl:y,isActive:r,updateLocation:x});function v(H){i("click:outside",H),f.persistent?R():r.value=!1}function O(){return r.value&&p.value}os&&Je(r,H=>{H?window.addEventListener("keydown",A):window.removeEventListener("keydown",A)},{immediate:!0});function A(H){H.key==="Escape"&&p.value&&(f.persistent?R():r.value=!1)}const V=o2();bd(()=>f.closeOnBack,()=>{dX(V,H=>{p.value&&r.value?(H(!1),f.persistent?R():r.value=!1):H()})});const q=be();Je(()=>r.value&&(f.absolute||f.contained)&&a.value==null,H=>{if(H){const F=tK(_.value);F&&F!==document.scrollingElement&&(q.value=F.scrollTop)}});function R(){f.noClickAnimation||N.value&&rd(N.value,[{transformOrigin:"center"},{transform:"scale(1.03)"},{transformOrigin:"center"}],{duration:150,easing:il})}return tt(()=>{var H,F;return K(Vt,null,[(H=t.activator)==null?void 0:H.call(t,{isActive:r.value,props:ct({ref:b},wp(w.value),f.activatorProps)}),I.value&&K(VP,{disabled:!a.value,to:a.value},{default:()=>[u.value&&K("div",ct({class:["v-overlay",{"v-overlay--absolute":f.absolute||f.contained,"v-overlay--active":r.value,"v-overlay--contained":f.contained},o.value,d.value],style:[g.value,{top:We(q.value)}],ref:_},s),[K(XX,ct({color:l,modelValue:r.value&&!!f.scrim},wp(k.value)),null),K(no,{appear:!0,persisted:!0,transition:f.transition,target:y.value,onAfterLeave:()=>{h(),i("afterLeave")}},{default:()=>[Ri(K("div",ct({ref:N,class:["v-overlay__content",f.contentClass],style:[T.value,M.value]},wp(S.value),f.contentProps),[(F=t.default)==null?void 0:F.call(t,{isActive:r})]),[[Td,r.value],[fa("click-outside"),{handler:v,closeConditional:O,include:()=>[y.value]}]])]})])]})])}),{activatorEl:y,animateClick:R,contentEl:N,globalTop:p,localTop:m,updateLocation:x}}});function _2(f){return vr(f,Object.keys(Wb.props))}function C2(){const e=ti("useScopeId").vnode.scopeId;return{scopeId:e?{[e]:""}:void 0}}const M2=Pi()({name:"VMenu",props:{id:String,...Mb(jb({closeDelay:250,closeOnContentClick:!0,locationStrategy:"connected",openDelay:300,scrim:!1,scrollStrategy:"reposition",transition:{component:qb}}),["absolute"])},emits:{"update:modelValue":f=>!0},setup(f,e){let{slots:t}=e;const s=ds(f,"modelValue"),{scopeId:i}=C2(),n=ln(),r=te(()=>f.id||`v-menu-${n}`),a=be(),o=Yt(Oy,null);let d=0;Mi(Oy,{register(){++d},unregister(){--d},closeParents(){setTimeout(()=>{d||(s.value=!1,o==null||o.closeParents())},40)}}),Je(s,u=>{u?o==null||o.register():o==null||o.unregister()});function c(){o==null||o.closeParents()}return tt(()=>{const[u]=_2(f);return K(Wb,ct({ref:a,class:["v-menu"]},u,{modelValue:s.value,"onUpdate:modelValue":h=>s.value=h,absolute:!0,activatorProps:ct({"aria-haspopup":"menu","aria-expanded":String(s.value),"aria-owns":r.value},f.activatorProps),"onClick:outside":c},i),{activator:t.activator,default:function(){for(var h,l=arguments.length,p=new Array(l),m=0;m<l;m++)p[m]=arguments[m];return K(js,{root:!0},{default:()=>[(h=t.default)==null?void 0:h.call(t,...p)]})}})}),Fu({id:r},a)}}),P2=Ke({chips:Boolean,closableChips:Boolean,eager:Boolean,hideNoData:Boolean,hideSelected:Boolean,menu:Boolean,menuIcon:{type:Ot,default:"$dropdown"},menuProps:{type:Object},multiple:Boolean,noDataText:{type:String,default:"$vuetify.noDataText"},openOnClear:Boolean,...y2({itemChildren:!1})},"v-select");Pi()({name:"VSelect",props:{...P2(),...Mb(Ub({modelValue:null}),["validationValue","dirty","appendInnerIcon"]),...Ed({transition:{component:qb}})},emits:{"update:modelValue":f=>!0,"update:menu":f=>!0},setup(f,e){let{slots:t}=e;const{t:s}=Vb(),i=be(),n=ds(f,"menu"),{items:r,transformIn:a,transformOut:o}=S2(f),d=ds(f,"modelValue",[],w=>a(Xn(w)),w=>{var k;const S=o(w);return f.multiple?S:(k=S[0])!=null?k:null}),c=te(()=>d.value.map(w=>r.value.find(S=>S.value===w.value)||w)),u=te(()=>c.value.map(w=>w.props.value)),h=be();function l(w){d.value=[],f.openOnClear&&(n.value=!0)}function p(){f.hideNoData&&!r.value.length||f.readonly||(n.value=!n.value)}function m(w){if(!f.readonly){if(["Enter","ArrowDown"," "].includes(w.key)&&(w.preventDefault(),n.value=!0),["Escape","Tab"].includes(w.key)&&(n.value=!1),w.key==="ArrowDown"){var S;(S=h.value)==null||S.focus("next")}else if(w.key==="ArrowUp"){var k;w.preventDefault(),(k=h.value)==null||k.focus("prev")}else if(w.key==="Home"){var T;w.preventDefault(),(T=h.value)==null||T.focus("first")}else if(w.key==="End"){var I;w.preventDefault(),(I=h.value)==null||I.focus("last")}}}function g(w){if(f.multiple){const S=u.value.findIndex(k=>k===w.value);if(S===-1)d.value=[...d.value,w];else{const k=[...d.value];k.splice(S,1),d.value=k}}else d.value=[w],n.value=!1}function y(w){var S;(S=h.value)!=null&&S.$el.contains(w.relatedTarget)||(n.value=!1)}function b(w){if(w.relatedTarget==null){var S;(S=i.value)==null||S.focus()}}return tt(()=>{const w=!!(f.chips||t.chip),[S]=DC(f);return K(lr,ct({ref:i},S,{modelValue:d.value.map(k=>k.props.value).join(", "),"onUpdate:modelValue":k=>{k==null&&(d.value=[])},validationValue:d.externalValue,dirty:d.value.length>0,class:["v-select",{"v-select--active-menu":n.value,"v-select--chips":!!f.chips,[`v-select--${f.multiple?"multiple":"single"}`]:!0,"v-select--selected":d.value.length}],appendInnerIcon:f.menuIcon,readonly:!0,"onClick:clear":l,"onClick:control":p,onBlur:y,onKeydown:m}),{...t,default:()=>{var k,T,I;return K(Vt,null,[K(M2,ct({modelValue:n.value,"onUpdate:modelValue":_=>n.value=_,activator:"parent",contentClass:"v-select__content",eager:f.eager,openOnClick:!1,closeOnContentClick:!1,transition:f.transition},f.menuProps),{default:()=>[K(v2,{ref:h,selected:u.value,selectStrategy:f.multiple?"independent":"single-independent",onMousedown:_=>_.preventDefault(),onFocusout:b},{default:()=>{var _;return[!r.value.length&&!f.hideNoData&&((_=(k=t["no-data"])==null?void 0:k.call(t))!=null?_:K(wd,{title:s(f.noDataText)},null)),(T=t["prepend-item"])==null?void 0:T.call(t),r.value.map((N,M)=>{var v;var x;return(v=(x=t.item)==null?void 0:x.call(t,{item:N,index:M,props:ct(N.props,{onClick:()=>g(N)})}))!=null?v:K(wd,ct({key:M},N.props,{onClick:()=>g(N)}),{prepend:O=>{let{isSelected:A}=O;return f.multiple&&!f.hideSelected?K(Wl,{modelValue:A,ripple:!1},null):void 0}})}),(I=t["append-item"])==null?void 0:I.call(t)]}})]}),c.value.map((_,N)=>{function M(v){v.stopPropagation(),v.preventDefault(),g(_)}const x={"onClick:close":M,modelValue:!0,"onUpdate:modelValue":void 0};return K("div",{key:_.value,class:"v-select__selection"},[w?K(js,{defaults:{VChip:{closable:f.closableChips,size:"small",text:_.title}}},{default:()=>[t.chip?t.chip({item:_,index:N,props:x}):K(d2,x,null)]}):t.selection?t.selection({item:_,index:N}):K("span",{class:"v-select__selection-text"},[_.title,f.multiple&&N<c.value.length-1&&K("span",{class:"v-select__selection-comma"},[ht(",")])])])})])}})}),Fu({menu:n,select:g},i)}});const YX=(f,e,t)=>f==null||e==null?-1:f.toString().toLocaleLowerCase().indexOf(e.toString().toLocaleLowerCase()),QX=Ke({customFilter:Function,customKeyFilter:Object,filterKeys:[Array,String],filterMode:{type:String,default:"intersection"},noFilter:Boolean},"filter");function ZX(f,e,t){var o,d;const s=[],i=(o=t==null?void 0:t.default)!=null?o:YX,n=t!=null&&t.filterKeys?Xn(t.filterKeys):!1,r=Object.keys((d=t==null?void 0:t.customKeyFilter)!=null?d:{}).length;if(!(f!=null&&f.length))return s;e:for(let c=0;c<f.length;c++){const u=f[c],h={},l={};let p=-1;if(e&&!(t!=null&&t.noFilter)){if(typeof u=="object"){const y=n||Object.keys(u);for(const b of y){var a;const w=Kn(u,b,u),S=t==null||(a=t.customKeyFilter)==null?void 0:a[b];if(p=S?S(w,e,u):i(w,e,u),p!==-1&&p!==!1)S?h[b]=p:l[b]=p;else if((t==null?void 0:t.filterMode)==="every")continue e}}else p=i(u,e,u),p!==-1&&p!==!1&&(l.title=p);const m=Object.keys(l).length,g=Object.keys(h).length;if(!m&&!g||(t==null?void 0:t.filterMode)==="union"&&g!==r&&!m||(t==null?void 0:t.filterMode)==="intersection"&&(g!==r||!m))continue}s.push({index:c,matches:{...l,...h}})}return s}function JX(f,e,t){const s=te(()=>typeof(t==null?void 0:t.value)!="string"&&typeof(t==null?void 0:t.value)!="number"?"":String(t.value));return{filteredItems:te(()=>{const n=rn(e);return ZX(n,s.value,{customKeyFilter:f.customKeyFilter,default:f.customFilter,filterKeys:f.filterKeys,filterMode:f.filterMode,noFilter:f.noFilter}).map(a=>{let{index:o,matches:d}=a;return{item:n[o],matches:d}})})}}function eY(f,e,t){if(Array.isArray(e))throw new Error("Multiple matches is not implemented");return typeof e=="number"&&~e?K(Vt,null,[K("span",{class:"v-autocomplete__unmask"},[f.substr(0,e)]),K("span",{class:"v-autocomplete__mask"},[f.substr(e,t)]),K("span",{class:"v-autocomplete__unmask"},[f.substr(e+t)])]):f}const tY=Pi()({name:"VAutocomplete",props:{search:String,...QX({filterKeys:["title"]}),...P2(),...Mb(Ub({modelValue:null}),["validationValue","dirty","appendInnerIcon"]),...Ed({transition:!1})},emits:{"update:search":f=>!0,"update:modelValue":f=>!0,"update:menu":f=>!0},setup(f,e){let{slots:t}=e;const{t:s}=Vb(),i=be(),n=be(!1),r=be(!0),a=ds(f,"menu"),{items:o,transformIn:d,transformOut:c}=S2(f),u=ds(f,"search",""),h=ds(f,"modelValue",[],M=>d(Xn(M)),M=>{var v;const x=c(M);return f.multiple?x:(v=x[0])!=null?v:null}),{filteredItems:l}=JX(f,o,te(()=>r.value?void 0:u.value)),p=te(()=>h.value.map(M=>o.value.find(x=>x.value===M.value)||M)),m=te(()=>p.value.map(M=>M.props.value)),g=be();function y(M){h.value=[],f.openOnClear&&(a.value=!0),u.value=""}function b(){f.hideNoData&&!o.value.length||f.readonly||(a.value=!0)}function w(M){if(!f.readonly){if(["Enter","ArrowDown"].includes(M.key)&&(a.value=!0),["Escape"].includes(M.key)&&(a.value=!1),["Enter","Escape","Tab"].includes(M.key)&&(r.value=!0),M.key==="ArrowDown"){var x;M.preventDefault(),(x=g.value)==null||x.focus("next")}else if(M.key==="ArrowUp"){var v;M.preventDefault(),(v=g.value)==null||v.focus("prev")}}}function S(M){u.value=M.target.value}function k(){n.value&&(r.value=!0)}function T(M){n.value=!0}function I(M){if(M.relatedTarget==null){var x;(x=i.value)==null||x.focus()}}const _=be(!1);function N(M){if(f.multiple){const x=m.value.findIndex(v=>v===M.value);if(x===-1)h.value=[...h.value,M],u.value="";else{const v=[...h.value];v.splice(x,1),h.value=v}}else h.value=[M],_.value=!0,t.selection||(u.value=M.title),a.value=!1,r.value=!0,_i(()=>_.value=!1)}return Je(n,M=>{var v;if(M){var x;_.value=!0,u.value=f.multiple||!!t.selection?"":String((v=(x=p.value.at(-1))==null?void 0:x.props.title)!=null?v:""),r.value=!0,_i(()=>_.value=!1)}else a.value=!1,u.value=""}),Je(u,M=>{!n.value||_.value||(M&&(a.value=!0),r.value=!M)}),tt(()=>{const M=!!(f.chips||t.chip),[x]=DC(f);return K(lr,ct({ref:i},x,{modelValue:u.value,"onUpdate:modelValue":v=>{v==null&&(h.value=[])},validationValue:h.externalValue,dirty:h.value.length>0,onInput:S,class:["v-autocomplete",{"v-autocomplete--active-menu":a.value,"v-autocomplete--chips":!!f.chips,[`v-autocomplete--${f.multiple?"multiple":"single"}`]:!0,"v-autocomplete--selection-slot":!!t.selection}],appendInnerIcon:f.menuIcon,readonly:f.readonly,"onClick:clear":y,"onClick:control":b,"onClick:input":b,onFocus:()=>n.value=!0,onBlur:()=>n.value=!1,onKeydown:w}),{...t,default:()=>{var v,O,A;return K(Vt,null,[K(M2,ct({modelValue:a.value,"onUpdate:modelValue":V=>a.value=V,activator:"parent",contentClass:"v-autocomplete__content",eager:f.eager,openOnClick:!1,closeOnContentClick:!1,transition:f.transition,onAfterLeave:k},f.menuProps),{default:()=>[K(v2,{ref:g,selected:m.value,selectStrategy:f.multiple?"independent":"single-independent",onMousedown:V=>V.preventDefault(),onFocusin:T,onFocusout:I},{default:()=>{var V;return[!l.value.length&&!f.hideNoData&&((V=(v=t["no-data"])==null?void 0:v.call(t))!=null?V:K(wd,{title:s(f.noDataText)},null)),(O=t["prepend-item"])==null?void 0:O.call(t),l.value.map((q,R)=>{var E;var H;let{item:F,matches:P}=q;return(E=(H=t.item)==null?void 0:H.call(t,{item:F,index:R,props:ct(F.props,{onClick:()=>N(F)})}))!=null?E:K(wd,ct({key:R},F.props,{onClick:()=>N(F)}),{prepend:j=>{let{isSelected:X}=j;return f.multiple&&!f.hideSelected?K(Wl,{modelValue:X,ripple:!1},null):void 0},title:()=>{var X;var j;return r.value?F.title:eY(F.title,P.title,(X=(j=u.value)==null?void 0:j.length)!=null?X:0)}})}),(A=t["append-item"])==null?void 0:A.call(t)]}})]}),p.value.map((V,q)=>{function R(F){F.stopPropagation(),F.preventDefault(),N(V)}const H={"onClick:close":R,modelValue:!0,"onUpdate:modelValue":void 0};return K("div",{key:V.value,class:"v-autocomplete__selection"},[M?K(js,{defaults:{VChip:{closable:f.closableChips,size:"small",text:V.title}}},{default:()=>[t.chip?t.chip({item:V,index:q,props:H}):K(d2,H,null)]}):t.selection?t.selection({item:V,index:q}):K("span",{class:"v-autocomplete__selection-text"},[V.title,f.multiple&&q<p.value.length-1&&K("span",{class:"v-autocomplete__selection-comma"},[ht(",")])])])})])}})}),Fu({isFocused:n,isPristine:r,menu:a,search:u,filteredItems:l,select:N},i)}});const sY=Ye({name:"VBtnGroup",props:{divided:Boolean,...po(),...er(),...go(),...Or(),...Vs(),...Ws(),...pa()},setup(f,e){let{slots:t}=e;const{themeClasses:s}=pi(f),{densityClasses:i}=xr(f),{borderClasses:n}=mo(f),{elevationClasses:r}=yo(f),{roundedClasses:a}=Ir(f);la({VBtn:{height:"auto",color:Xe(f,"color"),density:Xe(f,"density"),flat:!0,variant:Xe(f,"variant")}}),tt(()=>K(f.tag,{class:["v-btn-group",{"v-btn-group--divided":f.divided},s.value,n.value,i.value,r.value,a.value]},t))}}),A2=Symbol.for("vuetify:v-btn-toggle");Pi()({name:"VBtnToggle",props:t2(),emits:{"update:modelValue":f=>!0},setup(f,e){let{slots:t}=e;const{isSelected:s,next:i,prev:n,select:r,selected:a}=n2(f,A2);return tt(()=>{var o;return K(sY,{class:"v-btn-toggle"},{default:()=>[(o=t.default)==null?void 0:o.call(t,{isSelected:s,next:i,prev:n,select:r,selected:a})]})}),{next:i,prev:n,select:r}}});const iY=Ye({name:"VProgressCircular",props:{bgColor:String,color:String,indeterminate:[Boolean,String],modelValue:{type:[Number,String],default:0},rotate:{type:[Number,String],default:0},width:{type:[Number,String],default:4},...Lu(),...Vs({tag:"div"}),...Ws()},setup(f,e){let{slots:t}=e;const s=20,i=2*Math.PI*s,n=be(),{themeClasses:r}=pi(f),{sizeClasses:a,sizeStyles:o}=Ru(f),{textColorClasses:d,textColorStyles:c}=ca(Xe(f,"color")),{textColorClasses:u,textColorStyles:h}=ca(Xe(f,"bgColor")),{intersectionRef:l,isIntersecting:p}=BC(),{resizeRef:m,contentRect:g}=oC(),y=te(()=>Math.max(0,Math.min(100,parseFloat(f.modelValue)))),b=te(()=>Number(f.width)),w=te(()=>o.value?Number(f.size):g.value?g.value.width:Math.max(b.value,32)),S=te(()=>s/(1-b.value/w.value)*2),k=te(()=>b.value/w.value*S.value),T=te(()=>We((100-y.value)/100*i));return wr(()=>{l.value=n.value,m.value=n.value}),tt(()=>K(f.tag,{ref:n,class:["v-progress-circular",{"v-progress-circular--indeterminate":!!f.indeterminate,"v-progress-circular--visible":p.value,"v-progress-circular--disable-shrink":f.indeterminate==="disable-shrink"},r.value,a.value,d.value],style:[o.value,c.value],role:"progressbar","aria-valuemin":"0","aria-valuemax":"100","aria-valuenow":f.indeterminate?void 0:y.value},{default:()=>[K("svg",{style:{transform:`rotate(calc(-90deg + ${Number(f.rotate)}deg))`},xmlns:"http://www.w3.org/2000/svg",viewBox:`0 0 ${S.value} ${S.value}`},[K("circle",{class:["v-progress-circular__underlay",u.value],style:h.value,fill:"transparent",cx:"50%",cy:"50%",r:s,"stroke-width":k.value,"stroke-dasharray":i,"stroke-dashoffset":0},null),K("circle",{class:"v-progress-circular__overlay",fill:"transparent",cx:"50%",cy:"50%",r:s,"stroke-width":k.value,"stroke-dasharray":i,"stroke-dashoffset":T.value},null)]),t.default&&K("div",{class:"v-progress-circular__content"},[t.default({value:y.value})])]})),{}}}),$O={center:"center",top:"bottom",bottom:"top",left:"right",right:"left"},B2=Ke({location:String},"location");function N2(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1,t=arguments.length>2?arguments[2]:void 0;const{isRtl:s}=qu();return{locationStyles:te(()=>{if(!f.location)return{};const{side:n,align:r}=yy(f.location.split(" ").length>1?f.location:`${f.location} center`,s.value);function a(d){return t?t(d):0}const o={};return n!=="center"&&(e?o[$O[n]]=`calc(100% - ${a(n)}px)`:o[n]=0),r!=="center"?e?o[$O[r]]=`calc(100% - ${a(r)}px)`:o[r]=0:(n==="center"?o.top=o.left="50%":o[{top:"left",bottom:"left",left:"top",right:"top"}[n]]="50%",o.transform={top:"translateX(-50%)",bottom:"translateX(-50%)",left:"translateY(-50%)",right:"translateY(-50%)",center:"translate(-50%, -50%)"}[n]),o})}}const nY=["static","relative","fixed","absolute","sticky"],E2=Ke({position:{type:String,validator:f=>nY.includes(f)}},"position");function V2(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Tr();return{positionClasses:te(()=>f.position?`${e}--${f.position}`:void 0)}}function rY(f,e){Je(()=>{var t;return(t=f.isActive)==null?void 0:t.value},t=>{f.isLink.value&&t&&e&&_i(()=>{e(!0)})},{immediate:!0})}const _t=Ye({name:"VBtn",directives:{Ripple:Du},props:{active:{type:Boolean,default:void 0},symbol:{type:null,default:A2},flat:Boolean,icon:[Boolean,String,Function,Object],prependIcon:Ot,appendIcon:Ot,block:Boolean,stacked:Boolean,ripple:{type:Boolean,default:!0},...po(),...Or(),...er(),...Vd(),...go(),...s2(),...Rb(),...B2(),...E2(),...Kl(),...Lu(),...Vs({tag:"button"}),...Ws(),...pa({variant:"elevated"})},emits:{"group:selected":f=>!0},setup(f,e){let{attrs:t,slots:s}=e;const{themeClasses:i}=pi(f),{borderClasses:n}=mo(f),{colorClasses:r,colorStyles:a,variantClasses:o}=Gu(f),{densityClasses:d}=xr(f),{dimensionStyles:c}=qd(f),{elevationClasses:u}=yo(f),{loaderClasses:h}=Fb(f),{locationStyles:l}=N2(f),{positionClasses:p}=V2(f),{roundedClasses:m}=Ir(f),{sizeClasses:g,sizeStyles:y}=Ru(f),b=i2(f,f.symbol,!1),w=zl(f,t),S=te(()=>{var I;return f.active!==!1&&(f.active||((I=w.isActive)==null?void 0:I.value)||(b==null?void 0:b.isSelected.value))}),k=te(()=>(b==null?void 0:b.disabled.value)||f.disabled),T=te(()=>f.variant==="elevated"&&!(f.disabled||f.flat||f.border));return rY(w,b==null?void 0:b.select),tt(()=>{var I,_,N,M;const x=w.isLink.value?"a":f.tag,v=!b||b.isSelected.value,O=!!(f.prependIcon||s.prepend),A=!!(f.appendIcon||s.append),V=!!(f.icon&&f.icon!==!0);return Ri(K(x,{type:x==="a"?void 0:"button",class:["v-btn",b==null?void 0:b.selectedClass.value,{"v-btn--active":S.value,"v-btn--block":f.block,"v-btn--disabled":k.value,"v-btn--elevated":T.value,"v-btn--flat":f.flat,"v-btn--icon":!!f.icon,"v-btn--loading":f.loading,"v-btn--stacked":f.stacked},i.value,n.value,v?r.value:void 0,d.value,u.value,h.value,p.value,m.value,g.value,o.value],style:[v?a.value:void 0,c.value,l.value,y.value],disabled:k.value||void 0,href:w.href.value,onClick:q=>{var R;k.value||((R=w.navigate)==null||R.call(w,q),b==null||b.toggle())}},{default:()=>{var q;return[Hu(!0,"v-btn"),!f.icon&&O&&K(js,{key:"prepend",defaults:{VIcon:{icon:f.prependIcon}}},{default:()=>{var R;return[K("span",{class:"v-btn__prepend"},[(R=(I=s.prepend)==null?void 0:I.call(s))!=null?R:K(dn,null,null)])]}}),K("span",{class:"v-btn__content","data-no-activator":""},[K(js,{key:"content",defaults:{VIcon:{icon:V?f.icon:void 0}}},{default:()=>{var R;return[(R=(_=s.default)==null?void 0:_.call(s))!=null?R:V&&K(dn,{key:"icon"},null)]}})]),!f.icon&&A&&K(js,{key:"append",defaults:{VIcon:{icon:f.appendIcon}}},{default:()=>{var R;return[K("span",{class:"v-btn__append"},[(R=(N=s.append)==null?void 0:N.call(s))!=null?R:K(dn,null,null)])]}}),!!f.loading&&K("span",{key:"loader",class:"v-btn__loader"},[(q=(M=s.loader)==null?void 0:M.call(s))!=null?q:K(iY,{color:typeof f.loading=="boolean"?void 0:f.loading,indeterminate:!0,size:"23",width:"2"},null)])]}}),[[fa("ripple"),!k.value&&f.ripple,null]])}),{}}});const tu=Ye({name:"VCardActions",setup(f,e){let{slots:t}=e;return la({VBtn:{variant:"text"}}),tt(()=>{var s;return K("div",{class:"v-card-actions"},[(s=t.default)==null?void 0:s.call(t)])}),{}}}),su=Vu("v-card-subtitle"),iu=Vu("v-card-title"),aY=Ye({name:"VCardItem",props:{appendAvatar:String,appendIcon:Ot,prependAvatar:String,prependIcon:Ot,subtitle:String,title:String,...er()},setup(f,e){let{slots:t}=e;return tt(()=>{var s,i,n,r,a;const o=!!(f.prependAvatar||f.prependIcon||t.prepend),d=!!(f.appendAvatar||f.appendIcon||t.append),c=!!(f.title||t.title),u=!!(f.subtitle||t.subtitle);return K("div",{class:"v-card-item"},[o&&K(js,{key:"prepend",defaults:{VAvatar:{density:f.density,icon:f.prependIcon,image:f.prependAvatar},VIcon:{density:f.density,icon:f.prependIcon}}},{default:()=>{var h;return[K("div",{class:"v-card-item__prepend"},[(h=(s=t.prepend)==null?void 0:s.call(t))!=null?h:K(uo,null,null)])]}}),K("div",{class:"v-card-item__content"},[c&&K(iu,{key:"title"},{default:()=>{var h;return[(h=(i=t.title)==null?void 0:i.call(t))!=null?h:f.title]}}),u&&K(su,{key:"subtitle"},{default:()=>{var h;return[(h=(n=t.subtitle)==null?void 0:n.call(t))!=null?h:f.subtitle]}}),(r=t.default)==null?void 0:r.call(t)]),d&&K(js,{key:"append",defaults:{VAvatar:{density:f.density,icon:f.appendIcon,image:f.appendAvatar},VIcon:{density:f.density,icon:f.appendIcon}}},{default:()=>{var h;return[K("div",{class:"v-card-item__append"},[(h=(a=t.append)==null?void 0:a.call(t))!=null?h:K(uo,null,null)])]}})])}),{}}}),oY=Vu("v-card-text"),Nh=Ye({name:"VCard",directives:{Ripple:Du},props:{appendAvatar:String,appendIcon:Ot,disabled:Boolean,flat:Boolean,hover:Boolean,image:String,link:{type:Boolean,default:void 0},prependAvatar:String,prependIcon:Ot,ripple:Boolean,subtitle:String,text:String,title:String,...Ws(),...po(),...er(),...Vd(),...go(),...Rb(),...B2(),...E2(),...Or(),...Kl(),...Vs(),...pa({variant:"elevated"})},setup(f,e){let{attrs:t,slots:s}=e;const{themeClasses:i}=pi(f),{borderClasses:n}=mo(f),{colorClasses:r,colorStyles:a,variantClasses:o}=Gu(f),{densityClasses:d}=xr(f),{dimensionStyles:c}=qd(f),{elevationClasses:u}=yo(f),{loaderClasses:h}=Fb(f),{locationStyles:l}=N2(f),{positionClasses:p}=V2(f),{roundedClasses:m}=Ir(f),g=zl(f,t),y=te(()=>f.link!==!1&&g.isLink.value),b=te(()=>!f.disabled&&f.link!==!1&&(f.link||g.isClickable.value));return tt(()=>{var w,S,k;const T=y.value?"a":f.tag,I=!!(s.title||f.title),_=!!(s.subtitle||f.subtitle),N=I||_,M=!!(s.append||f.appendAvatar||f.appendIcon),x=!!(s.prepend||f.prependAvatar||f.prependIcon),v=!!(s.image||f.image),O=N||x||M,A=!!(s.text||f.text);return Ri(K(T,{class:["v-card",{"v-card--disabled":f.disabled,"v-card--flat":f.flat,"v-card--hover":f.hover&&!(f.disabled||f.flat),"v-card--link":b.value},i.value,n.value,r.value,d.value,u.value,h.value,p.value,m.value,o.value],style:[a.value,c.value,l.value],href:g.href.value,onClick:b.value&&g.navigate,tabindex:f.disabled?-1:void 0},{default:()=>[v&&K(js,{key:"image",defaults:{VImg:{cover:!0,src:f.image}}},{default:()=>{var V;return[K("div",{class:"v-card__image"},[(V=(w=s.image)==null?void 0:w.call(s))!=null?V:K(e2,null,null)])]}}),K(NC,{name:"v-card",active:!!f.loading,color:typeof f.loading=="boolean"?void 0:f.loading},{default:s.loader}),O&&K(aY,{key:"item",prependAvatar:f.prependAvatar,prependIcon:f.prependIcon,title:f.title,subtitle:f.subtitle,appendAvatar:f.appendAvatar,appendIcon:f.appendIcon},{default:s.item,prepend:s.prepend,title:s.title,subtitle:s.subtitle,append:s.append}),A&&K(oY,{key:"text"},{default:()=>{var V;return[(V=(S=s.text)==null?void 0:S.call(s))!=null?V:f.text]}}),(k=s.default)==null?void 0:k.call(s),s.actions&&K(tu,null,{default:s.actions}),Hu(b.value,"v-card")]}),[[fa("ripple"),b.value]])}),{}}});const Eh=Pi()({name:"VDialog",props:{fullscreen:Boolean,retainFocus:{type:Boolean,default:!0},scrollable:Boolean,...jb({origin:"center center",scrollStrategy:"block",transition:{component:qb},zIndex:2400})},emits:{"update:modelValue":f=>!0},setup(f,e){let{slots:t}=e;const s=ds(f,"modelValue"),{scopeId:i}=C2(),n=be();function r(a){var o,d;const c=a.relatedTarget,u=a.target;if(c!==u&&(o=n.value)!=null&&o.contentEl&&(d=n.value)!=null&&d.globalTop&&![document,n.value.contentEl].includes(u)&&!n.value.contentEl.contains(u)){const h=[...n.value.contentEl.querySelectorAll('button, [href], input:not([type="hidden"]), select, textarea, [tabindex]:not([tabindex="-1"])')].filter(m=>!m.hasAttribute("disabled")&&!m.matches('[tabindex="-1"]'));if(!h.length)return;const l=h[0],p=h[h.length-1];c===l?p.focus():l.focus()}}return os&&Je(()=>s.value&&f.retainFocus,a=>{a?document.addEventListener("focusin",r):document.removeEventListener("focusin",r)},{immediate:!0}),Je(s,async a=>{if(await _i(),a){var o;(o=n.value.contentEl)==null||o.focus({preventScroll:!0})}else{var d;(d=n.value.activatorEl)==null||d.focus({preventScroll:!0})}}),tt(()=>{const[a]=_2(f);return K(Wb,ct({ref:n,class:["v-dialog",{"v-dialog--fullscreen":f.fullscreen,"v-dialog--scrollable":f.scrollable}]},a,{modelValue:s.value,"onUpdate:modelValue":o=>s.value=o,"aria-role":"dialog","aria-modal":"true",activatorProps:ct({"aria-haspopup":"dialog","aria-expanded":String(s.value)},f.activatorProps)},i),{activator:t.activator,default:function(){for(var o,d=arguments.length,c=new Array(d),u=0;u<d;u++)c[u]=arguments[u];return K(js,{root:!0},{default:()=>[(o=t.default)==null?void 0:o.call(t,...c)]})}})}),Fu({},n)}});const dY=Ye({name:"VContainer",props:{fluid:{type:Boolean,default:!1},...Vs()},setup(f,e){let{slots:t}=e;return tt(()=>K(f.tag,{class:["v-container",{"v-container--fluid":f.fluid}]},t)),{}}}),zb=["sm","md","lg","xl","xxl"],q2=(()=>zb.reduce((f,e)=>(f[e]={type:[Boolean,String,Number],default:!1},f),{}))(),L2=(()=>zb.reduce((f,e)=>(f["offset"+br(e)]={type:[String,Number],default:null},f),{}))(),R2=(()=>zb.reduce((f,e)=>(f["order"+br(e)]={type:[String,Number],default:null},f),{}))(),jO={col:Object.keys(q2),offset:Object.keys(L2),order:Object.keys(R2)};function cY(f,e,t){let s=f;if(!(t==null||t===!1)){if(e){const i=e.replace(f,"");s+=`-${i}`}return f==="col"&&(s="v-"+s),f==="col"&&(t===""||t===!0)||(s+=`-${t}`),s.toLowerCase()}}const uY=["auto","start","end","center","baseline","stretch"],Zo=Ye({name:"VCol",props:{cols:{type:[Boolean,String,Number],default:!1},...q2,offset:{type:[String,Number],default:null},...L2,order:{type:[String,Number],default:null},...R2,alignSelf:{type:String,default:null,validator:f=>uY.includes(f)},...Vs()},setup(f,e){let{slots:t}=e;const s=te(()=>{const i=[];let n;for(n in jO)jO[n].forEach(a=>{const o=f[a],d=cY(n,a,o);d&&i.push(d)});const r=i.some(a=>a.startsWith("v-col-"));return i.push({"v-col":!r||!f.cols,[`v-col-${f.cols}`]:f.cols,[`offset-${f.offset}`]:f.offset,[`order-${f.order}`]:f.order,[`align-self-${f.alignSelf}`]:f.alignSelf}),i});return()=>{var i;return ha(f.tag,{class:s.value},(i=t.default)==null?void 0:i.call(t))}}}),fY=["sm","md","lg","xl","xxl"],Kb=["start","end","center"],F2=["space-between","space-around","space-evenly"];function Xb(f,e){return fY.reduce((t,s)=>(t[f+br(s)]=e(),t),{})}const hY=[...Kb,"baseline","stretch"],D2=f=>hY.includes(f),H2=Xb("align",()=>({type:String,default:null,validator:D2})),lY=[...Kb,...F2],G2=f=>lY.includes(f),U2=Xb("justify",()=>({type:String,default:null,validator:G2})),pY=[...Kb,...F2,"stretch"],$2=f=>pY.includes(f),j2=Xb("alignContent",()=>({type:String,default:null,validator:$2})),WO={align:Object.keys(H2),justify:Object.keys(U2),alignContent:Object.keys(j2)},mY={align:"align",justify:"justify",alignContent:"align-content"};function gY(f,e,t){let s=mY[f];if(t!=null){if(e){const i=e.replace(f,"");s+=`-${i}`}return s+=`-${t}`,s.toLowerCase()}}const Vh=Ye({name:"VRow",props:{dense:Boolean,noGutters:Boolean,align:{type:String,default:null,validator:D2},...H2,justify:{type:String,default:null,validator:G2},...U2,alignContent:{type:String,default:null,validator:$2},...j2,...Vs()},setup(f,e){let{slots:t}=e;const s=te(()=>{const i=[];let n;for(n in WO)WO[n].forEach(r=>{const a=f[r],o=gY(n,r,a);o&&i.push(o)});return i.push({"v-row--no-gutters":f.noGutters,"v-row--dense":f.dense,[`align-${f.align}`]:f.align,[`justify-${f.justify}`]:f.justify,[`align-content-${f.alignContent}`]:f.alignContent}),i});return()=>{var i;return ha(f.tag,{class:["v-row",s.value]},(i=t.default)==null?void 0:i.call(t))}}});function W2(){const f=be(!1);return Jn(()=>{window.requestAnimationFrame(()=>{f.value=!0})}),{ssrBootStyles:te(()=>f.value?void 0:{transition:"none !important"}),isBooted:Iu(f)}}const yY=Ye({name:"VMain",props:{scrollable:Boolean,...Vs({tag:"main"})},setup(f,e){let{slots:t}=e;const{mainStyles:s}=rK(),{ssrBootStyles:i}=W2();return tt(()=>{var n,r;return K(f.tag,{class:["v-main",{"v-main--scrollable":f.scrollable}],style:[s.value,i.value]},{default:()=>[f.scrollable?K("div",{class:"v-main__scroller"},[(n=t.default)==null?void 0:n.call(t)]):(r=t.default)==null?void 0:r.call(t)]})}),{}}});const Cy=Symbol.for("vuetify:display"),zO={mobileBreakpoint:"lg",thresholds:{xs:0,sm:600,md:960,lg:1280,xl:1920,xxl:2560}},bY=function(){let f=arguments.length>0&&arguments[0]!==void 0?arguments[0]:zO;return yr(zO,f)};function KO(f){return os&&!f?window.innerWidth:0}function XO(f){return os&&!f?window.innerHeight:0}function wY(){const f=os?window.navigator.userAgent:"ssr";function e(p){return Boolean(f.match(p))}const t=e(/android/i),s=e(/iphone|ipad|ipod/i),i=e(/cordova/i),n=e(/electron/i),r=e(/chrome/i),a=e(/edge/i),o=e(/firefox/i),d=e(/opera/i),c=e(/win/i),u=e(/mac/i),h=e(/linux/i),l=e(/ssr/i);return{android:t,ios:s,cordova:i,electron:n,chrome:r,edge:a,firefox:o,opera:d,win:c,mac:u,linux:h,touch:xz,ssr:l}}function SY(f,e){const{thresholds:t,mobileBreakpoint:s}=bY(f),i=be(XO(e)),n=wY(),r=Js({}),a=be(KO(e));function o(){i.value=XO(),a.value=KO()}return wr(()=>{const d=a.value<t.sm,c=a.value<t.md&&!d,u=a.value<t.lg&&!(c||d),h=a.value<t.xl&&!(u||c||d),l=a.value<t.xxl&&!(h||u||c||d),p=a.value>=t.xxl,m=d?"xs":c?"sm":u?"md":h?"lg":l?"xl":"xxl",g=typeof s=="number"?s:t[s],y=n.ssr?n.android||n.ios||n.opera:a.value<g;r.xs=d,r.sm=c,r.md=u,r.lg=h,r.xl=l,r.xxl=p,r.smAndUp=!d,r.mdAndUp=!(d||c),r.lgAndUp=!(d||c||u),r.xlAndUp=!(d||c||u||h),r.smAndDown=!(u||h||l||p),r.mdAndDown=!(h||l||p),r.lgAndDown=!(l||p),r.xlAndDown=!p,r.name=m,r.height=i.value,r.width=a.value,r.mobile=y,r.mobileBreakpoint=s,r.platform=n,r.thresholds=t}),os&&window.addEventListener("resize",o,{passive:!0}),{...Wy(r),update:o}}function kY(){const f=Yt(Cy);if(!f)throw new Error("Could not find Vuetify display injection");return f}function vY(f){let{rootEl:e,isSticky:t,layoutItemStyles:s}=f;const i=be(!1),n=be(0),r=te(()=>{const d=typeof i.value=="boolean"?"top":i.value;return[t.value?{top:"auto",bottom:"auto",height:void 0}:void 0,i.value?{[d]:We(n.value)}:{top:s.value.top}]});Jn(()=>{Je(t,d=>{d?window.addEventListener("scroll",o,{passive:!0}):window.removeEventListener("scroll",o)},{immediate:!0})}),hn(()=>{document.removeEventListener("scroll",o)});let a=0;function o(){var p;const d=a>window.scrollY?"up":"down",c=e.value.getBoundingClientRect(),u=parseFloat((p=s.value.top)!=null?p:0),h=window.scrollY-Math.max(0,n.value-u),l=c.height+Math.max(n.value,u)-window.scrollY-window.innerHeight;c.height<window.innerHeight-u?(i.value="top",n.value=u):d==="up"&&i.value==="bottom"||d==="down"&&i.value==="top"?(n.value=window.scrollY+c.top,i.value=!0):d==="down"&&l<=0?(n.value=0,i.value="bottom"):d==="up"&&h<=0&&(n.value=c.top+h,i.value="top"),a=window.scrollY}return{isStuck:i,stickyStyles:r}}const TY=100,OY=20;function YO(f){const e=1.41421356237;return(f<0?-1:1)*Math.sqrt(Math.abs(f))*e}function QO(f){if(f.length<2)return 0;if(f.length===2)return f[1].t===f[0].t?0:(f[1].d-f[0].d)/(f[1].t-f[0].t);let e=0;for(let t=f.length-1;t>0;t--){if(f[t].t===f[t-1].t)continue;const s=YO(e),i=(f[t].d-f[t-1].d)/(f[t].t-f[t-1].t);e+=(i-s)*Math.abs(i),t===f.length-1&&(e*=.5)}return YO(e)*1e3}function IY(){const f={};function e(i){Array.from(i.changedTouches).forEach(n=>{var a;((a=f[n.identifier])!=null?a:f[n.identifier]=new Nz(OY)).push([i.timeStamp,n])})}function t(i){Array.from(i.changedTouches).forEach(n=>{delete f[n.identifier]})}function s(i){var n;const r=(n=f[i])==null?void 0:n.values().reverse();if(!r)throw new Error(`No samples for touch id ${i}`);const a=r[0],o=[],d=[];for(const c of r){if(a[0]-c[0]>TY)break;o.push({t:c[0],d:c[1].clientX}),d.push({t:c[0],d:c[1].clientY})}return{x:QO(o),y:QO(d),get direction(){const{x:c,y:u}=this,[h,l]=[Math.abs(c),Math.abs(u)];return h>l&&c>=0?"right":h>l&&c<=0?"left":l>h&&u>=0?"down":l>h&&u<=0?"up":xY()}}}return{addMovement:e,endTouch:t,getVelocity:s}}function xY(){throw new Error}function _Y(f){let{isActive:e,isTemporary:t,width:s,touchless:i,position:n}=f;Jn(()=>{window.addEventListener("touchstart",y,{passive:!0}),window.addEventListener("touchmove",b,{passive:!1}),window.addEventListener("touchend",w,{passive:!0})}),hn(()=>{window.removeEventListener("touchstart",y),window.removeEventListener("touchmove",b),window.removeEventListener("touchend",w)});const r=te(()=>n.value!=="bottom"),{addMovement:a,endTouch:o,getVelocity:d}=IY();let c=!1;const u=be(!1),h=be(0),l=be(0);let p;function m(k,T){return(n.value==="left"?k:n.value==="right"?document.documentElement.clientWidth-k:n.value==="bottom"?document.documentElement.clientHeight-k:Jo())-(T?s.value:0)}function g(k){let T=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0;const I=n.value==="left"?(k-l.value)/s.value:n.value==="right"?(document.documentElement.clientWidth-k-l.value)/s.value:n.value==="bottom"?(document.documentElement.clientHeight-k-l.value)/s.value:Jo();return T?Math.max(0,Math.min(1,I)):I}function y(k){if(i.value)return;const T=k.changedTouches[0].clientX,I=k.changedTouches[0].clientY,_=25,N=n.value==="left"?T<_:n.value==="right"?T>document.documentElement.clientWidth-_:n.value==="bottom"?I>document.documentElement.clientHeight-_:Jo(),M=e.value&&(n.value==="left"?T<s.value:n.value==="right"?T>document.documentElement.clientWidth-s.value:n.value==="bottom"?I>document.documentElement.clientHeight-s.value:Jo());(N||M||e.value&&t.value)&&(c=!0,p=[T,I],l.value=m(r.value?T:I,e.value),h.value=g(r.value?T:I),o(k),a(k))}function b(k){const T=k.changedTouches[0].clientX,I=k.changedTouches[0].clientY;if(c){if(!k.cancelable){c=!1;return}const N=Math.abs(T-p[0]),M=Math.abs(I-p[1]);(r.value?N>M&&N>3:M>N&&M>3)?(u.value=!0,c=!1):(r.value?M:N)>3&&(c=!1)}if(!u.value)return;k.preventDefault(),a(k);const _=g(r.value?T:I,!1);h.value=Math.max(0,Math.min(1,_)),_>1?l.value=m(r.value?T:I,!0):_<0&&(l.value=m(r.value?T:I,!1))}function w(k){if(c=!1,!u.value)return;a(k),u.value=!1;const T=d(k.changedTouches[0].identifier),I=Math.abs(T.x),_=Math.abs(T.y);(r.value?I>_&&I>400:_>I&&_>3)?e.value=T.direction===({left:"right",right:"left",bottom:"up"}[n.value]||Jo()):e.value=h.value>.5}const S=te(()=>u.value?{transform:n.value==="left"?`translateX(calc(-100% + ${h.value*s.value}px))`:n.value==="right"?`translateX(calc(100% - ${h.value*s.value}px))`:n.value==="bottom"?`translateY(calc(100% - ${h.value*s.value}px))`:Jo(),transition:"none"}:void 0);return{isDragging:u,dragProgress:h,dragStyles:S}}function Jo(){throw new Error}const CY=["start","end","left","right","bottom"],MY=Ye({name:"VNavigationDrawer",props:{color:String,disableResizeWatcher:Boolean,disableRouteWatcher:Boolean,expandOnHover:Boolean,floating:Boolean,modelValue:{type:Boolean,default:null},permanent:Boolean,rail:Boolean,railWidth:{type:[Number,String],default:56},scrim:{type:[String,Boolean],default:!0},image:String,temporary:Boolean,touchless:Boolean,width:{type:[Number,String],default:256},location:{type:String,default:"start",validator:f=>CY.includes(f)},sticky:Boolean,...po(),...go(),...nK(),...Or(),...Vs({tag:"nav"}),...Ws()},emits:{"update:modelValue":f=>!0},setup(f,e){let{attrs:t,slots:s}=e;const{isRtl:i}=qu(),{themeClasses:n}=pi(f),{borderClasses:r}=mo(f),{backgroundColorClasses:a,backgroundColorStyles:o}=ua(Xe(f,"color")),{elevationClasses:d}=yo(f),{mobile:c}=kY(),{roundedClasses:u}=Ir(f),h=o2(),l=ds(f,"modelValue",null,q=>!!q),{ssrBootStyles:p}=W2(),m=be(),g=be(!1),y=te(()=>f.rail&&f.expandOnHover&&g.value?Number(f.width):Number(f.rail?f.railWidth:f.width)),b=te(()=>by(f.location,i.value)),w=te(()=>!f.permanent&&(c.value||f.temporary)),S=te(()=>f.sticky&&!w.value&&b.value!=="bottom");f.disableResizeWatcher||Je(w,q=>!f.permanent&&(l.value=!q)),!f.disableRouteWatcher&&h&&Je(h.currentRoute,()=>w.value&&(l.value=!1)),Je(()=>f.permanent,q=>{q&&(l.value=!0)}),kl(()=>{f.modelValue!=null||w.value||(l.value=f.permanent||!c.value)});const{isDragging:k,dragProgress:T,dragStyles:I}=_Y({isActive:l,isTemporary:w,width:y,touchless:Xe(f,"touchless"),position:b}),_=te(()=>{const q=w.value?0:f.rail&&f.expandOnHover?Number(f.railWidth):y.value;return k.value?q*T.value:q}),{layoutItemStyles:N,layoutRect:M,layoutItemScrimStyles:x}=aK({id:f.name,order:te(()=>parseInt(f.order,10)),position:b,layoutSize:_,elementSize:y,active:te(()=>l.value||k.value),disableTransitions:te(()=>k.value),absolute:te(()=>f.absolute||S.value&&typeof v.value!="string")}),{isStuck:v,stickyStyles:O}=vY({rootEl:m,isSticky:S,layoutItemStyles:N}),A=ua(te(()=>typeof f.scrim=="string"?f.scrim:null)),V=te(()=>({...k.value?{opacity:T.value*.2,transition:"none"}:void 0,...M.value?{left:We(M.value.left),right:We(M.value.right),top:We(M.value.top),bottom:We(M.value.bottom)}:void 0,...x.value}));return la({VList:{bgColor:"transparent"}}),tt(()=>{var q,R,H,F;const P=s.image||f.image;return K(Vt,null,[K(f.tag,ct({ref:m,onMouseenter:()=>g.value=!0,onMouseleave:()=>g.value=!1,class:["v-navigation-drawer",`v-navigation-drawer--${b.value}`,{"v-navigation-drawer--expand-on-hover":f.expandOnHover,"v-navigation-drawer--floating":f.floating,"v-navigation-drawer--is-hovering":g.value,"v-navigation-drawer--rail":f.rail,"v-navigation-drawer--temporary":w.value,"v-navigation-drawer--active":l.value,"v-navigation-drawer--sticky":S.value},n.value,a.value,r.value,d.value,u.value],style:[o.value,N.value,I.value,p.value,O.value]},t),{default:()=>[P&&K("div",{key:"image",class:"v-navigation-drawer__img"},[s.image?(q=s.image)==null?void 0:q.call(s,{image:f.image}):K("img",{src:f.image,alt:""},null)]),s.prepend&&K("div",{class:"v-navigation-drawer__prepend"},[(R=s.prepend)==null?void 0:R.call(s)]),K("div",{class:"v-navigation-drawer__content"},[(H=s.default)==null?void 0:H.call(s)]),s.append&&K("div",{class:"v-navigation-drawer__append"},[(F=s.append)==null?void 0:F.call(s)])]}),K(Yn,{name:"fade-transition"},{default:()=>[w.value&&(k.value||l.value)&&!!f.scrim&&K("div",{class:["v-navigation-drawer__scrim",A.backgroundColorClasses.value],style:[V.value,A.backgroundColorStyles.value],onClick:()=>l.value=!1},null)]})])}),{isStuck:v}}}),PY={class:"d-flex align-top justify-center"},AY={class:"d-flex align-top justify-center"},BY={class:"d-flex align-top justify-center"},NY={class:"d-flex align-top justify-center"},EY=$s("h1",{class:"text-h3 font-weight-bold"},"CryptoPositionsBot",-1),VY={key:0,class:"text-h4 font-weight-bold",style:{color:"rgb(169, 94, 171)"}},qY=$s("div",{class:"py-5"},null,-1),LY={key:0,style:{"max-height":"450px",padding:".5em"},class:"overflow-y-auto"},RY=$s("h3",null,"Exchange Keys",-1),FY={style:{"margin-bottom":"1em"}},DY={class:"d-flex align-top justify-center"},HY={key:1},GY={style:{"margin-top":"1em"}},UY={key:0,style:{"margin-top":"1em","max-height":"400px","min-width":"400px",padding:"1em"},class:"overflow-y-auto"},$Y=$s("h3",null,"Discord Settings",-1),jY=$s("a",{target:"_blank",href:"https://discord.com/api/oauth2/authorize?client_id=1044389854236127262&permissions=83968&scope=bot"},"Invite Discord Bot",-1),WY={key:0,style:{"margin-top":"1em","max-height":"400px","min-width":"400px",padding:"1em"},class:"overflow-y-auto"},zY=$s("h3",null,"Twitch Settings",-1),KY=Qy({__name:"App",setup(f){const e=be(""),t=be([]),s=II(()=>Buffer.from(JSON.stringify(t.value),"utf-8").toString("base64")),i=be({}),n=be(null),r=be(!0),a=be(!0),o=be(!1),d=be(!1),c=be(!1),u=be(!1),h=be(!0),l=be(""),p=be(""),m=be(!1),g=be(!1),y=be(!1),b=be(!1),w=be(5),S=be(null),k=Js({exchangeKeys:t,twitchAccessToken:i,twitchUserInfo:n,editExchangeKeys:r,editDiscordInfo:a,editTwitchInfo:h,discordChannelId:l,discordMessageId:p,enabled:m,discordEnabled:g,twitchEnabled:y,twitchTimeoutEnabled:b,twitchTimeoutLength:w,userInfo:S,deleteDialog:o,logoutDialog:d,startDialog:c,stopDialog:u}),T=()=>{window.location.href="https://id.twitch.tv/oauth2/authorize?response_type=token&client_id=z5o8ef6nmef6wbxm2h6ry6xfatvqud&redirect_uri=https://www.cryptopositionsbot.com/&scope=channel%3Amanage%3Apolls+channel%3Aread%3Apolls&state=c3ab8aa609ea11e793ae92361f002671"};Jn(()=>{if(document.location.hash){var P={};decodeURIComponent(window.location.hash.substring(1)).split("&").forEach(E=>{let[j,X]=E.split("=");P[j]=X}),k.twitchAccessToken=P,document.location.hash="",I().then(()=>{_().then(()=>{}).catch(E=>{console.error(E)})}).catch(E=>{console.error(E)})}});const I=()=>new Promise((P,E)=>{as.get(`https://bot.cryptopositionsbot.com/twitchUserInfo?access_token=${k.twitchAccessToken.access_token}`).then(j=>{k.twitchUserInfo=j.data,P()}).catch(j=>{console.error(j),E(j)})}),_=()=>new Promise((P,E)=>{as.get(`https://bot.cryptopositionsbot.com/userInfo?access_token=${k.twitchAccessToken.access_token}`).then(j=>{e.value=Buffer.from(JSON.stringify(j.data.EXCHANGE_KEYS),"utf-8").toString("base64"),k.userInfo=j.data,k.userInfo.EXCHANGE_KEYS.length>0&&k.exchangeKeys.push(...j.data.EXCHANGE_KEYS),k.discordChannelId=j.data.DISCORD_CHANNEL,k.discordMessageId=j.data.DISCORD_MESSAGE,k.discordEnabled=j.data.DISCORD_ENABLED,k.twitchEnabled=j.data.TWITCH_ENABLED,k.twitchTimeoutEnabled=j.data.TWITCH_TIMEOUT,k.twitchTimeoutLength=j.data.TWITCH_TIMEOUT_EXPIRE,k.enabled=j.data.ENABLED,P()}).catch(j=>{console.error(j),E(j)})}),N=()=>{k.userInfo.EXCHANGE_KEYS.length>0&&(k.exchangeKeys=[...k.userInfo.EXCHANGE_KEYS])},M=()=>{k.discordChannelId=k.userInfo.DISCORD_CHANNEL,k.discordMessageId=k.userInfo.DISCORD_MESSAGE,k.discordEnabled=k.userInfo.DISCORD_ENABLED},x=()=>{k.twitchEnabled=k.userInfo.TWITCH_ENABLED,k.twitchTimeoutEnabled=k.userInfo.TWITCH_TIMEOUT,k.twitchTimeoutLength=k.userInfo.TWITCH_TIMEOUT_EXPIRE},v=()=>new Promise((P,E)=>{let j={access_token:k.twitchAccessToken.access_token,exchangeKeys:k.exchangeKeys};as.post("https://bot.cryptopositionsbot.com/userExchangeKeys",j).then(X=>{e.value=Buffer.from(JSON.stringify(k.exchangeKeys),"utf-8").toString("base64"),k.userInfo.EXCHANGE_KEYS=k.exchangeKeys.map(Q=>({EXCHANGE_ID:Q.EXCHANGE_ID,DESCRIPTION:Q.DESCRIPTION,API_KEY:new Array(Q.API_KEY.length+1).join("*"),API_SECRET:new Array(Q.API_SECRET.length+1).join("*"),KEY_ID:Q.KEY_ID})),P()}).catch(X=>{console.error(X),E(X)})}),O=()=>new Promise((P,E)=>{let j={access_token:k.twitchAccessToken.access_token,discordInfo:{DISCORD_CHANNEL:k.discordChannelId,DISCORD_MESSAGE:k.discordMessageId,DISCORD_ENABLED:k.discordEnabled}};as.post("https://bot.cryptopositionsbot.com/userDiscordInfo",j).then(X=>{k.userInfo.DISCORD_CHANNEL=k.discordChannelId,k.userInfo.DISCORD_MESSAGE=k.discordMessageId,k.userInfo.DISCORD_ENABLED=k.discordEnabled,P()}).catch(X=>{console.error(X),E(X)})}),A=()=>new Promise((P,E)=>{let j={access_token:k.twitchAccessToken.access_token,twitchInfo:{TWITCH_ENABLED:k.twitchEnabled,TWITCH_TIMEOUT:k.twitchTimeoutEnabled,TWITCH_TIMEOUT_EXPIRE:k.twitchTimeoutLength}};as.post("https://bot.cryptopositionsbot.com/userTwitchInfo",j).then(X=>{k.userInfo.TWITCH_ENABLED=k.twitchEnabled,k.userInfo.TWITCH_TIMEOUT=k.twitchTimeoutEnabled,k.userInfo.TWITCH_TIMEOUT_EXPIRE=k.twitchTimeoutLength,P()}).catch(X=>{console.error(X),E(X)})}),V=()=>new Promise((P,E)=>{let j={access_token:k.twitchAccessToken.access_token,enabled:k.enabled};as.post("https://bot.cryptopositionsbot.com/userEnabled",j).then(X=>{k.userInfo.ENABLED=k.enabled,P()}).catch(X=>{console.error(X),E(X)})}),q=()=>{k.userInfo=null,k.twitchUserInfo=null},R=()=>new Promise((P,E)=>{let j={access_token:k.twitchAccessToken.access_token};as.post("https://bot.cryptopositionsbot.com/removeUser",j).then(X=>{k.deleteDialog=!1,q(),P()}).catch(X=>{console.error(X),E(X)})}),H=()=>new Promise((P,E)=>{let j={access_token:k.twitchAccessToken.access_token};as.post("https://bot.cryptopositionsbot.com/start",j).then(X=>{k.userInfo.IS_RUNNING=!0,k.startDialog=!1,P()}).catch(X=>{console.error(X),E(X)})}),F=()=>new Promise((P,E)=>{let j={access_token:k.twitchAccessToken.access_token};as.post("https://bot.cryptopositionsbot.com/stop",j).then(X=>{k.userInfo.IS_RUNNING=!1,k.stopDialog=!1,P()}).catch(X=>{console.error(X),E(X)})});return(P,E)=>(St(),Kt(IK,{id:"inspire"},{default:qe(()=>[K(Eh,{modelValue:d.value,"onUpdate:modelValue":E[2]||(E[2]=j=>d.value=j)},{default:qe(()=>[$s("div",PY,[K(Nh,{style:{width:"400px"}},{default:qe(()=>[K(iu,null,{default:qe(()=>[ht("Logout")]),_:1}),K(su,null,{default:qe(()=>[ht("Are you sure you want to logout?")]),_:1}),K(tu,null,{default:qe(()=>[K(_t,{onClick:E[0]||(E[0]=j=>q()),color:"error"},{default:qe(()=>[ht("Logout")]),_:1}),K(_t,{onClick:E[1]||(E[1]=j=>{d.value=!1})},{default:qe(()=>[ht("Cancel")]),_:1})]),_:1})]),_:1})])]),_:1},8,["modelValue"]),K(Eh,{modelValue:o.value,"onUpdate:modelValue":E[5]||(E[5]=j=>o.value=j)},{default:qe(()=>[$s("div",AY,[K(Nh,{style:{width:"400px"}},{default:qe(()=>[K(iu,null,{default:qe(()=>[ht("Deletion")]),_:1}),K(su,null,{default:qe(()=>[ht("Are you sure you want to delete your user?")]),_:1}),K(tu,null,{default:qe(()=>[K(_t,{onClick:E[3]||(E[3]=j=>R()),color:"error"},{default:qe(()=>[ht("Delete")]),_:1}),K(_t,{onClick:E[4]||(E[4]=j=>{o.value=!1})},{default:qe(()=>[ht("Cancel")]),_:1})]),_:1})]),_:1})])]),_:1},8,["modelValue"]),K(Eh,{modelValue:c.value,"onUpdate:modelValue":E[8]||(E[8]=j=>c.value=j)},{default:qe(()=>[$s("div",BY,[K(Nh,{style:{width:"400px"}},{default:qe(()=>[K(iu,null,{default:qe(()=>[ht("Start Running?")]),_:1}),K(su,null,{default:qe(()=>[ht("Allow the bot to pull data from Exchanges?")]),_:1}),K(tu,null,{default:qe(()=>[K(_t,{onClick:E[6]||(E[6]=j=>H()),color:"error"},{default:qe(()=>[ht("Start")]),_:1}),K(_t,{onClick:E[7]||(E[7]=j=>{c.value=!1})},{default:qe(()=>[ht("Cancel")]),_:1})]),_:1})]),_:1})])]),_:1},8,["modelValue"]),K(Eh,{modelValue:u.value,"onUpdate:modelValue":E[11]||(E[11]=j=>u.value=j)},{default:qe(()=>[$s("div",NY,[K(Nh,{style:{width:"400px"}},{default:qe(()=>[K(iu,null,{default:qe(()=>[ht("Stop Running?")]),_:1}),K(su,null,{default:qe(()=>[ht("Are you sure you want to stop the bot?")]),_:1}),K(tu,null,{default:qe(()=>[K(_t,{onClick:E[9]||(E[9]=j=>F()),color:"error"},{default:qe(()=>[ht("Stop")]),_:1}),K(_t,{onClick:E[10]||(E[10]=j=>{u.value=!1})},{default:qe(()=>[ht("Cancel")]),_:1})]),_:1})]),_:1})])]),_:1},8,["modelValue"]),k.twitchUserInfo!==null?(St(),Kt(MY,{key:0,"model-value":"",class:"pt-4",color:"grey-lighten-3",rail:""},{default:qe(()=>[K(uo,{style:{"margin-top":"1em",cursor:"pointer"},color:"grey-darken-1",image:k.twitchUserInfo!==null?k.twitchUserInfo.profile_image_url:"",size:36,onClick:E[12]||(E[12]=()=>{k.twitchUserInfo!==null&&(k.logoutDialog=!0)}),class:"d-block text-center mx-auto mb-9"},null,8,["image"]),k.twitchUserInfo!==null?(St(),Kt(id,{key:0})):Bt("",!0),k.twitchUserInfo!==null?(St(),Kt(_t,{key:1,style:{"margin-top":"2em"},active:k.editExchangeKeys,flat:"",class:"d-block text-center mx-auto mb-9",size:"32px",icon:"mdi-key",onClick:E[13]||(E[13]=j=>k.editExchangeKeys=!k.editExchangeKeys)},null,8,["active"])):Bt("",!0),k.twitchUserInfo!==null?(St(),Kt(id,{key:2})):Bt("",!0),k.twitchUserInfo!==null?(St(),Kt(_t,{key:3,style:{"margin-top":"2em"},active:k.editDiscordInfo,flat:"",class:"d-block text-center mx-auto mb-9",size:"32px",icon:"mdi-forum",onClick:E[14]||(E[14]=j=>k.editDiscordInfo=!k.editDiscordInfo)},null,8,["active"])):Bt("",!0),k.twitchUserInfo!==null?(St(),Kt(id,{key:4})):Bt("",!0),k.twitchUserInfo!==null?(St(),Kt(_t,{key:5,style:{"margin-top":"2em"},active:k.editTwitchInfo,flat:"",class:"d-block text-center mx-auto mb-9",size:"32px",icon:"mdi-chat",onClick:E[15]||(E[15]=j=>k.editTwitchInfo=!k.editTwitchInfo)},null,8,["active"])):Bt("",!0),k.twitchUserInfo!==null?(St(),Kt(id,{key:6})):Bt("",!0),k.twitchUserInfo!==null?(St(),Kt(_t,{key:7,style:{"margin-top":"2em"},active:k.deleteDialog,flat:"",color:"error",class:"d-block text-center mx-auto mb-9",size:"32px",icon:"mdi-trash-can",onClick:E[16]||(E[16]=j=>k.deleteDialog=!k.deleteDialog)},null,8,["active"])):Bt("",!0),K(id)]),_:1})):Bt("",!0),K(yY,null,{default:qe(()=>[K(dY,{class:"fill-height"},{default:qe(()=>[K(JC,{class:"d-flex align-center text-center justify-center fill-height"},{default:qe(()=>[EY,k.twitchUserInfo!==null?(St(),ya("h2",VY,mp(k.twitchUserInfo.display_name),1)):Bt("",!0),qY,K(Vh,{class:"d-flex align-top justify-center"},{default:qe(()=>[K(Zo,{cols:"auto"},{default:qe(()=>[k.twitchUserInfo===null?(St(),Kt(_t,{key:0,onClick:T,color:"rgb(169, 94, 171)"},{default:qe(()=>[ht("Connect Twitch")]),_:1})):Bt("",!0)]),_:1})]),_:1}),k.twitchUserInfo!==null&&k.userInfo!==null?(St(),Kt(Vh,{key:1,class:"d-flex align-top justify-center"},{default:qe(()=>[K(Zo,{cols:"auto"},{default:qe(()=>[K(Bh,{label:"Active",modelValue:k.enabled,"onUpdate:modelValue":E[17]||(E[17]=j=>k.enabled=j)},null,8,["modelValue"]),k.enabled!==k.userInfo.ENABLED?(St(),Kt(_t,{key:0,color:"success",onClick:E[18]||(E[18]=j=>V())},{default:qe(()=>[ht("Save ")]),_:1})):Bt("",!0)]),_:1})]),_:1})):Bt("",!0),k.twitchUserInfo!==null&&k.userInfo!==null?(St(),Kt(Vh,{key:2,class:"d-flex align-top justify-center"},{default:qe(()=>[K(Zo,{cols:"auto"},{default:qe(()=>[k.twitchUserInfo!==null?(St(),Kt(_t,{key:0,icon:k.userInfo.IS_RUNNING?"mdi-stop":"mdi-play",disabled:!k.enabled,color:k.userInfo.IS_RUNNING?"error":"success",onClick:E[19]||(E[19]=()=>{k.userInfo.IS_RUNNING?u.value=!0:c.value=!0})},null,8,["icon","disabled","color"])):Bt("",!0)]),_:1})]),_:1})):Bt("",!0),k.twitchUserInfo!==null&&k.userInfo!==null?(St(),Kt(Vh,{key:3,class:"d-flex align-top justify-center"},{default:qe(()=>[K(Zo,{cols:"auto"},{default:qe(()=>[k.editExchangeKeys?(St(),ya("div",LY,[RY,(St(!0),ya(Vt,null,mP(k.exchangeKeys,(j,X)=>(St(),ya("p",{style:{"margin-top":"1em"},key:"exchangeKey-"+X},[$s("p",FY,"#"+mp(X+1),1),K(tY,{disabled:!m.value,variant:"underlined",style:{height:"auto"},density:"compact",label:"EXCHANGE",items:rn(Iz),modelValue:j.EXCHANGE_ID,"onUpdate:modelValue":Q=>j.EXCHANGE_ID=Q},null,8,["disabled","items","modelValue","onUpdate:modelValue"]),K(lr,{disabled:!m.value,variant:"underlined",density:"compact",label:"DESCRIPTION",modelValue:j.DESCRIPTION,"onUpdate:modelValue":Q=>j.DESCRIPTION=Q},null,8,["disabled","modelValue","onUpdate:modelValue"]),K(lr,{disabled:!m.value,variant:"underlined",density:"compact",label:"API KEY",modelValue:j.API_KEY,"onUpdate:modelValue":Q=>j.API_KEY=Q,type:"password"},null,8,["disabled","modelValue","onUpdate:modelValue"]),K(lr,{disabled:!m.value,variant:"underlined",density:"compact",label:"API SECRET",modelValue:j.API_SECRET,"onUpdate:modelValue":Q=>j.API_SECRET=Q,type:"password"},null,8,["disabled","modelValue","onUpdate:modelValue"]),K(_t,{disabled:!m.value,style:{"margin-bottom":"2em"},color:"error",onClick:()=>{k.exchangeKeys.splice(X,1)}},{default:qe(()=>[ht("Remove Exchange API Key #"+mp(X+1),1)]),_:2},1032,["disabled","onClick"])]))),128)),$s("p",DY,[K(_t,{disabled:!m.value,color:"primary",onClick:E[20]||(E[20]=j=>k.exchangeKeys.push({KEY_ID:rn(EB)(),EXCHANGE_ID:"",API_KEY:"",API_SECRET:"",DESCRIPTION:""}))},{default:qe(()=>[ht(" Add Exchange API Key")]),_:1},8,["disabled"])])])):Bt("",!0),r.value?(St(),ya("div",HY,[$s("p",GY,[K(_t,{disabled:!k.enabled||e.value===rn(s),style:{margin:".25em"},color:"success",onClick:E[21]||(E[21]=j=>v())},{default:qe(()=>[ht("Save")]),_:1},8,["disabled"]),k.exchangeKeys.length!==k.userInfo.EXCHANGE_KEYS.length||e.value!==rn(s)?(St(),Kt(_t,{key:0,disabled:!k.enabled,style:{margin:".25em"},color:"error",onClick:E[22]||(E[22]=j=>N())},{default:qe(()=>[ht("Cancel")]),_:1},8,["disabled"])):(St(),Kt(_t,{key:1,disabled:!k.enabled,style:{margin:".25em"},color:"error",onClick:E[23]||(E[23]=j=>k.editExchangeKeys=!k.editExchangeKeys)},{default:qe(()=>[ht("Close")]),_:1},8,["disabled"]))])])):Bt("",!0)]),_:1}),K(Zo,{cols:"auto"},{default:qe(()=>[k.editDiscordInfo?(St(),ya("div",UY,[$Y,K(Bh,{disabled:!k.enabled,label:"Discord Enabled",modelValue:k.discordEnabled,"onUpdate:modelValue":E[24]||(E[24]=j=>k.discordEnabled=j)},null,8,["disabled","modelValue"]),jY,K(lr,{disabled:!k.enabled,variant:"underlined",density:"compact",label:"Discord Channel ID",modelValue:k.discordChannelId,"onUpdate:modelValue":E[25]||(E[25]=j=>k.discordChannelId=j)},null,8,["disabled","modelValue"]),K(lr,{disabled:!k.enabled,variant:"underlined",density:"compact",label:"Discord Message ID",modelValue:k.discordMessageId,"onUpdate:modelValue":E[26]||(E[26]=j=>k.discordMessageId=j)},null,8,["disabled","modelValue"]),$s("p",null,[K(_t,{style:{margin:".25em"},color:"success",onClick:E[27]||(E[27]=j=>O()),disabled:!k.enabled||!(k.discordEnabled!==k.userInfo.DISCORD_ENABLED||k.discordChannelId!==k.userInfo.DISCORD_CHANNEL||k.discordMessageId!==k.userInfo.DISCORD_MESSAGE)},{default:qe(()=>[ht(" Save")]),_:1},8,["disabled"]),k.discordEnabled!==k.userInfo.DISCORD_ENABLED||k.discordChannelId!==k.userInfo.DISCORD_CHANNEL||k.discordMessageId!==k.userInfo.DISCORD_MESSAGE?(St(),Kt(_t,{key:0,disabled:!k.enabled,style:{margin:".25em"},color:"error",onClick:E[28]||(E[28]=j=>M())},{default:qe(()=>[ht(" Cancel")]),_:1},8,["disabled"])):Bt("",!0),k.discordEnabled===k.userInfo.DISCORD_ENABLED&&k.discordChannelId===k.userInfo.DISCORD_CHANNEL&&k.discordMessageId===k.userInfo.DISCORD_MESSAGE?(St(),Kt(_t,{key:1,disabled:!k.enabled,style:{margin:".25em"},color:"error",onClick:E[29]||(E[29]=j=>k.editDiscordInfo=!k.editDiscordInfo)},{default:qe(()=>[ht(" Close")]),_:1},8,["disabled"])):Bt("",!0)])])):Bt("",!0)]),_:1}),K(Zo,{cols:"auto"},{default:qe(()=>[h.value?(St(),ya("div",WY,[zY,K(Bh,{disabled:!k.enabled,label:"Twitch Enabled",modelValue:y.value,"onUpdate:modelValue":E[30]||(E[30]=j=>y.value=j)},null,8,["disabled","modelValue"]),K(Bh,{disabled:!k.enabled,label:"Timeout Enabled",modelValue:b.value,"onUpdate:modelValue":E[31]||(E[31]=j=>b.value=j)},null,8,["disabled","modelValue"]),K(lr,{disabled:!k.enabled,variant:"underlined",density:"compact",type:"number",label:"Timeout Length (minutes)",modelValue:k.twitchTimeoutLength,"onUpdate:modelValue":E[32]||(E[32]=j=>k.twitchTimeoutLength=j)},null,8,["disabled","modelValue"]),$s("p",null,[K(_t,{style:{margin:".25em"},color:"success",onClick:E[33]||(E[33]=j=>A()),disabled:!m.value||!(k.twitchEnabled!==S.value.TWITCH_ENABLED||b.value!==S.value.TWITCH_TIMEOUT||Number.parseFloat(w.value.toString())!==Number.parseFloat(S.value.TWITCH_TIMEOUT_EXPIRE.toString()))},{default:qe(()=>[ht(" Save")]),_:1},8,["disabled"]),k.twitchEnabled!==S.value.TWITCH_ENABLED||b.value!==S.value.TWITCH_TIMEOUT||Number.parseFloat(w.value.toString())!==Number.parseFloat(S.value.TWITCH_TIMEOUT_EXPIRE.toString())?(St(),Kt(_t,{key:0,disabled:!k.enabled,style:{margin:".25em"},color:"error",onClick:E[34]||(E[34]=j=>x())},{default:qe(()=>[ht(" Cancel")]),_:1},8,["disabled"])):Bt("",!0),y.value!==S.value.TWITCH_ENABLED||b.value!==S.value.TWITCH_TIMEOUT||Number.parseFloat(w.value.toString())!==Number.parseFloat(S.value.TWITCH_TIMEOUT_EXPIRE.toString())?Bt("",!0):(St(),Kt(_t,{key:1,disabled:!k.enabled,style:{margin:".25em"},color:"error",onClick:E[35]||(E[35]=j=>k.editTwitchInfo=!k.editTwitchInfo)},{default:qe(()=>[ht(" Close")]),_:1},8,["disabled"]))])])):Bt("",!0)]),_:1})]),_:1})):Bt("",!0)]),_:1})]),_:1})]),_:1})]),_:1}))}}),XY="modulepreload",YY=function(f){return"/"+f},ZO={},QY=function(e,t,s){if(!t||t.length===0)return e();const i=document.getElementsByTagName("link");return Promise.all(t.map(n=>{if(n=YY(n),n in ZO)return;ZO[n]=!0;const r=n.endsWith(".css"),a=r?'[rel="stylesheet"]':"";if(!!s)for(let c=i.length-1;c>=0;c--){const u=i[c];if(u.href===n&&(!r||u.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${n}"]${a}`))return;const d=document.createElement("link");if(d.rel=r?"stylesheet":XY,r||(d.as="script",d.crossOrigin=""),d.href=n,document.head.appendChild(d),r)return new Promise((c,u)=>{d.addEventListener("load",c),d.addEventListener("error",()=>u(new Error(`Unable to preload CSS for ${n}`)))})})).then(()=>e())};async function ZY(){(await QY(()=>import("./webfontloader.b777d690.js").then(e=>e.w),[])).load({google:{families:["Roboto:100,300,400,500,700,900&display=swap"]}})}function z2(){let f=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};const{blueprint:e,...t}=f,s=yr(e,t),{aliases:i={},components:n={},directives:r={}}=s,a=Qz(s.defaults),o=SY(s.display,s.ssr),d=yK(s.theme),c=BK(s.icons),u=TK(s.locale);return{install:l=>{for(const p in r)l.directive(p,r[p]);for(const p in n)l.component(p,n[p]);for(const p in i)l.component(p,Ye({...i[p],name:p,aliasName:i[p].name}));if(d.install(l),l.provide(ku,a),l.provide(Cy,o),l.provide(al,d),l.provide(Sy,c),l.provide(ol,u),os&&s.ssr)if(l.$nuxt)l.$nuxt.hook("app:suspense:resolve",()=>{o.update()});else{const{mount:p}=l;l.mount=function(){const m=p(...arguments);return _i(()=>o.update()),l.mount=p,m}}ln.reset(),l.mixin({computed:{$vuetify(){return Js({defaults:Qc.call(this,ku),display:Qc.call(this,Cy),theme:Qc.call(this,al),icons:Qc.call(this,Sy),locale:Qc.call(this,ol)})}}})},defaults:a,display:o,theme:d,icons:c,locale:u}}const JY="3.0.2";z2.version=JY;function Qc(f){var n;var e,t;const s=this.$,i=(n=(e=s.parent)==null?void 0:e.provides)!=null?n:(t=s.vnode.appContext)==null?void 0:t.provides;if(i&&f in i)return i[f]}const eQ=z2({theme:{themes:{light:{colors:{primary:"#1867C0",secondary:"#5CBBF6"}}}}});function tQ(f){ZY(),f.use(eQ)}const K2=IA(KY);tQ(K2);K2.mount("#app");
