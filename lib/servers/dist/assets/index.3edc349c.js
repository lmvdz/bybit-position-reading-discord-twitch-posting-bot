(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const n of i)if(n.type==="childList")for(const r of n.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&s(r)}).observe(document,{childList:!0,subtree:!0});function t(i){const n={};return i.integrity&&(n.integrity=i.integrity),i.referrerpolicy&&(n.referrerPolicy=i.referrerpolicy),i.crossorigin==="use-credentials"?n.credentials="include":i.crossorigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function s(i){if(i.ep)return;i.ep=!0;const n=t(i);fetch(i.href,n)}})();var Xh=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Ly(f){var e=f.default;if(typeof e=="function"){var t=function(){return e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(f).forEach(function(s){var i=Object.getOwnPropertyDescriptor(f,s);Object.defineProperty(t,s,i.get?i:{enumerable:!0,get:function(){return f[s]}})}),t}var pl={},ml={};ml.byteLength=iM;ml.toByteArray=rM;ml.fromByteArray=dM;var Zn=[],dn=[],tM=typeof Uint8Array<"u"?Uint8Array:Array,vp="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(var vo=0,sM=vp.length;vo<sM;++vo)Zn[vo]=vp[vo],dn[vp.charCodeAt(vo)]=vo;dn["-".charCodeAt(0)]=62;dn["_".charCodeAt(0)]=63;function fI(f){var e=f.length;if(e%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var t=f.indexOf("=");t===-1&&(t=e);var s=t===e?0:4-t%4;return[t,s]}function iM(f){var e=fI(f),t=e[0],s=e[1];return(t+s)*3/4-s}function nM(f,e,t){return(e+t)*3/4-t}function rM(f){var e,t=fI(f),s=t[0],i=t[1],n=new tM(nM(f,s,i)),r=0,a=i>0?s-4:s,o;for(o=0;o<a;o+=4)e=dn[f.charCodeAt(o)]<<18|dn[f.charCodeAt(o+1)]<<12|dn[f.charCodeAt(o+2)]<<6|dn[f.charCodeAt(o+3)],n[r++]=e>>16&255,n[r++]=e>>8&255,n[r++]=e&255;return i===2&&(e=dn[f.charCodeAt(o)]<<2|dn[f.charCodeAt(o+1)]>>4,n[r++]=e&255),i===1&&(e=dn[f.charCodeAt(o)]<<10|dn[f.charCodeAt(o+1)]<<4|dn[f.charCodeAt(o+2)]>>2,n[r++]=e>>8&255,n[r++]=e&255),n}function aM(f){return Zn[f>>18&63]+Zn[f>>12&63]+Zn[f>>6&63]+Zn[f&63]}function oM(f,e,t){for(var s,i=[],n=e;n<t;n+=3)s=(f[n]<<16&16711680)+(f[n+1]<<8&65280)+(f[n+2]&255),i.push(aM(s));return i.join("")}function dM(f){for(var e,t=f.length,s=t%3,i=[],n=16383,r=0,a=t-s;r<a;r+=n)i.push(oM(f,r,r+n>a?a:r+n));return s===1?(e=f[t-1],i.push(Zn[e>>2]+Zn[e<<4&63]+"==")):s===2&&(e=(f[t-2]<<8)+f[t-1],i.push(Zn[e>>10]+Zn[e>>4&63]+Zn[e<<2&63]+"=")),i.join("")}var Ry={};/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */Ry.read=function(f,e,t,s,i){var n,r,a=i*8-s-1,o=(1<<a)-1,d=o>>1,c=-7,u=t?i-1:0,h=t?-1:1,l=f[e+u];for(u+=h,n=l&(1<<-c)-1,l>>=-c,c+=a;c>0;n=n*256+f[e+u],u+=h,c-=8);for(r=n&(1<<-c)-1,n>>=-c,c+=s;c>0;r=r*256+f[e+u],u+=h,c-=8);if(n===0)n=1-d;else{if(n===o)return r?NaN:(l?-1:1)*(1/0);r=r+Math.pow(2,s),n=n-d}return(l?-1:1)*r*Math.pow(2,n-s)};Ry.write=function(f,e,t,s,i,n){var r,a,o,d=n*8-i-1,c=(1<<d)-1,u=c>>1,h=i===23?Math.pow(2,-24)-Math.pow(2,-77):0,l=s?0:n-1,p=s?1:-1,m=e<0||e===0&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(a=isNaN(e)?1:0,r=c):(r=Math.floor(Math.log(e)/Math.LN2),e*(o=Math.pow(2,-r))<1&&(r--,o*=2),r+u>=1?e+=h/o:e+=h*Math.pow(2,1-u),e*o>=2&&(r++,o/=2),r+u>=c?(a=0,r=c):r+u>=1?(a=(e*o-1)*Math.pow(2,i),r=r+u):(a=e*Math.pow(2,u-1)*Math.pow(2,i),r=0));i>=8;f[t+l]=a&255,l+=p,a/=256,i-=8);for(r=r<<i|a,d+=i;d>0;f[t+l]=r&255,l+=p,r/=256,d-=8);f[t+l-p]|=m*128};/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */(function(f){const e=ml,t=Ry,s=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;f.Buffer=a,f.SlowBuffer=b,f.INSPECT_MAX_BYTES=50;const i=2147483647;f.kMaxLength=i,a.TYPED_ARRAY_SUPPORT=n(),!a.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function n(){try{const L=new Uint8Array(1),M={foo:function(){return 42}};return Object.setPrototypeOf(M,Uint8Array.prototype),Object.setPrototypeOf(L,M),L.foo()===42}catch{return!1}}Object.defineProperty(a.prototype,"parent",{enumerable:!0,get:function(){if(!!a.isBuffer(this))return this.buffer}}),Object.defineProperty(a.prototype,"offset",{enumerable:!0,get:function(){if(!!a.isBuffer(this))return this.byteOffset}});function r(L){if(L>i)throw new RangeError('The value "'+L+'" is invalid for option "size"');const M=new Uint8Array(L);return Object.setPrototypeOf(M,a.prototype),M}function a(L,M,B){if(typeof L=="number"){if(typeof M=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return u(L)}return o(L,M,B)}a.poolSize=8192;function o(L,M,B){if(typeof L=="string")return h(L,M);if(ArrayBuffer.isView(L))return p(L);if(L==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof L);if(ce(L,ArrayBuffer)||L&&ce(L.buffer,ArrayBuffer)||typeof SharedArrayBuffer<"u"&&(ce(L,SharedArrayBuffer)||L&&ce(L.buffer,SharedArrayBuffer)))return m(L,M,B);if(typeof L=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const K=L.valueOf&&L.valueOf();if(K!=null&&K!==L)return a.from(K,M,B);const Z=g(L);if(Z)return Z;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof L[Symbol.toPrimitive]=="function")return a.from(L[Symbol.toPrimitive]("string"),M,B);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof L)}a.from=function(L,M,B){return o(L,M,B)},Object.setPrototypeOf(a.prototype,Uint8Array.prototype),Object.setPrototypeOf(a,Uint8Array);function d(L){if(typeof L!="number")throw new TypeError('"size" argument must be of type number');if(L<0)throw new RangeError('The value "'+L+'" is invalid for option "size"')}function c(L,M,B){return d(L),L<=0?r(L):M!==void 0?typeof B=="string"?r(L).fill(M,B):r(L).fill(M):r(L)}a.alloc=function(L,M,B){return c(L,M,B)};function u(L){return d(L),r(L<0?0:y(L)|0)}a.allocUnsafe=function(L){return u(L)},a.allocUnsafeSlow=function(L){return u(L)};function h(L,M){if((typeof M!="string"||M==="")&&(M="utf8"),!a.isEncoding(M))throw new TypeError("Unknown encoding: "+M);const B=w(L,M)|0;let K=r(B);const Z=K.write(L,M);return Z!==B&&(K=K.slice(0,Z)),K}function l(L){const M=L.length<0?0:y(L.length)|0,B=r(M);for(let K=0;K<M;K+=1)B[K]=L[K]&255;return B}function p(L){if(ce(L,Uint8Array)){const M=new Uint8Array(L);return m(M.buffer,M.byteOffset,M.byteLength)}return l(L)}function m(L,M,B){if(M<0||L.byteLength<M)throw new RangeError('"offset" is outside of buffer bounds');if(L.byteLength<M+(B||0))throw new RangeError('"length" is outside of buffer bounds');let K;return M===void 0&&B===void 0?K=new Uint8Array(L):B===void 0?K=new Uint8Array(L,M):K=new Uint8Array(L,M,B),Object.setPrototypeOf(K,a.prototype),K}function g(L){if(a.isBuffer(L)){const M=y(L.length)|0,B=r(M);return B.length===0||L.copy(B,0,0,M),B}if(L.length!==void 0)return typeof L.length!="number"||ke(L.length)?r(0):l(L);if(L.type==="Buffer"&&Array.isArray(L.data))return l(L.data)}function y(L){if(L>=i)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+i.toString(16)+" bytes");return L|0}function b(L){return+L!=L&&(L=0),a.alloc(+L)}a.isBuffer=function(M){return M!=null&&M._isBuffer===!0&&M!==a.prototype},a.compare=function(M,B){if(ce(M,Uint8Array)&&(M=a.from(M,M.offset,M.byteLength)),ce(B,Uint8Array)&&(B=a.from(B,B.offset,B.byteLength)),!a.isBuffer(M)||!a.isBuffer(B))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(M===B)return 0;let K=M.length,Z=B.length;for(let re=0,ae=Math.min(K,Z);re<ae;++re)if(M[re]!==B[re]){K=M[re],Z=B[re];break}return K<Z?-1:Z<K?1:0},a.isEncoding=function(M){switch(String(M).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},a.concat=function(M,B){if(!Array.isArray(M))throw new TypeError('"list" argument must be an Array of Buffers');if(M.length===0)return a.alloc(0);let K;if(B===void 0)for(B=0,K=0;K<M.length;++K)B+=M[K].length;const Z=a.allocUnsafe(B);let re=0;for(K=0;K<M.length;++K){let ae=M[K];if(ce(ae,Uint8Array))re+ae.length>Z.length?(a.isBuffer(ae)||(ae=a.from(ae)),ae.copy(Z,re)):Uint8Array.prototype.set.call(Z,ae,re);else if(a.isBuffer(ae))ae.copy(Z,re);else throw new TypeError('"list" argument must be an Array of Buffers');re+=ae.length}return Z};function w(L,M){if(a.isBuffer(L))return L.length;if(ArrayBuffer.isView(L)||ce(L,ArrayBuffer))return L.byteLength;if(typeof L!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof L);const B=L.length,K=arguments.length>2&&arguments[2]===!0;if(!K&&B===0)return 0;let Z=!1;for(;;)switch(M){case"ascii":case"latin1":case"binary":return B;case"utf8":case"utf-8":return Y(L).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return B*2;case"hex":return B>>>1;case"base64":return ne(L).length;default:if(Z)return K?-1:Y(L).length;M=(""+M).toLowerCase(),Z=!0}}a.byteLength=w;function k(L,M,B){let K=!1;if((M===void 0||M<0)&&(M=0),M>this.length||((B===void 0||B>this.length)&&(B=this.length),B<=0)||(B>>>=0,M>>>=0,B<=M))return"";for(L||(L="utf8");;)switch(L){case"hex":return F(this,M,B);case"utf8":case"utf-8":return v(this,M,B);case"ascii":return R(this,M,B);case"latin1":case"binary":return G(this,M,B);case"base64":return I(this,M,B);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return A(this,M,B);default:if(K)throw new TypeError("Unknown encoding: "+L);L=(L+"").toLowerCase(),K=!0}}a.prototype._isBuffer=!0;function T(L,M,B){const K=L[M];L[M]=L[B],L[B]=K}a.prototype.swap16=function(){const M=this.length;if(M%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let B=0;B<M;B+=2)T(this,B,B+1);return this},a.prototype.swap32=function(){const M=this.length;if(M%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let B=0;B<M;B+=4)T(this,B,B+3),T(this,B+1,B+2);return this},a.prototype.swap64=function(){const M=this.length;if(M%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let B=0;B<M;B+=8)T(this,B,B+7),T(this,B+1,B+6),T(this,B+2,B+5),T(this,B+3,B+4);return this},a.prototype.toString=function(){const M=this.length;return M===0?"":arguments.length===0?v(this,0,M):k.apply(this,arguments)},a.prototype.toLocaleString=a.prototype.toString,a.prototype.equals=function(M){if(!a.isBuffer(M))throw new TypeError("Argument must be a Buffer");return this===M?!0:a.compare(this,M)===0},a.prototype.inspect=function(){let M="";const B=f.INSPECT_MAX_BYTES;return M=this.toString("hex",0,B).replace(/(.{2})/g,"$1 ").trim(),this.length>B&&(M+=" ... "),"<Buffer "+M+">"},s&&(a.prototype[s]=a.prototype.inspect),a.prototype.compare=function(M,B,K,Z,re){if(ce(M,Uint8Array)&&(M=a.from(M,M.offset,M.byteLength)),!a.isBuffer(M))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof M);if(B===void 0&&(B=0),K===void 0&&(K=M?M.length:0),Z===void 0&&(Z=0),re===void 0&&(re=this.length),B<0||K>M.length||Z<0||re>this.length)throw new RangeError("out of range index");if(Z>=re&&B>=K)return 0;if(Z>=re)return-1;if(B>=K)return 1;if(B>>>=0,K>>>=0,Z>>>=0,re>>>=0,this===M)return 0;let ae=re-Z,Ee=K-B;const We=Math.min(ae,Ee),Ne=this.slice(Z,re),De=M.slice(B,K);for(let ut=0;ut<We;++ut)if(Ne[ut]!==De[ut]){ae=Ne[ut],Ee=De[ut];break}return ae<Ee?-1:Ee<ae?1:0};function O(L,M,B,K,Z){if(L.length===0)return-1;if(typeof B=="string"?(K=B,B=0):B>2147483647?B=2147483647:B<-2147483648&&(B=-2147483648),B=+B,ke(B)&&(B=Z?0:L.length-1),B<0&&(B=L.length+B),B>=L.length){if(Z)return-1;B=L.length-1}else if(B<0)if(Z)B=0;else return-1;if(typeof M=="string"&&(M=a.from(M,K)),a.isBuffer(M))return M.length===0?-1:x(L,M,B,K,Z);if(typeof M=="number")return M=M&255,typeof Uint8Array.prototype.indexOf=="function"?Z?Uint8Array.prototype.indexOf.call(L,M,B):Uint8Array.prototype.lastIndexOf.call(L,M,B):x(L,[M],B,K,Z);throw new TypeError("val must be string, number or Buffer")}function x(L,M,B,K,Z){let re=1,ae=L.length,Ee=M.length;if(K!==void 0&&(K=String(K).toLowerCase(),K==="ucs2"||K==="ucs-2"||K==="utf16le"||K==="utf-16le")){if(L.length<2||M.length<2)return-1;re=2,ae/=2,Ee/=2,B/=2}function We(De,ut){return re===1?De[ut]:De.readUInt16BE(ut*re)}let Ne;if(Z){let De=-1;for(Ne=B;Ne<ae;Ne++)if(We(L,Ne)===We(M,De===-1?0:Ne-De)){if(De===-1&&(De=Ne),Ne-De+1===Ee)return De*re}else De!==-1&&(Ne-=Ne-De),De=-1}else for(B+Ee>ae&&(B=ae-Ee),Ne=B;Ne>=0;Ne--){let De=!0;for(let ut=0;ut<Ee;ut++)if(We(L,Ne+ut)!==We(M,ut)){De=!1;break}if(De)return Ne}return-1}a.prototype.includes=function(M,B,K){return this.indexOf(M,B,K)!==-1},a.prototype.indexOf=function(M,B,K){return O(this,M,B,K,!0)},a.prototype.lastIndexOf=function(M,B,K){return O(this,M,B,K,!1)};function C(L,M,B,K){B=Number(B)||0;const Z=L.length-B;K?(K=Number(K),K>Z&&(K=Z)):K=Z;const re=M.length;K>re/2&&(K=re/2);let ae;for(ae=0;ae<K;++ae){const Ee=parseInt(M.substr(ae*2,2),16);if(ke(Ee))return ae;L[B+ae]=Ee}return ae}function E(L,M,B,K){return te(Y(M,L.length-B),L,B,K)}function P(L,M,B,K){return te(z(M),L,B,K)}function _(L,M,B,K){return te(ne(M),L,B,K)}function S(L,M,B,K){return te(X(M,L.length-B),L,B,K)}a.prototype.write=function(M,B,K,Z){if(B===void 0)Z="utf8",K=this.length,B=0;else if(K===void 0&&typeof B=="string")Z=B,K=this.length,B=0;else if(isFinite(B))B=B>>>0,isFinite(K)?(K=K>>>0,Z===void 0&&(Z="utf8")):(Z=K,K=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const re=this.length-B;if((K===void 0||K>re)&&(K=re),M.length>0&&(K<0||B<0)||B>this.length)throw new RangeError("Attempt to write outside buffer bounds");Z||(Z="utf8");let ae=!1;for(;;)switch(Z){case"hex":return C(this,M,B,K);case"utf8":case"utf-8":return E(this,M,B,K);case"ascii":case"latin1":case"binary":return P(this,M,B,K);case"base64":return _(this,M,B,K);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return S(this,M,B,K);default:if(ae)throw new TypeError("Unknown encoding: "+Z);Z=(""+Z).toLowerCase(),ae=!0}},a.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function I(L,M,B){return M===0&&B===L.length?e.fromByteArray(L):e.fromByteArray(L.slice(M,B))}function v(L,M,B){B=Math.min(L.length,B);const K=[];let Z=M;for(;Z<B;){const re=L[Z];let ae=null,Ee=re>239?4:re>223?3:re>191?2:1;if(Z+Ee<=B){let We,Ne,De,ut;switch(Ee){case 1:re<128&&(ae=re);break;case 2:We=L[Z+1],(We&192)===128&&(ut=(re&31)<<6|We&63,ut>127&&(ae=ut));break;case 3:We=L[Z+1],Ne=L[Z+2],(We&192)===128&&(Ne&192)===128&&(ut=(re&15)<<12|(We&63)<<6|Ne&63,ut>2047&&(ut<55296||ut>57343)&&(ae=ut));break;case 4:We=L[Z+1],Ne=L[Z+2],De=L[Z+3],(We&192)===128&&(Ne&192)===128&&(De&192)===128&&(ut=(re&15)<<18|(We&63)<<12|(Ne&63)<<6|De&63,ut>65535&&ut<1114112&&(ae=ut))}}ae===null?(ae=65533,Ee=1):ae>65535&&(ae-=65536,K.push(ae>>>10&1023|55296),ae=56320|ae&1023),K.push(ae),Z+=Ee}return q(K)}const N=4096;function q(L){const M=L.length;if(M<=N)return String.fromCharCode.apply(String,L);let B="",K=0;for(;K<M;)B+=String.fromCharCode.apply(String,L.slice(K,K+=N));return B}function R(L,M,B){let K="";B=Math.min(L.length,B);for(let Z=M;Z<B;++Z)K+=String.fromCharCode(L[Z]&127);return K}function G(L,M,B){let K="";B=Math.min(L.length,B);for(let Z=M;Z<B;++Z)K+=String.fromCharCode(L[Z]);return K}function F(L,M,B){const K=L.length;(!M||M<0)&&(M=0),(!B||B<0||B>K)&&(B=K);let Z="";for(let re=M;re<B;++re)Z+=ue[L[re]];return Z}function A(L,M,B){const K=L.slice(M,B);let Z="";for(let re=0;re<K.length-1;re+=2)Z+=String.fromCharCode(K[re]+K[re+1]*256);return Z}a.prototype.slice=function(M,B){const K=this.length;M=~~M,B=B===void 0?K:~~B,M<0?(M+=K,M<0&&(M=0)):M>K&&(M=K),B<0?(B+=K,B<0&&(B=0)):B>K&&(B=K),B<M&&(B=M);const Z=this.subarray(M,B);return Object.setPrototypeOf(Z,a.prototype),Z};function V(L,M,B){if(L%1!==0||L<0)throw new RangeError("offset is not uint");if(L+M>B)throw new RangeError("Trying to access beyond buffer length")}a.prototype.readUintLE=a.prototype.readUIntLE=function(M,B,K){M=M>>>0,B=B>>>0,K||V(M,B,this.length);let Z=this[M],re=1,ae=0;for(;++ae<B&&(re*=256);)Z+=this[M+ae]*re;return Z},a.prototype.readUintBE=a.prototype.readUIntBE=function(M,B,K){M=M>>>0,B=B>>>0,K||V(M,B,this.length);let Z=this[M+--B],re=1;for(;B>0&&(re*=256);)Z+=this[M+--B]*re;return Z},a.prototype.readUint8=a.prototype.readUInt8=function(M,B){return M=M>>>0,B||V(M,1,this.length),this[M]},a.prototype.readUint16LE=a.prototype.readUInt16LE=function(M,B){return M=M>>>0,B||V(M,2,this.length),this[M]|this[M+1]<<8},a.prototype.readUint16BE=a.prototype.readUInt16BE=function(M,B){return M=M>>>0,B||V(M,2,this.length),this[M]<<8|this[M+1]},a.prototype.readUint32LE=a.prototype.readUInt32LE=function(M,B){return M=M>>>0,B||V(M,4,this.length),(this[M]|this[M+1]<<8|this[M+2]<<16)+this[M+3]*16777216},a.prototype.readUint32BE=a.prototype.readUInt32BE=function(M,B){return M=M>>>0,B||V(M,4,this.length),this[M]*16777216+(this[M+1]<<16|this[M+2]<<8|this[M+3])},a.prototype.readBigUInt64LE=Ie(function(M){M=M>>>0,j(M,"offset");const B=this[M],K=this[M+7];(B===void 0||K===void 0)&&U(M,this.length-8);const Z=B+this[++M]*2**8+this[++M]*2**16+this[++M]*2**24,re=this[++M]+this[++M]*2**8+this[++M]*2**16+K*2**24;return BigInt(Z)+(BigInt(re)<<BigInt(32))}),a.prototype.readBigUInt64BE=Ie(function(M){M=M>>>0,j(M,"offset");const B=this[M],K=this[M+7];(B===void 0||K===void 0)&&U(M,this.length-8);const Z=B*2**24+this[++M]*2**16+this[++M]*2**8+this[++M],re=this[++M]*2**24+this[++M]*2**16+this[++M]*2**8+K;return(BigInt(Z)<<BigInt(32))+BigInt(re)}),a.prototype.readIntLE=function(M,B,K){M=M>>>0,B=B>>>0,K||V(M,B,this.length);let Z=this[M],re=1,ae=0;for(;++ae<B&&(re*=256);)Z+=this[M+ae]*re;return re*=128,Z>=re&&(Z-=Math.pow(2,8*B)),Z},a.prototype.readIntBE=function(M,B,K){M=M>>>0,B=B>>>0,K||V(M,B,this.length);let Z=B,re=1,ae=this[M+--Z];for(;Z>0&&(re*=256);)ae+=this[M+--Z]*re;return re*=128,ae>=re&&(ae-=Math.pow(2,8*B)),ae},a.prototype.readInt8=function(M,B){return M=M>>>0,B||V(M,1,this.length),this[M]&128?(255-this[M]+1)*-1:this[M]},a.prototype.readInt16LE=function(M,B){M=M>>>0,B||V(M,2,this.length);const K=this[M]|this[M+1]<<8;return K&32768?K|4294901760:K},a.prototype.readInt16BE=function(M,B){M=M>>>0,B||V(M,2,this.length);const K=this[M+1]|this[M]<<8;return K&32768?K|4294901760:K},a.prototype.readInt32LE=function(M,B){return M=M>>>0,B||V(M,4,this.length),this[M]|this[M+1]<<8|this[M+2]<<16|this[M+3]<<24},a.prototype.readInt32BE=function(M,B){return M=M>>>0,B||V(M,4,this.length),this[M]<<24|this[M+1]<<16|this[M+2]<<8|this[M+3]},a.prototype.readBigInt64LE=Ie(function(M){M=M>>>0,j(M,"offset");const B=this[M],K=this[M+7];(B===void 0||K===void 0)&&U(M,this.length-8);const Z=this[M+4]+this[M+5]*2**8+this[M+6]*2**16+(K<<24);return(BigInt(Z)<<BigInt(32))+BigInt(B+this[++M]*2**8+this[++M]*2**16+this[++M]*2**24)}),a.prototype.readBigInt64BE=Ie(function(M){M=M>>>0,j(M,"offset");const B=this[M],K=this[M+7];(B===void 0||K===void 0)&&U(M,this.length-8);const Z=(B<<24)+this[++M]*2**16+this[++M]*2**8+this[++M];return(BigInt(Z)<<BigInt(32))+BigInt(this[++M]*2**24+this[++M]*2**16+this[++M]*2**8+K)}),a.prototype.readFloatLE=function(M,B){return M=M>>>0,B||V(M,4,this.length),t.read(this,M,!0,23,4)},a.prototype.readFloatBE=function(M,B){return M=M>>>0,B||V(M,4,this.length),t.read(this,M,!1,23,4)},a.prototype.readDoubleLE=function(M,B){return M=M>>>0,B||V(M,8,this.length),t.read(this,M,!0,52,8)},a.prototype.readDoubleBE=function(M,B){return M=M>>>0,B||V(M,8,this.length),t.read(this,M,!1,52,8)};function Q(L,M,B,K,Z,re){if(!a.isBuffer(L))throw new TypeError('"buffer" argument must be a Buffer instance');if(M>Z||M<re)throw new RangeError('"value" argument is out of bounds');if(B+K>L.length)throw new RangeError("Index out of range")}a.prototype.writeUintLE=a.prototype.writeUIntLE=function(M,B,K,Z){if(M=+M,B=B>>>0,K=K>>>0,!Z){const Ee=Math.pow(2,8*K)-1;Q(this,M,B,K,Ee,0)}let re=1,ae=0;for(this[B]=M&255;++ae<K&&(re*=256);)this[B+ae]=M/re&255;return B+K},a.prototype.writeUintBE=a.prototype.writeUIntBE=function(M,B,K,Z){if(M=+M,B=B>>>0,K=K>>>0,!Z){const Ee=Math.pow(2,8*K)-1;Q(this,M,B,K,Ee,0)}let re=K-1,ae=1;for(this[B+re]=M&255;--re>=0&&(ae*=256);)this[B+re]=M/ae&255;return B+K},a.prototype.writeUint8=a.prototype.writeUInt8=function(M,B,K){return M=+M,B=B>>>0,K||Q(this,M,B,1,255,0),this[B]=M&255,B+1},a.prototype.writeUint16LE=a.prototype.writeUInt16LE=function(M,B,K){return M=+M,B=B>>>0,K||Q(this,M,B,2,65535,0),this[B]=M&255,this[B+1]=M>>>8,B+2},a.prototype.writeUint16BE=a.prototype.writeUInt16BE=function(M,B,K){return M=+M,B=B>>>0,K||Q(this,M,B,2,65535,0),this[B]=M>>>8,this[B+1]=M&255,B+2},a.prototype.writeUint32LE=a.prototype.writeUInt32LE=function(M,B,K){return M=+M,B=B>>>0,K||Q(this,M,B,4,4294967295,0),this[B+3]=M>>>24,this[B+2]=M>>>16,this[B+1]=M>>>8,this[B]=M&255,B+4},a.prototype.writeUint32BE=a.prototype.writeUInt32BE=function(M,B,K){return M=+M,B=B>>>0,K||Q(this,M,B,4,4294967295,0),this[B]=M>>>24,this[B+1]=M>>>16,this[B+2]=M>>>8,this[B+3]=M&255,B+4};function J(L,M,B,K,Z){D(M,K,Z,L,B,7);let re=Number(M&BigInt(4294967295));L[B++]=re,re=re>>8,L[B++]=re,re=re>>8,L[B++]=re,re=re>>8,L[B++]=re;let ae=Number(M>>BigInt(32)&BigInt(4294967295));return L[B++]=ae,ae=ae>>8,L[B++]=ae,ae=ae>>8,L[B++]=ae,ae=ae>>8,L[B++]=ae,B}function se(L,M,B,K,Z){D(M,K,Z,L,B,7);let re=Number(M&BigInt(4294967295));L[B+7]=re,re=re>>8,L[B+6]=re,re=re>>8,L[B+5]=re,re=re>>8,L[B+4]=re;let ae=Number(M>>BigInt(32)&BigInt(4294967295));return L[B+3]=ae,ae=ae>>8,L[B+2]=ae,ae=ae>>8,L[B+1]=ae,ae=ae>>8,L[B]=ae,B+8}a.prototype.writeBigUInt64LE=Ie(function(M,B=0){return J(this,M,B,BigInt(0),BigInt("0xffffffffffffffff"))}),a.prototype.writeBigUInt64BE=Ie(function(M,B=0){return se(this,M,B,BigInt(0),BigInt("0xffffffffffffffff"))}),a.prototype.writeIntLE=function(M,B,K,Z){if(M=+M,B=B>>>0,!Z){const We=Math.pow(2,8*K-1);Q(this,M,B,K,We-1,-We)}let re=0,ae=1,Ee=0;for(this[B]=M&255;++re<K&&(ae*=256);)M<0&&Ee===0&&this[B+re-1]!==0&&(Ee=1),this[B+re]=(M/ae>>0)-Ee&255;return B+K},a.prototype.writeIntBE=function(M,B,K,Z){if(M=+M,B=B>>>0,!Z){const We=Math.pow(2,8*K-1);Q(this,M,B,K,We-1,-We)}let re=K-1,ae=1,Ee=0;for(this[B+re]=M&255;--re>=0&&(ae*=256);)M<0&&Ee===0&&this[B+re+1]!==0&&(Ee=1),this[B+re]=(M/ae>>0)-Ee&255;return B+K},a.prototype.writeInt8=function(M,B,K){return M=+M,B=B>>>0,K||Q(this,M,B,1,127,-128),M<0&&(M=255+M+1),this[B]=M&255,B+1},a.prototype.writeInt16LE=function(M,B,K){return M=+M,B=B>>>0,K||Q(this,M,B,2,32767,-32768),this[B]=M&255,this[B+1]=M>>>8,B+2},a.prototype.writeInt16BE=function(M,B,K){return M=+M,B=B>>>0,K||Q(this,M,B,2,32767,-32768),this[B]=M>>>8,this[B+1]=M&255,B+2},a.prototype.writeInt32LE=function(M,B,K){return M=+M,B=B>>>0,K||Q(this,M,B,4,2147483647,-2147483648),this[B]=M&255,this[B+1]=M>>>8,this[B+2]=M>>>16,this[B+3]=M>>>24,B+4},a.prototype.writeInt32BE=function(M,B,K){return M=+M,B=B>>>0,K||Q(this,M,B,4,2147483647,-2147483648),M<0&&(M=4294967295+M+1),this[B]=M>>>24,this[B+1]=M>>>16,this[B+2]=M>>>8,this[B+3]=M&255,B+4},a.prototype.writeBigInt64LE=Ie(function(M,B=0){return J(this,M,B,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),a.prototype.writeBigInt64BE=Ie(function(M,B=0){return se(this,M,B,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function we(L,M,B,K,Z,re){if(B+K>L.length)throw new RangeError("Index out of range");if(B<0)throw new RangeError("Index out of range")}function le(L,M,B,K,Z){return M=+M,B=B>>>0,Z||we(L,M,B,4),t.write(L,M,B,K,23,4),B+4}a.prototype.writeFloatLE=function(M,B,K){return le(this,M,B,!0,K)},a.prototype.writeFloatBE=function(M,B,K){return le(this,M,B,!1,K)};function Oe(L,M,B,K,Z){return M=+M,B=B>>>0,Z||we(L,M,B,8),t.write(L,M,B,K,52,8),B+8}a.prototype.writeDoubleLE=function(M,B,K){return Oe(this,M,B,!0,K)},a.prototype.writeDoubleBE=function(M,B,K){return Oe(this,M,B,!1,K)},a.prototype.copy=function(M,B,K,Z){if(!a.isBuffer(M))throw new TypeError("argument should be a Buffer");if(K||(K=0),!Z&&Z!==0&&(Z=this.length),B>=M.length&&(B=M.length),B||(B=0),Z>0&&Z<K&&(Z=K),Z===K||M.length===0||this.length===0)return 0;if(B<0)throw new RangeError("targetStart out of bounds");if(K<0||K>=this.length)throw new RangeError("Index out of range");if(Z<0)throw new RangeError("sourceEnd out of bounds");Z>this.length&&(Z=this.length),M.length-B<Z-K&&(Z=M.length-B+K);const re=Z-K;return this===M&&typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin(B,K,Z):Uint8Array.prototype.set.call(M,this.subarray(K,Z),B),re},a.prototype.fill=function(M,B,K,Z){if(typeof M=="string"){if(typeof B=="string"?(Z=B,B=0,K=this.length):typeof K=="string"&&(Z=K,K=this.length),Z!==void 0&&typeof Z!="string")throw new TypeError("encoding must be a string");if(typeof Z=="string"&&!a.isEncoding(Z))throw new TypeError("Unknown encoding: "+Z);if(M.length===1){const ae=M.charCodeAt(0);(Z==="utf8"&&ae<128||Z==="latin1")&&(M=ae)}}else typeof M=="number"?M=M&255:typeof M=="boolean"&&(M=Number(M));if(B<0||this.length<B||this.length<K)throw new RangeError("Out of range index");if(K<=B)return this;B=B>>>0,K=K===void 0?this.length:K>>>0,M||(M=0);let re;if(typeof M=="number")for(re=B;re<K;++re)this[re]=M;else{const ae=a.isBuffer(M)?M:a.from(M,Z),Ee=ae.length;if(Ee===0)throw new TypeError('The value "'+M+'" is invalid for argument "value"');for(re=0;re<K-B;++re)this[re+B]=ae[re%Ee]}return this};const Ce={};function Le(L,M,B){Ce[L]=class extends B{constructor(){super(),Object.defineProperty(this,"message",{value:M.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${L}]`,this.stack,delete this.name}get code(){return L}set code(Z){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:Z,writable:!0})}toString(){return`${this.name} [${L}]: ${this.message}`}}}Le("ERR_BUFFER_OUT_OF_BOUNDS",function(L){return L?`${L} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),Le("ERR_INVALID_ARG_TYPE",function(L,M){return`The "${L}" argument must be of type number. Received type ${typeof M}`},TypeError),Le("ERR_OUT_OF_RANGE",function(L,M,B){let K=`The value of "${L}" is out of range.`,Z=B;return Number.isInteger(B)&&Math.abs(B)>2**32?Z=Fe(String(B)):typeof B=="bigint"&&(Z=String(B),(B>BigInt(2)**BigInt(32)||B<-(BigInt(2)**BigInt(32)))&&(Z=Fe(Z)),Z+="n"),K+=` It must be ${M}. Received ${Z}`,K},RangeError);function Fe(L){let M="",B=L.length;const K=L[0]==="-"?1:0;for(;B>=K+4;B-=3)M=`_${L.slice(B-3,B)}${M}`;return`${L.slice(0,B)}${M}`}function At(L,M,B){j(M,"offset"),(L[M]===void 0||L[M+B]===void 0)&&U(M,L.length-(B+1))}function D(L,M,B,K,Z,re){if(L>B||L<M){const ae=typeof M=="bigint"?"n":"";let Ee;throw re>3?M===0||M===BigInt(0)?Ee=`>= 0${ae} and < 2${ae} ** ${(re+1)*8}${ae}`:Ee=`>= -(2${ae} ** ${(re+1)*8-1}${ae}) and < 2 ** ${(re+1)*8-1}${ae}`:Ee=`>= ${M}${ae} and <= ${B}${ae}`,new Ce.ERR_OUT_OF_RANGE("value",Ee,L)}At(K,Z,re)}function j(L,M){if(typeof L!="number")throw new Ce.ERR_INVALID_ARG_TYPE(M,"number",L)}function U(L,M,B){throw Math.floor(L)!==L?(j(L,B),new Ce.ERR_OUT_OF_RANGE(B||"offset","an integer",L)):M<0?new Ce.ERR_BUFFER_OUT_OF_BOUNDS:new Ce.ERR_OUT_OF_RANGE(B||"offset",`>= ${B?1:0} and <= ${M}`,L)}const H=/[^+/0-9A-Za-z-_]/g;function W(L){if(L=L.split("=")[0],L=L.trim().replace(H,""),L.length<2)return"";for(;L.length%4!==0;)L=L+"=";return L}function Y(L,M){M=M||1/0;let B;const K=L.length;let Z=null;const re=[];for(let ae=0;ae<K;++ae){if(B=L.charCodeAt(ae),B>55295&&B<57344){if(!Z){if(B>56319){(M-=3)>-1&&re.push(239,191,189);continue}else if(ae+1===K){(M-=3)>-1&&re.push(239,191,189);continue}Z=B;continue}if(B<56320){(M-=3)>-1&&re.push(239,191,189),Z=B;continue}B=(Z-55296<<10|B-56320)+65536}else Z&&(M-=3)>-1&&re.push(239,191,189);if(Z=null,B<128){if((M-=1)<0)break;re.push(B)}else if(B<2048){if((M-=2)<0)break;re.push(B>>6|192,B&63|128)}else if(B<65536){if((M-=3)<0)break;re.push(B>>12|224,B>>6&63|128,B&63|128)}else if(B<1114112){if((M-=4)<0)break;re.push(B>>18|240,B>>12&63|128,B>>6&63|128,B&63|128)}else throw new Error("Invalid code point")}return re}function z(L){const M=[];for(let B=0;B<L.length;++B)M.push(L.charCodeAt(B)&255);return M}function X(L,M){let B,K,Z;const re=[];for(let ae=0;ae<L.length&&!((M-=2)<0);++ae)B=L.charCodeAt(ae),K=B>>8,Z=B%256,re.push(Z),re.push(K);return re}function ne(L){return e.toByteArray(W(L))}function te(L,M,B,K){let Z;for(Z=0;Z<K&&!(Z+B>=M.length||Z>=L.length);++Z)M[Z+B]=L[Z];return Z}function ce(L,M){return L instanceof M||L!=null&&L.constructor!=null&&L.constructor.name!=null&&L.constructor.name===M.name}function ke(L){return L!==L}const ue=function(){const L="0123456789abcdef",M=new Array(256);for(let B=0;B<16;++B){const K=B*16;for(let Z=0;Z<16;++Z)M[K+Z]=L[B]+L[Z]}return M}();function Ie(L){return typeof BigInt>"u"?Pe:L}function Pe(){throw new Error("BigInt not supported")}})(pl);window.Buffer=pl.Buffer;function Fy(f,e){const t=Object.create(null),s=f.split(",");for(let i=0;i<s.length;i++)t[s[i]]=!0;return e?i=>!!t[i.toLowerCase()]:i=>!!t[i]}function Pi(f){if(Ue(f)){const e={};for(let t=0;t<f.length;t++){const s=f[t],i=gs(s)?hM(s):Pi(s);if(i)for(const n in i)e[n]=i[n]}return e}else{if(gs(f))return f;if(qt(f))return f}}const cM=/;(?![^(]*\))/g,uM=/:([^]+)/,fM=/\/\*.*?\*\//gs;function hM(f){const e={};return f.replace(fM,"").split(cM).forEach(t=>{if(t){const s=t.split(uM);s.length>1&&(e[s[0].trim()]=s[1].trim())}}),e}function Dy(f){let e="";if(gs(f))e=f;else if(Ue(f))for(let t=0;t<f.length;t++){const s=Dy(f[t]);s&&(e+=s+" ")}else if(qt(f))for(const t in f)f[t]&&(e+=t+" ");return e.trim()}const lM="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",pM=Fy(lM);function hI(f){return!!f||f===""}const To=f=>gs(f)?f:f==null?"":Ue(f)||qt(f)&&(f.toString===gI||!Ze(f.toString))?JSON.stringify(f,lI,2):String(f),lI=(f,e)=>e&&e.__v_isRef?lI(f,e.value):hd(e)?{[`Map(${e.size})`]:[...e.entries()].reduce((t,[s,i])=>(t[`${s} =>`]=i,t),{})}:pI(e)?{[`Set(${e.size})`]:[...e.values()]}:qt(e)&&!Ue(e)&&!yI(e)?String(e):e,Nt={},fd=[],En=()=>{},mM=()=>!1,gM=/^on[^a-z]/,gl=f=>gM.test(f),Hy=f=>f.startsWith("onUpdate:"),Ls=Object.assign,Gy=(f,e)=>{const t=f.indexOf(e);t>-1&&f.splice(t,1)},yM=Object.prototype.hasOwnProperty,pt=(f,e)=>yM.call(f,e),Ue=Array.isArray,hd=f=>yl(f)==="[object Map]",pI=f=>yl(f)==="[object Set]",Ze=f=>typeof f=="function",gs=f=>typeof f=="string",Uy=f=>typeof f=="symbol",qt=f=>f!==null&&typeof f=="object",mI=f=>qt(f)&&Ze(f.then)&&Ze(f.catch),gI=Object.prototype.toString,yl=f=>gI.call(f),bM=f=>yl(f).slice(8,-1),yI=f=>yl(f)==="[object Object]",$y=f=>gs(f)&&f!=="NaN"&&f[0]!=="-"&&""+parseInt(f,10)===f,Dh=Fy(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),bl=f=>{const e=Object.create(null);return t=>e[t]||(e[t]=f(t))},wM=/-(\w)/g,pn=bl(f=>f.replace(wM,(e,t)=>t?t.toUpperCase():"")),kM=/\B([A-Z])/g,Id=bl(f=>f.replace(kM,"-$1").toLowerCase()),Cr=bl(f=>f.charAt(0).toUpperCase()+f.slice(1)),Hh=bl(f=>f?`on${Cr(f)}`:""),bu=(f,e)=>!Object.is(f,e),Tp=(f,e)=>{for(let t=0;t<f.length;t++)f[t](e)},Yh=(f,e,t)=>{Object.defineProperty(f,e,{configurable:!0,enumerable:!1,value:t})},jy=f=>{const e=parseFloat(f);return isNaN(e)?f:e};let uw;const SM=()=>uw||(uw=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});let cn;class bI{constructor(e=!1){this.detached=e,this.active=!0,this.effects=[],this.cleanups=[],this.parent=cn,!e&&cn&&(this.index=(cn.scopes||(cn.scopes=[])).push(this)-1)}run(e){if(this.active){const t=cn;try{return cn=this,e()}finally{cn=t}}}on(){cn=this}off(){cn=this.parent}stop(e){if(this.active){let t,s;for(t=0,s=this.effects.length;t<s;t++)this.effects[t].stop();for(t=0,s=this.cleanups.length;t<s;t++)this.cleanups[t]();if(this.scopes)for(t=0,s=this.scopes.length;t<s;t++)this.scopes[t].stop(!0);if(!this.detached&&this.parent&&!e){const i=this.parent.scopes.pop();i&&i!==this&&(this.parent.scopes[this.index]=i,i.index=this.index)}this.parent=void 0,this.active=!1}}}function wl(f){return new bI(f)}function vM(f,e=cn){e&&e.active&&e.effects.push(f)}function rr(f){cn&&cn.cleanups.push(f)}const Wy=f=>{const e=new Set(f);return e.w=0,e.n=0,e},wI=f=>(f.w&ba)>0,kI=f=>(f.n&ba)>0,TM=({deps:f})=>{if(f.length)for(let e=0;e<f.length;e++)f[e].w|=ba},OM=f=>{const{deps:e}=f;if(e.length){let t=0;for(let s=0;s<e.length;s++){const i=e[s];wI(i)&&!kI(i)?i.delete(f):e[t++]=i,i.w&=~ba,i.n&=~ba}e.length=t}},Yg=new WeakMap;let au=0,ba=1;const Qg=30;let An;const ho=Symbol(""),Zg=Symbol("");class zy{constructor(e,t=null,s){this.fn=e,this.scheduler=t,this.active=!0,this.deps=[],this.parent=void 0,vM(this,s)}run(){if(!this.active)return this.fn();let e=An,t=ga;for(;e;){if(e===this)return;e=e.parent}try{return this.parent=An,An=this,ga=!0,ba=1<<++au,au<=Qg?TM(this):fw(this),this.fn()}finally{au<=Qg&&OM(this),ba=1<<--au,An=this.parent,ga=t,this.parent=void 0,this.deferStop&&this.stop()}}stop(){An===this?this.deferStop=!0:this.active&&(fw(this),this.onStop&&this.onStop(),this.active=!1)}}function fw(f){const{deps:e}=f;if(e.length){for(let t=0;t<e.length;t++)e[t].delete(f);e.length=0}}let ga=!0;const SI=[];function xd(){SI.push(ga),ga=!1}function _d(){const f=SI.pop();ga=f===void 0?!0:f}function Hi(f,e,t){if(ga&&An){let s=Yg.get(f);s||Yg.set(f,s=new Map);let i=s.get(t);i||s.set(t,i=Wy()),vI(i)}}function vI(f,e){let t=!1;au<=Qg?kI(f)||(f.n|=ba,t=!wI(f)):t=!f.has(An),t&&(f.add(An),An.deps.push(f))}function Or(f,e,t,s,i,n){const r=Yg.get(f);if(!r)return;let a=[];if(e==="clear")a=[...r.values()];else if(t==="length"&&Ue(f)){const o=jy(s);r.forEach((d,c)=>{(c==="length"||c>=o)&&a.push(d)})}else switch(t!==void 0&&a.push(r.get(t)),e){case"add":Ue(f)?$y(t)&&a.push(r.get("length")):(a.push(r.get(ho)),hd(f)&&a.push(r.get(Zg)));break;case"delete":Ue(f)||(a.push(r.get(ho)),hd(f)&&a.push(r.get(Zg)));break;case"set":hd(f)&&a.push(r.get(ho));break}if(a.length===1)a[0]&&Jg(a[0]);else{const o=[];for(const d of a)d&&o.push(...d);Jg(Wy(o))}}function Jg(f,e){const t=Ue(f)?f:[...f];for(const s of t)s.computed&&hw(s);for(const s of t)s.computed||hw(s)}function hw(f,e){(f!==An||f.allowRecurse)&&(f.scheduler?f.scheduler():f.run())}const IM=Fy("__proto__,__v_isRef,__isVue"),TI=new Set(Object.getOwnPropertyNames(Symbol).filter(f=>f!=="arguments"&&f!=="caller").map(f=>Symbol[f]).filter(Uy)),xM=Ky(),_M=Ky(!1,!0),CM=Ky(!0),lw=MM();function MM(){const f={};return["includes","indexOf","lastIndexOf"].forEach(e=>{f[e]=function(...t){const s=mt(this);for(let n=0,r=this.length;n<r;n++)Hi(s,"get",n+"");const i=s[e](...t);return i===-1||i===!1?s[e](...t.map(mt)):i}}),["push","pop","shift","unshift","splice"].forEach(e=>{f[e]=function(...t){xd();const s=mt(this)[e].apply(this,t);return _d(),s}}),f}function Ky(f=!1,e=!1){return function(s,i,n){if(i==="__v_isReactive")return!f;if(i==="__v_isReadonly")return f;if(i==="__v_isShallow")return e;if(i==="__v_raw"&&n===(f?e?jM:CI:e?_I:xI).get(s))return s;const r=Ue(s);if(!f&&r&&pt(lw,i))return Reflect.get(lw,i,n);const a=Reflect.get(s,i,n);return(Uy(i)?TI.has(i):IM(i))||(f||Hi(s,"get",i),e)?a:Qt(a)?r&&$y(i)?a:a.value:qt(a)?f?Eu(a):ti(a):a}}const PM=OI(),AM=OI(!0);function OI(f=!1){return function(t,s,i,n){let r=t[s];if(bd(r)&&Qt(r)&&!Qt(i))return!1;if(!f&&(!Qh(i)&&!bd(i)&&(r=mt(r),i=mt(i)),!Ue(t)&&Qt(r)&&!Qt(i)))return r.value=i,!0;const a=Ue(t)&&$y(s)?Number(s)<t.length:pt(t,s),o=Reflect.set(t,s,i,n);return t===mt(n)&&(a?bu(i,r)&&Or(t,"set",s,i):Or(t,"add",s,i)),o}}function BM(f,e){const t=pt(f,e);f[e];const s=Reflect.deleteProperty(f,e);return s&&t&&Or(f,"delete",e,void 0),s}function EM(f,e){const t=Reflect.has(f,e);return(!Uy(e)||!TI.has(e))&&Hi(f,"has",e),t}function NM(f){return Hi(f,"iterate",Ue(f)?"length":ho),Reflect.ownKeys(f)}const II={get:xM,set:PM,deleteProperty:BM,has:EM,ownKeys:NM},VM={get:CM,set(f,e){return!0},deleteProperty(f,e){return!0}},qM=Ls({},II,{get:_M,set:AM}),Xy=f=>f,kl=f=>Reflect.getPrototypeOf(f);function Qu(f,e,t=!1,s=!1){f=f.__v_raw;const i=mt(f),n=mt(e);t||(e!==n&&Hi(i,"get",e),Hi(i,"get",n));const{has:r}=kl(i),a=s?Xy:t?Zy:wu;if(r.call(i,e))return a(f.get(e));if(r.call(i,n))return a(f.get(n));f!==i&&f.get(e)}function Zu(f,e=!1){const t=this.__v_raw,s=mt(t),i=mt(f);return e||(f!==i&&Hi(s,"has",f),Hi(s,"has",i)),f===i?t.has(f):t.has(f)||t.has(i)}function Ju(f,e=!1){return f=f.__v_raw,!e&&Hi(mt(f),"iterate",ho),Reflect.get(f,"size",f)}function pw(f){f=mt(f);const e=mt(this);return kl(e).has.call(e,f)||(e.add(f),Or(e,"add",f,f)),this}function mw(f,e){e=mt(e);const t=mt(this),{has:s,get:i}=kl(t);let n=s.call(t,f);n||(f=mt(f),n=s.call(t,f));const r=i.call(t,f);return t.set(f,e),n?bu(e,r)&&Or(t,"set",f,e):Or(t,"add",f,e),this}function gw(f){const e=mt(this),{has:t,get:s}=kl(e);let i=t.call(e,f);i||(f=mt(f),i=t.call(e,f)),s&&s.call(e,f);const n=e.delete(f);return i&&Or(e,"delete",f,void 0),n}function yw(){const f=mt(this),e=f.size!==0,t=f.clear();return e&&Or(f,"clear",void 0,void 0),t}function ef(f,e){return function(s,i){const n=this,r=n.__v_raw,a=mt(r),o=e?Xy:f?Zy:wu;return!f&&Hi(a,"iterate",ho),r.forEach((d,c)=>s.call(i,o(d),o(c),n))}}function tf(f,e,t){return function(...s){const i=this.__v_raw,n=mt(i),r=hd(n),a=f==="entries"||f===Symbol.iterator&&r,o=f==="keys"&&r,d=i[f](...s),c=t?Xy:e?Zy:wu;return!e&&Hi(n,"iterate",o?Zg:ho),{next(){const{value:u,done:h}=d.next();return h?{value:u,done:h}:{value:a?[c(u[0]),c(u[1])]:c(u),done:h}},[Symbol.iterator](){return this}}}}function Lr(f){return function(...e){return f==="delete"?!1:this}}function LM(){const f={get(n){return Qu(this,n)},get size(){return Ju(this)},has:Zu,add:pw,set:mw,delete:gw,clear:yw,forEach:ef(!1,!1)},e={get(n){return Qu(this,n,!1,!0)},get size(){return Ju(this)},has:Zu,add:pw,set:mw,delete:gw,clear:yw,forEach:ef(!1,!0)},t={get(n){return Qu(this,n,!0)},get size(){return Ju(this,!0)},has(n){return Zu.call(this,n,!0)},add:Lr("add"),set:Lr("set"),delete:Lr("delete"),clear:Lr("clear"),forEach:ef(!0,!1)},s={get(n){return Qu(this,n,!0,!0)},get size(){return Ju(this,!0)},has(n){return Zu.call(this,n,!0)},add:Lr("add"),set:Lr("set"),delete:Lr("delete"),clear:Lr("clear"),forEach:ef(!0,!0)};return["keys","values","entries",Symbol.iterator].forEach(n=>{f[n]=tf(n,!1,!1),t[n]=tf(n,!0,!1),e[n]=tf(n,!1,!0),s[n]=tf(n,!0,!0)}),[f,t,e,s]}const[RM,FM,DM,HM]=LM();function Yy(f,e){const t=e?f?HM:DM:f?FM:RM;return(s,i,n)=>i==="__v_isReactive"?!f:i==="__v_isReadonly"?f:i==="__v_raw"?s:Reflect.get(pt(t,i)&&i in s?t:s,i,n)}const GM={get:Yy(!1,!1)},UM={get:Yy(!1,!0)},$M={get:Yy(!0,!1)},xI=new WeakMap,_I=new WeakMap,CI=new WeakMap,jM=new WeakMap;function WM(f){switch(f){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function zM(f){return f.__v_skip||!Object.isExtensible(f)?0:WM(bM(f))}function ti(f){return bd(f)?f:Qy(f,!1,II,GM,xI)}function MI(f){return Qy(f,!1,qM,UM,_I)}function Eu(f){return Qy(f,!0,VM,$M,CI)}function Qy(f,e,t,s,i){if(!qt(f)||f.__v_raw&&!(e&&f.__v_isReactive))return f;const n=i.get(f);if(n)return n;const r=zM(f);if(r===0)return f;const a=new Proxy(f,r===2?s:t);return i.set(f,a),a}function ld(f){return bd(f)?ld(f.__v_raw):!!(f&&f.__v_isReactive)}function bd(f){return!!(f&&f.__v_isReadonly)}function Qh(f){return!!(f&&f.__v_isShallow)}function PI(f){return ld(f)||bd(f)}function mt(f){const e=f&&f.__v_raw;return e?mt(e):f}function AI(f){return Yh(f,"__v_skip",!0),f}const wu=f=>qt(f)?ti(f):f,Zy=f=>qt(f)?Eu(f):f;function BI(f){ga&&An&&(f=mt(f),vI(f.dep||(f.dep=Wy())))}function EI(f,e){f=mt(f),f.dep&&Jg(f.dep)}function Qt(f){return!!(f&&f.__v_isRef===!0)}function fe(f){return NI(f,!1)}function KM(f){return NI(f,!0)}function NI(f,e){return Qt(f)?f:new XM(f,e)}class XM{constructor(e,t){this.__v_isShallow=t,this.dep=void 0,this.__v_isRef=!0,this._rawValue=t?e:mt(e),this._value=t?e:wu(e)}get value(){return BI(this),this._value}set value(e){const t=this.__v_isShallow||Qh(e)||bd(e);e=t?e:mt(e),bu(e,this._rawValue)&&(this._rawValue=e,this._value=t?e:wu(e),EI(this))}}function ei(f){return Qt(f)?f.value:f}const YM={get:(f,e,t)=>ei(Reflect.get(f,e,t)),set:(f,e,t,s)=>{const i=f[e];return Qt(i)&&!Qt(t)?(i.value=t,!0):Reflect.set(f,e,t,s)}};function VI(f){return ld(f)?f:new Proxy(f,YM)}function Jy(f){const e=Ue(f)?new Array(f.length):{};for(const t in f)e[t]=je(f,t);return e}class QM{constructor(e,t,s){this._object=e,this._key=t,this._defaultValue=s,this.__v_isRef=!0}get value(){const e=this._object[this._key];return e===void 0?this._defaultValue:e}set value(e){this._object[this._key]=e}}function je(f,e,t){const s=f[e];return Qt(s)?s:new QM(f,e,t)}var qI;class ZM{constructor(e,t,s,i){this._setter=t,this.dep=void 0,this.__v_isRef=!0,this[qI]=!1,this._dirty=!0,this.effect=new zy(e,()=>{this._dirty||(this._dirty=!0,EI(this))}),this.effect.computed=this,this.effect.active=this._cacheable=!i,this.__v_isReadonly=s}get value(){const e=mt(this);return BI(e),(e._dirty||!e._cacheable)&&(e._dirty=!1,e._value=e.effect.run()),e._value}set value(e){this._setter(e)}}qI="__v_isReadonly";function LI(f,e,t=!1){let s,i;const n=Ze(f);return n?(s=f,i=En):(s=f.get,i=f.set),new ZM(s,i,n||!i,t)}function ya(f,e,t,s){let i;try{i=s?f(...s):f()}catch(n){Sl(n,e,t)}return i}function hn(f,e,t,s){if(Ze(f)){const n=ya(f,e,t,s);return n&&mI(n)&&n.catch(r=>{Sl(r,e,t)}),n}const i=[];for(let n=0;n<f.length;n++)i.push(hn(f[n],e,t,s));return i}function Sl(f,e,t,s=!0){const i=e?e.vnode:null;if(e){let n=e.parent;const r=e.proxy,a=t;for(;n;){const d=n.ec;if(d){for(let c=0;c<d.length;c++)if(d[c](f,r,a)===!1)return}n=n.parent}const o=e.appContext.config.errorHandler;if(o){ya(o,null,10,[f,r,a]);return}}JM(f,t,i,s)}function JM(f,e,t,s=!0){console.error(f)}let ku=!1,ey=!1;const si=[];let Jn=0;const pd=[];let Sr=null,ro=0;const RI=Promise.resolve();let eb=null;function Bi(f){const e=eb||RI;return f?e.then(this?f.bind(this):f):e}function eP(f){let e=Jn+1,t=si.length;for(;e<t;){const s=e+t>>>1;Su(si[s])<f?e=s+1:t=s}return e}function tb(f){(!si.length||!si.includes(f,ku&&f.allowRecurse?Jn+1:Jn))&&(f.id==null?si.push(f):si.splice(eP(f.id),0,f),FI())}function FI(){!ku&&!ey&&(ey=!0,eb=RI.then(HI))}function tP(f){const e=si.indexOf(f);e>Jn&&si.splice(e,1)}function sP(f){Ue(f)?pd.push(...f):(!Sr||!Sr.includes(f,f.allowRecurse?ro+1:ro))&&pd.push(f),FI()}function bw(f,e=ku?Jn+1:0){for(;e<si.length;e++){const t=si[e];t&&t.pre&&(si.splice(e,1),e--,t())}}function DI(f){if(pd.length){const e=[...new Set(pd)];if(pd.length=0,Sr){Sr.push(...e);return}for(Sr=e,Sr.sort((t,s)=>Su(t)-Su(s)),ro=0;ro<Sr.length;ro++)Sr[ro]();Sr=null,ro=0}}const Su=f=>f.id==null?1/0:f.id,iP=(f,e)=>{const t=Su(f)-Su(e);if(t===0){if(f.pre&&!e.pre)return-1;if(e.pre&&!f.pre)return 1}return t};function HI(f){ey=!1,ku=!0,si.sort(iP);const e=En;try{for(Jn=0;Jn<si.length;Jn++){const t=si[Jn];t&&t.active!==!1&&ya(t,null,14)}}finally{Jn=0,si.length=0,DI(),ku=!1,eb=null,(si.length||pd.length)&&HI()}}function nP(f,e,...t){if(f.isUnmounted)return;const s=f.vnode.props||Nt;let i=t;const n=e.startsWith("update:"),r=n&&e.slice(7);if(r&&r in s){const c=`${r==="modelValue"?"model":r}Modifiers`,{number:u,trim:h}=s[c]||Nt;h&&(i=t.map(l=>gs(l)?l.trim():l)),u&&(i=t.map(jy))}let a,o=s[a=Hh(e)]||s[a=Hh(pn(e))];!o&&n&&(o=s[a=Hh(Id(e))]),o&&hn(o,f,6,i);const d=s[a+"Once"];if(d){if(!f.emitted)f.emitted={};else if(f.emitted[a])return;f.emitted[a]=!0,hn(d,f,6,i)}}function GI(f,e,t=!1){const s=e.emitsCache,i=s.get(f);if(i!==void 0)return i;const n=f.emits;let r={},a=!1;if(!Ze(f)){const o=d=>{const c=GI(d,e,!0);c&&(a=!0,Ls(r,c))};!t&&e.mixins.length&&e.mixins.forEach(o),f.extends&&o(f.extends),f.mixins&&f.mixins.forEach(o)}return!n&&!a?(qt(f)&&s.set(f,null),null):(Ue(n)?n.forEach(o=>r[o]=null):Ls(r,n),qt(f)&&s.set(f,r),r)}function vl(f,e){return!f||!gl(e)?!1:(e=e.slice(2).replace(/Once$/,""),pt(f,e[0].toLowerCase()+e.slice(1))||pt(f,Id(e))||pt(f,e))}let Di=null,UI=null;function Zh(f){const e=Di;return Di=f,UI=f&&f.type.__scopeId||null,e}function Be(f,e=Di,t){if(!e||f._n)return f;const s=(...i)=>{s._d&&Mw(-1);const n=Zh(e);let r;try{r=f(...i)}finally{Zh(n),s._d&&Mw(1)}return r};return s._n=!0,s._c=!0,s._d=!0,s}function Op(f){const{type:e,vnode:t,proxy:s,withProxy:i,props:n,propsOptions:[r],slots:a,attrs:o,emit:d,render:c,renderCache:u,data:h,setupState:l,ctx:p,inheritAttrs:m}=f;let g,y;const b=Zh(f);try{if(t.shapeFlag&4){const k=i||s;g=Qn(c.call(k,k,u,n,l,h,p)),y=o}else{const k=e;g=Qn(k.length>1?k(n,{attrs:o,slots:a,emit:d}):k(n,null)),y=e.props?o:rP(o)}}catch(k){pu.length=0,Sl(k,f,1),g=$(Nn)}let w=g;if(y&&m!==!1){const k=Object.keys(y),{shapeFlag:T}=w;k.length&&T&7&&(r&&k.some(Hy)&&(y=aP(y,r)),w=Ir(w,y))}return t.dirs&&(w=Ir(w),w.dirs=w.dirs?w.dirs.concat(t.dirs):t.dirs),t.transition&&(w.transition=t.transition),g=w,Zh(b),g}const rP=f=>{let e;for(const t in f)(t==="class"||t==="style"||gl(t))&&((e||(e={}))[t]=f[t]);return e},aP=(f,e)=>{const t={};for(const s in f)(!Hy(s)||!(s.slice(9)in e))&&(t[s]=f[s]);return t};function oP(f,e,t){const{props:s,children:i,component:n}=f,{props:r,children:a,patchFlag:o}=e,d=n.emitsOptions;if(e.dirs||e.transition)return!0;if(t&&o>=0){if(o&1024)return!0;if(o&16)return s?ww(s,r,d):!!r;if(o&8){const c=e.dynamicProps;for(let u=0;u<c.length;u++){const h=c[u];if(r[h]!==s[h]&&!vl(d,h))return!0}}}else return(i||a)&&(!a||!a.$stable)?!0:s===r?!1:s?r?ww(s,r,d):!0:!!r;return!1}function ww(f,e,t){const s=Object.keys(e);if(s.length!==Object.keys(f).length)return!0;for(let i=0;i<s.length;i++){const n=s[i];if(e[n]!==f[n]&&!vl(t,n))return!0}return!1}function dP({vnode:f,parent:e},t){for(;e&&e.subTree===f;)(f=e.vnode).el=t,e=e.parent}const cP=f=>f.__isSuspense;function uP(f,e){e&&e.pendingBranch?Ue(f)?e.effects.push(...f):e.effects.push(f):sP(f)}function Ni(f,e){if(qs){let t=qs.provides;const s=qs.parent&&qs.parent.provides;s===t&&(t=qs.provides=Object.create(s)),t[f]=e}}function Zt(f,e,t=!1){const s=qs||Di;if(s){const i=s.parent==null?s.vnode.appContext&&s.vnode.appContext.provides:s.parent.provides;if(i&&f in i)return i[f];if(arguments.length>1)return t&&Ze(e)?e.call(s.proxy):e}}function Mr(f,e){return sb(f,null,e)}const sf={};function st(f,e,t){return sb(f,e,t)}function sb(f,e,{immediate:t,deep:s,flush:i,onTrack:n,onTrigger:r}=Nt){const a=qs;let o,d=!1,c=!1;if(Qt(f)?(o=()=>f.value,d=Qh(f)):ld(f)?(o=()=>f,s=!0):Ue(f)?(c=!0,d=f.some(w=>ld(w)||Qh(w)),o=()=>f.map(w=>{if(Qt(w))return w.value;if(ld(w))return uo(w);if(Ze(w))return ya(w,a,2)})):Ze(f)?e?o=()=>ya(f,a,2):o=()=>{if(!(a&&a.isUnmounted))return u&&u(),hn(f,a,3,[h])}:o=En,e&&s){const w=o;o=()=>uo(w())}let u,h=w=>{u=y.onStop=()=>{ya(w,a,4)}},l;if(Iu)if(h=En,e?t&&hn(e,a,3,[o(),c?[]:void 0,h]):o(),i==="sync"){const w=sA();l=w.__watcherHandles||(w.__watcherHandles=[])}else return En;let p=c?new Array(f.length).fill(sf):sf;const m=()=>{if(!!y.active)if(e){const w=y.run();(s||d||(c?w.some((k,T)=>bu(k,p[T])):bu(w,p)))&&(u&&u(),hn(e,a,3,[w,p===sf?void 0:c&&p[0]===sf?[]:p,h]),p=w)}else y.run()};m.allowRecurse=!!e;let g;i==="sync"?g=m:i==="post"?g=()=>Ai(m,a&&a.suspense):(m.pre=!0,a&&(m.id=a.uid),g=()=>tb(m));const y=new zy(o,g);e?t?m():p=y.run():i==="post"?Ai(y.run.bind(y),a&&a.suspense):y.run();const b=()=>{y.stop(),a&&a.scope&&Gy(a.scope.effects,y)};return l&&l.push(b),b}function fP(f,e,t){const s=this.proxy,i=gs(f)?f.includes(".")?$I(s,f):()=>s[f]:f.bind(s,s);let n;Ze(e)?n=e:(n=e.handler,t=e);const r=qs;wd(this);const a=sb(i,n.bind(s),t);return r?wd(r):lo(),a}function $I(f,e){const t=e.split(".");return()=>{let s=f;for(let i=0;i<t.length&&s;i++)s=s[t[i]];return s}}function uo(f,e){if(!qt(f)||f.__v_skip||(e=e||new Set,e.has(f)))return f;if(e.add(f),Qt(f))uo(f.value,e);else if(Ue(f))for(let t=0;t<f.length;t++)uo(f[t],e);else if(pI(f)||hd(f))f.forEach(t=>{uo(t,e)});else if(yI(f))for(const t in f)uo(f[t],e);return f}function jI(){const f={isMounted:!1,isLeaving:!1,isUnmounting:!1,leavingVNodes:new Map};return ar(()=>{f.isMounted=!0}),mn(()=>{f.isUnmounting=!0}),f}const Wi=[Function,Array],hP={name:"BaseTransition",props:{mode:String,appear:Boolean,persisted:Boolean,onBeforeEnter:Wi,onEnter:Wi,onAfterEnter:Wi,onEnterCancelled:Wi,onBeforeLeave:Wi,onLeave:Wi,onAfterLeave:Wi,onLeaveCancelled:Wi,onBeforeAppear:Wi,onAppear:Wi,onAfterAppear:Wi,onAppearCancelled:Wi},setup(f,{slots:e}){const t=Cl(),s=jI();let i;return()=>{const n=e.default&&ib(e.default(),!0);if(!n||!n.length)return;let r=n[0];if(n.length>1){for(const m of n)if(m.type!==Nn){r=m;break}}const a=mt(f),{mode:o}=a;if(s.isLeaving)return Ip(r);const d=kw(r);if(!d)return Ip(r);const c=vu(d,a,s,t);Tu(d,c);const u=t.subTree,h=u&&kw(u);let l=!1;const{getTransitionKey:p}=d.type;if(p){const m=p();i===void 0?i=m:m!==i&&(i=m,l=!0)}if(h&&h.type!==Nn&&(!ao(d,h)||l)){const m=vu(h,a,s,t);if(Tu(h,m),o==="out-in")return s.isLeaving=!0,m.afterLeave=()=>{s.isLeaving=!1,t.update.active!==!1&&t.update()},Ip(r);o==="in-out"&&d.type!==Nn&&(m.delayLeave=(g,y,b)=>{const w=zI(s,h);w[String(h.key)]=h,g._leaveCb=()=>{y(),g._leaveCb=void 0,delete c.delayedLeave},c.delayedLeave=b})}return r}}},WI=hP;function zI(f,e){const{leavingVNodes:t}=f;let s=t.get(e.type);return s||(s=Object.create(null),t.set(e.type,s)),s}function vu(f,e,t,s){const{appear:i,mode:n,persisted:r=!1,onBeforeEnter:a,onEnter:o,onAfterEnter:d,onEnterCancelled:c,onBeforeLeave:u,onLeave:h,onAfterLeave:l,onLeaveCancelled:p,onBeforeAppear:m,onAppear:g,onAfterAppear:y,onAppearCancelled:b}=e,w=String(f.key),k=zI(t,f),T=(C,E)=>{C&&hn(C,s,9,E)},O=(C,E)=>{const P=E[1];T(C,E),Ue(C)?C.every(_=>_.length<=1)&&P():C.length<=1&&P()},x={mode:n,persisted:r,beforeEnter(C){let E=a;if(!t.isMounted)if(i)E=m||a;else return;C._leaveCb&&C._leaveCb(!0);const P=k[w];P&&ao(f,P)&&P.el._leaveCb&&P.el._leaveCb(),T(E,[C])},enter(C){let E=o,P=d,_=c;if(!t.isMounted)if(i)E=g||o,P=y||d,_=b||c;else return;let S=!1;const I=C._enterCb=v=>{S||(S=!0,v?T(_,[C]):T(P,[C]),x.delayedLeave&&x.delayedLeave(),C._enterCb=void 0)};E?O(E,[C,I]):I()},leave(C,E){const P=String(f.key);if(C._enterCb&&C._enterCb(!0),t.isUnmounting)return E();T(u,[C]);let _=!1;const S=C._leaveCb=I=>{_||(_=!0,E(),I?T(p,[C]):T(l,[C]),C._leaveCb=void 0,k[P]===f&&delete k[P])};k[P]=f,h?O(h,[C,S]):S()},clone(C){return vu(C,e,t,s)}};return x}function Ip(f){if(Tl(f))return f=Ir(f),f.children=null,f}function kw(f){return Tl(f)?f.children?f.children[0]:void 0:f}function Tu(f,e){f.shapeFlag&6&&f.component?Tu(f.component.subTree,e):f.shapeFlag&128?(f.ssContent.transition=e.clone(f.ssContent),f.ssFallback.transition=e.clone(f.ssFallback)):f.transition=e}function ib(f,e=!1,t){let s=[],i=0;for(let n=0;n<f.length;n++){let r=f[n];const a=t==null?r.key:String(t)+String(r.key!=null?r.key:n);r.type===Ft?(r.patchFlag&128&&i++,s=s.concat(ib(r.children,e,a))):(e||r.type!==Nn)&&s.push(a!=null?Ir(r,{key:a}):r)}if(i>1)for(let n=0;n<s.length;n++)s[n].patchFlag=-2;return s}function nb(f){return Ze(f)?{setup:f,name:f.name}:f}const Gh=f=>!!f.type.__asyncLoader,Tl=f=>f.type.__isKeepAlive;function KI(f,e){YI(f,"a",e)}function XI(f,e){YI(f,"da",e)}function YI(f,e,t=qs){const s=f.__wdc||(f.__wdc=()=>{let i=t;for(;i;){if(i.isDeactivated)return;i=i.parent}return f()});if(Ol(e,s,t),t){let i=t.parent;for(;i&&i.parent;)Tl(i.parent.vnode)&&lP(s,e,t,i),i=i.parent}}function lP(f,e,t,s){const i=Ol(e,f,s,!0);ZI(()=>{Gy(s[e],i)},t)}function Ol(f,e,t=qs,s=!1){if(t){const i=t[f]||(t[f]=[]),n=e.__weh||(e.__weh=(...r)=>{if(t.isUnmounted)return;xd(),wd(t);const a=hn(e,t,f,r);return lo(),_d(),a});return s?i.unshift(n):i.push(n),n}}const Pr=f=>(e,t=qs)=>(!Iu||f==="sp")&&Ol(f,(...s)=>e(...s),t),Il=Pr("bm"),ar=Pr("m"),pP=Pr("bu"),QI=Pr("u"),mn=Pr("bum"),ZI=Pr("um"),mP=Pr("sp"),gP=Pr("rtg"),yP=Pr("rtc");function bP(f,e=qs){Ol("ec",f,e)}function Gi(f,e){const t=Di;if(t===null)return f;const s=Ml(t)||t.proxy,i=f.dirs||(f.dirs=[]);for(let n=0;n<e.length;n++){let[r,a,o,d=Nt]=e[n];r&&(Ze(r)&&(r={mounted:r,updated:r}),r.deep&&uo(a),i.push({dir:r,instance:s,value:a,oldValue:void 0,arg:o,modifiers:d}))}return f}function va(f,e,t,s){const i=f.dirs,n=e&&e.dirs;for(let r=0;r<i.length;r++){const a=i[r];n&&(a.oldValue=n[r].value);let o=a.dir[s];o&&(xd(),hn(o,t,8,[f.el,a,f,e]),_d())}}const JI="components",wP="directives",ex=Symbol();function kP(f){return gs(f)?tx(JI,f,!1)||f:f||ex}function ka(f){return tx(wP,f)}function tx(f,e,t=!0,s=!1){const i=Di||qs;if(i){const n=i.type;if(f===JI){const a=JP(n,!1);if(a&&(a===e||a===pn(e)||a===Cr(pn(e))))return n}const r=Sw(i[f]||n[f],e)||Sw(i.appContext[f],e);return!r&&s?n:r}}function Sw(f,e){return f&&(f[e]||f[pn(e)]||f[Cr(pn(e))])}function SP(f,e,t,s){let i;const n=t&&t[s];if(Ue(f)||gs(f)){i=new Array(f.length);for(let r=0,a=f.length;r<a;r++)i[r]=e(f[r],r,void 0,n&&n[r])}else if(typeof f=="number"){i=new Array(f);for(let r=0;r<f;r++)i[r]=e(r+1,r,void 0,n&&n[r])}else if(qt(f))if(f[Symbol.iterator])i=Array.from(f,(r,a)=>e(r,a,void 0,n&&n[a]));else{const r=Object.keys(f);i=new Array(r.length);for(let a=0,o=r.length;a<o;a++){const d=r[a];i[a]=e(f[d],d,a,n&&n[a])}}else i=[];return t&&(t[s]=i),i}function vP(f,e){for(let t=0;t<e.length;t++){const s=e[t];if(Ue(s))for(let i=0;i<s.length;i++)f[s[i].name]=s[i].fn;else s&&(f[s.name]=s.key?(...i)=>{const n=s.fn(...i);return n&&(n.key=s.key),n}:s.fn)}return f}function xp(f,e){const t={};for(const s in f)t[e&&/[A-Z]/.test(s)?`on:${s}`:Hh(s)]=f[s];return t}const ty=f=>f?hx(f)?Ml(f)||f.proxy:ty(f.parent):null,hu=Ls(Object.create(null),{$:f=>f,$el:f=>f.vnode.el,$data:f=>f.data,$props:f=>f.props,$attrs:f=>f.attrs,$slots:f=>f.slots,$refs:f=>f.refs,$parent:f=>ty(f.parent),$root:f=>ty(f.root),$emit:f=>f.emit,$options:f=>rb(f),$forceUpdate:f=>f.f||(f.f=()=>tb(f.update)),$nextTick:f=>f.n||(f.n=Bi.bind(f.proxy)),$watch:f=>fP.bind(f)}),_p=(f,e)=>f!==Nt&&!f.__isScriptSetup&&pt(f,e),TP={get({_:f},e){const{ctx:t,setupState:s,data:i,props:n,accessCache:r,type:a,appContext:o}=f;let d;if(e[0]!=="$"){const l=r[e];if(l!==void 0)switch(l){case 1:return s[e];case 2:return i[e];case 4:return t[e];case 3:return n[e]}else{if(_p(s,e))return r[e]=1,s[e];if(i!==Nt&&pt(i,e))return r[e]=2,i[e];if((d=f.propsOptions[0])&&pt(d,e))return r[e]=3,n[e];if(t!==Nt&&pt(t,e))return r[e]=4,t[e];sy&&(r[e]=0)}}const c=hu[e];let u,h;if(c)return e==="$attrs"&&Hi(f,"get",e),c(f);if((u=a.__cssModules)&&(u=u[e]))return u;if(t!==Nt&&pt(t,e))return r[e]=4,t[e];if(h=o.config.globalProperties,pt(h,e))return h[e]},set({_:f},e,t){const{data:s,setupState:i,ctx:n}=f;return _p(i,e)?(i[e]=t,!0):s!==Nt&&pt(s,e)?(s[e]=t,!0):pt(f.props,e)||e[0]==="$"&&e.slice(1)in f?!1:(n[e]=t,!0)},has({_:{data:f,setupState:e,accessCache:t,ctx:s,appContext:i,propsOptions:n}},r){let a;return!!t[r]||f!==Nt&&pt(f,r)||_p(e,r)||(a=n[0])&&pt(a,r)||pt(s,r)||pt(hu,r)||pt(i.config.globalProperties,r)},defineProperty(f,e,t){return t.get!=null?f._.accessCache[e]=0:pt(t,"value")&&this.set(f,e,t.value,null),Reflect.defineProperty(f,e,t)}};let sy=!0;function OP(f){const e=rb(f),t=f.proxy,s=f.ctx;sy=!1,e.beforeCreate&&vw(e.beforeCreate,f,"bc");const{data:i,computed:n,methods:r,watch:a,provide:o,inject:d,created:c,beforeMount:u,mounted:h,beforeUpdate:l,updated:p,activated:m,deactivated:g,beforeDestroy:y,beforeUnmount:b,destroyed:w,unmounted:k,render:T,renderTracked:O,renderTriggered:x,errorCaptured:C,serverPrefetch:E,expose:P,inheritAttrs:_,components:S,directives:I,filters:v}=e;if(d&&IP(d,s,null,f.appContext.config.unwrapInjectedRef),r)for(const R in r){const G=r[R];Ze(G)&&(s[R]=G.bind(t))}if(i){const R=i.call(t,t);qt(R)&&(f.data=ti(R))}if(sy=!0,n)for(const R in n){const G=n[R],F=Ze(G)?G.bind(t,t):Ze(G.get)?G.get.bind(t,t):En,A=!Ze(G)&&Ze(G.set)?G.set.bind(t):En,V=ie({get:F,set:A});Object.defineProperty(s,R,{enumerable:!0,configurable:!0,get:()=>V.value,set:Q=>V.value=Q})}if(a)for(const R in a)sx(a[R],s,t,R);if(o){const R=Ze(o)?o.call(t):o;Reflect.ownKeys(R).forEach(G=>{Ni(G,R[G])})}c&&vw(c,f,"c");function q(R,G){Ue(G)?G.forEach(F=>R(F.bind(t))):G&&R(G.bind(t))}if(q(Il,u),q(ar,h),q(pP,l),q(QI,p),q(KI,m),q(XI,g),q(bP,C),q(yP,O),q(gP,x),q(mn,b),q(ZI,k),q(mP,E),Ue(P))if(P.length){const R=f.exposed||(f.exposed={});P.forEach(G=>{Object.defineProperty(R,G,{get:()=>t[G],set:F=>t[G]=F})})}else f.exposed||(f.exposed={});T&&f.render===En&&(f.render=T),_!=null&&(f.inheritAttrs=_),S&&(f.components=S),I&&(f.directives=I)}function IP(f,e,t=En,s=!1){Ue(f)&&(f=iy(f));for(const i in f){const n=f[i];let r;qt(n)?"default"in n?r=Zt(n.from||i,n.default,!0):r=Zt(n.from||i):r=Zt(n),Qt(r)&&s?Object.defineProperty(e,i,{enumerable:!0,configurable:!0,get:()=>r.value,set:a=>r.value=a}):e[i]=r}}function vw(f,e,t){hn(Ue(f)?f.map(s=>s.bind(e.proxy)):f.bind(e.proxy),e,t)}function sx(f,e,t,s){const i=s.includes(".")?$I(t,s):()=>t[s];if(gs(f)){const n=e[f];Ze(n)&&st(i,n)}else if(Ze(f))st(i,f.bind(t));else if(qt(f))if(Ue(f))f.forEach(n=>sx(n,e,t,s));else{const n=Ze(f.handler)?f.handler.bind(t):e[f.handler];Ze(n)&&st(i,n,f)}}function rb(f){const e=f.type,{mixins:t,extends:s}=e,{mixins:i,optionsCache:n,config:{optionMergeStrategies:r}}=f.appContext,a=n.get(e);let o;return a?o=a:!i.length&&!t&&!s?o=e:(o={},i.length&&i.forEach(d=>Jh(o,d,r,!0)),Jh(o,e,r)),qt(e)&&n.set(e,o),o}function Jh(f,e,t,s=!1){const{mixins:i,extends:n}=e;n&&Jh(f,n,t,!0),i&&i.forEach(r=>Jh(f,r,t,!0));for(const r in e)if(!(s&&r==="expose")){const a=xP[r]||t&&t[r];f[r]=a?a(f[r],e[r]):e[r]}return f}const xP={data:Tw,props:no,emits:no,methods:no,computed:no,beforeCreate:pi,created:pi,beforeMount:pi,mounted:pi,beforeUpdate:pi,updated:pi,beforeDestroy:pi,beforeUnmount:pi,destroyed:pi,unmounted:pi,activated:pi,deactivated:pi,errorCaptured:pi,serverPrefetch:pi,components:no,directives:no,watch:CP,provide:Tw,inject:_P};function Tw(f,e){return e?f?function(){return Ls(Ze(f)?f.call(this,this):f,Ze(e)?e.call(this,this):e)}:e:f}function _P(f,e){return no(iy(f),iy(e))}function iy(f){if(Ue(f)){const e={};for(let t=0;t<f.length;t++)e[f[t]]=f[t];return e}return f}function pi(f,e){return f?[...new Set([].concat(f,e))]:e}function no(f,e){return f?Ls(Ls(Object.create(null),f),e):e}function CP(f,e){if(!f)return e;if(!e)return f;const t=Ls(Object.create(null),f);for(const s in e)t[s]=pi(f[s],e[s]);return t}function MP(f,e,t,s=!1){const i={},n={};Yh(n,_l,1),f.propsDefaults=Object.create(null),ix(f,e,i,n);for(const r in f.propsOptions[0])r in i||(i[r]=void 0);t?f.props=s?i:MI(i):f.type.props?f.props=i:f.props=n,f.attrs=n}function PP(f,e,t,s){const{props:i,attrs:n,vnode:{patchFlag:r}}=f,a=mt(i),[o]=f.propsOptions;let d=!1;if((s||r>0)&&!(r&16)){if(r&8){const c=f.vnode.dynamicProps;for(let u=0;u<c.length;u++){let h=c[u];if(vl(f.emitsOptions,h))continue;const l=e[h];if(o)if(pt(n,h))l!==n[h]&&(n[h]=l,d=!0);else{const p=pn(h);i[p]=ny(o,a,p,l,f,!1)}else l!==n[h]&&(n[h]=l,d=!0)}}}else{ix(f,e,i,n)&&(d=!0);let c;for(const u in a)(!e||!pt(e,u)&&((c=Id(u))===u||!pt(e,c)))&&(o?t&&(t[u]!==void 0||t[c]!==void 0)&&(i[u]=ny(o,a,u,void 0,f,!0)):delete i[u]);if(n!==a)for(const u in n)(!e||!pt(e,u)&&!0)&&(delete n[u],d=!0)}d&&Or(f,"set","$attrs")}function ix(f,e,t,s){const[i,n]=f.propsOptions;let r=!1,a;if(e)for(let o in e){if(Dh(o))continue;const d=e[o];let c;i&&pt(i,c=pn(o))?!n||!n.includes(c)?t[c]=d:(a||(a={}))[c]=d:vl(f.emitsOptions,o)||(!(o in s)||d!==s[o])&&(s[o]=d,r=!0)}if(n){const o=mt(t),d=a||Nt;for(let c=0;c<n.length;c++){const u=n[c];t[u]=ny(i,o,u,d[u],f,!pt(d,u))}}return r}function ny(f,e,t,s,i,n){const r=f[t];if(r!=null){const a=pt(r,"default");if(a&&s===void 0){const o=r.default;if(r.type!==Function&&Ze(o)){const{propsDefaults:d}=i;t in d?s=d[t]:(wd(i),s=d[t]=o.call(null,e),lo())}else s=o}r[0]&&(n&&!a?s=!1:r[1]&&(s===""||s===Id(t))&&(s=!0))}return s}function nx(f,e,t=!1){const s=e.propsCache,i=s.get(f);if(i)return i;const n=f.props,r={},a=[];let o=!1;if(!Ze(f)){const c=u=>{o=!0;const[h,l]=nx(u,e,!0);Ls(r,h),l&&a.push(...l)};!t&&e.mixins.length&&e.mixins.forEach(c),f.extends&&c(f.extends),f.mixins&&f.mixins.forEach(c)}if(!n&&!o)return qt(f)&&s.set(f,fd),fd;if(Ue(n))for(let c=0;c<n.length;c++){const u=pn(n[c]);Ow(u)&&(r[u]=Nt)}else if(n)for(const c in n){const u=pn(c);if(Ow(u)){const h=n[c],l=r[u]=Ue(h)||Ze(h)?{type:h}:Object.assign({},h);if(l){const p=_w(Boolean,l.type),m=_w(String,l.type);l[0]=p>-1,l[1]=m<0||p<m,(p>-1||pt(l,"default"))&&a.push(u)}}}const d=[r,a];return qt(f)&&s.set(f,d),d}function Ow(f){return f[0]!=="$"}function Iw(f){const e=f&&f.toString().match(/^\s*function (\w+)/);return e?e[1]:f===null?"null":""}function xw(f,e){return Iw(f)===Iw(e)}function _w(f,e){return Ue(e)?e.findIndex(t=>xw(t,f)):Ze(e)&&xw(e,f)?0:-1}const rx=f=>f[0]==="_"||f==="$stable",ab=f=>Ue(f)?f.map(Qn):[Qn(f)],AP=(f,e,t)=>{if(e._n)return e;const s=Be((...i)=>ab(e(...i)),t);return s._c=!1,s},ax=(f,e,t)=>{const s=f._ctx;for(const i in f){if(rx(i))continue;const n=f[i];if(Ze(n))e[i]=AP(i,n,s);else if(n!=null){const r=ab(n);e[i]=()=>r}}},ox=(f,e)=>{const t=ab(e);f.slots.default=()=>t},BP=(f,e)=>{if(f.vnode.shapeFlag&32){const t=e._;t?(f.slots=mt(e),Yh(e,"_",t)):ax(e,f.slots={})}else f.slots={},e&&ox(f,e);Yh(f.slots,_l,1)},EP=(f,e,t)=>{const{vnode:s,slots:i}=f;let n=!0,r=Nt;if(s.shapeFlag&32){const a=e._;a?t&&a===1?n=!1:(Ls(i,e),!t&&a===1&&delete i._):(n=!e.$stable,ax(e,i)),r=e}else e&&(ox(f,e),r={default:1});if(n)for(const a in i)!rx(a)&&!(a in r)&&delete i[a]};function dx(){return{app:null,config:{isNativeTag:mM,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let NP=0;function VP(f,e){return function(s,i=null){Ze(s)||(s=Object.assign({},s)),i!=null&&!qt(i)&&(i=null);const n=dx(),r=new Set;let a=!1;const o=n.app={_uid:NP++,_component:s,_props:i,_container:null,_context:n,_instance:null,version:iA,get config(){return n.config},set config(d){},use(d,...c){return r.has(d)||(d&&Ze(d.install)?(r.add(d),d.install(o,...c)):Ze(d)&&(r.add(d),d(o,...c))),o},mixin(d){return n.mixins.includes(d)||n.mixins.push(d),o},component(d,c){return c?(n.components[d]=c,o):n.components[d]},directive(d,c){return c?(n.directives[d]=c,o):n.directives[d]},mount(d,c,u){if(!a){const h=$(s,i);return h.appContext=n,c&&e?e(h,d):f(h,d,u),a=!0,o._container=d,d.__vue_app__=o,Ml(h.component)||h.component.proxy}},unmount(){a&&(f(null,o._container),delete o._container.__vue_app__)},provide(d,c){return n.provides[d]=c,o}};return o}}function ry(f,e,t,s,i=!1){if(Ue(f)){f.forEach((h,l)=>ry(h,e&&(Ue(e)?e[l]:e),t,s,i));return}if(Gh(s)&&!i)return;const n=s.shapeFlag&4?Ml(s.component)||s.component.proxy:s.el,r=i?null:n,{i:a,r:o}=f,d=e&&e.r,c=a.refs===Nt?a.refs={}:a.refs,u=a.setupState;if(d!=null&&d!==o&&(gs(d)?(c[d]=null,pt(u,d)&&(u[d]=null)):Qt(d)&&(d.value=null)),Ze(o))ya(o,a,12,[r,c]);else{const h=gs(o),l=Qt(o);if(h||l){const p=()=>{if(f.f){const m=h?pt(u,o)?u[o]:c[o]:o.value;i?Ue(m)&&Gy(m,n):Ue(m)?m.includes(n)||m.push(n):h?(c[o]=[n],pt(u,o)&&(u[o]=c[o])):(o.value=[n],f.k&&(c[f.k]=o.value))}else h?(c[o]=r,pt(u,o)&&(u[o]=r)):l&&(o.value=r,f.k&&(c[f.k]=r))};r?(p.id=-1,Ai(p,t)):p()}}}const Ai=uP;function qP(f){return LP(f)}function LP(f,e){const t=SM();t.__VUE__=!0;const{insert:s,remove:i,patchProp:n,createElement:r,createText:a,createComment:o,setText:d,setElementText:c,parentNode:u,nextSibling:h,setScopeId:l=En,insertStaticContent:p}=f,m=(D,j,U,H=null,W=null,Y=null,z=!1,X=null,ne=!!j.dynamicChildren)=>{if(D===j)return;D&&!ao(D,j)&&(H=Oe(D),Q(D,W,Y,!0),D=null),j.patchFlag===-2&&(ne=!1,j.dynamicChildren=null);const{type:te,ref:ce,shapeFlag:ke}=j;switch(te){case xl:g(D,j,U,H);break;case Nn:y(D,j,U,H);break;case Cp:D==null&&b(j,U,H,z);break;case Ft:S(D,j,U,H,W,Y,z,X,ne);break;default:ke&1?T(D,j,U,H,W,Y,z,X,ne):ke&6?I(D,j,U,H,W,Y,z,X,ne):(ke&64||ke&128)&&te.process(D,j,U,H,W,Y,z,X,ne,Le)}ce!=null&&W&&ry(ce,D&&D.ref,Y,j||D,!j)},g=(D,j,U,H)=>{if(D==null)s(j.el=a(j.children),U,H);else{const W=j.el=D.el;j.children!==D.children&&d(W,j.children)}},y=(D,j,U,H)=>{D==null?s(j.el=o(j.children||""),U,H):j.el=D.el},b=(D,j,U,H)=>{[D.el,D.anchor]=p(D.children,j,U,H,D.el,D.anchor)},w=({el:D,anchor:j},U,H)=>{let W;for(;D&&D!==j;)W=h(D),s(D,U,H),D=W;s(j,U,H)},k=({el:D,anchor:j})=>{let U;for(;D&&D!==j;)U=h(D),i(D),D=U;i(j)},T=(D,j,U,H,W,Y,z,X,ne)=>{z=z||j.type==="svg",D==null?O(j,U,H,W,Y,z,X,ne):E(D,j,W,Y,z,X,ne)},O=(D,j,U,H,W,Y,z,X)=>{let ne,te;const{type:ce,props:ke,shapeFlag:ue,transition:Ie,dirs:Pe}=D;if(ne=D.el=r(D.type,Y,ke&&ke.is,ke),ue&8?c(ne,D.children):ue&16&&C(D.children,ne,null,H,W,Y&&ce!=="foreignObject",z,X),Pe&&va(D,null,H,"created"),ke){for(const M in ke)M!=="value"&&!Dh(M)&&n(ne,M,null,ke[M],Y,D.children,H,W,le);"value"in ke&&n(ne,"value",null,ke.value),(te=ke.onVnodeBeforeMount)&&qn(te,H,D)}x(ne,D,D.scopeId,z,H),Pe&&va(D,null,H,"beforeMount");const L=(!W||W&&!W.pendingBranch)&&Ie&&!Ie.persisted;L&&Ie.beforeEnter(ne),s(ne,j,U),((te=ke&&ke.onVnodeMounted)||L||Pe)&&Ai(()=>{te&&qn(te,H,D),L&&Ie.enter(ne),Pe&&va(D,null,H,"mounted")},W)},x=(D,j,U,H,W)=>{if(U&&l(D,U),H)for(let Y=0;Y<H.length;Y++)l(D,H[Y]);if(W){let Y=W.subTree;if(j===Y){const z=W.vnode;x(D,z,z.scopeId,z.slotScopeIds,W.parent)}}},C=(D,j,U,H,W,Y,z,X,ne=0)=>{for(let te=ne;te<D.length;te++){const ce=D[te]=X?la(D[te]):Qn(D[te]);m(null,ce,j,U,H,W,Y,z,X)}},E=(D,j,U,H,W,Y,z)=>{const X=j.el=D.el;let{patchFlag:ne,dynamicChildren:te,dirs:ce}=j;ne|=D.patchFlag&16;const ke=D.props||Nt,ue=j.props||Nt;let Ie;U&&Ta(U,!1),(Ie=ue.onVnodeBeforeUpdate)&&qn(Ie,U,j,D),ce&&va(j,D,U,"beforeUpdate"),U&&Ta(U,!0);const Pe=W&&j.type!=="foreignObject";if(te?P(D.dynamicChildren,te,X,U,H,Pe,Y):z||G(D,j,X,null,U,H,Pe,Y,!1),ne>0){if(ne&16)_(X,j,ke,ue,U,H,W);else if(ne&2&&ke.class!==ue.class&&n(X,"class",null,ue.class,W),ne&4&&n(X,"style",ke.style,ue.style,W),ne&8){const L=j.dynamicProps;for(let M=0;M<L.length;M++){const B=L[M],K=ke[B],Z=ue[B];(Z!==K||B==="value")&&n(X,B,K,Z,W,D.children,U,H,le)}}ne&1&&D.children!==j.children&&c(X,j.children)}else!z&&te==null&&_(X,j,ke,ue,U,H,W);((Ie=ue.onVnodeUpdated)||ce)&&Ai(()=>{Ie&&qn(Ie,U,j,D),ce&&va(j,D,U,"updated")},H)},P=(D,j,U,H,W,Y,z)=>{for(let X=0;X<j.length;X++){const ne=D[X],te=j[X],ce=ne.el&&(ne.type===Ft||!ao(ne,te)||ne.shapeFlag&70)?u(ne.el):U;m(ne,te,ce,null,H,W,Y,z,!0)}},_=(D,j,U,H,W,Y,z)=>{if(U!==H){if(U!==Nt)for(const X in U)!Dh(X)&&!(X in H)&&n(D,X,U[X],null,z,j.children,W,Y,le);for(const X in H){if(Dh(X))continue;const ne=H[X],te=U[X];ne!==te&&X!=="value"&&n(D,X,te,ne,z,j.children,W,Y,le)}"value"in H&&n(D,"value",U.value,H.value)}},S=(D,j,U,H,W,Y,z,X,ne)=>{const te=j.el=D?D.el:a(""),ce=j.anchor=D?D.anchor:a("");let{patchFlag:ke,dynamicChildren:ue,slotScopeIds:Ie}=j;Ie&&(X=X?X.concat(Ie):Ie),D==null?(s(te,U,H),s(ce,U,H),C(j.children,U,ce,W,Y,z,X,ne)):ke>0&&ke&64&&ue&&D.dynamicChildren?(P(D.dynamicChildren,ue,U,W,Y,z,X),(j.key!=null||W&&j===W.subTree)&&ob(D,j,!0)):G(D,j,U,ce,W,Y,z,X,ne)},I=(D,j,U,H,W,Y,z,X,ne)=>{j.slotScopeIds=X,D==null?j.shapeFlag&512?W.ctx.activate(j,U,H,z,ne):v(j,U,H,W,Y,z,ne):N(D,j,ne)},v=(D,j,U,H,W,Y,z)=>{const X=D.component=KP(D,H,W);if(Tl(D)&&(X.ctx.renderer=Le),XP(X),X.asyncDep){if(W&&W.registerDep(X,q),!D.el){const ne=X.subTree=$(Nn);y(null,ne,j,U)}return}q(X,D,j,U,W,Y,z)},N=(D,j,U)=>{const H=j.component=D.component;if(oP(D,j,U))if(H.asyncDep&&!H.asyncResolved){R(H,j,U);return}else H.next=j,tP(H.update),H.update();else j.el=D.el,H.vnode=j},q=(D,j,U,H,W,Y,z)=>{const X=()=>{if(D.isMounted){let{next:ce,bu:ke,u:ue,parent:Ie,vnode:Pe}=D,L=ce,M;Ta(D,!1),ce?(ce.el=Pe.el,R(D,ce,z)):ce=Pe,ke&&Tp(ke),(M=ce.props&&ce.props.onVnodeBeforeUpdate)&&qn(M,Ie,ce,Pe),Ta(D,!0);const B=Op(D),K=D.subTree;D.subTree=B,m(K,B,u(K.el),Oe(K),D,W,Y),ce.el=B.el,L===null&&dP(D,B.el),ue&&Ai(ue,W),(M=ce.props&&ce.props.onVnodeUpdated)&&Ai(()=>qn(M,Ie,ce,Pe),W)}else{let ce;const{el:ke,props:ue}=j,{bm:Ie,m:Pe,parent:L}=D,M=Gh(j);if(Ta(D,!1),Ie&&Tp(Ie),!M&&(ce=ue&&ue.onVnodeBeforeMount)&&qn(ce,L,j),Ta(D,!0),ke&&At){const B=()=>{D.subTree=Op(D),At(ke,D.subTree,D,W,null)};M?j.type.__asyncLoader().then(()=>!D.isUnmounted&&B()):B()}else{const B=D.subTree=Op(D);m(null,B,U,H,D,W,Y),j.el=B.el}if(Pe&&Ai(Pe,W),!M&&(ce=ue&&ue.onVnodeMounted)){const B=j;Ai(()=>qn(ce,L,B),W)}(j.shapeFlag&256||L&&Gh(L.vnode)&&L.vnode.shapeFlag&256)&&D.a&&Ai(D.a,W),D.isMounted=!0,j=U=H=null}},ne=D.effect=new zy(X,()=>tb(te),D.scope),te=D.update=()=>ne.run();te.id=D.uid,Ta(D,!0),te()},R=(D,j,U)=>{j.component=D;const H=D.vnode.props;D.vnode=j,D.next=null,PP(D,j.props,H,U),EP(D,j.children,U),xd(),bw(),_d()},G=(D,j,U,H,W,Y,z,X,ne=!1)=>{const te=D&&D.children,ce=D?D.shapeFlag:0,ke=j.children,{patchFlag:ue,shapeFlag:Ie}=j;if(ue>0){if(ue&128){A(te,ke,U,H,W,Y,z,X,ne);return}else if(ue&256){F(te,ke,U,H,W,Y,z,X,ne);return}}Ie&8?(ce&16&&le(te,W,Y),ke!==te&&c(U,ke)):ce&16?Ie&16?A(te,ke,U,H,W,Y,z,X,ne):le(te,W,Y,!0):(ce&8&&c(U,""),Ie&16&&C(ke,U,H,W,Y,z,X,ne))},F=(D,j,U,H,W,Y,z,X,ne)=>{D=D||fd,j=j||fd;const te=D.length,ce=j.length,ke=Math.min(te,ce);let ue;for(ue=0;ue<ke;ue++){const Ie=j[ue]=ne?la(j[ue]):Qn(j[ue]);m(D[ue],Ie,U,null,W,Y,z,X,ne)}te>ce?le(D,W,Y,!0,!1,ke):C(j,U,H,W,Y,z,X,ne,ke)},A=(D,j,U,H,W,Y,z,X,ne)=>{let te=0;const ce=j.length;let ke=D.length-1,ue=ce-1;for(;te<=ke&&te<=ue;){const Ie=D[te],Pe=j[te]=ne?la(j[te]):Qn(j[te]);if(ao(Ie,Pe))m(Ie,Pe,U,null,W,Y,z,X,ne);else break;te++}for(;te<=ke&&te<=ue;){const Ie=D[ke],Pe=j[ue]=ne?la(j[ue]):Qn(j[ue]);if(ao(Ie,Pe))m(Ie,Pe,U,null,W,Y,z,X,ne);else break;ke--,ue--}if(te>ke){if(te<=ue){const Ie=ue+1,Pe=Ie<ce?j[Ie].el:H;for(;te<=ue;)m(null,j[te]=ne?la(j[te]):Qn(j[te]),U,Pe,W,Y,z,X,ne),te++}}else if(te>ue)for(;te<=ke;)Q(D[te],W,Y,!0),te++;else{const Ie=te,Pe=te,L=new Map;for(te=Pe;te<=ue;te++){const We=j[te]=ne?la(j[te]):Qn(j[te]);We.key!=null&&L.set(We.key,te)}let M,B=0;const K=ue-Pe+1;let Z=!1,re=0;const ae=new Array(K);for(te=0;te<K;te++)ae[te]=0;for(te=Ie;te<=ke;te++){const We=D[te];if(B>=K){Q(We,W,Y,!0);continue}let Ne;if(We.key!=null)Ne=L.get(We.key);else for(M=Pe;M<=ue;M++)if(ae[M-Pe]===0&&ao(We,j[M])){Ne=M;break}Ne===void 0?Q(We,W,Y,!0):(ae[Ne-Pe]=te+1,Ne>=re?re=Ne:Z=!0,m(We,j[Ne],U,null,W,Y,z,X,ne),B++)}const Ee=Z?RP(ae):fd;for(M=Ee.length-1,te=K-1;te>=0;te--){const We=Pe+te,Ne=j[We],De=We+1<ce?j[We+1].el:H;ae[te]===0?m(null,Ne,U,De,W,Y,z,X,ne):Z&&(M<0||te!==Ee[M]?V(Ne,U,De,2):M--)}}},V=(D,j,U,H,W=null)=>{const{el:Y,type:z,transition:X,children:ne,shapeFlag:te}=D;if(te&6){V(D.component.subTree,j,U,H);return}if(te&128){D.suspense.move(j,U,H);return}if(te&64){z.move(D,j,U,Le);return}if(z===Ft){s(Y,j,U);for(let ke=0;ke<ne.length;ke++)V(ne[ke],j,U,H);s(D.anchor,j,U);return}if(z===Cp){w(D,j,U);return}if(H!==2&&te&1&&X)if(H===0)X.beforeEnter(Y),s(Y,j,U),Ai(()=>X.enter(Y),W);else{const{leave:ke,delayLeave:ue,afterLeave:Ie}=X,Pe=()=>s(Y,j,U),L=()=>{ke(Y,()=>{Pe(),Ie&&Ie()})};ue?ue(Y,Pe,L):L()}else s(Y,j,U)},Q=(D,j,U,H=!1,W=!1)=>{const{type:Y,props:z,ref:X,children:ne,dynamicChildren:te,shapeFlag:ce,patchFlag:ke,dirs:ue}=D;if(X!=null&&ry(X,null,U,D,!0),ce&256){j.ctx.deactivate(D);return}const Ie=ce&1&&ue,Pe=!Gh(D);let L;if(Pe&&(L=z&&z.onVnodeBeforeUnmount)&&qn(L,j,D),ce&6)we(D.component,U,H);else{if(ce&128){D.suspense.unmount(U,H);return}Ie&&va(D,null,j,"beforeUnmount"),ce&64?D.type.remove(D,j,U,W,Le,H):te&&(Y!==Ft||ke>0&&ke&64)?le(te,j,U,!1,!0):(Y===Ft&&ke&384||!W&&ce&16)&&le(ne,j,U),H&&J(D)}(Pe&&(L=z&&z.onVnodeUnmounted)||Ie)&&Ai(()=>{L&&qn(L,j,D),Ie&&va(D,null,j,"unmounted")},U)},J=D=>{const{type:j,el:U,anchor:H,transition:W}=D;if(j===Ft){se(U,H);return}if(j===Cp){k(D);return}const Y=()=>{i(U),W&&!W.persisted&&W.afterLeave&&W.afterLeave()};if(D.shapeFlag&1&&W&&!W.persisted){const{leave:z,delayLeave:X}=W,ne=()=>z(U,Y);X?X(D.el,Y,ne):ne()}else Y()},se=(D,j)=>{let U;for(;D!==j;)U=h(D),i(D),D=U;i(j)},we=(D,j,U)=>{const{bum:H,scope:W,update:Y,subTree:z,um:X}=D;H&&Tp(H),W.stop(),Y&&(Y.active=!1,Q(z,D,j,U)),X&&Ai(X,j),Ai(()=>{D.isUnmounted=!0},j),j&&j.pendingBranch&&!j.isUnmounted&&D.asyncDep&&!D.asyncResolved&&D.suspenseId===j.pendingId&&(j.deps--,j.deps===0&&j.resolve())},le=(D,j,U,H=!1,W=!1,Y=0)=>{for(let z=Y;z<D.length;z++)Q(D[z],j,U,H,W)},Oe=D=>D.shapeFlag&6?Oe(D.component.subTree):D.shapeFlag&128?D.suspense.next():h(D.anchor||D.el),Ce=(D,j,U)=>{D==null?j._vnode&&Q(j._vnode,null,null,!0):m(j._vnode||null,D,j,null,null,null,U),bw(),DI(),j._vnode=D},Le={p:m,um:Q,m:V,r:J,mt:v,mc:C,pc:G,pbc:P,n:Oe,o:f};let Fe,At;return e&&([Fe,At]=e(Le)),{render:Ce,hydrate:Fe,createApp:VP(Ce,Fe)}}function Ta({effect:f,update:e},t){f.allowRecurse=e.allowRecurse=t}function ob(f,e,t=!1){const s=f.children,i=e.children;if(Ue(s)&&Ue(i))for(let n=0;n<s.length;n++){const r=s[n];let a=i[n];a.shapeFlag&1&&!a.dynamicChildren&&((a.patchFlag<=0||a.patchFlag===32)&&(a=i[n]=la(i[n]),a.el=r.el),t||ob(r,a)),a.type===xl&&(a.el=r.el)}}function RP(f){const e=f.slice(),t=[0];let s,i,n,r,a;const o=f.length;for(s=0;s<o;s++){const d=f[s];if(d!==0){if(i=t[t.length-1],f[i]<d){e[s]=i,t.push(s);continue}for(n=0,r=t.length-1;n<r;)a=n+r>>1,f[t[a]]<d?n=a+1:r=a;d<f[t[n]]&&(n>0&&(e[s]=t[n-1]),t[n]=s)}}for(n=t.length,r=t[n-1];n-- >0;)t[n]=r,r=e[r];return t}const FP=f=>f.__isTeleport,lu=f=>f&&(f.disabled||f.disabled===""),Cw=f=>typeof SVGElement<"u"&&f instanceof SVGElement,ay=(f,e)=>{const t=f&&f.to;return gs(t)?e?e(t):null:t},DP={__isTeleport:!0,process(f,e,t,s,i,n,r,a,o,d){const{mc:c,pc:u,pbc:h,o:{insert:l,querySelector:p,createText:m,createComment:g}}=d,y=lu(e.props);let{shapeFlag:b,children:w,dynamicChildren:k}=e;if(f==null){const T=e.el=m(""),O=e.anchor=m("");l(T,t,s),l(O,t,s);const x=e.target=ay(e.props,p),C=e.targetAnchor=m("");x&&(l(C,x),r=r||Cw(x));const E=(P,_)=>{b&16&&c(w,P,_,i,n,r,a,o)};y?E(t,O):x&&E(x,C)}else{e.el=f.el;const T=e.anchor=f.anchor,O=e.target=f.target,x=e.targetAnchor=f.targetAnchor,C=lu(f.props),E=C?t:O,P=C?T:x;if(r=r||Cw(O),k?(h(f.dynamicChildren,k,E,i,n,r,a),ob(f,e,!0)):o||u(f,e,E,P,i,n,r,a,!1),y)C||nf(e,t,T,d,1);else if((e.props&&e.props.to)!==(f.props&&f.props.to)){const _=e.target=ay(e.props,p);_&&nf(e,_,null,d,0)}else C&&nf(e,O,x,d,1)}cx(e)},remove(f,e,t,s,{um:i,o:{remove:n}},r){const{shapeFlag:a,children:o,anchor:d,targetAnchor:c,target:u,props:h}=f;if(u&&n(c),(r||!lu(h))&&(n(d),a&16))for(let l=0;l<o.length;l++){const p=o[l];i(p,e,t,!0,!!p.dynamicChildren)}},move:nf,hydrate:HP};function nf(f,e,t,{o:{insert:s},m:i},n=2){n===0&&s(f.targetAnchor,e,t);const{el:r,anchor:a,shapeFlag:o,children:d,props:c}=f,u=n===2;if(u&&s(r,e,t),(!u||lu(c))&&o&16)for(let h=0;h<d.length;h++)i(d[h],e,t,2);u&&s(a,e,t)}function HP(f,e,t,s,i,n,{o:{nextSibling:r,parentNode:a,querySelector:o}},d){const c=e.target=ay(e.props,o);if(c){const u=c._lpa||c.firstChild;if(e.shapeFlag&16)if(lu(e.props))e.anchor=d(r(f),e,a(f),t,s,i,n),e.targetAnchor=u;else{e.anchor=r(f);let h=u;for(;h;)if(h=r(h),h&&h.nodeType===8&&h.data==="teleport anchor"){e.targetAnchor=h,c._lpa=e.targetAnchor&&r(e.targetAnchor);break}d(u,e,c,t,s,i,n)}cx(e)}return e.anchor&&r(e.anchor)}const GP=DP;function cx(f){const e=f.ctx;if(e&&e.ut){let t=f.children[0].el;for(;t!==f.targetAnchor;)t.nodeType===1&&t.setAttribute("data-v-owner",e.uid),t=t.nextSibling;e.ut()}}const Ft=Symbol(void 0),xl=Symbol(void 0),Nn=Symbol(void 0),Cp=Symbol(void 0),pu=[];let Bn=null;function Ge(f=!1){pu.push(Bn=f?null:[])}function UP(){pu.pop(),Bn=pu[pu.length-1]||null}let Ou=1;function Mw(f){Ou+=f}function ux(f){return f.dynamicChildren=Ou>0?Bn||fd:null,UP(),Ou>0&&Bn&&Bn.push(f),f}function bi(f,e,t,s,i,n){return ux(mi(f,e,t,s,i,n,!0))}function lt(f,e,t,s,i){return ux($(f,e,t,s,i,!0))}function oy(f){return f?f.__v_isVNode===!0:!1}function ao(f,e){return f.type===e.type&&f.key===e.key}const _l="__vInternal",fx=({key:f})=>f!=null?f:null,Uh=({ref:f,ref_key:e,ref_for:t})=>f!=null?gs(f)||Qt(f)||Ze(f)?{i:Di,r:f,k:e,f:!!t}:f:null;function mi(f,e=null,t=null,s=0,i=null,n=f===Ft?0:1,r=!1,a=!1){const o={__v_isVNode:!0,__v_skip:!0,type:f,props:e,key:e&&fx(e),ref:e&&Uh(e),scopeId:UI,slotScopeIds:null,children:t,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetAnchor:null,staticCount:0,shapeFlag:n,patchFlag:s,dynamicProps:i,dynamicChildren:null,appContext:null,ctx:Di};return a?(db(o,t),n&128&&f.normalize(o)):t&&(o.shapeFlag|=gs(t)?8:16),Ou>0&&!r&&Bn&&(o.patchFlag>0||n&6)&&o.patchFlag!==32&&Bn.push(o),o}const $=$P;function $P(f,e=null,t=null,s=0,i=null,n=!1){if((!f||f===ex)&&(f=Nn),oy(f)){const a=Ir(f,e,!0);return t&&db(a,t),Ou>0&&!n&&Bn&&(a.shapeFlag&6?Bn[Bn.indexOf(f)]=a:Bn.push(a)),a.patchFlag|=-2,a}if(eA(f)&&(f=f.__vccOpts),e){e=jP(e);let{class:a,style:o}=e;a&&!gs(a)&&(e.class=Dy(a)),qt(o)&&(PI(o)&&!Ue(o)&&(o=Ls({},o)),e.style=Pi(o))}const r=gs(f)?1:cP(f)?128:FP(f)?64:qt(f)?4:Ze(f)?2:0;return mi(f,e,t,s,i,r,n,!0)}function jP(f){return f?PI(f)||_l in f?Ls({},f):f:null}function Ir(f,e,t=!1){const{props:s,ref:i,patchFlag:n,children:r}=f,a=e?Je(s||{},e):s;return{__v_isVNode:!0,__v_skip:!0,type:f.type,props:a,key:a&&fx(a),ref:e&&e.ref?t&&i?Ue(i)?i.concat(Uh(e)):[i,Uh(e)]:Uh(e):i,scopeId:f.scopeId,slotScopeIds:f.slotScopeIds,children:r,target:f.target,targetAnchor:f.targetAnchor,staticCount:f.staticCount,shapeFlag:f.shapeFlag,patchFlag:e&&f.type!==Ft?n===-1?16:n|16:n,dynamicProps:f.dynamicProps,dynamicChildren:f.dynamicChildren,appContext:f.appContext,dirs:f.dirs,transition:f.transition,component:f.component,suspense:f.suspense,ssContent:f.ssContent&&Ir(f.ssContent),ssFallback:f.ssFallback&&Ir(f.ssFallback),el:f.el,anchor:f.anchor,ctx:f.ctx}}function et(f=" ",e=0){return $(xl,null,f,e)}function tt(f="",e=!1){return e?(Ge(),lt(Nn,null,f)):$(Nn,null,f)}function Qn(f){return f==null||typeof f=="boolean"?$(Nn):Ue(f)?$(Ft,null,f.slice()):typeof f=="object"?la(f):$(xl,null,String(f))}function la(f){return f.el===null&&f.patchFlag!==-1||f.memo?f:Ir(f)}function db(f,e){let t=0;const{shapeFlag:s}=f;if(e==null)e=null;else if(Ue(e))t=16;else if(typeof e=="object")if(s&65){const i=e.default;i&&(i._c&&(i._d=!1),db(f,i()),i._c&&(i._d=!0));return}else{t=32;const i=e._;!i&&!(_l in e)?e._ctx=Di:i===3&&Di&&(Di.slots._===1?e._=1:(e._=2,f.patchFlag|=1024))}else Ze(e)?(e={default:e,_ctx:Di},t=32):(e=String(e),s&64?(t=16,e=[et(e)]):t=8);f.children=e,f.shapeFlag|=t}function Je(...f){const e={};for(let t=0;t<f.length;t++){const s=f[t];for(const i in s)if(i==="class")e.class!==s.class&&(e.class=Dy([e.class,s.class]));else if(i==="style")e.style=Pi([e.style,s.style]);else if(gl(i)){const n=e[i],r=s[i];r&&n!==r&&!(Ue(n)&&n.includes(r))&&(e[i]=n?[].concat(n,r):r)}else i!==""&&(e[i]=s[i])}return e}function qn(f,e,t,s=null){hn(f,e,7,[t,s])}const WP=dx();let zP=0;function KP(f,e,t){const s=f.type,i=(e?e.appContext:f.appContext)||WP,n={uid:zP++,vnode:f,type:s,parent:e,appContext:i,root:null,next:null,subTree:null,effect:null,update:null,scope:new bI(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:e?e.provides:Object.create(i.provides),accessCache:null,renderCache:[],components:null,directives:null,propsOptions:nx(s,i),emitsOptions:GI(s,i),emit:null,emitted:null,propsDefaults:Nt,inheritAttrs:s.inheritAttrs,ctx:Nt,data:Nt,props:Nt,attrs:Nt,slots:Nt,refs:Nt,setupState:Nt,setupContext:null,suspense:t,suspenseId:t?t.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return n.ctx={_:n},n.root=e?e.root:n,n.emit=nP.bind(null,n),f.ce&&f.ce(n),n}let qs=null;const Cl=()=>qs||Di,wd=f=>{qs=f,f.scope.on()},lo=()=>{qs&&qs.scope.off(),qs=null};function hx(f){return f.vnode.shapeFlag&4}let Iu=!1;function XP(f,e=!1){Iu=e;const{props:t,children:s}=f.vnode,i=hx(f);MP(f,t,i,e),BP(f,s);const n=i?YP(f,e):void 0;return Iu=!1,n}function YP(f,e){const t=f.type;f.accessCache=Object.create(null),f.proxy=AI(new Proxy(f.ctx,TP));const{setup:s}=t;if(s){const i=f.setupContext=s.length>1?ZP(f):null;wd(f),xd();const n=ya(s,f,0,[f.props,i]);if(_d(),lo(),mI(n)){if(n.then(lo,lo),e)return n.then(r=>{Pw(f,r,e)}).catch(r=>{Sl(r,f,0)});f.asyncDep=n}else Pw(f,n,e)}else lx(f,e)}function Pw(f,e,t){Ze(e)?f.type.__ssrInlineRender?f.ssrRender=e:f.render=e:qt(e)&&(f.setupState=VI(e)),lx(f,t)}let Aw;function lx(f,e,t){const s=f.type;if(!f.render){if(!e&&Aw&&!s.render){const i=s.template||rb(f).template;if(i){const{isCustomElement:n,compilerOptions:r}=f.appContext.config,{delimiters:a,compilerOptions:o}=s,d=Ls(Ls({isCustomElement:n,delimiters:a},r),o);s.render=Aw(i,d)}}f.render=s.render||En}wd(f),xd(),OP(f),_d(),lo()}function QP(f){return new Proxy(f.attrs,{get(e,t){return Hi(f,"get","$attrs"),e[t]}})}function ZP(f){const e=s=>{f.exposed=s||{}};let t;return{get attrs(){return t||(t=QP(f))},slots:f.slots,emit:f.emit,expose:e}}function Ml(f){if(f.exposed)return f.exposeProxy||(f.exposeProxy=new Proxy(VI(AI(f.exposed)),{get(e,t){if(t in e)return e[t];if(t in hu)return hu[t](f)},has(e,t){return t in e||t in hu}}))}function JP(f,e=!0){return Ze(f)?f.displayName||f.name:f.name||e&&f.__name}function eA(f){return Ze(f)&&"__vccOpts"in f}const ie=(f,e)=>LI(f,e,Iu);function Sa(f,e,t){const s=arguments.length;return s===2?qt(e)&&!Ue(e)?oy(e)?$(f,null,[e]):$(f,e):$(f,null,e):(s>3?t=Array.prototype.slice.call(arguments,2):s===3&&oy(t)&&(t=[t]),$(f,e,t))}const tA=Symbol(""),sA=()=>Zt(tA),iA="3.2.45",nA="http://www.w3.org/2000/svg",oo=typeof document<"u"?document:null,Bw=oo&&oo.createElement("template"),rA={insert:(f,e,t)=>{e.insertBefore(f,t||null)},remove:f=>{const e=f.parentNode;e&&e.removeChild(f)},createElement:(f,e,t,s)=>{const i=e?oo.createElementNS(nA,f):oo.createElement(f,t?{is:t}:void 0);return f==="select"&&s&&s.multiple!=null&&i.setAttribute("multiple",s.multiple),i},createText:f=>oo.createTextNode(f),createComment:f=>oo.createComment(f),setText:(f,e)=>{f.nodeValue=e},setElementText:(f,e)=>{f.textContent=e},parentNode:f=>f.parentNode,nextSibling:f=>f.nextSibling,querySelector:f=>oo.querySelector(f),setScopeId(f,e){f.setAttribute(e,"")},insertStaticContent(f,e,t,s,i,n){const r=t?t.previousSibling:e.lastChild;if(i&&(i===n||i.nextSibling))for(;e.insertBefore(i.cloneNode(!0),t),!(i===n||!(i=i.nextSibling)););else{Bw.innerHTML=s?`<svg>${f}</svg>`:f;const a=Bw.content;if(s){const o=a.firstChild;for(;o.firstChild;)a.appendChild(o.firstChild);a.removeChild(o)}e.insertBefore(a,t)}return[r?r.nextSibling:e.firstChild,t?t.previousSibling:e.lastChild]}};function aA(f,e,t){const s=f._vtc;s&&(e=(e?[e,...s]:[...s]).join(" ")),e==null?f.removeAttribute("class"):t?f.setAttribute("class",e):f.className=e}function oA(f,e,t){const s=f.style,i=gs(t);if(t&&!i){for(const n in t)dy(s,n,t[n]);if(e&&!gs(e))for(const n in e)t[n]==null&&dy(s,n,"")}else{const n=s.display;i?e!==t&&(s.cssText=t):e&&f.removeAttribute("style"),"_vod"in f&&(s.display=n)}}const Ew=/\s*!important$/;function dy(f,e,t){if(Ue(t))t.forEach(s=>dy(f,e,s));else if(t==null&&(t=""),e.startsWith("--"))f.setProperty(e,t);else{const s=dA(f,e);Ew.test(t)?f.setProperty(Id(s),t.replace(Ew,""),"important"):f[s]=t}}const Nw=["Webkit","Moz","ms"],Mp={};function dA(f,e){const t=Mp[e];if(t)return t;let s=pn(e);if(s!=="filter"&&s in f)return Mp[e]=s;s=Cr(s);for(let i=0;i<Nw.length;i++){const n=Nw[i]+s;if(n in f)return Mp[e]=n}return e}const Vw="http://www.w3.org/1999/xlink";function cA(f,e,t,s,i){if(s&&e.startsWith("xlink:"))t==null?f.removeAttributeNS(Vw,e.slice(6,e.length)):f.setAttributeNS(Vw,e,t);else{const n=pM(e);t==null||n&&!hI(t)?f.removeAttribute(e):f.setAttribute(e,n?"":t)}}function uA(f,e,t,s,i,n,r){if(e==="innerHTML"||e==="textContent"){s&&r(s,i,n),f[e]=t==null?"":t;return}if(e==="value"&&f.tagName!=="PROGRESS"&&!f.tagName.includes("-")){f._value=t;const o=t==null?"":t;(f.value!==o||f.tagName==="OPTION")&&(f.value=o),t==null&&f.removeAttribute(e);return}let a=!1;if(t===""||t==null){const o=typeof f[e];o==="boolean"?t=hI(t):t==null&&o==="string"?(t="",a=!0):o==="number"&&(t=0,a=!0)}try{f[e]=t}catch{}a&&f.removeAttribute(e)}function fA(f,e,t,s){f.addEventListener(e,t,s)}function hA(f,e,t,s){f.removeEventListener(e,t,s)}function lA(f,e,t,s,i=null){const n=f._vei||(f._vei={}),r=n[e];if(s&&r)r.value=s;else{const[a,o]=pA(e);if(s){const d=n[e]=yA(s,i);fA(f,a,d,o)}else r&&(hA(f,a,r,o),n[e]=void 0)}}const qw=/(?:Once|Passive|Capture)$/;function pA(f){let e;if(qw.test(f)){e={};let s;for(;s=f.match(qw);)f=f.slice(0,f.length-s[0].length),e[s[0].toLowerCase()]=!0}return[f[2]===":"?f.slice(3):Id(f.slice(2)),e]}let Pp=0;const mA=Promise.resolve(),gA=()=>Pp||(mA.then(()=>Pp=0),Pp=Date.now());function yA(f,e){const t=s=>{if(!s._vts)s._vts=Date.now();else if(s._vts<=t.attached)return;hn(bA(s,t.value),e,5,[s])};return t.value=f,t.attached=gA(),t}function bA(f,e){if(Ue(e)){const t=f.stopImmediatePropagation;return f.stopImmediatePropagation=()=>{t.call(f),f._stopped=!0},e.map(s=>i=>!i._stopped&&s&&s(i))}else return e}const Lw=/^on[a-z]/,wA=(f,e,t,s,i=!1,n,r,a,o)=>{e==="class"?aA(f,s,i):e==="style"?oA(f,t,s):gl(e)?Hy(e)||lA(f,e,t,s,r):(e[0]==="."?(e=e.slice(1),!0):e[0]==="^"?(e=e.slice(1),!1):kA(f,e,s,i))?uA(f,e,s,n,r,a,o):(e==="true-value"?f._trueValue=s:e==="false-value"&&(f._falseValue=s),cA(f,e,s,i))};function kA(f,e,t,s){return s?!!(e==="innerHTML"||e==="textContent"||e in f&&Lw.test(e)&&Ze(t)):e==="spellcheck"||e==="draggable"||e==="translate"||e==="form"||e==="list"&&f.tagName==="INPUT"||e==="type"&&f.tagName==="TEXTAREA"||Lw.test(e)&&gs(t)?!1:e in f}const Rr="transition",$d="animation",sr=(f,{slots:e})=>Sa(WI,mx(f),e);sr.displayName="Transition";const px={name:String,type:String,css:{type:Boolean,default:!0},duration:[String,Number,Object],enterFromClass:String,enterActiveClass:String,enterToClass:String,appearFromClass:String,appearActiveClass:String,appearToClass:String,leaveFromClass:String,leaveActiveClass:String,leaveToClass:String},SA=sr.props=Ls({},WI.props,px),Oa=(f,e=[])=>{Ue(f)?f.forEach(t=>t(...e)):f&&f(...e)},Rw=f=>f?Ue(f)?f.some(e=>e.length>1):f.length>1:!1;function mx(f){const e={};for(const S in f)S in px||(e[S]=f[S]);if(f.css===!1)return e;const{name:t="v",type:s,duration:i,enterFromClass:n=`${t}-enter-from`,enterActiveClass:r=`${t}-enter-active`,enterToClass:a=`${t}-enter-to`,appearFromClass:o=n,appearActiveClass:d=r,appearToClass:c=a,leaveFromClass:u=`${t}-leave-from`,leaveActiveClass:h=`${t}-leave-active`,leaveToClass:l=`${t}-leave-to`}=f,p=vA(i),m=p&&p[0],g=p&&p[1],{onBeforeEnter:y,onEnter:b,onEnterCancelled:w,onLeave:k,onLeaveCancelled:T,onBeforeAppear:O=y,onAppear:x=b,onAppearCancelled:C=w}=e,E=(S,I,v)=>{ha(S,I?c:a),ha(S,I?d:r),v&&v()},P=(S,I)=>{S._isLeaving=!1,ha(S,u),ha(S,l),ha(S,h),I&&I()},_=S=>(I,v)=>{const N=S?x:b,q=()=>E(I,S,v);Oa(N,[I,q]),Fw(()=>{ha(I,S?o:n),kr(I,S?c:a),Rw(N)||Dw(I,s,m,q)})};return Ls(e,{onBeforeEnter(S){Oa(y,[S]),kr(S,n),kr(S,r)},onBeforeAppear(S){Oa(O,[S]),kr(S,o),kr(S,d)},onEnter:_(!1),onAppear:_(!0),onLeave(S,I){S._isLeaving=!0;const v=()=>P(S,I);kr(S,u),yx(),kr(S,h),Fw(()=>{!S._isLeaving||(ha(S,u),kr(S,l),Rw(k)||Dw(S,s,g,v))}),Oa(k,[S,v])},onEnterCancelled(S){E(S,!1),Oa(w,[S])},onAppearCancelled(S){E(S,!0),Oa(C,[S])},onLeaveCancelled(S){P(S),Oa(T,[S])}})}function vA(f){if(f==null)return null;if(qt(f))return[Ap(f.enter),Ap(f.leave)];{const e=Ap(f);return[e,e]}}function Ap(f){return jy(f)}function kr(f,e){e.split(/\s+/).forEach(t=>t&&f.classList.add(t)),(f._vtc||(f._vtc=new Set)).add(e)}function ha(f,e){e.split(/\s+/).forEach(s=>s&&f.classList.remove(s));const{_vtc:t}=f;t&&(t.delete(e),t.size||(f._vtc=void 0))}function Fw(f){requestAnimationFrame(()=>{requestAnimationFrame(f)})}let TA=0;function Dw(f,e,t,s){const i=f._endId=++TA,n=()=>{i===f._endId&&s()};if(t)return setTimeout(n,t);const{type:r,timeout:a,propCount:o}=gx(f,e);if(!r)return s();const d=r+"end";let c=0;const u=()=>{f.removeEventListener(d,h),n()},h=l=>{l.target===f&&++c>=o&&u()};setTimeout(()=>{c<o&&u()},a+1),f.addEventListener(d,h)}function gx(f,e){const t=window.getComputedStyle(f),s=p=>(t[p]||"").split(", "),i=s(`${Rr}Delay`),n=s(`${Rr}Duration`),r=Hw(i,n),a=s(`${$d}Delay`),o=s(`${$d}Duration`),d=Hw(a,o);let c=null,u=0,h=0;e===Rr?r>0&&(c=Rr,u=r,h=n.length):e===$d?d>0&&(c=$d,u=d,h=o.length):(u=Math.max(r,d),c=u>0?r>d?Rr:$d:null,h=c?c===Rr?n.length:o.length:0);const l=c===Rr&&/\b(transform|all)(,|$)/.test(s(`${Rr}Property`).toString());return{type:c,timeout:u,propCount:h,hasTransform:l}}function Hw(f,e){for(;f.length<e.length;)f=f.concat(f);return Math.max(...e.map((t,s)=>Gw(t)+Gw(f[s])))}function Gw(f){return Number(f.slice(0,-1).replace(",","."))*1e3}function yx(){return document.body.offsetHeight}const bx=new WeakMap,wx=new WeakMap,OA={name:"TransitionGroup",props:Ls({},SA,{tag:String,moveClass:String}),setup(f,{slots:e}){const t=Cl(),s=jI();let i,n;return QI(()=>{if(!i.length)return;const r=f.moveClass||`${f.name||"v"}-move`;if(!MA(i[0].el,t.vnode.el,r))return;i.forEach(xA),i.forEach(_A);const a=i.filter(CA);yx(),a.forEach(o=>{const d=o.el,c=d.style;kr(d,r),c.transform=c.webkitTransform=c.transitionDuration="";const u=d._moveCb=h=>{h&&h.target!==d||(!h||/transform$/.test(h.propertyName))&&(d.removeEventListener("transitionend",u),d._moveCb=null,ha(d,r))};d.addEventListener("transitionend",u)})}),()=>{const r=mt(f),a=mx(r);let o=r.tag||Ft;i=n,n=e.default?ib(e.default()):[];for(let d=0;d<n.length;d++){const c=n[d];c.key!=null&&Tu(c,vu(c,a,s,t))}if(i)for(let d=0;d<i.length;d++){const c=i[d];Tu(c,vu(c,a,s,t)),bx.set(c,c.el.getBoundingClientRect())}return $(o,null,n)}}},IA=OA;function xA(f){const e=f.el;e._moveCb&&e._moveCb(),e._enterCb&&e._enterCb()}function _A(f){wx.set(f,f.el.getBoundingClientRect())}function CA(f){const e=bx.get(f),t=wx.get(f),s=e.left-t.left,i=e.top-t.top;if(s||i){const n=f.el.style;return n.transform=n.webkitTransform=`translate(${s}px,${i}px)`,n.transitionDuration="0s",f}}function MA(f,e,t){const s=f.cloneNode();f._vtc&&f._vtc.forEach(r=>{r.split(/\s+/).forEach(a=>a&&s.classList.remove(a))}),t.split(/\s+/).forEach(r=>r&&s.classList.add(r)),s.style.display="none";const i=e.nodeType===1?e:e.parentNode;i.appendChild(s);const{hasTransform:n}=gx(s);return i.removeChild(s),n}const Cd={beforeMount(f,{value:e},{transition:t}){f._vod=f.style.display==="none"?"":f.style.display,t&&e?t.beforeEnter(f):jd(f,e)},mounted(f,{value:e},{transition:t}){t&&e&&t.enter(f)},updated(f,{value:e,oldValue:t},{transition:s}){!e!=!t&&(s?e?(s.beforeEnter(f),jd(f,!0),s.enter(f)):s.leave(f,()=>{jd(f,!1)}):jd(f,e))},beforeUnmount(f,{value:e}){jd(f,e)}};function jd(f,e){f.style.display=e?f._vod:"none"}const PA=Ls({patchProp:wA},rA);let Uw;function AA(){return Uw||(Uw=qP(PA))}const BA=(...f)=>{const e=AA().createApp(...f),{mount:t}=e;return e.mount=s=>{const i=EA(s);if(!i)return;const n=e._component;!Ze(n)&&!n.render&&!n.template&&(n.template=i.innerHTML),i.innerHTML="";const r=t(i,!1,i instanceof SVGElement);return i instanceof Element&&(i.removeAttribute("v-cloak"),i.setAttribute("data-v-app","")),r},e};function EA(f){return gs(f)?document.querySelector(f):f}function kx(f,e){return function(){return f.apply(e,arguments)}}const{toString:Sx}=Object.prototype,{getPrototypeOf:cb}=Object,ub=(f=>e=>{const t=Sx.call(e);return f[t]||(f[t]=t.slice(8,-1).toLowerCase())})(Object.create(null)),Ar=f=>(f=f.toLowerCase(),e=>ub(e)===f),Pl=f=>e=>typeof e===f,{isArray:Nu}=Array,cy=Pl("undefined");function NA(f){return f!==null&&!cy(f)&&f.constructor!==null&&!cy(f.constructor)&&Md(f.constructor.isBuffer)&&f.constructor.isBuffer(f)}const vx=Ar("ArrayBuffer");function VA(f){let e;return typeof ArrayBuffer<"u"&&ArrayBuffer.isView?e=ArrayBuffer.isView(f):e=f&&f.buffer&&vx(f.buffer),e}const qA=Pl("string"),Md=Pl("function"),Tx=Pl("number"),Ox=f=>f!==null&&typeof f=="object",LA=f=>f===!0||f===!1,$h=f=>{if(ub(f)!=="object")return!1;const e=cb(f);return(e===null||e===Object.prototype||Object.getPrototypeOf(e)===null)&&!(Symbol.toStringTag in f)&&!(Symbol.iterator in f)},RA=Ar("Date"),FA=Ar("File"),DA=Ar("Blob"),HA=Ar("FileList"),GA=f=>Ox(f)&&Md(f.pipe),UA=f=>{const e="[object FormData]";return f&&(typeof FormData=="function"&&f instanceof FormData||Sx.call(f)===e||Md(f.toString)&&f.toString()===e)},$A=Ar("URLSearchParams"),jA=f=>f.trim?f.trim():f.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"");function Al(f,e,{allOwnKeys:t=!1}={}){if(f===null||typeof f>"u")return;let s,i;if(typeof f!="object"&&(f=[f]),Nu(f))for(s=0,i=f.length;s<i;s++)e.call(null,f[s],s,f);else{const n=t?Object.getOwnPropertyNames(f):Object.keys(f),r=n.length;let a;for(s=0;s<r;s++)a=n[s],e.call(null,f[a],a,f)}}function uy(){const f={},e=(t,s)=>{$h(f[s])&&$h(t)?f[s]=uy(f[s],t):$h(t)?f[s]=uy({},t):Nu(t)?f[s]=t.slice():f[s]=t};for(let t=0,s=arguments.length;t<s;t++)arguments[t]&&Al(arguments[t],e);return f}const WA=(f,e,t,{allOwnKeys:s}={})=>(Al(e,(i,n)=>{t&&Md(i)?f[n]=kx(i,t):f[n]=i},{allOwnKeys:s}),f),zA=f=>(f.charCodeAt(0)===65279&&(f=f.slice(1)),f),KA=(f,e,t,s)=>{f.prototype=Object.create(e.prototype,s),f.prototype.constructor=f,Object.defineProperty(f,"super",{value:e.prototype}),t&&Object.assign(f.prototype,t)},XA=(f,e,t,s)=>{let i,n,r;const a={};if(e=e||{},f==null)return e;do{for(i=Object.getOwnPropertyNames(f),n=i.length;n-- >0;)r=i[n],(!s||s(r,f,e))&&!a[r]&&(e[r]=f[r],a[r]=!0);f=t!==!1&&cb(f)}while(f&&(!t||t(f,e))&&f!==Object.prototype);return e},YA=(f,e,t)=>{f=String(f),(t===void 0||t>f.length)&&(t=f.length),t-=e.length;const s=f.indexOf(e,t);return s!==-1&&s===t},QA=f=>{if(!f)return null;if(Nu(f))return f;let e=f.length;if(!Tx(e))return null;const t=new Array(e);for(;e-- >0;)t[e]=f[e];return t},ZA=(f=>e=>f&&e instanceof f)(typeof Uint8Array<"u"&&cb(Uint8Array)),JA=(f,e)=>{const s=(f&&f[Symbol.iterator]).call(f);let i;for(;(i=s.next())&&!i.done;){const n=i.value;e.call(f,n[0],n[1])}},eB=(f,e)=>{let t;const s=[];for(;(t=f.exec(e))!==null;)s.push(t);return s},tB=Ar("HTMLFormElement"),sB=f=>f.toLowerCase().replace(/[_-\s]([a-z\d])(\w*)/g,function(t,s,i){return s.toUpperCase()+i}),$w=(({hasOwnProperty:f})=>(e,t)=>f.call(e,t))(Object.prototype),iB=Ar("RegExp"),Ix=(f,e)=>{const t=Object.getOwnPropertyDescriptors(f),s={};Al(t,(i,n)=>{e(i,n,f)!==!1&&(s[n]=i)}),Object.defineProperties(f,s)},nB=f=>{Ix(f,(e,t)=>{const s=f[t];if(!!Md(s)){if(e.enumerable=!1,"writable"in e){e.writable=!1;return}e.set||(e.set=()=>{throw Error("Can not read-only method '"+t+"'")})}})},rB=(f,e)=>{const t={},s=i=>{i.forEach(n=>{t[n]=!0})};return Nu(f)?s(f):s(String(f).split(e)),t},aB=()=>{},oB=(f,e)=>(f=+f,Number.isFinite(f)?f:e),he={isArray:Nu,isArrayBuffer:vx,isBuffer:NA,isFormData:UA,isArrayBufferView:VA,isString:qA,isNumber:Tx,isBoolean:LA,isObject:Ox,isPlainObject:$h,isUndefined:cy,isDate:RA,isFile:FA,isBlob:DA,isRegExp:iB,isFunction:Md,isStream:GA,isURLSearchParams:$A,isTypedArray:ZA,isFileList:HA,forEach:Al,merge:uy,extend:WA,trim:jA,stripBOM:zA,inherits:KA,toFlatObject:XA,kindOf:ub,kindOfTest:Ar,endsWith:YA,toArray:QA,forEachEntry:JA,matchAll:eB,isHTMLForm:tB,hasOwnProperty:$w,hasOwnProp:$w,reduceDescriptors:Ix,freezeMethods:nB,toObjectSet:rB,toCamelCase:sB,noop:aB,toFiniteNumber:oB};function yt(f,e,t,s,i){Error.call(this),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=new Error().stack,this.message=f,this.name="AxiosError",e&&(this.code=e),t&&(this.config=t),s&&(this.request=s),i&&(this.response=i)}he.inherits(yt,Error,{toJSON:function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:this.config,code:this.code,status:this.response&&this.response.status?this.response.status:null}}});const xx=yt.prototype,_x={};["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED","ERR_NOT_SUPPORT","ERR_INVALID_URL"].forEach(f=>{_x[f]={value:f}});Object.defineProperties(yt,_x);Object.defineProperty(xx,"isAxiosError",{value:!0});yt.from=(f,e,t,s,i,n)=>{const r=Object.create(xx);return he.toFlatObject(f,r,function(o){return o!==Error.prototype},a=>a!=="isAxiosError"),yt.call(r,f.message,e,t,s,i),r.cause=f,r.name=f.name,n&&Object.assign(r,n),r};var dB=typeof self=="object"?self.FormData:window.FormData;function fy(f){return he.isPlainObject(f)||he.isArray(f)}function Cx(f){return he.endsWith(f,"[]")?f.slice(0,-2):f}function jw(f,e,t){return f?f.concat(e).map(function(i,n){return i=Cx(i),!t&&n?"["+i+"]":i}).join(t?".":""):e}function cB(f){return he.isArray(f)&&!f.some(fy)}const uB=he.toFlatObject(he,{},null,function(e){return/^is[A-Z]/.test(e)});function fB(f){return f&&he.isFunction(f.append)&&f[Symbol.toStringTag]==="FormData"&&f[Symbol.iterator]}function Bl(f,e,t){if(!he.isObject(f))throw new TypeError("target must be an object");e=e||new(dB||FormData),t=he.toFlatObject(t,{metaTokens:!0,dots:!1,indexes:!1},!1,function(m,g){return!he.isUndefined(g[m])});const s=t.metaTokens,i=t.visitor||c,n=t.dots,r=t.indexes,o=(t.Blob||typeof Blob<"u"&&Blob)&&fB(e);if(!he.isFunction(i))throw new TypeError("visitor must be a function");function d(p){if(p===null)return"";if(he.isDate(p))return p.toISOString();if(!o&&he.isBlob(p))throw new yt("Blob is not supported. Use a Buffer instead.");return he.isArrayBuffer(p)||he.isTypedArray(p)?o&&typeof Blob=="function"?new Blob([p]):Buffer.from(p):p}function c(p,m,g){let y=p;if(p&&!g&&typeof p=="object"){if(he.endsWith(m,"{}"))m=s?m:m.slice(0,-2),p=JSON.stringify(p);else if(he.isArray(p)&&cB(p)||he.isFileList(p)||he.endsWith(m,"[]")&&(y=he.toArray(p)))return m=Cx(m),y.forEach(function(w,k){!(he.isUndefined(w)||w===null)&&e.append(r===!0?jw([m],k,n):r===null?m:m+"[]",d(w))}),!1}return fy(p)?!0:(e.append(jw(g,m,n),d(p)),!1)}const u=[],h=Object.assign(uB,{defaultVisitor:c,convertValue:d,isVisitable:fy});function l(p,m){if(!he.isUndefined(p)){if(u.indexOf(p)!==-1)throw Error("Circular reference detected in "+m.join("."));u.push(p),he.forEach(p,function(y,b){(!(he.isUndefined(y)||y===null)&&i.call(e,y,he.isString(b)?b.trim():b,m,h))===!0&&l(y,m?m.concat(b):[b])}),u.pop()}}if(!he.isObject(f))throw new TypeError("data must be an object");return l(f),e}function Ww(f){const e={"!":"%21","'":"%27","(":"%28",")":"%29","~":"%7E","%20":"+","%00":"\0"};return encodeURIComponent(f).replace(/[!'()~]|%20|%00/g,function(s){return e[s]})}function fb(f,e){this._pairs=[],f&&Bl(f,this,e)}const Mx=fb.prototype;Mx.append=function(e,t){this._pairs.push([e,t])};Mx.toString=function(e){const t=e?function(s){return e.call(this,s,Ww)}:Ww;return this._pairs.map(function(i){return t(i[0])+"="+t(i[1])},"").join("&")};function hB(f){return encodeURIComponent(f).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}function Px(f,e,t){if(!e)return f;const s=t&&t.encode||hB,i=t&&t.serialize;let n;if(i?n=i(e,t):n=he.isURLSearchParams(e)?e.toString():new fb(e,t).toString(s),n){const r=f.indexOf("#");r!==-1&&(f=f.slice(0,r)),f+=(f.indexOf("?")===-1?"?":"&")+n}return f}class zw{constructor(){this.handlers=[]}use(e,t,s){return this.handlers.push({fulfilled:e,rejected:t,synchronous:s?s.synchronous:!1,runWhen:s?s.runWhen:null}),this.handlers.length-1}eject(e){this.handlers[e]&&(this.handlers[e]=null)}clear(){this.handlers&&(this.handlers=[])}forEach(e){he.forEach(this.handlers,function(s){s!==null&&e(s)})}}const Ax={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1},lB=typeof URLSearchParams<"u"?URLSearchParams:fb,pB=FormData,mB=(()=>{let f;return typeof navigator<"u"&&((f=navigator.product)==="ReactNative"||f==="NativeScript"||f==="NS")?!1:typeof window<"u"&&typeof document<"u"})(),Tr={isBrowser:!0,classes:{URLSearchParams:lB,FormData:pB,Blob},isStandardBrowserEnv:mB,protocols:["http","https","file","blob","url","data"]};function gB(f,e){return Bl(f,new Tr.classes.URLSearchParams,Object.assign({visitor:function(t,s,i,n){return Tr.isNode&&he.isBuffer(t)?(this.append(s,t.toString("base64")),!1):n.defaultVisitor.apply(this,arguments)}},e))}function yB(f){return he.matchAll(/\w+|\[(\w*)]/g,f).map(e=>e[0]==="[]"?"":e[1]||e[0])}function bB(f){const e={},t=Object.keys(f);let s;const i=t.length;let n;for(s=0;s<i;s++)n=t[s],e[n]=f[n];return e}function Bx(f){function e(t,s,i,n){let r=t[n++];const a=Number.isFinite(+r),o=n>=t.length;return r=!r&&he.isArray(i)?i.length:r,o?(he.hasOwnProp(i,r)?i[r]=[i[r],s]:i[r]=s,!a):((!i[r]||!he.isObject(i[r]))&&(i[r]=[]),e(t,s,i[r],n)&&he.isArray(i[r])&&(i[r]=bB(i[r])),!a)}if(he.isFormData(f)&&he.isFunction(f.entries)){const t={};return he.forEachEntry(f,(s,i)=>{e(yB(s),i,t,0)}),t}return null}function wB(f,e,t){const s=t.config.validateStatus;!t.status||!s||s(t.status)?f(t):e(new yt("Request failed with status code "+t.status,[yt.ERR_BAD_REQUEST,yt.ERR_BAD_RESPONSE][Math.floor(t.status/100)-4],t.config,t.request,t))}const kB=Tr.isStandardBrowserEnv?function(){return{write:function(t,s,i,n,r,a){const o=[];o.push(t+"="+encodeURIComponent(s)),he.isNumber(i)&&o.push("expires="+new Date(i).toGMTString()),he.isString(n)&&o.push("path="+n),he.isString(r)&&o.push("domain="+r),a===!0&&o.push("secure"),document.cookie=o.join("; ")},read:function(t){const s=document.cookie.match(new RegExp("(^|;\\s*)("+t+")=([^;]*)"));return s?decodeURIComponent(s[3]):null},remove:function(t){this.write(t,"",Date.now()-864e5)}}}():function(){return{write:function(){},read:function(){return null},remove:function(){}}}();function SB(f){return/^([a-z][a-z\d+\-.]*:)?\/\//i.test(f)}function vB(f,e){return e?f.replace(/\/+$/,"")+"/"+e.replace(/^\/+/,""):f}function Ex(f,e){return f&&!SB(e)?vB(f,e):e}const TB=Tr.isStandardBrowserEnv?function(){const e=/(msie|trident)/i.test(navigator.userAgent),t=document.createElement("a");let s;function i(n){let r=n;return e&&(t.setAttribute("href",r),r=t.href),t.setAttribute("href",r),{href:t.href,protocol:t.protocol?t.protocol.replace(/:$/,""):"",host:t.host,search:t.search?t.search.replace(/^\?/,""):"",hash:t.hash?t.hash.replace(/^#/,""):"",hostname:t.hostname,port:t.port,pathname:t.pathname.charAt(0)==="/"?t.pathname:"/"+t.pathname}}return s=i(window.location.href),function(r){const a=he.isString(r)?i(r):r;return a.protocol===s.protocol&&a.host===s.host}}():function(){return function(){return!0}}();function Vu(f,e,t){yt.call(this,f==null?"canceled":f,yt.ERR_CANCELED,e,t),this.name="CanceledError"}he.inherits(Vu,yt,{__CANCEL__:!0});function OB(f){const e=/^([-+\w]{1,25})(:?\/\/|:)/.exec(f);return e&&e[1]||""}const IB=he.toObjectSet(["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"]),xB=f=>{const e={};let t,s,i;return f&&f.split(`
`).forEach(function(r){i=r.indexOf(":"),t=r.substring(0,i).trim().toLowerCase(),s=r.substring(i+1).trim(),!(!t||e[t]&&IB[t])&&(t==="set-cookie"?e[t]?e[t].push(s):e[t]=[s]:e[t]=e[t]?e[t]+", "+s:s)}),e},Kw=Symbol("internals"),Nx=Symbol("defaults");function ou(f){return f&&String(f).trim().toLowerCase()}function jh(f){return f===!1||f==null?f:he.isArray(f)?f.map(jh):String(f)}function _B(f){const e=Object.create(null),t=/([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;let s;for(;s=t.exec(f);)e[s[1]]=s[2];return e}function Xw(f,e,t,s){if(he.isFunction(s))return s.call(this,e,t);if(!!he.isString(e)){if(he.isString(s))return e.indexOf(s)!==-1;if(he.isRegExp(s))return s.test(e)}}function CB(f){return f.trim().toLowerCase().replace(/([a-z\d])(\w*)/g,(e,t,s)=>t.toUpperCase()+s)}function MB(f,e){const t=he.toCamelCase(" "+e);["get","set","has"].forEach(s=>{Object.defineProperty(f,s+t,{value:function(i,n,r){return this[s].call(this,e,i,n,r)},configurable:!0})})}function Wd(f,e){e=e.toLowerCase();const t=Object.keys(f);let s=t.length,i;for(;s-- >0;)if(i=t[s],e===i.toLowerCase())return i;return null}function ln(f,e){f&&this.set(f),this[Nx]=e||null}Object.assign(ln.prototype,{set:function(f,e,t){const s=this;function i(n,r,a){const o=ou(r);if(!o)throw new Error("header name must be a non-empty string");const d=Wd(s,o);d&&a!==!0&&(s[d]===!1||a===!1)||(s[d||r]=jh(n))}return he.isPlainObject(f)?he.forEach(f,(n,r)=>{i(n,r,e)}):i(e,f,t),this},get:function(f,e){if(f=ou(f),!f)return;const t=Wd(this,f);if(t){const s=this[t];if(!e)return s;if(e===!0)return _B(s);if(he.isFunction(e))return e.call(this,s,t);if(he.isRegExp(e))return e.exec(s);throw new TypeError("parser must be boolean|regexp|function")}},has:function(f,e){if(f=ou(f),f){const t=Wd(this,f);return!!(t&&(!e||Xw(this,this[t],t,e)))}return!1},delete:function(f,e){const t=this;let s=!1;function i(n){if(n=ou(n),n){const r=Wd(t,n);r&&(!e||Xw(t,t[r],r,e))&&(delete t[r],s=!0)}}return he.isArray(f)?f.forEach(i):i(f),s},clear:function(){return Object.keys(this).forEach(this.delete.bind(this))},normalize:function(f){const e=this,t={};return he.forEach(this,(s,i)=>{const n=Wd(t,i);if(n){e[n]=jh(s),delete e[i];return}const r=f?CB(i):String(i).trim();r!==i&&delete e[i],e[r]=jh(s),t[r]=!0}),this},toJSON:function(f){const e=Object.create(null);return he.forEach(Object.assign({},this[Nx]||null,this),(t,s)=>{t==null||t===!1||(e[s]=f&&he.isArray(t)?t.join(", "):t)}),e}});Object.assign(ln,{from:function(f){return he.isString(f)?new this(xB(f)):f instanceof this?f:new this(f)},accessor:function(f){const t=(this[Kw]=this[Kw]={accessors:{}}).accessors,s=this.prototype;function i(n){const r=ou(n);t[r]||(MB(s,n),t[r]=!0)}return he.isArray(f)?f.forEach(i):i(f),this}});ln.accessor(["Content-Type","Content-Length","Accept","Accept-Encoding","User-Agent"]);he.freezeMethods(ln.prototype);he.freezeMethods(ln);function PB(f,e){f=f||10;const t=new Array(f),s=new Array(f);let i=0,n=0,r;return e=e!==void 0?e:1e3,function(o){const d=Date.now(),c=s[n];r||(r=d),t[i]=o,s[i]=d;let u=n,h=0;for(;u!==i;)h+=t[u++],u=u%f;if(i=(i+1)%f,i===n&&(n=(n+1)%f),d-r<e)return;const l=c&&d-c;return l?Math.round(h*1e3/l):void 0}}function Yw(f,e){let t=0;const s=PB(50,250);return i=>{const n=i.loaded,r=i.lengthComputable?i.total:void 0,a=n-t,o=s(a),d=n<=r;t=n;const c={loaded:n,total:r,progress:r?n/r:void 0,bytes:a,rate:o||void 0,estimated:o&&r&&d?(r-n)/o:void 0};c[e?"download":"upload"]=!0,f(c)}}function Qw(f){return new Promise(function(t,s){let i=f.data;const n=ln.from(f.headers).normalize(),r=f.responseType;let a;function o(){f.cancelToken&&f.cancelToken.unsubscribe(a),f.signal&&f.signal.removeEventListener("abort",a)}he.isFormData(i)&&Tr.isStandardBrowserEnv&&n.setContentType(!1);let d=new XMLHttpRequest;if(f.auth){const l=f.auth.username||"",p=f.auth.password?unescape(encodeURIComponent(f.auth.password)):"";n.set("Authorization","Basic "+btoa(l+":"+p))}const c=Ex(f.baseURL,f.url);d.open(f.method.toUpperCase(),Px(c,f.params,f.paramsSerializer),!0),d.timeout=f.timeout;function u(){if(!d)return;const l=ln.from("getAllResponseHeaders"in d&&d.getAllResponseHeaders()),m={data:!r||r==="text"||r==="json"?d.responseText:d.response,status:d.status,statusText:d.statusText,headers:l,config:f,request:d};wB(function(y){t(y),o()},function(y){s(y),o()},m),d=null}if("onloadend"in d?d.onloadend=u:d.onreadystatechange=function(){!d||d.readyState!==4||d.status===0&&!(d.responseURL&&d.responseURL.indexOf("file:")===0)||setTimeout(u)},d.onabort=function(){!d||(s(new yt("Request aborted",yt.ECONNABORTED,f,d)),d=null)},d.onerror=function(){s(new yt("Network Error",yt.ERR_NETWORK,f,d)),d=null},d.ontimeout=function(){let p=f.timeout?"timeout of "+f.timeout+"ms exceeded":"timeout exceeded";const m=f.transitional||Ax;f.timeoutErrorMessage&&(p=f.timeoutErrorMessage),s(new yt(p,m.clarifyTimeoutError?yt.ETIMEDOUT:yt.ECONNABORTED,f,d)),d=null},Tr.isStandardBrowserEnv){const l=(f.withCredentials||TB(c))&&f.xsrfCookieName&&kB.read(f.xsrfCookieName);l&&n.set(f.xsrfHeaderName,l)}i===void 0&&n.setContentType(null),"setRequestHeader"in d&&he.forEach(n.toJSON(),function(p,m){d.setRequestHeader(m,p)}),he.isUndefined(f.withCredentials)||(d.withCredentials=!!f.withCredentials),r&&r!=="json"&&(d.responseType=f.responseType),typeof f.onDownloadProgress=="function"&&d.addEventListener("progress",Yw(f.onDownloadProgress,!0)),typeof f.onUploadProgress=="function"&&d.upload&&d.upload.addEventListener("progress",Yw(f.onUploadProgress)),(f.cancelToken||f.signal)&&(a=l=>{!d||(s(!l||l.type?new Vu(null,f,d):l),d.abort(),d=null)},f.cancelToken&&f.cancelToken.subscribe(a),f.signal&&(f.signal.aborted?a():f.signal.addEventListener("abort",a)));const h=OB(c);if(h&&Tr.protocols.indexOf(h)===-1){s(new yt("Unsupported protocol "+h+":",yt.ERR_BAD_REQUEST,f));return}d.send(i||null)})}const Zw={http:Qw,xhr:Qw},Jw={getAdapter:f=>{if(he.isString(f)){const e=Zw[f];if(!f)throw Error(he.hasOwnProp(f)?`Adapter '${f}' is not available in the build`:`Can not resolve adapter '${f}'`);return e}if(!he.isFunction(f))throw new TypeError("adapter is not a function");return f},adapters:Zw},AB={"Content-Type":"application/x-www-form-urlencoded"};function BB(){let f;return typeof XMLHttpRequest<"u"?f=Jw.getAdapter("xhr"):typeof process<"u"&&he.kindOf(process)==="process"&&(f=Jw.getAdapter("http")),f}function EB(f,e,t){if(he.isString(f))try{return(e||JSON.parse)(f),he.trim(f)}catch(s){if(s.name!=="SyntaxError")throw s}return(t||JSON.stringify)(f)}const Pd={transitional:Ax,adapter:BB(),transformRequest:[function(e,t){const s=t.getContentType()||"",i=s.indexOf("application/json")>-1,n=he.isObject(e);if(n&&he.isHTMLForm(e)&&(e=new FormData(e)),he.isFormData(e))return i&&i?JSON.stringify(Bx(e)):e;if(he.isArrayBuffer(e)||he.isBuffer(e)||he.isStream(e)||he.isFile(e)||he.isBlob(e))return e;if(he.isArrayBufferView(e))return e.buffer;if(he.isURLSearchParams(e))return t.setContentType("application/x-www-form-urlencoded;charset=utf-8",!1),e.toString();let a;if(n){if(s.indexOf("application/x-www-form-urlencoded")>-1)return gB(e,this.formSerializer).toString();if((a=he.isFileList(e))||s.indexOf("multipart/form-data")>-1){const o=this.env&&this.env.FormData;return Bl(a?{"files[]":e}:e,o&&new o,this.formSerializer)}}return n||i?(t.setContentType("application/json",!1),EB(e)):e}],transformResponse:[function(e){const t=this.transitional||Pd.transitional,s=t&&t.forcedJSONParsing,i=this.responseType==="json";if(e&&he.isString(e)&&(s&&!this.responseType||i)){const r=!(t&&t.silentJSONParsing)&&i;try{return JSON.parse(e)}catch(a){if(r)throw a.name==="SyntaxError"?yt.from(a,yt.ERR_BAD_RESPONSE,this,null,this.response):a}}return e}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:Tr.classes.FormData,Blob:Tr.classes.Blob},validateStatus:function(e){return e>=200&&e<300},headers:{common:{Accept:"application/json, text/plain, */*"}}};he.forEach(["delete","get","head"],function(e){Pd.headers[e]={}});he.forEach(["post","put","patch"],function(e){Pd.headers[e]=he.merge(AB)});function Bp(f,e){const t=this||Pd,s=e||t,i=ln.from(s.headers);let n=s.data;return he.forEach(f,function(a){n=a.call(t,n,i.normalize(),e?e.status:void 0)}),i.normalize(),n}function Vx(f){return!!(f&&f.__CANCEL__)}function Ep(f){if(f.cancelToken&&f.cancelToken.throwIfRequested(),f.signal&&f.signal.aborted)throw new Vu}function e1(f){return Ep(f),f.headers=ln.from(f.headers),f.data=Bp.call(f,f.transformRequest),(f.adapter||Pd.adapter)(f).then(function(s){return Ep(f),s.data=Bp.call(f,f.transformResponse,s),s.headers=ln.from(s.headers),s},function(s){return Vx(s)||(Ep(f),s&&s.response&&(s.response.data=Bp.call(f,f.transformResponse,s.response),s.response.headers=ln.from(s.response.headers))),Promise.reject(s)})}function xu(f,e){e=e||{};const t={};function s(d,c){return he.isPlainObject(d)&&he.isPlainObject(c)?he.merge(d,c):he.isPlainObject(c)?he.merge({},c):he.isArray(c)?c.slice():c}function i(d){if(he.isUndefined(e[d])){if(!he.isUndefined(f[d]))return s(void 0,f[d])}else return s(f[d],e[d])}function n(d){if(!he.isUndefined(e[d]))return s(void 0,e[d])}function r(d){if(he.isUndefined(e[d])){if(!he.isUndefined(f[d]))return s(void 0,f[d])}else return s(void 0,e[d])}function a(d){if(d in e)return s(f[d],e[d]);if(d in f)return s(void 0,f[d])}const o={url:n,method:n,data:n,baseURL:r,transformRequest:r,transformResponse:r,paramsSerializer:r,timeout:r,timeoutMessage:r,withCredentials:r,adapter:r,responseType:r,xsrfCookieName:r,xsrfHeaderName:r,onUploadProgress:r,onDownloadProgress:r,decompress:r,maxContentLength:r,maxBodyLength:r,beforeRedirect:r,transport:r,httpAgent:r,httpsAgent:r,cancelToken:r,socketPath:r,responseEncoding:r,validateStatus:a};return he.forEach(Object.keys(f).concat(Object.keys(e)),function(c){const u=o[c]||i,h=u(c);he.isUndefined(h)&&u!==a||(t[c]=h)}),t}const qx="1.1.3",hb={};["object","boolean","number","function","string","symbol"].forEach((f,e)=>{hb[f]=function(s){return typeof s===f||"a"+(e<1?"n ":" ")+f}});const t1={};hb.transitional=function(e,t,s){function i(n,r){return"[Axios v"+qx+"] Transitional option '"+n+"'"+r+(s?". "+s:"")}return(n,r,a)=>{if(e===!1)throw new yt(i(r," has been removed"+(t?" in "+t:"")),yt.ERR_DEPRECATED);return t&&!t1[r]&&(t1[r]=!0,console.warn(i(r," has been deprecated since v"+t+" and will be removed in the near future"))),e?e(n,r,a):!0}};function NB(f,e,t){if(typeof f!="object")throw new yt("options must be an object",yt.ERR_BAD_OPTION_VALUE);const s=Object.keys(f);let i=s.length;for(;i-- >0;){const n=s[i],r=e[n];if(r){const a=f[n],o=a===void 0||r(a,n,f);if(o!==!0)throw new yt("option "+n+" must be "+o,yt.ERR_BAD_OPTION_VALUE);continue}if(t!==!0)throw new yt("Unknown option "+n,yt.ERR_BAD_OPTION)}}const hy={assertOptions:NB,validators:hb},Fr=hy.validators;class po{constructor(e){this.defaults=e,this.interceptors={request:new zw,response:new zw}}request(e,t){typeof e=="string"?(t=t||{},t.url=e):t=e||{},t=xu(this.defaults,t);const{transitional:s,paramsSerializer:i}=t;s!==void 0&&hy.assertOptions(s,{silentJSONParsing:Fr.transitional(Fr.boolean),forcedJSONParsing:Fr.transitional(Fr.boolean),clarifyTimeoutError:Fr.transitional(Fr.boolean)},!1),i!==void 0&&hy.assertOptions(i,{encode:Fr.function,serialize:Fr.function},!0),t.method=(t.method||this.defaults.method||"get").toLowerCase();const n=t.headers&&he.merge(t.headers.common,t.headers[t.method]);n&&he.forEach(["delete","get","head","post","put","patch","common"],function(p){delete t.headers[p]}),t.headers=new ln(t.headers,n);const r=[];let a=!0;this.interceptors.request.forEach(function(p){typeof p.runWhen=="function"&&p.runWhen(t)===!1||(a=a&&p.synchronous,r.unshift(p.fulfilled,p.rejected))});const o=[];this.interceptors.response.forEach(function(p){o.push(p.fulfilled,p.rejected)});let d,c=0,u;if(!a){const l=[e1.bind(this),void 0];for(l.unshift.apply(l,r),l.push.apply(l,o),u=l.length,d=Promise.resolve(t);c<u;)d=d.then(l[c++],l[c++]);return d}u=r.length;let h=t;for(c=0;c<u;){const l=r[c++],p=r[c++];try{h=l(h)}catch(m){p.call(this,m);break}}try{d=e1.call(this,h)}catch(l){return Promise.reject(l)}for(c=0,u=o.length;c<u;)d=d.then(o[c++],o[c++]);return d}getUri(e){e=xu(this.defaults,e);const t=Ex(e.baseURL,e.url);return Px(t,e.params,e.paramsSerializer)}}he.forEach(["delete","get","head","options"],function(e){po.prototype[e]=function(t,s){return this.request(xu(s||{},{method:e,url:t,data:(s||{}).data}))}});he.forEach(["post","put","patch"],function(e){function t(s){return function(n,r,a){return this.request(xu(a||{},{method:e,headers:s?{"Content-Type":"multipart/form-data"}:{},url:n,data:r}))}}po.prototype[e]=t(),po.prototype[e+"Form"]=t(!0)});class lb{constructor(e){if(typeof e!="function")throw new TypeError("executor must be a function.");let t;this.promise=new Promise(function(n){t=n});const s=this;this.promise.then(i=>{if(!s._listeners)return;let n=s._listeners.length;for(;n-- >0;)s._listeners[n](i);s._listeners=null}),this.promise.then=i=>{let n;const r=new Promise(a=>{s.subscribe(a),n=a}).then(i);return r.cancel=function(){s.unsubscribe(n)},r},e(function(n,r,a){s.reason||(s.reason=new Vu(n,r,a),t(s.reason))})}throwIfRequested(){if(this.reason)throw this.reason}subscribe(e){if(this.reason){e(this.reason);return}this._listeners?this._listeners.push(e):this._listeners=[e]}unsubscribe(e){if(!this._listeners)return;const t=this._listeners.indexOf(e);t!==-1&&this._listeners.splice(t,1)}static source(){let e;return{token:new lb(function(i){e=i}),cancel:e}}}function VB(f){return function(t){return f.apply(null,t)}}function qB(f){return he.isObject(f)&&f.isAxiosError===!0}function Lx(f){const e=new po(f),t=kx(po.prototype.request,e);return he.extend(t,po.prototype,e,{allOwnKeys:!0}),he.extend(t,e,null,{allOwnKeys:!0}),t.create=function(i){return Lx(xu(f,i))},t}const Ct=Lx(Pd);Ct.Axios=po;Ct.CanceledError=Vu;Ct.CancelToken=lb;Ct.isCancel=Vx;Ct.VERSION=qx;Ct.toFormData=Bl;Ct.AxiosError=yt;Ct.Cancel=Ct.CanceledError;Ct.all=function(e){return Promise.all(e)};Ct.spread=VB;Ct.isAxiosError=qB;Ct.formToJSON=f=>Bx(he.isHTMLForm(f)?new FormData(f):f);let rf;const LB=new Uint8Array(16);function RB(){if(!rf&&(rf=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!rf))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return rf(LB)}const js=[];for(let f=0;f<256;++f)js.push((f+256).toString(16).slice(1));function FB(f,e=0){return(js[f[e+0]]+js[f[e+1]]+js[f[e+2]]+js[f[e+3]]+"-"+js[f[e+4]]+js[f[e+5]]+"-"+js[f[e+6]]+js[f[e+7]]+"-"+js[f[e+8]]+js[f[e+9]]+"-"+js[f[e+10]]+js[f[e+11]]+js[f[e+12]]+js[f[e+13]]+js[f[e+14]]+js[f[e+15]]).toLowerCase()}const DB=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto),s1={randomUUID:DB};function HB(f,e,t){if(s1.randomUUID&&!e&&!f)return s1.randomUUID();f=f||{};const s=f.random||(f.rng||RB)();if(s[6]=s[6]&15|64,s[8]=s[8]&63|128,e){t=t||0;for(let i=0;i<16;++i)e[t+i]=s[i];return e}return FB(s)}const Rx=f=>f?(f^Math.random()*16>>f/4).toString(16):([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,Rx),Fx=f=>f?(f^Math.random()*16>>f/4).toString(16):([1e5]+100+400+8e3).replace(/[018]/g,Fx),Dx=f=>f?(f^Math.random()*16>>f/4).toString(16):([1e7]+1e3+4e3+8e5).replace(/[018]/g,Dx);var pb={uuid:Rx,uuid16:Fx,uuid22:Dx,unCamelCase:f=>f.match(/[A-Z]/)?f.replace(/[a-z0-9][A-Z]/g,e=>e[0]+"_"+e[1]).replace(/[A-Z0-9][A-Z0-9][a-z][^$]/g,e=>e[0]+"_"+e[1]+e[2]+e[3]).replace(/[a-z][0-9]$/g,e=>e[0]+"_"+e[1]).toLowerCase():f,capitalize:f=>f.length?f.charAt(0).toUpperCase()+f.slice(1):f,strip:f=>f.replace(/^\s+|\s+$/g,"")},af={exports:{}};const GB={},UB=Object.freeze(Object.defineProperty({__proto__:null,default:GB},Symbol.toStringTag,{value:"Module"})),Et=Ly(UB);var i1;function $B(){return i1||(i1=1,function(f,e){Object.defineProperty(e,"__esModule",{value:!0});const t=Symbol("buffer"),s=Symbol("type");class i{constructor(){this[s]="";const H=arguments[0],W=arguments[1],Y=[];if(H){const X=H,ne=Number(X.length);for(let te=0;te<ne;te++){const ce=X[te];let ke;ce instanceof Buffer?ke=ce:ArrayBuffer.isView(ce)?ke=Buffer.from(ce.buffer,ce.byteOffset,ce.byteLength):ce instanceof ArrayBuffer?ke=Buffer.from(ce):ce instanceof i?ke=ce[t]:ke=Buffer.from(typeof ce=="string"?ce:String(ce)),Y.push(ke)}}this[t]=Buffer.concat(Y);let z=W&&W.type!==void 0&&String(W.type).toLowerCase();z&&!/[^\u0020-\u007E]/.test(z)&&(this[s]=z)}get size(){return this[t].length}get type(){return this[s]}slice(){const H=this.size,W=arguments[0],Y=arguments[1];let z,X;W===void 0?z=0:W<0?z=Math.max(H+W,0):z=Math.min(W,H),Y===void 0?X=H:Y<0?X=Math.max(H+Y,0):X=Math.min(Y,H);const ne=Math.max(X-z,0),ce=this[t].slice(z,z+ne),ke=new i([],{type:arguments[2]});return ke[t]=ce,ke}}Object.defineProperties(i.prototype,{size:{enumerable:!0},type:{enumerable:!0},slice:{enumerable:!0}}),Object.defineProperty(i.prototype,Symbol.toStringTag,{value:"Blob",writable:!1,enumerable:!1,configurable:!0});function n(U,H,W){Error.call(this,U),this.message=U,this.type=H,W&&(this.code=this.errno=W.code),Error.captureStackTrace(this,this.constructor)}n.prototype=Object.create(Error.prototype),n.prototype.constructor=n,n.prototype.name="FetchError";const r=Et;var a=Et;const o=a.PassThrough,d=Symbol("Body internals");function c(U){var H=this,W=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},Y=W.size;let z=Y===void 0?0:Y;var X=W.timeout;let ne=X===void 0?0:X;U==null?U=null:typeof U=="string"||l(U)||U instanceof i||Buffer.isBuffer(U)||Object.prototype.toString.call(U)==="[object ArrayBuffer]"||U instanceof r||(U=String(U)),this[d]={body:U,disturbed:!1,error:null},this.size=z,this.timeout=ne,U instanceof r&&U.on("error",function(te){H[d].error=new n(`Invalid response body while trying to fetch ${H.url}: ${te.message}`,"system",te)})}c.prototype={get body(){return this[d].body},get bodyUsed(){return this[d].disturbed},arrayBuffer(){return u.call(this).then(function(U){return U.buffer.slice(U.byteOffset,U.byteOffset+U.byteLength)})},blob(){let U=this.headers&&this.headers.get("content-type")||"";return u.call(this).then(function(H){return Object.assign(new i([],{type:U.toLowerCase()}),{[t]:H})})},json(){var U=this;return u.call(this).then(function(H){try{return JSON.parse(H.toString())}catch(W){return c.Promise.reject(new n(`invalid json response body at ${U.url} reason: ${W.message}`,"invalid-json"))}})},text(){return u.call(this).then(function(U){return U.toString()})},buffer(){return u.call(this)},textConverted(){var U=this;return u.call(this).then(function(H){return h(H,U.headers)})}},Object.defineProperties(c.prototype,{body:{enumerable:!0},bodyUsed:{enumerable:!0},arrayBuffer:{enumerable:!0},blob:{enumerable:!0},json:{enumerable:!0},text:{enumerable:!0}}),c.mixIn=function(U){for(const H of Object.getOwnPropertyNames(c.prototype))if(!(H in U)){const W=Object.getOwnPropertyDescriptor(c.prototype,H);Object.defineProperty(U,H,W)}};function u(){var U=this;if(this[d].disturbed)return c.Promise.reject(new TypeError(`body used already for: ${this.url}`));if(this[d].disturbed=!0,this[d].error)return c.Promise.reject(this[d].error);if(this.body===null)return c.Promise.resolve(Buffer.alloc(0));if(typeof this.body=="string")return c.Promise.resolve(Buffer.from(this.body));if(this.body instanceof i)return c.Promise.resolve(this.body[t]);if(Buffer.isBuffer(this.body))return c.Promise.resolve(this.body);if(Object.prototype.toString.call(this.body)==="[object ArrayBuffer]")return c.Promise.resolve(Buffer.from(this.body));if(!(this.body instanceof r))return c.Promise.resolve(Buffer.alloc(0));let H=[],W=0,Y=!1;return new c.Promise(function(z,X){let ne;U.timeout&&(ne=setTimeout(function(){Y=!0,X(new n(`Response timeout while trying to fetch ${U.url} (over ${U.timeout}ms)`,"body-timeout"))},U.timeout)),U.body.on("error",function(te){X(new n(`Invalid response body while trying to fetch ${U.url}: ${te.message}`,"system",te))}),U.body.on("data",function(te){if(!(Y||te===null)){if(U.size&&W+te.length>U.size){Y=!0,X(new n(`content size at ${U.url} over limit: ${U.size}`,"max-size"));return}W+=te.length,H.push(te)}}),U.body.on("end",function(){if(!Y){clearTimeout(ne);try{z(Buffer.concat(H))}catch(te){X(new n(`Could not create Buffer from response body for ${U.url}: ${te.message}`,"system",te))}}})})}function h(U,H){if(typeof convert!="function")throw new Error("The package `encoding` must be installed to use the textConverted() function");const W=H.get("content-type");let Y="utf-8",z,X;return W&&(z=/charset=([^;]*)/i.exec(W)),X=U.slice(0,1024).toString(),!z&&X&&(z=/<meta.+?charset=(['"])(.+?)\1/i.exec(X)),!z&&X&&(z=/<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(X),z&&(z=/charset=(.*)/i.exec(z.pop()))),!z&&X&&(z=/<\?xml.+?encoding=(['"])(.+?)\1/i.exec(X)),z&&(Y=z.pop(),(Y==="gb2312"||Y==="gbk")&&(Y="gb18030")),convert(U,"UTF-8",Y).toString()}function l(U){return typeof U!="object"||typeof U.append!="function"||typeof U.delete!="function"||typeof U.get!="function"||typeof U.getAll!="function"||typeof U.has!="function"||typeof U.set!="function"?!1:U.constructor.name==="URLSearchParams"||Object.prototype.toString.call(U)==="[object URLSearchParams]"||typeof U.sort=="function"}function p(U){let H,W,Y=U.body;if(U.bodyUsed)throw new Error("cannot clone body after it is used");return Y instanceof r&&typeof Y.getBoundary!="function"&&(H=new o,W=new o,Y.pipe(H),Y.pipe(W),U[d].body=H,Y=W),Y}function m(U){const H=U.body;return H===null?null:typeof H=="string"?"text/plain;charset=UTF-8":l(H)?"application/x-www-form-urlencoded;charset=UTF-8":H instanceof i?H.type||null:Buffer.isBuffer(H)||Object.prototype.toString.call(H)==="[object ArrayBuffer]"?null:typeof H.getBoundary=="function"?`multipart/form-data;boundary=${H.getBoundary()}`:null}function g(U){const H=U.body;return H===null?0:typeof H=="string"?Buffer.byteLength(H):l(H)?Buffer.byteLength(String(H)):H instanceof i?H.size:Buffer.isBuffer(H)?H.length:Object.prototype.toString.call(H)==="[object ArrayBuffer]"?H.byteLength:H&&typeof H.getLengthSync=="function"&&(H._lengthRetrievers&&H._lengthRetrievers.length==0||H.hasKnownLength&&H.hasKnownLength())?H.getLengthSync():null}function y(U,H){const W=H.body;W===null?U.end():typeof W=="string"?(U.write(W),U.end()):l(W)?(U.write(Buffer.from(String(W))),U.end()):W instanceof i?(U.write(W[t]),U.end()):Buffer.isBuffer(W)?(U.write(W),U.end()):Object.prototype.toString.call(W)==="[object ArrayBuffer]"?(U.write(Buffer.from(W)),U.end()):W.pipe(U)}c.Promise=Xh.Promise;const b=/[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/,w=/[^\t\x20-\x7e\x80-\xff]/;function k(U){if(U=`${U}`,b.test(U))throw new TypeError(`${U} is not a legal HTTP header name`)}function T(U){if(U=`${U}`,w.test(U))throw new TypeError(`${U} is not a legal HTTP header value`)}function O(U,H){H=H.toLowerCase();for(const W in U)if(W.toLowerCase()===H)return W}const x=Symbol("map");class C{constructor(){let H=arguments.length>0&&arguments[0]!==void 0?arguments[0]:void 0;if(this[x]=Object.create(null),H instanceof C){const W=H.raw(),Y=Object.keys(W);for(const z of Y)for(const X of W[z])this.append(z,X);return}if(H!=null)if(typeof H=="object"){const W=H[Symbol.iterator];if(W!=null){if(typeof W!="function")throw new TypeError("Header pairs must be iterable");const Y=[];for(const z of H){if(typeof z!="object"||typeof z[Symbol.iterator]!="function")throw new TypeError("Each header pair must be iterable");Y.push(Array.from(z))}for(const z of Y){if(z.length!==2)throw new TypeError("Each header pair must be a name/value tuple");this.append(z[0],z[1])}}else for(const Y of Object.keys(H)){const z=H[Y];this.append(Y,z)}}else throw new TypeError("Provided initializer must be an object")}get(H){H=`${H}`,k(H);const W=O(this[x],H);return W===void 0?null:this[x][W].join(", ")}forEach(H){let W=arguments.length>1&&arguments[1]!==void 0?arguments[1]:void 0,Y=E(this),z=0;for(;z<Y.length;){var X=Y[z];const ne=X[0],te=X[1];H.call(W,te,ne,this),Y=E(this),z++}}set(H,W){H=`${H}`,W=`${W}`,k(H),T(W);const Y=O(this[x],H);this[x][Y!==void 0?Y:H]=[W]}append(H,W){H=`${H}`,W=`${W}`,k(H),T(W);const Y=O(this[x],H);Y!==void 0?this[x][Y].push(W):this[x][H]=[W]}has(H){return H=`${H}`,k(H),O(this[x],H)!==void 0}delete(H){H=`${H}`,k(H);const W=O(this[x],H);W!==void 0&&delete this[x][W]}raw(){return this[x]}keys(){return _(this,"key")}values(){return _(this,"value")}[Symbol.iterator](){return _(this,"key+value")}}C.prototype.entries=C.prototype[Symbol.iterator],Object.defineProperty(C.prototype,Symbol.toStringTag,{value:"Headers",writable:!1,enumerable:!1,configurable:!0}),Object.defineProperties(C.prototype,{get:{enumerable:!0},forEach:{enumerable:!0},set:{enumerable:!0},append:{enumerable:!0},has:{enumerable:!0},delete:{enumerable:!0},keys:{enumerable:!0},values:{enumerable:!0},entries:{enumerable:!0}});function E(U){let H=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"key+value";return Object.keys(U[x]).sort().map(H==="key"?function(Y){return Y.toLowerCase()}:H==="value"?function(Y){return U[x][Y].join(", ")}:function(Y){return[Y.toLowerCase(),U[x][Y].join(", ")]})}const P=Symbol("internal");function _(U,H){const W=Object.create(S);return W[P]={target:U,kind:H,index:0},W}const S=Object.setPrototypeOf({next(){if(!this||Object.getPrototypeOf(this)!==S)throw new TypeError("Value of `this` is not a HeadersIterator");var U=this[P];const H=U.target,W=U.kind,Y=U.index,z=E(H,W),X=z.length;return Y>=X?{value:void 0,done:!0}:(this[P].index=Y+1,{value:z[Y],done:!1})}},Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));Object.defineProperty(S,Symbol.toStringTag,{value:"HeadersIterator",writable:!1,enumerable:!1,configurable:!0});function I(U){const H=Object.assign({__proto__:null},U[x]),W=O(U[x],"Host");return W!==void 0&&(H[W]=H[W][0]),H}function v(U){const H=new C;for(const W of Object.keys(U))if(!b.test(W))if(Array.isArray(U[W]))for(const Y of U[W])w.test(Y)||(H[x][W]===void 0?H[x][W]=[Y]:H[x][W].push(Y));else w.test(U[W])||(H[x][W]=[U[W]]);return H}var N=Et;const q=N.STATUS_CODES,R=Symbol("Response internals");class G{constructor(){let H=arguments.length>0&&arguments[0]!==void 0?arguments[0]:null,W=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};c.call(this,H,W);const Y=W.status||200;this[R]={url:W.url,status:Y,statusText:W.statusText||q[Y],headers:new C(W.headers)}}get url(){return this[R].url}get status(){return this[R].status}get ok(){return this[R].status>=200&&this[R].status<300}get statusText(){return this[R].statusText}get headers(){return this[R].headers}clone(){return new G(p(this),{url:this.url,status:this.status,statusText:this.statusText,headers:this.headers,ok:this.ok})}}c.mixIn(G.prototype),Object.defineProperties(G.prototype,{url:{enumerable:!0},status:{enumerable:!0},ok:{enumerable:!0},statusText:{enumerable:!0},headers:{enumerable:!0},clone:{enumerable:!0}}),Object.defineProperty(G.prototype,Symbol.toStringTag,{value:"Response",writable:!1,enumerable:!1,configurable:!0});var F=Et;const A=F.format,V=F.parse,Q=Symbol("Request internals");function J(U){return typeof U=="object"&&typeof U[Q]=="object"}class se{constructor(H){let W=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},Y;J(H)?Y=V(H.url):(H&&H.href?Y=V(H.href):Y=V(`${H}`),H={});let z=W.method||H.method||"GET";if(z=z.toUpperCase(),(W.body!=null||J(H)&&H.body!==null)&&(z==="GET"||z==="HEAD"))throw new TypeError("Request with GET/HEAD method cannot have body");let X=W.body!=null?W.body:J(H)&&H.body!==null?p(H):null;c.call(this,X,{timeout:W.timeout||H.timeout||0,size:W.size||H.size||0});const ne=new C(W.headers||H.headers||{});if(W.body!=null){const te=m(this);te!==null&&!ne.has("Content-Type")&&ne.append("Content-Type",te)}this[Q]={method:z,redirect:W.redirect||H.redirect||"follow",headers:ne,parsedURL:Y},this.follow=W.follow!==void 0?W.follow:H.follow!==void 0?H.follow:20,this.compress=W.compress!==void 0?W.compress:H.compress!==void 0?H.compress:!0,this.counter=W.counter||H.counter||0,this.agent=W.agent||H.agent}get method(){return this[Q].method}get url(){return A(this[Q].parsedURL)}get headers(){return this[Q].headers}get redirect(){return this[Q].redirect}clone(){return new se(this)}}c.mixIn(se.prototype),Object.defineProperty(se.prototype,Symbol.toStringTag,{value:"Request",writable:!1,enumerable:!1,configurable:!0}),Object.defineProperties(se.prototype,{method:{enumerable:!0},url:{enumerable:!0},headers:{enumerable:!0},redirect:{enumerable:!0},clone:{enumerable:!0}});function we(U){const H=U[Q].parsedURL,W=new C(U[Q].headers);if(W.has("Accept")||W.set("Accept","*/*"),!H.protocol||!H.hostname)throw new TypeError("Only absolute URLs are supported");if(!/^https?:$/.test(H.protocol))throw new TypeError("Only HTTP(S) protocols are supported");let Y=null;if(U.body==null&&/^(POST|PUT)$/i.test(U.method)&&(Y="0"),U.body!=null){const z=g(U);typeof z=="number"&&(Y=String(z))}return Y&&W.set("Content-Length",Y),W.has("User-Agent")||W.set("User-Agent","node-fetch/1.0 (+https://github.com/bitinn/node-fetch)"),U.compress&&W.set("Accept-Encoding","gzip,deflate"),!W.has("Connection")&&!U.agent&&W.set("Connection","close"),Object.assign({},H,{method:U.method,headers:I(W),agent:U.agent})}const le=Et,Oe=Et;var Ce=Et;const Le=Ce.PassThrough;var Fe=Et;const At=Fe.resolve,D=Et;function j(U,H){if(!j.Promise)throw new Error("native promise missing, set fetch.Promise to your favorite alternative");return c.Promise=j.Promise,new j.Promise(function(W,Y){const z=new se(U,H),X=we(z),ne=(X.protocol==="https:"?Oe:le).request,te=ne(X);let ce;function ke(){te.abort(),clearTimeout(ce)}z.timeout&&te.once("socket",function(ue){ce=setTimeout(function(){Y(new n(`network timeout at: ${z.url}`,"request-timeout")),ke()},z.timeout)}),te.on("error",function(ue){Y(new n(`request to ${z.url} failed, reason: ${ue.message}`,"system",ue)),ke()}),te.on("response",function(ue){clearTimeout(ce);const Ie=v(ue.headers);if(j.isRedirect(ue.statusCode)){const K=Ie.get("Location"),Z=K===null?null:At(z.url,K);switch(z.redirect){case"error":Y(new n(`redirect mode is set to error: ${z.url}`,"no-redirect")),ke();return;case"manual":Z!==null&&Ie.set("Location",Z);break;case"follow":if(Z===null)break;if(z.counter>=z.follow){Y(new n(`maximum redirect reached at: ${z.url}`,"max-redirect")),ke();return}const re={headers:new C(z.headers),follow:z.follow,counter:z.counter+1,agent:z.agent,compress:z.compress,method:z.method,body:z.body};if(ue.statusCode!==303&&z.body&&g(z)===null){Y(new n("Cannot follow redirect with body being a readable stream","unsupported-redirect")),ke();return}(ue.statusCode===303||(ue.statusCode===301||ue.statusCode===302)&&z.method==="POST")&&(re.method="GET",re.body=void 0,re.headers.delete("content-length")),W(j(new se(Z,re))),ke();return}}let Pe=ue.pipe(new Le);const L={url:z.url,status:ue.statusCode,statusText:ue.statusMessage,headers:Ie,size:z.size,timeout:z.timeout},M=Ie.get("Content-Encoding");if(!z.compress||z.method==="HEAD"||M===null||ue.statusCode===204||ue.statusCode===304){W(new G(Pe,L));return}const B={flush:D.Z_SYNC_FLUSH,finishFlush:D.Z_SYNC_FLUSH};if(M=="gzip"||M=="x-gzip"){Pe=Pe.pipe(D.createGunzip(B)),W(new G(Pe,L));return}if(M=="deflate"||M=="x-deflate"){ue.pipe(new Le).once("data",function(Z){(Z[0]&15)===8?Pe=Pe.pipe(D.createInflate()):Pe=Pe.pipe(D.createInflateRaw()),W(new G(Pe,L))});return}W(new G(Pe,L))}),y(te,z)})}j.isRedirect=function(U){return U===301||U===302||U===303||U===307||U===308},j.default=j,j.Promise=Xh.Promise,j.http=le,j.https=Oe,f.exports=e=j,e.Headers=C,e.Request=se,e.Response=G,e.FetchError=n}(af,af.exports)),af.exports}var Np,n1;function jB(){if(n1)return Np;n1=1;var f=$B();function e(t){const s=function(i,n){return typeof i=="string"&&i.slice(0,2)==="//"?t("https:"+i,n):t(i,n)};return s.http=t.http,s.https=t.https,s}return Np=function(t){return t&&t.Promise&&(f.Promise=t.Promise),{fetch:e(f),Headers:f.Headers,Request:f.Request,Response:f.Response}},Np}const Hx=typeof window<"u",WB=typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.electron<"u",Gx=typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope,zB=typeof process<"u"&&process.platform==="win32",KB=!(Hx||Gx),XB=typeof fetch>"u"?jB()().fetch:fetch;var YB={isBrowser:Hx,isElectron:WB,isWebWorker:Gx,isNode:KB,isWindows:zB,defaultFetch:XB};const Zs=Number.isFinite,QB=Number.isInteger,Ux=Array.isArray,du=f=>f!=null,mb=f=>typeof f=="string",El=f=>f!==null&&typeof f=="object",ZB=f=>f instanceof RegExp,JB=f=>El(f)&&Object.getPrototypeOf(f)===Object.prototype&&!Ux(f)&&!ZB(f),Ln=f=>du(f)&&f.toString||Zs(f),Xn=(f,e)=>El(f)&&f[e]!==""&&f[e]!==null?f[e]:void 0,Dr=(f,e,t)=>El(f)?f[e]!==void 0&&f[e]!==""&&f[e]!==null?f[e]:f[t]!==""&&f[t]!==null?f[t]:void 0:void 0,Hr=(f,e)=>f[e.find(t=>Xn(f,t)!==void 0)],Ia=f=>Zs(f)||mb(f)&&f.length!==0?parseFloat(f):NaN,xa=f=>Zs(f)||mb(f)&&f.length!==0?Math.trunc(Number(f)):NaN;var $x={isNumber:Zs,isInteger:QB,isArray:Ux,isObject:El,isString:mb,isStringCoercible:Ln,isDictionary:JB,hasProps:du,prop:Xn,asFloat:Ia,asInteger:xa,safeFloat:(f,e,t,s=Ia(Xn(f,e)))=>Zs(s)?s:t,safeInteger:(f,e,t,s=xa(Xn(f,e)))=>Zs(s)?s:t,safeIntegerProduct:(f,e,t,s,i=xa(Xn(f,e)))=>Zs(i)?parseInt(i*t):s,safeTimestamp:(f,e,t,s=Ia(Xn(f,e)))=>Zs(s)?parseInt(s*1e3):t,safeValue:(f,e,t,s=Xn(f,e))=>du(s)?s:t,safeString:(f,e,t,s=Xn(f,e))=>Ln(s)?String(s):t,safeStringLower:(f,e,t,s=Xn(f,e))=>Ln(s)?String(s).toLowerCase():t,safeStringUpper:(f,e,t,s=Xn(f,e))=>Ln(s)?String(s).toUpperCase():t,safeFloat2:(f,e,t,s,i=Ia(Dr(f,e,t)))=>Zs(i)?i:s,safeInteger2:(f,e,t,s,i=xa(Dr(f,e,t)))=>Zs(i)?i:s,safeIntegerProduct2:(f,e,t,s,i,n=xa(Dr(f,e,t)))=>Zs(n)?parseInt(n*s):i,safeTimestamp2:(f,e,t,s,i=Ia(Dr(f,e,t)))=>Zs(i)?parseInt(i*1e3):s,safeValue2:(f,e,t,s,i=Dr(f,e,t))=>du(i)?i:s,safeString2:(f,e,t,s,i=Dr(f,e,t))=>Ln(i)?String(i):s,safeStringLower2:(f,e,t,s,i=Dr(f,e,t))=>Ln(i)?String(i).toLowerCase():s,safeStringUpper2:(f,e,t,s,i=Dr(f,e,t))=>Ln(i)?String(i).toUpperCase():s,safeFloatN:(f,e,t,s=Ia(Hr(f,e)))=>Zs(s)?s:t,safeIntegerN:(f,e,t,s=xa(Hr(f,e)))=>Zs(s)?s:t,safeIntegerProductN:(f,e,t,s,i=xa(Hr(f,e)))=>Zs(i)?parseInt(i*t):s,safeTimestampN:(f,e,t,s=Ia(Hr(f,e)))=>Zs(s)?parseInt(s*1e3):t,safeValueN:(f,e,t,s=Hr(f,e))=>du(s)?s:t,safeStringN:(f,e,t,s=Hr(f,e))=>Ln(s)?String(s):t,safeStringLowerN:(f,e,t,s=Hr(f,e))=>Ln(s)?String(s).toLowerCase():t,safeStringUpperN:(f,e,t,s=Hr(f,e))=>Ln(s)?String(s).toUpperCase():t};const{isNumber:eE,isDictionary:r1,isArray:el}=$x,a1=Object.keys,rd=f=>el(f)?f:Object.values(f),o1=f=>new Set(rd(f)),jx=(...f)=>Object.assign({},...f),d1=f=>el(f)?Array.from(f):jx(f);var Wx={keys:a1,values:rd,extend:jx,clone:d1,index:o1,ordered:f=>f,unique:f=>Array.from(o1(f)),arrayConcat:(f,e)=>f.concat(e),inArray(f,e){return e.includes(f)},toArray(f){return Object.values(f)},isEmpty(f){return f?(Array.isArray(f)?f:Object.keys(f)).length<1:!0},keysort(f,e={}){for(const t of a1(f).sort())e[t]=f[t];return e},indexBy(f,e,t={}){for(const s of rd(f))e in s&&(t[s[e]]=s);return t},groupBy(f,e,t={}){for(const s of rd(f))if(e in s){const i=s[e];t[i]=t[i]||[],t[i].push(s)}return t},filterBy(f,e,t=void 0,s=[]){for(const i of rd(f))i[e]===t&&s.push(i);return s},sortBy:(f,e,t=!1,s=t?-1:1)=>f.sort((i,n)=>i[e]<n[e]?-s:i[e]>n[e]?s:0),sortBy2:(f,e,t,s=!1,i=s?-1:1)=>f.sort((n,r)=>n[e]<r[e]?-i:n[e]>r[e]?i:n[t]<r[t]?-i:n[t]>r[t]?i:0),flatten:function f(e,t=[]){for(const s of e)el(s)?f(s,t):t.push(s);return t},pluck:(f,e)=>rd(f).filter(t=>e in t).map(t=>t[e]),omit(f,...e){if(!Array.isArray(f)){const t=d1(f);for(const s of e)if(el(s))for(const i of s)delete t[i];else delete t[s];return t}return f},sum(...f){const e=f.filter(eE);return e.length>0?e.reduce((t,s)=>t+s,0):void 0},deepExtend:function f(...e){let t;for(const s of e)if(r1(s)){r1(t)||(t={});for(const i in s)t[i]=f(t[i],s[i])}else t=s;return t}};const vr=0,tl=1,zx=2,Kx=3,pa=0,gb=1,sl=2,co=0,Xx=1,tE={ROUND:vr,TRUNCATE:tl,ROUND_UP:zx,ROUND_DOWN:Kx,DECIMAL_PLACES:pa,SIGNIFICANT_DIGITS:gb,TICK_SIZE:sl,NO_PADDING:co,PAD_WITH_ZERO:Xx};function yb(f){if(f===void 0)return;if(typeof f!="number")return f.toString();const e=f.toString();if(Math.abs(f)<1){const t=e.split("e-"),s=t[0].replace(".",""),i=parseInt(t[1]),n=e[0]==="-";if(i)return f=(n?"-":"")+"0."+new Array(i).join("0")+s.substring(n),f}else{const t=e.split("e");if(t[1]){let s=parseInt(t[1]);const i=t[0].split(".");let n="";return i[1]&&(s-=i[1].length,n=i[1]),i[0]+n+new Array(s+1).join("0")}}return e}const c1=[],Yx=(f,e=0)=>{if(f=yb(f),e>0){const t=c1[e]||(c1[e]=new RegExp("([-]*\\d+\\.\\d{"+e+"})(\\d)")),[,s]=f.toString().match(t)||[null,f];return s.toString()}return parseInt(f).toString()},sE=(f,e=0)=>parseFloat(Yx(f,e));function ly(f){const e=f.replace(/0+$/g,"").split(".");return e.length>1?e[1].length:0}const ad=(f,e,t,s=pa,i=co)=>{if(s===sl&&t<=0)throw new Error("TICK_SIZE cant be used with negative or zero numPrecisionDigits");if(t<0){const J=Math.pow(10,-t);if(e===vr)return(J*ad(f/J,e,0,s,i)).toString();if(e===tl)return(f-f%J).toString()}if(s===sl){const J=ad(t,vr,22,pa,co),se=ly(J);let we=f%t;we=Number(ad(we,vr,8,pa,co));const le=ad(we/t,vr,Math.max(se,8),pa,co);return ly(le)!==0&&(e===vr?f>0?we>=t/2?f=f-we+t:f=f-we:we>=t/2?f=Number(f)-we:f=Number(f)-we-t:e===tl&&(f=f-we)),ad(f,vr,se,pa,i)}const n=yb(f),r=n[0]==="-",a=r?1:0,o=n.length;for(var d=0;d<o&&n[d]!==".";d++);const c=d<n.length,u=45,h=46,l=48,p=l+1,m=l+5,g=l+9,y=new Uint8Array(o-a+(c?0:1));y[0]=l;let b=y.length,w=-1,k=-1;for(var T=1,O=a;O<o;O++,T++){const J=n.charCodeAt(O);if(J===h)b=T--;else{if(J<l||J>g)throw new Error(`${n}: invalid number (contains an illegal character '${n[T-1]}')`);y[T]=J,J!==l&&w<0&&(w=T)}}w<0&&(w=1);let x=s===pa?b:w,C=x+t;k=-1;let E=!0,P=r;for(let J=y.length-1,se=0;J>=0;J--){let we=y[J];J!==0?(we+=se,J>=x+t&&(we=e===vr&&we>=m&&!(we===m&&se)?g+1:l),we>g?(we=l,se=1):se=0):se&&(we=p),y[J]=we,we!==l&&(E=!1,w=J,k=k<0?J+1:k)}s===gb&&(x=w,C=x+t),E&&(P=!1);const _=w>=b||E?b-1:w,S=k<b?b:k,I=P?1:0,v=I+(b-_),N=Math.max(S-b,0),q=S-_,R=i===co?q:C-_,G=Math.max(R-q,0),F=v+1+N,A=F+G,V=N+G===0,Q=new Uint8Array(v+(V?0:1)+N+G);for(P&&(Q[0]=u),T=I,O=_;T<v;T++,O++)Q[T]=y[O];for(V||(Q[v]=h),T=v+1,O=b;T<F;T++,O++)Q[T]=y[O];for(T=F;T<A;T++)Q[T]=l;return String.fromCharCode(...Q)};function iE(f){if(!(f===void 0||f==="")&&parseFloat(f)!==0)return f}var me={numberToString:yb,precisionFromString:ly,decimalToPrecision:ad,truncate_to_string:Yx,truncate:sE,omitZero:iE,precisionConstants:tE,ROUND:vr,TRUNCATE:tl,ROUND_UP:zx,ROUND_DOWN:Kx,DECIMAL_PLACES:pa,SIGNIFICANT_DIGITS:gb,TICK_SIZE:sl,NO_PADDING:co,PAD_WITH_ZERO:Xx},Ad={exports:{}},Bd={exports:{}};(function(f,e){(function(t,s){f.exports=s()})(Xh,function(){var t=t||function(s,i){var n=Object.create||function(){function g(){}return function(y){var b;return g.prototype=y,b=new g,g.prototype=null,b}}(),r={},a=r.lib={},o=a.Base=function(){return{extend:function(g){var y=n(this);return g&&y.mixIn(g),(!y.hasOwnProperty("init")||this.init===y.init)&&(y.init=function(){y.$super.init.apply(this,arguments)}),y.init.prototype=y,y.$super=this,y},create:function(){var g=this.extend();return g.init.apply(g,arguments),g},init:function(){},mixIn:function(g){for(var y in g)g.hasOwnProperty(y)&&(this[y]=g[y]);g.hasOwnProperty("toString")&&(this.toString=g.toString)},clone:function(){return this.init.prototype.extend(this)}}}(),d=a.WordArray=o.extend({init:function(g,y){g=this.words=g||[],y!=i?this.sigBytes=y:this.sigBytes=g.length*4},toString:function(g){return(g||u).stringify(this)},concat:function(g){var y=this.words,b=g.words,w=this.sigBytes,k=g.sigBytes;if(this.clamp(),w%4)for(var T=0;T<k;T++){var O=b[T>>>2]>>>24-T%4*8&255;y[w+T>>>2]|=O<<24-(w+T)%4*8}else for(var T=0;T<k;T+=4)y[w+T>>>2]=b[T>>>2];return this.sigBytes+=k,this},clamp:function(){var g=this.words,y=this.sigBytes;g[y>>>2]&=4294967295<<32-y%4*8,g.length=s.ceil(y/4)},clone:function(){var g=o.clone.call(this);return g.words=this.words.slice(0),g},random:function(g){for(var y=[],b=function(x){var x=x,C=987654321,E=4294967295;return function(){C=36969*(C&65535)+(C>>16)&E,x=18e3*(x&65535)+(x>>16)&E;var P=(C<<16)+x&E;return P/=4294967296,P+=.5,P*(s.random()>.5?1:-1)}},w=0,k;w<g;w+=4){var T=b((k||s.random())*4294967296);k=T()*987654071,y.push(T()*4294967296|0)}return new d.init(y,g)}}),c=r.enc={},u=c.Hex={stringify:function(g){for(var y=g.words,b=g.sigBytes,w=[],k=0;k<b;k++){var T=y[k>>>2]>>>24-k%4*8&255;w.push((T>>>4).toString(16)),w.push((T&15).toString(16))}return w.join("")},parse:function(g){for(var y=g.length,b=[],w=0;w<y;w+=2)b[w>>>3]|=parseInt(g.substr(w,2),16)<<24-w%8*4;return new d.init(b,y/2)}},h=c.Latin1={stringify:function(g){for(var y=g.words,b=g.sigBytes,w=[],k=0;k<b;k++){var T=y[k>>>2]>>>24-k%4*8&255;w.push(String.fromCharCode(T))}return w.join("")},parse:function(g){for(var y=g.length,b=[],w=0;w<y;w++)b[w>>>2]|=(g.charCodeAt(w)&255)<<24-w%4*8;return new d.init(b,y)}},l=c.Utf8={stringify:function(g){try{return decodeURIComponent(escape(h.stringify(g)))}catch{throw new Error("Malformed UTF-8 data")}},parse:function(g){return h.parse(unescape(encodeURIComponent(g)))}},p=a.BufferedBlockAlgorithm=o.extend({reset:function(){this._data=new d.init,this._nDataBytes=0},_append:function(g){typeof g=="string"&&(g=l.parse(g)),this._data.concat(g),this._nDataBytes+=g.sigBytes},_process:function(g){var y=this._data,b=y.words,w=y.sigBytes,k=this.blockSize,T=k*4,O=w/T;g?O=s.ceil(O):O=s.max((O|0)-this._minBufferSize,0);var x=O*k,C=s.min(x*4,w);if(x){for(var E=0;E<x;E+=k)this._doProcessBlock(b,E);var P=b.splice(0,x);y.sigBytes-=C}return new d.init(P,C)},clone:function(){var g=o.clone.call(this);return g._data=this._data.clone(),g},_minBufferSize:0});a.Hasher=p.extend({cfg:o.extend(),init:function(g){this.cfg=this.cfg.extend(g),this.reset()},reset:function(){p.reset.call(this),this._doReset()},update:function(g){return this._append(g),this._process(),this},finalize:function(g){g&&this._append(g);var y=this._doFinalize();return y},blockSize:16,_createHelper:function(g){return function(y,b){return new g.init(b).finalize(y)}},_createHmacHelper:function(g){return function(y,b){return new m.HMAC.init(g,b).finalize(y)}}});var m=r.algo={};return r}(Math);(function(){var s=t,i=s.lib,n=i.WordArray,r=s.enc;r.Base64={stringify:function(o){var d=o.words,c=o.sigBytes,u=this._map;o.clamp();for(var h=[],l=0;l<c;l+=3)for(var p=d[l>>>2]>>>24-l%4*8&255,m=d[l+1>>>2]>>>24-(l+1)%4*8&255,g=d[l+2>>>2]>>>24-(l+2)%4*8&255,y=p<<16|m<<8|g,b=0;b<4&&l+b*.75<c;b++)h.push(u.charAt(y>>>6*(3-b)&63));var w=u.charAt(64);if(w)for(;h.length%4;)h.push(w);return h.join("")},parse:function(o){var d=o.length,c=this._map,u=this._reverseMap;if(!u){u=this._reverseMap=[];for(var h=0;h<c.length;h++)u[c.charCodeAt(h)]=h}var l=c.charAt(64);if(l){var p=o.indexOf(l);p!==-1&&(d=p)}return a(o,d,u)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="};function a(o,d,c){for(var u=[],h=0,l=0;l<d;l++)if(l%4){var p=c[o.charCodeAt(l-1)]<<l%4*2,m=c[o.charCodeAt(l)]>>>6-l%4*2;u[h>>>2]|=(p|m)<<24-h%4*8,h++}return n.create(u,h)}})(),function(s){var i=t,n=i.lib,r=n.WordArray,a=n.Hasher,o=i.algo,d=[];(function(){for(var m=0;m<64;m++)d[m]=s.abs(s.sin(m+1))*4294967296|0})();var c=o.MD5=a.extend({_doReset:function(){this._hash=new r.init([1732584193,4023233417,2562383102,271733878])},_doProcessBlock:function(m,g){for(var y=0;y<16;y++){var b=g+y,w=m[b];m[b]=(w<<8|w>>>24)&16711935|(w<<24|w>>>8)&4278255360}var k=this._hash.words,T=m[g+0],O=m[g+1],x=m[g+2],C=m[g+3],E=m[g+4],P=m[g+5],_=m[g+6],S=m[g+7],I=m[g+8],v=m[g+9],N=m[g+10],q=m[g+11],R=m[g+12],G=m[g+13],F=m[g+14],A=m[g+15],V=k[0],Q=k[1],J=k[2],se=k[3];V=u(V,Q,J,se,T,7,d[0]),se=u(se,V,Q,J,O,12,d[1]),J=u(J,se,V,Q,x,17,d[2]),Q=u(Q,J,se,V,C,22,d[3]),V=u(V,Q,J,se,E,7,d[4]),se=u(se,V,Q,J,P,12,d[5]),J=u(J,se,V,Q,_,17,d[6]),Q=u(Q,J,se,V,S,22,d[7]),V=u(V,Q,J,se,I,7,d[8]),se=u(se,V,Q,J,v,12,d[9]),J=u(J,se,V,Q,N,17,d[10]),Q=u(Q,J,se,V,q,22,d[11]),V=u(V,Q,J,se,R,7,d[12]),se=u(se,V,Q,J,G,12,d[13]),J=u(J,se,V,Q,F,17,d[14]),Q=u(Q,J,se,V,A,22,d[15]),V=h(V,Q,J,se,O,5,d[16]),se=h(se,V,Q,J,_,9,d[17]),J=h(J,se,V,Q,q,14,d[18]),Q=h(Q,J,se,V,T,20,d[19]),V=h(V,Q,J,se,P,5,d[20]),se=h(se,V,Q,J,N,9,d[21]),J=h(J,se,V,Q,A,14,d[22]),Q=h(Q,J,se,V,E,20,d[23]),V=h(V,Q,J,se,v,5,d[24]),se=h(se,V,Q,J,F,9,d[25]),J=h(J,se,V,Q,C,14,d[26]),Q=h(Q,J,se,V,I,20,d[27]),V=h(V,Q,J,se,G,5,d[28]),se=h(se,V,Q,J,x,9,d[29]),J=h(J,se,V,Q,S,14,d[30]),Q=h(Q,J,se,V,R,20,d[31]),V=l(V,Q,J,se,P,4,d[32]),se=l(se,V,Q,J,I,11,d[33]),J=l(J,se,V,Q,q,16,d[34]),Q=l(Q,J,se,V,F,23,d[35]),V=l(V,Q,J,se,O,4,d[36]),se=l(se,V,Q,J,E,11,d[37]),J=l(J,se,V,Q,S,16,d[38]),Q=l(Q,J,se,V,N,23,d[39]),V=l(V,Q,J,se,G,4,d[40]),se=l(se,V,Q,J,T,11,d[41]),J=l(J,se,V,Q,C,16,d[42]),Q=l(Q,J,se,V,_,23,d[43]),V=l(V,Q,J,se,v,4,d[44]),se=l(se,V,Q,J,R,11,d[45]),J=l(J,se,V,Q,A,16,d[46]),Q=l(Q,J,se,V,x,23,d[47]),V=p(V,Q,J,se,T,6,d[48]),se=p(se,V,Q,J,S,10,d[49]),J=p(J,se,V,Q,F,15,d[50]),Q=p(Q,J,se,V,P,21,d[51]),V=p(V,Q,J,se,R,6,d[52]),se=p(se,V,Q,J,C,10,d[53]),J=p(J,se,V,Q,N,15,d[54]),Q=p(Q,J,se,V,O,21,d[55]),V=p(V,Q,J,se,I,6,d[56]),se=p(se,V,Q,J,A,10,d[57]),J=p(J,se,V,Q,_,15,d[58]),Q=p(Q,J,se,V,G,21,d[59]),V=p(V,Q,J,se,E,6,d[60]),se=p(se,V,Q,J,q,10,d[61]),J=p(J,se,V,Q,x,15,d[62]),Q=p(Q,J,se,V,v,21,d[63]),k[0]=k[0]+V|0,k[1]=k[1]+Q|0,k[2]=k[2]+J|0,k[3]=k[3]+se|0},_doFinalize:function(){var m=this._data,g=m.words,y=this._nDataBytes*8,b=m.sigBytes*8;g[b>>>5]|=128<<24-b%32;var w=s.floor(y/4294967296),k=y;g[(b+64>>>9<<4)+15]=(w<<8|w>>>24)&16711935|(w<<24|w>>>8)&4278255360,g[(b+64>>>9<<4)+14]=(k<<8|k>>>24)&16711935|(k<<24|k>>>8)&4278255360,m.sigBytes=(g.length+1)*4,this._process();for(var T=this._hash,O=T.words,x=0;x<4;x++){var C=O[x];O[x]=(C<<8|C>>>24)&16711935|(C<<24|C>>>8)&4278255360}return T},clone:function(){var m=a.clone.call(this);return m._hash=this._hash.clone(),m}});function u(m,g,y,b,w,k,T){var O=m+(g&y|~g&b)+w+T;return(O<<k|O>>>32-k)+g}function h(m,g,y,b,w,k,T){var O=m+(g&b|y&~b)+w+T;return(O<<k|O>>>32-k)+g}function l(m,g,y,b,w,k,T){var O=m+(g^y^b)+w+T;return(O<<k|O>>>32-k)+g}function p(m,g,y,b,w,k,T){var O=m+(y^(g|~b))+w+T;return(O<<k|O>>>32-k)+g}i.MD5=a._createHelper(c),i.HmacMD5=a._createHmacHelper(c)}(Math),function(){var s=t,i=s.lib,n=i.WordArray,r=i.Hasher,a=s.algo,o=[],d=a.SHA1=r.extend({_doReset:function(){this._hash=new n.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(c,u){for(var h=this._hash.words,l=h[0],p=h[1],m=h[2],g=h[3],y=h[4],b=0;b<80;b++){if(b<16)o[b]=c[u+b]|0;else{var w=o[b-3]^o[b-8]^o[b-14]^o[b-16];o[b]=w<<1|w>>>31}var k=(l<<5|l>>>27)+y+o[b];b<20?k+=(p&m|~p&g)+1518500249:b<40?k+=(p^m^g)+1859775393:b<60?k+=(p&m|p&g|m&g)-1894007588:k+=(p^m^g)-899497514,y=g,g=m,m=p<<30|p>>>2,p=l,l=k}h[0]=h[0]+l|0,h[1]=h[1]+p|0,h[2]=h[2]+m|0,h[3]=h[3]+g|0,h[4]=h[4]+y|0},_doFinalize:function(){var c=this._data,u=c.words,h=this._nDataBytes*8,l=c.sigBytes*8;return u[l>>>5]|=128<<24-l%32,u[(l+64>>>9<<4)+14]=Math.floor(h/4294967296),u[(l+64>>>9<<4)+15]=h,c.sigBytes=u.length*4,this._process(),this._hash},clone:function(){var c=r.clone.call(this);return c._hash=this._hash.clone(),c}});s.SHA1=r._createHelper(d),s.HmacSHA1=r._createHmacHelper(d)}(),function(s){var i=t,n=i.lib,r=n.WordArray,a=n.Hasher,o=i.algo,d=[],c=[];(function(){function l(y){for(var b=s.sqrt(y),w=2;w<=b;w++)if(!(y%w))return!1;return!0}function p(y){return(y-(y|0))*4294967296|0}for(var m=2,g=0;g<64;)l(m)&&(g<8&&(d[g]=p(s.pow(m,1/2))),c[g]=p(s.pow(m,1/3)),g++),m++})();var u=[],h=o.SHA256=a.extend({_doReset:function(){this._hash=new r.init(d.slice(0))},_doProcessBlock:function(l,p){for(var m=this._hash.words,g=m[0],y=m[1],b=m[2],w=m[3],k=m[4],T=m[5],O=m[6],x=m[7],C=0;C<64;C++){if(C<16)u[C]=l[p+C]|0;else{var E=u[C-15],P=(E<<25|E>>>7)^(E<<14|E>>>18)^E>>>3,_=u[C-2],S=(_<<15|_>>>17)^(_<<13|_>>>19)^_>>>10;u[C]=P+u[C-7]+S+u[C-16]}var I=k&T^~k&O,v=g&y^g&b^y&b,N=(g<<30|g>>>2)^(g<<19|g>>>13)^(g<<10|g>>>22),q=(k<<26|k>>>6)^(k<<21|k>>>11)^(k<<7|k>>>25),R=x+q+I+c[C]+u[C],G=N+v;x=O,O=T,T=k,k=w+R|0,w=b,b=y,y=g,g=R+G|0}m[0]=m[0]+g|0,m[1]=m[1]+y|0,m[2]=m[2]+b|0,m[3]=m[3]+w|0,m[4]=m[4]+k|0,m[5]=m[5]+T|0,m[6]=m[6]+O|0,m[7]=m[7]+x|0},_doFinalize:function(){var l=this._data,p=l.words,m=this._nDataBytes*8,g=l.sigBytes*8;return p[g>>>5]|=128<<24-g%32,p[(g+64>>>9<<4)+14]=s.floor(m/4294967296),p[(g+64>>>9<<4)+15]=m,l.sigBytes=p.length*4,this._process(),this._hash},clone:function(){var l=a.clone.call(this);return l._hash=this._hash.clone(),l}});i.SHA256=a._createHelper(h),i.HmacSHA256=a._createHmacHelper(h)}(Math),function(){var s=t,i=s.lib,n=i.WordArray,r=s.enc;r.Utf16=r.Utf16BE={stringify:function(o){for(var d=o.words,c=o.sigBytes,u=[],h=0;h<c;h+=2){var l=d[h>>>2]>>>16-h%4*8&65535;u.push(String.fromCharCode(l))}return u.join("")},parse:function(o){for(var d=o.length,c=[],u=0;u<d;u++)c[u>>>1]|=o.charCodeAt(u)<<16-u%2*16;return n.create(c,d*2)}},r.Utf16LE={stringify:function(o){for(var d=o.words,c=o.sigBytes,u=[],h=0;h<c;h+=2){var l=a(d[h>>>2]>>>16-h%4*8&65535);u.push(String.fromCharCode(l))}return u.join("")},parse:function(o){for(var d=o.length,c=[],u=0;u<d;u++)c[u>>>1]|=a(o.charCodeAt(u)<<16-u%2*16);return n.create(c,d*2)}};function a(o){return o<<8&4278255360|o>>>8&16711935}}(),function(){if(typeof ArrayBuffer=="function"){var s=t,i=s.lib,n=i.WordArray,r=n.init,a=n.init=function(o){if(o instanceof ArrayBuffer&&(o=new Uint8Array(o)),(o instanceof Int8Array||typeof Uint8ClampedArray<"u"&&o instanceof Uint8ClampedArray||o instanceof Int16Array||o instanceof Uint16Array||o instanceof Int32Array||o instanceof Uint32Array||o instanceof Float32Array||o instanceof Float64Array)&&(o=new Uint8Array(o.buffer,o.byteOffset,o.byteLength)),o instanceof Uint8Array){for(var d=o.byteLength,c=[],u=0;u<d;u++)c[u>>>2]|=o[u]<<24-u%4*8;r.call(this,c,d)}else r.apply(this,arguments)};a.prototype=n}}();/** @preserve
		(c) 2012 by Cédric Mesnil. All rights reserved.

		Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

		    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
		    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

		THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		*/(function(s){var i=t,n=i.lib,r=n.WordArray,a=n.Hasher,o=i.algo,d=r.create([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13]),c=r.create([5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11]),u=r.create([11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6]),h=r.create([8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]),l=r.create([0,1518500249,1859775393,2400959708,2840853838]),p=r.create([1352829926,1548603684,1836072691,2053994217,0]),m=o.RIPEMD160=a.extend({_doReset:function(){this._hash=r.create([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(O,x){for(var C=0;C<16;C++){var E=x+C,P=O[E];O[E]=(P<<8|P>>>24)&16711935|(P<<24|P>>>8)&4278255360}var _=this._hash.words,S=l.words,I=p.words,v=d.words,N=c.words,q=u.words,R=h.words,G,F,A,V,Q,J,se,we,le,Oe;J=G=_[0],se=F=_[1],we=A=_[2],le=V=_[3],Oe=Q=_[4];for(var Ce,C=0;C<80;C+=1)Ce=G+O[x+v[C]]|0,C<16?Ce+=g(F,A,V)+S[0]:C<32?Ce+=y(F,A,V)+S[1]:C<48?Ce+=b(F,A,V)+S[2]:C<64?Ce+=w(F,A,V)+S[3]:Ce+=k(F,A,V)+S[4],Ce=Ce|0,Ce=T(Ce,q[C]),Ce=Ce+Q|0,G=Q,Q=V,V=T(A,10),A=F,F=Ce,Ce=J+O[x+N[C]]|0,C<16?Ce+=k(se,we,le)+I[0]:C<32?Ce+=w(se,we,le)+I[1]:C<48?Ce+=b(se,we,le)+I[2]:C<64?Ce+=y(se,we,le)+I[3]:Ce+=g(se,we,le)+I[4],Ce=Ce|0,Ce=T(Ce,R[C]),Ce=Ce+Oe|0,J=Oe,Oe=le,le=T(we,10),we=se,se=Ce;Ce=_[1]+A+le|0,_[1]=_[2]+V+Oe|0,_[2]=_[3]+Q+J|0,_[3]=_[4]+G+se|0,_[4]=_[0]+F+we|0,_[0]=Ce},_doFinalize:function(){var O=this._data,x=O.words,C=this._nDataBytes*8,E=O.sigBytes*8;x[E>>>5]|=128<<24-E%32,x[(E+64>>>9<<4)+14]=(C<<8|C>>>24)&16711935|(C<<24|C>>>8)&4278255360,O.sigBytes=(x.length+1)*4,this._process();for(var P=this._hash,_=P.words,S=0;S<5;S++){var I=_[S];_[S]=(I<<8|I>>>24)&16711935|(I<<24|I>>>8)&4278255360}return P},clone:function(){var O=a.clone.call(this);return O._hash=this._hash.clone(),O}});function g(O,x,C){return O^x^C}function y(O,x,C){return O&x|~O&C}function b(O,x,C){return(O|~x)^C}function w(O,x,C){return O&C|x&~C}function k(O,x,C){return O^(x|~C)}function T(O,x){return O<<x|O>>>32-x}i.RIPEMD160=a._createHelper(m),i.HmacRIPEMD160=a._createHmacHelper(m)})(),function(){var s=t,i=s.lib,n=i.Base,r=s.enc,a=r.Utf8,o=s.algo;o.HMAC=n.extend({init:function(d,c){d=this._hasher=new d.init,typeof c=="string"&&(c=a.parse(c));var u=d.blockSize,h=u*4;c.sigBytes>h&&(c=d.finalize(c)),c.clamp();for(var l=this._oKey=c.clone(),p=this._iKey=c.clone(),m=l.words,g=p.words,y=0;y<u;y++)m[y]^=1549556828,g[y]^=909522486;l.sigBytes=p.sigBytes=h,this.reset()},reset:function(){var d=this._hasher;d.reset(),d.update(this._iKey)},update:function(d){return this._hasher.update(d),this},finalize:function(d){var c=this._hasher,u=c.finalize(d);c.reset();var h=c.finalize(this._oKey.clone().concat(u));return h}})}(),function(){var s=t,i=s.lib,n=i.Base,r=i.WordArray,a=s.algo,o=a.SHA1,d=a.HMAC,c=a.PBKDF2=n.extend({cfg:n.extend({keySize:128/32,hasher:o,iterations:1}),init:function(u){this.cfg=this.cfg.extend(u)},compute:function(u,h){for(var l=this.cfg,p=d.create(l.hasher,u),m=r.create(),g=r.create([1]),y=m.words,b=g.words,w=l.keySize,k=l.iterations;y.length<w;){var T=p.update(h).finalize(g);p.reset();for(var O=T.words,x=O.length,C=T,E=1;E<k;E++){C=p.finalize(C),p.reset();for(var P=C.words,_=0;_<x;_++)O[_]^=P[_]}m.concat(T),b[0]++}return m.sigBytes=w*4,m}});s.PBKDF2=function(u,h,l){return c.create(l).compute(u,h)}}(),function(){var s=t,i=s.lib,n=i.Base,r=i.WordArray,a=s.algo,o=a.MD5,d=a.EvpKDF=n.extend({cfg:n.extend({keySize:128/32,hasher:o,iterations:1}),init:function(c){this.cfg=this.cfg.extend(c)},compute:function(c,u){for(var h=this.cfg,l=h.hasher.create(),p=r.create(),m=p.words,g=h.keySize,y=h.iterations;m.length<g;){b&&l.update(b);var b=l.update(c).finalize(u);l.reset();for(var w=1;w<y;w++)b=l.finalize(b),l.reset();p.concat(b)}return p.sigBytes=g*4,p}});s.EvpKDF=function(c,u,h){return d.create(h).compute(c,u)}}(),function(){var s=t,i=s.lib,n=i.WordArray,r=s.algo,a=r.SHA256,o=r.SHA224=a.extend({_doReset:function(){this._hash=new n.init([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428])},_doFinalize:function(){var d=a._doFinalize.call(this);return d.sigBytes-=4,d}});s.SHA224=a._createHelper(o),s.HmacSHA224=a._createHmacHelper(o)}(),function(s){var i=t,n=i.lib,r=n.Base,a=n.WordArray,o=i.x64={};o.Word=r.extend({init:function(d,c){this.high=d,this.low=c}}),o.WordArray=r.extend({init:function(d,c){d=this.words=d||[],c!=s?this.sigBytes=c:this.sigBytes=d.length*8},toX32:function(){for(var d=this.words,c=d.length,u=[],h=0;h<c;h++){var l=d[h];u.push(l.high),u.push(l.low)}return a.create(u,this.sigBytes)},clone:function(){for(var d=r.clone.call(this),c=d.words=this.words.slice(0),u=c.length,h=0;h<u;h++)c[h]=c[h].clone();return d}})}(),function(s){var i=t,n=i.lib,r=n.WordArray,a=n.Hasher,o=i.x64,d=o.Word,c=i.algo,u=[],h=[],l=[];(function(){for(var g=1,y=0,b=0;b<24;b++){u[g+5*y]=(b+1)*(b+2)/2%64;var w=y%5,k=(2*g+3*y)%5;g=w,y=k}for(var g=0;g<5;g++)for(var y=0;y<5;y++)h[g+5*y]=y+(2*g+3*y)%5*5;for(var T=1,O=0;O<24;O++){for(var x=0,C=0,E=0;E<7;E++){if(T&1){var P=(1<<E)-1;P<32?C^=1<<P:x^=1<<P-32}T&128?T=T<<1^113:T<<=1}l[O]=d.create(x,C)}})();var p=[];(function(){for(var g=0;g<25;g++)p[g]=d.create()})();var m=c.SHA3=a.extend({cfg:a.cfg.extend({outputLength:512}),_doReset:function(){for(var g=this._state=[],y=0;y<25;y++)g[y]=new d.init;this.blockSize=(1600-2*this.cfg.outputLength)/32},_doProcessBlock:function(g,y){for(var b=this._state,w=this.blockSize/2,k=0;k<w;k++){var T=g[y+2*k],O=g[y+2*k+1];T=(T<<8|T>>>24)&16711935|(T<<24|T>>>8)&4278255360,O=(O<<8|O>>>24)&16711935|(O<<24|O>>>8)&4278255360;var x=b[k];x.high^=O,x.low^=T}for(var C=0;C<24;C++){for(var E=0;E<5;E++){for(var P=0,_=0,S=0;S<5;S++){var x=b[E+5*S];P^=x.high,_^=x.low}var I=p[E];I.high=P,I.low=_}for(var E=0;E<5;E++)for(var v=p[(E+4)%5],N=p[(E+1)%5],q=N.high,R=N.low,P=v.high^(q<<1|R>>>31),_=v.low^(R<<1|q>>>31),S=0;S<5;S++){var x=b[E+5*S];x.high^=P,x.low^=_}for(var G=1;G<25;G++){var x=b[G],F=x.high,A=x.low,V=u[G];if(V<32)var P=F<<V|A>>>32-V,_=A<<V|F>>>32-V;else var P=A<<V-32|F>>>64-V,_=F<<V-32|A>>>64-V;var Q=p[h[G]];Q.high=P,Q.low=_}var J=p[0],se=b[0];J.high=se.high,J.low=se.low;for(var E=0;E<5;E++)for(var S=0;S<5;S++){var G=E+5*S,x=b[G],we=p[G],le=p[(E+1)%5+5*S],Oe=p[(E+2)%5+5*S];x.high=we.high^~le.high&Oe.high,x.low=we.low^~le.low&Oe.low}var x=b[0],Ce=l[C];x.high^=Ce.high,x.low^=Ce.low}},_doFinalize:function(){var g=this._data,y=g.words;this._nDataBytes*8;var b=g.sigBytes*8,w=this.blockSize*32;y[b>>>5]|=1<<24-b%32,y[(s.ceil((b+1)/w)*w>>>5)-1]|=128,g.sigBytes=y.length*4,this._process();for(var k=this._state,T=this.cfg.outputLength/8,O=T/8,x=[],C=0;C<O;C++){var E=k[C],P=E.high,_=E.low;P=(P<<8|P>>>24)&16711935|(P<<24|P>>>8)&4278255360,_=(_<<8|_>>>24)&16711935|(_<<24|_>>>8)&4278255360,x.push(_),x.push(P)}return new r.init(x,T)},clone:function(){for(var g=a.clone.call(this),y=g._state=this._state.slice(0),b=0;b<25;b++)y[b]=y[b].clone();return g}});i.SHA3=a._createHelper(m),i.HmacSHA3=a._createHmacHelper(m)}(Math),function(){var s=t,i=s.lib,n=i.Hasher,r=s.x64,a=r.Word,o=r.WordArray,d=s.algo;function c(){return a.create.apply(a,arguments)}var u=[c(1116352408,3609767458),c(1899447441,602891725),c(3049323471,3964484399),c(3921009573,2173295548),c(961987163,4081628472),c(1508970993,3053834265),c(2453635748,2937671579),c(2870763221,3664609560),c(3624381080,2734883394),c(310598401,1164996542),c(607225278,1323610764),c(1426881987,3590304994),c(1925078388,4068182383),c(2162078206,991336113),c(2614888103,633803317),c(3248222580,3479774868),c(3835390401,2666613458),c(4022224774,944711139),c(264347078,2341262773),c(604807628,2007800933),c(770255983,1495990901),c(1249150122,1856431235),c(1555081692,3175218132),c(1996064986,2198950837),c(2554220882,3999719339),c(2821834349,766784016),c(2952996808,2566594879),c(3210313671,3203337956),c(3336571891,1034457026),c(3584528711,2466948901),c(113926993,3758326383),c(338241895,168717936),c(666307205,1188179964),c(773529912,1546045734),c(1294757372,1522805485),c(1396182291,2643833823),c(1695183700,2343527390),c(1986661051,1014477480),c(2177026350,1206759142),c(2456956037,344077627),c(2730485921,1290863460),c(2820302411,3158454273),c(3259730800,3505952657),c(3345764771,106217008),c(3516065817,3606008344),c(3600352804,1432725776),c(4094571909,1467031594),c(275423344,851169720),c(430227734,3100823752),c(506948616,1363258195),c(659060556,3750685593),c(883997877,3785050280),c(958139571,3318307427),c(1322822218,3812723403),c(1537002063,2003034995),c(1747873779,3602036899),c(1955562222,1575990012),c(2024104815,1125592928),c(2227730452,2716904306),c(2361852424,442776044),c(2428436474,593698344),c(2756734187,3733110249),c(3204031479,2999351573),c(3329325298,3815920427),c(3391569614,3928383900),c(3515267271,566280711),c(3940187606,3454069534),c(4118630271,4000239992),c(116418474,1914138554),c(174292421,2731055270),c(289380356,3203993006),c(460393269,320620315),c(685471733,587496836),c(852142971,1086792851),c(1017036298,365543100),c(1126000580,2618297676),c(1288033470,3409855158),c(1501505948,4234509866),c(1607167915,987167468),c(1816402316,1246189591)],h=[];(function(){for(var p=0;p<80;p++)h[p]=c()})();var l=d.SHA512=n.extend({_doReset:function(){this._hash=new o.init([new a.init(1779033703,4089235720),new a.init(3144134277,2227873595),new a.init(1013904242,4271175723),new a.init(2773480762,1595750129),new a.init(1359893119,2917565137),new a.init(2600822924,725511199),new a.init(528734635,4215389547),new a.init(1541459225,327033209)])},_doProcessBlock:function(p,m){for(var g=this._hash.words,y=g[0],b=g[1],w=g[2],k=g[3],T=g[4],O=g[5],x=g[6],C=g[7],E=y.high,P=y.low,_=b.high,S=b.low,I=w.high,v=w.low,N=k.high,q=k.low,R=T.high,G=T.low,F=O.high,A=O.low,V=x.high,Q=x.low,J=C.high,se=C.low,we=E,le=P,Oe=_,Ce=S,Le=I,Fe=v,At=N,D=q,j=R,U=G,H=F,W=A,Y=V,z=Q,X=J,ne=se,te=0;te<80;te++){var ce=h[te];if(te<16)var ke=ce.high=p[m+te*2]|0,ue=ce.low=p[m+te*2+1]|0;else{var Ie=h[te-15],Pe=Ie.high,L=Ie.low,M=(Pe>>>1|L<<31)^(Pe>>>8|L<<24)^Pe>>>7,B=(L>>>1|Pe<<31)^(L>>>8|Pe<<24)^(L>>>7|Pe<<25),K=h[te-2],Z=K.high,re=K.low,ae=(Z>>>19|re<<13)^(Z<<3|re>>>29)^Z>>>6,Ee=(re>>>19|Z<<13)^(re<<3|Z>>>29)^(re>>>6|Z<<26),We=h[te-7],Ne=We.high,De=We.low,ut=h[te-16],Jt=ut.high,Dt=ut.low,ue=B+De,ke=M+Ne+(ue>>>0<B>>>0?1:0),ue=ue+Ee,ke=ke+ae+(ue>>>0<Ee>>>0?1:0),ue=ue+Dt,ke=ke+Jt+(ue>>>0<Dt>>>0?1:0);ce.high=ke,ce.low=ue}var zu=j&H^~j&Y,Ht=U&W^~U&z,es=we&Oe^we&Le^Oe&Le,Ku=le&Ce^le&Fe^Ce&Fe,ts=(we>>>28|le<<4)^(we<<30|le>>>2)^(we<<25|le>>>7),Gt=(le>>>28|we<<4)^(le<<30|we>>>2)^(le<<25|we>>>7),Xu=(j>>>14|U<<18)^(j>>>18|U<<14)^(j<<23|U>>>9),ss=(U>>>14|j<<18)^(U>>>18|j<<14)^(U<<23|j>>>9),Ut=u[te],Yu=Ut.high,$t=Ut.low,dt=ne+ss,bn=X+Xu+(dt>>>0<ne>>>0?1:0),dt=dt+Ht,bn=bn+zu+(dt>>>0<Ht>>>0?1:0),dt=dt+$t,bn=bn+Yu+(dt>>>0<$t>>>0?1:0),dt=dt+ue,bn=bn+ke+(dt>>>0<ue>>>0?1:0),jt=Gt+Ku,is=ts+es+(jt>>>0<Gt>>>0?1:0);X=Y,ne=z,Y=H,z=W,H=j,W=U,U=D+dt|0,j=At+bn+(U>>>0<D>>>0?1:0)|0,At=Le,D=Fe,Le=Oe,Fe=Ce,Oe=we,Ce=le,le=dt+jt|0,we=bn+is+(le>>>0<dt>>>0?1:0)|0}P=y.low=P+le,y.high=E+we+(P>>>0<le>>>0?1:0),S=b.low=S+Ce,b.high=_+Oe+(S>>>0<Ce>>>0?1:0),v=w.low=v+Fe,w.high=I+Le+(v>>>0<Fe>>>0?1:0),q=k.low=q+D,k.high=N+At+(q>>>0<D>>>0?1:0),G=T.low=G+U,T.high=R+j+(G>>>0<U>>>0?1:0),A=O.low=A+W,O.high=F+H+(A>>>0<W>>>0?1:0),Q=x.low=Q+z,x.high=V+Y+(Q>>>0<z>>>0?1:0),se=C.low=se+ne,C.high=J+X+(se>>>0<ne>>>0?1:0)},_doFinalize:function(){var p=this._data,m=p.words,g=this._nDataBytes*8,y=p.sigBytes*8;m[y>>>5]|=128<<24-y%32,m[(y+128>>>10<<5)+30]=Math.floor(g/4294967296),m[(y+128>>>10<<5)+31]=g,p.sigBytes=m.length*4,this._process();var b=this._hash.toX32();return b},clone:function(){var p=n.clone.call(this);return p._hash=this._hash.clone(),p},blockSize:1024/32});s.SHA512=n._createHelper(l),s.HmacSHA512=n._createHmacHelper(l)}(),function(){var s=t,i=s.x64,n=i.Word,r=i.WordArray,a=s.algo,o=a.SHA512,d=a.SHA384=o.extend({_doReset:function(){this._hash=new r.init([new n.init(3418070365,3238371032),new n.init(1654270250,914150663),new n.init(2438529370,812702999),new n.init(355462360,4144912697),new n.init(1731405415,4290775857),new n.init(2394180231,1750603025),new n.init(3675008525,1694076839),new n.init(1203062813,3204075428)])},_doFinalize:function(){var c=o._doFinalize.call(this);return c.sigBytes-=16,c}});s.SHA384=o._createHelper(d),s.HmacSHA384=o._createHmacHelper(d)}(),t.lib.Cipher||function(s){var i=t,n=i.lib,r=n.Base,a=n.WordArray,o=n.BufferedBlockAlgorithm,d=i.enc;d.Utf8;var c=d.Base64,u=i.algo,h=u.EvpKDF,l=n.Cipher=o.extend({cfg:r.extend(),createEncryptor:function(P,_){return this.create(this._ENC_XFORM_MODE,P,_)},createDecryptor:function(P,_){return this.create(this._DEC_XFORM_MODE,P,_)},init:function(P,_,S){this.cfg=this.cfg.extend(S),this._xformMode=P,this._key=_,this.reset()},reset:function(){o.reset.call(this),this._doReset()},process:function(P){return this._append(P),this._process()},finalize:function(P){P&&this._append(P);var _=this._doFinalize();return _},keySize:128/32,ivSize:128/32,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(){function P(_){return typeof _=="string"?E:O}return function(_){return{encrypt:function(S,I,v){return P(I).encrypt(_,S,I,v)},decrypt:function(S,I,v){return P(I).decrypt(_,S,I,v)}}}}()});n.StreamCipher=l.extend({_doFinalize:function(){var P=this._process(!0);return P},blockSize:1});var p=i.mode={},m=n.BlockCipherMode=r.extend({createEncryptor:function(P,_){return this.Encryptor.create(P,_)},createDecryptor:function(P,_){return this.Decryptor.create(P,_)},init:function(P,_){this._cipher=P,this._iv=_}}),g=p.CBC=function(){var P=m.extend();P.Encryptor=P.extend({processBlock:function(S,I){var v=this._cipher,N=v.blockSize;_.call(this,S,I,N),v.encryptBlock(S,I),this._prevBlock=S.slice(I,I+N)}}),P.Decryptor=P.extend({processBlock:function(S,I){var v=this._cipher,N=v.blockSize,q=S.slice(I,I+N);v.decryptBlock(S,I),_.call(this,S,I,N),this._prevBlock=q}});function _(S,I,v){var N=this._iv;if(N){var q=N;this._iv=s}else var q=this._prevBlock;for(var R=0;R<v;R++)S[I+R]^=q[R]}return P}(),y=i.pad={},b=y.Pkcs7={pad:function(P,_){for(var S=_*4,I=S-P.sigBytes%S,v=I<<24|I<<16|I<<8|I,N=[],q=0;q<I;q+=4)N.push(v);var R=a.create(N,I);P.concat(R)},unpad:function(P){var _=P.words[P.sigBytes-1>>>2]&255;P.sigBytes-=_}};n.BlockCipher=l.extend({cfg:l.cfg.extend({mode:g,padding:b}),reset:function(){l.reset.call(this);var P=this.cfg,_=P.iv,S=P.mode;if(this._xformMode==this._ENC_XFORM_MODE)var I=S.createEncryptor;else{var I=S.createDecryptor;this._minBufferSize=1}this._mode&&this._mode.__creator==I?this._mode.init(this,_&&_.words):(this._mode=I.call(S,this,_&&_.words),this._mode.__creator=I)},_doProcessBlock:function(P,_){this._mode.processBlock(P,_)},_doFinalize:function(){var P=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){P.pad(this._data,this.blockSize);var _=this._process(!0)}else{var _=this._process(!0);P.unpad(_)}return _},blockSize:128/32});var w=n.CipherParams=r.extend({init:function(P){this.mixIn(P)},toString:function(P){return(P||this.formatter).stringify(this)}}),k=i.format={},T=k.OpenSSL={stringify:function(P){var _=P.ciphertext,S=P.salt;if(S)var I=a.create([1398893684,1701076831]).concat(S).concat(_);else var I=_;return I.toString(c)},parse:function(P){var _=c.parse(P),S=_.words;if(S[0]==1398893684&&S[1]==1701076831){var I=a.create(S.slice(2,4));S.splice(0,4),_.sigBytes-=16}return w.create({ciphertext:_,salt:I})}},O=n.SerializableCipher=r.extend({cfg:r.extend({format:T}),encrypt:function(P,_,S,I){I=this.cfg.extend(I);var v=P.createEncryptor(S,I),N=v.finalize(_),q=v.cfg;return w.create({ciphertext:N,key:S,iv:q.iv,algorithm:P,mode:q.mode,padding:q.padding,blockSize:P.blockSize,formatter:I.format})},decrypt:function(P,_,S,I){I=this.cfg.extend(I),_=this._parse(_,I.format);var v=P.createDecryptor(S,I).finalize(_.ciphertext);return v},_parse:function(P,_){return typeof P=="string"?_.parse(P,this):P}}),x=i.kdf={},C=x.OpenSSL={execute:function(P,_,S,I){I||(I=a.random(64/8));var v=h.create({keySize:_+S}).compute(P,I),N=a.create(v.words.slice(_),S*4);return v.sigBytes=_*4,w.create({key:v,iv:N,salt:I})}},E=n.PasswordBasedCipher=O.extend({cfg:O.cfg.extend({kdf:C}),encrypt:function(P,_,S,I){I=this.cfg.extend(I);var v=I.kdf.execute(S,P.keySize,P.ivSize);I.iv=v.iv;var N=O.encrypt.call(this,P,_,v.key,I);return N.mixIn(v),N},decrypt:function(P,_,S,I){I=this.cfg.extend(I),_=this._parse(_,I.format);var v=I.kdf.execute(S,P.keySize,P.ivSize,_.salt);I.iv=v.iv;var N=O.decrypt.call(this,P,_,v.key,I);return N}})}(),t.mode.CFB=function(){var s=t.lib.BlockCipherMode.extend();s.Encryptor=s.extend({processBlock:function(n,r){var a=this._cipher,o=a.blockSize;i.call(this,n,r,o,a),this._prevBlock=n.slice(r,r+o)}}),s.Decryptor=s.extend({processBlock:function(n,r){var a=this._cipher,o=a.blockSize,d=n.slice(r,r+o);i.call(this,n,r,o,a),this._prevBlock=d}});function i(n,r,a,o){var d=this._iv;if(d){var c=d.slice(0);this._iv=void 0}else var c=this._prevBlock;o.encryptBlock(c,0);for(var u=0;u<a;u++)n[r+u]^=c[u]}return s}(),t.mode.ECB=function(){var s=t.lib.BlockCipherMode.extend();return s.Encryptor=s.extend({processBlock:function(i,n){this._cipher.encryptBlock(i,n)}}),s.Decryptor=s.extend({processBlock:function(i,n){this._cipher.decryptBlock(i,n)}}),s}(),t.pad.AnsiX923={pad:function(s,i){var n=s.sigBytes,r=i*4,a=r-n%r,o=n+a-1;s.clamp(),s.words[o>>>2]|=a<<24-o%4*8,s.sigBytes+=a},unpad:function(s){var i=s.words[s.sigBytes-1>>>2]&255;s.sigBytes-=i}},t.pad.Iso10126={pad:function(s,i){var n=i*4,r=n-s.sigBytes%n;s.concat(t.lib.WordArray.random(r-1)).concat(t.lib.WordArray.create([r<<24],1))},unpad:function(s){var i=s.words[s.sigBytes-1>>>2]&255;s.sigBytes-=i}},t.pad.Iso97971={pad:function(s,i){s.concat(t.lib.WordArray.create([2147483648],1)),t.pad.ZeroPadding.pad(s,i)},unpad:function(s){t.pad.ZeroPadding.unpad(s),s.sigBytes--}},t.mode.OFB=function(){var s=t.lib.BlockCipherMode.extend(),i=s.Encryptor=s.extend({processBlock:function(n,r){var a=this._cipher,o=a.blockSize,d=this._iv,c=this._keystream;d&&(c=this._keystream=d.slice(0),this._iv=void 0),a.encryptBlock(c,0);for(var u=0;u<o;u++)n[r+u]^=c[u]}});return s.Decryptor=i,s}(),t.pad.NoPadding={pad:function(){},unpad:function(){}},function(s){var i=t,n=i.lib,r=n.CipherParams,a=i.enc,o=a.Hex,d=i.format;d.Hex={stringify:function(c){return c.ciphertext.toString(o)},parse:function(c){var u=o.parse(c);return r.create({ciphertext:u})}}}(),function(){var s=t,i=s.lib,n=i.BlockCipher,r=s.algo,a=[],o=[],d=[],c=[],u=[],h=[],l=[],p=[],m=[],g=[];(function(){for(var w=[],k=0;k<256;k++)k<128?w[k]=k<<1:w[k]=k<<1^283;for(var T=0,O=0,k=0;k<256;k++){var x=O^O<<1^O<<2^O<<3^O<<4;x=x>>>8^x&255^99,a[T]=x,o[x]=T;var C=w[T],E=w[C],P=w[E],_=w[x]*257^x*16843008;d[T]=_<<24|_>>>8,c[T]=_<<16|_>>>16,u[T]=_<<8|_>>>24,h[T]=_;var _=P*16843009^E*65537^C*257^T*16843008;l[x]=_<<24|_>>>8,p[x]=_<<16|_>>>16,m[x]=_<<8|_>>>24,g[x]=_,T?(T=C^w[w[w[P^C]]],O^=w[w[O]]):T=O=1}})();var y=[0,1,2,4,8,16,32,64,128,27,54],b=r.AES=n.extend({_doReset:function(){if(!(this._nRounds&&this._keyPriorReset===this._key)){for(var w=this._keyPriorReset=this._key,k=w.words,T=w.sigBytes/4,O=this._nRounds=T+6,x=(O+1)*4,C=this._keySchedule=[],E=0;E<x;E++)if(E<T)C[E]=k[E];else{var P=C[E-1];E%T?T>6&&E%T==4&&(P=a[P>>>24]<<24|a[P>>>16&255]<<16|a[P>>>8&255]<<8|a[P&255]):(P=P<<8|P>>>24,P=a[P>>>24]<<24|a[P>>>16&255]<<16|a[P>>>8&255]<<8|a[P&255],P^=y[E/T|0]<<24),C[E]=C[E-T]^P}for(var _=this._invKeySchedule=[],S=0;S<x;S++){var E=x-S;if(S%4)var P=C[E];else var P=C[E-4];S<4||E<=4?_[S]=P:_[S]=l[a[P>>>24]]^p[a[P>>>16&255]]^m[a[P>>>8&255]]^g[a[P&255]]}}},encryptBlock:function(w,k){this._doCryptBlock(w,k,this._keySchedule,d,c,u,h,a)},decryptBlock:function(w,k){var T=w[k+1];w[k+1]=w[k+3],w[k+3]=T,this._doCryptBlock(w,k,this._invKeySchedule,l,p,m,g,o);var T=w[k+1];w[k+1]=w[k+3],w[k+3]=T},_doCryptBlock:function(w,k,T,O,x,C,E,P){for(var _=this._nRounds,S=w[k]^T[0],I=w[k+1]^T[1],v=w[k+2]^T[2],N=w[k+3]^T[3],q=4,R=1;R<_;R++){var G=O[S>>>24]^x[I>>>16&255]^C[v>>>8&255]^E[N&255]^T[q++],F=O[I>>>24]^x[v>>>16&255]^C[N>>>8&255]^E[S&255]^T[q++],A=O[v>>>24]^x[N>>>16&255]^C[S>>>8&255]^E[I&255]^T[q++],V=O[N>>>24]^x[S>>>16&255]^C[I>>>8&255]^E[v&255]^T[q++];S=G,I=F,v=A,N=V}var G=(P[S>>>24]<<24|P[I>>>16&255]<<16|P[v>>>8&255]<<8|P[N&255])^T[q++],F=(P[I>>>24]<<24|P[v>>>16&255]<<16|P[N>>>8&255]<<8|P[S&255])^T[q++],A=(P[v>>>24]<<24|P[N>>>16&255]<<16|P[S>>>8&255]<<8|P[I&255])^T[q++],V=(P[N>>>24]<<24|P[S>>>16&255]<<16|P[I>>>8&255]<<8|P[v&255])^T[q++];w[k]=G,w[k+1]=F,w[k+2]=A,w[k+3]=V},keySize:256/32});s.AES=n._createHelper(b)}(),function(){var s=t,i=s.lib,n=i.WordArray,r=i.BlockCipher,a=s.algo,o=[57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4],d=[14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32],c=[1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28],u=[{0:8421888,268435456:32768,536870912:8421378,805306368:2,1073741824:512,1342177280:8421890,1610612736:8389122,1879048192:8388608,2147483648:514,2415919104:8389120,2684354560:33280,2952790016:8421376,3221225472:32770,3489660928:8388610,3758096384:0,4026531840:33282,134217728:0,402653184:8421890,671088640:33282,939524096:32768,1207959552:8421888,1476395008:512,1744830464:8421378,2013265920:2,2281701376:8389120,2550136832:33280,2818572288:8421376,3087007744:8389122,3355443200:8388610,3623878656:32770,3892314112:514,4160749568:8388608,1:32768,268435457:2,536870913:8421888,805306369:8388608,1073741825:8421378,1342177281:33280,1610612737:512,1879048193:8389122,2147483649:8421890,2415919105:8421376,2684354561:8388610,2952790017:33282,3221225473:514,3489660929:8389120,3758096385:32770,4026531841:0,134217729:8421890,402653185:8421376,671088641:8388608,939524097:512,1207959553:32768,1476395009:8388610,1744830465:2,2013265921:33282,2281701377:32770,2550136833:8389122,2818572289:514,3087007745:8421888,3355443201:8389120,3623878657:0,3892314113:33280,4160749569:8421378},{0:1074282512,16777216:16384,33554432:524288,50331648:1074266128,67108864:1073741840,83886080:1074282496,100663296:1073758208,117440512:16,134217728:540672,150994944:1073758224,167772160:1073741824,184549376:540688,201326592:524304,218103808:0,234881024:16400,251658240:1074266112,8388608:1073758208,25165824:540688,41943040:16,58720256:1073758224,75497472:1074282512,92274688:1073741824,109051904:524288,125829120:1074266128,142606336:524304,159383552:0,176160768:16384,192937984:1074266112,209715200:1073741840,226492416:540672,243269632:1074282496,260046848:16400,268435456:0,285212672:1074266128,301989888:1073758224,318767104:1074282496,335544320:1074266112,352321536:16,369098752:540688,385875968:16384,402653184:16400,419430400:524288,436207616:524304,452984832:1073741840,469762048:540672,486539264:1073758208,503316480:1073741824,520093696:1074282512,276824064:540688,293601280:524288,310378496:1074266112,327155712:16384,343932928:1073758208,360710144:1074282512,377487360:16,394264576:1073741824,411041792:1074282496,427819008:1073741840,444596224:1073758224,461373440:524304,478150656:0,494927872:16400,511705088:1074266128,528482304:540672},{0:260,1048576:0,2097152:67109120,3145728:65796,4194304:65540,5242880:67108868,6291456:67174660,7340032:67174400,8388608:67108864,9437184:67174656,10485760:65792,11534336:67174404,12582912:67109124,13631488:65536,14680064:4,15728640:256,524288:67174656,1572864:67174404,2621440:0,3670016:67109120,4718592:67108868,5767168:65536,6815744:65540,7864320:260,8912896:4,9961472:256,11010048:67174400,12058624:65796,13107200:65792,14155776:67109124,15204352:67174660,16252928:67108864,16777216:67174656,17825792:65540,18874368:65536,19922944:67109120,20971520:256,22020096:67174660,23068672:67108868,24117248:0,25165824:67109124,26214400:67108864,27262976:4,28311552:65792,29360128:67174400,30408704:260,31457280:65796,32505856:67174404,17301504:67108864,18350080:260,19398656:67174656,20447232:0,21495808:65540,22544384:67109120,23592960:256,24641536:67174404,25690112:65536,26738688:67174660,27787264:65796,28835840:67108868,29884416:67109124,30932992:67174400,31981568:4,33030144:65792},{0:2151682048,65536:2147487808,131072:4198464,196608:2151677952,262144:0,327680:4198400,393216:2147483712,458752:4194368,524288:2147483648,589824:4194304,655360:64,720896:2147487744,786432:2151678016,851968:4160,917504:4096,983040:2151682112,32768:2147487808,98304:64,163840:2151678016,229376:2147487744,294912:4198400,360448:2151682112,425984:0,491520:2151677952,557056:4096,622592:2151682048,688128:4194304,753664:4160,819200:2147483648,884736:4194368,950272:4198464,1015808:2147483712,1048576:4194368,1114112:4198400,1179648:2147483712,1245184:0,1310720:4160,1376256:2151678016,1441792:2151682048,1507328:2147487808,1572864:2151682112,1638400:2147483648,1703936:2151677952,1769472:4198464,1835008:2147487744,1900544:4194304,1966080:64,2031616:4096,1081344:2151677952,1146880:2151682112,1212416:0,1277952:4198400,1343488:4194368,1409024:2147483648,1474560:2147487808,1540096:64,1605632:2147483712,1671168:4096,1736704:2147487744,1802240:2151678016,1867776:4160,1933312:2151682048,1998848:4194304,2064384:4198464},{0:128,4096:17039360,8192:262144,12288:536870912,16384:537133184,20480:16777344,24576:553648256,28672:262272,32768:16777216,36864:537133056,40960:536871040,45056:553910400,49152:553910272,53248:0,57344:17039488,61440:553648128,2048:17039488,6144:553648256,10240:128,14336:17039360,18432:262144,22528:537133184,26624:553910272,30720:536870912,34816:537133056,38912:0,43008:553910400,47104:16777344,51200:536871040,55296:553648128,59392:16777216,63488:262272,65536:262144,69632:128,73728:536870912,77824:553648256,81920:16777344,86016:553910272,90112:537133184,94208:16777216,98304:553910400,102400:553648128,106496:17039360,110592:537133056,114688:262272,118784:536871040,122880:0,126976:17039488,67584:553648256,71680:16777216,75776:17039360,79872:537133184,83968:536870912,88064:17039488,92160:128,96256:553910272,100352:262272,104448:553910400,108544:0,112640:553648128,116736:16777344,120832:262144,124928:537133056,129024:536871040},{0:268435464,256:8192,512:270532608,768:270540808,1024:268443648,1280:2097152,1536:2097160,1792:268435456,2048:0,2304:268443656,2560:2105344,2816:8,3072:270532616,3328:2105352,3584:8200,3840:270540800,128:270532608,384:270540808,640:8,896:2097152,1152:2105352,1408:268435464,1664:268443648,1920:8200,2176:2097160,2432:8192,2688:268443656,2944:270532616,3200:0,3456:270540800,3712:2105344,3968:268435456,4096:268443648,4352:270532616,4608:270540808,4864:8200,5120:2097152,5376:268435456,5632:268435464,5888:2105344,6144:2105352,6400:0,6656:8,6912:270532608,7168:8192,7424:268443656,7680:270540800,7936:2097160,4224:8,4480:2105344,4736:2097152,4992:268435464,5248:268443648,5504:8200,5760:270540808,6016:270532608,6272:270540800,6528:270532616,6784:8192,7040:2105352,7296:2097160,7552:0,7808:268435456,8064:268443656},{0:1048576,16:33555457,32:1024,48:1049601,64:34604033,80:0,96:1,112:34603009,128:33555456,144:1048577,160:33554433,176:34604032,192:34603008,208:1025,224:1049600,240:33554432,8:34603009,24:0,40:33555457,56:34604032,72:1048576,88:33554433,104:33554432,120:1025,136:1049601,152:33555456,168:34603008,184:1048577,200:1024,216:34604033,232:1,248:1049600,256:33554432,272:1048576,288:33555457,304:34603009,320:1048577,336:33555456,352:34604032,368:1049601,384:1025,400:34604033,416:1049600,432:1,448:0,464:34603008,480:33554433,496:1024,264:1049600,280:33555457,296:34603009,312:1,328:33554432,344:1048576,360:1025,376:34604032,392:33554433,408:34603008,424:0,440:34604033,456:1049601,472:1024,488:33555456,504:1048577},{0:134219808,1:131072,2:134217728,3:32,4:131104,5:134350880,6:134350848,7:2048,8:134348800,9:134219776,10:133120,11:134348832,12:2080,13:0,14:134217760,15:133152,2147483648:2048,2147483649:134350880,2147483650:134219808,2147483651:134217728,2147483652:134348800,2147483653:133120,2147483654:133152,2147483655:32,2147483656:134217760,2147483657:2080,2147483658:131104,2147483659:134350848,2147483660:0,2147483661:134348832,2147483662:134219776,2147483663:131072,16:133152,17:134350848,18:32,19:2048,20:134219776,21:134217760,22:134348832,23:131072,24:0,25:131104,26:134348800,27:134219808,28:134350880,29:133120,30:2080,31:134217728,2147483664:131072,2147483665:2048,2147483666:134348832,2147483667:133152,2147483668:32,2147483669:134348800,2147483670:134217728,2147483671:134219808,2147483672:134350880,2147483673:134217760,2147483674:134219776,2147483675:0,2147483676:133120,2147483677:2080,2147483678:131104,2147483679:134350848}],h=[4160749569,528482304,33030144,2064384,129024,8064,504,2147483679],l=a.DES=r.extend({_doReset:function(){for(var y=this._key,b=y.words,w=[],k=0;k<56;k++){var T=o[k]-1;w[k]=b[T>>>5]>>>31-T%32&1}for(var O=this._subKeys=[],x=0;x<16;x++){for(var C=O[x]=[],E=c[x],k=0;k<24;k++)C[k/6|0]|=w[(d[k]-1+E)%28]<<31-k%6,C[4+(k/6|0)]|=w[28+(d[k+24]-1+E)%28]<<31-k%6;C[0]=C[0]<<1|C[0]>>>31;for(var k=1;k<7;k++)C[k]=C[k]>>>(k-1)*4+3;C[7]=C[7]<<5|C[7]>>>27}for(var P=this._invSubKeys=[],k=0;k<16;k++)P[k]=O[15-k]},encryptBlock:function(y,b){this._doCryptBlock(y,b,this._subKeys)},decryptBlock:function(y,b){this._doCryptBlock(y,b,this._invSubKeys)},_doCryptBlock:function(y,b,w){this._lBlock=y[b],this._rBlock=y[b+1],p.call(this,4,252645135),p.call(this,16,65535),m.call(this,2,858993459),m.call(this,8,16711935),p.call(this,1,1431655765);for(var k=0;k<16;k++){for(var T=w[k],O=this._lBlock,x=this._rBlock,C=0,E=0;E<8;E++)C|=u[E][((x^T[E])&h[E])>>>0];this._lBlock=x,this._rBlock=O^C}var P=this._lBlock;this._lBlock=this._rBlock,this._rBlock=P,p.call(this,1,1431655765),m.call(this,8,16711935),m.call(this,2,858993459),p.call(this,16,65535),p.call(this,4,252645135),y[b]=this._lBlock,y[b+1]=this._rBlock},keySize:64/32,ivSize:64/32,blockSize:64/32});function p(y,b){var w=(this._lBlock>>>y^this._rBlock)&b;this._rBlock^=w,this._lBlock^=w<<y}function m(y,b){var w=(this._rBlock>>>y^this._lBlock)&b;this._lBlock^=w,this._rBlock^=w<<y}s.DES=r._createHelper(l);var g=a.TripleDES=r.extend({_doReset:function(){var y=this._key,b=y.words;this._des1=l.createEncryptor(n.create(b.slice(0,2))),this._des2=l.createEncryptor(n.create(b.slice(2,4))),this._des3=l.createEncryptor(n.create(b.slice(4,6)))},encryptBlock:function(y,b){this._des1.encryptBlock(y,b),this._des2.decryptBlock(y,b),this._des3.encryptBlock(y,b)},decryptBlock:function(y,b){this._des3.decryptBlock(y,b),this._des2.encryptBlock(y,b),this._des1.decryptBlock(y,b)},keySize:192/32,ivSize:64/32,blockSize:64/32});s.TripleDES=r._createHelper(g)}(),function(){var s=t,i=s.lib,n=i.StreamCipher,r=s.algo,a=r.RC4=n.extend({_doReset:function(){for(var c=this._key,u=c.words,h=c.sigBytes,l=this._S=[],p=0;p<256;p++)l[p]=p;for(var p=0,m=0;p<256;p++){var g=p%h,y=u[g>>>2]>>>24-g%4*8&255;m=(m+l[p]+y)%256;var b=l[p];l[p]=l[m],l[m]=b}this._i=this._j=0},_doProcessBlock:function(c,u){c[u]^=o.call(this)},keySize:256/32,ivSize:0});function o(){for(var c=this._S,u=this._i,h=this._j,l=0,p=0;p<4;p++){u=(u+1)%256,h=(h+c[u])%256;var m=c[u];c[u]=c[h],c[h]=m,l|=c[(c[u]+c[h])%256]<<24-p*8}return this._i=u,this._j=h,l}s.RC4=n._createHelper(a);var d=r.RC4Drop=a.extend({cfg:a.cfg.extend({drop:192}),_doReset:function(){a._doReset.call(this);for(var c=this.cfg.drop;c>0;c--)o.call(this)}});s.RC4Drop=n._createHelper(d)}();/** @preserve
 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
 * derived from CryptoJS.mode.CTR
 * Jan Hruby jhruby.web@gmail.com
 */return t.mode.CTRGladman=function(){var s=t.lib.BlockCipherMode.extend();function i(a){if((a>>24&255)===255){var o=a>>16&255,d=a>>8&255,c=a&255;o===255?(o=0,d===255?(d=0,c===255?c=0:++c):++d):++o,a=0,a+=o<<16,a+=d<<8,a+=c}else a+=1<<24;return a}function n(a){return(a[0]=i(a[0]))===0&&(a[1]=i(a[1])),a}var r=s.Encryptor=s.extend({processBlock:function(a,o){var d=this._cipher,c=d.blockSize,u=this._iv,h=this._counter;u&&(h=this._counter=u.slice(0),this._iv=void 0),n(h);var l=h.slice(0);d.encryptBlock(l,0);for(var p=0;p<c;p++)a[o+p]^=l[p]}});return s.Decryptor=r,s}(),function(){var s=t,i=s.lib,n=i.StreamCipher,r=s.algo,a=[],o=[],d=[],c=r.Rabbit=n.extend({_doReset:function(){for(var h=this._key.words,l=this.cfg.iv,p=0;p<4;p++)h[p]=(h[p]<<8|h[p]>>>24)&16711935|(h[p]<<24|h[p]>>>8)&4278255360;var m=this._X=[h[0],h[3]<<16|h[2]>>>16,h[1],h[0]<<16|h[3]>>>16,h[2],h[1]<<16|h[0]>>>16,h[3],h[2]<<16|h[1]>>>16],g=this._C=[h[2]<<16|h[2]>>>16,h[0]&4294901760|h[1]&65535,h[3]<<16|h[3]>>>16,h[1]&4294901760|h[2]&65535,h[0]<<16|h[0]>>>16,h[2]&4294901760|h[3]&65535,h[1]<<16|h[1]>>>16,h[3]&4294901760|h[0]&65535];this._b=0;for(var p=0;p<4;p++)u.call(this);for(var p=0;p<8;p++)g[p]^=m[p+4&7];if(l){var y=l.words,b=y[0],w=y[1],k=(b<<8|b>>>24)&16711935|(b<<24|b>>>8)&4278255360,T=(w<<8|w>>>24)&16711935|(w<<24|w>>>8)&4278255360,O=k>>>16|T&4294901760,x=T<<16|k&65535;g[0]^=k,g[1]^=O,g[2]^=T,g[3]^=x,g[4]^=k,g[5]^=O,g[6]^=T,g[7]^=x;for(var p=0;p<4;p++)u.call(this)}},_doProcessBlock:function(h,l){var p=this._X;u.call(this),a[0]=p[0]^p[5]>>>16^p[3]<<16,a[1]=p[2]^p[7]>>>16^p[5]<<16,a[2]=p[4]^p[1]>>>16^p[7]<<16,a[3]=p[6]^p[3]>>>16^p[1]<<16;for(var m=0;m<4;m++)a[m]=(a[m]<<8|a[m]>>>24)&16711935|(a[m]<<24|a[m]>>>8)&4278255360,h[l+m]^=a[m]},blockSize:128/32,ivSize:64/32});function u(){for(var h=this._X,l=this._C,p=0;p<8;p++)o[p]=l[p];l[0]=l[0]+1295307597+this._b|0,l[1]=l[1]+3545052371+(l[0]>>>0<o[0]>>>0?1:0)|0,l[2]=l[2]+886263092+(l[1]>>>0<o[1]>>>0?1:0)|0,l[3]=l[3]+1295307597+(l[2]>>>0<o[2]>>>0?1:0)|0,l[4]=l[4]+3545052371+(l[3]>>>0<o[3]>>>0?1:0)|0,l[5]=l[5]+886263092+(l[4]>>>0<o[4]>>>0?1:0)|0,l[6]=l[6]+1295307597+(l[5]>>>0<o[5]>>>0?1:0)|0,l[7]=l[7]+3545052371+(l[6]>>>0<o[6]>>>0?1:0)|0,this._b=l[7]>>>0<o[7]>>>0?1:0;for(var p=0;p<8;p++){var m=h[p]+l[p],g=m&65535,y=m>>>16,b=((g*g>>>17)+g*y>>>15)+y*y,w=((m&4294901760)*m|0)+((m&65535)*m|0);d[p]=b^w}h[0]=d[0]+(d[7]<<16|d[7]>>>16)+(d[6]<<16|d[6]>>>16)|0,h[1]=d[1]+(d[0]<<8|d[0]>>>24)+d[7]|0,h[2]=d[2]+(d[1]<<16|d[1]>>>16)+(d[0]<<16|d[0]>>>16)|0,h[3]=d[3]+(d[2]<<8|d[2]>>>24)+d[1]|0,h[4]=d[4]+(d[3]<<16|d[3]>>>16)+(d[2]<<16|d[2]>>>16)|0,h[5]=d[5]+(d[4]<<8|d[4]>>>24)+d[3]|0,h[6]=d[6]+(d[5]<<16|d[5]>>>16)+(d[4]<<16|d[4]>>>16)|0,h[7]=d[7]+(d[6]<<8|d[6]>>>24)+d[5]|0}s.Rabbit=n._createHelper(c)}(),t.mode.CTR=function(){var s=t.lib.BlockCipherMode.extend(),i=s.Encryptor=s.extend({processBlock:function(n,r){var a=this._cipher,o=a.blockSize,d=this._iv,c=this._counter;d&&(c=this._counter=d.slice(0),this._iv=void 0);var u=c.slice(0);a.encryptBlock(u,0),c[o-1]=c[o-1]+1|0;for(var h=0;h<o;h++)n[r+h]^=u[h]}});return s.Decryptor=i,s}(),function(){var s=t,i=s.lib,n=i.StreamCipher,r=s.algo,a=[],o=[],d=[],c=r.RabbitLegacy=n.extend({_doReset:function(){var h=this._key.words,l=this.cfg.iv,p=this._X=[h[0],h[3]<<16|h[2]>>>16,h[1],h[0]<<16|h[3]>>>16,h[2],h[1]<<16|h[0]>>>16,h[3],h[2]<<16|h[1]>>>16],m=this._C=[h[2]<<16|h[2]>>>16,h[0]&4294901760|h[1]&65535,h[3]<<16|h[3]>>>16,h[1]&4294901760|h[2]&65535,h[0]<<16|h[0]>>>16,h[2]&4294901760|h[3]&65535,h[1]<<16|h[1]>>>16,h[3]&4294901760|h[0]&65535];this._b=0;for(var g=0;g<4;g++)u.call(this);for(var g=0;g<8;g++)m[g]^=p[g+4&7];if(l){var y=l.words,b=y[0],w=y[1],k=(b<<8|b>>>24)&16711935|(b<<24|b>>>8)&4278255360,T=(w<<8|w>>>24)&16711935|(w<<24|w>>>8)&4278255360,O=k>>>16|T&4294901760,x=T<<16|k&65535;m[0]^=k,m[1]^=O,m[2]^=T,m[3]^=x,m[4]^=k,m[5]^=O,m[6]^=T,m[7]^=x;for(var g=0;g<4;g++)u.call(this)}},_doProcessBlock:function(h,l){var p=this._X;u.call(this),a[0]=p[0]^p[5]>>>16^p[3]<<16,a[1]=p[2]^p[7]>>>16^p[5]<<16,a[2]=p[4]^p[1]>>>16^p[7]<<16,a[3]=p[6]^p[3]>>>16^p[1]<<16;for(var m=0;m<4;m++)a[m]=(a[m]<<8|a[m]>>>24)&16711935|(a[m]<<24|a[m]>>>8)&4278255360,h[l+m]^=a[m]},blockSize:128/32,ivSize:64/32});function u(){for(var h=this._X,l=this._C,p=0;p<8;p++)o[p]=l[p];l[0]=l[0]+1295307597+this._b|0,l[1]=l[1]+3545052371+(l[0]>>>0<o[0]>>>0?1:0)|0,l[2]=l[2]+886263092+(l[1]>>>0<o[1]>>>0?1:0)|0,l[3]=l[3]+1295307597+(l[2]>>>0<o[2]>>>0?1:0)|0,l[4]=l[4]+3545052371+(l[3]>>>0<o[3]>>>0?1:0)|0,l[5]=l[5]+886263092+(l[4]>>>0<o[4]>>>0?1:0)|0,l[6]=l[6]+1295307597+(l[5]>>>0<o[5]>>>0?1:0)|0,l[7]=l[7]+3545052371+(l[6]>>>0<o[6]>>>0?1:0)|0,this._b=l[7]>>>0<o[7]>>>0?1:0;for(var p=0;p<8;p++){var m=h[p]+l[p],g=m&65535,y=m>>>16,b=((g*g>>>17)+g*y>>>15)+y*y,w=((m&4294901760)*m|0)+((m&65535)*m|0);d[p]=b^w}h[0]=d[0]+(d[7]<<16|d[7]>>>16)+(d[6]<<16|d[6]>>>16)|0,h[1]=d[1]+(d[0]<<8|d[0]>>>24)+d[7]|0,h[2]=d[2]+(d[1]<<16|d[1]>>>16)+(d[0]<<16|d[0]>>>16)|0,h[3]=d[3]+(d[2]<<8|d[2]>>>24)+d[1]|0,h[4]=d[4]+(d[3]<<16|d[3]>>>16)+(d[2]<<16|d[2]>>>16)|0,h[5]=d[5]+(d[4]<<8|d[4]>>>24)+d[3]|0,h[6]=d[6]+(d[5]<<16|d[5]>>>16)+(d[4]<<16|d[4]>>>16)|0,h[7]=d[7]+(d[6]<<8|d[6]>>>24)+d[5]|0}s.RabbitLegacy=n._createHelper(c)}(),t.pad.ZeroPadding={pad:function(s,i){var n=i*4;s.clamp(),s.sigBytes+=n-(s.sigBytes%n||n)},unpad:function(s){for(var i=s.words,n=s.sigBytes-1;!(i[n>>>2]>>>24-n%4*8&255);)n--;s.sigBytes=n+1}},t})})(Bd);var Vp=Object.prototype.hasOwnProperty,od=Array.isArray,Rn=function(){for(var f=[],e=0;e<256;++e)f.push("%"+((e<16?"0":"")+e.toString(16)).toUpperCase());return f}(),nE=function(e){for(;e.length>1;){var t=e.pop(),s=t.obj[t.prop];if(od(s)){for(var i=[],n=0;n<s.length;++n)typeof s[n]<"u"&&i.push(s[n]);t.obj[t.prop]=i}}},Qx=function(e,t){for(var s=t&&t.plainObjects?Object.create(null):{},i=0;i<e.length;++i)typeof e[i]<"u"&&(s[i]=e[i]);return s},rE=function f(e,t,s){if(!t)return e;if(typeof t!="object"){if(od(e))e.push(t);else if(e&&typeof e=="object")(s&&(s.plainObjects||s.allowPrototypes)||!Vp.call(Object.prototype,t))&&(e[t]=!0);else return[e,t];return e}if(!e||typeof e!="object")return[e].concat(t);var i=e;return od(e)&&!od(t)&&(i=Qx(e,s)),od(e)&&od(t)?(t.forEach(function(n,r){if(Vp.call(e,r)){var a=e[r];a&&typeof a=="object"&&n&&typeof n=="object"?e[r]=f(a,n,s):e.push(n)}else e[r]=n}),e):Object.keys(t).reduce(function(n,r){var a=t[r];return Vp.call(n,r)?n[r]=f(n[r],a,s):n[r]=a,n},i)},aE=function(e,t){return Object.keys(t).reduce(function(s,i){return s[i]=t[i],s},e)},oE=function(f,e,t){var s=f.replace(/\+/g," ");if(t==="iso-8859-1")return s.replace(/%[0-9a-f]{2}/gi,unescape);try{return decodeURIComponent(s)}catch{return s}},dE=function(e,t,s){if(e.length===0)return e;var i=typeof e=="string"?e:String(e);if(s==="iso-8859-1")return escape(i).replace(/%u[0-9a-f]{4}/gi,function(o){return"%26%23"+parseInt(o.slice(2),16)+"%3B"});for(var n="",r=0;r<i.length;++r){var a=i.charCodeAt(r);if(a===45||a===46||a===95||a===126||a>=48&&a<=57||a>=65&&a<=90||a>=97&&a<=122){n+=i.charAt(r);continue}if(a<128){n=n+Rn[a];continue}if(a<2048){n=n+(Rn[192|a>>6]+Rn[128|a&63]);continue}if(a<55296||a>=57344){n=n+(Rn[224|a>>12]+Rn[128|a>>6&63]+Rn[128|a&63]);continue}r+=1,a=65536+((a&1023)<<10|i.charCodeAt(r)&1023),n+=Rn[240|a>>18]+Rn[128|a>>12&63]+Rn[128|a>>6&63]+Rn[128|a&63]}return n},cE=function(e){for(var t=[{obj:{o:e},prop:"o"}],s=[],i=0;i<t.length;++i)for(var n=t[i],r=n.obj[n.prop],a=Object.keys(r),o=0;o<a.length;++o){var d=a[o],c=r[d];typeof c=="object"&&c!==null&&s.indexOf(c)===-1&&(t.push({obj:r,prop:d}),s.push(c))}return nE(t),e},uE=function(e){return Object.prototype.toString.call(e)==="[object RegExp]"},fE=function(e){return!e||typeof e!="object"?!1:!!(e.constructor&&e.constructor.isBuffer&&e.constructor.isBuffer(e))},hE=function(e,t){return[].concat(e,t)},Zx={arrayToObject:Qx,assign:aE,combine:hE,compact:cE,decode:oE,encode:dE,isBuffer:fE,isRegExp:uE,merge:rE},lE=String.prototype.replace,pE=/%20/g,Jx={default:"RFC3986",formatters:{RFC1738:function(f){return lE.call(f,pE,"+")},RFC3986:function(f){return f}},RFC1738:"RFC1738",RFC3986:"RFC3986"},e_=Zx,mu=Jx,mE=Object.prototype.hasOwnProperty,u1={brackets:function(e){return e+"[]"},comma:"comma",indices:function(e,t){return e+"["+t+"]"},repeat:function(e){return e}},md=Array.isArray,gE=Array.prototype.push,py=function(f,e){gE.apply(f,md(e)?e:[e])},yE=Date.prototype.toISOString,Js={addQueryPrefix:!1,allowDots:!1,charset:"utf-8",charsetSentinel:!1,delimiter:"&",encode:!0,encoder:e_.encode,encodeValuesOnly:!1,formatter:mu.formatters[mu.default],indices:!1,serializeDate:function(e){return yE.call(e)},skipNulls:!1,strictNullHandling:!1},bE=function f(e,t,s,i,n,r,a,o,d,c,u,h,l){var p=e;if(typeof a=="function"?p=a(t,p):p instanceof Date?p=c(p):s==="comma"&&md(p)&&(p=p.join(",")),p===null){if(i)return r&&!h?r(t,Js.encoder,l):t;p=""}if(typeof p=="string"||typeof p=="number"||typeof p=="boolean"||e_.isBuffer(p)){if(r){var m=h?t:r(t,Js.encoder,l);return[u(m)+"="+u(r(p,Js.encoder,l))]}return[u(t)+"="+u(String(p))]}var g=[];if(typeof p>"u")return g;var y;if(md(a))y=a;else{var b=Object.keys(p);y=o?b.sort(o):b}for(var w=0;w<y.length;++w){var k=y[w];n&&p[k]===null||(md(p)?py(g,f(p[k],typeof s=="function"?s(t,k):t,s,i,n,r,a,o,d,c,u,h,l)):py(g,f(p[k],t+(d?"."+k:"["+k+"]"),s,i,n,r,a,o,d,c,u,h,l)))}return g},wE=function(e){if(!e)return Js;if(e.encoder!==null&&e.encoder!==void 0&&typeof e.encoder!="function")throw new TypeError("Encoder has to be a function.");var t=e.charset||Js.charset;if(typeof e.charset<"u"&&e.charset!=="utf-8"&&e.charset!=="iso-8859-1")throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");var s=mu.default;if(typeof e.format<"u"){if(!mE.call(mu.formatters,e.format))throw new TypeError("Unknown format option provided.");s=e.format}var i=mu.formatters[s],n=Js.filter;return(typeof e.filter=="function"||md(e.filter))&&(n=e.filter),{addQueryPrefix:typeof e.addQueryPrefix=="boolean"?e.addQueryPrefix:Js.addQueryPrefix,allowDots:typeof e.allowDots>"u"?Js.allowDots:!!e.allowDots,charset:t,charsetSentinel:typeof e.charsetSentinel=="boolean"?e.charsetSentinel:Js.charsetSentinel,delimiter:typeof e.delimiter>"u"?Js.delimiter:e.delimiter,encode:typeof e.encode=="boolean"?e.encode:Js.encode,encoder:typeof e.encoder=="function"?e.encoder:Js.encoder,encodeValuesOnly:typeof e.encodeValuesOnly=="boolean"?e.encodeValuesOnly:Js.encodeValuesOnly,filter:n,formatter:i,serializeDate:typeof e.serializeDate=="function"?e.serializeDate:Js.serializeDate,skipNulls:typeof e.skipNulls=="boolean"?e.skipNulls:Js.skipNulls,sort:typeof e.sort=="function"?e.sort:null,strictNullHandling:typeof e.strictNullHandling=="boolean"?e.strictNullHandling:Js.strictNullHandling}},kE=function(f,e){var t=f,s=wE(e),i,n;typeof s.filter=="function"?(n=s.filter,t=n("",t)):md(s.filter)&&(n=s.filter,i=n);var r=[];if(typeof t!="object"||t===null)return"";var a;e&&e.arrayFormat in u1?a=e.arrayFormat:e&&"indices"in e?a=e.indices?"indices":"repeat":a="indices";var o=u1[a];i||(i=Object.keys(t)),s.sort&&i.sort(s.sort);for(var d=0;d<i.length;++d){var c=i[d];s.skipNulls&&t[c]===null||py(r,bE(t[c],c,o,s.strictNullHandling,s.skipNulls,s.encode?s.encoder:null,s.filter,s.sort,s.allowDots,s.serializeDate,s.formatter,s.encodeValuesOnly,s.charset))}var u=r.join(s.delimiter),h=s.addQueryPrefix===!0?"?":"";return s.charsetSentinel&&(s.charset==="iso-8859-1"?h+="utf8=%26%2310003%3B&":h+="utf8=%E2%9C%93&"),u.length>0?h+u:""},_u=Zx,my=Object.prototype.hasOwnProperty,Ws={allowDots:!1,allowPrototypes:!1,arrayLimit:20,charset:"utf-8",charsetSentinel:!1,comma:!1,decoder:_u.decode,delimiter:"&",depth:5,ignoreQueryPrefix:!1,interpretNumericEntities:!1,parameterLimit:1e3,parseArrays:!0,plainObjects:!1,strictNullHandling:!1},SE=function(f){return f.replace(/&#(\d+);/g,function(e,t){return String.fromCharCode(parseInt(t,10))})},vE="utf8=%26%2310003%3B",TE="utf8=%E2%9C%93",OE=function(e,t){var s={},i=t.ignoreQueryPrefix?e.replace(/^\?/,""):e,n=t.parameterLimit===1/0?void 0:t.parameterLimit,r=i.split(t.delimiter,n),a=-1,o,d=t.charset;if(t.charsetSentinel)for(o=0;o<r.length;++o)r[o].indexOf("utf8=")===0&&(r[o]===TE?d="utf-8":r[o]===vE&&(d="iso-8859-1"),a=o,o=r.length);for(o=0;o<r.length;++o)if(o!==a){var c=r[o],u=c.indexOf("]="),h=u===-1?c.indexOf("="):u+1,l,p;h===-1?(l=t.decoder(c,Ws.decoder,d),p=t.strictNullHandling?null:""):(l=t.decoder(c.slice(0,h),Ws.decoder,d),p=t.decoder(c.slice(h+1),Ws.decoder,d)),p&&t.interpretNumericEntities&&d==="iso-8859-1"&&(p=SE(p)),p&&t.comma&&p.indexOf(",")>-1&&(p=p.split(",")),my.call(s,l)?s[l]=_u.combine(s[l],p):s[l]=p}return s},IE=function(f,e,t){for(var s=e,i=f.length-1;i>=0;--i){var n,r=f[i];if(r==="[]"&&t.parseArrays)n=[].concat(s);else{n=t.plainObjects?Object.create(null):{};var a=r.charAt(0)==="["&&r.charAt(r.length-1)==="]"?r.slice(1,-1):r,o=parseInt(a,10);!t.parseArrays&&a===""?n={0:s}:!isNaN(o)&&r!==a&&String(o)===a&&o>=0&&t.parseArrays&&o<=t.arrayLimit?(n=[],n[o]=s):n[a]=s}s=n}return s},xE=function(e,t,s){if(!!e){var i=s.allowDots?e.replace(/\.([^.[]+)/g,"[$1]"):e,n=/(\[[^[\]]*])/,r=/(\[[^[\]]*])/g,a=n.exec(i),o=a?i.slice(0,a.index):i,d=[];if(o){if(!s.plainObjects&&my.call(Object.prototype,o)&&!s.allowPrototypes)return;d.push(o)}for(var c=0;(a=r.exec(i))!==null&&c<s.depth;){if(c+=1,!s.plainObjects&&my.call(Object.prototype,a[1].slice(1,-1))&&!s.allowPrototypes)return;d.push(a[1])}return a&&d.push("["+i.slice(a.index)+"]"),IE(d,t,s)}},_E=function(e){if(!e)return Ws;if(e.decoder!==null&&e.decoder!==void 0&&typeof e.decoder!="function")throw new TypeError("Decoder has to be a function.");if(typeof e.charset<"u"&&e.charset!=="utf-8"&&e.charset!=="iso-8859-1")throw new Error("The charset option must be either utf-8, iso-8859-1, or undefined");var t=typeof e.charset>"u"?Ws.charset:e.charset;return{allowDots:typeof e.allowDots>"u"?Ws.allowDots:!!e.allowDots,allowPrototypes:typeof e.allowPrototypes=="boolean"?e.allowPrototypes:Ws.allowPrototypes,arrayLimit:typeof e.arrayLimit=="number"?e.arrayLimit:Ws.arrayLimit,charset:t,charsetSentinel:typeof e.charsetSentinel=="boolean"?e.charsetSentinel:Ws.charsetSentinel,comma:typeof e.comma=="boolean"?e.comma:Ws.comma,decoder:typeof e.decoder=="function"?e.decoder:Ws.decoder,delimiter:typeof e.delimiter=="string"||_u.isRegExp(e.delimiter)?e.delimiter:Ws.delimiter,depth:typeof e.depth=="number"?e.depth:Ws.depth,ignoreQueryPrefix:e.ignoreQueryPrefix===!0,interpretNumericEntities:typeof e.interpretNumericEntities=="boolean"?e.interpretNumericEntities:Ws.interpretNumericEntities,parameterLimit:typeof e.parameterLimit=="number"?e.parameterLimit:Ws.parameterLimit,parseArrays:e.parseArrays!==!1,plainObjects:typeof e.plainObjects=="boolean"?e.plainObjects:Ws.plainObjects,strictNullHandling:typeof e.strictNullHandling=="boolean"?e.strictNullHandling:Ws.strictNullHandling}},CE=function(f,e){var t=_E(e);if(f===""||f===null||typeof f>"u")return t.plainObjects?Object.create(null):{};for(var s=typeof f=="string"?OE(f,t):f,i=t.plainObjects?Object.create(null):{},n=Object.keys(s),r=0;r<n.length;++r){var a=n[r],o=xE(a,s[a],t);i=_u.merge(i,o,t)}return _u.compact(i)},ME=kE,PE=CE,AE=Jx,BE={formats:AE,parse:PE,stringify:ME},Ui={exports:{}};(function(f){(function(e,t){function s(_,S){if(!_)throw new Error(S||"Assertion failed")}function i(_,S){_.super_=S;var I=function(){};I.prototype=S.prototype,_.prototype=new I,_.prototype.constructor=_}function n(_,S,I){if(n.isBN(_))return _;this.negative=0,this.words=null,this.length=0,this.red=null,_!==null&&((S==="le"||S==="be")&&(I=S,S=10),this._init(_||0,S||10,I||"be"))}typeof e=="object"?e.exports=n:t.BN=n,n.BN=n,n.wordSize=26;var r;try{r=pl.Buffer}catch{}n.isBN=function(S){return S instanceof n?!0:S!==null&&typeof S=="object"&&S.constructor.wordSize===n.wordSize&&Array.isArray(S.words)},n.max=function(S,I){return S.cmp(I)>0?S:I},n.min=function(S,I){return S.cmp(I)<0?S:I},n.prototype._init=function(S,I,v){if(typeof S=="number")return this._initNumber(S,I,v);if(typeof S=="object")return this._initArray(S,I,v);I==="hex"&&(I=16),s(I===(I|0)&&I>=2&&I<=36),S=S.toString().replace(/\s+/g,"");var N=0;S[0]==="-"&&N++,I===16?this._parseHex(S,N):this._parseBase(S,I,N),S[0]==="-"&&(this.negative=1),this._strip(),v==="le"&&this._initArray(this.toArray(),I,v)},n.prototype._initNumber=function(S,I,v){S<0&&(this.negative=1,S=-S),S<67108864?(this.words=[S&67108863],this.length=1):S<4503599627370496?(this.words=[S&67108863,S/67108864&67108863],this.length=2):(s(S<9007199254740992),this.words=[S&67108863,S/67108864&67108863,1],this.length=3),v==="le"&&this._initArray(this.toArray(),I,v)},n.prototype._initArray=function(S,I,v){if(s(typeof S.length=="number"),S.length<=0)return this.words=[0],this.length=1,this;this.length=Math.ceil(S.length/3),this.words=new Array(this.length);for(var N=0;N<this.length;N++)this.words[N]=0;var q,R,G=0;if(v==="be")for(N=S.length-1,q=0;N>=0;N-=3)R=S[N]|S[N-1]<<8|S[N-2]<<16,this.words[q]|=R<<G&67108863,this.words[q+1]=R>>>26-G&67108863,G+=24,G>=26&&(G-=26,q++);else if(v==="le")for(N=0,q=0;N<S.length;N+=3)R=S[N]|S[N+1]<<8|S[N+2]<<16,this.words[q]|=R<<G&67108863,this.words[q+1]=R>>>26-G&67108863,G+=24,G>=26&&(G-=26,q++);return this._strip()};function a(_,S,I){for(var v=0,N=Math.min(_.length,I),q=0,R=S;R<N;R++){var G=_.charCodeAt(R)-48;v<<=4;var F;G>=49&&G<=54?F=G-49+10:G>=17&&G<=22?F=G-17+10:F=G,v|=F,q|=F}return s(!(q&240),"Invalid character in "+_),v}n.prototype._parseHex=function(S,I){this.length=Math.ceil((S.length-I)/6),this.words=new Array(this.length);for(var v=0;v<this.length;v++)this.words[v]=0;var N,q,R=0;for(v=S.length-6,N=0;v>=I;v-=6)q=a(S,v,v+6),this.words[N]|=q<<R&67108863,this.words[N+1]|=q>>>26-R&4194303,R+=24,R>=26&&(R-=26,N++);v+6!==I&&(q=a(S,I,v+6),this.words[N]|=q<<R&67108863,this.words[N+1]|=q>>>26-R&4194303),this._strip()};function o(_,S,I,v){for(var N=0,q=0,R=Math.min(_.length,I),G=S;G<R;G++){var F=_.charCodeAt(G)-48;N*=v,F>=49?q=F-49+10:F>=17?q=F-17+10:q=F,s(F>=0&&q<v,"Invalid character"),N+=q}return N}n.prototype._parseBase=function(S,I,v){this.words=[0],this.length=1;for(var N=0,q=1;q<=67108863;q*=I)N++;N--,q=q/I|0;for(var R=S.length-v,G=R%N,F=Math.min(R,R-G)+v,A=0,V=v;V<F;V+=N)A=o(S,V,V+N,I),this.imuln(q),this.words[0]+A<67108864?this.words[0]+=A:this._iaddn(A);if(G!==0){var Q=1;for(A=o(S,V,S.length,I),V=0;V<G;V++)Q*=I;this.imuln(Q),this.words[0]+A<67108864?this.words[0]+=A:this._iaddn(A)}},n.prototype.copy=function(S){S.words=new Array(this.length);for(var I=0;I<this.length;I++)S.words[I]=this.words[I];S.length=this.length,S.negative=this.negative,S.red=this.red},n.prototype._move=function(S){S.words=this.words,S.length=this.length,S.negative=this.negative,S.red=this.red},n.prototype.clone=function(){var S=new n(null);return this.copy(S),S},n.prototype._expand=function(S){for(;this.length<S;)this.words[this.length++]=0;return this},n.prototype._strip=function(){for(;this.length>1&&this.words[this.length-1]===0;)this.length--;return this._normSign()},n.prototype._normSign=function(){return this.length===1&&this.words[0]===0&&(this.negative=0),this},typeof Symbol<"u"&&typeof Symbol.for=="function"?n.prototype[Symbol.for("nodejs.util.inspect.custom")]=d:n.prototype.inspect=d;function d(){return(this.red?"<BN-R: ":"<BN: ")+this.toString(16)+">"}var c=["","0","00","000","0000","00000","000000","0000000","00000000","000000000","0000000000","00000000000","000000000000","0000000000000","00000000000000","000000000000000","0000000000000000","00000000000000000","000000000000000000","0000000000000000000","00000000000000000000","000000000000000000000","0000000000000000000000","00000000000000000000000","000000000000000000000000","0000000000000000000000000"],u=[0,0,25,16,12,11,10,9,8,8,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],h=[0,0,33554432,43046721,16777216,48828125,60466176,40353607,16777216,43046721,1e7,19487171,35831808,62748517,7529536,11390625,16777216,24137569,34012224,47045881,64e6,4084101,5153632,6436343,7962624,9765625,11881376,14348907,17210368,20511149,243e5,28629151,33554432,39135393,45435424,52521875,60466176];n.prototype.toString=function(S,I){S=S||10,I=I|0||1;var v;if(S===16||S==="hex"){v="";for(var N=0,q=0,R=0;R<this.length;R++){var G=this.words[R],F=((G<<N|q)&16777215).toString(16);q=G>>>24-N&16777215,q!==0||R!==this.length-1?v=c[6-F.length]+F+v:v=F+v,N+=2,N>=26&&(N-=26,R--)}for(q!==0&&(v=q.toString(16)+v);v.length%I!==0;)v="0"+v;return this.negative!==0&&(v="-"+v),v}if(S===(S|0)&&S>=2&&S<=36){var A=u[S],V=h[S];v="";var Q=this.clone();for(Q.negative=0;!Q.isZero();){var J=Q.modrn(V).toString(S);Q=Q.idivn(V),Q.isZero()?v=J+v:v=c[A-J.length]+J+v}for(this.isZero()&&(v="0"+v);v.length%I!==0;)v="0"+v;return this.negative!==0&&(v="-"+v),v}s(!1,"Base should be between 2 and 36")},n.prototype.toNumber=function(){var S=this.words[0];return this.length===2?S+=this.words[1]*67108864:this.length===3&&this.words[2]===1?S+=4503599627370496+this.words[1]*67108864:this.length>2&&s(!1,"Number can only safely store up to 53 bits"),this.negative!==0?-S:S},n.prototype.toJSON=function(){return this.toString(16,2)},r&&(n.prototype.toBuffer=function(S,I){return this.toArrayLike(r,S,I)}),n.prototype.toArray=function(S,I){return this.toArrayLike(Array,S,I)};var l=function(S,I){return S.allocUnsafe?S.allocUnsafe(I):new S(I)};n.prototype.toArrayLike=function(S,I,v){this._strip();var N=this.byteLength(),q=v||Math.max(1,N);s(N<=q,"byte array longer than desired length"),s(q>0,"Requested array length <= 0");var R=l(S,q),G=I==="le"?"LE":"BE";return this["_toArrayLike"+G](R,N),R},n.prototype._toArrayLikeLE=function(S,I){for(var v=0,N=0,q=0,R=0;q<this.length;q++){var G=this.words[q]<<R|N;S[v++]=G&255,v<S.length&&(S[v++]=G>>8&255),v<S.length&&(S[v++]=G>>16&255),R===6?(v<S.length&&(S[v++]=G>>24&255),N=0,R=0):(N=G>>>24,R+=2)}if(v<S.length)for(S[v++]=N;v<S.length;)S[v++]=0},n.prototype._toArrayLikeBE=function(S,I){for(var v=S.length-1,N=0,q=0,R=0;q<this.length;q++){var G=this.words[q]<<R|N;S[v--]=G&255,v>=0&&(S[v--]=G>>8&255),v>=0&&(S[v--]=G>>16&255),R===6?(v>=0&&(S[v--]=G>>24&255),N=0,R=0):(N=G>>>24,R+=2)}if(v>=0)for(S[v--]=N;v>=0;)S[v--]=0},Math.clz32?n.prototype._countBits=function(S){return 32-Math.clz32(S)}:n.prototype._countBits=function(S){var I=S,v=0;return I>=4096&&(v+=13,I>>>=13),I>=64&&(v+=7,I>>>=7),I>=8&&(v+=4,I>>>=4),I>=2&&(v+=2,I>>>=2),v+I},n.prototype._zeroBits=function(S){if(S===0)return 26;var I=S,v=0;return(I&8191)===0&&(v+=13,I>>>=13),(I&127)===0&&(v+=7,I>>>=7),(I&15)===0&&(v+=4,I>>>=4),(I&3)===0&&(v+=2,I>>>=2),(I&1)===0&&v++,v},n.prototype.bitLength=function(){var S=this.words[this.length-1],I=this._countBits(S);return(this.length-1)*26+I};function p(_){for(var S=new Array(_.bitLength()),I=0;I<S.length;I++){var v=I/26|0,N=I%26;S[I]=_.words[v]>>>N&1}return S}n.prototype.zeroBits=function(){if(this.isZero())return 0;for(var S=0,I=0;I<this.length;I++){var v=this._zeroBits(this.words[I]);if(S+=v,v!==26)break}return S},n.prototype.byteLength=function(){return Math.ceil(this.bitLength()/8)},n.prototype.toTwos=function(S){return this.negative!==0?this.abs().inotn(S).iaddn(1):this.clone()},n.prototype.fromTwos=function(S){return this.testn(S-1)?this.notn(S).iaddn(1).ineg():this.clone()},n.prototype.isNeg=function(){return this.negative!==0},n.prototype.neg=function(){return this.clone().ineg()},n.prototype.ineg=function(){return this.isZero()||(this.negative^=1),this},n.prototype.iuor=function(S){for(;this.length<S.length;)this.words[this.length++]=0;for(var I=0;I<S.length;I++)this.words[I]=this.words[I]|S.words[I];return this._strip()},n.prototype.ior=function(S){return s((this.negative|S.negative)===0),this.iuor(S)},n.prototype.or=function(S){return this.length>S.length?this.clone().ior(S):S.clone().ior(this)},n.prototype.uor=function(S){return this.length>S.length?this.clone().iuor(S):S.clone().iuor(this)},n.prototype.iuand=function(S){var I;this.length>S.length?I=S:I=this;for(var v=0;v<I.length;v++)this.words[v]=this.words[v]&S.words[v];return this.length=I.length,this._strip()},n.prototype.iand=function(S){return s((this.negative|S.negative)===0),this.iuand(S)},n.prototype.and=function(S){return this.length>S.length?this.clone().iand(S):S.clone().iand(this)},n.prototype.uand=function(S){return this.length>S.length?this.clone().iuand(S):S.clone().iuand(this)},n.prototype.iuxor=function(S){var I,v;this.length>S.length?(I=this,v=S):(I=S,v=this);for(var N=0;N<v.length;N++)this.words[N]=I.words[N]^v.words[N];if(this!==I)for(;N<I.length;N++)this.words[N]=I.words[N];return this.length=I.length,this._strip()},n.prototype.ixor=function(S){return s((this.negative|S.negative)===0),this.iuxor(S)},n.prototype.xor=function(S){return this.length>S.length?this.clone().ixor(S):S.clone().ixor(this)},n.prototype.uxor=function(S){return this.length>S.length?this.clone().iuxor(S):S.clone().iuxor(this)},n.prototype.inotn=function(S){s(typeof S=="number"&&S>=0);var I=Math.ceil(S/26)|0,v=S%26;this._expand(I),v>0&&I--;for(var N=0;N<I;N++)this.words[N]=~this.words[N]&67108863;return v>0&&(this.words[N]=~this.words[N]&67108863>>26-v),this._strip()},n.prototype.notn=function(S){return this.clone().inotn(S)},n.prototype.setn=function(S,I){s(typeof S=="number"&&S>=0);var v=S/26|0,N=S%26;return this._expand(v+1),I?this.words[v]=this.words[v]|1<<N:this.words[v]=this.words[v]&~(1<<N),this._strip()},n.prototype.iadd=function(S){var I;if(this.negative!==0&&S.negative===0)return this.negative=0,I=this.isub(S),this.negative^=1,this._normSign();if(this.negative===0&&S.negative!==0)return S.negative=0,I=this.isub(S),S.negative=1,I._normSign();var v,N;this.length>S.length?(v=this,N=S):(v=S,N=this);for(var q=0,R=0;R<N.length;R++)I=(v.words[R]|0)+(N.words[R]|0)+q,this.words[R]=I&67108863,q=I>>>26;for(;q!==0&&R<v.length;R++)I=(v.words[R]|0)+q,this.words[R]=I&67108863,q=I>>>26;if(this.length=v.length,q!==0)this.words[this.length]=q,this.length++;else if(v!==this)for(;R<v.length;R++)this.words[R]=v.words[R];return this},n.prototype.add=function(S){var I;return S.negative!==0&&this.negative===0?(S.negative=0,I=this.sub(S),S.negative^=1,I):S.negative===0&&this.negative!==0?(this.negative=0,I=S.sub(this),this.negative=1,I):this.length>S.length?this.clone().iadd(S):S.clone().iadd(this)},n.prototype.isub=function(S){if(S.negative!==0){S.negative=0;var I=this.iadd(S);return S.negative=1,I._normSign()}else if(this.negative!==0)return this.negative=0,this.iadd(S),this.negative=1,this._normSign();var v=this.cmp(S);if(v===0)return this.negative=0,this.length=1,this.words[0]=0,this;var N,q;v>0?(N=this,q=S):(N=S,q=this);for(var R=0,G=0;G<q.length;G++)I=(N.words[G]|0)-(q.words[G]|0)+R,R=I>>26,this.words[G]=I&67108863;for(;R!==0&&G<N.length;G++)I=(N.words[G]|0)+R,R=I>>26,this.words[G]=I&67108863;if(R===0&&G<N.length&&N!==this)for(;G<N.length;G++)this.words[G]=N.words[G];return this.length=Math.max(this.length,G),N!==this&&(this.negative=1),this._strip()},n.prototype.sub=function(S){return this.clone().isub(S)};function m(_,S,I){I.negative=S.negative^_.negative;var v=_.length+S.length|0;I.length=v,v=v-1|0;var N=_.words[0]|0,q=S.words[0]|0,R=N*q,G=R&67108863,F=R/67108864|0;I.words[0]=G;for(var A=1;A<v;A++){for(var V=F>>>26,Q=F&67108863,J=Math.min(A,S.length-1),se=Math.max(0,A-_.length+1);se<=J;se++){var we=A-se|0;N=_.words[we]|0,q=S.words[se]|0,R=N*q+Q,V+=R/67108864|0,Q=R&67108863}I.words[A]=Q|0,F=V|0}return F!==0?I.words[A]=F|0:I.length--,I._strip()}var g=function(S,I,v){var N=S.words,q=I.words,R=v.words,G=0,F,A,V,Q=N[0]|0,J=Q&8191,se=Q>>>13,we=N[1]|0,le=we&8191,Oe=we>>>13,Ce=N[2]|0,Le=Ce&8191,Fe=Ce>>>13,At=N[3]|0,D=At&8191,j=At>>>13,U=N[4]|0,H=U&8191,W=U>>>13,Y=N[5]|0,z=Y&8191,X=Y>>>13,ne=N[6]|0,te=ne&8191,ce=ne>>>13,ke=N[7]|0,ue=ke&8191,Ie=ke>>>13,Pe=N[8]|0,L=Pe&8191,M=Pe>>>13,B=N[9]|0,K=B&8191,Z=B>>>13,re=q[0]|0,ae=re&8191,Ee=re>>>13,We=q[1]|0,Ne=We&8191,De=We>>>13,ut=q[2]|0,Jt=ut&8191,Dt=ut>>>13,zu=q[3]|0,Ht=zu&8191,es=zu>>>13,Ku=q[4]|0,ts=Ku&8191,Gt=Ku>>>13,Xu=q[5]|0,ss=Xu&8191,Ut=Xu>>>13,Yu=q[6]|0,$t=Yu&8191,dt=Yu>>>13,bn=q[7]|0,jt=bn&8191,is=bn>>>13,dw=q[8]|0,ys=dw&8191,bs=dw>>>13,cw=q[9]|0,ws=cw&8191,ks=cw>>>13;v.negative=S.negative^I.negative,v.length=19,F=Math.imul(J,ae),A=Math.imul(J,Ee),A=A+Math.imul(se,ae)|0,V=Math.imul(se,Ee);var ip=(G+F|0)+((A&8191)<<13)|0;G=(V+(A>>>13)|0)+(ip>>>26)|0,ip&=67108863,F=Math.imul(le,ae),A=Math.imul(le,Ee),A=A+Math.imul(Oe,ae)|0,V=Math.imul(Oe,Ee),F=F+Math.imul(J,Ne)|0,A=A+Math.imul(J,De)|0,A=A+Math.imul(se,Ne)|0,V=V+Math.imul(se,De)|0;var np=(G+F|0)+((A&8191)<<13)|0;G=(V+(A>>>13)|0)+(np>>>26)|0,np&=67108863,F=Math.imul(Le,ae),A=Math.imul(Le,Ee),A=A+Math.imul(Fe,ae)|0,V=Math.imul(Fe,Ee),F=F+Math.imul(le,Ne)|0,A=A+Math.imul(le,De)|0,A=A+Math.imul(Oe,Ne)|0,V=V+Math.imul(Oe,De)|0,F=F+Math.imul(J,Jt)|0,A=A+Math.imul(J,Dt)|0,A=A+Math.imul(se,Jt)|0,V=V+Math.imul(se,Dt)|0;var rp=(G+F|0)+((A&8191)<<13)|0;G=(V+(A>>>13)|0)+(rp>>>26)|0,rp&=67108863,F=Math.imul(D,ae),A=Math.imul(D,Ee),A=A+Math.imul(j,ae)|0,V=Math.imul(j,Ee),F=F+Math.imul(Le,Ne)|0,A=A+Math.imul(Le,De)|0,A=A+Math.imul(Fe,Ne)|0,V=V+Math.imul(Fe,De)|0,F=F+Math.imul(le,Jt)|0,A=A+Math.imul(le,Dt)|0,A=A+Math.imul(Oe,Jt)|0,V=V+Math.imul(Oe,Dt)|0,F=F+Math.imul(J,Ht)|0,A=A+Math.imul(J,es)|0,A=A+Math.imul(se,Ht)|0,V=V+Math.imul(se,es)|0;var ap=(G+F|0)+((A&8191)<<13)|0;G=(V+(A>>>13)|0)+(ap>>>26)|0,ap&=67108863,F=Math.imul(H,ae),A=Math.imul(H,Ee),A=A+Math.imul(W,ae)|0,V=Math.imul(W,Ee),F=F+Math.imul(D,Ne)|0,A=A+Math.imul(D,De)|0,A=A+Math.imul(j,Ne)|0,V=V+Math.imul(j,De)|0,F=F+Math.imul(Le,Jt)|0,A=A+Math.imul(Le,Dt)|0,A=A+Math.imul(Fe,Jt)|0,V=V+Math.imul(Fe,Dt)|0,F=F+Math.imul(le,Ht)|0,A=A+Math.imul(le,es)|0,A=A+Math.imul(Oe,Ht)|0,V=V+Math.imul(Oe,es)|0,F=F+Math.imul(J,ts)|0,A=A+Math.imul(J,Gt)|0,A=A+Math.imul(se,ts)|0,V=V+Math.imul(se,Gt)|0;var op=(G+F|0)+((A&8191)<<13)|0;G=(V+(A>>>13)|0)+(op>>>26)|0,op&=67108863,F=Math.imul(z,ae),A=Math.imul(z,Ee),A=A+Math.imul(X,ae)|0,V=Math.imul(X,Ee),F=F+Math.imul(H,Ne)|0,A=A+Math.imul(H,De)|0,A=A+Math.imul(W,Ne)|0,V=V+Math.imul(W,De)|0,F=F+Math.imul(D,Jt)|0,A=A+Math.imul(D,Dt)|0,A=A+Math.imul(j,Jt)|0,V=V+Math.imul(j,Dt)|0,F=F+Math.imul(Le,Ht)|0,A=A+Math.imul(Le,es)|0,A=A+Math.imul(Fe,Ht)|0,V=V+Math.imul(Fe,es)|0,F=F+Math.imul(le,ts)|0,A=A+Math.imul(le,Gt)|0,A=A+Math.imul(Oe,ts)|0,V=V+Math.imul(Oe,Gt)|0,F=F+Math.imul(J,ss)|0,A=A+Math.imul(J,Ut)|0,A=A+Math.imul(se,ss)|0,V=V+Math.imul(se,Ut)|0;var dp=(G+F|0)+((A&8191)<<13)|0;G=(V+(A>>>13)|0)+(dp>>>26)|0,dp&=67108863,F=Math.imul(te,ae),A=Math.imul(te,Ee),A=A+Math.imul(ce,ae)|0,V=Math.imul(ce,Ee),F=F+Math.imul(z,Ne)|0,A=A+Math.imul(z,De)|0,A=A+Math.imul(X,Ne)|0,V=V+Math.imul(X,De)|0,F=F+Math.imul(H,Jt)|0,A=A+Math.imul(H,Dt)|0,A=A+Math.imul(W,Jt)|0,V=V+Math.imul(W,Dt)|0,F=F+Math.imul(D,Ht)|0,A=A+Math.imul(D,es)|0,A=A+Math.imul(j,Ht)|0,V=V+Math.imul(j,es)|0,F=F+Math.imul(Le,ts)|0,A=A+Math.imul(Le,Gt)|0,A=A+Math.imul(Fe,ts)|0,V=V+Math.imul(Fe,Gt)|0,F=F+Math.imul(le,ss)|0,A=A+Math.imul(le,Ut)|0,A=A+Math.imul(Oe,ss)|0,V=V+Math.imul(Oe,Ut)|0,F=F+Math.imul(J,$t)|0,A=A+Math.imul(J,dt)|0,A=A+Math.imul(se,$t)|0,V=V+Math.imul(se,dt)|0;var cp=(G+F|0)+((A&8191)<<13)|0;G=(V+(A>>>13)|0)+(cp>>>26)|0,cp&=67108863,F=Math.imul(ue,ae),A=Math.imul(ue,Ee),A=A+Math.imul(Ie,ae)|0,V=Math.imul(Ie,Ee),F=F+Math.imul(te,Ne)|0,A=A+Math.imul(te,De)|0,A=A+Math.imul(ce,Ne)|0,V=V+Math.imul(ce,De)|0,F=F+Math.imul(z,Jt)|0,A=A+Math.imul(z,Dt)|0,A=A+Math.imul(X,Jt)|0,V=V+Math.imul(X,Dt)|0,F=F+Math.imul(H,Ht)|0,A=A+Math.imul(H,es)|0,A=A+Math.imul(W,Ht)|0,V=V+Math.imul(W,es)|0,F=F+Math.imul(D,ts)|0,A=A+Math.imul(D,Gt)|0,A=A+Math.imul(j,ts)|0,V=V+Math.imul(j,Gt)|0,F=F+Math.imul(Le,ss)|0,A=A+Math.imul(Le,Ut)|0,A=A+Math.imul(Fe,ss)|0,V=V+Math.imul(Fe,Ut)|0,F=F+Math.imul(le,$t)|0,A=A+Math.imul(le,dt)|0,A=A+Math.imul(Oe,$t)|0,V=V+Math.imul(Oe,dt)|0,F=F+Math.imul(J,jt)|0,A=A+Math.imul(J,is)|0,A=A+Math.imul(se,jt)|0,V=V+Math.imul(se,is)|0;var up=(G+F|0)+((A&8191)<<13)|0;G=(V+(A>>>13)|0)+(up>>>26)|0,up&=67108863,F=Math.imul(L,ae),A=Math.imul(L,Ee),A=A+Math.imul(M,ae)|0,V=Math.imul(M,Ee),F=F+Math.imul(ue,Ne)|0,A=A+Math.imul(ue,De)|0,A=A+Math.imul(Ie,Ne)|0,V=V+Math.imul(Ie,De)|0,F=F+Math.imul(te,Jt)|0,A=A+Math.imul(te,Dt)|0,A=A+Math.imul(ce,Jt)|0,V=V+Math.imul(ce,Dt)|0,F=F+Math.imul(z,Ht)|0,A=A+Math.imul(z,es)|0,A=A+Math.imul(X,Ht)|0,V=V+Math.imul(X,es)|0,F=F+Math.imul(H,ts)|0,A=A+Math.imul(H,Gt)|0,A=A+Math.imul(W,ts)|0,V=V+Math.imul(W,Gt)|0,F=F+Math.imul(D,ss)|0,A=A+Math.imul(D,Ut)|0,A=A+Math.imul(j,ss)|0,V=V+Math.imul(j,Ut)|0,F=F+Math.imul(Le,$t)|0,A=A+Math.imul(Le,dt)|0,A=A+Math.imul(Fe,$t)|0,V=V+Math.imul(Fe,dt)|0,F=F+Math.imul(le,jt)|0,A=A+Math.imul(le,is)|0,A=A+Math.imul(Oe,jt)|0,V=V+Math.imul(Oe,is)|0,F=F+Math.imul(J,ys)|0,A=A+Math.imul(J,bs)|0,A=A+Math.imul(se,ys)|0,V=V+Math.imul(se,bs)|0;var fp=(G+F|0)+((A&8191)<<13)|0;G=(V+(A>>>13)|0)+(fp>>>26)|0,fp&=67108863,F=Math.imul(K,ae),A=Math.imul(K,Ee),A=A+Math.imul(Z,ae)|0,V=Math.imul(Z,Ee),F=F+Math.imul(L,Ne)|0,A=A+Math.imul(L,De)|0,A=A+Math.imul(M,Ne)|0,V=V+Math.imul(M,De)|0,F=F+Math.imul(ue,Jt)|0,A=A+Math.imul(ue,Dt)|0,A=A+Math.imul(Ie,Jt)|0,V=V+Math.imul(Ie,Dt)|0,F=F+Math.imul(te,Ht)|0,A=A+Math.imul(te,es)|0,A=A+Math.imul(ce,Ht)|0,V=V+Math.imul(ce,es)|0,F=F+Math.imul(z,ts)|0,A=A+Math.imul(z,Gt)|0,A=A+Math.imul(X,ts)|0,V=V+Math.imul(X,Gt)|0,F=F+Math.imul(H,ss)|0,A=A+Math.imul(H,Ut)|0,A=A+Math.imul(W,ss)|0,V=V+Math.imul(W,Ut)|0,F=F+Math.imul(D,$t)|0,A=A+Math.imul(D,dt)|0,A=A+Math.imul(j,$t)|0,V=V+Math.imul(j,dt)|0,F=F+Math.imul(Le,jt)|0,A=A+Math.imul(Le,is)|0,A=A+Math.imul(Fe,jt)|0,V=V+Math.imul(Fe,is)|0,F=F+Math.imul(le,ys)|0,A=A+Math.imul(le,bs)|0,A=A+Math.imul(Oe,ys)|0,V=V+Math.imul(Oe,bs)|0,F=F+Math.imul(J,ws)|0,A=A+Math.imul(J,ks)|0,A=A+Math.imul(se,ws)|0,V=V+Math.imul(se,ks)|0;var hp=(G+F|0)+((A&8191)<<13)|0;G=(V+(A>>>13)|0)+(hp>>>26)|0,hp&=67108863,F=Math.imul(K,Ne),A=Math.imul(K,De),A=A+Math.imul(Z,Ne)|0,V=Math.imul(Z,De),F=F+Math.imul(L,Jt)|0,A=A+Math.imul(L,Dt)|0,A=A+Math.imul(M,Jt)|0,V=V+Math.imul(M,Dt)|0,F=F+Math.imul(ue,Ht)|0,A=A+Math.imul(ue,es)|0,A=A+Math.imul(Ie,Ht)|0,V=V+Math.imul(Ie,es)|0,F=F+Math.imul(te,ts)|0,A=A+Math.imul(te,Gt)|0,A=A+Math.imul(ce,ts)|0,V=V+Math.imul(ce,Gt)|0,F=F+Math.imul(z,ss)|0,A=A+Math.imul(z,Ut)|0,A=A+Math.imul(X,ss)|0,V=V+Math.imul(X,Ut)|0,F=F+Math.imul(H,$t)|0,A=A+Math.imul(H,dt)|0,A=A+Math.imul(W,$t)|0,V=V+Math.imul(W,dt)|0,F=F+Math.imul(D,jt)|0,A=A+Math.imul(D,is)|0,A=A+Math.imul(j,jt)|0,V=V+Math.imul(j,is)|0,F=F+Math.imul(Le,ys)|0,A=A+Math.imul(Le,bs)|0,A=A+Math.imul(Fe,ys)|0,V=V+Math.imul(Fe,bs)|0,F=F+Math.imul(le,ws)|0,A=A+Math.imul(le,ks)|0,A=A+Math.imul(Oe,ws)|0,V=V+Math.imul(Oe,ks)|0;var lp=(G+F|0)+((A&8191)<<13)|0;G=(V+(A>>>13)|0)+(lp>>>26)|0,lp&=67108863,F=Math.imul(K,Jt),A=Math.imul(K,Dt),A=A+Math.imul(Z,Jt)|0,V=Math.imul(Z,Dt),F=F+Math.imul(L,Ht)|0,A=A+Math.imul(L,es)|0,A=A+Math.imul(M,Ht)|0,V=V+Math.imul(M,es)|0,F=F+Math.imul(ue,ts)|0,A=A+Math.imul(ue,Gt)|0,A=A+Math.imul(Ie,ts)|0,V=V+Math.imul(Ie,Gt)|0,F=F+Math.imul(te,ss)|0,A=A+Math.imul(te,Ut)|0,A=A+Math.imul(ce,ss)|0,V=V+Math.imul(ce,Ut)|0,F=F+Math.imul(z,$t)|0,A=A+Math.imul(z,dt)|0,A=A+Math.imul(X,$t)|0,V=V+Math.imul(X,dt)|0,F=F+Math.imul(H,jt)|0,A=A+Math.imul(H,is)|0,A=A+Math.imul(W,jt)|0,V=V+Math.imul(W,is)|0,F=F+Math.imul(D,ys)|0,A=A+Math.imul(D,bs)|0,A=A+Math.imul(j,ys)|0,V=V+Math.imul(j,bs)|0,F=F+Math.imul(Le,ws)|0,A=A+Math.imul(Le,ks)|0,A=A+Math.imul(Fe,ws)|0,V=V+Math.imul(Fe,ks)|0;var pp=(G+F|0)+((A&8191)<<13)|0;G=(V+(A>>>13)|0)+(pp>>>26)|0,pp&=67108863,F=Math.imul(K,Ht),A=Math.imul(K,es),A=A+Math.imul(Z,Ht)|0,V=Math.imul(Z,es),F=F+Math.imul(L,ts)|0,A=A+Math.imul(L,Gt)|0,A=A+Math.imul(M,ts)|0,V=V+Math.imul(M,Gt)|0,F=F+Math.imul(ue,ss)|0,A=A+Math.imul(ue,Ut)|0,A=A+Math.imul(Ie,ss)|0,V=V+Math.imul(Ie,Ut)|0,F=F+Math.imul(te,$t)|0,A=A+Math.imul(te,dt)|0,A=A+Math.imul(ce,$t)|0,V=V+Math.imul(ce,dt)|0,F=F+Math.imul(z,jt)|0,A=A+Math.imul(z,is)|0,A=A+Math.imul(X,jt)|0,V=V+Math.imul(X,is)|0,F=F+Math.imul(H,ys)|0,A=A+Math.imul(H,bs)|0,A=A+Math.imul(W,ys)|0,V=V+Math.imul(W,bs)|0,F=F+Math.imul(D,ws)|0,A=A+Math.imul(D,ks)|0,A=A+Math.imul(j,ws)|0,V=V+Math.imul(j,ks)|0;var mp=(G+F|0)+((A&8191)<<13)|0;G=(V+(A>>>13)|0)+(mp>>>26)|0,mp&=67108863,F=Math.imul(K,ts),A=Math.imul(K,Gt),A=A+Math.imul(Z,ts)|0,V=Math.imul(Z,Gt),F=F+Math.imul(L,ss)|0,A=A+Math.imul(L,Ut)|0,A=A+Math.imul(M,ss)|0,V=V+Math.imul(M,Ut)|0,F=F+Math.imul(ue,$t)|0,A=A+Math.imul(ue,dt)|0,A=A+Math.imul(Ie,$t)|0,V=V+Math.imul(Ie,dt)|0,F=F+Math.imul(te,jt)|0,A=A+Math.imul(te,is)|0,A=A+Math.imul(ce,jt)|0,V=V+Math.imul(ce,is)|0,F=F+Math.imul(z,ys)|0,A=A+Math.imul(z,bs)|0,A=A+Math.imul(X,ys)|0,V=V+Math.imul(X,bs)|0,F=F+Math.imul(H,ws)|0,A=A+Math.imul(H,ks)|0,A=A+Math.imul(W,ws)|0,V=V+Math.imul(W,ks)|0;var gp=(G+F|0)+((A&8191)<<13)|0;G=(V+(A>>>13)|0)+(gp>>>26)|0,gp&=67108863,F=Math.imul(K,ss),A=Math.imul(K,Ut),A=A+Math.imul(Z,ss)|0,V=Math.imul(Z,Ut),F=F+Math.imul(L,$t)|0,A=A+Math.imul(L,dt)|0,A=A+Math.imul(M,$t)|0,V=V+Math.imul(M,dt)|0,F=F+Math.imul(ue,jt)|0,A=A+Math.imul(ue,is)|0,A=A+Math.imul(Ie,jt)|0,V=V+Math.imul(Ie,is)|0,F=F+Math.imul(te,ys)|0,A=A+Math.imul(te,bs)|0,A=A+Math.imul(ce,ys)|0,V=V+Math.imul(ce,bs)|0,F=F+Math.imul(z,ws)|0,A=A+Math.imul(z,ks)|0,A=A+Math.imul(X,ws)|0,V=V+Math.imul(X,ks)|0;var yp=(G+F|0)+((A&8191)<<13)|0;G=(V+(A>>>13)|0)+(yp>>>26)|0,yp&=67108863,F=Math.imul(K,$t),A=Math.imul(K,dt),A=A+Math.imul(Z,$t)|0,V=Math.imul(Z,dt),F=F+Math.imul(L,jt)|0,A=A+Math.imul(L,is)|0,A=A+Math.imul(M,jt)|0,V=V+Math.imul(M,is)|0,F=F+Math.imul(ue,ys)|0,A=A+Math.imul(ue,bs)|0,A=A+Math.imul(Ie,ys)|0,V=V+Math.imul(Ie,bs)|0,F=F+Math.imul(te,ws)|0,A=A+Math.imul(te,ks)|0,A=A+Math.imul(ce,ws)|0,V=V+Math.imul(ce,ks)|0;var bp=(G+F|0)+((A&8191)<<13)|0;G=(V+(A>>>13)|0)+(bp>>>26)|0,bp&=67108863,F=Math.imul(K,jt),A=Math.imul(K,is),A=A+Math.imul(Z,jt)|0,V=Math.imul(Z,is),F=F+Math.imul(L,ys)|0,A=A+Math.imul(L,bs)|0,A=A+Math.imul(M,ys)|0,V=V+Math.imul(M,bs)|0,F=F+Math.imul(ue,ws)|0,A=A+Math.imul(ue,ks)|0,A=A+Math.imul(Ie,ws)|0,V=V+Math.imul(Ie,ks)|0;var wp=(G+F|0)+((A&8191)<<13)|0;G=(V+(A>>>13)|0)+(wp>>>26)|0,wp&=67108863,F=Math.imul(K,ys),A=Math.imul(K,bs),A=A+Math.imul(Z,ys)|0,V=Math.imul(Z,bs),F=F+Math.imul(L,ws)|0,A=A+Math.imul(L,ks)|0,A=A+Math.imul(M,ws)|0,V=V+Math.imul(M,ks)|0;var kp=(G+F|0)+((A&8191)<<13)|0;G=(V+(A>>>13)|0)+(kp>>>26)|0,kp&=67108863,F=Math.imul(K,ws),A=Math.imul(K,ks),A=A+Math.imul(Z,ws)|0,V=Math.imul(Z,ks);var Sp=(G+F|0)+((A&8191)<<13)|0;return G=(V+(A>>>13)|0)+(Sp>>>26)|0,Sp&=67108863,R[0]=ip,R[1]=np,R[2]=rp,R[3]=ap,R[4]=op,R[5]=dp,R[6]=cp,R[7]=up,R[8]=fp,R[9]=hp,R[10]=lp,R[11]=pp,R[12]=mp,R[13]=gp,R[14]=yp,R[15]=bp,R[16]=wp,R[17]=kp,R[18]=Sp,G!==0&&(R[19]=G,v.length++),v};Math.imul||(g=m);function y(_,S,I){I.negative=S.negative^_.negative,I.length=_.length+S.length;for(var v=0,N=0,q=0;q<I.length-1;q++){var R=N;N=0;for(var G=v&67108863,F=Math.min(q,S.length-1),A=Math.max(0,q-_.length+1);A<=F;A++){var V=q-A,Q=_.words[V]|0,J=S.words[A]|0,se=Q*J,we=se&67108863;R=R+(se/67108864|0)|0,we=we+G|0,G=we&67108863,R=R+(we>>>26)|0,N+=R>>>26,R&=67108863}I.words[q]=G,v=R,R=N}return v!==0?I.words[q]=v:I.length--,I._strip()}function b(_,S,I){return y(_,S,I)}n.prototype.mulTo=function(S,I){var v,N=this.length+S.length;return this.length===10&&S.length===10?v=g(this,S,I):N<63?v=m(this,S,I):N<1024?v=y(this,S,I):v=b(this,S,I),v},n.prototype.mul=function(S){var I=new n(null);return I.words=new Array(this.length+S.length),this.mulTo(S,I)},n.prototype.mulf=function(S){var I=new n(null);return I.words=new Array(this.length+S.length),b(this,S,I)},n.prototype.imul=function(S){return this.clone().mulTo(S,this)},n.prototype.imuln=function(S){var I=S<0;I&&(S=-S),s(typeof S=="number"),s(S<67108864);for(var v=0,N=0;N<this.length;N++){var q=(this.words[N]|0)*S,R=(q&67108863)+(v&67108863);v>>=26,v+=q/67108864|0,v+=R>>>26,this.words[N]=R&67108863}return v!==0&&(this.words[N]=v,this.length++),I?this.ineg():this},n.prototype.muln=function(S){return this.clone().imuln(S)},n.prototype.sqr=function(){return this.mul(this)},n.prototype.isqr=function(){return this.imul(this.clone())},n.prototype.pow=function(S){var I=p(S);if(I.length===0)return new n(1);for(var v=this,N=0;N<I.length&&I[N]===0;N++,v=v.sqr());if(++N<I.length)for(var q=v.sqr();N<I.length;N++,q=q.sqr())I[N]!==0&&(v=v.mul(q));return v},n.prototype.iushln=function(S){s(typeof S=="number"&&S>=0);var I=S%26,v=(S-I)/26,N=67108863>>>26-I<<26-I,q;if(I!==0){var R=0;for(q=0;q<this.length;q++){var G=this.words[q]&N,F=(this.words[q]|0)-G<<I;this.words[q]=F|R,R=G>>>26-I}R&&(this.words[q]=R,this.length++)}if(v!==0){for(q=this.length-1;q>=0;q--)this.words[q+v]=this.words[q];for(q=0;q<v;q++)this.words[q]=0;this.length+=v}return this._strip()},n.prototype.ishln=function(S){return s(this.negative===0),this.iushln(S)},n.prototype.iushrn=function(S,I,v){s(typeof S=="number"&&S>=0);var N;I?N=(I-I%26)/26:N=0;var q=S%26,R=Math.min((S-q)/26,this.length),G=67108863^67108863>>>q<<q,F=v;if(N-=R,N=Math.max(0,N),F){for(var A=0;A<R;A++)F.words[A]=this.words[A];F.length=R}if(R!==0)if(this.length>R)for(this.length-=R,A=0;A<this.length;A++)this.words[A]=this.words[A+R];else this.words[0]=0,this.length=1;var V=0;for(A=this.length-1;A>=0&&(V!==0||A>=N);A--){var Q=this.words[A]|0;this.words[A]=V<<26-q|Q>>>q,V=Q&G}return F&&V!==0&&(F.words[F.length++]=V),this.length===0&&(this.words[0]=0,this.length=1),this._strip()},n.prototype.ishrn=function(S,I,v){return s(this.negative===0),this.iushrn(S,I,v)},n.prototype.shln=function(S){return this.clone().ishln(S)},n.prototype.ushln=function(S){return this.clone().iushln(S)},n.prototype.shrn=function(S){return this.clone().ishrn(S)},n.prototype.ushrn=function(S){return this.clone().iushrn(S)},n.prototype.testn=function(S){s(typeof S=="number"&&S>=0);var I=S%26,v=(S-I)/26,N=1<<I;if(this.length<=v)return!1;var q=this.words[v];return!!(q&N)},n.prototype.imaskn=function(S){s(typeof S=="number"&&S>=0);var I=S%26,v=(S-I)/26;if(s(this.negative===0,"imaskn works only with positive numbers"),this.length<=v)return this;if(I!==0&&v++,this.length=Math.min(v,this.length),I!==0){var N=67108863^67108863>>>I<<I;this.words[this.length-1]&=N}return this._strip()},n.prototype.maskn=function(S){return this.clone().imaskn(S)},n.prototype.iaddn=function(S){return s(typeof S=="number"),s(S<67108864),S<0?this.isubn(-S):this.negative!==0?this.length===1&&(this.words[0]|0)<=S?(this.words[0]=S-(this.words[0]|0),this.negative=0,this):(this.negative=0,this.isubn(S),this.negative=1,this):this._iaddn(S)},n.prototype._iaddn=function(S){this.words[0]+=S;for(var I=0;I<this.length&&this.words[I]>=67108864;I++)this.words[I]-=67108864,I===this.length-1?this.words[I+1]=1:this.words[I+1]++;return this.length=Math.max(this.length,I+1),this},n.prototype.isubn=function(S){if(s(typeof S=="number"),s(S<67108864),S<0)return this.iaddn(-S);if(this.negative!==0)return this.negative=0,this.iaddn(S),this.negative=1,this;if(this.words[0]-=S,this.length===1&&this.words[0]<0)this.words[0]=-this.words[0],this.negative=1;else for(var I=0;I<this.length&&this.words[I]<0;I++)this.words[I]+=67108864,this.words[I+1]-=1;return this._strip()},n.prototype.addn=function(S){return this.clone().iaddn(S)},n.prototype.subn=function(S){return this.clone().isubn(S)},n.prototype.iabs=function(){return this.negative=0,this},n.prototype.abs=function(){return this.clone().iabs()},n.prototype._ishlnsubmul=function(S,I,v){var N=S.length+v,q;this._expand(N);var R,G=0;for(q=0;q<S.length;q++){R=(this.words[q+v]|0)+G;var F=(S.words[q]|0)*I;R-=F&67108863,G=(R>>26)-(F/67108864|0),this.words[q+v]=R&67108863}for(;q<this.length-v;q++)R=(this.words[q+v]|0)+G,G=R>>26,this.words[q+v]=R&67108863;if(G===0)return this._strip();for(s(G===-1),G=0,q=0;q<this.length;q++)R=-(this.words[q]|0)+G,G=R>>26,this.words[q]=R&67108863;return this.negative=1,this._strip()},n.prototype._wordDiv=function(S,I){var v=this.length-S.length,N=this.clone(),q=S,R=q.words[q.length-1]|0,G=this._countBits(R);v=26-G,v!==0&&(q=q.ushln(v),N.iushln(v),R=q.words[q.length-1]|0);var F=N.length-q.length,A;if(I!=="mod"){A=new n(null),A.length=F+1,A.words=new Array(A.length);for(var V=0;V<A.length;V++)A.words[V]=0}var Q=N.clone()._ishlnsubmul(q,1,F);Q.negative===0&&(N=Q,A&&(A.words[F]=1));for(var J=F-1;J>=0;J--){var se=(N.words[q.length+J]|0)*67108864+(N.words[q.length+J-1]|0);for(se=Math.min(se/R|0,67108863),N._ishlnsubmul(q,se,J);N.negative!==0;)se--,N.negative=0,N._ishlnsubmul(q,1,J),N.isZero()||(N.negative^=1);A&&(A.words[J]=se)}return A&&A._strip(),N._strip(),I!=="div"&&v!==0&&N.iushrn(v),{div:A||null,mod:N}},n.prototype.divmod=function(S,I,v){if(s(!S.isZero()),this.isZero())return{div:new n(0),mod:new n(0)};var N,q,R;return this.negative!==0&&S.negative===0?(R=this.neg().divmod(S,I),I!=="mod"&&(N=R.div.neg()),I!=="div"&&(q=R.mod.neg(),v&&q.negative!==0&&q.iadd(S)),{div:N,mod:q}):this.negative===0&&S.negative!==0?(R=this.divmod(S.neg(),I),I!=="mod"&&(N=R.div.neg()),{div:N,mod:R.mod}):(this.negative&S.negative)!==0?(R=this.neg().divmod(S.neg(),I),I!=="div"&&(q=R.mod.neg(),v&&q.negative!==0&&q.isub(S)),{div:R.div,mod:q}):S.length>this.length||this.cmp(S)<0?{div:new n(0),mod:this}:S.length===1?I==="div"?{div:this.divn(S.words[0]),mod:null}:I==="mod"?{div:null,mod:new n(this.modrn(S.words[0]))}:{div:this.divn(S.words[0]),mod:new n(this.modrn(S.words[0]))}:this._wordDiv(S,I)},n.prototype.div=function(S){return this.divmod(S,"div",!1).div},n.prototype.mod=function(S){return this.divmod(S,"mod",!1).mod},n.prototype.umod=function(S){return this.divmod(S,"mod",!0).mod},n.prototype.divRound=function(S){var I=this.divmod(S);if(I.mod.isZero())return I.div;var v=I.div.negative!==0?I.mod.isub(S):I.mod,N=S.ushrn(1),q=S.andln(1),R=v.cmp(N);return R<0||q===1&&R===0?I.div:I.div.negative!==0?I.div.isubn(1):I.div.iaddn(1)},n.prototype.modrn=function(S){var I=S<0;I&&(S=-S),s(S<=67108863);for(var v=(1<<26)%S,N=0,q=this.length-1;q>=0;q--)N=(v*N+(this.words[q]|0))%S;return I?-N:N},n.prototype.modn=function(S){return this.modrn(S)},n.prototype.idivn=function(S){var I=S<0;I&&(S=-S),s(S<=67108863);for(var v=0,N=this.length-1;N>=0;N--){var q=(this.words[N]|0)+v*67108864;this.words[N]=q/S|0,v=q%S}return this._strip(),I?this.ineg():this},n.prototype.divn=function(S){return this.clone().idivn(S)},n.prototype.egcd=function(S){s(S.negative===0),s(!S.isZero());var I=this,v=S.clone();I.negative!==0?I=I.umod(S):I=I.clone();for(var N=new n(1),q=new n(0),R=new n(0),G=new n(1),F=0;I.isEven()&&v.isEven();)I.iushrn(1),v.iushrn(1),++F;for(var A=v.clone(),V=I.clone();!I.isZero();){for(var Q=0,J=1;(I.words[0]&J)===0&&Q<26;++Q,J<<=1);if(Q>0)for(I.iushrn(Q);Q-- >0;)(N.isOdd()||q.isOdd())&&(N.iadd(A),q.isub(V)),N.iushrn(1),q.iushrn(1);for(var se=0,we=1;(v.words[0]&we)===0&&se<26;++se,we<<=1);if(se>0)for(v.iushrn(se);se-- >0;)(R.isOdd()||G.isOdd())&&(R.iadd(A),G.isub(V)),R.iushrn(1),G.iushrn(1);I.cmp(v)>=0?(I.isub(v),N.isub(R),q.isub(G)):(v.isub(I),R.isub(N),G.isub(q))}return{a:R,b:G,gcd:v.iushln(F)}},n.prototype._invmp=function(S){s(S.negative===0),s(!S.isZero());var I=this,v=S.clone();I.negative!==0?I=I.umod(S):I=I.clone();for(var N=new n(1),q=new n(0),R=v.clone();I.cmpn(1)>0&&v.cmpn(1)>0;){for(var G=0,F=1;(I.words[0]&F)===0&&G<26;++G,F<<=1);if(G>0)for(I.iushrn(G);G-- >0;)N.isOdd()&&N.iadd(R),N.iushrn(1);for(var A=0,V=1;(v.words[0]&V)===0&&A<26;++A,V<<=1);if(A>0)for(v.iushrn(A);A-- >0;)q.isOdd()&&q.iadd(R),q.iushrn(1);I.cmp(v)>=0?(I.isub(v),N.isub(q)):(v.isub(I),q.isub(N))}var Q;return I.cmpn(1)===0?Q=N:Q=q,Q.cmpn(0)<0&&Q.iadd(S),Q},n.prototype.gcd=function(S){if(this.isZero())return S.abs();if(S.isZero())return this.abs();var I=this.clone(),v=S.clone();I.negative=0,v.negative=0;for(var N=0;I.isEven()&&v.isEven();N++)I.iushrn(1),v.iushrn(1);do{for(;I.isEven();)I.iushrn(1);for(;v.isEven();)v.iushrn(1);var q=I.cmp(v);if(q<0){var R=I;I=v,v=R}else if(q===0||v.cmpn(1)===0)break;I.isub(v)}while(!0);return v.iushln(N)},n.prototype.invm=function(S){return this.egcd(S).a.umod(S)},n.prototype.isEven=function(){return(this.words[0]&1)===0},n.prototype.isOdd=function(){return(this.words[0]&1)===1},n.prototype.andln=function(S){return this.words[0]&S},n.prototype.bincn=function(S){s(typeof S=="number");var I=S%26,v=(S-I)/26,N=1<<I;if(this.length<=v)return this._expand(v+1),this.words[v]|=N,this;for(var q=N,R=v;q!==0&&R<this.length;R++){var G=this.words[R]|0;G+=q,q=G>>>26,G&=67108863,this.words[R]=G}return q!==0&&(this.words[R]=q,this.length++),this},n.prototype.isZero=function(){return this.length===1&&this.words[0]===0},n.prototype.cmpn=function(S){var I=S<0;if(this.negative!==0&&!I)return-1;if(this.negative===0&&I)return 1;this._strip();var v;if(this.length>1)v=1;else{I&&(S=-S),s(S<=67108863,"Number is too big");var N=this.words[0]|0;v=N===S?0:N<S?-1:1}return this.negative!==0?-v|0:v},n.prototype.cmp=function(S){if(this.negative!==0&&S.negative===0)return-1;if(this.negative===0&&S.negative!==0)return 1;var I=this.ucmp(S);return this.negative!==0?-I|0:I},n.prototype.ucmp=function(S){if(this.length>S.length)return 1;if(this.length<S.length)return-1;for(var I=0,v=this.length-1;v>=0;v--){var N=this.words[v]|0,q=S.words[v]|0;if(N!==q){N<q?I=-1:N>q&&(I=1);break}}return I},n.prototype.gtn=function(S){return this.cmpn(S)===1},n.prototype.gt=function(S){return this.cmp(S)===1},n.prototype.gten=function(S){return this.cmpn(S)>=0},n.prototype.gte=function(S){return this.cmp(S)>=0},n.prototype.ltn=function(S){return this.cmpn(S)===-1},n.prototype.lt=function(S){return this.cmp(S)===-1},n.prototype.lten=function(S){return this.cmpn(S)<=0},n.prototype.lte=function(S){return this.cmp(S)<=0},n.prototype.eqn=function(S){return this.cmpn(S)===0},n.prototype.eq=function(S){return this.cmp(S)===0},n.red=function(S){return new E(S)},n.prototype.toRed=function(S){return s(!this.red,"Already a number in reduction context"),s(this.negative===0,"red works only with positives"),S.convertTo(this)._forceRed(S)},n.prototype.fromRed=function(){return s(this.red,"fromRed works only with numbers in reduction context"),this.red.convertFrom(this)},n.prototype._forceRed=function(S){return this.red=S,this},n.prototype.forceRed=function(S){return s(!this.red,"Already a number in reduction context"),this._forceRed(S)},n.prototype.redAdd=function(S){return s(this.red,"redAdd works only with red numbers"),this.red.add(this,S)},n.prototype.redIAdd=function(S){return s(this.red,"redIAdd works only with red numbers"),this.red.iadd(this,S)},n.prototype.redSub=function(S){return s(this.red,"redSub works only with red numbers"),this.red.sub(this,S)},n.prototype.redISub=function(S){return s(this.red,"redISub works only with red numbers"),this.red.isub(this,S)},n.prototype.redShl=function(S){return s(this.red,"redShl works only with red numbers"),this.red.shl(this,S)},n.prototype.redMul=function(S){return s(this.red,"redMul works only with red numbers"),this.red._verify2(this,S),this.red.mul(this,S)},n.prototype.redIMul=function(S){return s(this.red,"redMul works only with red numbers"),this.red._verify2(this,S),this.red.imul(this,S)},n.prototype.redSqr=function(){return s(this.red,"redSqr works only with red numbers"),this.red._verify1(this),this.red.sqr(this)},n.prototype.redISqr=function(){return s(this.red,"redISqr works only with red numbers"),this.red._verify1(this),this.red.isqr(this)},n.prototype.redSqrt=function(){return s(this.red,"redSqrt works only with red numbers"),this.red._verify1(this),this.red.sqrt(this)},n.prototype.redInvm=function(){return s(this.red,"redInvm works only with red numbers"),this.red._verify1(this),this.red.invm(this)},n.prototype.redNeg=function(){return s(this.red,"redNeg works only with red numbers"),this.red._verify1(this),this.red.neg(this)},n.prototype.redPow=function(S){return s(this.red&&!S.red,"redPow(normalNum)"),this.red._verify1(this),this.red.pow(this,S)};var w={k256:null,p224:null,p192:null,p25519:null};function k(_,S){this.name=_,this.p=new n(S,16),this.n=this.p.bitLength(),this.k=new n(1).iushln(this.n).isub(this.p),this.tmp=this._tmp()}k.prototype._tmp=function(){var S=new n(null);return S.words=new Array(Math.ceil(this.n/13)),S},k.prototype.ireduce=function(S){var I=S,v;do this.split(I,this.tmp),I=this.imulK(I),I=I.iadd(this.tmp),v=I.bitLength();while(v>this.n);var N=v<this.n?-1:I.ucmp(this.p);return N===0?(I.words[0]=0,I.length=1):N>0?I.isub(this.p):I._strip(),I},k.prototype.split=function(S,I){S.iushrn(this.n,0,I)},k.prototype.imulK=function(S){return S.imul(this.k)};function T(){k.call(this,"k256","ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")}i(T,k),T.prototype.split=function(S,I){for(var v=4194303,N=Math.min(S.length,9),q=0;q<N;q++)I.words[q]=S.words[q];if(I.length=N,S.length<=9){S.words[0]=0,S.length=1;return}var R=S.words[9];for(I.words[I.length++]=R&v,q=10;q<S.length;q++){var G=S.words[q]|0;S.words[q-10]=(G&v)<<4|R>>>22,R=G}R>>>=22,S.words[q-10]=R,R===0&&S.length>10?S.length-=10:S.length-=9},T.prototype.imulK=function(S){S.words[S.length]=0,S.words[S.length+1]=0,S.length+=2;for(var I=0,v=0;v<S.length;v++){var N=S.words[v]|0;I+=N*977,S.words[v]=I&67108863,I=N*64+(I/67108864|0)}return S.words[S.length-1]===0&&(S.length--,S.words[S.length-1]===0&&S.length--),S};function O(){k.call(this,"p224","ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")}i(O,k);function x(){k.call(this,"p192","ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")}i(x,k);function C(){k.call(this,"25519","7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")}i(C,k),C.prototype.imulK=function(S){for(var I=0,v=0;v<S.length;v++){var N=(S.words[v]|0)*19+I,q=N&67108863;N>>>=26,S.words[v]=q,I=N}return I!==0&&(S.words[S.length++]=I),S},n._prime=function(S){if(w[S])return w[S];var I;if(S==="k256")I=new T;else if(S==="p224")I=new O;else if(S==="p192")I=new x;else if(S==="p25519")I=new C;else throw new Error("Unknown prime "+S);return w[S]=I,I};function E(_){if(typeof _=="string"){var S=n._prime(_);this.m=S.p,this.prime=S}else s(_.gtn(1),"modulus must be greater than 1"),this.m=_,this.prime=null}E.prototype._verify1=function(S){s(S.negative===0,"red works only with positives"),s(S.red,"red works only with red numbers")},E.prototype._verify2=function(S,I){s((S.negative|I.negative)===0,"red works only with positives"),s(S.red&&S.red===I.red,"red works only with red numbers")},E.prototype.imod=function(S){return this.prime?this.prime.ireduce(S)._forceRed(this):(S.umod(this.m)._forceRed(this)._move(S),S)},E.prototype.neg=function(S){return S.isZero()?S.clone():this.m.sub(S)._forceRed(this)},E.prototype.add=function(S,I){this._verify2(S,I);var v=S.add(I);return v.cmp(this.m)>=0&&v.isub(this.m),v._forceRed(this)},E.prototype.iadd=function(S,I){this._verify2(S,I);var v=S.iadd(I);return v.cmp(this.m)>=0&&v.isub(this.m),v},E.prototype.sub=function(S,I){this._verify2(S,I);var v=S.sub(I);return v.cmpn(0)<0&&v.iadd(this.m),v._forceRed(this)},E.prototype.isub=function(S,I){this._verify2(S,I);var v=S.isub(I);return v.cmpn(0)<0&&v.iadd(this.m),v},E.prototype.shl=function(S,I){return this._verify1(S),this.imod(S.ushln(I))},E.prototype.imul=function(S,I){return this._verify2(S,I),this.imod(S.imul(I))},E.prototype.mul=function(S,I){return this._verify2(S,I),this.imod(S.mul(I))},E.prototype.isqr=function(S){return this.imul(S,S.clone())},E.prototype.sqr=function(S){return this.mul(S,S)},E.prototype.sqrt=function(S){if(S.isZero())return S.clone();var I=this.m.andln(3);if(s(I%2===1),I===3){var v=this.m.add(new n(1)).iushrn(2);return this.pow(S,v)}for(var N=this.m.subn(1),q=0;!N.isZero()&&N.andln(1)===0;)q++,N.iushrn(1);s(!N.isZero());var R=new n(1).toRed(this),G=R.redNeg(),F=this.m.subn(1).iushrn(1),A=this.m.bitLength();for(A=new n(2*A*A).toRed(this);this.pow(A,F).cmp(G)!==0;)A.redIAdd(G);for(var V=this.pow(A,N),Q=this.pow(S,N.addn(1).iushrn(1)),J=this.pow(S,N),se=q;J.cmp(R)!==0;){for(var we=J,le=0;we.cmp(R)!==0;le++)we=we.redSqr();s(le<se);var Oe=this.pow(V,new n(1).iushln(se-le-1));Q=Q.redMul(Oe),V=Oe.redSqr(),J=J.redMul(V),se=le}return Q},E.prototype.invm=function(S){var I=S._invmp(this.m);return I.negative!==0?(I.negative=0,this.imod(I).redNeg()):this.imod(I)},E.prototype.pow=function(S,I){if(I.isZero())return new n(1).toRed(this);if(I.cmpn(1)===0)return S.clone();var v=4,N=new Array(1<<v);N[0]=new n(1).toRed(this),N[1]=S;for(var q=2;q<N.length;q++)N[q]=this.mul(N[q-1],S);var R=N[0],G=0,F=0,A=I.bitLength()%26;for(A===0&&(A=26),q=I.length-1;q>=0;q--){for(var V=I.words[q],Q=A-1;Q>=0;Q--){var J=V>>Q&1;if(R!==N[0]&&(R=this.sqr(R)),J===0&&G===0){F=0;continue}G<<=1,G|=J,F++,!(F!==v&&(q!==0||Q!==0))&&(R=this.mul(R,N[G]),F=0,G=0)}A=26}return R},E.prototype.convertTo=function(S){var I=S.umod(this.m);return I===S?I.clone():I},E.prototype.convertFrom=function(S){var I=S.clone();return I.red=null,I},n.mont=function(S){return new P(S)};function P(_){E.call(this,_),this.shift=this.m.bitLength(),this.shift%26!==0&&(this.shift+=26-this.shift%26),this.r=new n(1).iushln(this.shift),this.r2=this.imod(this.r.sqr()),this.rinv=this.r._invmp(this.m),this.minv=this.rinv.mul(this.r).isubn(1).div(this.m),this.minv=this.minv.umod(this.r),this.minv=this.r.sub(this.minv)}i(P,E),P.prototype.convertTo=function(S){return this.imod(S.ushln(this.shift))},P.prototype.convertFrom=function(S){var I=this.imod(S.mul(this.rinv));return I.red=null,I},P.prototype.imul=function(S,I){if(S.isZero()||I.isZero())return S.words[0]=0,S.length=1,S;var v=S.imul(I),N=v.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),q=v.isub(N).iushrn(this.shift),R=q;return q.cmp(this.m)>=0?R=q.isub(this.m):q.cmpn(0)<0&&(R=q.iadd(this.m)),R._forceRed(this)},P.prototype.mul=function(S,I){if(S.isZero()||I.isZero())return new n(0)._forceRed(this);var v=S.mul(I),N=v.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),q=v.isub(N).iushrn(this.shift),R=q;return q.cmp(this.m)>=0?R=q.isub(this.m):q.cmpn(0)<0&&(R=q.iadd(this.m)),R._forceRed(this)},P.prototype.invm=function(S){var I=this.imod(S._invmp(this.m).mul(this.r2));return I._forceRed(this)}})(f,Xh)})(Ui);(function(f){const e=Bd.exports,t=BE,s=Ui.exports,i="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";let n=null,r=null;f.exports={json:(o,d=void 0)=>JSON.stringify(o),isJsonEncodedObject:o=>typeof o=="string"&&o.length>=2&&(o[0]==="{"||o[0]==="["),stringToBinary:o=>e.enc.Latin1.parse(o),stringToBase64:o=>e.enc.Latin1.parse(o).toString(e.enc.Base64),base64ToBinary:o=>e.enc.Base64.parse(o),base64ToString:o=>e.enc.Base64.parse(o).toString(e.enc.Utf8),binaryToBase64:o=>o.toString(e.enc.Base64),base16ToBinary:o=>e.enc.Hex.parse(o),binaryToBase16:o=>o.toString(e.enc.Hex),binaryConcat:(...o)=>o.reduce((d,c)=>d.concat(c)),binaryConcatArray:o=>o.reduce((d,c)=>d.concat(c)),urlencode:o=>t.stringify(o),urlencodeNested:o=>t.stringify(o),urlencodeWithArrayRepeat:o=>t.stringify(o,{arrayFormat:"repeat"}),rawencode:o=>t.stringify(o,{encode:!1}),encode:o=>o,decode:o=>o,urlencodeBase64:o=>o.replace(/[=]+$/,"").replace(/\+/g,"-").replace(/\//g,"_"),numberToLE:(o,d)=>{const c=new s(o).toArray("le",d);return a(c)},numberToBE:(o,d)=>{const c=new s(o).toArray("be",d);return a(c)},base58ToBinary:o=>{if(!n){n={},r={};for(let u=0;u<58;u++){const h=i[u],l=new s(u);n[h]=l,r[l]=h}}let d=new s(0);const c=new s(58);for(let u=0;u<o.length;u++){const h=o[u];d.imul(c),d.iadd(n[h])}return a(d.toArray("be"))},binaryToBase58:o=>{if(!r){n={},r={};for(let l=0;l<58;l++){const p=i[l],m=new s(l);n[p]=m,r[m]=p}}const d=new s(58),c=o.toString(e.enc.Hex);let u=new s(c,16),h=[];for(;!u.isZero();){const{div:l,mod:p}=u.divmod(d);u=l,h.push(r[p])}return h.reverse().join("")}};function a(o){const d=[];for(let c=0;c<o.length;c++)d[c/4|0]|=o[c]<<24-8*c;return e.lib.WordArray.create(d,o.length)}f.exports.byteArrayToWordArray=a})(Ad);var t_={},Ei={};Ei.linebrk=function(f,e){for(var t="",s=0;s+e<f.length;)t+=f.substring(s,s+e)+`
`,s+=e;return t+f.substring(s,f.length)};Ei.get32IntFromBuffer=function(f,e){e=e||0;var t=0;if((t=f.length-e)>0){if(t>=4)return f.readUInt32BE(e);for(var s=0,i=e+t,n=0;i>e;i--,n+=2)s+=f[i-1]*Math.pow(16,n);return s}else return NaN};Ei._={isObject:function(f){var e=typeof f;return!!f&&(e=="object"||e=="function")},isString:function(f){return typeof f=="string"||f instanceof String},isNumber:function(f){return typeof f=="number"||!isNaN(parseFloat(f))&&isFinite(f)},omit:function(f,e){var t={};for(var s in f)!f.hasOwnProperty(s)||s===e||(t[s]=f[s]);return t}};Ei.trimSurroundingText=function(f,e,t){var s=0,i=f.length,n=f.indexOf(e);n>=0&&(s=n+e.length);var r=f.indexOf(t,n);return r>=0&&(i=r),f.substring(s,i)};var EE=Ei._,Ed;function Ae(f,e){f!=null&&(typeof f=="number"?this.fromNumber(f,e):Buffer.isBuffer(f)?this.fromBuffer(f):e==null&&typeof f!="string"?this.fromByteArray(f):this.fromString(f,e))}function Ot(){return new Ae(null)}function NE(f,e,t,s,i,n){for(var r=e&16383,a=e>>14;--n>=0;){var o=this[f]&16383,d=this[f++]>>14,c=a*o+d*r;o=r*o+((c&16383)<<14)+t[s]+i,i=(o>>28)+(c>>14)+a*d,t[s++]=o&268435455}return i}Ae.prototype.am=NE;Ed=28;Ae.prototype.DB=Ed;Ae.prototype.DM=(1<<Ed)-1;Ae.prototype.DV=1<<Ed;var bb=52;Ae.prototype.FV=Math.pow(2,bb);Ae.prototype.F1=bb-Ed;Ae.prototype.F2=2*Ed-bb;var VE="0123456789abcdefghijklmnopqrstuvwxyz",Nl=new Array,Nd,un;Nd="0".charCodeAt(0);for(un=0;un<=9;++un)Nl[Nd++]=un;Nd="a".charCodeAt(0);for(un=10;un<36;++un)Nl[Nd++]=un;Nd="A".charCodeAt(0);for(un=10;un<36;++un)Nl[Nd++]=un;function gy(f){return VE.charAt(f)}function s_(f,e){var t=Nl[f.charCodeAt(e)];return t==null?-1:t}function qE(f){for(var e=this.t-1;e>=0;--e)f[e]=this[e];f.t=this.t,f.s=this.s}function LE(f){this.t=1,this.s=f<0?-1:0,f>0?this[0]=f:f<-1?this[0]=f+DV:this.t=0}function Vl(f){var e=Ot();return e.fromInt(f),e}function RE(f,e,t){var s;switch(e){case 2:s=1;break;case 4:s=2;break;case 8:s=3;break;case 16:s=4;break;case 32:s=5;break;case 256:s=8;break;default:this.fromRadix(f,e);return}this.t=0,this.s=0;for(var i=f.length,n=!1,r=0;--i>=0;){var a=s==8?f[i]&255:s_(f,i);if(a<0){f.charAt(i)=="-"&&(n=!0);continue}n=!1,r===0?this[this.t++]=a:r+s>this.DB?(this[this.t-1]|=(a&(1<<this.DB-r)-1)<<r,this[this.t++]=a>>this.DB-r):this[this.t-1]|=a<<r,r+=s,r>=this.DB&&(r-=this.DB)}!t&&s==8&&(f[0]&128)!=0&&(this.s=-1,r>0&&(this[this.t-1]|=(1<<this.DB-r)-1<<r)),this.clamp(),n&&Ae.ZERO.subTo(this,this)}function FE(f,e){this.fromString(f,256,e)}function DE(f){this.fromString(f,256,!0)}function HE(){for(var f=this.s&this.DM;this.t>0&&this[this.t-1]==f;)--this.t}function GE(f){if(this.s<0)return"-"+this.negate().toString(f);var e;if(f==16)e=4;else if(f==8)e=3;else if(f==2)e=1;else if(f==32)e=5;else if(f==4)e=2;else return this.toRadix(f);var t=(1<<e)-1,s,i=!1,n="",r=this.t,a=this.DB-r*this.DB%e;if(r-- >0)for(a<this.DB&&(s=this[r]>>a)>0&&(i=!0,n=gy(s));r>=0;)a<e?(s=(this[r]&(1<<a)-1)<<e-a,s|=this[--r]>>(a+=this.DB-e)):(s=this[r]>>(a-=e)&t,a<=0&&(a+=this.DB,--r)),s>0&&(i=!0),i&&(n+=gy(s));return i?n:"0"}function UE(){var f=Ot();return Ae.ZERO.subTo(this,f),f}function $E(){return this.s<0?this.negate():this}function jE(f){var e=this.s-f.s;if(e!=0)return e;var t=this.t;if(e=t-f.t,e!=0)return this.s<0?-e:e;for(;--t>=0;)if((e=this[t]-f[t])!=0)return e;return 0}function ql(f){var e=1,t;return(t=f>>>16)!=0&&(f=t,e+=16),(t=f>>8)!=0&&(f=t,e+=8),(t=f>>4)!=0&&(f=t,e+=4),(t=f>>2)!=0&&(f=t,e+=2),(t=f>>1)!=0&&(f=t,e+=1),e}function WE(){return this.t<=0?0:this.DB*(this.t-1)+ql(this[this.t-1]^this.s&this.DM)}function zE(f,e){var t;for(t=this.t-1;t>=0;--t)e[t+f]=this[t];for(t=f-1;t>=0;--t)e[t]=0;e.t=this.t+f,e.s=this.s}function KE(f,e){for(var t=f;t<this.t;++t)e[t-f]=this[t];e.t=Math.max(this.t-f,0),e.s=this.s}function XE(f,e){var t=f%this.DB,s=this.DB-t,i=(1<<s)-1,n=Math.floor(f/this.DB),r=this.s<<t&this.DM,a;for(a=this.t-1;a>=0;--a)e[a+n+1]=this[a]>>s|r,r=(this[a]&i)<<t;for(a=n-1;a>=0;--a)e[a]=0;e[n]=r,e.t=this.t+n+1,e.s=this.s,e.clamp()}function YE(f,e){e.s=this.s;var t=Math.floor(f/this.DB);if(t>=this.t){e.t=0;return}var s=f%this.DB,i=this.DB-s,n=(1<<s)-1;e[0]=this[t]>>s;for(var r=t+1;r<this.t;++r)e[r-t-1]|=(this[r]&n)<<i,e[r-t]=this[r]>>s;s>0&&(e[this.t-t-1]|=(this.s&n)<<i),e.t=this.t-t,e.clamp()}function QE(f,e){for(var t=0,s=0,i=Math.min(f.t,this.t);t<i;)s+=this[t]-f[t],e[t++]=s&this.DM,s>>=this.DB;if(f.t<this.t){for(s-=f.s;t<this.t;)s+=this[t],e[t++]=s&this.DM,s>>=this.DB;s+=this.s}else{for(s+=this.s;t<f.t;)s-=f[t],e[t++]=s&this.DM,s>>=this.DB;s-=f.s}e.s=s<0?-1:0,s<-1?e[t++]=this.DV+s:s>0&&(e[t++]=s),e.t=t,e.clamp()}function ZE(f,e){var t=this.abs(),s=f.abs(),i=t.t;for(e.t=i+s.t;--i>=0;)e[i]=0;for(i=0;i<s.t;++i)e[i+t.t]=t.am(0,s[i],e,i,0,t.t);e.s=0,e.clamp(),this.s!=f.s&&Ae.ZERO.subTo(e,e)}function JE(f){for(var e=this.abs(),t=f.t=2*e.t;--t>=0;)f[t]=0;for(t=0;t<e.t-1;++t){var s=e.am(t,e[t],f,2*t,0,1);(f[t+e.t]+=e.am(t+1,2*e[t],f,2*t+1,s,e.t-t-1))>=e.DV&&(f[t+e.t]-=e.DV,f[t+e.t+1]=1)}f.t>0&&(f[f.t-1]+=e.am(t,e[t],f,2*t,0,1)),f.s=0,f.clamp()}function eN(f,e,t){var s=f.abs();if(!(s.t<=0)){var i=this.abs();if(i.t<s.t){e!=null&&e.fromInt(0),t!=null&&this.copyTo(t);return}t==null&&(t=Ot());var n=Ot(),r=this.s,a=f.s,o=this.DB-ql(s[s.t-1]);o>0?(s.lShiftTo(o,n),i.lShiftTo(o,t)):(s.copyTo(n),i.copyTo(t));var d=n.t,c=n[d-1];if(c!==0){var u=c*(1<<this.F1)+(d>1?n[d-2]>>this.F2:0),h=this.FV/u,l=(1<<this.F1)/u,p=1<<this.F2,m=t.t,g=m-d,y=e==null?Ot():e;for(n.dlShiftTo(g,y),t.compareTo(y)>=0&&(t[t.t++]=1,t.subTo(y,t)),Ae.ONE.dlShiftTo(d,y),y.subTo(n,n);n.t<d;)n[n.t++]=0;for(;--g>=0;){var b=t[--m]==c?this.DM:Math.floor(t[m]*h+(t[m-1]+p)*l);if((t[m]+=n.am(0,b,t,g,0,d))<b)for(n.dlShiftTo(g,y),t.subTo(y,t);t[m]<--b;)t.subTo(y,t)}e!=null&&(t.drShiftTo(d,e),r!=a&&Ae.ZERO.subTo(e,e)),t.t=d,t.clamp(),o>0&&t.rShiftTo(o,t),r<0&&Ae.ZERO.subTo(t,t)}}}function tN(f){var e=Ot();return this.abs().divRemTo(f,null,e),this.s<0&&e.compareTo(Ae.ZERO)>0&&f.subTo(e,e),e}function Vd(f){this.m=f}function sN(f){return f.s<0||f.compareTo(this.m)>=0?f.mod(this.m):f}function iN(f){return f}function nN(f){f.divRemTo(this.m,null,f)}function rN(f,e,t){f.multiplyTo(e,t),this.reduce(t)}function aN(f,e){f.squareTo(e),this.reduce(e)}Vd.prototype.convert=sN;Vd.prototype.revert=iN;Vd.prototype.reduce=nN;Vd.prototype.mulTo=rN;Vd.prototype.sqrTo=aN;function oN(){if(this.t<1)return 0;var f=this[0];if((f&1)===0)return 0;var e=f&3;return e=e*(2-(f&15)*e)&15,e=e*(2-(f&255)*e)&255,e=e*(2-((f&65535)*e&65535))&65535,e=e*(2-f*e%this.DV)%this.DV,e>0?this.DV-e:-e}function qd(f){this.m=f,this.mp=f.invDigit(),this.mpl=this.mp&32767,this.mph=this.mp>>15,this.um=(1<<f.DB-15)-1,this.mt2=2*f.t}function dN(f){var e=Ot();return f.abs().dlShiftTo(this.m.t,e),e.divRemTo(this.m,null,e),f.s<0&&e.compareTo(Ae.ZERO)>0&&this.m.subTo(e,e),e}function cN(f){var e=Ot();return f.copyTo(e),this.reduce(e),e}function uN(f){for(;f.t<=this.mt2;)f[f.t++]=0;for(var e=0;e<this.m.t;++e){var t=f[e]&32767,s=t*this.mpl+((t*this.mph+(f[e]>>15)*this.mpl&this.um)<<15)&f.DM;for(t=e+this.m.t,f[t]+=this.m.am(0,s,f,e,0,this.m.t);f[t]>=f.DV;)f[t]-=f.DV,f[++t]++}f.clamp(),f.drShiftTo(this.m.t,f),f.compareTo(this.m)>=0&&f.subTo(this.m,f)}function fN(f,e){f.squareTo(e),this.reduce(e)}function hN(f,e,t){f.multiplyTo(e,t),this.reduce(t)}qd.prototype.convert=dN;qd.prototype.revert=cN;qd.prototype.reduce=uN;qd.prototype.mulTo=hN;qd.prototype.sqrTo=fN;function lN(){return(this.t>0?this[0]&1:this.s)===0}function pN(f,e){if(f>4294967295||f<1)return Ae.ONE;var t=Ot(),s=Ot(),i=e.convert(this),n=ql(f)-1;for(i.copyTo(t);--n>=0;)if(e.sqrTo(t,s),(f&1<<n)>0)e.mulTo(s,i,t);else{var r=t;t=s,s=r}return e.revert(t)}function mN(){var f=Ot();return this.copyTo(f),f}function gN(){if(this.s<0){if(this.t==1)return this[0]-this.DV;if(this.t===0)return-1}else{if(this.t==1)return this[0];if(this.t===0)return 0}return(this[1]&(1<<32-this.DB)-1)<<this.DB|this[0]}function yN(f){return Math.floor(Math.LN2*this.DB/Math.log(f))}function bN(){return this.s<0?-1:this.t<=0||this.t==1&&this[0]<=0?0:1}function wN(f){if(f==null&&(f=10),this.signum()===0||f<2||f>36)return"0";var e=this.chunkSize(f),t=Math.pow(f,e),s=Vl(t),i=Ot(),n=Ot(),r="";for(this.divRemTo(s,i,n);i.signum()>0;)r=(t+n.intValue()).toString(f).substr(1)+r,i.divRemTo(s,i,n);return n.intValue().toString(f)+r}function kN(f,e){this.fromInt(0),e==null&&(e=10);for(var t=this.chunkSize(e),s=Math.pow(e,t),i=!1,n=0,r=0,a=0;a<f.length;++a){var o=s_(f,a);if(o<0){f.charAt(a)=="-"&&this.signum()===0&&(i=!0);continue}r=e*r+o,++n>=t&&(this.dMultiply(s),this.dAddOffset(r,0),n=0,r=0)}n>0&&(this.dMultiply(Math.pow(e,n)),this.dAddOffset(r,0)),i&&Ae.ZERO.subTo(this,this)}function SN(){var f=this.t,e=new Array;e[0]=this.s;var t=this.DB-f*this.DB%8,s,i=0;if(f-- >0)for(t<this.DB&&(s=this[f]>>t)!=(this.s&this.DM)>>t&&(e[i++]=s|this.s<<this.DB-t);f>=0;)t<8?(s=(this[f]&(1<<t)-1)<<8-t,s|=this[--f]>>(t+=this.DB-8)):(s=this[f]>>(t-=8)&255,t<=0&&(t+=this.DB,--f)),(s&128)!=0&&(s|=-256),i===0&&(this.s&128)!=(s&128)&&++i,(i>0||s!=this.s)&&(e[i++]=s);return e}function vN(f){var e=Buffer.from(this.toByteArray());if(f===!0&&e[0]===0)e=e.slice(1);else if(EE.isNumber(f)){if(e.length>f){for(var t=0;t<e.length-f;t++)if(e[t]!==0)return null;return e.slice(e.length-f)}else if(e.length<f){var s=Buffer.alloc(f);return s.fill(0,0,f-e.length),e.copy(s,f-e.length),s}}return e}function TN(f){return this.compareTo(f)==0}function ON(f){return this.compareTo(f)<0?this:f}function IN(f){return this.compareTo(f)>0?this:f}function xN(f,e,t){var s,i,n=Math.min(f.t,this.t);for(s=0;s<n;++s)t[s]=e(this[s],f[s]);if(f.t<this.t){for(i=f.s&this.DM,s=n;s<this.t;++s)t[s]=e(this[s],i);t.t=this.t}else{for(i=this.s&this.DM,s=n;s<f.t;++s)t[s]=e(i,f[s]);t.t=f.t}t.s=e(this.s,f.s),t.clamp()}function _N(f,e){return f&e}function CN(f){var e=Ot();return this.bitwiseTo(f,_N,e),e}function MN(f,e){return f|e}function PN(f){var e=Ot();return this.bitwiseTo(f,MN,e),e}function AN(f,e){return f^e}function BN(f){var e=Ot();return this.bitwiseTo(f,AN,e),e}function EN(){for(var f=Ot(),e=0;e<this.t;++e)f[e]=this.DM&~this[e];return f.t=this.t,f.s=~this.s,f}function NN(f){if(f===0)return-1;var e=0;return(f&65535)===0&&(f>>=16,e+=16),(f&255)===0&&(f>>=8,e+=8),(f&15)===0&&(f>>=4,e+=4),(f&3)===0&&(f>>=2,e+=2),(f&1)===0&&++e,e}function VN(){for(var f=0;f<this.t;++f)if(this[f]!=0)return f*this.DB+NN(this[f]);return this.s<0?this.t*this.DB:-1}function qN(f,e){for(var t=0,s=0,i=Math.min(f.t,this.t);t<i;)s+=this[t]+f[t],e[t++]=s&this.DM,s>>=this.DB;if(f.t<this.t){for(s+=f.s;t<this.t;)s+=this[t],e[t++]=s&this.DM,s>>=this.DB;s+=this.s}else{for(s+=this.s;t<f.t;)s+=f[t],e[t++]=s&this.DM,s>>=this.DB;s+=f.s}e.s=s<0?-1:0,s>0?e[t++]=s:s<-1&&(e[t++]=this.DV+s),e.t=t,e.clamp()}function LN(f){var e=Ot();return this.addTo(f,e),e}function RN(f){var e=Ot();return this.subTo(f,e),e}function FN(f){var e=Ot();return this.multiplyTo(f,e),e}function DN(){var f=Ot();return this.squareTo(f),f}function HN(f){var e=Ot();return this.divRemTo(f,e,null),e}function GN(f){var e=Ot();return this.divRemTo(f,null,e),e}function UN(f){this[this.t]=this.am(0,f-1,this,0,0,this.t),++this.t,this.clamp()}function $N(f,e){if(f!==0){for(;this.t<=e;)this[this.t++]=0;for(this[e]+=f;this[e]>=this.DV;)this[e]-=this.DV,++e>=this.t&&(this[this.t++]=0),++this[e]}}function qu(){}function i_(f){return f}function jN(f,e,t){f.multiplyTo(e,t)}function WN(f,e){f.squareTo(e)}qu.prototype.convert=i_;qu.prototype.revert=i_;qu.prototype.mulTo=jN;qu.prototype.sqrTo=WN;function zN(f){return this.exp(f,new qu)}function KN(f,e,t){var s=Math.min(this.t+f.t,e);for(t.s=0,t.t=s;s>0;)t[--s]=0;var i;for(i=t.t-this.t;s<i;++s)t[s+this.t]=this.am(0,f[s],t,s,0,this.t);for(i=Math.min(f.t,e);s<i;++s)this.am(0,f[s],t,s,0,e-s);t.clamp()}function XN(f,e,t){--e;var s=t.t=this.t+f.t-e;for(t.s=0;--s>=0;)t[s]=0;for(s=Math.max(e-this.t,0);s<f.t;++s)t[this.t+s-e]=this.am(e-s,f[s],t,0,0,this.t+s-e);t.clamp(),t.drShiftTo(1,t)}function Ld(f){this.r2=Ot(),this.q3=Ot(),Ae.ONE.dlShiftTo(2*f.t,this.r2),this.mu=this.r2.divide(f),this.m=f}function YN(f){if(f.s<0||f.t>2*this.m.t)return f.mod(this.m);if(f.compareTo(this.m)<0)return f;var e=Ot();return f.copyTo(e),this.reduce(e),e}function QN(f){return f}function ZN(f){for(f.drShiftTo(this.m.t-1,this.r2),f.t>this.m.t+1&&(f.t=this.m.t+1,f.clamp()),this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3),this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);f.compareTo(this.r2)<0;)f.dAddOffset(1,this.m.t+1);for(f.subTo(this.r2,f);f.compareTo(this.m)>=0;)f.subTo(this.m,f)}function JN(f,e){f.squareTo(e),this.reduce(e)}function e3(f,e,t){f.multiplyTo(e,t),this.reduce(t)}Ld.prototype.convert=YN;Ld.prototype.revert=QN;Ld.prototype.reduce=ZN;Ld.prototype.mulTo=e3;Ld.prototype.sqrTo=JN;function t3(f,e){var t=f.bitLength(),s,i=Vl(1),n;if(t<=0)return i;t<18?s=1:t<48?s=3:t<144?s=4:t<768?s=5:s=6,t<8?n=new Vd(e):e.isEven()?n=new Ld(e):n=new qd(e);var r=new Array,a=3,o=s-1,d=(1<<s)-1;if(r[1]=n.convert(this),s>1){var c=Ot();for(n.sqrTo(r[1],c);a<=d;)r[a]=Ot(),n.mulTo(c,r[a-2],r[a]),a+=2}var u=f.t-1,h,l=!0,p=Ot(),m;for(t=ql(f[u])-1;u>=0;){for(t>=o?h=f[u]>>t-o&d:(h=(f[u]&(1<<t+1)-1)<<o-t,u>0&&(h|=f[u-1]>>this.DB+t-o)),a=s;(h&1)===0;)h>>=1,--a;if((t-=a)<0&&(t+=this.DB,--u),l)r[h].copyTo(i),l=!1;else{for(;a>1;)n.sqrTo(i,p),n.sqrTo(p,i),a-=2;a>0?n.sqrTo(i,p):(m=i,i=p,p=m),n.mulTo(p,r[h],i)}for(;u>=0&&(f[u]&1<<t)===0;)n.sqrTo(i,p),m=i,i=p,p=m,--t<0&&(t=this.DB-1,--u)}return n.revert(i)}function s3(f){var e=this.s<0?this.negate():this.clone(),t=f.s<0?f.negate():f.clone();if(e.compareTo(t)<0){var s=e;e=t,t=s}var i=e.getLowestSetBit(),n=t.getLowestSetBit();if(n<0)return e;for(i<n&&(n=i),n>0&&(e.rShiftTo(n,e),t.rShiftTo(n,t));e.signum()>0;)(i=e.getLowestSetBit())>0&&e.rShiftTo(i,e),(i=t.getLowestSetBit())>0&&t.rShiftTo(i,t),e.compareTo(t)>=0?(e.subTo(t,e),e.rShiftTo(1,e)):(t.subTo(e,t),t.rShiftTo(1,t));return n>0&&t.lShiftTo(n,t),t}Ae.prototype.copyTo=qE;Ae.prototype.fromInt=LE;Ae.prototype.fromString=RE;Ae.prototype.fromByteArray=FE;Ae.prototype.fromBuffer=DE;Ae.prototype.clamp=HE;Ae.prototype.dlShiftTo=zE;Ae.prototype.drShiftTo=KE;Ae.prototype.lShiftTo=XE;Ae.prototype.rShiftTo=YE;Ae.prototype.subTo=QE;Ae.prototype.multiplyTo=ZE;Ae.prototype.squareTo=JE;Ae.prototype.divRemTo=eN;Ae.prototype.invDigit=oN;Ae.prototype.isEven=lN;Ae.prototype.exp=pN;Ae.prototype.chunkSize=yN;Ae.prototype.toRadix=wN;Ae.prototype.fromRadix=kN;Ae.prototype.bitwiseTo=xN;Ae.prototype.addTo=qN;Ae.prototype.dMultiply=UN;Ae.prototype.dAddOffset=$N;Ae.prototype.multiplyLowerTo=KN;Ae.prototype.multiplyUpperTo=XN;Ae.prototype.toString=GE;Ae.prototype.negate=UE;Ae.prototype.abs=$E;Ae.prototype.compareTo=jE;Ae.prototype.bitLength=WE;Ae.prototype.mod=tN;Ae.prototype.clone=mN;Ae.prototype.intValue=gN;Ae.prototype.signum=bN;Ae.prototype.toByteArray=SN;Ae.prototype.toBuffer=vN;Ae.prototype.equals=TN;Ae.prototype.min=ON;Ae.prototype.max=IN;Ae.prototype.and=CN;Ae.prototype.or=PN;Ae.prototype.xor=BN;Ae.prototype.not=EN;Ae.prototype.getLowestSetBit=VN;Ae.prototype.add=LN;Ae.prototype.subtract=RN;Ae.prototype.multiply=FN;Ae.prototype.divide=HN;Ae.prototype.remainder=GN;Ae.prototype.modPow=t3;Ae.prototype.pow=zN;Ae.prototype.gcd=s3;Ae.int2char=gy;Ae.ZERO=Vl(0);Ae.ONE=Vl(1);Ae.prototype.square=DN;var n_=Ae,wb={exports:{}},kb={exports:{}},i3=n_,n3=Bd.exports,f1={RSA_NO_PADDING:3},r3={md2:Buffer.from("3020300c06082a864886f70d020205000410","hex"),md5:Buffer.from("3020300c06082a864886f70d020505000410","hex"),sha1:Buffer.from("3021300906052b0e03021a05000414","hex"),sha224:Buffer.from("302d300d06096086480165030402040500041c","hex"),sha256:Buffer.from("3031300d060960864801650304020105000420","hex"),sha384:Buffer.from("3041300d060960864801650304020205000430","hex"),sha512:Buffer.from("3051300d060960864801650304020305000440","hex"),ripemd160:Buffer.from("3021300906052b2403020105000414","hex"),rmd160:Buffer.from("3021300906052b2403020105000414","hex")},a3={ripemd160:"rmd160"},o3="sha256";kb.exports={isEncryption:!0,isSignature:!0};kb.exports.makeScheme=function(f,e){function t(s,i){this.key=s,this.options=i}return t.prototype.maxMessageLength=function(){return this.options.encryptionSchemeOptions&&this.options.encryptionSchemeOptions.padding==f1.RSA_NO_PADDING?this.key.encryptedDataLength:this.key.encryptedDataLength-11},t.prototype.encUnPad=function(s,i){i=i||{};var n=0;if(this.options.encryptionSchemeOptions&&this.options.encryptionSchemeOptions.padding==f1.RSA_NO_PADDING){var r;return typeof s.lastIndexOf=="function"?r=s.slice(s.lastIndexOf("\0")+1,s.length):r=s.slice(String.prototype.lastIndexOf.call(s,"\0")+1,s.length),r}if(s.length<4)return null;if(i.type===1){if(s[0]!==0&&s[1]!==1)return null;for(n=3;s[n]!==0;)if(s[n]!=255||++n>=s.length)return null}else{if(s[0]!==0&&s[1]!==2)return null;for(n=3;s[n]!==0;)if(++n>=s.length)return null}return s.slice(n+1,s.length)},t.prototype.sign=function(s){var i=this.options.signingSchemeOptions.hash||o3;if(this.options.environment==="browser"){i=a3[i]||i;var n=n3[i.toUpperCase()](s.toString()),r=c3(n),a=this.pkcs1pad(r,i),o=this.key.$doPrivate(new i3(a)).toBuffer(this.key.encryptedDataLength);return o}else throw new Error("CCXT only supports browser mode :P")},t.prototype.pkcs1pad=function(s,i){var n=r3[i];if(!n)throw Error("Unsupported hash algorithm");var r=Buffer.concat([n,s]);if(r.length+10>this.key.encryptedDataLength)throw Error("Key is too short for signing algorithm ("+i+")");var a=Buffer.alloc(this.key.encryptedDataLength-r.length-1);a.fill(255,0,a.length-1),a[0]=1,a[a.length-1]=0;var o=Buffer.concat([a,r]);return o},new t(f,e)};function d3(f,e){var t=[],s=255;return e>0&&t.push(f>>>24),e>1&&t.push(f>>>16&s),e>2&&t.push(f>>>8&s),e>3&&t.push(f&s),t}function c3(f){let e;if(f.hasOwnProperty("sigBytes")&&f.hasOwnProperty("words"))e=f.sigBytes,f=f.words;else throw Error("Argument not a wordArray");const t=[];let s=[],i=0;for(;e>0;)s=d3(f[i],Math.min(4,e)),e-=s.length,t.push(s),i++;return new Buffer.from([].concat.apply([],t),"hex")}(function(f){f.exports={pkcs1:kb.exports,isEncryption:function(e){return f.exports[e]&&f.exports[e].isEncryption},isSignature:function(e){return f.exports[e]&&f.exports[e].isSignature}}})(wb);var h1=Ei._,_a=n_,u3=Ei,l1=wb.exports;t_.Key=function(){function f(){this.n=null,this.e=0,this.d=null,this.p=null,this.q=null,this.dmp1=null,this.dmq1=null,this.coeff=null}return f.prototype.setOptions=function(e){var t=l1[e.signingScheme],s=l1[e.encryptionScheme];t===s?this.signingScheme=this.encryptionScheme=s.makeScheme(this,e):(this.encryptionScheme=s.makeScheme(this,e),this.signingScheme=t.makeScheme(this,e))},f.prototype.setPrivate=function(e,t,s,i,n,r,a,o){if(e&&t&&s&&e.length>0&&(h1.isNumber(t)||t.length>0)&&s.length>0)this.n=new _a(e),this.e=h1.isNumber(t)?t:u3.get32IntFromBuffer(t,0),this.d=new _a(s),i&&n&&r&&a&&o&&(this.p=new _a(i),this.q=new _a(n),this.dmp1=new _a(r),this.dmq1=new _a(a),this.coeff=new _a(o)),this.$$recalculateCache();else throw Error("Invalid RSA private key")},f.prototype.$doPrivate=function(e){if(this.p||this.q)return e.modPow(this.d,this.n);for(var t=e.mod(this.p).modPow(this.dmp1,this.p),s=e.mod(this.q).modPow(this.dmq1,this.q);t.compareTo(s)<0;)t=t.add(this.p);return t.subtract(s).multiply(this.coeff).mod(this.p).multiply(this.q).add(s)},f.prototype.sign=function(e){return this.signingScheme.sign.apply(this.signingScheme,arguments)},f.prototype.isPrivate=function(){return this.n&&this.e&&this.d||!1},Object.defineProperty(f.prototype,"keySize",{get:function(){return this.cache.keyBitLength}}),Object.defineProperty(f.prototype,"encryptedDataLength",{get:function(){return this.cache.keyByteLength}}),Object.defineProperty(f.prototype,"maxMessageLength",{get:function(){return this.encryptionScheme.maxMessageLength()}}),f.prototype.$$recalculateCache=function(){this.cache=this.cache||{},this.cache.keyBitLength=this.n.bitLength(),this.cache.keyByteLength=this.cache.keyBitLength+6>>3},f}();var r_={exports:{}},a_={exports:{}},o_={exports:{}},d_={newInvalidAsn1Error:function(f){var e=new Error;return e.name="InvalidAsn1Error",e.message=f||"",e}},c_={EOC:0,Boolean:1,Integer:2,BitString:3,OctetString:4,Null:5,OID:6,ObjectDescriptor:7,External:8,Real:9,Enumeration:10,PDV:11,Utf8String:12,RelativeOID:13,Sequence:16,Set:17,NumericString:18,PrintableString:19,T61String:20,VideotexString:21,IA5String:22,UTCTime:23,GeneralizedTime:24,GraphicString:25,VisibleString:26,GeneralString:28,UniversalString:29,CharacterString:30,BMPString:31,Constructor:32,Context:128},f3=Et,Lu=c_,h3=d_,kd=h3.newInvalidAsn1Error;function yi(f){if(!f||!Buffer.isBuffer(f))throw new TypeError("data must be a node Buffer");this._buf=f,this._size=f.length,this._len=0,this._offset=0}Object.defineProperty(yi.prototype,"length",{enumerable:!0,get:function(){return this._len}});Object.defineProperty(yi.prototype,"offset",{enumerable:!0,get:function(){return this._offset}});Object.defineProperty(yi.prototype,"remain",{get:function(){return this._size-this._offset}});Object.defineProperty(yi.prototype,"buffer",{get:function(){return this._buf.slice(this._offset)}});yi.prototype.readByte=function(f){if(this._size-this._offset<1)return null;var e=this._buf[this._offset]&255;return f||(this._offset+=1),e};yi.prototype.peek=function(){return this.readByte(!0)};yi.prototype.readLength=function(f){if(f===void 0&&(f=this._offset),f>=this._size)return null;var e=this._buf[f++]&255;if(e===null)return null;if((e&128)===128){if(e&=127,e===0)throw kd("Indefinite length not supported");if(e>4)throw kd("encoding too long");if(this._size-f<e)return null;this._len=0;for(var t=0;t<e;t++)this._len=(this._len<<8)+(this._buf[f++]&255)}else this._len=e;return f};yi.prototype.readSequence=function(f){var e=this.peek();if(e===null)return null;if(f!==void 0&&f!==e)throw kd("Expected 0x"+f.toString(16)+": got 0x"+e.toString(16));var t=this.readLength(this._offset+1);return t===null?null:(this._offset=t,e)};yi.prototype.readInt=function(){return this._readTag(Lu.Integer)};yi.prototype.readBoolean=function(){return this._readTag(Lu.Boolean)!==0};yi.prototype.readEnumeration=function(){return this._readTag(Lu.Enumeration)};yi.prototype.readString=function(f,e){f||(f=Lu.OctetString);var t=this.peek();if(t===null)return null;if(t!==f)throw kd("Expected 0x"+f.toString(16)+": got 0x"+t.toString(16));var s=this.readLength(this._offset+1);if(s===null||this.length>this._size-s)return null;if(this._offset=s,this.length===0)return e?Buffer.alloc(0):"";var i=this._buf.slice(this._offset,this._offset+this.length);return this._offset+=this.length,e?i:i.toString("utf8")};yi.prototype.readOID=function(f){f||(f=Lu.OID);var e=this.readString(f,!0);if(e===null)return null;for(var t=[],s=0,i=0;i<e.length;i++){var n=e[i]&255;s<<=7,s+=n&127,(n&128)===0&&(t.push(s),s=0)}return s=t.shift(),t.unshift(s%40),t.unshift(s/40>>0),t.join(".")};yi.prototype._readTag=function(f){f3.ok(f!==void 0);var e=this.peek();if(e===null)return null;if(e!==f)throw kd("Expected 0x"+f.toString(16)+": got 0x"+e.toString(16));var t=this.readLength(this._offset+1);if(t===null)return null;if(this.length>4)throw kd("Integer too long: "+this.length);if(this.length>this._size-t)return null;this._offset=t;for(var s=this._buf[this._offset],i=0,n=0;n<this.length;n++)i<<=8,i|=this._buf[this._offset++]&255;return(s&128)===128&&n!==4&&(i-=1<<n*8),i>>0};var l3=yi;(function(f){var e=d_,t=c_,s=l3;f.exports={Reader:s};for(var i in t)t.hasOwnProperty(i)&&(f.exports[i]=t[i]);for(var n in e)e.hasOwnProperty(n)&&(f.exports[n]=e[n])})(o_);var p1=o_.exports,u_={Ber:p1,BerReader:p1.Reader};(function(f){var e=u_.Ber,t=Ei._,s=Ei;const i="-----BEGIN RSA PRIVATE KEY-----",n="-----END RSA PRIVATE KEY-----",r="-----BEGIN RSA PUBLIC KEY-----",a="-----END RSA PUBLIC KEY-----";f.exports={privateExport:function(o,d){d=d||{};var c=o.n.toBuffer(),u=o.d.toBuffer(),h=o.p.toBuffer(),l=o.q.toBuffer(),p=o.dmp1.toBuffer(),m=o.dmq1.toBuffer(),g=o.coeff.toBuffer(),y=c.length+u.length+h.length+l.length+p.length+m.length+g.length+512,b=new e.Writer({size:y});return b.startSequence(),b.writeInt(0),b.writeBuffer(c,2),b.writeInt(o.e),b.writeBuffer(u,2),b.writeBuffer(h,2),b.writeBuffer(l,2),b.writeBuffer(p,2),b.writeBuffer(m,2),b.writeBuffer(g,2),b.endSequence(),d.type==="der"?b.buffer:i+`
`+s.linebrk(b.buffer.toString("base64"),64)+`
`+n},privateImport:function(o,d,c){c=c||{};var u;if(c.type!=="der")if(Buffer.isBuffer(d)&&(d=d.toString("utf8")),t.isString(d)){var h=s.trimSurroundingText(d,i,n).replace(/\s+|\n\r|\n|\r$/gm,"");u=Buffer.from(h,"base64")}else throw Error("Unsupported key format");else if(Buffer.isBuffer(d))u=d;else throw Error("Unsupported key format");var l=new e.Reader(u);l.readSequence(),l.readString(2,!0),o.setPrivate(l.readString(2,!0),l.readString(2,!0),l.readString(2,!0),l.readString(2,!0),l.readString(2,!0),l.readString(2,!0),l.readString(2,!0),l.readString(2,!0))},publicExport:function(o,d){d=d||{};var c=o.n.toBuffer(),u=c.length+512,h=new e.Writer({size:u});return h.startSequence(),h.writeBuffer(c,2),h.writeInt(o.e),h.endSequence(),d.type==="der"?h.buffer:r+`
`+s.linebrk(h.buffer.toString("base64"),64)+`
`+a},publicImport:function(o,d,c){c=c||{};var u;if(c.type!=="der"){if(Buffer.isBuffer(d)&&(d=d.toString("utf8")),t.isString(d)){var h=s.trimSurroundingText(d,r,a).replace(/\s+|\n\r|\n|\r$/gm,"");u=Buffer.from(h,"base64")}}else if(Buffer.isBuffer(d))u=d;else throw Error("Unsupported key format");var l=new e.Reader(u);l.readSequence(),o.setPublic(l.readString(2,!0),l.readString(2,!0))},autoImport:function(o,d){return/^[\S\s]*-----BEGIN RSA PRIVATE KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END RSA PRIVATE KEY-----[\S\s]*$/g.test(d)?(f.exports.privateImport(o,d),!0):/^[\S\s]*-----BEGIN RSA PUBLIC KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END RSA PUBLIC KEY-----[\S\s]*$/g.test(d)?(f.exports.publicImport(o,d),!0):!1}}})(a_);var f_={exports:{}};(function(f){var e=u_.Ber,t=Ei._,s="1.2.840.113549.1.1.1",i=Ei;const n="-----BEGIN PRIVATE KEY-----",r="-----END PRIVATE KEY-----",a="-----BEGIN PUBLIC KEY-----",o="-----END PUBLIC KEY-----";f.exports={privateExport:function(d,c){c=c||{};var u=d.n.toBuffer(),h=d.d.toBuffer(),l=d.p.toBuffer(),p=d.q.toBuffer(),m=d.dmp1.toBuffer(),g=d.dmq1.toBuffer(),y=d.coeff.toBuffer(),b=u.length+h.length+l.length+p.length+m.length+g.length+y.length+512,w=new e.Writer({size:b});w.startSequence(),w.writeInt(0),w.writeBuffer(u,2),w.writeInt(d.e),w.writeBuffer(h,2),w.writeBuffer(l,2),w.writeBuffer(p,2),w.writeBuffer(m,2),w.writeBuffer(g,2),w.writeBuffer(y,2),w.endSequence();var k=new e.Writer({size:b});return k.startSequence(),k.writeInt(0),k.startSequence(),k.writeOID(s),k.writeNull(),k.endSequence(),k.writeBuffer(w.buffer,4),k.endSequence(),c.type==="der"?k.buffer:n+`
`+i.linebrk(k.buffer.toString("base64"),64)+`
`+r},privateImport:function(d,c,u){u=u||{};var h;if(u.type!=="der")if(Buffer.isBuffer(c)&&(c=c.toString("utf8")),t.isString(c)){var l=i.trimSurroundingText(c,n,r).replace("-----END PRIVATE KEY-----","").replace(/\s+|\n\r|\n|\r$/gm,"");h=Buffer.from(l,"base64")}else throw Error("Unsupported key format");else if(Buffer.isBuffer(c))h=c;else throw Error("Unsupported key format");var p=new e.Reader(h);p.readSequence(),p.readInt(0);var m=new e.Reader(p.readString(48,!0));if(m.readOID(6,!0)!==s)throw Error("Invalid Public key format");var g=new e.Reader(p.readString(4,!0));g.readSequence(),g.readString(2,!0),d.setPrivate(g.readString(2,!0),g.readString(2,!0),g.readString(2,!0),g.readString(2,!0),g.readString(2,!0),g.readString(2,!0),g.readString(2,!0),g.readString(2,!0))},publicExport:function(d,c){c=c||{};var u=d.n.toBuffer(),h=u.length+512,l=new e.Writer({size:h});l.writeByte(0),l.startSequence(),l.writeBuffer(u,2),l.writeInt(d.e),l.endSequence();var p=new e.Writer({size:h});return p.startSequence(),p.startSequence(),p.writeOID(s),p.writeNull(),p.endSequence(),p.writeBuffer(l.buffer,3),p.endSequence(),c.type==="der"?p.buffer:a+`
`+i.linebrk(p.buffer.toString("base64"),64)+`
`+o},publicImport:function(d,c,u){u=u||{};var h;if(u.type!=="der"){if(Buffer.isBuffer(c)&&(c=c.toString("utf8")),t.isString(c)){var l=i.trimSurroundingText(c,a,o).replace(/\s+|\n\r|\n|\r$/gm,"");h=Buffer.from(l,"base64")}}else if(Buffer.isBuffer(c))h=c;else throw Error("Unsupported key format");var p=new e.Reader(h);p.readSequence();var m=new e.Reader(p.readString(48,!0));if(m.readOID(6,!0)!==s)throw Error("Invalid Public key format");var g=new e.Reader(p.readString(3,!0));g.readByte(),g.readSequence(),d.setPublic(g.readString(2,!0),g.readString(2,!0))},autoImport:function(d,c){return/^[\S\s]*-----BEGIN PRIVATE KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END PRIVATE KEY-----[\S\s]*$/g.test(c)?(f.exports.privateImport(d,c),!0):/^[\S\s]*-----BEGIN PUBLIC KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END PUBLIC KEY-----[\S\s]*$/g.test(c)?(f.exports.publicImport(d,c),!0):!1}}})(f_);var h_={exports:{}};(function(f){Ei._,f.exports={privateExport:function(e,t){return{n:e.n.toBuffer(),e:e.e,d:e.d.toBuffer(),p:e.p.toBuffer(),q:e.q.toBuffer(),dmp1:e.dmp1.toBuffer(),dmq1:e.dmq1.toBuffer(),coeff:e.coeff.toBuffer()}},privateImport:function(e,t,s){if(t.n&&t.e&&t.d&&t.p&&t.q&&t.dmp1&&t.dmq1&&t.coeff)e.setPrivate(t.n,t.e,t.d,t.p,t.q,t.dmp1,t.dmq1,t.coeff);else throw Error("Invalid key data")},publicExport:function(e,t){return{n:e.n.toBuffer(),e:e.e}},publicImport:function(e,t,s){if(t.n&&t.e)e.setPublic(t.n,t.e);else throw Error("Invalid key data")},autoImport:function(e,t){return t.n&&t.e?t.d&&t.p&&t.q&&t.dmp1&&t.dmq1&&t.coeff?(f.exports.privateImport(e,t),!0):(f.exports.publicImport(e,t),!0):!1}}})(h_);(function(f){Ei._,f.exports={pkcs1:a_.exports,pkcs8:f_.exports,components:h_.exports,detectAndImport:function(e,t,s){if(s===void 0){for(var i in f.exports)if(typeof f.exports[i].autoImport=="function"&&f.exports[i].autoImport(e,t))return!0}else if(s){var n=formatParse(s);if(f.exports[n.scheme])n.keyType==="private"?f.exports[n.scheme].privateImport(e,t,n.keyOpt):f.exports[n.scheme].publicImport(e,t,n.keyOpt);else throw Error("Unsupported key format")}return!1}}})(r_);/*!
 * RSA library for Node.js
 *
 * Author: rzcoder
 * License MIT
 */var p3=t_,zi=Ei._,m1=wb.exports,m3=r_.exports,g3=function(){var f={browser:["md5","ripemd160","sha1","sha256","sha512"]},e="pkcs1",t="pkcs1",s={private:"pkcs1-private-pem","private-der":"pkcs1-private-der",public:"pkcs8-public-pem","public-der":"pkcs8-public-der"};function i(n,r,a){if(!(this instanceof i))return new i(n,r,a);zi.isObject(r)&&(a=r,r=void 0),this.$options={signingScheme:t,signingSchemeOptions:{hash:"sha256",saltLength:null},encryptionScheme:e,encryptionSchemeOptions:{hash:"sha1",label:null},environment:"browser",rsaUtils:this},this.keyPair=new p3.Key,this.$cache={},Buffer.isBuffer(n)||zi.isString(n)?this.importKey(n,r):zi.isObject(n)&&this.generateKeyPair(n.b,n.e),this.setOptions(a)}return i.prototype.setOptions=function(n){if(n=n||{},n.environment&&(this.$options.environment=n.environment),n.signingScheme){if(zi.isString(n.signingScheme)){var r=n.signingScheme.toLowerCase().split("-");r.length==1?f.node.indexOf(r[0])>-1?(this.$options.signingSchemeOptions={hash:r[0]},this.$options.signingScheme=t):(this.$options.signingScheme=r[0],this.$options.signingSchemeOptions={hash:null}):(this.$options.signingSchemeOptions={hash:r[1]},this.$options.signingScheme=r[0])}else zi.isObject(n.signingScheme)&&(this.$options.signingScheme=n.signingScheme.scheme||t,this.$options.signingSchemeOptions=zi.omit(n.signingScheme,"scheme"));if(!m1.isSignature(this.$options.signingScheme))throw Error("Unsupported signing scheme");if(this.$options.signingSchemeOptions.hash&&f[this.$options.environment].indexOf(this.$options.signingSchemeOptions.hash)===-1)throw Error("Unsupported hashing algorithm for "+this.$options.environment+" environment")}if(n.encryptionScheme){if(zi.isString(n.encryptionScheme)?(this.$options.encryptionScheme=n.encryptionScheme.toLowerCase(),this.$options.encryptionSchemeOptions={}):zi.isObject(n.encryptionScheme)&&(this.$options.encryptionScheme=n.encryptionScheme.scheme||e,this.$options.encryptionSchemeOptions=zi.omit(n.encryptionScheme,"scheme")),!m1.isEncryption(this.$options.encryptionScheme))throw Error("Unsupported encryption scheme");if(this.$options.encryptionSchemeOptions.hash&&f[this.$options.environment].indexOf(this.$options.encryptionSchemeOptions.hash)===-1)throw Error("Unsupported hashing algorithm for "+this.$options.environment+" environment")}this.keyPair.setOptions(this.$options)},i.prototype.importKey=function(n,r){if(!n)throw Error("Empty key given");if(r&&(r=s[r]||r),!m3.detectAndImport(this.keyPair,n,r)&&r===void 0)throw Error("Key format must be specified");return this.$cache={},this},i.prototype.isPrivate=function(){return this.keyPair.isPrivate()},i.prototype.isPublic=function(n){return this.keyPair.isPublic(n)},i.prototype.isEmpty=function(n){return!(this.keyPair.n||this.keyPair.e||this.keyPair.d)},i.prototype.sign=function(n,r,a){if(!this.isPrivate())throw Error("This is not private key");var o=this.keyPair.sign(this.$getDataForEncrypt(n,a));return r&&r!="buffer"&&(o=o.toString(r)),o},i.prototype.$getDataForEncrypt=function(n,r){if(zi.isString(n)||zi.isNumber(n))return Buffer.from(""+n,r||"utf8");if(Buffer.isBuffer(n))return n;if(zi.isObject(n))return Buffer.from(JSON.stringify(n));throw Error("Unexpected data type")},i}(),qp={},yo={};(function(f){var e=f,t=Ui.exports;e.assert=function(l,p){if(!l)throw new Error(p)};function s(l,p){for(var m=[],g=1<<p+1,y=l.clone();y.cmpn(1)>=0;){var b;if(y.isOdd()){var w=y.andln(g-1);w>(g>>1)-1?b=(g>>1)-w:b=w,y.isubn(b)}else b=0;m.push(b);for(var k=y.cmpn(0)!==0&&y.andln(g-1)===0?p+1:1,T=1;T<k;T++)m.push(0);y.iushrn(k)}return m}e.getNAF=s;function i(l,p){var m=[[],[]];l=l.clone(),p=p.clone();for(var g=0,y=0;l.cmpn(-g)>0||p.cmpn(-y)>0;){var b=l.andln(3)+g&3,w=p.andln(3)+y&3;b===3&&(b=-1),w===3&&(w=-1);var k;if((b&1)===0)k=0;else{var T=l.andln(7)+g&7;(T===3||T===5)&&w===2?k=-b:k=b}m[0].push(k);var O;if((w&1)===0)O=0;else{var T=p.andln(7)+y&7;(T===3||T===5)&&b===2?O=-w:O=w}m[1].push(O),2*g===k+1&&(g=1-g),2*y===O+1&&(y=1-y),l.iushrn(1),p.iushrn(1)}return m}e.getJSF=i;function n(l,p,m){var g="_"+p;l.prototype[p]=function(){return this[g]!==void 0?this[g]:this[g]=m.call(this)}}e.cachedProperty=n;function r(l){return typeof l=="string"?e.toArray(l,"hex"):l}e.parseBytes=r;function a(l){return new t(l,"hex","le")}e.intFromLE=a;function o(l,p){var m=[],g=255;return p>0&&m.push(l>>>24),p>1&&m.push(l>>>16&g),p>2&&m.push(l>>>8&g),p>3&&m.push(l&g),m}function d(l){let p;if(l.hasOwnProperty("sigBytes")&&l.hasOwnProperty("words"))p=l.sigBytes,l=l.words;else throw Error("Argument not a wordArray");const m=[];let g=[],y=0;for(;p>0;)g=o(l[y],Math.min(4,p)),p-=g.length,m.push(g),y++;return[].concat.apply([],m)}e.wordArrayToBuffer=d;function c(l,p){if(Array.isArray(l))return l.slice();if(!l)return[];var m=[];if(typeof l!="string"){for(var g=0;g<l.length;g++)m[g]=l[g]|0;return m}if(p==="hex"){l=l.replace(/[^a-z0-9]+/ig,""),l.length%2!==0&&(l="0"+l);for(var g=0;g<l.length;g+=2)m.push(parseInt(l[g]+l[g+1],16))}else for(var g=0;g<l.length;g++){var y=l.charCodeAt(g),b=y>>8,w=y&255;b?m.push(b,w):m.push(w)}return m}e.toArray=c;function u(l){return l.length===1?"0"+l:l}e.zero2=u;function h(l){for(var p="",m=0;m<l.length;m++)p+=u(l[m].toString(16));return p}e.toHex=h,e.encode=function(p,m){return m==="hex"?h(p):p}})(yo);var Lp={},Rp,g1;function y3(){if(g1)return Rp;g1=1;var f=Ui.exports,e=ir(),t=e.utils,s=t.getNAF,i=t.getJSF,n=t.assert;function r(o,d){this.type=o,this.p=new f(d.p,16),this.red=d.prime?f.red(d.prime):f.mont(this.p),this.zero=new f(0).toRed(this.red),this.one=new f(1).toRed(this.red),this.two=new f(2).toRed(this.red),this.n=d.n&&new f(d.n,16),this.g=d.g&&this.pointFromJSON(d.g,d.gRed),this._wnafT1=new Array(4),this._wnafT2=new Array(4),this._wnafT3=new Array(4),this._wnafT4=new Array(4);var c=this.n&&this.p.div(this.n);!c||c.cmpn(100)>0?this.redN=null:(this._maxwellTrick=!0,this.redN=this.n.toRed(this.red))}Rp=r,r.prototype.point=function(){throw new Error("Not implemented")},r.prototype.validate=function(){throw new Error("Not implemented")},r.prototype._fixedNafMul=function(d,c){n(d.precomputed);var u=d._getDoubles(),h=s(c,1),l=(1<<u.step+1)-(u.step%2===0?2:1);l/=3;for(var p=[],m=0;m<h.length;m+=u.step){for(var g=0,c=m+u.step-1;c>=m;c--)g=(g<<1)+h[c];p.push(g)}for(var y=this.jpoint(null,null,null),b=this.jpoint(null,null,null),w=l;w>0;w--){for(var m=0;m<p.length;m++){var g=p[m];g===w?b=b.mixedAdd(u.points[m]):g===-w&&(b=b.mixedAdd(u.points[m].neg()))}y=y.add(b)}return y.toP()},r.prototype._wnafMul=function(d,c){var u=4,h=d._getNAFPoints(u);u=h.wnd;for(var l=h.points,p=s(c,u),m=this.jpoint(null,null,null),g=p.length-1;g>=0;g--){for(var c=0;g>=0&&p[g]===0;g--)c++;if(g>=0&&c++,m=m.dblp(c),g<0)break;var y=p[g];n(y!==0),d.type==="affine"?y>0?m=m.mixedAdd(l[y-1>>1]):m=m.mixedAdd(l[-y-1>>1].neg()):y>0?m=m.add(l[y-1>>1]):m=m.add(l[-y-1>>1].neg())}return d.type==="affine"?m.toP():m},r.prototype._wnafMulAdd=function(d,c,u,h,l){for(var p=this._wnafT1,m=this._wnafT2,g=this._wnafT3,y=0,b=0;b<h;b++){var w=c[b],k=w._getNAFPoints(d);p[b]=k.wnd,m[b]=k.points}for(var b=h-1;b>=1;b-=2){var T=b-1,O=b;if(p[T]!==1||p[O]!==1){g[T]=s(u[T],p[T]),g[O]=s(u[O],p[O]),y=Math.max(g[T].length,y),y=Math.max(g[O].length,y);continue}var x=[c[T],null,null,c[O]];c[T].y.cmp(c[O].y)===0?(x[1]=c[T].add(c[O]),x[2]=c[T].toJ().mixedAdd(c[O].neg())):c[T].y.cmp(c[O].y.redNeg())===0?(x[1]=c[T].toJ().mixedAdd(c[O]),x[2]=c[T].add(c[O].neg())):(x[1]=c[T].toJ().mixedAdd(c[O]),x[2]=c[T].toJ().mixedAdd(c[O].neg()));var C=[-3,-1,-5,-7,0,7,5,1,3],E=i(u[T],u[O]);y=Math.max(E[0].length,y),g[T]=new Array(y),g[O]=new Array(y);for(var P=0;P<y;P++){var _=E[0][P]|0,S=E[1][P]|0;g[T][P]=C[(_+1)*3+(S+1)],g[O][P]=0,m[T]=x}}for(var I=this.jpoint(null,null,null),v=this._wnafT4,b=y;b>=0;b--){for(var N=0;b>=0;){for(var q=!0,P=0;P<h;P++)v[P]=g[P][b]|0,v[P]!==0&&(q=!1);if(!q)break;N++,b--}if(b>=0&&N++,I=I.dblp(N),b<0)break;for(var P=0;P<h;P++){var R=v[P],w;R!==0&&(R>0?w=m[P][R-1>>1]:R<0&&(w=m[P][-R-1>>1].neg()),w.type==="affine"?I=I.mixedAdd(w):I=I.add(w))}}for(var b=0;b<h;b++)m[b]=null;return l?I:I.toP()};function a(o,d){this.curve=o,this.type=d,this.precomputed=null}return r.BasePoint=a,a.prototype.eq=function(){throw new Error("Not implemented")},a.prototype.validate=function(){return this.curve.validate(this)},r.prototype.decodePoint=function(d,c){d=t.toArray(d,c);var u=this.p.byteLength();if((d[0]===4||d[0]===6||d[0]===7)&&d.length-1===2*u){d[0]===6?n(d[d.length-1]%2===0):d[0]===7&&n(d[d.length-1]%2===1);var h=this.point(d.slice(1,1+u),d.slice(1+u,1+2*u));return h}else if((d[0]===2||d[0]===3)&&d.length-1===u)return this.pointFromX(d.slice(1,1+u),d[0]===3);throw new Error("Unknown point format")},a.prototype.encodeCompressed=function(d){return this.encode(d,!0)},a.prototype._encode=function(d){var c=this.curve.p.byteLength(),u=this.getX().toArray("be",c);return d?[this.getY().isEven()?2:3].concat(u):[4].concat(u,this.getY().toArray("be",c))},a.prototype.encode=function(d,c){return t.encode(this._encode(c),d)},a.prototype.precompute=function(d){if(this.precomputed)return this;var c={doubles:null,naf:null,beta:null};return c.naf=this._getNAFPoints(8),c.doubles=this._getDoubles(4,d),c.beta=this._getBeta(),this.precomputed=c,this},a.prototype._hasDoubles=function(d){if(!this.precomputed)return!1;var c=this.precomputed.doubles;return c?c.points.length>=Math.ceil((d.bitLength()+1)/c.step):!1},a.prototype._getDoubles=function(d,c){if(this.precomputed&&this.precomputed.doubles)return this.precomputed.doubles;for(var u=[this],h=this,l=0;l<c;l+=d){for(var p=0;p<d;p++)h=h.dbl();u.push(h)}return{step:d,points:u}},a.prototype._getNAFPoints=function(d){if(this.precomputed&&this.precomputed.naf)return this.precomputed.naf;for(var c=[this],u=(1<<d)-1,h=u===1?null:this.dbl(),l=1;l<u;l++)c[l]=c[l-1].add(h);return{wnd:d,points:c}},a.prototype._getBeta=function(){return null},a.prototype.dblp=function(d){for(var c=this,u=0;u<d;u++)c=c.dbl();return c},Rp}var Fp,y1;function b3(){if(y1)return Fp;y1=1;var f=Ll(),e=ir(),t=Ui.exports,s=e.inherits,i=f.base,n=e.utils.assert;function r(d){i.call(this,"short",d),this.a=new t(d.a,16).toRed(this.red),this.b=new t(d.b,16).toRed(this.red),this.tinv=this.two.redInvm(),this.zeroA=this.a.fromRed().cmpn(0)===0,this.threeA=this.a.fromRed().sub(this.p).cmpn(-3)===0,this.endo=this._getEndomorphism(d),this._endoWnafT1=new Array(4),this._endoWnafT2=new Array(4)}s(r,i),Fp=r,r.prototype._getEndomorphism=function(c){if(!(!this.zeroA||!this.g||!this.n||this.p.modn(3)!==1)){var u,h;if(c.beta)u=new t(c.beta,16).toRed(this.red);else{var l=this._getEndoRoots(this.p);u=l[0].cmp(l[1])<0?l[0]:l[1],u=u.toRed(this.red)}if(c.lambda)h=new t(c.lambda,16);else{var p=this._getEndoRoots(this.n);this.g.mul(p[0]).x.cmp(this.g.x.redMul(u))===0?h=p[0]:(h=p[1],n(this.g.mul(h).x.cmp(this.g.x.redMul(u))===0))}var m;return c.basis?m=c.basis.map(function(g){return{a:new t(g.a,16),b:new t(g.b,16)}}):m=this._getEndoBasis(h),{beta:u,lambda:h,basis:m}}},r.prototype._getEndoRoots=function(c){var u=c===this.p?this.red:t.mont(c),h=new t(2).toRed(u).redInvm(),l=h.redNeg(),p=new t(3).toRed(u).redNeg().redSqrt().redMul(h),m=l.redAdd(p).fromRed(),g=l.redSub(p).fromRed();return[m,g]},r.prototype._getEndoBasis=function(c){for(var u=this.n.ushrn(Math.floor(this.n.bitLength()/2)),h=c,l=this.n.clone(),p=new t(1),m=new t(0),g=new t(0),y=new t(1),b,w,k,T,O,x,C,E=0,P,_;h.cmpn(0)!==0;){var S=l.div(h);P=l.sub(S.mul(h)),_=g.sub(S.mul(p));var I=y.sub(S.mul(m));if(!k&&P.cmp(u)<0)b=C.neg(),w=p,k=P.neg(),T=_;else if(k&&++E===2)break;C=P,l=h,h=P,g=p,p=_,y=m,m=I}O=P.neg(),x=_;var v=k.sqr().add(T.sqr()),N=O.sqr().add(x.sqr());return N.cmp(v)>=0&&(O=b,x=w),k.negative&&(k=k.neg(),T=T.neg()),O.negative&&(O=O.neg(),x=x.neg()),[{a:k,b:T},{a:O,b:x}]},r.prototype._endoSplit=function(c){var u=this.endo.basis,h=u[0],l=u[1],p=l.b.mul(c).divRound(this.n),m=h.b.neg().mul(c).divRound(this.n),g=p.mul(h.a),y=m.mul(l.a),b=p.mul(h.b),w=m.mul(l.b),k=c.sub(g).sub(y),T=b.add(w).neg();return{k1:k,k2:T}},r.prototype.pointFromX=function(c,u){c=new t(c,16),c.red||(c=c.toRed(this.red));var h=c.redSqr().redMul(c).redIAdd(c.redMul(this.a)).redIAdd(this.b),l=h.redSqrt();if(l.redSqr().redSub(h).cmp(this.zero)!==0)throw new Error("invalid point");var p=l.fromRed().isOdd();return(u&&!p||!u&&p)&&(l=l.redNeg()),this.point(c,l)},r.prototype.validate=function(c){if(c.inf)return!0;var u=c.x,h=c.y,l=this.a.redMul(u),p=u.redSqr().redMul(u).redIAdd(l).redIAdd(this.b);return h.redSqr().redISub(p).cmpn(0)===0},r.prototype._endoWnafMulAdd=function(c,u,h){for(var l=this._endoWnafT1,p=this._endoWnafT2,m=0;m<c.length;m++){var g=this._endoSplit(u[m]),y=c[m],b=y._getBeta();g.k1.negative&&(g.k1.ineg(),y=y.neg(!0)),g.k2.negative&&(g.k2.ineg(),b=b.neg(!0)),l[m*2]=y,l[m*2+1]=b,p[m*2]=g.k1,p[m*2+1]=g.k2}for(var w=this._wnafMulAdd(1,l,p,m*2,h),k=0;k<m*2;k++)l[k]=null,p[k]=null;return w};function a(d,c,u,h){i.BasePoint.call(this,d,"affine"),c===null&&u===null?(this.x=null,this.y=null,this.inf=!0):(this.x=new t(c,16),this.y=new t(u,16),h&&(this.x.forceRed(this.curve.red),this.y.forceRed(this.curve.red)),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.inf=!1)}s(a,i.BasePoint),r.prototype.point=function(c,u,h){return new a(this,c,u,h)},r.prototype.pointFromJSON=function(c,u){return a.fromJSON(this,c,u)},a.prototype._getBeta=function(){if(!!this.curve.endo){var c=this.precomputed;if(c&&c.beta)return c.beta;var u=this.curve.point(this.x.redMul(this.curve.endo.beta),this.y);if(c){var h=this.curve,l=function(p){return h.point(p.x.redMul(h.endo.beta),p.y)};c.beta=u,u.precomputed={beta:null,naf:c.naf&&{wnd:c.naf.wnd,points:c.naf.points.map(l)},doubles:c.doubles&&{step:c.doubles.step,points:c.doubles.points.map(l)}}}return u}},a.prototype.toJSON=function(){return this.precomputed?[this.x,this.y,this.precomputed&&{doubles:this.precomputed.doubles&&{step:this.precomputed.doubles.step,points:this.precomputed.doubles.points.slice(1)},naf:this.precomputed.naf&&{wnd:this.precomputed.naf.wnd,points:this.precomputed.naf.points.slice(1)}}]:[this.x,this.y]},a.fromJSON=function(c,u,h){typeof u=="string"&&(u=JSON.parse(u));var l=c.point(u[0],u[1],h);if(!u[2])return l;function p(g){return c.point(g[0],g[1],h)}var m=u[2];return l.precomputed={beta:null,doubles:m.doubles&&{step:m.doubles.step,points:[l].concat(m.doubles.points.map(p))},naf:m.naf&&{wnd:m.naf.wnd,points:[l].concat(m.naf.points.map(p))}},l},a.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" y: "+this.y.fromRed().toString(16,2)+">"},a.prototype.isInfinity=function(){return this.inf},a.prototype.add=function(c){if(this.inf)return c;if(c.inf)return this;if(this.eq(c))return this.dbl();if(this.neg().eq(c))return this.curve.point(null,null);if(this.x.cmp(c.x)===0)return this.curve.point(null,null);var u=this.y.redSub(c.y);u.cmpn(0)!==0&&(u=u.redMul(this.x.redSub(c.x).redInvm()));var h=u.redSqr().redISub(this.x).redISub(c.x),l=u.redMul(this.x.redSub(h)).redISub(this.y);return this.curve.point(h,l)},a.prototype.dbl=function(){if(this.inf)return this;var c=this.y.redAdd(this.y);if(c.cmpn(0)===0)return this.curve.point(null,null);var u=this.curve.a,h=this.x.redSqr(),l=c.redInvm(),p=h.redAdd(h).redIAdd(h).redIAdd(u).redMul(l),m=p.redSqr().redISub(this.x.redAdd(this.x)),g=p.redMul(this.x.redSub(m)).redISub(this.y);return this.curve.point(m,g)},a.prototype.getX=function(){return this.x.fromRed()},a.prototype.getY=function(){return this.y.fromRed()},a.prototype.mul=function(c){return c=new t(c,16),this._hasDoubles(c)?this.curve._fixedNafMul(this,c):this.curve.endo?this.curve._endoWnafMulAdd([this],[c]):this.curve._wnafMul(this,c)},a.prototype.mulAdd=function(c,u,h){var l=[this,u],p=[c,h];return this.curve.endo?this.curve._endoWnafMulAdd(l,p):this.curve._wnafMulAdd(1,l,p,2)},a.prototype.jmulAdd=function(c,u,h){var l=[this,u],p=[c,h];return this.curve.endo?this.curve._endoWnafMulAdd(l,p,!0):this.curve._wnafMulAdd(1,l,p,2,!0)},a.prototype.eq=function(c){return this===c||this.inf===c.inf&&(this.inf||this.x.cmp(c.x)===0&&this.y.cmp(c.y)===0)},a.prototype.neg=function(c){if(this.inf)return this;var u=this.curve.point(this.x,this.y.redNeg());if(c&&this.precomputed){var h=this.precomputed,l=function(p){return p.neg()};u.precomputed={naf:h.naf&&{wnd:h.naf.wnd,points:h.naf.points.map(l)},doubles:h.doubles&&{step:h.doubles.step,points:h.doubles.points.map(l)}}}return u},a.prototype.toJ=function(){if(this.inf)return this.curve.jpoint(null,null,null);var c=this.curve.jpoint(this.x,this.y,this.curve.one);return c};function o(d,c,u,h){i.BasePoint.call(this,d,"jacobian"),c===null&&u===null&&h===null?(this.x=this.curve.one,this.y=this.curve.one,this.z=new t(0)):(this.x=new t(c,16),this.y=new t(u,16),this.z=new t(h,16)),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)),this.zOne=this.z===this.curve.one}return s(o,i.BasePoint),r.prototype.jpoint=function(c,u,h){return new o(this,c,u,h)},o.prototype.toP=function(){if(this.isInfinity())return this.curve.point(null,null);var c=this.z.redInvm(),u=c.redSqr(),h=this.x.redMul(u),l=this.y.redMul(u).redMul(c);return this.curve.point(h,l)},o.prototype.neg=function(){return this.curve.jpoint(this.x,this.y.redNeg(),this.z)},o.prototype.add=function(c){if(this.isInfinity())return c;if(c.isInfinity())return this;var u=c.z.redSqr(),h=this.z.redSqr(),l=this.x.redMul(u),p=c.x.redMul(h),m=this.y.redMul(u.redMul(c.z)),g=c.y.redMul(h.redMul(this.z)),y=l.redSub(p),b=m.redSub(g);if(y.cmpn(0)===0)return b.cmpn(0)!==0?this.curve.jpoint(null,null,null):this.dbl();var w=y.redSqr(),k=w.redMul(y),T=l.redMul(w),O=b.redSqr().redIAdd(k).redISub(T).redISub(T),x=b.redMul(T.redISub(O)).redISub(m.redMul(k)),C=this.z.redMul(c.z).redMul(y);return this.curve.jpoint(O,x,C)},o.prototype.mixedAdd=function(c){if(this.isInfinity())return c.toJ();if(c.isInfinity())return this;var u=this.z.redSqr(),h=this.x,l=c.x.redMul(u),p=this.y,m=c.y.redMul(u).redMul(this.z),g=h.redSub(l),y=p.redSub(m);if(g.cmpn(0)===0)return y.cmpn(0)!==0?this.curve.jpoint(null,null,null):this.dbl();var b=g.redSqr(),w=b.redMul(g),k=h.redMul(b),T=y.redSqr().redIAdd(w).redISub(k).redISub(k),O=y.redMul(k.redISub(T)).redISub(p.redMul(w)),x=this.z.redMul(g);return this.curve.jpoint(T,O,x)},o.prototype.dblp=function(c){if(c===0)return this;if(this.isInfinity())return this;if(!c)return this.dbl();if(this.curve.zeroA||this.curve.threeA){for(var u=this,h=0;h<c;h++)u=u.dbl();return u}for(var l=this.curve.a,p=this.curve.tinv,m=this.x,g=this.y,y=this.z,b=y.redSqr().redSqr(),w=g.redAdd(g),h=0;h<c;h++){var k=m.redSqr(),T=w.redSqr(),O=T.redSqr(),x=k.redAdd(k).redIAdd(k).redIAdd(l.redMul(b)),C=m.redMul(T),E=x.redSqr().redISub(C.redAdd(C)),P=C.redISub(E),_=x.redMul(P);_=_.redIAdd(_).redISub(O);var S=w.redMul(y);h+1<c&&(b=b.redMul(O)),m=E,y=S,w=_}return this.curve.jpoint(m,w.redMul(p),y)},o.prototype.dbl=function(){return this.isInfinity()?this:this.curve.zeroA?this._zeroDbl():this.curve.threeA?this._threeDbl():this._dbl()},o.prototype._zeroDbl=function(){var c,u,h;if(this.zOne){var l=this.x.redSqr(),p=this.y.redSqr(),m=p.redSqr(),g=this.x.redAdd(p).redSqr().redISub(l).redISub(m);g=g.redIAdd(g);var y=l.redAdd(l).redIAdd(l),b=y.redSqr().redISub(g).redISub(g),w=m.redIAdd(m);w=w.redIAdd(w),w=w.redIAdd(w),c=b,u=y.redMul(g.redISub(b)).redISub(w),h=this.y.redAdd(this.y)}else{var k=this.x.redSqr(),T=this.y.redSqr(),O=T.redSqr(),x=this.x.redAdd(T).redSqr().redISub(k).redISub(O);x=x.redIAdd(x);var C=k.redAdd(k).redIAdd(k),E=C.redSqr(),P=O.redIAdd(O);P=P.redIAdd(P),P=P.redIAdd(P),c=E.redISub(x).redISub(x),u=C.redMul(x.redISub(c)).redISub(P),h=this.y.redMul(this.z),h=h.redIAdd(h)}return this.curve.jpoint(c,u,h)},o.prototype._threeDbl=function(){var c,u,h;if(this.zOne){var l=this.x.redSqr(),p=this.y.redSqr(),m=p.redSqr(),g=this.x.redAdd(p).redSqr().redISub(l).redISub(m);g=g.redIAdd(g);var y=l.redAdd(l).redIAdd(l).redIAdd(this.curve.a),b=y.redSqr().redISub(g).redISub(g);c=b;var w=m.redIAdd(m);w=w.redIAdd(w),w=w.redIAdd(w),u=y.redMul(g.redISub(b)).redISub(w),h=this.y.redAdd(this.y)}else{var k=this.z.redSqr(),T=this.y.redSqr(),O=this.x.redMul(T),x=this.x.redSub(k).redMul(this.x.redAdd(k));x=x.redAdd(x).redIAdd(x);var C=O.redIAdd(O);C=C.redIAdd(C);var E=C.redAdd(C);c=x.redSqr().redISub(E),h=this.y.redAdd(this.z).redSqr().redISub(T).redISub(k);var P=T.redSqr();P=P.redIAdd(P),P=P.redIAdd(P),P=P.redIAdd(P),u=x.redMul(C.redISub(c)).redISub(P)}return this.curve.jpoint(c,u,h)},o.prototype._dbl=function(){var c=this.curve.a,u=this.x,h=this.y,l=this.z,p=l.redSqr().redSqr(),m=u.redSqr(),g=h.redSqr(),y=m.redAdd(m).redIAdd(m).redIAdd(c.redMul(p)),b=u.redAdd(u);b=b.redIAdd(b);var w=b.redMul(g),k=y.redSqr().redISub(w.redAdd(w)),T=w.redISub(k),O=g.redSqr();O=O.redIAdd(O),O=O.redIAdd(O),O=O.redIAdd(O);var x=y.redMul(T).redISub(O),C=h.redAdd(h).redMul(l);return this.curve.jpoint(k,x,C)},o.prototype.trpl=function(){if(!this.curve.zeroA)return this.dbl().add(this);var c=this.x.redSqr(),u=this.y.redSqr(),h=this.z.redSqr(),l=u.redSqr(),p=c.redAdd(c).redIAdd(c),m=p.redSqr(),g=this.x.redAdd(u).redSqr().redISub(c).redISub(l);g=g.redIAdd(g),g=g.redAdd(g).redIAdd(g),g=g.redISub(m);var y=g.redSqr(),b=l.redIAdd(l);b=b.redIAdd(b),b=b.redIAdd(b),b=b.redIAdd(b);var w=p.redIAdd(g).redSqr().redISub(m).redISub(y).redISub(b),k=u.redMul(w);k=k.redIAdd(k),k=k.redIAdd(k);var T=this.x.redMul(y).redISub(k);T=T.redIAdd(T),T=T.redIAdd(T);var O=this.y.redMul(w.redMul(b.redISub(w)).redISub(g.redMul(y)));O=O.redIAdd(O),O=O.redIAdd(O),O=O.redIAdd(O);var x=this.z.redAdd(g).redSqr().redISub(h).redISub(y);return this.curve.jpoint(T,O,x)},o.prototype.mul=function(c,u){return c=new t(c,u),this.curve._wnafMul(this,c)},o.prototype.eq=function(c){if(c.type==="affine")return this.eq(c.toJ());if(this===c)return!0;var u=this.z.redSqr(),h=c.z.redSqr();if(this.x.redMul(h).redISub(c.x.redMul(u)).cmpn(0)!==0)return!1;var l=u.redMul(this.z),p=h.redMul(c.z);return this.y.redMul(p).redISub(c.y.redMul(l)).cmpn(0)===0},o.prototype.eqXToP=function(c){var u=this.z.redSqr(),h=c.toRed(this.curve.red).redMul(u);if(this.x.cmp(h)===0)return!0;for(var l=c.clone(),p=this.curve.redN.redMul(u);;){if(l.iadd(this.curve.n),l.cmp(this.curve.p)>=0)return!1;if(h.redIAdd(p),this.x.cmp(h)===0)return!0}return!1},o.prototype.inspect=function(){return this.isInfinity()?"<EC JPoint Infinity>":"<EC JPoint x: "+this.x.toString(16,2)+" y: "+this.y.toString(16,2)+" z: "+this.z.toString(16,2)+">"},o.prototype.isInfinity=function(){return this.z.cmpn(0)===0},Fp}var Dp,b1;function w3(){if(b1)return Dp;b1=1;var f=Ll(),e=Ui.exports,t=ir().inherits,s=f.base,i=ir(),n=i.utils;function r(o){s.call(this,"mont",o),this.a=new e(o.a,16).toRed(this.red),this.b=new e(o.b,16).toRed(this.red),this.i4=new e(4).toRed(this.red).redInvm(),this.two=new e(2).toRed(this.red),this.a24=this.i4.redMul(this.a.redAdd(this.two))}t(r,s),Dp=r,r.prototype.validate=function(d){var c=d.normalize().x,u=c.redSqr(),h=u.redMul(c).redAdd(u.redMul(this.a)).redAdd(c),l=h.redSqrt();return l.redSqr().cmp(h)===0};function a(o,d,c){s.BasePoint.call(this,o,"projective"),d===null&&c===null?(this.x=this.curve.one,this.z=this.curve.zero):(this.x=new e(d,16),this.z=new e(c,16),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)))}return t(a,s.BasePoint),r.prototype.decodePoint=function(d,c){return this.point(n.toArray(d,c),1)},r.prototype.point=function(d,c){return new a(this,d,c)},r.prototype.pointFromJSON=function(d){return a.fromJSON(this,d)},a.prototype.precompute=function(){},a.prototype._encode=function(){return this.getX().toArray("be",this.curve.p.byteLength())},a.fromJSON=function(d,c){return new a(d,c[0],c[1]||d.one)},a.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" z: "+this.z.fromRed().toString(16,2)+">"},a.prototype.isInfinity=function(){return this.z.cmpn(0)===0},a.prototype.dbl=function(){var d=this.x.redAdd(this.z),c=d.redSqr(),u=this.x.redSub(this.z),h=u.redSqr(),l=c.redSub(h),p=c.redMul(h),m=l.redMul(h.redAdd(this.curve.a24.redMul(l)));return this.curve.point(p,m)},a.prototype.add=function(){throw new Error("Not supported on Montgomery curve")},a.prototype.diffAdd=function(d,c){var u=this.x.redAdd(this.z),h=this.x.redSub(this.z),l=d.x.redAdd(d.z),p=d.x.redSub(d.z),m=p.redMul(u),g=l.redMul(h),y=c.z.redMul(m.redAdd(g).redSqr()),b=c.x.redMul(m.redISub(g).redSqr());return this.curve.point(y,b)},a.prototype.mul=function(d){for(var c=d.clone(),u=this,h=this.curve.point(null,null),l=this,p=[];c.cmpn(0)!==0;c.iushrn(1))p.push(c.andln(1));for(var m=p.length-1;m>=0;m--)p[m]===0?(u=u.diffAdd(h,l),h=h.dbl()):(h=u.diffAdd(h,l),u=u.dbl());return h},a.prototype.mulAdd=function(){throw new Error("Not supported on Montgomery curve")},a.prototype.jumlAdd=function(){throw new Error("Not supported on Montgomery curve")},a.prototype.eq=function(d){return this.getX().cmp(d.getX())===0},a.prototype.normalize=function(){return this.x=this.x.redMul(this.z.redInvm()),this.z=this.curve.one,this},a.prototype.getX=function(){return this.normalize(),this.x.fromRed()},Dp}var Hp,w1;function k3(){if(w1)return Hp;w1=1;var f=Ll(),e=ir(),t=Ui.exports,s=e.inherits,i=f.base,n=e.utils.assert;function r(o){this.twisted=(o.a|0)!==1,this.mOneA=this.twisted&&(o.a|0)===-1,this.extended=this.mOneA,i.call(this,"edwards",o),this.a=new t(o.a,16).umod(this.red.m),this.a=this.a.toRed(this.red),this.c=new t(o.c,16).toRed(this.red),this.c2=this.c.redSqr(),this.d=new t(o.d,16).toRed(this.red),this.dd=this.d.redAdd(this.d),n(!this.twisted||this.c.fromRed().cmpn(1)===0),this.oneC=(o.c|0)===1}s(r,i),Hp=r,r.prototype._mulA=function(d){return this.mOneA?d.redNeg():this.a.redMul(d)},r.prototype._mulC=function(d){return this.oneC?d:this.c.redMul(d)},r.prototype.jpoint=function(d,c,u,h){return this.point(d,c,u,h)},r.prototype.pointFromX=function(d,c){d=new t(d,16),d.red||(d=d.toRed(this.red));var u=d.redSqr(),h=this.c2.redSub(this.a.redMul(u)),l=this.one.redSub(this.c2.redMul(this.d).redMul(u)),p=h.redMul(l.redInvm()),m=p.redSqrt();if(m.redSqr().redSub(p).cmp(this.zero)!==0)throw new Error("invalid point");var g=m.fromRed().isOdd();return(c&&!g||!c&&g)&&(m=m.redNeg()),this.point(d,m)},r.prototype.pointFromY=function(d,c){d=new t(d,16),d.red||(d=d.toRed(this.red));var u=d.redSqr(),h=u.redSub(this.one),l=u.redMul(this.d).redAdd(this.one),p=h.redMul(l.redInvm());if(p.cmp(this.zero)===0){if(c)throw new Error("invalid point");return this.point(this.zero,d)}var m=p.redSqrt();if(m.redSqr().redSub(p).cmp(this.zero)!==0)throw new Error("invalid point");return m.isOdd()!==c&&(m=m.redNeg()),this.point(m,d)},r.prototype.validate=function(d){if(d.isInfinity())return!0;d.normalize();var c=d.x.redSqr(),u=d.y.redSqr(),h=c.redMul(this.a).redAdd(u),l=this.c2.redMul(this.one.redAdd(this.d.redMul(c).redMul(u)));return h.cmp(l)===0};function a(o,d,c,u,h){i.BasePoint.call(this,o,"projective"),d===null&&c===null&&u===null?(this.x=this.curve.zero,this.y=this.curve.one,this.z=this.curve.one,this.t=this.curve.zero,this.zOne=!0):(this.x=new t(d,16),this.y=new t(c,16),this.z=u?new t(u,16):this.curve.one,this.t=h&&new t(h,16),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)),this.t&&!this.t.red&&(this.t=this.t.toRed(this.curve.red)),this.zOne=this.z===this.curve.one,this.curve.extended&&!this.t&&(this.t=this.x.redMul(this.y),this.zOne||(this.t=this.t.redMul(this.z.redInvm()))))}return s(a,i.BasePoint),r.prototype.pointFromJSON=function(d){return a.fromJSON(this,d)},r.prototype.point=function(d,c,u,h){return new a(this,d,c,u,h)},a.fromJSON=function(d,c){return new a(d,c[0],c[1],c[2])},a.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" y: "+this.y.fromRed().toString(16,2)+" z: "+this.z.fromRed().toString(16,2)+">"},a.prototype.isInfinity=function(){return this.x.cmpn(0)===0&&this.y.cmp(this.z)===0},a.prototype._extDbl=function(){var d=this.x.redSqr(),c=this.y.redSqr(),u=this.z.redSqr();u=u.redIAdd(u);var h=this.curve._mulA(d),l=this.x.redAdd(this.y).redSqr().redISub(d).redISub(c),p=h.redAdd(c),m=p.redSub(u),g=h.redSub(c),y=l.redMul(m),b=p.redMul(g),w=l.redMul(g),k=m.redMul(p);return this.curve.point(y,b,k,w)},a.prototype._projDbl=function(){var d=this.x.redAdd(this.y).redSqr(),c=this.x.redSqr(),u=this.y.redSqr(),h,l,p;if(this.curve.twisted){var m=this.curve._mulA(c),g=m.redAdd(u);if(this.zOne)h=d.redSub(c).redSub(u).redMul(g.redSub(this.curve.two)),l=g.redMul(m.redSub(u)),p=g.redSqr().redSub(g).redSub(g);else{var y=this.z.redSqr(),b=g.redSub(y).redISub(y);h=d.redSub(c).redISub(u).redMul(b),l=g.redMul(m.redSub(u)),p=g.redMul(b)}}else{var m=c.redAdd(u),y=this.curve._mulC(this.c.redMul(this.z)).redSqr(),b=m.redSub(y).redSub(y);h=this.curve._mulC(d.redISub(m)).redMul(b),l=this.curve._mulC(m).redMul(c.redISub(u)),p=m.redMul(b)}return this.curve.point(h,l,p)},a.prototype.dbl=function(){return this.isInfinity()?this:this.curve.extended?this._extDbl():this._projDbl()},a.prototype._extAdd=function(d){var c=this.y.redSub(this.x).redMul(d.y.redSub(d.x)),u=this.y.redAdd(this.x).redMul(d.y.redAdd(d.x)),h=this.t.redMul(this.curve.dd).redMul(d.t),l=this.z.redMul(d.z.redAdd(d.z)),p=u.redSub(c),m=l.redSub(h),g=l.redAdd(h),y=u.redAdd(c),b=p.redMul(m),w=g.redMul(y),k=p.redMul(y),T=m.redMul(g);return this.curve.point(b,w,T,k)},a.prototype._projAdd=function(d){var c=this.z.redMul(d.z),u=c.redSqr(),h=this.x.redMul(d.x),l=this.y.redMul(d.y),p=this.curve.d.redMul(h).redMul(l),m=u.redSub(p),g=u.redAdd(p),y=this.x.redAdd(this.y).redMul(d.x.redAdd(d.y)).redISub(h).redISub(l),b=c.redMul(m).redMul(y),w,k;return this.curve.twisted?(w=c.redMul(g).redMul(l.redSub(this.curve._mulA(h))),k=m.redMul(g)):(w=c.redMul(g).redMul(l.redSub(h)),k=this.curve._mulC(m).redMul(g)),this.curve.point(b,w,k)},a.prototype.add=function(d){return this.isInfinity()?d:d.isInfinity()?this:this.curve.extended?this._extAdd(d):this._projAdd(d)},a.prototype.mul=function(d){return this._hasDoubles(d)?this.curve._fixedNafMul(this,d):this.curve._wnafMul(this,d)},a.prototype.mulAdd=function(d,c,u){return this.curve._wnafMulAdd(1,[this,c],[d,u],2,!1)},a.prototype.jmulAdd=function(d,c,u){return this.curve._wnafMulAdd(1,[this,c],[d,u],2,!0)},a.prototype.normalize=function(){if(this.zOne)return this;var d=this.z.redInvm();return this.x=this.x.redMul(d),this.y=this.y.redMul(d),this.t&&(this.t=this.t.redMul(d)),this.z=this.curve.one,this.zOne=!0,this},a.prototype.neg=function(){return this.curve.point(this.x.redNeg(),this.y,this.z,this.t&&this.t.redNeg())},a.prototype.getX=function(){return this.normalize(),this.x.fromRed()},a.prototype.getY=function(){return this.normalize(),this.y.fromRed()},a.prototype.eq=function(d){return this===d||this.getX().cmp(d.getX())===0&&this.getY().cmp(d.getY())===0},a.prototype.eqXToP=function(d){var c=d.toRed(this.curve.red).redMul(this.z);if(this.x.cmp(c)===0)return!0;for(var u=d.clone(),h=this.curve.redN.redMul(this.z);;){if(u.iadd(this.curve.n),u.cmp(this.curve.p)>=0)return!1;if(c.redIAdd(h),this.x.cmp(c)===0)return!0}return!1},a.prototype.toP=a.prototype.normalize,a.prototype.mixedAdd=a.prototype.add,Hp}var k1;function Ll(){return k1||(k1=1,function(f){var e=f;e.base=y3(),e.short=b3(),e.mont=w3(),e.edwards=k3()}(Lp)),Lp}var Gp={},Up,S1;function S3(){return S1||(S1=1,Up={doubles:{step:4,points:[["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a","f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"],["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508","11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"],["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739","d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"],["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640","4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"],["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c","4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"],["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda","96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"],["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa","5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"],["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0","cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"],["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d","9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"],["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d","e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"],["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1","9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"],["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0","5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"],["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047","10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"],["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862","283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"],["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7","7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"],["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd","56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"],["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83","7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"],["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a","53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"],["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8","bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"],["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d","4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"],["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725","7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"],["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754","4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"],["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c","17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"],["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6","6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"],["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39","c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"],["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891","893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"],["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b","febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"],["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03","2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"],["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d","eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"],["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070","7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"],["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4","e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"],["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da","662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"],["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11","1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"],["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e","efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"],["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41","2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"],["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef","67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"],["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8","db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"],["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d","648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"],["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96","35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"],["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd","ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"],["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5","9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"],["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266","40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"],["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71","34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"],["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac","c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"],["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751","1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"],["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e","493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"],["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241","c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"],["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3","be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"],["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f","4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"],["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19","aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"],["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be","b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"],["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9","6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"],["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2","8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"],["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13","7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"],["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c","ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"],["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba","2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"],["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151","e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"],["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073","d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"],["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458","38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"],["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b","69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"],["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366","d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"],["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa","40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"],["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0","620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"],["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787","7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"],["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e","ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]]},naf:{wnd:7,points:[["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9","388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"],["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4","d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"],["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc","6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"],["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe","cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"],["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb","d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"],["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8","ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"],["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e","581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"],["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34","4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"],["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c","85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"],["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5","321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"],["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f","2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"],["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714","73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"],["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729","a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"],["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db","2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"],["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4","e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"],["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5","b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"],["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479","2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"],["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d","80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"],["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f","1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"],["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb","d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"],["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9","eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"],["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963","758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"],["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74","958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"],["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530","e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"],["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b","5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"],["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247","cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"],["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1","cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"],["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120","4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"],["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435","91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"],["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18","673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"],["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8","59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"],["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb","3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"],["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f","55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"],["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143","efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"],["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba","e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"],["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45","f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"],["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a","744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"],["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e","c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"],["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8","e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"],["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c","30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"],["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519","e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"],["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab","100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"],["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca","ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"],["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf","8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"],["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610","68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"],["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4","f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"],["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c","d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"],["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940","edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"],["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980","a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"],["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3","66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"],["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf","9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"],["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63","4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"],["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448","fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"],["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf","5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"],["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5","8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"],["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6","8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"],["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5","5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"],["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99","f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"],["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51","f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"],["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5","42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"],["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5","204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"],["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997","4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"],["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881","73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"],["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5","39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"],["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66","d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"],["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726","ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"],["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede","6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"],["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94","60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"],["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31","3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"],["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51","b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"],["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252","ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"],["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5","cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"],["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b","6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"],["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4","322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"],["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f","6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"],["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889","2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"],["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246","b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"],["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984","998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"],["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a","b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"],["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030","bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"],["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197","6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"],["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593","c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"],["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef","21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"],["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38","60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"],["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a","49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"],["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111","5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"],["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502","7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"],["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea","be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"],["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26","8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"],["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986","39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"],["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e","62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"],["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4","25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"],["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda","ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"],["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859","cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"],["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f","f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"],["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c","6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"],["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942","fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"],["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a","1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"],["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80","5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"],["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d","438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"],["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1","cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"],["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63","c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"],["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352","6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"],["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193","ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"],["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00","9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"],["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58","ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"],["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7","d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"],["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8","c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"],["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e","67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"],["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d","cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"],["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b","299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"],["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f","f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"],["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6","462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"],["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297","62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"],["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a","7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"],["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c","ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"],["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52","4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"],["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb","bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"],["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065","bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"],["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917","603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"],["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9","cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"],["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3","553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"],["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57","712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"],["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66","ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"],["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8","9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"],["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721","9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"],["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180","4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]]}}),Up}var v1;function l_(){return v1||(v1=1,function(f){var e=f,t=ir(),s=t.utils.assert;function i(a){a.type==="short"?this.curve=new t.curve.short(a):a.type==="edwards"?this.curve=new t.curve.edwards(a):this.curve=new t.curve.mont(a),this.g=this.curve.g,this.n=this.curve.n,this.hash=a.hash,s(this.g.validate(),"Invalid curve"),s(this.g.mul(this.n).isInfinity(),"Invalid curve, G*N != O")}e.PresetCurve=i;function n(a,o){Object.defineProperty(e,a,{configurable:!0,enumerable:!0,get:function(){var d=new i(o);return Object.defineProperty(e,a,{configurable:!0,enumerable:!0,value:d}),d}})}n("p192",{type:"short",prime:"p192",p:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",a:"ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",b:"64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",n:"ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",hash:"SHA256",gRed:!1,g:["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012","07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]}),n("p224",{type:"short",prime:"p224",p:"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",a:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",b:"b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",n:"ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",hash:"SHA256",gRed:!1,g:["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21","bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]}),n("p256",{type:"short",prime:null,p:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",a:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",b:"5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",n:"ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",hash:"SHA256",gRed:!1,g:["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296","4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]}),n("p384",{type:"short",prime:null,p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",a:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",b:"b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",n:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",hash:"SHA384",gRed:!1,g:["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7","3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]}),n("p521",{type:"short",prime:null,p:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",a:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",b:"00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",n:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",hash:"SHA512",gRed:!1,g:["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66","00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]}),n("curve25519",{type:"mont",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"76d06",b:"1",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",hash:"SHA256",gRed:!1,g:["9"]}),n("ed25519",{type:"edwards",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"-1",c:"1",d:"52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",hash:"SHA256",gRed:!1,g:["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a","6666666666666666666666666666666666666666666666666666666666666658"]});var r;try{r=S3()}catch{r=void 0}n("secp256k1",{type:"short",prime:"k256",p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",a:"0",b:"7",n:"ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",h:"1",hash:"SHA256",beta:"7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",lambda:"5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",basis:[{a:"3086d221a7d46bcde86c90e49284eb15",b:"-e4437ed6010e88286f547fa90abfe4c3"},{a:"114ca50f7a8e2f3f657c1108d9d44cfd8",b:"3086d221a7d46bcde86c90e49284eb15"}],gRed:!1,g:["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798","483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",r]})}(Gp)),Gp}var fn=Bd.exports,p_=yo.assert,v3=yo,{byteArrayToWordArray:T1}=Ad.exports;const T3=fn.enc.Utf8.parse(""),O3=fn.enc.Utf8.parse("\0");function wa(f){if(!(this instanceof wa))return new wa(f);this.hash=f.hash,this.predResist=!!f.predResist,this.outLen=this.hash.slice(3,6),this.minEntropy=f.minEntropy||192,this._reseed=null,this.reseedInterval=null,this.K=null,this.V=null;var e=f.entropy,t=f.nonce,s=[];p_(e.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits"),this._init(e,t,s)}var I3=wa;wa.prototype._init=function(e,t,s){var i=e.concat(t).concat(s);this.K=new fn.lib.WordArray.init,this.V=new fn.lib.WordArray.init;const n=(1<<24)+(1<<16)+(1<<8)+1;this.V.words=Array(this.outLen/32).fill(n),this.V.sigBytes=32,this._update(i),this._reseed=1,this.reseedInterval=281474976710656};wa.prototype._hmac=function(){return new fn.lib.WordArray.init};wa.prototype._update=function(e){var t=this._hmac();t.concat(this.V),t.concat(O3),e&&t.concat(T1(e)),this.K=fn["Hmac"+this.hash](t,this.K),this.V=fn["Hmac"+this.hash](this.V,this.K),e&&(t=this._hmac(),t.concat(this.V),t.concat(T3),t.concat(T1(e)),this.K=fn["Hmac"+this.hash](t,this.K),this.V=fn["Hmac"+this.hash](this.V,this.K))};wa.prototype.reseed=function(e,t,s,i){typeof t!="string"&&(s=t,t=null),p_(e.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits"),this._update(e.concat(s||[])),this._reseed=1};wa.prototype.generate=function(e,t,s,i){if(this._reseed>this.reseedInterval)throw new Error("Reseed is required");typeof t!="string"&&(s=t,t=null),s&&(s=fn.enc.Utf8.parse(s),this._update(s));for(var n=new fn.lib.WordArray.init;n.sigBytes<e;)this.V=fn["Hmac"+this.hash](this.V,this.K),n.concat(this.V);return this._update(s),this._reseed++,v3.wordArrayToBuffer(n)};var $p,O1;function x3(){if(O1)return $p;O1=1;var f=Ui.exports,e=ir(),t=e.utils,s=t.assert;function i(n,r){this.ec=n,this.priv=null,this.pub=null,r.priv&&this._importPrivate(r.priv,r.privEnc),r.pub&&this._importPublic(r.pub,r.pubEnc)}return $p=i,i.fromPublic=function(r,a,o){return a instanceof i?a:new i(r,{pub:a,pubEnc:o})},i.fromPrivate=function(r,a,o){return a instanceof i?a:new i(r,{priv:a,privEnc:o})},i.prototype.validate=function(){var r=this.getPublic();return r.isInfinity()?{result:!1,reason:"Invalid public key"}:r.validate()?r.mul(this.ec.curve.n).isInfinity()?{result:!0,reason:null}:{result:!1,reason:"Public key * N != O"}:{result:!1,reason:"Public key is not a point"}},i.prototype.getPublic=function(r,a){return typeof r=="string"&&(a=r,r=null),this.pub||(this.pub=this.ec.g.mul(this.priv)),a?this.pub.encode(a,r):this.pub},i.prototype.getPrivate=function(r){return r==="hex"?this.priv.toString(16,2):this.priv},i.prototype._importPrivate=function(r,a){this.priv=new f(r,a||16),this.priv=this.priv.umod(this.ec.curve.n)},i.prototype._importPublic=function(r,a){if(r.x||r.y){this.ec.curve.type==="mont"?s(r.x,"Need x coordinate"):(this.ec.curve.type==="short"||this.ec.curve.type==="edwards")&&s(r.x&&r.y,"Need both x and y coordinate"),this.pub=this.ec.curve.point(r.x,r.y);return}this.pub=this.ec.curve.decodePoint(r,a)},i.prototype.derive=function(r){return r.mul(this.priv).getX()},i.prototype.sign=function(r,a,o){return this.ec.sign(r,this,a,o)},i.prototype.verify=function(r,a){return this.ec.verify(r,a,this)},i.prototype.inspect=function(){return"<Key priv: "+(this.priv&&this.priv.toString(16,2))+" pub: "+(this.pub&&this.pub.inspect())+" >"},$p}var jp,I1;function _3(){if(I1)return jp;I1=1;var f=Ui.exports,e=ir(),t=e.utils,s=t.assert;function i(n,r){if(n instanceof i)return n;s(n.r&&n.s,"Signature without r or s"),this.r=new f(n.r,16),this.s=new f(n.s,16),n.recoveryParam===void 0?this.recoveryParam=null:this.recoveryParam=n.recoveryParam}return jp=i,jp}var Wp,x1;function C3(){if(x1)return Wp;x1=1;var f=Ui.exports,e=I3,t=ir(),s=t.utils,i=s.assert,n=x3(),r=_3();function a(o){if(!(this instanceof a))return new a(o);typeof o=="string"&&(i(t.curves.hasOwnProperty(o),"Unknown curve "+o),o=t.curves[o]),o instanceof t.curves.PresetCurve&&(o={curve:o}),this.curve=o.curve.curve,this.n=this.curve.n,this.nh=this.n.ushrn(1),this.g=this.curve.g,this.g=o.curve.g,this.g.precompute(o.curve.n.bitLength()+1),this.hash=o.hash||o.curve.hash}return Wp=a,a.prototype.keyPair=function(d){return new n(this,d)},a.prototype.keyFromPrivate=function(d,c){return n.fromPrivate(this,d,c)},a.prototype.keyFromPublic=function(d,c){return n.fromPublic(this,d,c)},a.prototype.genKeyPair=function(d){d||(d={});var c=new e({hash:this.hash,pers:d.pers,persEnc:d.persEnc||"utf8",entropy:d.entropy||null,entropyEnc:d.entropy&&d.entropyEnc||"utf8",nonce:this.n.toArray()}),u=this.n.byteLength(),h=this.n.sub(new f(2));do{var l=new f(c.generate(u));if(!(l.cmp(h)>0))return l.iaddn(1),this.keyFromPrivate(l)}while(!0)},a.prototype._truncateToN=function(d,c){var u=d.byteLength()*8-this.n.bitLength();return u>0&&(d=d.ushrn(u)),!c&&d.cmp(this.n)>=0?d.sub(this.n):d},a.prototype.sign=function(d,c,u,h){typeof u=="object"&&(h=u,u=null),h||(h={}),c=this.keyFromPrivate(c,u),d=this._truncateToN(new f(d,16));for(var l=this.n.byteLength(),p=c.getPrivate().toArray("be",l),m=d.toArray("be",l),g=new e({hash:this.hash,entropy:h.extraEntropy?p.concat(h.extraEntropy):p,nonce:m,pers:h.pers,persEnc:h.persEnc||"utf8"}),y=this.n.sub(new f(1)),b=0;;b++){var w=h.k?h.k(b):new f(g.generate(this.n.byteLength()));if(w=this._truncateToN(w,!0),!(w.cmpn(1)<=0||w.cmp(y)>=0)){var k=this.g.mul(w);if(!k.isInfinity()){var T=k.getX(),O=T.umod(this.n);if(O.cmpn(0)!==0){var x=w.invm(this.n).mul(O.mul(c.getPrivate()).iadd(d));if(x=x.umod(this.n),x.cmpn(0)!==0){var C=(k.getY().isOdd()?1:0)|(T.cmp(O)!==0?2:0);return h.canonical&&x.cmp(this.nh)>0&&(x=this.n.sub(x),C^=1),new r({r:O,s:x,recoveryParam:C})}}}}}},a.prototype.verify=function(d,c,u,h){d=this._truncateToN(new f(d,16)),u=this.keyFromPublic(u,h),c=new r(c,"hex");var l=c.r,p=c.s;if(l.cmpn(1)<0||l.cmp(this.n)>=0||p.cmpn(1)<0||p.cmp(this.n)>=0)return!1;var m=p.invm(this.n),g=m.mul(d).umod(this.n),y=m.mul(l).umod(this.n);if(!this.curve._maxwellTrick){var b=this.g.mulAdd(g,u.getPublic(),y);return b.isInfinity()?!1:b.getX().umod(this.n).cmp(l)===0}var b=this.g.jmulAdd(g,u.getPublic(),y);return b.isInfinity()?!1:b.eqXToP(l)},a.prototype.recoverPubKey=function(o,d,c,u){i((3&c)===c,"The recovery param is more than two bits"),d=new r(d,u);var h=this.n,l=new f(o),p=d.r,m=d.s,g=c&1,y=c>>1;if(p.cmp(this.curve.p.umod(this.curve.n))>=0&&y)throw new Error("Unable to find sencond key candinate");y?p=this.curve.pointFromX(p.add(this.curve.n),g):p=this.curve.pointFromX(p,g);var b=d.r.invm(h),w=h.sub(l).mul(b).umod(h),k=m.mul(b).umod(h);return this.g.mulAdd(w,p,k)},a.prototype.getKeyRecoveryParam=function(o,d,c,u){if(d=new r(d,u),d.recoveryParam!==null)return d.recoveryParam;for(var h=0;h<4;h++){var l;try{l=this.recoverPubKey(o,d,h)}catch{continue}if(l.eq(c))return h}throw new Error("Unable to find valid recovery factor")},Wp}var Ru=yo,Sb=Ru.assert,_1=Ru.parseBytes,Rd=Ru.cachedProperty;function As(f,e){this.eddsa=f,this._secret=_1(e.secret),f.isPoint(e.pub)?this._pub=e.pub:this._pubBytes=_1(e.pub)}As.fromPublic=function(e,t){return t instanceof As?t:new As(e,{pub:t})};As.fromSecret=function(e,t){return t instanceof As?t:new As(e,{secret:t})};As.prototype.secret=function(){return this._secret};Rd(As,"pubBytes",function(){return this.eddsa.encodePoint(this.pub())});Rd(As,"pub",function(){return this._pubBytes?this.eddsa.decodePoint(this._pubBytes):this.eddsa.g.mul(this.priv())});Rd(As,"privBytes",function(){var e=this.eddsa,t=this.hash(),s=e.encodingLength-1,i=t.slice(0,e.encodingLength);return i[0]&=248,i[s]&=127,i[s]|=64,i});Rd(As,"priv",function(){return this.eddsa.decodeInt(this.privBytes())});Rd(As,"hash",function(){return this.eddsa.hash().update(this.secret()).digest()});Rd(As,"messagePrefix",function(){return this.hash().slice(this.eddsa.encodingLength)});As.prototype.sign=function(e){return Sb(this._secret,"KeyPair can only verify"),this.eddsa.sign(e,this)};As.prototype.signModified=function(e){return Sb(this._secret,"KeyPair can only verify"),this.eddsa.signModified(e,this)};As.prototype.verify=function(e,t){return this.eddsa.verify(e,t,this)};As.prototype.getSecret=function(e){return Sb(this._secret,"KeyPair is public only"),Ru.encode(this.secret(),e)};As.prototype.getPublic=function(e){return Ru.encode(this.pubBytes(),e)};var M3=As,P3=Ui.exports,Rl=yo,A3=Rl.assert,Fl=Rl.cachedProperty,B3=Rl.parseBytes;function bo(f,e){this.eddsa=f,typeof e!="object"&&(e=B3(e)),Array.isArray(e)&&(e={R:e.slice(0,f.encodingLength),S:e.slice(f.encodingLength)}),A3(e.R&&e.S,"Signature without R or S"),f.isPoint(e.R)&&(this._R=e.R),e.S instanceof P3&&(this._S=e.S),this._Rencoded=Array.isArray(e.R)?e.R:e.Rencoded,this._Sencoded=Array.isArray(e.S)?e.S:e.Sencoded}Fl(bo,"S",function(){return this.eddsa.decodeInt(this.Sencoded())});Fl(bo,"R",function(){return this.eddsa.decodePoint(this.Rencoded())});Fl(bo,"Rencoded",function(){return this.eddsa.encodePoint(this.R())});Fl(bo,"Sencoded",function(){return this.eddsa.encodeInt(this.S())});bo.prototype.toBytes=function(){return this.Rencoded().concat(this.Sencoded())};bo.prototype.toHex=function(){return Rl.encode(this.toBytes(),"hex").toUpperCase()};var E3=bo,zp,C1;function N3(){if(C1)return zp;C1=1;var f=l_(),e=yo,t=e.assert,s=e.parseBytes,i=M3,n=E3;const r=Ui.exports,{byteArrayToWordArray:a}=Ad.exports,o=Bd.exports;function d(c){if(t(c==="ed25519","only tested with ed25519 so far"),!(this instanceof d))return new d(c);var u=f[c].curve;this.curve=u,this.g=u.g,this.g.precompute(u.n.bitLength()+1),this.pointClass=u.point().constructor,this.encodingLength=Math.ceil(u.n.bitLength()/8)}return zp=d,d.prototype.sign=function(u,h){u=s(u);var l=this.keyFromSecret(h),p=this.hashInt(l.secret(),u),m=this.g.mul(p),g=this.encodePoint(m),y=this.hashInt(g,l.pubBytes(),u);y=y.mul(l.priv());var b=p.add(y).umod(this.curve.n);return this.makeSignature({R:m,S:b,Rencoded:g})},d.prototype.signModified=function(u,h){u=s(u);var l=this.keyFromSecret(h);const p=new r(l.secret(),16,"le"),m=this.encodePoint(this.g.mul(p)),g=m[31]&128;var y=this.hashInt(l.secret(),u),b=this.g.mul(y),w=this.encodePoint(b);let k=this.hashInt(w,m,u);k=k.mul(p);var T=y.add(k).umod(this.curve.n),O=T.toArray("le",32);return O[31]|=g,this.makeSignature({R:b,S:T,Rencoded:w,Sencoded:O})},d.prototype.verify=function(u,h,l){u=s(u),h=this.makeSignature(h);var p=this.keyFromPublic(l),m=this.hashInt(h.Rencoded(),p.pubBytes(),u),g=this.g.mul(h.S()),y=h.R().add(p.pub().mul(m));return y.eq(g)},d.prototype.hashInt=function(){let u=Array.from(arguments).reduce((l,p)=>l.concat(p));u=a(u);const h=o.SHA512(u).toString(o.enc.Hex);return e.intFromLE(h).umod(this.curve.n)},d.prototype.keyFromPublic=function(u){return i.fromPublic(this,u)},d.prototype.keyFromSecret=function(u){return i.fromSecret(this,u)},d.prototype.makeSignature=function(u){return u instanceof n?u:new n(this,u)},d.prototype.encodePoint=function(u){var h=u.getY().toArray("le",this.encodingLength);return h[this.encodingLength-1]|=u.getX().isOdd()?128:0,h},d.prototype.decodePoint=function(u){u=e.parseBytes(u);var h=u.length-1,l=u.slice(0,h).concat(u[h]&-129),p=(u[h]&128)!==0,m=e.intFromLE(l);return this.curve.pointFromY(m,p)},d.prototype.encodeInt=function(u){return u.toArray("le",this.encodingLength)},d.prototype.decodeInt=function(u){return e.intFromLE(u)},d.prototype.isPoint=function(u){return u instanceof this.pointClass},zp}var M1;function ir(){return M1||(M1=1,function(f){var e=f;function t(s,i){s.super_=i;var n=function(){};n.prototype=i.prototype,s.prototype=new n,s.prototype.constructor=s}e.inherits=t,e.version="6.5.0",e.utils=yo,e.curve=Ll(),e.curves=l_(),e.ec=C3(),e.eddsa=N3()}(qp)),qp}const V3={BaseError:{ExchangeError:{AuthenticationError:{PermissionDenied:{AccountNotEnabled:{}},AccountSuspended:{}},ArgumentsRequired:{},BadRequest:{BadSymbol:{},MarginModeAlreadySet:{}},BadResponse:{NullResponse:{}},InsufficientFunds:{},InvalidAddress:{AddressPending:{}},InvalidOrder:{OrderNotFound:{},OrderNotCached:{},CancelPending:{},OrderImmediatelyFillable:{},OrderNotFillable:{},DuplicateOrderId:{}},NotSupported:{}},NetworkError:{DDoSProtection:{RateLimitExceeded:{}},ExchangeNotAvailable:{OnMaintenance:{}},InvalidNonce:{},RequestTimeout:{}}}};var q3=V3;const L3=q3;function m_(f,e,t={}){for(const[s,i]of Object.entries(e)){const n=Object.assign(t,{[s]:class extends f{constructor(r){super(r),this.constructor=n,this.__proto__=n.prototype,this.name=s,this.message=r,Object.setPrototypeOf(this,n.prototype)}}})[s];m_(n,i,t)}return t}var de=m_(Error,L3);const Sd=Bd.exports,{capitalize:yy}=pb,{stringToBase64:P1,urlencodeBase64:of}=Ad.exports,R3=g3,{binaryToBase58:F3,byteArrayToWordArray:D3}=Ad.exports,g_=ir(),H3=g_.ec,G3=g_.eddsa,df=Ui.exports,y_=(f,e="md5",t="hex")=>{const s={};e==="keccak"&&(e="SHA3",s.outputLength=256);const i=Sd[e.toUpperCase()](f,s);return t==="binary"?i:i.toString(Sd.enc[yy(t)])},vb=(f,e,t="sha256",s="hex")=>{const i=Sd["Hmac"+t.toUpperCase()](f,e);if(s){const n=s==="binary"?"Latin1":yy(s);return i.toString(Sd.enc[yy(n)])}return i};function b_(f,e,t="RS256"){const s={RS256:"pkcs1-sha256",RS512:"pkcs1-sha512"};if(!(t in s))throw new ExchangeError(t+" is not a supported rsa signing algorithm.");const i=s[t];return new R3(e,{environment:"browser",signingScheme:i}).sign(f,"base64","binary")}function U3(f,e,t="HS256"){const s={HS256:"sha256",HS384:"sha384",HS512:"sha512"},i=of(P1(JSON.stringify({alg:t,typ:"JWT"}))),n=of(P1(JSON.stringify(f))),r=[i,n].join("."),a=t.slice(0,2),o=s[t];let d;return a==="HS"?d=of(vb(r,e,o,"base64")):a==="RS"&&(d=of(b_(r,e,t))),[r,d].join(".")}function $3(f,e,t="p256",s=void 0,i=!1){let n=f;s!==void 0&&(n=y_(f,s,"hex"));const r=new H3(t);let a=r.sign(n,e,"hex",{canonical:!0}),o=new df("0");const d=new df("1").shln(8*31).sub(new df("1"));for(;i&&(a.r.gt(r.nh)||a.r.lte(d)||a.s.lte(d));)a=r.sign(n,e,"hex",{canonical:!0,extraEntropy:o.toArray("le",32)}),o=o.add(new df("1"));return{r:a.r.toString(16).padStart(64,"0"),s:a.s.toString(16).padStart(64,"0"),v:a.recoveryParam}}function j3(f,e,t="ed25519"){const i=new G3(t).signModified(f,e);return F3(D3(i.toBytes()))}const W3=f=>{const e=r=>(r<15.5?"0":"")+Math.round(r).toString(16),t=r=>parseInt(r,16),s=(r,a)=>(a+r).slice(-a.length),i=r=>{let a="ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",o="",d="";for(let c=0;c<r.length;c++){let u=a.indexOf(r.charAt(c).toUpperCase());o+=s(u.toString(2),"00000")}for(let c=0;c+4<=o.length;c+=4){let u=o.substr(c,4);d=d+parseInt(u,2).toString(16)}return d};return(r=>{r=r.replace(" ","");let a=Math.round(new Date().getTime()/1e3),o=s(e(Math.floor(a/30)),"0000000000000000"),d=vb(Sd.enc.Hex.parse(o),Sd.enc.Hex.parse(i(r)),"sha1","hex"),c=t(d.substring(d.length-1)),u=(t(d.substr(c*2,8))&t("7fffffff"))+"";return u=u.substr(u.length-6,6),u})(f)};function Wh(f,e=!1){const t="00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D";Wh.table===void 0&&(Wh.table=t.split(" ").map(n=>parseInt(n,16)));let s=-1;for(let n=0;n<f.length;n++)s=s>>>8^Wh.table[(s^f.charCodeAt(n))&255];const i=(s^-1)>>>0;return e&&i>=2147483648?i-4294967296:i}var z3={hash:y_,hmac:vb,jwt:U3,totp:W3,rsa:b_,ecdsa:$3,eddsa:j3,crc32:Wh};const vd=Date.now,w_=()=>vd()*1e3,K3=vd,X3=()=>Math.floor(vd()/1e3),Y3=()=>{const s=(w_()*10+122192928e9).toString(16),i=s.slice(7,15)+s.slice(3,7)+"1"+s.slice(0,3),n="9696",r="ff".repeat(6);return i+n+r},Q3=setTimeout,zh=(f,e,t=Q3,s=vd()+e)=>{if(e>=2147483647)throw new Error("setTimeout() function was called with unrealistic value of "+e.toString());let i=()=>{},n=!0;const r=t(()=>{n=!0;const a=s-vd();a>0?i=zh(f,a,t,s):f()},e);return function(){n&&(n=!1,clearTimeout(r)),i()}};class Cu extends Error{constructor(){const e="timed out";super(e),this.constructor=Cu,this.__proto__=Cu.prototype,this.message=e}}const Z3=f=>{let e;if(typeof f=="number"?e=Math.floor(f):e=parseInt(f,10),!(Number.isNaN(e)||e<0))try{return new Date(e).toISOString()}catch{return}},k_=f=>{if(!(typeof f!="string"||!f)&&!f.match(/^[0-9]+$/)&&!(f.indexOf("-")<0||f.indexOf(":")<0))try{const e=Date.parse(f.indexOf("+")>=0||f.slice(-1)==="Z"?f:(f+"Z").replace(/\s(\d\d):/,"T$1:"));return Number.isNaN(e)?void 0:e}catch{return}},J3=f=>{if(!(typeof f!="string"||!f)){if(f.indexOf("GMT")>=0)try{return Date.parse(f)}catch{return}return k_(f)}},eV=(f=void 0)=>new Date(f).toUTCString(),tV=(f,e="-")=>{e=e||"";const t=new Date(f),s=t.getUTCFullYear().toString();let i=t.getUTCMonth()+1,n=t.getUTCDate();return i=i<10?"0"+i:i.toString(),n=n<10?"0"+n:n.toString(),i+e+n+e+s},Tb=(f,e,t=!0)=>{e=e||"";const s=new Date(f),i=s.getUTCFullYear(),r=(t?i:i-2e3).toString();let a=s.getUTCMonth()+1,o=s.getUTCDate();return a=a<10?"0"+a:a.toString(),o=o<10?"0"+o:o.toString(),r+e+a+e+o},sV=(f,e="")=>Tb(f,e,!1),iV=(f,e="-")=>Tb(f,e,!0),nV=(f,e=" ")=>{const t=new Date(f),s=t.getUTCFullYear();let i=t.getUTCMonth()+1,n=t.getUTCDate(),r=t.getUTCHours(),a=t.getUTCMinutes(),o=t.getUTCSeconds();return i=i<10?"0"+i:i,n=n<10?"0"+n:n,r=r<10?"0"+r:r,a=a<10?"0"+a:a,o=o<10?"0"+o:o,s+"-"+i+"-"+n+e+r+":"+a+":"+o};var Ob={now:vd,microseconds:w_,milliseconds:K3,seconds:X3,iso8601:Z3,parse8601:k_,rfc2616:eV,uuidv1:Y3,parseDate:J3,mdy:tV,ymd:Tb,yymmdd:sV,yyyymmdd:iV,ymdhms:nV,setTimeout_safe:zh,sleep:f=>new Promise(e=>zh(e,f)),TimedOut:Cu,timeout:async(f,e)=>{let t=()=>{};const s=new Promise(i=>t=zh(i,f));try{return await Promise.race([e,s.then(()=>{throw new Cu})])}finally{t()}}};const{now:A1,sleep:rV}=Ob;class aV{constructor(e){this.config={refillRate:1,delay:.001,capacity:1,maxCapacity:2e3,tokens:0,cost:1},Object.assign(this.config,e),this.queue=[],this.running=!1}async loop(){let e=A1();for(;this.running;){const{resolver:t,cost:s}=this.queue[0];if(this.config.tokens>=0)this.config.tokens-=s,t(),this.queue.shift(),await Promise.resolve(),this.queue.length===0&&(this.running=!1);else{await rV(this.config.delay*1e3);const i=A1(),n=i-e;e=i;const r=this.config.tokens+this.config.refillRate*n;this.config.tokens=Math.min(r,this.config.capacity)}}}}function oV(f){function e(i=void 0){let n;const r=new Promise((a,o)=>{n=a});if(this.queue.length>this.config.maxCapacity)throw new Error("throttle queue is over maxCapacity ("+this.config.maxCapacity.toString()+"), see https://github.com/ccxt/ccxt/issues/11645#issuecomment-1195695526");return i=i===void 0?this.config.cost:i,this.queue.push({resolver:n,cost:i}),this.running||(this.running=!0,this.loop()),r}const t=new aV(f),s=e.bind(t);return s.config=t.config,s.queue=t.queue,s}var dV={throttle:oV};const{ROUND_UP:S_,ROUND_DOWN:v_}=me,{NotSupported:cV}=de,Ib=f=>{const e=f.slice(0,-1),t=f.slice(-1);let s;if(t==="y")s=60*60*24*365;else if(t==="M")s=60*60*24*30;else if(t==="w")s=60*60*24*7;else if(t==="d")s=60*60*24;else if(t==="h")s=60*60;else if(t==="m")s=60;else if(t==="s")s=1;else throw new cV("timeframe unit "+t+" is not supported");return e*s},uV=(f,e,t=v_)=>{const s=Ib(f)*1e3,i=e%s;return e-i+(t===S_?s:0)},fV=(f,e="1m",t=-1/0,s=1/0)=>{const i=Ib(e)*1e3,n=[],[r,,a,o,d,c,u]=[0,1,2,3,4,5,6],h=Math.min(f.length-1,s);for(let l=0;l<=h;l++){const p=f[l];if(p.timestamp<t)continue;const m=Math.floor(p.timestamp/i)*i,g=n.length-1;g===-1||m>=n[g][r]+i?n.push([m,p.price,p.price,p.price,p.price,p.amount,1]):(n[g][a]=Math.max(n[g][a],p.price),n[g][o]=Math.min(n[g][o],p.price),n[g][d]=p.price,n[g][c]+=p.amount,n[g][u]++)}return n},hV=f=>{const e=/{([\w-]+)}/g,t=[];let s=e.exec(f);for(;s;)t.push(s[1]),s=e.exec(f);return t},lV=(f,e)=>{if(!Array.isArray(e)){const t=Object.keys(e);for(let s=0;s<t.length;s++){const i=t[s];Array.isArray(e[i])||(f=f.replace("{"+i+"}",e[i]))}}return f};function pV(f,e){return f!==void 0&&e!==void 0&&f>0?e/f:void 0}var mV={aggregate(f){const e={};for(let t=0;t<f.length;t++){const[s,i]=f[t];i>0&&(e[s]=(e[s]||0)+i)}return Object.keys(e).map(t=>[parseFloat(t),parseFloat(e[t])])},parseTimeframe:Ib,roundTimeframe:uV,buildOHLCVC:fV,ROUND_UP:S_,ROUND_DOWN:v_,implodeParams:lV,extractParams:hV,vwap:pV};const{unCamelCase:gV}=pb,yV=f=>{for(const e in f)f[gV(e)]=f[e];return f};var Fu=yV(Object.assign({},YB,Wx,pb,$x,me,Ad.exports,z3,Ob,dV,mV));const bV=BigInt(0),wV=BigInt(-1),zd=BigInt(10);class nt{constructor(e,t=void 0){if(t===void 0){let s=0;e=e.toLowerCase(),e.indexOf("e")>-1&&([e,s]=e.split("e"),s=parseInt(s));const i=e.indexOf(".");this.decimals=i>-1?e.length-i-1:0;const n=e.replace(".","");this.integer=BigInt(n),this.decimals=this.decimals-s}else this.integer=e,this.decimals=t}mul(e){const t=this.integer*e.integer;return new nt(t,this.decimals+e.decimals)}div(e,t=18){const s=t-this.decimals+e.decimals;let i;if(s===0)i=this.integer;else if(s<0){const r=zd**BigInt(-s);i=this.integer/r}else{const r=zd**BigInt(s);i=this.integer*r}const n=i/e.integer;return new nt(n,t)}add(e){if(this.decimals===e.decimals){const t=this.integer+e.integer;return new nt(t,this.decimals)}else{const[t,s]=this.decimals>e.decimals?[e,this]:[this,e],i=s.decimals-t.decimals,r=t.integer*zd**BigInt(i)+s.integer;return new nt(r,s.decimals)}}mod(e){const t=Math.max(-this.decimals+e.decimals,0),s=this.integer*zd**BigInt(t),i=Math.max(-e.decimals+this.decimals,0),n=e.integer*zd**BigInt(i),r=s%n;return new nt(r,i+e.decimals)}sub(e){const t=new nt(-e.integer,e.decimals);return this.add(t)}abs(){return new nt(this.integer<0?this.integer*wV:this.integer,this.decimals)}neg(){return new nt(-this.integer,this.decimals)}min(e){return this.lt(e)?this:e}max(e){return this.gt(e)?this:e}gt(e){return this.sub(e).integer>0}ge(e){return this.sub(e).integer>=0}lt(e){return e.gt(this)}le(e){return e.ge(this)}reduce(){const e=this.integer.toString(),t=e.length-1;if(t===0)return e==="0"&&(this.decimals=0),this;let s;for(s=t;s>=0&&e.charAt(s)==="0";s--);const i=t-s;if(i===0)return this;this.decimals-=i,this.integer=BigInt(e.slice(0,s+1))}equals(e){return this.reduce(),e.reduce(),this.decimals===e.decimals&&this.integer===e.integer}toString(){this.reduce();let e,t;this.integer<0?(e="-",t=-this.integer):(e="",t=this.integer);const s=Array.from(t.toString(this.base).padStart(this.decimals,"0")),i=s.length-this.decimals;let n;return i===0?n="0.":this.decimals<0?n="0".repeat(-this.decimals):this.decimals===0?n="":n=".",s.splice(i,0,n),e+s.join("")}static stringMul(e,t){if(!(e===void 0||t===void 0))return new nt(e).mul(new nt(t)).toString()}static stringDiv(e,t,s=18){if(e===void 0||t===void 0)return;const i=new nt(t);if(i.integer!==bV)return new nt(e).div(i,s).toString()}static stringAdd(e,t){if(!(e===void 0&&t===void 0))return e===void 0?t:t===void 0?e:new nt(e).add(new nt(t)).toString()}static stringSub(e,t){if(!(e===void 0||t===void 0))return new nt(e).sub(new nt(t)).toString()}static stringAbs(e){if(e!==void 0)return new nt(e).abs().toString()}static stringNeg(e){if(e!==void 0)return new nt(e).neg().toString()}static stringMod(e,t){if(!(e===void 0||t===void 0))return new nt(e).mod(new nt(t)).toString()}static stringEquals(e,t){if(!(e===void 0||t===void 0))return new nt(e).equals(new nt(t))}static stringEq(e,t){if(!(e===void 0||t===void 0))return new nt(e).equals(new nt(t))}static stringMin(e,t){if(!(e===void 0||t===void 0))return new nt(e).min(new nt(t)).toString()}static stringMax(e,t){if(!(e===void 0||t===void 0))return new nt(e).max(new nt(t)).toString()}static stringGt(e,t){if(!(e===void 0||t===void 0))return new nt(e).gt(new nt(t))}static stringGe(e,t){if(!(e===void 0||t===void 0))return new nt(e).ge(new nt(t))}static stringLt(e,t){if(!(e===void 0||t===void 0))return new nt(e).lt(new nt(t))}static stringLe(e,t){if(!(e===void 0||t===void 0))return new nt(e).le(new nt(t))}}var Se=nt;const xb=Fu,{isNode:Oo,clone:Kp,unCamelCase:kV,throttle:SV,timeout:vV,TimedOut:TV,defaultFetch:Kd}=xb,{ExchangeError:Gr,BadSymbol:Xp,NullResponse:B1,InvalidAddress:Yp,InvalidOrder:E1,NotSupported:He,AuthenticationError:Qp,DDoSProtection:OV,RequestTimeout:Zp,ExchangeNotAvailable:Fs,RateLimitExceeded:IV,ArgumentsRequired:Ca}=de,{TRUNCATE:N1,ROUND:Jp,DECIMAL_PLACES:V1,NO_PADDING:xV,TICK_SIZE:_V}=xb.precisionConstants,it=Se;var ge=class by{describe(){return{id:void 0,name:void 0,countries:void 0,enableRateLimit:!0,rateLimit:2e3,certified:!1,pro:!1,alias:!1,has:{publicAPI:!0,privateAPI:!0,CORS:void 0,spot:void 0,margin:void 0,swap:void 0,future:void 0,option:void 0,addMargin:void 0,cancelAllOrders:void 0,cancelOrder:!0,cancelOrders:void 0,createDepositAddress:void 0,createLimitOrder:!0,createMarketOrder:!0,createOrder:!0,createPostOnlyOrder:void 0,createReduceOnlyOrder:void 0,createStopOrder:void 0,createStopLimitOrder:void 0,createStopMarketOrder:void 0,editOrder:"emulated",fetchAccounts:void 0,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowInterest:void 0,fetchBorrowRate:void 0,fetchBorrowRateHistory:void 0,fetchBorrowRatesPerSymbol:void 0,fetchBorrowRates:void 0,fetchCanceledOrders:void 0,fetchClosedOrder:void 0,fetchClosedOrders:void 0,fetchCurrencies:"emulated",fetchDeposit:void 0,fetchDepositAddress:void 0,fetchDepositAddresses:void 0,fetchDepositAddressesByNetwork:void 0,fetchDeposits:void 0,fetchTransactionFee:void 0,fetchTransactionFees:void 0,fetchFundingHistory:void 0,fetchFundingRate:void 0,fetchFundingRateHistory:void 0,fetchFundingRates:void 0,fetchIndexOHLCV:void 0,fetchL2OrderBook:!0,fetchLedger:void 0,fetchLedgerEntry:void 0,fetchLeverageTiers:void 0,fetchMarketLeverageTiers:void 0,fetchMarkets:!0,fetchMarkOHLCV:void 0,fetchMyTrades:void 0,fetchOHLCV:"emulated",fetchOpenOrder:void 0,fetchOpenOrders:void 0,fetchOrder:void 0,fetchOrderBook:!0,fetchOrderBooks:void 0,fetchOrders:void 0,fetchOrderTrades:void 0,fetchPermissions:void 0,fetchPosition:void 0,fetchPositions:void 0,fetchPositionsRisk:void 0,fetchPremiumIndexOHLCV:void 0,fetchStatus:"emulated",fetchTicker:!0,fetchTickers:void 0,fetchTime:void 0,fetchTrades:!0,fetchTradingFee:void 0,fetchTradingFees:void 0,fetchTradingLimits:void 0,fetchTransactions:void 0,fetchTransfers:void 0,fetchWithdrawal:void 0,fetchWithdrawals:void 0,reduceMargin:void 0,setLeverage:void 0,setMargin:void 0,setMarginMode:void 0,setPositionMode:void 0,signIn:void 0,transfer:void 0,withdraw:void 0},urls:{logo:void 0,api:void 0,www:void 0,doc:void 0,fees:void 0},api:void 0,requiredCredentials:{apiKey:!0,secret:!0,uid:!1,login:!1,password:!1,twofa:!1,privateKey:!1,walletAddress:!1,token:!1},markets:void 0,currencies:{},timeframes:void 0,fees:{trading:{tierBased:void 0,percentage:void 0,taker:void 0,maker:void 0},funding:{tierBased:void 0,percentage:void 0,withdraw:{},deposit:{}}},status:{status:"ok",updated:void 0,eta:void 0,url:void 0},exceptions:void 0,httpExceptions:{422:Gr,418:OV,429:IV,404:Fs,409:Fs,410:Fs,500:Fs,501:Fs,502:Fs,520:Fs,521:Fs,522:Fs,525:Fs,526:Fs,400:Fs,403:Fs,405:Fs,503:Fs,530:Fs,408:Zp,504:Zp,401:Qp,511:Qp},commonCurrencies:{XBT:"BTC",BCC:"BCH",BCHABC:"BCH",BCHSV:"BSV"},precisionMode:V1,paddingMode:xV,limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}}}}constructor(e={}){Object.assign(this,xb),this.options={},this.fetchOptions={},this.userAgents={chrome:"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36",chrome39:"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36",chrome100:"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.75 Safari/537.36"},this.headers={},this.proxy="",this.origin="*",this.minFundingAddressLength=1,this.substituteCommonCurrencyCodes=!0,this.quoteJsonNumbers=!0,this.number=Number,this.handleContentTypeApplicationZip=!1,this.reduceFees=!0,this.fetchImplementation=Kd,this.validateServerSsl=!0,this.validateClientSsl=!1,this.timeout=1e4,this.verbose=!1,this.debug=!1,this.userAgent=void 0,this.twofa=void 0,this.apiKey=void 0,this.secret=void 0,this.uid=void 0,this.login=void 0,this.password=void 0,this.privateKey=void 0,this.walletAddress=void 0,this.token=void 0,this.balance={},this.orderbooks={},this.tickers={},this.orders=void 0,this.trades={},this.transactions={},this.ohlcvs={},this.myTrades=void 0,this.positions={},this.requiresWeb3=!1,this.requiresEddsa=!1,this.precision={},this.lastRestRequestTimestamp=0,this.enableLastJsonResponse=!0,this.enableLastHttpResponse=!0,this.enableLastResponseHeaders=!0,this.last_http_response=void 0,this.last_json_response=void 0,this.last_response_headers=void 0;const t=(r=this)=>{if(r!==null){const a=Object.getOwnPropertyNames(r);for(let o=0;o<a.length;o++){const d=a[o];this[kV(d)]=this[d]}t(Object.getPrototypeOf(r))}};t();const s=Object.entries(this.describe()).concat(Object.entries(e));for(let r=0;r<s.length;r++){const[a,o]=s[r];o&&Object.getPrototypeOf(o)===Object.prototype?this[a]=this.deepExtend(this[a],o):this[a]=o}const i={keepAlive:!0};this.validateServerSsl||(i.rejectUnauthorized=!1),!this.httpAgent&&Kd.http&&Oo&&(this.httpAgent=new Kd.http.Agent(i)),!this.httpsAgent&&Kd.https&&Oo&&(this.httpsAgent=new Kd.https.Agent(i));const n=Object.keys(this.has);for(let r=0;r<n.length;r++){const a=n[r];this["has"+this.capitalize(a)]=!!this.has[a]}this.api&&this.defineRestApi(this.api,"request"),this.initRestRateLimiter(),this.markets&&this.setMarkets(this.markets)}encodeURIComponent(...e){return encodeURIComponent(...e)}checkRequiredVersion(e,t=!0){let s=!0;const[i,n,r]=e.split("."),[a,o,d]=by.ccxtVersion.split("."),c=parseInt(i),u=parseInt(n),h=parseInt(r),l=parseInt(a),p=parseInt(o),m=parseInt(d);if(c>l&&(s=!1),c===l&&(u>p||u===p&&h>m)&&(s=!1),!s){if(t)throw new He("Your current version of CCXT is "+by.ccxtVersion+", a newer version "+e+" is required, please, upgrade your version of CCXT");return t}return s}checkAddress(e){if(e===void 0)throw new Yp(this.id+" address is undefined");if(this.unique(e).length===1||e.length<this.minFundingAddressLength||e.includes(" "))throw new Yp(this.id+" address is invalid or has less than "+this.minFundingAddressLength.toString()+' characters: "'+this.json(e)+'"');return e}initRestRateLimiter(){if(this.rateLimit===void 0)throw new Error(this.id+".rateLimit property is not configured");this.tokenBucket=this.extend({delay:.001,capacity:1,cost:1,maxCapacity:1e3,refillRate:this.rateLimit>0?1/this.rateLimit:Number.MAX_VALUE},this.tokenBucket),this.throttle=SV(this.tokenBucket),this.executeRestRequest=(e,t="GET",s=void 0,i=void 0)=>{const n=this.fetchImplementation,r={method:t,headers:s,body:i,timeout:this.timeout};this.agent?r.agent=this.agent:this.httpAgent&&e.indexOf("http://")===0?r.agent=this.httpAgent:this.httpsAgent&&e.indexOf("https://")===0&&(r.agent=this.httpsAgent);const a=n(e,this.extend(r,this.fetchOptions)).catch(o=>{throw Oo?new Fs([this.id,t,e,o.type,o.message].join(" ")):o}).then(o=>this.handleRestResponse(o,e,t,s,i));return vV(this.timeout,a).catch(o=>{throw o instanceof TV?new Zp(this.id+" "+t+" "+e+" request timed out ("+this.timeout+" ms)"):o})}}setSandboxMode(e){if(e)if("test"in this.urls)typeof this.urls.api=="string"?(this.urls.apiBackup=this.urls.api,this.urls.api=this.urls.test):(this.urls.apiBackup=Kp(this.urls.api),this.urls.api=Kp(this.urls.test));else throw new He(this.id+" does not have a sandbox URL");else"apiBackup"in this.urls&&(typeof this.urls.api=="string"?this.urls.api=this.urls.apiBackup:this.urls.api=Kp(this.urls.apiBackup))}defineRestApiEndpoint(e,t,s,i,n,r,a={}){const o=n.split(/[^a-zA-Z0-9]/),d=o.map(this.capitalize).join(""),c=o.map(y=>y.trim().toLowerCase()).filter(y=>y.length>0).join("_"),u=[r[0]].concat(r.slice(1).map(this.capitalize)).join(""),h=[r[0]].concat(r.slice(1).map(y=>y.trim()).filter(y=>y.length>0)).join("_"),l=u+i+this.capitalize(d),p=h+"_"+s+"_"+c,m=r.length>1?r:r[0],g=async(y={},b={})=>this[e](n,m,t,y,void 0,void 0,a,b);this[l]=g,this[p]=g}defineRestApi(e,t,s=[]){const i=Object.keys(e);for(let n=0;n<i.length;n++){const r=i[n],a=e[r],o=r.toUpperCase(),d=r.toLowerCase(),c=this.capitalize(d);if(Array.isArray(a))for(let u=0;u<a.length;u++){const h=a[u].trim();this.defineRestApiEndpoint(t,o,d,c,h,s)}else if(r.match(/^(?:get|post|put|delete|head|patch)$/i)){const u=Object.keys(a);for(let h=0;h<u.length;h++){const l=u[h],p=l.trim(),m=a[l];if(typeof m=="object")this.defineRestApiEndpoint(t,o,d,c,p,s,m);else if(typeof m=="number")this.defineRestApiEndpoint(t,o,d,c,p,s,{cost:m});else throw new He(this.id+" defineRestApi() API format is not supported, API leafs must strings, objects or numbers")}}else this.defineRestApi(a,t,s.concat([r]))}}log(...e){console.log(...e)}fetch(e,t="GET",s=void 0,i=void 0){return Oo&&this.userAgent&&(typeof this.userAgent=="string"?s=this.extend({"User-Agent":this.userAgent},s):typeof this.userAgent=="object"&&"User-Agent"in this.userAgent&&(s=this.extend(this.userAgent,s))),typeof this.proxy=="function"?(e=this.proxy(e),Oo&&(s=this.extend({Origin:this.origin},s))):typeof this.proxy=="string"&&(this.proxy.length&&Oo&&(s=this.extend({Origin:this.origin},s)),e=this.proxy+e),s=this.extend(this.headers,s),s=this.setHeaders(s),this.verbose&&this.log(`fetch Request:
`,this.id,t,e,`
RequestHeaders:
`,s,`
RequestBody:
`,i,`
`),this.executeRestRequest(e,t,s,i)}parseJson(e){try{if(this.isJsonEncodedObject(e))return JSON.parse(this.onJsonResponse(e))}catch{return}}getResponseHeaders(e){const t={};return e.headers.forEach((s,i)=>{i=i.split("-").map(n=>this.capitalize(n)).join("-"),t[i]=s}),t}handleRestResponse(e,t,s="GET",i=void 0,n=void 0){const r=this.getResponseHeaders(e);if(this.handleContentTypeApplicationZip&&r["Content-Type"]==="application/zip"){const a=e.buffer();return this.enableLastResponseHeaders&&(this.last_response_headers=r),this.enableLastHttpResponse&&(this.last_http_response=a),this.verbose&&this.log(`handleRestResponse:
`,this.id,s,t,e.status,e.statusText,`
ResponseHeaders:
`,r,"ZIP redacted",`
`),a}return e.text().then(a=>{const o=this.onRestResponse(e.status,e.statusText,t,s,r,a,i,n),d=this.parseJson(o);return this.enableLastResponseHeaders&&(this.last_response_headers=r),this.enableLastHttpResponse&&(this.last_http_response=a),this.enableLastJsonResponse&&(this.last_json_response=d),this.verbose&&this.log(`handleRestResponse:
`,this.id,s,t,e.status,e.statusText,`
ResponseHeaders:
`,r,`
ResponseBody:
`,a,`
`),this.handleErrors(e.status,e.statusText,t,s,r,a,d,i,n)||this.handleHttpStatusCode(e.status,e.statusText,t,s,a),d||a})}onRestResponse(e,t,s,i,n,r,a,o){return r.trim()}onJsonResponse(e){return this.quoteJsonNumbers?e.replace(/":([+.0-9eE-]+)([,}])/g,'":"$1"$2'):e}async loadMarketsHelper(e=!1,t={}){if(!e&&this.markets)return this.markets_by_id?this.markets:this.setMarkets(this.markets);let s;this.has.fetchCurrencies===!0&&(s=await this.fetchCurrencies());const i=await this.fetchMarkets(t);return this.setMarkets(i,s)}loadMarkets(e=!1,t={}){return(e&&!this.reloadingMarkets||!this.marketsLoading)&&(this.reloadingMarkets=!0,this.marketsLoading=this.loadMarketsHelper(e,t).then(s=>(this.reloadingMarkets=!1,s),s=>{throw this.reloadingMarkets=!1,s})),this.marketsLoading}fetchCurrencies(e={}){return new Promise((t,s)=>t(this.currencies))}fetchMarkets(e={}){return new Promise((t,s)=>t(Object.values(this.markets)))}filterBySinceLimit(e,t=void 0,s=void 0,i="timestamp",n=!1){return t!=null&&(e=e.filter(a=>a[i]>=t)),s!=null&&(e=n?e.slice(-s):e.slice(0,s)),e}filterByValueSinceLimit(e,t,s=void 0,i=void 0,n=void 0,r="timestamp",a=!1){const o=s!=null,d=i!=null;return(o||d)&&(e=e.filter(c=>(o?c[t]===s:!0)&&(d?c[r]>=i:!0))),n!=null&&(e=a?e.slice(-n):e.slice(0,n)),e}checkRequiredDependencies(){}remove0xPrefix(e){return e.slice(0,2)==="0x"?e.slice(2):e}hashMessage(e){const t=this.base16ToBinary(this.remove0xPrefix(e)),s=this.stringToBinary(`Ethereum Signed Message:
`+t.sigBytes);return"0x"+this.hash(this.binaryConcat(s,t),"keccak","hex")}signHash(e,t){const s=this.ecdsa(e.slice(-64),t.slice(-64),"secp256k1",void 0);return{r:"0x"+s.r,s:"0x"+s.s,v:27+s.v}}signMessage(e,t){return this.signHash(this.hashMessage(e),t.slice(-64))}signMessageString(e,t){const s=this.signMessage(e,t);return s.r+this.remove0xPrefix(s.s)+this.binaryToBase16(this.numberToBE(s.v))}parseNumber(e,t=void 0){if(e===void 0)return t;try{return this.number(e)}catch{return t}}checkOrderArguments(e,t,s,i,n,r){if(n===void 0&&t==="limit")throw new Ca(this.id+" createOrder() requires a price argument for a limit order");if(i<=0)throw new Ca(this.id+" createOrder() amount should be above 0")}handleHttpStatusCode(e,t,s,i,n){const r=e.toString();if(r in this.httpExceptions){const a=this.httpExceptions[r];throw new a(this.id+" "+i+" "+s+" "+r+" "+t+" "+n)}}safeLedgerEntry(e,t=void 0){t=this.safeCurrency(void 0,t);let s=this.safeString(e,"direction"),i=this.safeString(e,"before"),n=this.safeString(e,"after");const r=this.safeString(e,"amount");r!==void 0&&(i===void 0&&n!==void 0?i=it.stringSub(n,r):i!==void 0&&n===void 0&&(n=it.stringAdd(i,r))),i!==void 0&&n!==void 0&&s===void 0&&(it.stringGt(i,n)&&(s="out"),it.stringGt(n,i)&&(s="in"));const a=this.safeValue(e,"fee");a!==void 0&&(a.cost=this.safeNumber(a,"cost"));const o=this.safeInteger(e,"timestamp");return{id:this.safeString(e,"id"),timestamp:o,datetime:this.iso8601(o),direction:s,account:this.safeString(e,"account"),referenceId:this.safeString(e,"referenceId"),referenceAccount:this.safeString(e,"referenceAccount"),type:this.safeString(e,"type"),currency:t.code,amount:this.parseNumber(r),before:this.parseNumber(i),after:this.parseNumber(n),status:this.safeString(e,"status"),fee:a,info:e}}setMarkets(e,t=void 0){const s=[],i=this.toArray(e);for(let o=0;o<i.length;o++){const d=this.deepExtend(this.safeMarket(),{precision:this.precision,limits:this.limits},this.fees.trading,i[o]);s.push(d)}this.markets=this.indexBy(s,"symbol"),this.markets_by_id=this.indexBy(e,"id");const n=this.keysort(this.markets),r=this.keysort(this.markets_by_id);if(this.symbols=Object.keys(n),this.ids=Object.keys(r),t!==void 0)this.currencies=this.deepExtend(this.currencies,t);else{let o=[],d=[];for(let m=0;m<s.length;m++){const g=s[m],y=this.precisionMode===V1?8:this.parseNumber("0.00000001"),b=this.safeValue(g,"precision",{});if("base"in g){const w=this.safeValue2(b,"base","amount",y),k={id:this.safeString2(g,"baseId","base"),numericId:this.safeString(g,"baseNumericId"),code:this.safeString(g,"base"),precision:w};o.push(k)}if("quote"in g){const w=this.safeValue2(b,"quote","price",y),k={id:this.safeString2(g,"quoteId","quote"),numericId:this.safeString(g,"quoteNumericId"),code:this.safeString(g,"quote"),precision:w};d.push(k)}}o=this.sortBy(o,"code"),d=this.sortBy(d,"code"),this.baseCurrencies=this.indexBy(o,"code"),this.quoteCurrencies=this.indexBy(d,"code");const c=this.arrayConcat(o,d),u=this.groupBy(c,"code"),h=Object.keys(u),l=[];for(let m=0;m<h.length;m++){const g=h[m],y=this.safeValue(u,g,[]);let b=this.safeValue(y,0);for(let w=1;w<y.length;w++){const k=y[w];this.precisionMode===_V?b=k.precision<b.precision?k:b:b=k.precision>b.precision?k:b}l.push(b)}const p=this.sortBy(l,"code");this.currencies=this.deepExtend(this.currencies,this.indexBy(p,"code"))}this.currencies_by_id=this.indexBy(this.currencies,"id");const a=this.keysort(this.currencies);return this.codes=Object.keys(a),this.markets}safeBalance(e){const t=this.omit(e,["info","timestamp","datetime","free","used","total"]),s=Object.keys(t);e.free={},e.used={},e.total={};const i={};for(let a=0;a<s.length;a++){const o=s[a];let d=this.safeString(e[o],"total"),c=this.safeString(e[o],"free"),u=this.safeString(e[o],"used");const h=this.safeString(e[o],"debt");d===void 0&&c!==void 0&&u!==void 0&&(d=it.stringAdd(c,u)),c===void 0&&d!==void 0&&u!==void 0&&(c=it.stringSub(d,u)),u===void 0&&d!==void 0&&c!==void 0&&(u=it.stringSub(d,c)),e[o].free=this.parseNumber(c),e[o].used=this.parseNumber(u),e[o].total=this.parseNumber(d),e.free[o]=e[o].free,e.used[o]=e[o].used,e.total[o]=e[o].total,h!==void 0&&(e[o].debt=this.parseNumber(h),i[o]=e[o].debt)}return Object.keys(i).length&&(e.debt=i),e}safeOrder(e,t=void 0){let s=this.omitZero(this.safeString(e,"amount")),i=this.safeString(e,"remaining"),n=this.safeString(e,"filled"),r=this.safeString(e,"cost"),a=this.omitZero(this.safeString(e,"average")),o=this.omitZero(this.safeString(e,"price")),d=this.safeInteger(e,"lastTradeTimestamp");const c=n===void 0,u=r===void 0,h=d===void 0,l=this.safeValue(e,"fee"),p=l===void 0,m=this.safeValue(e,"fees")===void 0,g=p||m,y=this.safeValue(e,"fees",[]);let b=[];if(c||u||g){const x=this.safeValue(e,"trades",b),C=this.number;this.number=String,b=this.parseTrades(x,t,void 0,void 0,{symbol:e.symbol,side:e.side,type:e.type,order:e.id}),this.number=C;let E=0;const P=Array.isArray(b);if(P&&(E=b.length),P&&E>0){e.symbol===void 0&&(e.symbol=b[0].symbol),e.side===void 0&&(e.side=b[0].side),e.type===void 0&&(e.type=b[0].type),e.id===void 0&&(e.id=b[0].order),c&&(n="0"),u&&(r="0");for(let _=0;_<b.length;_++){const S=b[_],I=this.safeString(S,"amount");c&&I!==void 0&&(n=it.stringAdd(n,I));const v=this.safeString(S,"cost");u&&v!==void 0&&(r=it.stringAdd(r,v));const N=this.safeValue(S,"timestamp");if(h&&N!==void 0&&(d===void 0?d=N:d=Math.max(d,N)),g){const q=this.safeValue(S,"fees");if(q!==void 0)for(let R=0;R<q.length;R++){const G=q[R];y.push(this.extend({},G))}else{const R=this.safeValue(S,"fee");R!==void 0&&y.push(this.extend({},R))}}}}}if(g){const x=this.reduceFees?this.reduceFeesByCurrency(y):y,C=x.length;for(let E=0;E<C;E++)x[E].cost=this.safeNumber(x[E],"cost"),"rate"in x[E]&&(x[E].rate=this.safeNumber(x[E],"rate"));!p&&C===0&&(l.cost=this.safeNumber(l,"cost"),"rate"in l&&(l.rate=this.safeNumber(l,"rate")),x.push(l)),e.fees=x,p&&C===1&&(e.fee=x[0])}if(s===void 0&&(n!==void 0&&i!==void 0?s=it.stringAdd(n,i):this.safeString(e,"status")==="closed"&&(s=n)),n===void 0&&s!==void 0&&i!==void 0&&(n=it.stringSub(s,i)),i===void 0&&s!==void 0&&n!==void 0&&(i=it.stringSub(s,n)),a===void 0&&n!==void 0&&r!==void 0&&it.stringGt(n,"0")&&(a=it.stringDiv(r,n)),u&&n!==void 0&&(a!==void 0||o!==void 0)){let x;a===void 0?x=o:x=a;const C=this.safeString(t,"contractSize");C!==void 0&&(this.safeValue(t,"inverse",!1)&&(x=it.stringDiv("1",x)),x=it.stringMul(x,C)),r=it.stringMul(x,n)}const k=this.safeValue(e,"type");(o===void 0||it.stringEquals(o,"0"))&&k==="market"&&(o=a);for(let x=0;x<b.length;x++){const C=b[x];C.amount=this.safeNumber(C,"amount"),C.price=this.safeNumber(C,"price"),C.cost=this.safeNumber(C,"cost");const E=this.safeValue(C,"fee",{});E.cost=this.safeNumber(E,"cost"),"rate"in E&&(E.rate=this.safeNumber(E,"rate")),C.fee=E}let O=this.safeString(e,"timeInForce");return O===void 0&&(this.safeString(e,"type")==="market"&&(O="IOC"),this.safeValue(e,"postOnly",!1)&&(O="PO")),this.extend(e,{lastTradeTimestamp:d,price:this.parseNumber(o),amount:this.parseNumber(s),cost:this.parseNumber(r),average:this.parseNumber(a),filled:this.parseNumber(n),remaining:this.parseNumber(i),timeInForce:O,trades:b})}parseOrders(e,t=void 0,s=void 0,i=void 0,n={}){let r=[];if(Array.isArray(e))for(let d=0;d<e.length;d++){const c=this.extend(this.parseOrder(e[d],t),n);r.push(c)}else{const d=Object.keys(e);for(let c=0;c<d.length;c++){const u=d[c],h=this.extend(this.parseOrder(this.extend({id:u},e[u]),t),n);r.push(h)}}r=this.sortBy(r,"timestamp");const a=t!==void 0?t.symbol:void 0,o=s===void 0;return this.filterBySymbolSinceLimit(r,a,s,i,o)}calculateFee(e,t,s,i,n,r="taker",a={}){if(t==="market"&&r==="maker")throw new Ca(this.id+' calculateFee() - you have provided incompatible arguments - "market" type order can not be "maker". Change either the "type" or the "takerOrMaker" argument to calculate the fee.');const o=this.markets[e],d=this.safeString(o,"feeSide","quote");let c="quote",u;const h=this.numberToString(i),l=this.numberToString(n);d==="quote"?u=it.stringMul(h,l):d==="base"?u=h:d==="get"?(u=h,s==="sell"?u=it.stringMul(u,l):c="base"):d==="give"&&(u=h,s==="buy"?u=it.stringMul(u,l):c="base"),o.spot||(c="settle"),t==="market"&&(r="taker");const p=this.safeString(o,r);return u!==void 0&&(u=it.stringMul(u,p)),{type:r,currency:o[c],rate:this.parseNumber(p),cost:this.parseNumber(u)}}safeTrade(e,t=void 0){const s=this.safeString(e,"amount"),i=this.safeString(e,"price");let n=this.safeString(e,"cost");if(n===void 0){const u=this.safeString(t,"contractSize");let h=i;u!==void 0&&(this.safeValue(t,"inverse",!1)&&(h=it.stringDiv("1",i)),h=it.stringMul(h,u)),n=it.stringMul(h,s)}const r=this.safeValue(e,"fee")===void 0,a=this.safeValue(e,"fees")===void 0,o=r||a,d=[];if(o){const u=this.safeValue(e,"fees");if(u!==void 0)for(let h=0;h<u.length;h++){const l=u[h];d.push(this.extend({},l))}else{const h=this.safeValue(e,"fee");h!==void 0&&d.push(this.extend({},h))}}const c=this.safeValue(e,"fee");if(o){const u=this.reduceFees?this.reduceFeesByCurrency(d):d,h=u.length;for(let p=0;p<h;p++)u[p].cost=this.safeNumber(u[p],"cost"),"rate"in u[p]&&(u[p].rate=this.safeNumber(u[p],"rate"));!r&&h===0&&(c.cost=this.safeNumber(c,"cost"),"rate"in c&&(c.rate=this.safeNumber(c,"rate")),u.push(c)),a&&(e.fees=u),r&&h===1&&(e.fee=u[0]);const l=this.safeValue(e,"fee");l!==void 0&&(l.cost=this.safeNumber(l,"cost"),"rate"in l&&(l.rate=this.safeNumber(l,"rate")),e.fee=l)}return e.amount=this.parseNumber(s),e.price=this.parseNumber(i),e.cost=this.parseNumber(n),e}reduceFeesByCurrency(e){const t={};for(let n=0;n<e.length;n++){const r=e[n],a=this.safeString(r,"currency");if(a!==void 0){const o=this.safeString(r,"rate"),d=this.safeValue(r,"cost");if(it.stringEq(d,"0"))continue;a in t||(t[a]={});const c=o===void 0?"":o;c in t[a]?t[a][c].cost=it.stringAdd(t[a][c].cost,d):(t[a][c]={currency:a,cost:d},o!==void 0&&(t[a][c].rate=o))}}let s=[];const i=Object.values(t);for(let n=0;n<i.length;n++){const r=Object.values(i[n]);s=this.arrayConcat(s,r)}return s}safeTicker(e,t=void 0){let s=this.safeValue(e,"open"),i=this.safeValue(e,"close"),n=this.safeValue(e,"last"),r=this.safeValue(e,"change"),a=this.safeValue(e,"percentage"),o=this.safeValue(e,"average"),d=this.safeValue(e,"vwap");const c=this.safeValue(e,"baseVolume"),u=this.safeValue(e,"quoteVolume");return d===void 0&&(d=it.stringDiv(u,c)),n!==void 0&&i===void 0?i=n:n===void 0&&i!==void 0&&(n=i),n!==void 0&&s!==void 0&&(r===void 0&&(r=it.stringSub(n,s)),o===void 0&&(o=it.stringDiv(it.stringAdd(n,s),"2"))),a===void 0&&r!==void 0&&s!==void 0&&it.stringGt(s,"0")&&(a=it.stringMul(it.stringDiv(r,s),"100")),r===void 0&&a!==void 0&&s!==void 0&&(r=it.stringDiv(it.stringMul(a,s),"100")),s===void 0&&n!==void 0&&r!==void 0&&(s=it.stringSub(n,r)),this.extend(e,{bid:this.safeNumber(e,"bid"),bidVolume:this.safeNumber(e,"bidVolume"),ask:this.safeNumber(e,"ask"),askVolume:this.safeNumber(e,"askVolume"),high:this.safeNumber(e,"high"),low:this.safeNumber(e,"low"),open:this.parseNumber(s),close:this.parseNumber(i),last:this.parseNumber(n),change:this.parseNumber(r),percentage:this.parseNumber(a),average:this.parseNumber(o),vwap:this.parseNumber(d),baseVolume:this.parseNumber(c),quoteVolume:this.parseNumber(u),previousClose:this.safeNumber(e,"previousClose")})}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){if(!this.has.fetchTrades)throw new He(this.id+" fetchOHLCV() is not supported yet");await this.loadMarkets();const r=await this.fetchTrades(e,s,i,n),a=this.buildOHLCVC(r,t,s,i),o=[];for(let d=0;d<a.length;d++)o.push([this.safeInteger(a[d],0),this.safeNumber(a[d],1),this.safeNumber(a[d],2),this.safeNumber(a[d],3),this.safeNumber(a[d],4),this.safeNumber(a[d],5)]);return o}convertTradingViewToOHLCV(e,t="t",s="o",i="h",n="l",r="c",a="v",o=!1){const d=[],c=this.safeValue(e,t,[]),u=this.safeValue(e,s,[]),h=this.safeValue(e,i,[]),l=this.safeValue(e,n,[]),p=this.safeValue(e,r,[]),m=this.safeValue(e,a,[]);for(let g=0;g<c.length;g++)d.push([o?this.safeInteger(c,g):this.safeTimestamp(c,g),this.safeValue(u,g),this.safeValue(h,g),this.safeValue(l,g),this.safeValue(p,g),this.safeValue(m,g)]);return d}convertOHLCVToTradingView(e,t="t",s="o",i="h",n="l",r="c",a="v",o=!1){const d={};d[t]=[],d[s]=[],d[i]=[],d[n]=[],d[r]=[],d[a]=[];for(let c=0;c<e.length;c++){const u=o?e[c][0]:parseInt(e[c][0]/1e3);d[t].push(u),d[s].push(e[c][1]),d[i].push(e[c][2]),d[n].push(e[c][3]),d[r].push(e[c][4]),d[a].push(e[c][5])}return d}marketIds(e){const t=[];for(let s=0;s<e.length;s++)t.push(this.marketId(e[s]));return t}marketSymbols(e){if(e===void 0)return e;const t=[];for(let s=0;s<e.length;s++)t.push(this.symbol(e[s]));return t}marketCodes(e){if(e===void 0)return e;const t=[];for(let s=0;s<e.length;s++)t.push(this.commonCurrencyCode(e[s]));return t}parseBidsAsks(e,t=0,s=1){e=this.toArray(e);const i=[];for(let n=0;n<e.length;n++)i.push(this.parseBidAsk(e[n],t,s));return i}async fetchL2OrderBook(e,t=void 0,s={}){const i=await this.fetchOrderBook(e,t,s);return this.extend(i,{asks:this.sortBy(this.aggregate(i.asks),0),bids:this.sortBy(this.aggregate(i.bids),0,!0)})}filterBySymbol(e,t=void 0){if(t===void 0)return e;const s=[];for(let i=0;i<e.length;i++)this.safeString(e[i],"symbol")===t&&s.push(e[i]);return s}parseOHLCV(e,t=void 0){return Array.isArray(e)?[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]:e}getNetwork(e,t){e=e.toUpperCase();const s={ETHEREUM:"ETH",ETHER:"ETH",ERC20:"ETH",ETH:"ETH",TRC20:"TRX",TRON:"TRX",TRX:"TRX",BEP20:"BSC",BSC:"BSC",HRC20:"HT",HECO:"HT",SPL:"SOL",SOL:"SOL",TERRA:"LUNA",LUNA:"LUNA",POLYGON:"MATIC",MATIC:"MATIC",EOS:"EOS",WAVES:"WAVES",AVALANCHE:"AVAX",AVAX:"AVAX",QTUM:"QTUM",CHZ:"CHZ",NEO:"NEO",ONT:"ONT",RON:"RON"};if(e===t)return e;if(e in s)return s[e];throw new He(this.id+" network "+e+" is not yet supported")}networkCodeToId(e){const t=this.safeValue(this.options,"networks",{});return this.safeString(t,e,e)}networkIdToCode(e){const t=this.safeValue(this.options,"networksById",{});return this.safeString(t,e,e)}handleNetworkCodeAndParams(e){const t=this.safeString2(e,"networkCode","network");return t!==void 0&&(e=this.omit(e,["networkCode","network"])),[t,e]}defaultNetworkCode(e){let t;const s=this.safeValue(this.options,"defaultNetworks",{});if(e in s)t=s[e];else{const i=this.safeValue(this.options,"defaultNetwork");i!==void 0&&(t=i)}return t}selectNetworkIdFromAvailableNetworks(e,t,s){let i;const n=Object.keys(s),r=n.length;if(t!==void 0){const a=this.networkCodeToId(t);if(r===0)throw new He(this.id+" - "+t+" network did not return any result for "+e);if(a in s)i=a;else throw new He(this.id+" - "+a+" network was not found for "+e+", use one of "+n.join(", "))}else{if(r===0)throw new He(this.id+" - no networks were returned for"+e);{const a=this.defaultNetworkCode(e),o=this.networkCodeToId(a);i=o in s?o:n[0]}}return i}safeNumber2(e,t,s,i=void 0){const n=this.safeString2(e,t,s);return this.parseNumber(n,i)}parseOrderBook(e,t,s=void 0,i="bids",n="asks",r=0,a=1){const o=this.parseBidsAsks(this.safeValue(e,i,[]),r,a),d=this.parseBidsAsks(this.safeValue(e,n,[]),r,a);return{symbol:t,bids:this.sortBy(o,0,!0),asks:this.sortBy(d,0),timestamp:s,datetime:this.iso8601(s),nonce:void 0}}parseOHLCVs(e,t=void 0,s="1m",i=void 0,n=void 0){const r=[];for(let d=0;d<e.length;d++)r.push(this.parseOHLCV(e[d],t));const a=this.sortBy(r,0),o=i===void 0;return this.filterBySinceLimit(a,i,n,0,o)}parseLeverageTiers(e,t=void 0,s=void 0){t=this.marketSymbols(t);const i={};for(let n=0;n<e.length;n++){const r=e[n],a=this.safeString(r,s),o=this.safeMarket(a),d=o.symbol;this.safeValue(o,"contract",!1)&&(t===void 0||this.inArray(d,t))&&(i[d]=this.parseMarketLeverageTiers(r,o))}return i}async loadTradingLimits(e=void 0,t=!1,s={}){if(this.has.fetchTradingLimits&&(t||!("limitsLoaded"in this.options))){const i=await this.fetchTradingLimits(e);for(let n=0;n<e.length;n++){const r=e[n];this.markets[r]=this.deepExtend(this.markets[r],i[r])}this.options.limitsLoaded=this.milliseconds()}return this.markets}parsePositions(e,t=void 0,s={}){t=this.marketSymbols(t),e=this.toArray(e);const i=[];for(let n=0;n<e.length;n++){const r=this.extend(this.parsePosition(e[n],void 0),s);i.push(r)}return this.filterByArray(i,"symbol",t,!1)}parseAccounts(e,t={}){e=this.toArray(e);const s=[];for(let i=0;i<e.length;i++){const n=this.extend(this.parseAccount(e[i]),t);s.push(n)}return s}parseTrades(e,t=void 0,s=void 0,i=void 0,n={}){e=this.toArray(e);let r=[];for(let d=0;d<e.length;d++){const c=this.extend(this.parseTrade(e[d],t),n);r.push(c)}r=this.sortBy2(r,"timestamp","id");const a=t!==void 0?t.symbol:void 0,o=s===void 0;return this.filterBySymbolSinceLimit(r,a,s,i,o)}parseTransactions(e,t=void 0,s=void 0,i=void 0,n={}){e=this.toArray(e);let r=[];for(let d=0;d<e.length;d++){const c=this.extend(this.parseTransaction(e[d],t),n);r.push(c)}r=this.sortBy(r,"timestamp");const a=t!==void 0?t.code:void 0,o=s===void 0;return this.filterByCurrencySinceLimit(r,a,s,i,o)}parseTransfers(e,t=void 0,s=void 0,i=void 0,n={}){e=this.toArray(e);let r=[];for(let d=0;d<e.length;d++){const c=this.extend(this.parseTransfer(e[d],t),n);r.push(c)}r=this.sortBy(r,"timestamp");const a=t!==void 0?t.code:void 0,o=s===void 0;return this.filterByCurrencySinceLimit(r,a,s,i,o)}parseLedger(e,t=void 0,s=void 0,i=void 0,n={}){let r=[];const a=this.toArray(e);for(let c=0;c<a.length;c++){const u=this.parseLedgerEntry(a[c],t);if(Array.isArray(u))for(let h=0;h<u.length;h++)r.push(this.extend(u[h],n));else r.push(this.extend(u,n))}r=this.sortBy(r,"timestamp");const o=t!==void 0?t.code:void 0,d=s===void 0;return this.filterByCurrencySinceLimit(r,o,s,i,d)}nonce(){return this.seconds()}setHeaders(e){return e}marketId(e){const t=this.market(e);return t!==void 0?t.id:e}symbol(e){const t=this.market(e);return this.safeString(t,"symbol",e)}resolvePath(e,t){return[this.implodeParams(e,t),this.omit(t,this.extractParams(e))]}filterByArray(e,t,s=void 0,i=!0){if(e=this.toArray(e),s===void 0||!s)return i?this.indexBy(e,t):e;const n=[];for(let r=0;r<e.length;r++)this.inArray(e[r][t],s)&&n.push(e[r]);return i?this.indexBy(n,t):n}async fetch2(e,t="public",s="GET",i={},n=void 0,r=void 0,a={},o={}){if(this.enableRateLimit){const c=this.calculateRateLimiterCost(t,s,e,i,a,o);await this.throttle(c)}this.lastRestRequestTimestamp=this.milliseconds();const d=this.sign(e,t,s,i,n,r);return await this.fetch(d.url,d.method,d.headers,d.body)}async request(e,t="public",s="GET",i={},n=void 0,r=void 0,a={},o={}){return await this.fetch2(e,t,s,i,n,r,a,o)}async loadAccounts(e=!1,t={}){if(e)this.accounts=await this.fetchAccounts(t);else{if(this.accounts)return this.accounts;this.accounts=await this.fetchAccounts(t)}return this.accountsById=this.indexBy(this.accounts,"id"),this.accounts}async fetchTrades(e,t=void 0,s=void 0,i={}){throw new He(this.id+" fetchTrades() is not supported yet")}async fetchOHLCVC(e,t="1m",s=void 0,i=void 0,n={}){if(!this.has.fetchTrades)throw new He(this.id+" fetchOHLCV() is not supported yet");await this.loadMarkets();const r=await this.fetchTrades(e,s,i,n);return this.buildOHLCVC(r,t,s,i)}parseTradingViewOHLCV(e,t=void 0,s="1m",i=void 0,n=void 0){const r=this.convertTradingViewToOHLCV(e);return this.parseOHLCVs(r,t,s,i,n)}async editLimitBuyOrder(e,t,s,i=void 0,n={}){return await this.editLimitOrder(e,t,"buy",s,i,n)}async editLimitSellOrder(e,t,s,i=void 0,n={}){return await this.editLimitOrder(e,t,"sell",s,i,n)}async editLimitOrder(e,t,s,i,n=void 0,r={}){return await this.editOrder(e,t,"limit",s,i,n,r)}async editOrder(e,t,s,i,n,r=void 0,a={}){return await this.cancelOrder(e,t),await this.createOrder(t,s,i,n,r,a)}async fetchPermissions(e={}){throw new He(this.id+" fetchPermissions() is not supported yet")}async fetchPosition(e,t={}){throw new He(this.id+" fetchPosition() is not supported yet")}async fetchPositions(e=void 0,t={}){throw new He(this.id+" fetchPositions() is not supported yet")}async fetchPositionsRisk(e=void 0,t={}){throw new He(this.id+" fetchPositionsRisk() is not supported yet")}async fetchBidsAsks(e=void 0,t={}){throw new He(this.id+" fetchBidsAsks() is not supported yet")}parseBidAsk(e,t=0,s=1){const i=this.safeNumber(e,t),n=this.safeNumber(e,s);return[i,n]}safeCurrency(e,t=void 0){if(e===void 0&&t!==void 0)return t;if(this.currencies_by_id!==void 0&&e in this.currencies_by_id&&this.currencies_by_id[e]!==void 0)return this.currencies_by_id[e];let s=e;return e!==void 0&&(s=this.commonCurrencyCode(e.toUpperCase())),{id:e,code:s}}safeMarket(e=void 0,t=void 0,s=void 0){const i={id:e,symbol:e,base:void 0,quote:void 0,baseId:void 0,quoteId:void 0,active:void 0,type:void 0,linear:void 0,inverse:void 0,spot:!1,swap:!1,future:!1,option:!1,margin:!1,contract:!1,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,optionType:void 0,strike:void 0,settle:void 0,settleId:void 0,precision:{amount:void 0,price:void 0},limits:{amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:void 0};if(e!==void 0){if(this.markets_by_id!==void 0&&e in this.markets_by_id)t=this.markets_by_id[e];else if(s!==void 0){const n=e.split(s);return n.length===2&&(i.baseId=this.safeString(n,0),i.quoteId=this.safeString(n,1),i.base=this.safeCurrencyCode(i.baseId),i.quote=this.safeCurrencyCode(i.quoteId),i.symbol=i.base+"/"+i.quote),i}}return t!==void 0?t:i}checkRequiredCredentials(e=!0){const t=Object.keys(this.requiredCredentials);for(let s=0;s<t.length;s++){const i=t[s];if(this.requiredCredentials[i]&&!this[i]){if(e)throw new Qp(this.id+' requires "'+i+'" credential');return e}}return!0}oath(){if(this.twofa!==void 0)return this.totp(this.twofa);throw new Gr(this.id+" exchange.twofa has not been set for 2FA Two-Factor Authentication")}async fetchBalance(e={}){throw new He(this.id+" fetchBalance() is not supported yet")}async fetchPartialBalance(e,t={}){return(await this.fetchBalance(t))[e]}async fetchFreeBalance(e={}){return await this.fetchPartialBalance("free",e)}async fetchUsedBalance(e={}){return await this.fetchPartialBalance("used",e)}async fetchTotalBalance(e={}){return await this.fetchPartialBalance("total",e)}async fetchStatus(e={}){if(this.has.fetchTime){const t=await this.fetchTime(e);this.status=this.extend(this.status,{updated:t})}return this.status}async fetchFundingFee(e,t={}){if(this.safeValue(this.options,"warnOnFetchFundingFee",!0))throw new He(this.id+' fetchFundingFee() method is deprecated, it will be removed in July 2022, please, use fetchTransactionFee() or set exchange.options["warnOnFetchFundingFee"] = false to suppress this warning');return await this.fetchTransactionFee(e,t)}async fetchFundingFees(e=void 0,t={}){if(this.safeValue(this.options,"warnOnFetchFundingFees",!0))throw new He(this.id+' fetchFundingFees() method is deprecated, it will be removed in July 2022. Please, use fetchTransactionFees() or set exchange.options["warnOnFetchFundingFees"] = false to suppress this warning');return await this.fetchTransactionFees(e,t)}async fetchTransactionFee(e,t={}){if(!this.has.fetchTransactionFees)throw new He(this.id+" fetchTransactionFee() is not supported yet");return await this.fetchTransactionFees([e],t)}async fetchTransactionFees(e=void 0,t={}){throw new He(this.id+" fetchTransactionFees() is not supported yet")}async fetchDepositWithdrawFee(e,t={}){if(!this.has.fetchDepositWithdrawFees)throw new He(this.id+" fetchDepositWithdrawFee() is not supported yet");const s=await this.fetchDepositWithdrawFees([e],t);return this.safeValue(s,e)}getSupportedMapping(e,t={}){if(e in t)return t[e];throw new He(this.id+" "+e+" does not have a value in mapping")}async fetchBorrowRate(e,t={}){if(await this.loadMarkets(),!this.has.fetchBorrowRates)throw new He(this.id+" fetchBorrowRate() is not supported yet");const s=await this.fetchBorrowRates(t),i=this.safeValue(s,e);if(i===void 0)throw new Gr(this.id+" fetchBorrowRate() could not find the borrow rate for currency code "+e);return i}handleOptionAndParams(e,t,s,i=void 0){const n="default"+this.capitalize(s);let r=this.safeString2(e,s,n);if(r!==void 0&&(e=this.omit(e,[s,n])),r===void 0){const a=this.safeValue(this.options,t);a!==void 0&&(r=this.safeString2(a,s,n))}return r===void 0&&(r=this.safeString2(this.options,s,n)),r=r!==void 0?r:i,[r,e]}handleMarketTypeAndParams(e,t=void 0,s={}){const i=this.safeString2(this.options,"defaultType","type","spot"),n=this.safeValue(this.options,e);let r=i;n!==void 0&&(typeof n=="string"?r=n:r=this.safeString2(n,"defaultType","type",r));const a=t===void 0?r:t.type,o=this.safeString2(s,"defaultType","type",a);return s=this.omit(s,["defaultType","type"]),[o,s]}handleSubTypeAndParams(e,t=void 0,s={},i="linear"){let n;const r=this.safeString2(s,"subType","defaultSubType");return r!==void 0?(n=r,s=this.omit(s,["subType","defaultSubType"])):(t!==void 0&&(t.linear?n="linear":t.inverse&&(n="inverse")),n===void 0&&(n=this.handleOptionAndParams(void 0,e,"subType",i)[0])),[n,s]}handleMarginModeAndParams(e,t={},s=void 0){return this.handleOptionAndParams(t,e,"marginMode",s)}throwExactlyMatchedException(e,t,s){if(t in e)throw new e[t](s)}throwBroadlyMatchedException(e,t,s){const i=this.findBroadlyMatchedKey(e,t);if(i!==void 0)throw new e[i](s)}findBroadlyMatchedKey(e,t){const s=Object.keys(e);for(let i=0;i<s.length;i++){const n=s[i];if(t!==void 0&&t.indexOf(n)>=0)return n}}handleErrors(e,t,s,i,n,r,a,o,d){}calculateRateLimiterCost(e,t,s,i,n={},r={}){return this.safeValue(n,"cost",1)}async fetchTicker(e,t={}){if(this.has.fetchTickers){const s=await this.fetchTickers([e],t),i=this.safeValue(s,e);if(i===void 0)throw new B1(this.id+" fetchTickers() could not find a ticker for "+e);return i}else throw new He(this.id+" fetchTicker() is not supported yet")}async fetchTickers(e=void 0,t={}){throw new He(this.id+" fetchTickers() is not supported yet")}async fetchOrder(e,t=void 0,s={}){throw new He(this.id+" fetchOrder() is not supported yet")}async fetchOrderStatus(e,t=void 0,s={}){return(await this.fetchOrder(e,t,s)).status}async fetchUnifiedOrder(e,t={}){return await this.fetchOrder(this.safeValue(e,"id"),this.safeValue(e,"symbol"),t)}async createOrder(e,t,s,i,n=void 0,r={}){throw new He(this.id+" createOrder() is not supported yet")}async cancelOrder(e,t=void 0,s={}){throw new He(this.id+" cancelOrder() is not supported yet")}async cancelUnifiedOrder(e,t={}){return this.cancelOrder(this.safeValue(e,"id"),this.safeValue(e,"symbol"),t)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){throw new He(this.id+" fetchOrders() is not supported yet")}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){throw new He(this.id+" fetchOpenOrders() is not supported yet")}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){throw new He(this.id+" fetchClosedOrders() is not supported yet")}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){throw new He(this.id+" fetchMyTrades() is not supported yet")}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){throw new He(this.id+" fetchTransactions() is not supported yet")}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){throw new He(this.id+" fetchDeposits() is not supported yet")}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){throw new He(this.id+" fetchWithdrawals() is not supported yet")}async fetchDepositAddress(e,t={}){if(this.has.fetchDepositAddresses){const s=await this.fetchDepositAddresses([e],t),i=this.safeValue(s,e);if(i===void 0)throw new Yp(this.id+" fetchDepositAddress() could not find a deposit address for "+e+", make sure you have created a corresponding deposit address in your wallet on the exchange website");return i}else throw new He(this.id+" fetchDepositAddress() is not supported yet")}account(){return{free:void 0,used:void 0,total:void 0}}commonCurrencyCode(e){return this.substituteCommonCurrencyCodes?this.safeString(this.commonCurrencies,e,e):e}currency(e){if(this.currencies===void 0)throw new Gr(this.id+" currencies not loaded");if(typeof e=="string"){if(e in this.currencies)return this.currencies[e];if(e in this.currencies_by_id)return this.currencies_by_id[e]}throw new Gr(this.id+" does not have currency code "+e)}market(e){if(this.markets===void 0)throw new Gr(this.id+" markets not loaded");if(this.markets_by_id===void 0)throw new Gr(this.id+" markets not loaded");if(typeof e=="string"){if(e in this.markets)return this.markets[e];if(e in this.markets_by_id)return this.markets_by_id[e]}throw new Xp(this.id+" does not have market symbol "+e)}handleWithdrawTagAndParams(e,t){return typeof e=="object"&&(t=this.extend(e,t),e=void 0),e===void 0&&(e=this.safeString(t,"tag"),e!==void 0&&(t=this.omit(t,"tag"))),[e,t]}async createLimitOrder(e,t,s,i,n={}){return await this.createOrder(e,"limit",t,s,i,n)}async createMarketOrder(e,t,s,i=void 0,n={}){return await this.createOrder(e,"market",t,s,i,n)}async createLimitBuyOrder(e,t,s,i={}){return await this.createOrder(e,"limit","buy",t,s,i)}async createLimitSellOrder(e,t,s,i={}){return await this.createOrder(e,"limit","sell",t,s,i)}async createMarketBuyOrder(e,t,s={}){return await this.createOrder(e,"market","buy",t,void 0,s)}async createMarketSellOrder(e,t,s={}){return await this.createOrder(e,"market","sell",t,void 0,s)}costToPrecision(e,t){const s=this.market(e);return this.decimalToPrecision(t,N1,s.precision.price,this.precisionMode,this.paddingMode)}priceToPrecision(e,t){const s=this.market(e);return this.decimalToPrecision(t,Jp,s.precision.price,this.precisionMode,this.paddingMode)}amountToPrecision(e,t){const s=this.market(e);return this.decimalToPrecision(t,N1,s.precision.amount,this.precisionMode,this.paddingMode)}feeToPrecision(e,t){const s=this.market(e);return this.decimalToPrecision(t,Jp,s.precision.price,this.precisionMode,this.paddingMode)}currencyToPrecision(e,t,s=void 0){const i=this.currencies[e];let n=this.safeValue(i,"precision");if(s!==void 0){const r=this.safeValue(i,"networks",{}),a=this.safeValue(r,s,{});n=this.safeValue(a,"precision",n)}return n===void 0?t:this.decimalToPrecision(t,Jp,n,this.precisionMode,this.paddingMode)}safeNumber(e,t,s=void 0){const i=this.safeString(e,t);return this.parseNumber(i,s)}safeNumberN(e,t,s=void 0){const i=this.safeStringN(e,t);return this.parseNumber(i,s)}parsePrecision(e){if(e!==void 0)return"1e"+it.stringNeg(e)}async loadTimeDifference(e={}){const t=await this.fetchTime(e),s=this.milliseconds();return this.options.timeDifference=s-t,this.options.timeDifference}implodeHostname(e){return this.implodeParams(e,{hostname:this.hostname})}async fetchMarketLeverageTiers(e,t={}){if(this.has.fetchLeverageTiers){if(!(await this.market(e)).contract)throw new Xp(this.id+" fetchMarketLeverageTiers() supports contract markets only");const i=await this.fetchLeverageTiers([e]);return this.safeValue(i,e)}else throw new He(this.id+" fetchMarketLeverageTiers() is not supported yet")}async createPostOnlyOrder(e,t,s,i,n,r={}){if(!this.has.createPostOnlyOrder)throw new He(this.id+"createPostOnlyOrder() is not supported yet");const a=this.extend(r,{postOnly:!0});return await this.createOrder(e,t,s,i,n,a)}async createReduceOnlyOrder(e,t,s,i,n,r={}){if(!this.has.createReduceOnlyOrder)throw new He(this.id+"createReduceOnlyOrder() is not supported yet");const a=this.extend(r,{reduceOnly:!0});return await this.createOrder(e,t,s,i,n,a)}async createStopOrder(e,t,s,i,n=void 0,r=void 0,a={}){if(!this.has.createStopOrder)throw new He(this.id+" createStopOrder() is not supported yet");if(r===void 0)throw new Ca(this.id+" create_stop_order() requires a stopPrice argument");const o=this.extend(a,{stopPrice:r});return await this.createOrder(e,t,s,i,n,o)}async createStopLimitOrder(e,t,s,i,n,r={}){if(!this.has.createStopLimitOrder)throw new He(this.id+" createStopLimitOrder() is not supported yet");const a=this.extend(r,{stopPrice:n});return await this.createOrder(e,"limit",t,s,i,a)}async createStopMarketOrder(e,t,s,i,n={}){if(!this.has.createStopMarketOrder)throw new He(this.id+" createStopMarketOrder() is not supported yet");const r=this.extend(n,{stopPrice:i});return await this.createOrder(e,"market",t,s,void 0,r)}safeCurrencyCode(e,t=void 0){return t=this.safeCurrency(e,t),t.code}filterBySymbolSinceLimit(e,t=void 0,s=void 0,i=void 0,n=!1){return this.filterByValueSinceLimit(e,"symbol",t,s,i,"timestamp",n)}filterByCurrencySinceLimit(e,t=void 0,s=void 0,i=void 0,n=!1){return this.filterByValueSinceLimit(e,"currency",t,s,i,"timestamp",n)}parseTickers(e,t=void 0,s={}){const i=[];if(Array.isArray(e))for(let n=0;n<e.length;n++){const r=this.extend(this.parseTicker(e[n]),s);i.push(r)}else{const n=Object.keys(e);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeMarket(a),d=this.extend(this.parseTicker(e[a],o),s);i.push(d)}}return t=this.marketSymbols(t),this.filterByArray(i,"symbol",t)}parseDepositAddresses(e,t=void 0,s=!0,i={}){let n=[];for(let r=0;r<e.length;r++){const a=this.extend(this.parseDepositAddress(e[r]),i);n.push(a)}return t!==void 0&&(n=this.filterByArray(n,"currency",t,!1)),n=s?this.indexBy(n,"currency"):n,n}parseBorrowInterests(e,t=void 0){const s=[];for(let i=0;i<e.length;i++){const n=e[i];s.push(this.parseBorrowInterest(n,t))}return s}parseFundingRateHistories(e,t=void 0,s=void 0,i=void 0){const n=[];for(let o=0;o<e.length;o++){const d=e[o];n.push(this.parseFundingRateHistory(d,t))}const r=this.sortBy(n,"timestamp"),a=t===void 0?void 0:t.symbol;return this.filterBySymbolSinceLimit(r,a,s,i)}safeSymbol(e,t=void 0,s=void 0){return t=this.safeMarket(e,t,s),t.symbol}parseFundingRate(e,t=void 0){throw new He(this.id+" parseFundingRate() is not supported yet")}parseFundingRates(e,t=void 0){const s={};for(let i=0;i<e.length;i++){const n=this.parseFundingRate(e[i],t);s[n.symbol]=n}return s}isTriggerOrder(e){const t=this.safeValue2(e,"trigger","stop");return t&&(e=this.omit(e,["trigger","stop"])),[t,e]}isPostOnly(e,t,s={}){const i=this.safeStringUpper(s,"timeInForce");let n=this.safeValue2(s,"postOnly","post_only",!1);const r=i==="IOC",a=i==="FOK";if(n=n||i==="PO"||t,n){if(r||a)throw new E1(this.id+" postOnly orders cannot have timeInForce equal to "+i);if(e)throw new E1(this.id+" market orders cannot be postOnly");return!0}else return!1}async fetchTradingFees(e={}){throw new He(this.id+" fetchTradingFees() is not supported yet")}async fetchTradingFee(e,t={}){if(!this.has.fetchTradingFees)throw new He(this.id+" fetchTradingFee() is not supported yet");return await this.fetchTradingFees(t)}parseOpenInterest(e,t=void 0){throw new He(this.id+" parseOpenInterest () is not supported yet")}parseOpenInterests(e,t=void 0,s=void 0,i=void 0){const n=[];for(let o=0;o<e.length;o++){const d=e[o],c=this.parseOpenInterest(d,t);n.push(c)}const r=this.sortBy(n,"timestamp"),a=this.safeString(t,"symbol");return this.filterBySymbolSinceLimit(r,a,s,i)}async fetchFundingRate(e,t={}){if(this.has.fetchFundingRates){if(await this.loadMarkets(),!this.market(e).contract)throw new Xp(this.id+" fetchFundingRate() supports contract markets only");const i=await this.fetchFundingRates([e],t),n=this.safeValue(i,e);if(n===void 0)throw new B1(this.id+" fetchFundingRate () returned no data for "+e);return n}else throw new He(this.id+" fetchFundingRate () is not supported yet")}async fetchMarkOHLCV(e,t="1m",s=void 0,i=void 0,n={}){if(this.has.fetchMarkOHLCV){const r={price:"mark"};return await this.fetchOHLCV(e,t,s,i,this.extend(r,n))}else throw new He(this.id+" fetchMarkOHLCV () is not supported yet")}async fetchIndexOHLCV(e,t="1m",s=void 0,i=void 0,n={}){if(this.has.fetchIndexOHLCV){const r={price:"index"};return await this.fetchOHLCV(e,t,s,i,this.extend(r,n))}else throw new He(this.id+" fetchIndexOHLCV () is not supported yet")}async fetchPremiumIndexOHLCV(e,t="1m",s=void 0,i=void 0,n={}){if(this.has.fetchPremiumIndexOHLCV){const r={price:"premiumIndex"};return await this.fetchOHLCV(e,t,s,i,this.extend(r,n))}else throw new He(this.id+" fetchPremiumIndexOHLCV () is not supported yet")}handleTimeInForce(e={}){const t=this.safeStringUpper(e,"timeInForce");if(t!==void 0){const s=this.safeString(this.options.timeInForce,t);if(s===void 0)throw new Gr(this.id+' does not support timeInForce "'+t+'"');return s}}convertTypeToAccount(e){const t=this.safeValue(this.options,"accountsByType",{}),s=e.toLowerCase();return s in t?t[s]:e in this.markets||e in this.markets_by_id?this.market(e).id:e}checkRequiredArgument(e,t,s,i=[]){if(t===void 0||i.length>0&&!this.inArray(t,i)){const n=i.join(", ");let r=this.id+" "+e+"() requires a "+s+" argument";throw n!==""&&(r+=", one of ("+n+")"),new Ca(r)}}checkRequiredMarginArgument(e,t,s){if(s==="isolated"&&t===void 0)throw new Ca(this.id+" "+e+"() requires a symbol argument for isolated margin");if(s==="cross"&&t!==void 0)throw new Ca(this.id+" "+e+"() cannot have a symbol argument for cross margin")}checkRequiredSymbol(e,t){this.checkRequiredArgument(e,t,"symbol")}parseDepositWithdrawFees(e,t=void 0,s=void 0){const i={};t=this.marketCodes(t);const n=Array.isArray(e);let r=e;n||(r=Object.keys(e));for(let a=0;a<r.length;a++){const o=r[a],d=n?o:e[o],c=n?this.safeString(d,s):o,u=this.safeValue(this.currencies_by_id,c),h=this.safeString(u,"code",c);(t===void 0||this.inArray(h,t))&&(i[h]=this.parseDepositWithdrawFee(d,u))}return i}depositWithdrawFee(e){return{info:e,withdraw:{fee:void 0,percentage:void 0},deposit:{fee:void 0,percentage:void 0},networks:{}}}};const{inflateRawSync:CV,gunzipSync:MV}=Et;function T_(f){return CV(f).toString()}function PV(f){return T_(Buffer.from(f,"base64"))}function AV(f){return MV(f).toString()}var O_={inflate:T_,inflate64:PV,gunzip:AV},BV=function(){let e,t;const s=new Promise((i,n)=>{e=i,t=n});return s.resolve=function(){e.apply(this,arguments)},s.reject=function(){t.apply(this,arguments)},s};const EV=de,NV=Fu,{isNode:VV,isJsonEncodedObject:qV,deepExtend:LV,milliseconds:em}=NV,{RequestTimeout:q1,NetworkError:L1,NotSupported:tm,BaseError:RV}=EV,{inflate:FV,gunzip:HV}=O_,R1=BV;var GV=class{constructor(e,t,s,i,n,r={}){Object.assign(this,LV({url:e,onMessageCallback:t,onErrorCallback:s,onCloseCallback:i,onConnectedCallback:n,verbose:!1,protocols:void 0,options:void 0,futures:{},subscriptions:{},rejections:{},connected:void 0,error:void 0,connectionStarted:void 0,connectionEstablished:void 0,isConnected:!1,connectionTimer:void 0,connectionTimeout:1e4,pingInterval:void 0,ping:void 0,keepAlive:3e4,maxPingPongMisses:2,connection:void 0,startedConnecting:!1,gunzip:!1,inflate:!1},r)),this.connected=R1()}future(e){e in this.futures||(this.futures[e]=R1());const t=this.futures[e];return e in this.rejections&&(t.reject(this.rejections[e]),delete this.rejections[e]),t}resolve(e,t){return this.verbose&&t===void 0&&this.log(new Date,"resolve received undefined messageHash"),t in this.futures&&(this.futures[t].resolve(e),delete this.futures[t]),e}reject(e,t=void 0){if(t)t in this.futures?(this.futures[t].reject(e),delete this.futures[t]):this.rejections[t]=e;else{const s=Object.keys(this.futures);for(let i=0;i<s.length;i++)this.reject(e,s[i])}return e}log(...e){console.log(...e)}connect(e=0){throw new tm("connect() not implemented yet")}isOpen(){throw new tm("isOpen() not implemented yet")}reset(e){this.clearConnectionTimeout(),this.clearPingInterval(),this.reject(e)}onConnectionTimeout(){if(!this.isOpen()){const e=new q1("Connection to "+this.url+" failed due to a connection timeout");this.onError(e),this.connection.close(1006)}}setConnectionTimeout(){if(this.connectionTimeout){const e=this.onConnectionTimeout.bind(this);this.connectionTimer=setTimeout(e,this.connectionTimeout)}}clearConnectionTimeout(){this.connectionTimer&&(this.connectionTimer=clearTimeout(this.connectionTimer))}setPingInterval(){if(this.keepAlive){const e=this.onPingInterval.bind(this);this.pingInterval=setInterval(e,this.keepAlive)}}clearPingInterval(){this.pingInterval&&(this.pingInterval=clearInterval(this.pingInterval))}onPingInterval(){if(this.keepAlive&&this.isOpen()){const e=em();this.lastPong=this.lastPong||e,this.lastPong+this.keepAlive*this.maxPingPongMisses<e?this.onError(new q1("Connection to "+this.url+" timed out due to a ping-pong keepalive missing on time")):this.ping?this.send(this.ping(this)):VV?this.connection.ping():this.lastPong=e}}onOpen(){this.verbose&&this.log(new Date,"onOpen"),this.connectionEstablished=em(),this.isConnected=!0,this.connected.resolve(this.url),this.clearConnectionTimeout(),this.setPingInterval(),this.onConnectedCallback(this)}onPing(){this.verbose&&this.log(new Date,"onPing")}onPong(){this.lastPong=em(),this.verbose&&this.log(new Date,"onPong")}onError(e){this.verbose&&this.log(new Date,"onError",e.message),e instanceof RV||(e=new L1(e.message)),this.error=e,this.reset(this.error),this.onErrorCallback(this,this.error)}onClose(e){this.verbose&&this.log(new Date,"onClose",e),this.error||this.reset(new L1("connection closed by remote server, closing code "+String(e.code))),this.onCloseCallback(this,e)}onUpgrade(e){this.verbose&&this.log(new Date,"onUpgrade")}send(e){this.verbose&&this.log(new Date,"sending",e),e=typeof e=="string"?e:JSON.stringify(e),this.connection.send(e)}close(){throw new tm("close() not implemented yet")}onMessage(e){e=e.data,e.byteLength!==void 0&&(this.gunzip?e=HV(e):this.inflate&&(e=FV(e)));try{e instanceof Buffer&&(e=e.toString()),qV(e)&&(e=JSON.parse(e.replace(/:(\d{15,}),/g,':"$1",'))),this.verbose&&this.log(new Date,"onMessage",e)}catch(t){this.log(new Date,"onMessage JSON.parse",t)}this.onMessageCallback(this,e)}},Xd={exports:{}},sm,F1;function wo(){return F1||(F1=1,sm={BINARY_TYPES:["nodebuffer","arraybuffer","fragments"],EMPTY_BUFFER:Buffer.alloc(0),GUID:"258EAFA5-E914-47DA-95CA-C5AB0DC85B11",kForOnEventAttribute:Symbol("kIsForOnEventAttribute"),kListener:Symbol("kListener"),kStatusCode:Symbol("status-code"),kWebSocket:Symbol("websocket"),NOOP:()=>{}}),sm}const UV={},$V=Object.freeze(Object.defineProperty({__proto__:null,default:UV},Symbol.toStringTag,{value:"Module"})),jV=Ly($V);var D1;function Dl(){if(D1)return Xd.exports;D1=1;const{EMPTY_BUFFER:f}=wo();function e(r,a){if(r.length===0)return f;if(r.length===1)return r[0];const o=Buffer.allocUnsafe(a);let d=0;for(let c=0;c<r.length;c++){const u=r[c];o.set(u,d),d+=u.length}return d<a?o.slice(0,d):o}function t(r,a,o,d,c){for(let u=0;u<c;u++)o[d+u]=r[u]^a[u&3]}function s(r,a){for(let o=0;o<r.length;o++)r[o]^=a[o&3]}function i(r){return r.byteLength===r.buffer.byteLength?r.buffer:r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}function n(r){if(n.readOnly=!0,Buffer.isBuffer(r))return r;let a;return r instanceof ArrayBuffer?a=Buffer.from(r):ArrayBuffer.isView(r)?a=Buffer.from(r.buffer,r.byteOffset,r.byteLength):(a=Buffer.from(r),n.readOnly=!1),a}if(Xd.exports={concat:e,mask:t,toArrayBuffer:i,toBuffer:n,unmask:s},!{}.WS_NO_BUFFER_UTIL)try{const r=jV;Xd.exports.mask=function(a,o,d,c,u){u<48?t(a,o,d,c,u):r.mask(a,o,d,c,u)},Xd.exports.unmask=function(a,o){a.length<32?s(a,o):r.unmask(a,o)}}catch{}return Xd.exports}var im,H1;function WV(){if(H1)return im;H1=1;const f=Symbol("kDone"),e=Symbol("kRun");class t{constructor(i){this[f]=()=>{this.pending--,this[e]()},this.concurrency=i||1/0,this.jobs=[],this.pending=0}add(i){this.jobs.push(i),this[e]()}[e](){if(this.pending!==this.concurrency&&this.jobs.length){const i=this.jobs.shift();this.pending++,i(this[f])}}}return im=t,im}var nm,G1;function Hl(){if(G1)return nm;G1=1;const f=Et,e=Dl(),t=WV(),{kStatusCode:s}=wo(),i=Buffer.from([0,0,255,255]),n=Symbol("permessage-deflate"),r=Symbol("total-length"),a=Symbol("callback"),o=Symbol("buffers"),d=Symbol("error");let c;class u{constructor(g,y,b){if(this._maxPayload=b|0,this._options=g||{},this._threshold=this._options.threshold!==void 0?this._options.threshold:1024,this._isServer=!!y,this._deflate=null,this._inflate=null,this.params=null,!c){const w=this._options.concurrencyLimit!==void 0?this._options.concurrencyLimit:10;c=new t(w)}}static get extensionName(){return"permessage-deflate"}offer(){const g={};return this._options.serverNoContextTakeover&&(g.server_no_context_takeover=!0),this._options.clientNoContextTakeover&&(g.client_no_context_takeover=!0),this._options.serverMaxWindowBits&&(g.server_max_window_bits=this._options.serverMaxWindowBits),this._options.clientMaxWindowBits?g.client_max_window_bits=this._options.clientMaxWindowBits:this._options.clientMaxWindowBits==null&&(g.client_max_window_bits=!0),g}accept(g){return g=this.normalizeParams(g),this.params=this._isServer?this.acceptAsServer(g):this.acceptAsClient(g),this.params}cleanup(){if(this._inflate&&(this._inflate.close(),this._inflate=null),this._deflate){const g=this._deflate[a];this._deflate.close(),this._deflate=null,g&&g(new Error("The deflate stream was closed while data was being processed"))}}acceptAsServer(g){const y=this._options,b=g.find(w=>!(y.serverNoContextTakeover===!1&&w.server_no_context_takeover||w.server_max_window_bits&&(y.serverMaxWindowBits===!1||typeof y.serverMaxWindowBits=="number"&&y.serverMaxWindowBits>w.server_max_window_bits)||typeof y.clientMaxWindowBits=="number"&&!w.client_max_window_bits));if(!b)throw new Error("None of the extension offers can be accepted");return y.serverNoContextTakeover&&(b.server_no_context_takeover=!0),y.clientNoContextTakeover&&(b.client_no_context_takeover=!0),typeof y.serverMaxWindowBits=="number"&&(b.server_max_window_bits=y.serverMaxWindowBits),typeof y.clientMaxWindowBits=="number"?b.client_max_window_bits=y.clientMaxWindowBits:(b.client_max_window_bits===!0||y.clientMaxWindowBits===!1)&&delete b.client_max_window_bits,b}acceptAsClient(g){const y=g[0];if(this._options.clientNoContextTakeover===!1&&y.client_no_context_takeover)throw new Error('Unexpected parameter "client_no_context_takeover"');if(!y.client_max_window_bits)typeof this._options.clientMaxWindowBits=="number"&&(y.client_max_window_bits=this._options.clientMaxWindowBits);else if(this._options.clientMaxWindowBits===!1||typeof this._options.clientMaxWindowBits=="number"&&y.client_max_window_bits>this._options.clientMaxWindowBits)throw new Error('Unexpected or invalid parameter "client_max_window_bits"');return y}normalizeParams(g){return g.forEach(y=>{Object.keys(y).forEach(b=>{let w=y[b];if(w.length>1)throw new Error(`Parameter "${b}" must have only a single value`);if(w=w[0],b==="client_max_window_bits"){if(w!==!0){const k=+w;if(!Number.isInteger(k)||k<8||k>15)throw new TypeError(`Invalid value for parameter "${b}": ${w}`);w=k}else if(!this._isServer)throw new TypeError(`Invalid value for parameter "${b}": ${w}`)}else if(b==="server_max_window_bits"){const k=+w;if(!Number.isInteger(k)||k<8||k>15)throw new TypeError(`Invalid value for parameter "${b}": ${w}`);w=k}else if(b==="client_no_context_takeover"||b==="server_no_context_takeover"){if(w!==!0)throw new TypeError(`Invalid value for parameter "${b}": ${w}`)}else throw new Error(`Unknown parameter "${b}"`);y[b]=w})}),g}decompress(g,y,b){c.add(w=>{this._decompress(g,y,(k,T)=>{w(),b(k,T)})})}compress(g,y,b){c.add(w=>{this._compress(g,y,(k,T)=>{w(),b(k,T)})})}_decompress(g,y,b){const w=this._isServer?"client":"server";if(!this._inflate){const k=`${w}_max_window_bits`,T=typeof this.params[k]!="number"?f.Z_DEFAULT_WINDOWBITS:this.params[k];this._inflate=f.createInflateRaw({...this._options.zlibInflateOptions,windowBits:T}),this._inflate[n]=this,this._inflate[r]=0,this._inflate[o]=[],this._inflate.on("error",p),this._inflate.on("data",l)}this._inflate[a]=b,this._inflate.write(g),y&&this._inflate.write(i),this._inflate.flush(()=>{const k=this._inflate[d];if(k){this._inflate.close(),this._inflate=null,b(k);return}const T=e.concat(this._inflate[o],this._inflate[r]);this._inflate._readableState.endEmitted?(this._inflate.close(),this._inflate=null):(this._inflate[r]=0,this._inflate[o]=[],y&&this.params[`${w}_no_context_takeover`]&&this._inflate.reset()),b(null,T)})}_compress(g,y,b){const w=this._isServer?"server":"client";if(!this._deflate){const k=`${w}_max_window_bits`,T=typeof this.params[k]!="number"?f.Z_DEFAULT_WINDOWBITS:this.params[k];this._deflate=f.createDeflateRaw({...this._options.zlibDeflateOptions,windowBits:T}),this._deflate[r]=0,this._deflate[o]=[],this._deflate.on("data",h)}this._deflate[a]=b,this._deflate.write(g),this._deflate.flush(f.Z_SYNC_FLUSH,()=>{if(!this._deflate)return;let k=e.concat(this._deflate[o],this._deflate[r]);y&&(k=k.slice(0,k.length-4)),this._deflate[a]=null,this._deflate[r]=0,this._deflate[o]=[],y&&this.params[`${w}_no_context_takeover`]&&this._deflate.reset(),b(null,k)})}}nm=u;function h(m){this[o].push(m),this[r]+=m.length}function l(m){if(this[r]+=m.length,this[n]._maxPayload<1||this[r]<=this[n]._maxPayload){this[o].push(m);return}this[d]=new RangeError("Max payload size exceeded"),this[d].code="WS_ERR_UNSUPPORTED_MESSAGE_LENGTH",this[d][s]=1009,this.removeListener("data",l),this.reset()}function p(m){this[n]._inflate=null,m[s]=1007,this[a](m)}return nm}var cf={exports:{}};const zV={},KV=Object.freeze(Object.defineProperty({__proto__:null,default:zV},Symbol.toStringTag,{value:"Module"})),XV=Ly(KV);var U1;function Gl(){if(U1)return cf.exports;U1=1;const f=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0];function e(s){return s>=1e3&&s<=1014&&s!==1004&&s!==1005&&s!==1006||s>=3e3&&s<=4999}function t(s){const i=s.length;let n=0;for(;n<i;)if((s[n]&128)===0)n++;else if((s[n]&224)===192){if(n+1===i||(s[n+1]&192)!==128||(s[n]&254)===192)return!1;n+=2}else if((s[n]&240)===224){if(n+2>=i||(s[n+1]&192)!==128||(s[n+2]&192)!==128||s[n]===224&&(s[n+1]&224)===128||s[n]===237&&(s[n+1]&224)===160)return!1;n+=3}else if((s[n]&248)===240){if(n+3>=i||(s[n+1]&192)!==128||(s[n+2]&192)!==128||(s[n+3]&192)!==128||s[n]===240&&(s[n+1]&240)===128||s[n]===244&&s[n+1]>143||s[n]>244)return!1;n+=4}else return!1;return!0}if(cf.exports={isValidStatusCode:e,isValidUTF8:t,tokenChars:f},!{}.WS_NO_UTF_8_VALIDATE)try{const s=XV;cf.exports.isValidUTF8=function(i){return i.length<150?t(i):s(i)}}catch{}return cf.exports}var rm,$1;function I_(){if($1)return rm;$1=1;const{Writable:f}=Et,e=Hl(),{BINARY_TYPES:t,EMPTY_BUFFER:s,kStatusCode:i,kWebSocket:n}=wo(),{concat:r,toArrayBuffer:a,unmask:o}=Dl(),{isValidStatusCode:d,isValidUTF8:c}=Gl(),u=0,h=1,l=2,p=3,m=4,g=5;class y extends f{constructor(k={}){super(),this._binaryType=k.binaryType||t[0],this._extensions=k.extensions||{},this._isServer=!!k.isServer,this._maxPayload=k.maxPayload|0,this._skipUTF8Validation=!!k.skipUTF8Validation,this[n]=void 0,this._bufferedBytes=0,this._buffers=[],this._compressed=!1,this._payloadLength=0,this._mask=void 0,this._fragmented=0,this._masked=!1,this._fin=!1,this._opcode=0,this._totalPayloadLength=0,this._messageLength=0,this._fragments=[],this._state=u,this._loop=!1}_write(k,T,O){if(this._opcode===8&&this._state==u)return O();this._bufferedBytes+=k.length,this._buffers.push(k),this.startLoop(O)}consume(k){if(this._bufferedBytes-=k,k===this._buffers[0].length)return this._buffers.shift();if(k<this._buffers[0].length){const O=this._buffers[0];return this._buffers[0]=O.slice(k),O.slice(0,k)}const T=Buffer.allocUnsafe(k);do{const O=this._buffers[0],x=T.length-k;k>=O.length?T.set(this._buffers.shift(),x):(T.set(new Uint8Array(O.buffer,O.byteOffset,k),x),this._buffers[0]=O.slice(k)),k-=O.length}while(k>0);return T}startLoop(k){let T;this._loop=!0;do switch(this._state){case u:T=this.getInfo();break;case h:T=this.getPayloadLength16();break;case l:T=this.getPayloadLength64();break;case p:this.getMask();break;case m:T=this.getData(k);break;default:this._loop=!1;return}while(this._loop);k(T)}getInfo(){if(this._bufferedBytes<2){this._loop=!1;return}const k=this.consume(2);if((k[0]&48)!==0)return this._loop=!1,b(RangeError,"RSV2 and RSV3 must be clear",!0,1002,"WS_ERR_UNEXPECTED_RSV_2_3");const T=(k[0]&64)===64;if(T&&!this._extensions[e.extensionName])return this._loop=!1,b(RangeError,"RSV1 must be clear",!0,1002,"WS_ERR_UNEXPECTED_RSV_1");if(this._fin=(k[0]&128)===128,this._opcode=k[0]&15,this._payloadLength=k[1]&127,this._opcode===0){if(T)return this._loop=!1,b(RangeError,"RSV1 must be clear",!0,1002,"WS_ERR_UNEXPECTED_RSV_1");if(!this._fragmented)return this._loop=!1,b(RangeError,"invalid opcode 0",!0,1002,"WS_ERR_INVALID_OPCODE");this._opcode=this._fragmented}else if(this._opcode===1||this._opcode===2){if(this._fragmented)return this._loop=!1,b(RangeError,`invalid opcode ${this._opcode}`,!0,1002,"WS_ERR_INVALID_OPCODE");this._compressed=T}else if(this._opcode>7&&this._opcode<11){if(!this._fin)return this._loop=!1,b(RangeError,"FIN must be set",!0,1002,"WS_ERR_EXPECTED_FIN");if(T)return this._loop=!1,b(RangeError,"RSV1 must be clear",!0,1002,"WS_ERR_UNEXPECTED_RSV_1");if(this._payloadLength>125)return this._loop=!1,b(RangeError,`invalid payload length ${this._payloadLength}`,!0,1002,"WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH")}else return this._loop=!1,b(RangeError,`invalid opcode ${this._opcode}`,!0,1002,"WS_ERR_INVALID_OPCODE");if(!this._fin&&!this._fragmented&&(this._fragmented=this._opcode),this._masked=(k[1]&128)===128,this._isServer){if(!this._masked)return this._loop=!1,b(RangeError,"MASK must be set",!0,1002,"WS_ERR_EXPECTED_MASK")}else if(this._masked)return this._loop=!1,b(RangeError,"MASK must be clear",!0,1002,"WS_ERR_UNEXPECTED_MASK");if(this._payloadLength===126)this._state=h;else if(this._payloadLength===127)this._state=l;else return this.haveLength()}getPayloadLength16(){if(this._bufferedBytes<2){this._loop=!1;return}return this._payloadLength=this.consume(2).readUInt16BE(0),this.haveLength()}getPayloadLength64(){if(this._bufferedBytes<8){this._loop=!1;return}const k=this.consume(8),T=k.readUInt32BE(0);return T>Math.pow(2,53-32)-1?(this._loop=!1,b(RangeError,"Unsupported WebSocket frame: payload length > 2^53 - 1",!1,1009,"WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH")):(this._payloadLength=T*Math.pow(2,32)+k.readUInt32BE(4),this.haveLength())}haveLength(){if(this._payloadLength&&this._opcode<8&&(this._totalPayloadLength+=this._payloadLength,this._totalPayloadLength>this._maxPayload&&this._maxPayload>0))return this._loop=!1,b(RangeError,"Max payload size exceeded",!1,1009,"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");this._masked?this._state=p:this._state=m}getMask(){if(this._bufferedBytes<4){this._loop=!1;return}this._mask=this.consume(4),this._state=m}getData(k){let T=s;if(this._payloadLength){if(this._bufferedBytes<this._payloadLength){this._loop=!1;return}T=this.consume(this._payloadLength),this._masked&&(this._mask[0]|this._mask[1]|this._mask[2]|this._mask[3])!==0&&o(T,this._mask)}if(this._opcode>7)return this.controlMessage(T);if(this._compressed){this._state=g,this.decompress(T,k);return}return T.length&&(this._messageLength=this._totalPayloadLength,this._fragments.push(T)),this.dataMessage()}decompress(k,T){this._extensions[e.extensionName].decompress(k,this._fin,(x,C)=>{if(x)return T(x);if(C.length){if(this._messageLength+=C.length,this._messageLength>this._maxPayload&&this._maxPayload>0)return T(b(RangeError,"Max payload size exceeded",!1,1009,"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));this._fragments.push(C)}const E=this.dataMessage();if(E)return T(E);this.startLoop(T)})}dataMessage(){if(this._fin){const k=this._messageLength,T=this._fragments;if(this._totalPayloadLength=0,this._messageLength=0,this._fragmented=0,this._fragments=[],this._opcode===2){let O;this._binaryType==="nodebuffer"?O=r(T,k):this._binaryType==="arraybuffer"?O=a(r(T,k)):O=T,this.emit("message",O,!0)}else{const O=r(T,k);if(!this._skipUTF8Validation&&!c(O))return this._loop=!1,b(Error,"invalid UTF-8 sequence",!0,1007,"WS_ERR_INVALID_UTF8");this.emit("message",O,!1)}}this._state=u}controlMessage(k){if(this._opcode===8)if(this._loop=!1,k.length===0)this.emit("conclude",1005,s),this.end();else{if(k.length===1)return b(RangeError,"invalid payload length 1",!0,1002,"WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");{const T=k.readUInt16BE(0);if(!d(T))return b(RangeError,`invalid status code ${T}`,!0,1002,"WS_ERR_INVALID_CLOSE_CODE");const O=k.slice(2);if(!this._skipUTF8Validation&&!c(O))return b(Error,"invalid UTF-8 sequence",!0,1007,"WS_ERR_INVALID_UTF8");this.emit("conclude",T,O),this.end()}}else this._opcode===9?this.emit("ping",k):this.emit("pong",k);this._state=u}}rm=y;function b(w,k,T,O,x){const C=new w(T?`Invalid WebSocket frame: ${k}`:k);return Error.captureStackTrace(C,b),C.code=x,C[i]=O,C}return rm}var am,j1;function x_(){if(j1)return am;j1=1;const{randomFillSync:f}=Et,e=Hl(),{EMPTY_BUFFER:t}=wo(),{isValidStatusCode:s}=Gl(),{mask:i,toBuffer:n}=Dl(),r=Symbol("kByteLength"),a=Buffer.alloc(4);class o{constructor(c,u,h){this._extensions=u||{},h&&(this._generateMask=h,this._maskBuffer=Buffer.alloc(4)),this._socket=c,this._firstFragment=!0,this._compress=!1,this._bufferedBytes=0,this._deflating=!1,this._queue=[]}static frame(c,u){let h,l=!1,p=2,m=!1;u.mask&&(h=u.maskBuffer||a,u.generateMask?u.generateMask(h):f(h,0,4),m=(h[0]|h[1]|h[2]|h[3])===0,p=6);let g;typeof c=="string"?(!u.mask||m)&&u[r]!==void 0?g=u[r]:(c=Buffer.from(c),g=c.length):(g=c.length,l=u.mask&&u.readOnly&&!m);let y=g;g>=65536?(p+=8,y=127):g>125&&(p+=2,y=126);const b=Buffer.allocUnsafe(l?g+p:p);return b[0]=u.fin?u.opcode|128:u.opcode,u.rsv1&&(b[0]|=64),b[1]=y,y===126?b.writeUInt16BE(g,2):y===127&&(b[2]=b[3]=0,b.writeUIntBE(g,4,6)),u.mask?(b[1]|=128,b[p-4]=h[0],b[p-3]=h[1],b[p-2]=h[2],b[p-1]=h[3],m?[b,c]:l?(i(c,h,b,p,g),[b]):(i(c,h,c,0,g),[b,c])):[b,c]}close(c,u,h,l){let p;if(c===void 0)p=t;else{if(typeof c!="number"||!s(c))throw new TypeError("First argument must be a valid error code number");if(u===void 0||!u.length)p=Buffer.allocUnsafe(2),p.writeUInt16BE(c,0);else{const g=Buffer.byteLength(u);if(g>123)throw new RangeError("The message must not be greater than 123 bytes");p=Buffer.allocUnsafe(2+g),p.writeUInt16BE(c,0),typeof u=="string"?p.write(u,2):p.set(u,2)}}const m={[r]:p.length,fin:!0,generateMask:this._generateMask,mask:h,maskBuffer:this._maskBuffer,opcode:8,readOnly:!1,rsv1:!1};this._deflating?this.enqueue([this.dispatch,p,!1,m,l]):this.sendFrame(o.frame(p,m),l)}ping(c,u,h){let l,p;if(typeof c=="string"?(l=Buffer.byteLength(c),p=!1):(c=n(c),l=c.length,p=n.readOnly),l>125)throw new RangeError("The data size must not be greater than 125 bytes");const m={[r]:l,fin:!0,generateMask:this._generateMask,mask:u,maskBuffer:this._maskBuffer,opcode:9,readOnly:p,rsv1:!1};this._deflating?this.enqueue([this.dispatch,c,!1,m,h]):this.sendFrame(o.frame(c,m),h)}pong(c,u,h){let l,p;if(typeof c=="string"?(l=Buffer.byteLength(c),p=!1):(c=n(c),l=c.length,p=n.readOnly),l>125)throw new RangeError("The data size must not be greater than 125 bytes");const m={[r]:l,fin:!0,generateMask:this._generateMask,mask:u,maskBuffer:this._maskBuffer,opcode:10,readOnly:p,rsv1:!1};this._deflating?this.enqueue([this.dispatch,c,!1,m,h]):this.sendFrame(o.frame(c,m),h)}send(c,u,h){const l=this._extensions[e.extensionName];let p=u.binary?2:1,m=u.compress,g,y;if(typeof c=="string"?(g=Buffer.byteLength(c),y=!1):(c=n(c),g=c.length,y=n.readOnly),this._firstFragment?(this._firstFragment=!1,m&&l&&l.params[l._isServer?"server_no_context_takeover":"client_no_context_takeover"]&&(m=g>=l._threshold),this._compress=m):(m=!1,p=0),u.fin&&(this._firstFragment=!0),l){const b={[r]:g,fin:u.fin,generateMask:this._generateMask,mask:u.mask,maskBuffer:this._maskBuffer,opcode:p,readOnly:y,rsv1:m};this._deflating?this.enqueue([this.dispatch,c,this._compress,b,h]):this.dispatch(c,this._compress,b,h)}else this.sendFrame(o.frame(c,{[r]:g,fin:u.fin,generateMask:this._generateMask,mask:u.mask,maskBuffer:this._maskBuffer,opcode:p,readOnly:y,rsv1:!1}),h)}dispatch(c,u,h,l){if(!u){this.sendFrame(o.frame(c,h),l);return}const p=this._extensions[e.extensionName];this._bufferedBytes+=h[r],this._deflating=!0,p.compress(c,h.fin,(m,g)=>{if(this._socket.destroyed){const y=new Error("The socket was closed while data was being compressed");typeof l=="function"&&l(y);for(let b=0;b<this._queue.length;b++){const w=this._queue[b],k=w[w.length-1];typeof k=="function"&&k(y)}return}this._bufferedBytes-=h[r],this._deflating=!1,h.readOnly=!1,this.sendFrame(o.frame(g,h),l),this.dequeue()})}dequeue(){for(;!this._deflating&&this._queue.length;){const c=this._queue.shift();this._bufferedBytes-=c[3][r],Reflect.apply(c[0],this,c.slice(1))}}enqueue(c){this._bufferedBytes+=c[3][r],this._queue.push(c)}sendFrame(c,u){c.length===2?(this._socket.cork(),this._socket.write(c[0]),this._socket.write(c[1],u),this._socket.uncork()):this._socket.write(c[0],u)}}return am=o,am}var om,W1;function YV(){if(W1)return om;W1=1;const{kForOnEventAttribute:f,kListener:e}=wo(),t=Symbol("kCode"),s=Symbol("kData"),i=Symbol("kError"),n=Symbol("kMessage"),r=Symbol("kReason"),a=Symbol("kTarget"),o=Symbol("kType"),d=Symbol("kWasClean");class c{constructor(y){this[a]=null,this[o]=y}get target(){return this[a]}get type(){return this[o]}}Object.defineProperty(c.prototype,"target",{enumerable:!0}),Object.defineProperty(c.prototype,"type",{enumerable:!0});class u extends c{constructor(y,b={}){super(y),this[t]=b.code===void 0?0:b.code,this[r]=b.reason===void 0?"":b.reason,this[d]=b.wasClean===void 0?!1:b.wasClean}get code(){return this[t]}get reason(){return this[r]}get wasClean(){return this[d]}}Object.defineProperty(u.prototype,"code",{enumerable:!0}),Object.defineProperty(u.prototype,"reason",{enumerable:!0}),Object.defineProperty(u.prototype,"wasClean",{enumerable:!0});class h extends c{constructor(y,b={}){super(y),this[i]=b.error===void 0?null:b.error,this[n]=b.message===void 0?"":b.message}get error(){return this[i]}get message(){return this[n]}}Object.defineProperty(h.prototype,"error",{enumerable:!0}),Object.defineProperty(h.prototype,"message",{enumerable:!0});class l extends c{constructor(y,b={}){super(y),this[s]=b.data===void 0?null:b.data}get data(){return this[s]}}Object.defineProperty(l.prototype,"data",{enumerable:!0}),om={CloseEvent:u,ErrorEvent:h,Event:c,EventTarget:{addEventListener(g,y,b={}){for(const k of this.listeners(g))if(!b[f]&&k[e]===y&&!k[f])return;let w;if(g==="message")w=function(T,O){const x=new l("message",{data:O?T:T.toString()});x[a]=this,m(y,this,x)};else if(g==="close")w=function(T,O){const x=new u("close",{code:T,reason:O.toString(),wasClean:this._closeFrameReceived&&this._closeFrameSent});x[a]=this,m(y,this,x)};else if(g==="error")w=function(T){const O=new h("error",{error:T,message:T.message});O[a]=this,m(y,this,O)};else if(g==="open")w=function(){const T=new c("open");T[a]=this,m(y,this,T)};else return;w[f]=!!b[f],w[e]=y,b.once?this.once(g,w):this.on(g,w)},removeEventListener(g,y){for(const b of this.listeners(g))if(b[e]===y&&!b[f]){this.removeListener(g,b);break}}},MessageEvent:l};function m(g,y,b){typeof g=="object"&&g.handleEvent?g.handleEvent.call(g,b):g.call(y,b)}return om}var dm,z1;function __(){if(z1)return dm;z1=1;const{tokenChars:f}=Gl();function e(i,n,r){i[n]===void 0?i[n]=[r]:i[n].push(r)}function t(i){const n=Object.create(null);let r=Object.create(null),a=!1,o=!1,d=!1,c,u,h=-1,l=-1,p=-1,m=0;for(;m<i.length;m++)if(l=i.charCodeAt(m),c===void 0)if(p===-1&&f[l]===1)h===-1&&(h=m);else if(m!==0&&(l===32||l===9))p===-1&&h!==-1&&(p=m);else if(l===59||l===44){if(h===-1)throw new SyntaxError(`Unexpected character at index ${m}`);p===-1&&(p=m);const y=i.slice(h,p);l===44?(e(n,y,r),r=Object.create(null)):c=y,h=p=-1}else throw new SyntaxError(`Unexpected character at index ${m}`);else if(u===void 0)if(p===-1&&f[l]===1)h===-1&&(h=m);else if(l===32||l===9)p===-1&&h!==-1&&(p=m);else if(l===59||l===44){if(h===-1)throw new SyntaxError(`Unexpected character at index ${m}`);p===-1&&(p=m),e(r,i.slice(h,p),!0),l===44&&(e(n,c,r),r=Object.create(null),c=void 0),h=p=-1}else if(l===61&&h!==-1&&p===-1)u=i.slice(h,m),h=p=-1;else throw new SyntaxError(`Unexpected character at index ${m}`);else if(o){if(f[l]!==1)throw new SyntaxError(`Unexpected character at index ${m}`);h===-1?h=m:a||(a=!0),o=!1}else if(d)if(f[l]===1)h===-1&&(h=m);else if(l===34&&h!==-1)d=!1,p=m;else if(l===92)o=!0;else throw new SyntaxError(`Unexpected character at index ${m}`);else if(l===34&&i.charCodeAt(m-1)===61)d=!0;else if(p===-1&&f[l]===1)h===-1&&(h=m);else if(h!==-1&&(l===32||l===9))p===-1&&(p=m);else if(l===59||l===44){if(h===-1)throw new SyntaxError(`Unexpected character at index ${m}`);p===-1&&(p=m);let y=i.slice(h,p);a&&(y=y.replace(/\\/g,""),a=!1),e(r,u,y),l===44&&(e(n,c,r),r=Object.create(null),c=void 0),u=void 0,h=p=-1}else throw new SyntaxError(`Unexpected character at index ${m}`);if(h===-1||d||l===32||l===9)throw new SyntaxError("Unexpected end of input");p===-1&&(p=m);const g=i.slice(h,p);return c===void 0?e(n,g,r):(u===void 0?e(r,g,!0):a?e(r,u,g.replace(/\\/g,"")):e(r,u,g),e(n,c,r)),n}function s(i){return Object.keys(i).map(n=>{let r=i[n];return Array.isArray(r)||(r=[r]),r.map(a=>[n].concat(Object.keys(a).map(o=>{let d=a[o];return Array.isArray(d)||(d=[d]),d.map(c=>c===!0?o:`${o}=${c}`).join("; ")})).join("; ")).join(", ")}).join(", ")}return dm={format:s,parse:t},dm}var cm,K1;function C_(){if(K1)return cm;K1=1;const f=Et,e=Et,t=Et,s=Et,i=Et,{randomBytes:n,createHash:r}=Et,{URL:a}=Et,o=Hl(),d=I_(),c=x_(),{BINARY_TYPES:u,EMPTY_BUFFER:h,GUID:l,kForOnEventAttribute:p,kListener:m,kStatusCode:g,kWebSocket:y,NOOP:b}=wo(),{EventTarget:{addEventListener:w,removeEventListener:k}}=YV(),{format:T,parse:O}=__(),{toBuffer:x}=Dl(),C=30*1e3,E=Symbol("kAborted"),P=[8,13],_=["CONNECTING","OPEN","CLOSING","CLOSED"],S=/^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;class I extends f{constructor(j,U,H){super(),this._binaryType=u[0],this._closeCode=1006,this._closeFrameReceived=!1,this._closeFrameSent=!1,this._closeMessage=h,this._closeTimer=null,this._extensions={},this._paused=!1,this._protocol="",this._readyState=I.CONNECTING,this._receiver=null,this._sender=null,this._socket=null,j!==null?(this._bufferedAmount=0,this._isServer=!1,this._redirects=0,U===void 0?U=[]:Array.isArray(U)||(typeof U=="object"&&U!==null?(H=U,U=[]):U=[U]),v(this,j,U,H)):this._isServer=!0}get binaryType(){return this._binaryType}set binaryType(j){!u.includes(j)||(this._binaryType=j,this._receiver&&(this._receiver._binaryType=j))}get bufferedAmount(){return this._socket?this._socket._writableState.length+this._sender._bufferedBytes:this._bufferedAmount}get extensions(){return Object.keys(this._extensions).join()}get isPaused(){return this._paused}get onclose(){return null}get onerror(){return null}get onopen(){return null}get onmessage(){return null}get protocol(){return this._protocol}get readyState(){return this._readyState}get url(){return this._url}setSocket(j,U,H){const W=new d({binaryType:this.binaryType,extensions:this._extensions,isServer:this._isServer,maxPayload:H.maxPayload,skipUTF8Validation:H.skipUTF8Validation});this._sender=new c(j,this._extensions,H.generateMask),this._receiver=W,this._socket=j,W[y]=this,j[y]=this,W.on("conclude",A),W.on("drain",V),W.on("error",Q),W.on("message",se),W.on("ping",we),W.on("pong",le),j.setTimeout(0),j.setNoDelay(),U.length>0&&j.unshift(U),j.on("close",Ce),j.on("data",Le),j.on("end",Fe),j.on("error",At),this._readyState=I.OPEN,this.emit("open")}emitClose(){if(!this._socket){this._readyState=I.CLOSED,this.emit("close",this._closeCode,this._closeMessage);return}this._extensions[o.extensionName]&&this._extensions[o.extensionName].cleanup(),this._receiver.removeAllListeners(),this._readyState=I.CLOSED,this.emit("close",this._closeCode,this._closeMessage)}close(j,U){if(this.readyState!==I.CLOSED){if(this.readyState===I.CONNECTING){const H="WebSocket was closed before the connection was established";return G(this,this._req,H)}if(this.readyState===I.CLOSING){this._closeFrameSent&&(this._closeFrameReceived||this._receiver._writableState.errorEmitted)&&this._socket.end();return}this._readyState=I.CLOSING,this._sender.close(j,U,!this._isServer,H=>{H||(this._closeFrameSent=!0,(this._closeFrameReceived||this._receiver._writableState.errorEmitted)&&this._socket.end())}),this._closeTimer=setTimeout(this._socket.destroy.bind(this._socket),C)}}pause(){this.readyState===I.CONNECTING||this.readyState===I.CLOSED||(this._paused=!0,this._socket.pause())}ping(j,U,H){if(this.readyState===I.CONNECTING)throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");if(typeof j=="function"?(H=j,j=U=void 0):typeof U=="function"&&(H=U,U=void 0),typeof j=="number"&&(j=j.toString()),this.readyState!==I.OPEN){F(this,j,H);return}U===void 0&&(U=!this._isServer),this._sender.ping(j||h,U,H)}pong(j,U,H){if(this.readyState===I.CONNECTING)throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");if(typeof j=="function"?(H=j,j=U=void 0):typeof U=="function"&&(H=U,U=void 0),typeof j=="number"&&(j=j.toString()),this.readyState!==I.OPEN){F(this,j,H);return}U===void 0&&(U=!this._isServer),this._sender.pong(j||h,U,H)}resume(){this.readyState===I.CONNECTING||this.readyState===I.CLOSED||(this._paused=!1,this._receiver._writableState.needDrain||this._socket.resume())}send(j,U,H){if(this.readyState===I.CONNECTING)throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");if(typeof U=="function"&&(H=U,U={}),typeof j=="number"&&(j=j.toString()),this.readyState!==I.OPEN){F(this,j,H);return}const W={binary:typeof j!="string",mask:!this._isServer,compress:!0,fin:!0,...U};this._extensions[o.extensionName]||(W.compress=!1),this._sender.send(j||h,W,H)}terminate(){if(this.readyState!==I.CLOSED){if(this.readyState===I.CONNECTING){const j="WebSocket was closed before the connection was established";return G(this,this._req,j)}this._socket&&(this._readyState=I.CLOSING,this._socket.destroy())}}}Object.defineProperty(I,"CONNECTING",{enumerable:!0,value:_.indexOf("CONNECTING")}),Object.defineProperty(I.prototype,"CONNECTING",{enumerable:!0,value:_.indexOf("CONNECTING")}),Object.defineProperty(I,"OPEN",{enumerable:!0,value:_.indexOf("OPEN")}),Object.defineProperty(I.prototype,"OPEN",{enumerable:!0,value:_.indexOf("OPEN")}),Object.defineProperty(I,"CLOSING",{enumerable:!0,value:_.indexOf("CLOSING")}),Object.defineProperty(I.prototype,"CLOSING",{enumerable:!0,value:_.indexOf("CLOSING")}),Object.defineProperty(I,"CLOSED",{enumerable:!0,value:_.indexOf("CLOSED")}),Object.defineProperty(I.prototype,"CLOSED",{enumerable:!0,value:_.indexOf("CLOSED")}),["binaryType","bufferedAmount","extensions","isPaused","protocol","readyState","url"].forEach(D=>{Object.defineProperty(I.prototype,D,{enumerable:!0})}),["open","error","close","message"].forEach(D=>{Object.defineProperty(I.prototype,`on${D}`,{enumerable:!0,get(){for(const j of this.listeners(D))if(j[p])return j[m];return null},set(j){for(const U of this.listeners(D))if(U[p]){this.removeListener(D,U);break}typeof j=="function"&&this.addEventListener(D,j,{[p]:!0})}})}),I.prototype.addEventListener=w,I.prototype.removeEventListener=k,cm=I;function v(D,j,U,H){const W={protocolVersion:P[1],maxPayload:104857600,skipUTF8Validation:!1,perMessageDeflate:!0,followRedirects:!1,maxRedirects:10,...H,createConnection:void 0,socketPath:void 0,hostname:void 0,protocol:void 0,timeout:void 0,method:"GET",host:void 0,path:void 0,port:void 0};if(!P.includes(W.protocolVersion))throw new RangeError(`Unsupported protocol version: ${W.protocolVersion} (supported versions: ${P.join(", ")})`);let Y;if(j instanceof a)Y=j,D._url=j.href;else{try{Y=new a(j)}catch{throw new SyntaxError(`Invalid URL: ${j}`)}D._url=j}const z=Y.protocol==="wss:",X=Y.protocol==="ws+unix:";let ne;if(Y.protocol!=="ws:"&&!z&&!X?ne=`The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`:X&&!Y.pathname?ne="The URL's pathname is empty":Y.hash&&(ne="The URL contains a fragment identifier"),ne){const L=new SyntaxError(ne);if(D._redirects===0)throw L;N(D,L);return}const te=z?443:80,ce=n(16).toString("base64"),ke=z?e.request:t.request,ue=new Set;let Ie;if(W.createConnection=z?R:q,W.defaultPort=W.defaultPort||te,W.port=Y.port||te,W.host=Y.hostname.startsWith("[")?Y.hostname.slice(1,-1):Y.hostname,W.headers={...W.headers,"Sec-WebSocket-Version":W.protocolVersion,"Sec-WebSocket-Key":ce,Connection:"Upgrade",Upgrade:"websocket"},W.path=Y.pathname+Y.search,W.timeout=W.handshakeTimeout,W.perMessageDeflate&&(Ie=new o(W.perMessageDeflate!==!0?W.perMessageDeflate:{},!1,W.maxPayload),W.headers["Sec-WebSocket-Extensions"]=T({[o.extensionName]:Ie.offer()})),U.length){for(const L of U){if(typeof L!="string"||!S.test(L)||ue.has(L))throw new SyntaxError("An invalid or duplicated subprotocol was specified");ue.add(L)}W.headers["Sec-WebSocket-Protocol"]=U.join(",")}if(W.origin&&(W.protocolVersion<13?W.headers["Sec-WebSocket-Origin"]=W.origin:W.headers.Origin=W.origin),(Y.username||Y.password)&&(W.auth=`${Y.username}:${Y.password}`),X){const L=W.path.split(":");W.socketPath=L[0],W.path=L[1]}let Pe;if(W.followRedirects){if(D._redirects===0){D._originalIpc=X,D._originalSecure=z,D._originalHostOrSocketPath=X?W.socketPath:Y.host;const L=H&&H.headers;if(H={...H,headers:{}},L)for(const[M,B]of Object.entries(L))H.headers[M.toLowerCase()]=B}else if(D.listenerCount("redirect")===0){const L=X?D._originalIpc?W.socketPath===D._originalHostOrSocketPath:!1:D._originalIpc?!1:Y.host===D._originalHostOrSocketPath;(!L||D._originalSecure&&!z)&&(delete W.headers.authorization,delete W.headers.cookie,L||delete W.headers.host,W.auth=void 0)}W.auth&&!H.headers.authorization&&(H.headers.authorization="Basic "+Buffer.from(W.auth).toString("base64")),Pe=D._req=ke(W),D._redirects&&D.emit("redirect",D.url,Pe)}else Pe=D._req=ke(W);W.timeout&&Pe.on("timeout",()=>{G(D,Pe,"Opening handshake has timed out")}),Pe.on("error",L=>{Pe===null||Pe[E]||(Pe=D._req=null,N(D,L))}),Pe.on("response",L=>{const M=L.headers.location,B=L.statusCode;if(M&&W.followRedirects&&B>=300&&B<400){if(++D._redirects>W.maxRedirects){G(D,Pe,"Maximum redirects exceeded");return}Pe.abort();let K;try{K=new a(M,j)}catch{const re=new SyntaxError(`Invalid URL: ${M}`);N(D,re);return}v(D,K,U,H)}else D.emit("unexpected-response",Pe,L)||G(D,Pe,`Unexpected server response: ${L.statusCode}`)}),Pe.on("upgrade",(L,M,B)=>{if(D.emit("upgrade",L),D.readyState!==I.CONNECTING)return;if(Pe=D._req=null,L.headers.upgrade.toLowerCase()!=="websocket"){G(D,M,"Invalid Upgrade header");return}const K=r("sha1").update(ce+l).digest("base64");if(L.headers["sec-websocket-accept"]!==K){G(D,M,"Invalid Sec-WebSocket-Accept header");return}const Z=L.headers["sec-websocket-protocol"];let re;if(Z!==void 0?ue.size?ue.has(Z)||(re="Server sent an invalid subprotocol"):re="Server sent a subprotocol but none was requested":ue.size&&(re="Server sent no subprotocol"),re){G(D,M,re);return}Z&&(D._protocol=Z);const ae=L.headers["sec-websocket-extensions"];if(ae!==void 0){if(!Ie){G(D,M,"Server sent a Sec-WebSocket-Extensions header but no extension was requested");return}let Ee;try{Ee=O(ae)}catch{G(D,M,"Invalid Sec-WebSocket-Extensions header");return}const We=Object.keys(Ee);if(We.length!==1||We[0]!==o.extensionName){G(D,M,"Server indicated an extension that was not requested");return}try{Ie.accept(Ee[o.extensionName])}catch{G(D,M,"Invalid Sec-WebSocket-Extensions header");return}D._extensions[o.extensionName]=Ie}D.setSocket(M,B,{generateMask:W.generateMask,maxPayload:W.maxPayload,skipUTF8Validation:W.skipUTF8Validation})}),Pe.end()}function N(D,j){D._readyState=I.CLOSING,D.emit("error",j),D.emitClose()}function q(D){return D.path=D.socketPath,s.connect(D)}function R(D){return D.path=void 0,!D.servername&&D.servername!==""&&(D.servername=s.isIP(D.host)?"":D.host),i.connect(D)}function G(D,j,U){D._readyState=I.CLOSING;const H=new Error(U);Error.captureStackTrace(H,G),j.setHeader?(j[E]=!0,j.abort(),j.socket&&!j.socket.destroyed&&j.socket.destroy(),process.nextTick(N,D,H)):(j.destroy(H),j.once("error",D.emit.bind(D,"error")),j.once("close",D.emitClose.bind(D)))}function F(D,j,U){if(j){const H=x(j).length;D._socket?D._sender._bufferedBytes+=H:D._bufferedAmount+=H}if(U){const H=new Error(`WebSocket is not open: readyState ${D.readyState} (${_[D.readyState]})`);U(H)}}function A(D,j){const U=this[y];U._closeFrameReceived=!0,U._closeMessage=j,U._closeCode=D,U._socket[y]!==void 0&&(U._socket.removeListener("data",Le),process.nextTick(Oe,U._socket),D===1005?U.close():U.close(D,j))}function V(){const D=this[y];D.isPaused||D._socket.resume()}function Q(D){const j=this[y];j._socket[y]!==void 0&&(j._socket.removeListener("data",Le),process.nextTick(Oe,j._socket),j.close(D[g])),j.emit("error",D)}function J(){this[y].emitClose()}function se(D,j){this[y].emit("message",D,j)}function we(D){const j=this[y];j.pong(D,!j._isServer,b),j.emit("ping",D)}function le(D){this[y].emit("pong",D)}function Oe(D){D.resume()}function Ce(){const D=this[y];this.removeListener("close",Ce),this.removeListener("data",Le),this.removeListener("end",Fe),D._readyState=I.CLOSING;let j;!this._readableState.endEmitted&&!D._closeFrameReceived&&!D._receiver._writableState.errorEmitted&&(j=D._socket.read())!==null&&D._receiver.write(j),D._receiver.end(),this[y]=void 0,clearTimeout(D._closeTimer),D._receiver._writableState.finished||D._receiver._writableState.errorEmitted?D.emitClose():(D._receiver.on("error",J),D._receiver.on("finish",J))}function Le(D){this[y]._receiver.write(D)||this.pause()}function Fe(){const D=this[y];D._readyState=I.CLOSING,D._receiver.end(),this.end()}function At(){const D=this[y];this.removeListener("error",At),this.on("error",b),D&&(D._readyState=I.CLOSING,this.destroy())}return cm}var um,X1;function QV(){if(X1)return um;X1=1;const{Duplex:f}=Et;function e(n){n.emit("close")}function t(){!this.destroyed&&this._writableState.finished&&this.destroy()}function s(n){this.removeListener("error",s),this.destroy(),this.listenerCount("error")===0&&this.emit("error",n)}function i(n,r){let a=!0;const o=new f({...r,autoDestroy:!1,emitClose:!1,objectMode:!1,writableObjectMode:!1});return n.on("message",function(c,u){const h=!u&&o._readableState.objectMode?c.toString():c;o.push(h)||n.pause()}),n.once("error",function(c){o.destroyed||(a=!1,o.destroy(c))}),n.once("close",function(){o.destroyed||o.push(null)}),o._destroy=function(d,c){if(n.readyState===n.CLOSED){c(d),process.nextTick(e,o);return}let u=!1;n.once("error",function(l){u=!0,c(l)}),n.once("close",function(){u||c(d),process.nextTick(e,o)}),a&&n.terminate()},o._final=function(d){if(n.readyState===n.CONNECTING){n.once("open",function(){o._final(d)});return}n._socket!==null&&(n._socket._writableState.finished?(d(),o._readableState.endEmitted&&o.destroy()):(n._socket.once("finish",function(){d()}),n.close()))},o._read=function(){n.isPaused&&n.resume()},o._write=function(d,c,u){if(n.readyState===n.CONNECTING){n.once("open",function(){o._write(d,c,u)});return}n.send(d,u)},o.on("end",t),o.on("error",s),o}return um=i,um}var fm,Y1;function ZV(){if(Y1)return fm;Y1=1;const{tokenChars:f}=Gl();function e(t){const s=new Set;let i=-1,n=-1,r=0;for(r;r<t.length;r++){const o=t.charCodeAt(r);if(n===-1&&f[o]===1)i===-1&&(i=r);else if(r!==0&&(o===32||o===9))n===-1&&i!==-1&&(n=r);else if(o===44){if(i===-1)throw new SyntaxError(`Unexpected character at index ${r}`);n===-1&&(n=r);const d=t.slice(i,n);if(s.has(d))throw new SyntaxError(`The "${d}" subprotocol is duplicated`);s.add(d),i=n=-1}else throw new SyntaxError(`Unexpected character at index ${r}`)}if(i===-1||n!==-1)throw new SyntaxError("Unexpected end of input");const a=t.slice(i,r);if(s.has(a))throw new SyntaxError(`The "${a}" subprotocol is duplicated`);return s.add(a),s}return fm={parse:e},fm}var hm,Q1;function JV(){if(Q1)return hm;Q1=1;const f=Et,e=Et,{createHash:t}=Et,s=__(),i=Hl(),n=ZV(),r=C_(),{GUID:a,kWebSocket:o}=wo(),d=/^[+/0-9A-Za-z]{22}==$/,c=0,u=1,h=2;class l extends f{constructor(k,T){if(super(),k={maxPayload:100*1024*1024,skipUTF8Validation:!1,perMessageDeflate:!1,handleProtocols:null,clientTracking:!0,verifyClient:null,noServer:!1,backlog:null,server:null,host:null,path:null,port:null,WebSocket:r,...k},k.port==null&&!k.server&&!k.noServer||k.port!=null&&(k.server||k.noServer)||k.server&&k.noServer)throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified');if(k.port!=null?(this._server=e.createServer((O,x)=>{const C=e.STATUS_CODES[426];x.writeHead(426,{"Content-Length":C.length,"Content-Type":"text/plain"}),x.end(C)}),this._server.listen(k.port,k.host,k.backlog,T)):k.server&&(this._server=k.server),this._server){const O=this.emit.bind(this,"connection");this._removeListeners=p(this._server,{listening:this.emit.bind(this,"listening"),error:this.emit.bind(this,"error"),upgrade:(x,C,E)=>{this.handleUpgrade(x,C,E,O)}})}k.perMessageDeflate===!0&&(k.perMessageDeflate={}),k.clientTracking&&(this.clients=new Set,this._shouldEmitClose=!1),this.options=k,this._state=c}address(){if(this.options.noServer)throw new Error('The server is operating in "noServer" mode');return this._server?this._server.address():null}close(k){if(this._state===h){k&&this.once("close",()=>{k(new Error("The server is not running"))}),process.nextTick(m,this);return}if(k&&this.once("close",k),this._state!==u)if(this._state=u,this.options.noServer||this.options.server)this._server&&(this._removeListeners(),this._removeListeners=this._server=null),this.clients?this.clients.size?this._shouldEmitClose=!0:process.nextTick(m,this):process.nextTick(m,this);else{const T=this._server;this._removeListeners(),this._removeListeners=this._server=null,T.close(()=>{m(this)})}}shouldHandle(k){if(this.options.path){const T=k.url.indexOf("?");if((T!==-1?k.url.slice(0,T):k.url)!==this.options.path)return!1}return!0}handleUpgrade(k,T,O,x){T.on("error",g);const C=k.headers["sec-websocket-key"],E=+k.headers["sec-websocket-version"];if(k.method!=="GET"){b(this,k,T,405,"Invalid HTTP method");return}if(k.headers.upgrade.toLowerCase()!=="websocket"){b(this,k,T,400,"Invalid Upgrade header");return}if(!C||!d.test(C)){b(this,k,T,400,"Missing or invalid Sec-WebSocket-Key header");return}if(E!==8&&E!==13){b(this,k,T,400,"Missing or invalid Sec-WebSocket-Version header");return}if(!this.shouldHandle(k)){y(T,400);return}const P=k.headers["sec-websocket-protocol"];let _=new Set;if(P!==void 0)try{_=n.parse(P)}catch{b(this,k,T,400,"Invalid Sec-WebSocket-Protocol header");return}const S=k.headers["sec-websocket-extensions"],I={};if(this.options.perMessageDeflate&&S!==void 0){const v=new i(this.options.perMessageDeflate,!0,this.options.maxPayload);try{const N=s.parse(S);N[i.extensionName]&&(v.accept(N[i.extensionName]),I[i.extensionName]=v)}catch{b(this,k,T,400,"Invalid or unacceptable Sec-WebSocket-Extensions header");return}}if(this.options.verifyClient){const v={origin:k.headers[`${E===8?"sec-websocket-origin":"origin"}`],secure:!!(k.socket.authorized||k.socket.encrypted),req:k};if(this.options.verifyClient.length===2){this.options.verifyClient(v,(N,q,R,G)=>{if(!N)return y(T,q||401,R,G);this.completeUpgrade(I,C,_,k,T,O,x)});return}if(!this.options.verifyClient(v))return y(T,401)}this.completeUpgrade(I,C,_,k,T,O,x)}completeUpgrade(k,T,O,x,C,E,P){if(!C.readable||!C.writable)return C.destroy();if(C[o])throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");if(this._state>c)return y(C,503);const S=["HTTP/1.1 101 Switching Protocols","Upgrade: websocket","Connection: Upgrade",`Sec-WebSocket-Accept: ${t("sha1").update(T+a).digest("base64")}`],I=new this.options.WebSocket(null);if(O.size){const v=this.options.handleProtocols?this.options.handleProtocols(O,x):O.values().next().value;v&&(S.push(`Sec-WebSocket-Protocol: ${v}`),I._protocol=v)}if(k[i.extensionName]){const v=k[i.extensionName].params,N=s.format({[i.extensionName]:[v]});S.push(`Sec-WebSocket-Extensions: ${N}`),I._extensions=k}this.emit("headers",S,x),C.write(S.concat(`\r
`).join(`\r
`)),C.removeListener("error",g),I.setSocket(C,E,{maxPayload:this.options.maxPayload,skipUTF8Validation:this.options.skipUTF8Validation}),this.clients&&(this.clients.add(I),I.on("close",()=>{this.clients.delete(I),this._shouldEmitClose&&!this.clients.size&&process.nextTick(m,this)})),P(I,x)}}hm=l;function p(w,k){for(const T of Object.keys(k))w.on(T,k[T]);return function(){for(const O of Object.keys(k))w.removeListener(O,k[O])}}function m(w){w._state=h,w.emit("close")}function g(){this.destroy()}function y(w,k,T,O){T=T||e.STATUS_CODES[k],O={Connection:"close","Content-Type":"text/html","Content-Length":Buffer.byteLength(T),...O},w.once("finish",w.destroy),w.end(`HTTP/1.1 ${k} ${e.STATUS_CODES[k]}\r
`+Object.keys(O).map(x=>`${x}: ${O[x]}`).join(`\r
`)+`\r
\r
`+T)}function b(w,k,T,O,x){if(w.listenerCount("wsClientError")){const C=new Error(x);Error.captureStackTrace(C,b),w.emit("wsClientError",C,T,k)}else y(T,O,x)}return hm}var lm,Z1;function eq(){if(Z1)return lm;Z1=1;const f=C_();return f.createWebSocketStream=QV(),f.Server=JV(),f.Receiver=I_(),f.Sender=x_(),f.WebSocket=f,f.WebSocketServer=f.Server,lm=f,lm}const tq=Fu,{sleep:sq,isNode:M_,milliseconds:iq}=tq,nq=GV,pm=M_?eq():self.WebSocket;var rq=class extends nq{createConnection(){this.verbose&&this.log(new Date,"connecting to",this.url),this.connectionStarted=iq(),this.setConnectionTimeout(),this.connection=new pm(this.url,this.protocols,this.options),this.connection.onopen=this.onOpen.bind(this),this.connection.onmessage=this.onMessage.bind(this),this.connection.onerror=this.onError.bind(this),this.connection.onclose=this.onClose.bind(this),M_&&this.connection.on("ping",this.onPing.bind(this)).on("pong",this.onPong.bind(this)).on("upgrade",this.onUpgrade.bind(this))}connect(e=0){return this.startedConnecting||(this.startedConnecting=!0,e?sq(e).then(this.createConnection.bind(this)):this.createConnection()),this.connected}isOpen(){return this.connection.readyState===pm.OPEN}close(){if(this.connection instanceof pm)return this.connection.close()}};function cd(f,e){let t=0,s=f.length-1;for(;t<=s;){const i=t+s>>>1;f[i]-e<0?t=i+1:s=i-1}return t}const aq=1024,P_=new Float64Array(new Array(aq).fill(Number.MAX_VALUE));class Ul extends Array{constructor(e=[],t=void 0){super(),Object.defineProperty(this,"index",{__proto__:null,value:new Float64Array(P_),writable:!0}),Object.defineProperty(this,"depth",{__proto__:null,value:t||Number.MAX_SAFE_INTEGER,writable:!0}),this.length=0;for(let s=0;s<e.length;s++)this.storeArray(e[s].slice())}storeArray(e){const t=e[0],s=e[1],i=this.side?-t:t,n=cd(this.index,i);if(s){if(this.index[n]===i)this[n][1]=s;else if(this.length++,this.index.copyWithin(n+1,n,this.index.length),this.index[n]=i,this.copyWithin(n+1,n,this.length),this[n]=e,this.length>this.index.length-1){const r=Array.from(this.index);r.length=this.length*2,r.fill(Number.MAX_VALUE,this.index.length),this.index=new Float64Array(r)}}else this.index[n]===i&&(this.index.copyWithin(n,n+1,this.index.length),this.index[this.length-1]=Number.MAX_VALUE,this.copyWithin(n,n+1,this.length),this.length--)}store(e,t){this.storeArray([e,t])}limit(){if(this.length>this.depth){for(let e=this.depth;e<this.length;e++)this.index[e]=Number.MAX_VALUE;this.length=this.depth}}}class _b extends Ul{store(e,t,s){this.storeArray([e,t,s])}storeArray(e){const t=e[0],s=e[1],i=e[2],n=this.side?-t:t,r=cd(this.index,n);if(s&&i){if(this.index[r]===n){const a=this[r];a[1]=s,a[2]=i}else if(this.length++,this.index.copyWithin(r+1,r,this.index.length),this.index[r]=n,this.copyWithin(r+1,r,this.length),this[r]=e,this.length>this.index.length-1){const a=Array.from(this.index);a.length=this.length*2,a.fill(Number.MAX_VALUE,this.index.length),this.index=new Float64Array(a)}}else this.index[r]===n&&(this.index.copyWithin(r,r+1,this.index.length),this.index[this.length-1]=Number.MAX_VALUE,this.copyWithin(r,r+1,this.length),this.length--)}}class Cb extends Array{constructor(e=[],t=Number.MAX_SAFE_INTEGER){super(e.length),Object.defineProperty(this,"hashmap",{__proto__:null,value:new Map,writable:!0}),Object.defineProperty(this,"index",{__proto__:null,value:new Float64Array(P_),writable:!0}),Object.defineProperty(this,"depth",{__proto__:null,value:t||Number.MAX_SAFE_INTEGER,writable:!0}),Object.defineProperty(this,"hidden",{__proto__:null,value:new Map,writable:!0});for(let s=0;s<e.length;s++)this.length=s,this.storeArray(e[s].slice())}store(e,t,s){this.storeArray([e,t,s])}storeArray(e){const t=e[0],s=e[1],i=e[2];let n;if(t!==void 0?n=this.side?-t:t:n=void 0,s){if(this.hashmap.has(i)){const a=this.hashmap.get(i);if(n=n||a,e[0]=Math.abs(n),n===a){const o=cd(this.index,n);this.index[o]=n,this[o]=e;return}else{const o=cd(this.index,a);this.index.copyWithin(o,o+1,this.index.length),this.index[this.length-1]=Number.MAX_VALUE,this.copyWithin(o,o+1,this.length),this.length--}}this.hashmap.set(i,n);const r=cd(this.index,n);if(this.length++,this.index.copyWithin(r+1,r,this.index.length),this.index[r]=n,this.copyWithin(r+1,r,this.length),this[r]=e,this.length>this.index.length-1){const a=Array.from(this.index);a.length=this.length*2,a.fill(Number.MAX_VALUE,this.index.length),this.index=new Float64Array(a)}}else if(this.hashmap.has(i)){const r=this.hashmap.get(i),a=cd(this.index,r);this.index.copyWithin(a,a+1,this.index.length),this.index[this.length-1]=Number.MAX_VALUE,this.copyWithin(a,a+1,this.length),this.length--,this.hashmap.delete(i)}}limit(){if(this.length>this.depth){for(let e=this.depth;e<this.length;e++)this.hashmap.delete(this.index[e]),this.index[e]=Number.MAX_VALUE;this.length=this.depth}}}class oq extends Ul{get side(){return!1}}class dq extends Ul{get side(){return!0}}class cq extends _b{get side(){return!1}}class uq extends _b{get side(){return!0}}class fq extends Cb{get side(){return!1}}class hq extends Cb{get side(){return!0}}var lq={Asks:oq,Bids:dq,OrderBookSide:Ul,CountedAsks:cq,CountedBids:uq,CountedOrderBookSide:_b,IndexedAsks:fq,IndexedBids:hq,IndexedOrderBookSide:Cb};const{iso8601:mm}=Ob,{extend:Du,deepExtend:wQ}=Wx,{Asks:pq,Bids:mq,CountedAsks:gq,CountedBids:yq,IndexedAsks:bq,IndexedBids:wq,IncrementalAsks:kq,IncrementalBids:Sq,IncrementalIndexedAsks:vq,IncrementalIndexedBids:Tq}=lq;class Hu{constructor(e={},t=void 0){Object.defineProperty(this,"cache",{__proto__:null,value:[],writable:!0}),t=t||Number.MAX_SAFE_INTEGER;const i=Object.entries(Du({bids:[],asks:[],timestamp:void 0,datetime:void 0,nonce:void 0,symbol:void 0},e));for(let n=0;n<i.length;n++){const[r,a]=i[n];this[r]=a}this.asks.constructor.name==="Array"&&(this.asks=new pq(this.asks,t)),this.bids.constructor.name==="Array"&&(this.bids=new mq(this.bids,t)),this.timestamp&&(this.datetime=mm(this.timestamp))}limit(){return this.asks.limit(),this.bids.limit(),this}update(e){return e.nonce!==void 0&&this.nonce!==void 0&&e.nonce<=this.nonce?this:(this.nonce=e.nonce,this.timestamp=e.timestamp,this.datetime=mm(this.timestamp),this.reset(e))}reset(e={}){if(this.asks.index.fill(Number.MAX_VALUE),this.asks.length=0,e.asks)for(let t=0;t<e.asks.length;t++)this.asks.storeArray(e.asks[t]);if(this.bids.index.fill(Number.MAX_VALUE),this.bids.length=0,e.bids)for(let t=0;t<e.bids.length;t++)this.bids.storeArray(e.bids[t]);return this.nonce=e.nonce,this.timestamp=e.timestamp,this.datetime=mm(this.timestamp),this.symbol=e.symbol,this}}class Oq extends Hu{constructor(e={},t=void 0){super(Du(e,{asks:new gq(e.asks||[],t),bids:new yq(e.bids||[],t)}))}}class Iq extends Hu{constructor(e={},t=void 0){super(Du(e,{asks:new bq(e.asks||[],t),bids:new wq(e.bids||[],t)}))}}class xq extends Hu{constructor(e={},t=void 0){super(Du(e,{asks:new kq(e.asks||[],t),bids:new Sq(e.bids||[],t)}))}}class _q extends Hu{constructor(e={},t=void 0){super(Du(e,{asks:new vq(e.asks||[],t),bids:new Tq(e.bids||[],t)}))}}var Cq={OrderBook:Hu,CountedOrderBook:Oq,IndexedOrderBook:Iq,IncrementalOrderBook:xq,IncrementalIndexedOrderBook:_q};const Mq=ge,Pq=Fu.throttle,Aq=rq,{OrderBook:Bq,IndexedOrderBook:Eq,CountedOrderBook:Nq}=Cq,gm=O_;var Vq=class extends Mq{constructor(e={}){super(e),this.newUpdates=e.newUpdates||!0}inflate(e){return gm.inflate(e)}inflate64(e){return gm.inflate64(e)}gunzip(e){return gm.gunzip(e)}orderBook(e={},t=Number.MAX_SAFE_INTEGER){return new Bq(e,t)}indexedOrderBook(e={},t=Number.MAX_SAFE_INTEGER){return new Eq(e,t)}countedOrderBook(e={},t=Number.MAX_SAFE_INTEGER){return new Nq(e,t)}client(e){if(this.clients=this.clients||{},!this.clients[e]){const t=this.handleMessage.bind(this),s=this.onError.bind(this),i=this.onClose.bind(this),n=this.onConnected.bind(this),r=this.safeValue(this.options,"ws",{}),a=this.extend(this.streaming,{log:this.log?this.log.bind(this):this.log,ping:this.ping?this.ping.bind(this):this.ping,verbose:this.verbose,throttle:Pq(this.tokenBucket)},r);this.clients[e]=new Aq(e,t,s,i,n,a)}return this.clients[e]}spawn(e,...t){e.apply(this,t).catch(s=>{})}delay(e,t,...s){setTimeout(()=>{this.spawn(t,...s)},e)}watch(e,t,s=void 0,i=void 0,n=void 0){const r=this.client(e),a=0,o=r.future(t);return r.connect(a).then(()=>{if(!r.subscriptions[i]){r.subscriptions[i]=n||!0;const c=this.safeValue(this.options,"ws"),u=this.safeValue(c,"cost",1);s&&(this.enableRateLimit&&r.throttle?r.throttle(u).then(()=>{r.send(s)}).catch(h=>{throw h}):r.send(s))}}),o}onConnected(e,t=void 0){}onError(e,t){e.url in this.clients&&this.clients[e.url].error&&delete this.clients[e.url]}onClose(e,t){e.error||this.clients[e.url]&&delete this.clients[e.url]}async close(){const e=Object.values(this.clients||{});for(let t=0;t<e.length;t++){const s=e[t];delete this.clients[s.url],await s.close()}}findTimeframe(e,t=void 0){t=t||this.timeframes;const s=Object.keys(t);for(let i=0;i<s.length;i++){const n=s[i];if(t[n]===e)return n}}formatScientificNotationFTX(e){return e===0?"0e-00":e.toExponential().replace("e-","e-0")}};const qq=ge,{ArgumentsRequired:Io,AuthenticationError:Yd,ExchangeError:uf,ExchangeNotAvailable:J1,OrderNotFound:Qd,InvalidOrder:at,CancelPending:Lq,RateLimitExceeded:ym,InsufficientFunds:bm,BadRequest:Ki,BadSymbol:wm,PermissionDenied:Rq}=de,{TICK_SIZE:Fq}=me,Mt=Se;var A_=class extends qq{describe(){return this.deepExtend(super.describe(),{id:"aax",name:"AAX",countries:["MT"],rateLimit:600,version:"v2",hostname:"aaxpro.com",pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createDepositAddress:!1,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchCanceledOrders:!0,fetchClosedOrder:void 0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:void 0,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchL3OrderBook:void 0,fetchLedger:void 0,fetchLedgerEntry:void 0,fetchLeverage:void 0,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:void 0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrders:!0,fetchOrderTrades:void 0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:"emulated",fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTradingLimits:void 0,fetchTransactionFee:void 0,fetchTransactionFees:void 0,fetchTransactions:void 0,fetchTransfer:!1,fetchTransfers:!0,fetchWithdrawal:!1,fetchWithdrawals:!0,fetchWithdrawalWhitelist:!1,reduceMargin:!1,setLeverage:!0,setMargin:!0,setMarginMode:!1,setPositionMode:void 0,signIn:void 0,transfer:!0,withdraw:!1},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","12h":"12h","1d":"1d","3d":"3d","1w":"1w"},urls:{logo:"https://user-images.githubusercontent.com/1294454/104140087-a27f2580-53c0-11eb-87c1-5d9e81208fe9.jpg",test:{v1:"https://api.testnet.{hostname}/marketdata/v1",public:"https://api.testnet.{hostname}",private:"https://api.testnet.{hostname}"},api:{v1:"https://api.{hostname}/marketdata/v1",public:"https://api.{hostname}",private:"https://api.{hostname}"},www:"https://www.aax.com",doc:"https://www.aax.com/apidoc/index.html",fees:"https://www.aax.com/en-US/vip/",referral:"https://www.aax.com/invite/sign-up?inviteCode=JXGm5Fy7R2MB"},api:{v1:{get:["getHistMarketData"]},public:{get:{currencies:1.2,"announcement/maintenance":1.2,time:1.2,instruments:1.2,"market/orderbook":1.2,"futures/position/openInterest":1.2,"market/tickers":1.2,"market/candles":1.2,"market/history/candles":1.2,"market/trades":1.2,"market/markPrice":1.2,"futures/funding/predictedFunding/{symbol}":1.2,"futures/funding/prevFundingRate/{symbol}":1.2,"futures/funding/fundingRate":1.2,"market/candles/index":1.2,"market/index/candles":1.2}},private:{get:{"user/info":1.2,"account/balances":1.2,"account/deposit/address":1.2,"account/deposits":1.2,"account/transfer":1.2,"account/withdraws":1.2,"spot/trades":1.2,"spot/openOrders":1.2,"spot/orders":1.2,"futures/position":1.2,"futures/position/closed":1.2,"futures/trades":1.2,"futures/openOrders":1.2,"futures/orders":1.2,"futures/funding/fundingFee":1.2,"futures/funding/predictedFundingFee/{symbol}":1.2},post:{"account/transfer":1.2,"spot/orders":1.2,"spot/orders/cancelAllOnTimeout":10,"futures/orders":1.2,"futures/orders/cancelAllOnTimeout":10,"futures/position/sltp":1.2,"futures/position/close":1.2,"futures/position/leverage":30,"futures/position/margin":1.2},put:{"spot/orders":1.2,"futures/orders":1.2},delete:{"spot/orders/cancel/{orderID}":1,"spot/orders/cancel/all":10,"futures/orders/cancel/{orderID}":1,"futures/orders/cancel/all":10}}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.0006"),taker:this.parseNumber("0.001")},funding:{tierBased:!1,percentage:!0,withdraw:{}}},commonCurrencies:{XBT:"XBT"},exceptions:{exact:{2002:bm,2003:Qd,10003:Ki,10006:Yd,10007:Yd,11007:Yd,20001:bm,20009:at,3e4:Qd,30001:at,30004:at,30005:at,30006:at,30007:at,30008:at,30009:at,30010:at,30011:Lq,30012:Ki,30013:wm,30014:Qd,30015:at,30016:uf,30017:at,30018:at,30019:at,30020:at,30021:at,30022:at,30023:at,30024:at,30025:at,30026:at,30027:at,30028:wm,30029:at,30030:at,30031:at,30032:at,30033:at,30034:ym,30035:ym,30036:J1,30037:at,30038:uf,30039:bm,30040:at,30041:at,30042:at,30043:at,30044:Ki,30045:at,30046:at,30047:at,30048:at,30049:at,30050:at,40004:Ki,40009:ym,40102:Yd,40103:Yd,40303:Rq,41001:Ki,41002:Ki,42001:J1,50001:uf,50002:uf},broad:{}},precisionMode:Fq,options:{defaultType:"spot",accountsByType:{spot:"SPTP",future:"FUTP",otc:"F2CP",saving:"VLTP"},accountsById:{SPTP:"spot",FUTP:"future",F2CP:"otc",VLTP:"saving"},networks:{ETH:"ERC20",TRX:"TRC20",SOL:"SPL"},transfer:{fillResponseFromRequest:!0}}})}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeInteger(t,"data")}async fetchStatus(e={}){const t=await this.publicGetAnnouncementMaintenance(e),s=this.milliseconds(),i=this.safeInteger(t,"ts",s),n=this.safeValue(t,"data",{});let r,a;if(n){const o=this.parse8601(this.safeString(n,"startTime")),d=this.parse8601(this.safeString(n,"endTime"));if(d!==void 0){const c=o===void 0?!0:i<o,u=i>d||c;a=d,r=u?"ok":"maintenance"}else r=n}else a=void 0,r="ok";return{status:r,updated:i,eta:a,url:void 0,info:t}}async fetchMarkets(e={}){const t=await this.publicGetInstruments(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeString(r,"base"),d=this.safeString(r,"quote"),c=this.safeString(r,"settleCurrency"),u=this.safeCurrencyCode(o),h=this.safeCurrencyCode(d),l=this.safeCurrencyCode(c),p=this.safeString(r,"status"),m=this.safeString(r,"type");let g,y,b;const w=m==="spot",k=m==="futures",T=this.safeStringLower(r,"settleType");T!==void 0&&(g=T==="inverse",y=T==="vanilla",b=T==="quanto");let O=u+"/"+h,x="spot",C,E,P;if(k){O=O+":"+l,x="swap",C=this.safeNumber(r,"multiplier"),E="1";const _=this.safeString(r,"imRate");P=Mt.stringDiv("1",_)}i.push({id:a,symbol:O,base:u,quote:h,settle:l,baseId:o,quoteId:d,settleId:c,type:x,spot:w,margin:!1,swap:k,future:!1,option:!1,active:p==="enable",contract:k,linear:y,inverse:g,quanto:b,taker:this.safeNumber(r,"takerFee"),maker:this.safeNumber(r,"makerFee"),contractSize:C,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(r,"lotSize"),price:this.safeNumber(r,"tickSize")},limits:{leverage:{min:this.parseNumber(E),max:this.parseNumber(P)},amount:{min:this.safeNumber(r,"minQuantity"),max:this.safeNumber(r,"maxQuantity")},price:{min:this.safeNumber(r,"minPrice"),max:this.safeNumber(r,"maxPrice")},cost:{min:void 0,max:void 0}},info:r})}return i}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s={},i=this.safeValue(t,"data",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.safeString(r,"network"),c=this.safeValue(r,"enableWithdraw"),u=this.safeValue(r,"enableDeposit"),h=this.safeValue(r,"visible"),l=c&&u&&h,p={info:r,id:d,network:this.safeCurrencyCode(d),limits:{withdraw:{min:this.safeNumber(r,"withdrawMin"),max:void 0},deposit:{min:this.safeNumber(r,"depositMin"),max:void 0}},active:l,withdraw:c&&h,deposit:u&&h,fee:this.safeNumber(r,"withdrawFee"),precision:this.safeNumber(r,"withdrawPrecision")},m=this.safeValue(s,o),g=this.safeString(r,"withdrawFee"),y=this.safeString(r,"withdrawPrecision"),b=this.safeString(r,"depositMin"),w=this.safeString(r,"withdrawMin");if(m!==void 0){m.networks.push(p);const k=m.precision.toString(),T=m.limits.deposit.min.toString(),O=m.limits.withdraw.min.toString(),x=m.fee.toString();m.precision=this.parseNumber(Mt.stringMax(k,y)),m.limits.deposit.min=this.parseNumber(Mt.stringMin(T,b)),m.limits.withdraw.min=this.parseNumber(Mt.stringMin(O,w)),m.fee=this.parseNumber(Mt.stringMin(x,g))}else{const k=this.safeString(r,"displayName"),T=u&&h,O=c&&h;s[o]={info:{},id:a,name:k,code:o,precision:this.parseNumber(y),active:l,deposit:T,withdraw:O,fee:this.parseNumber(g),networks:[p],limits:{amount:{min:void 0,max:void 0},deposit:{min:this.parseNumber(b),max:void 0},withdraw:{min:this.parseNumber(w),max:void 0}}}}}return s}parseTicker(e,t=void 0){const s=this.safeInteger(e,"t"),i=this.safeString(e,"s"),n=this.safeSymbol(i,t),r=this.safeString(e,"c"),a=this.safeString(e,"o"),o=this.safeString(e,"v");return this.safeTicker({symbol:n,timestamp:s,datetime:void 0,high:this.safeString(e,"h"),low:this.safeString(e,"l"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:a,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:o,info:e},t)}async setMargin(e,t,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id,margin:t},r=await this.privatePostFuturesPositionMargin(this.extend(n,s)),a=this.safeValue(r,"data",{});return this.parseModifyMargin(a,i)}parseModifyMargin(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeString(e,"quote");return{info:e,type:"set",amount:void 0,total:this.safeNumber(e,"posMargin"),code:this.safeCurrencyCode(i),symbol:this.safeSymbol(s,t),status:void 0}}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetMarketTickers(t),i=this.safeValue(s,"tickers",[]),n=[],r=this.safeInteger(s,"t");for(let a=0;a<i.length;a++){const o=this.parseTicker(this.extend(i[a],{t:r}));n.push(o)}return this.filterByArray(n,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);if(e=i.symbol,t===void 0)t=20;else if(t!==20&&t!==50)throw new Ki(this.id+" fetchOrderBook() limit argument must be undefined, 20 or 50");const n={symbol:i.id,level:t},r=await this.publicGetMarketOrderbook(this.extend(n,s)),a=this.safeInteger(r,"t");return this.parseOrderBook(r,e,a)}parseTrade(e,t=void 0){let s=this.safeInteger(e,"t");s===void 0&&(s=this.parse8601(this.safeString(e,"createTime")));let i=this.safeString2(e,"tid","tradeID");i=this.safeString(e,"i",i);const n=this.safeString(e,"symbol");t=this.safeMarket(n,t);let r=this.safeString2(e,"p","filledPrice");const a=this.safeString2(e,"q","filledQty"),o=this.safeString(e,"orderID"),d=this.safeValue(e,"taker");let c;d!==void 0&&(c=d?"taker":"maker");let u=this.safeString(e,"side");u==="1"?u="buy":u==="2"&&(u="sell"),u===void 0&&(u=r[0]==="-"?"sell":"buy"),r=Mt.stringAbs(r);const h=this.parseOrderType(this.safeString(e,"orderType"));let l;const p=this.safeString(e,"commission");if(p!==void 0){let m;u==="buy"?m=t.base:u==="sell"&&(m=t.quote),l={currency:m,cost:p}}return this.safeTrade({info:e,id:i,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:h,side:u,order:o,takerOrMaker:c,price:r,amount:a,cost:void 0,fee:l},t)}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.currency=n.id),t!==void 0&&(r.startTime=t);const a=await this.privateGetAccountTransfer(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransfers(o,n,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);s=s===void 0?2e3:s,s=Math.min(s,2e3);const r={symbol:n.id,limit:s},a=await this.publicGetMarketTrades(r),o=this.safeValue(a,"trades",[]);return this.parseTrades(o,n,t,s)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,5),this.safeNumber(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,6)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,timeFrame:this.timeframes[t]};i=i===void 0?500:i;const o=this.parseTimeframe(t);if(s===void 0){const u=this.seconds();a.start=u-o*i,a.end=u}else{const u=parseInt(s/1e3);a.start=u,a.end=this.sum(u,o*i)}const d=await this.publicGetMarketHistoryCandles(this.extend(a,n)),c=this.safeValue(d,"data",[]);return this.parseOHLCVs(c,r,t,s,i)}async fetchAccounts(e={}){const t=await this.privateGetAccountBalances(e),s=this.safeValue(t,"data",{});return this.parseAccounts(s)}parseAccount(e){const t=this.safeString(e,"currency"),s=this.safeString(e,"purseType"),i=this.safeValue(this.options,"accountsById",{});return{info:e,id:void 0,code:this.safeCurrencyCode(t),type:this.safeString(i,s,s)}}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString2(this.options,"fetchBalance","defaultType","spot"),s=this.safeString(e,"type",t),i=this.safeValue(this.options,"accountsByType",{}),n=this.safeString(i,s,s),r={purseType:n};e=this.omit(e,"type");const a=await this.privateGetAccountBalances(this.extend(r,e)),o=this.safeValue(a,"data",[]),d=this.safeInteger(a,"ts"),c={info:a,timestamp:d,datetime:this.iso8601(d)};for(let u=0;u<o.length;u++){const h=o[u];if(this.safeString(h,"purseType")===n){const p=this.safeString(h,"currency"),m=this.safeCurrencyCode(p),g=this.account();g.free=this.safeString(h,"available"),g.used=this.safeString(h,"unavailable"),c[m]=g}}return this.safeBalance(c)}async createOrder(e,t,s,i,n=void 0,r={}){let a=t.toUpperCase();const o=s.toUpperCase();await this.loadMarkets();const d=this.market(e),c={symbol:d.id,orderQty:this.amountToPrecision(e,i),side:o},u=this.safeString2(r,"clOrdID","clientOrderId");u!==void 0&&(c.clOrdID=u);const h=this.isPostOnly(a==="MARKET",void 0,r),l=this.safeString(r,"timeInForce");h&&(c.execInst="Post-Only"),l!==void 0&&l!=="PO"&&(c.timeInForce=l);const p=this.safeValue2(r,"triggerPrice","stopPrice");if(r=this.omit(r,["clOrdID","clientOrderId","postOnly","timeInForce","stopPrice","triggerPrice"]),p===void 0){if(a==="STOP-LIMIT"||a==="STOP")throw new Io(this.id+" createOrder() requires a stopPrice parameter for "+a+" orders")}else a==="LIMIT"?a="STOP-LIMIT":a==="MARKET"&&(a="STOP"),c.stopPrice=this.priceToPrecision(e,p);(a==="LIMIT"||a==="STOP-LIMIT")&&(c.price=this.priceToPrecision(e,n)),c.orderType=a;let m;d.spot?m="privatePostSpotOrders":d.contract&&(m="privatePostFuturesOrders");const g=await this[m](this.extend(c,r)),y=this.safeValue(g,"data",{});return this.parseOrder(y,d)}async editOrder(e,t,s,i,n,r=void 0,a={}){await this.loadMarkets();const o=this.market(t),d={orderID:e},c=this.safeValue2(a,"triggerPrice","stopPrice");c!==void 0&&(d.stopPrice=this.priceToPrecision(t,c),a=this.omit(a,"stopPrice")),r!==void 0&&(d.price=this.priceToPrecision(t,r)),n!==void 0&&(d.orderQty=this.amountToPrecision(t,n));let u;o.spot?u="privatePutSpotOrders":o.contract&&(u="privatePutFuturesOrders");const h=await this[u](this.extend(d,a)),l=this.safeValue(h,"data",{});return this.parseOrder(l,o)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderID:e};let n;t!==void 0&&(n=this.market(t));const[r,a]=this.handleMarketTypeAndParams("cancelOrder",n,s),o=this.getSupportedMapping(r,{spot:"privateDeleteSpotOrdersCancelOrderID",swap:"privateDeleteFuturesOrdersCancelOrderID",future:"privateDeleteFuturesOrdersCancelOrderID"}),d=await this[o](this.extend(i,a)),c=this.safeValue(d,"data",{});return this.parseOrder(c,n)}async cancelOrders(e,t=void 0,s={}){if(t===void 0)throw new Io(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={symbol:i.id};let r;i.spot?r="privateDeleteSpotOrdersCancelAll":i.contract&&(r="privateDeleteFuturesOrdersCancelAll");const a=this.safeValue(s,"clientOrderIds");return a!==void 0?(s=this.omit(s,["clientOrderIds"]),n.clOrdID=a.join(",")):e!==void 0&&(n.orderID=e.join(",")),await this[r](this.extend(n,s))}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new Io(this.id+" cancelAllOrders() requires a symbol argument");await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let n;return s.spot?n="privateDeleteSpotOrdersCancelAll":s.contract&&(n="privateDeleteFuturesOrdersCancelAll"),await this[n](this.extend(i,t))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeString2(this.options,"fetchOrder","defaultType","spot");s.type=this.safeString(s,"type",i);const n={},r=this.safeString2(s,"clOrdID","clientOrderId");r===void 0?n.orderID=e:(n.clOrdID=r,s=this.omit(s,["clOrdID","clientOrderId"]));const a=await this.fetchOrders(t,void 0,void 0,this.extend(n,s)),o=this.safeValue(a,0);if(o===void 0)throw r===void 0?new Qd(this.id+" fetchOrder() could not find order id "+e):new Qd(this.id+" fetchOrder() could not find order clientOrderID "+r);return o}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id);const[a,o]=this.handleMarketTypeAndParams("fetchOpenOrders",r,i),d=this.getSupportedMapping(a,{spot:"privateGetSpotOpenOrders",swap:"privateGetFuturesOpenOrders",future:"privateGetFuturesOpenOrders"}),c=this.safeString2(i,"clOrdID","clientOrderId");c!==void 0&&(n.clOrdID=c,i=this.omit(i,["clOrdID","clientOrderId"])),s!==void 0&&(n.pageSize=s);const u=await this[d](this.extend(n,o)),h=this.safeValue(u,"data",{}),l=this.safeValue(h,"list",[]);return this.parseOrders(l,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={orderStatus:"2"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){const n={orderStatus:"3"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id);const[a,o]=this.handleMarketTypeAndParams("fetchOrders",r,i),d=this.getSupportedMapping(a,{spot:"privateGetSpotOrders",swap:"privateGetFuturesOrders",future:"privateGetFuturesOrders"}),c=this.safeString2(i,"clOrdID","clientOrderId");c!==void 0&&(n.clOrdID=c,i=this.omit(i,["clOrdID","clientOrderId"])),s!==void 0&&(n.pageSize=s),t!==void 0&&(n.startDate=this.yyyymmdd(t));const u=await this[d](this.extend(n,o)),h=this.safeValue(u,"data",{}),l=this.safeValue(h,"list",[]);return this.parseOrders(l,r,t,s)}parseOrderStatus(e){const t={0:"open",1:"open",2:"open",3:"closed",4:"canceled",5:"canceled",6:"rejected",10:"expired",11:"rejected"};return this.safeString(t,e,e)}parseOrderType(e){const t={1:"market",2:"limit",3:"stop",4:"stop-limit",7:"stop-loss",8:"take-profit"};return this.safeString(t,e,e)}parseTimeInForce(e){const t={1:"GTC",3:"IOC",4:"FOK"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){let s=this.safeValue(e,"createTime");typeof s=="string"&&(s=this.parse8601(s));const i=this.parseOrderStatus(this.safeString(e,"orderStatus")),n=this.parseOrderType(this.safeString(e,"orderType"));let r=this.safeString(e,"side");r==="1"?r="buy":r==="2"&&(r="sell");const a=this.safeString(e,"orderID"),o=this.safeString(e,"clOrdID"),d=this.safeString(e,"symbol");t=this.safeMarket(d,t);const c=this.safeString(e,"price"),u=this.safeNumber(e,"stopPrice"),h=this.parseTimeInForce(this.safeString(e,"timeInForce")),p=this.safeString(e,"execInst")==="Post-Only",m=this.safeString(e,"avgPrice"),g=this.safeString(e,"orderQty"),y=this.safeString(e,"cumQty");let b=this.safeString(e,"leavesQty");Mt.stringEquals(y,"0")&&Mt.stringEquals(b,"0")&&(b=void 0);let w=this.safeValue(e,"transactTime");typeof w=="string"&&(w=this.parse8601(w));let k;const T=this.safeNumber(e,"commission");if(T!==void 0){let O;r==="buy"?O=t.base:r==="sell"&&(O=t.quote),k={currency:O,cost:T}}return this.safeOrder({id:a,info:e,clientOrderId:o,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:w,status:i,symbol:t.symbol,type:n,timeInForce:h,postOnly:p,side:r,price:c,stopPrice:u,average:m,amount:g,filled:y,remaining:b,cost:void 0,trades:void 0,fee:k},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id);const[a,o]=this.handleMarketTypeAndParams("fetchMyTrades",r,i),d=this.getSupportedMapping(a,{spot:"privateGetSpotTrades",swap:"privateGetFuturesTrades",future:"privateGetFuturesTrades"});s!==void 0&&(n.pageSize=s),t!==void 0&&(n.startDate=this.yyyymmdd(t));const c=await this[d](this.extend(n,o)),u=this.safeValue(c,"data",{}),h=this.safeValue(u,"list",[]);return this.parseTrades(h,r,t,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id};if("network"in t){const a=this.safeValue(this.options,"networks",{}),o=this.safeStringUpper(t,"network");t=this.omit(t,"network"),i.network=this.safeStringUpper(a,o,o)}const n=await this.privateGetAccountDepositAddress(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseDepositAddress(r,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.currency(e),n.currency=r.id),t!==void 0){const d=parseInt(t/1e3);n.startTime=d,n.endTime=this.sum(d,90*24*60*60)}const a=await this.privateGetAccountDeposits(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.currency(e),n.currency=r.id),t!==void 0){const d=parseInt(t/1e3);n.startTime=d,n.endTime=this.sum(d,90*24*60*60)}const a=await this.privateGetAccountWithdraws(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,r,t,s)}parseTransactionStatusByType(e,t=void 0){const s={deposit:{1:"pending",2:"ok",3:"failed"},withdrawal:{0:"pending",1:"pending",2:"pending",3:"failed",4:"pending",5:"ok",6:"failed"}};return this.safeString(this.safeValue(s,t,{}),e,e)}parseAddressByType(e,t,s=void 0){let i,n,r,a;return s==="deposit"?(i=e,r=t):s==="withdrawal"&&(n=e,a=t),[i,r,n,a]}parseTransaction(e,t=void 0){const s=this.safeString(e,"fee");let i="withdrawal";s===void 0&&(i="deposit");const n=this.safeCurrencyCode(this.safeString(e,"currency")),r=this.safeString(e,"txHash"),a=this.safeString(e,"address"),o=this.safeString(e,"addressTag"),[d,c,u,h]=this.parseAddressByType(a,o,i),l=this.safeString(e,"quantity"),p=this.parse8601(this.safeString(e,"createdTime")),m=this.parse8601(this.safeString(e,"updatedTime")),g=this.parseTransactionStatusByType(this.safeString(e,"status"),i),y=this.safeString(e,"network");return{id:void 0,info:e,txid:r,timestamp:p,datetime:this.iso8601(p),network:y,addressFrom:d,address:a,addressTo:u,amount:this.parseNumber(l),type:i,currency:n,status:g,updated:m,tagFrom:c,tag:o,tagTo:h,comment:void 0,fee:s}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new Ki("Funding rates only exist for swap contracts");const i={symbol:s.id},n=await this.publicGetFuturesFundingPrevFundingRateSymbol(this.extend(i,t)),r=this.safeValue(n,"data");return this.parseFundingRate(r)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeNumber(e,"markPrice"),r=this.safeNumber(e,"fundingRate"),a=this.safeString(e,"fundingTime"),o=this.safeString(e,"nextFundingTime");return{info:e,symbol:i,markPrice:n,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:void 0,fundingTimestamp:this.parse8601(o),fundingDatetime:o,nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:r,previousFundingTimestamp:this.parse8601(a),previousFundingDatetime:a}}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"tag");let n=this.safeString(e,"currency");const r=this.safeString(e,"network");r!==void 0&&(n=n.replace(r,""));const a=this.safeCurrencyCode(n);return{info:e,currency:a,address:s,tag:i,network:r}}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Io(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};t!==void 0&&(r.startTime=parseInt(t/1e3));const a=this.safeInteger2(i,"until","till");i=this.omit(i,["till","until"]),a!==void 0&&(r.endTime=parseInt(a/1e3)),s!==void 0&&(r.limit=s);const o=await this.publicGetFuturesFundingFundingRate(this.extend(r,i)),d=this.safeValue(o,"data",[]),c=[];for(let h=0;h<d.length;h++){const l=d[h],p=this.safeString(l,"symbol"),m=this.safeSymbol(p),g=this.safeString(l,"fundingTime");c.push({info:l,symbol:m,fundingRate:this.safeNumber(l,"fundingRate"),timestamp:this.parse8601(g),datetime:g})}const u=this.sortBy(c,"timestamp");return this.filterBySymbolSinceLimit(u,n.symbol,t,s)}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),e===void 0)throw new Io(this.id+" fetchFundingHistory() requires a symbol argument");if(s===void 0)s=100;else if(s>1e3)throw new Ki(this.id+" fetchFundingHistory() limit argument cannot exceed 1000");const r={symbol:this.market(e).id,limit:s};t!==void 0&&(r.startTime=t);const a=await this.privateGetFuturesFundingFundingFee(this.extend(r,i)),o=this.safeValue(a,"data",[]),d=[];for(let c=0;c<o.length;c++){const u=o[c],h=this.safeString(u,"fundingTime");d.push({info:u,symbol:e,code:this.safeCurrencyCode(this.safeString(u,"currency")),timestamp:this.parse8601(h),datetime:h,id:void 0,amount:this.safeNumber(u,"fundingFee")})}return d}async setLeverage(e,t=void 0,s={}){if(await this.loadMarkets(),t===void 0)throw new Io(this.id+" setLeverage() requires a symbol argument");if(e<1||e>100)throw new Ki(this.id+" leverage should be between 1 and 100");const i=this.market(t);if(i.type!=="swap")throw new wm(this.id+" setLeverage() supports swap contracts only");const n={symbol:i.id,leverage:e};return await this.privatePostFuturesPositionLeverage(this.extend(n,s))}parseTransfer(e,t=void 0){const s=this.safeString(e,"transferID"),i=this.safeNumber(e,"quantity"),n=this.parse8601(this.safeString(e,"transferTime")),r=this.safeValue(this.options,"accounts",{}),a=this.safeString(e,"fromPurse"),o=this.safeString(e,"toPurse"),d=this.safeString(r,a),c=this.safeString(r,o),u=this.safeString(e,"currency"),h=this.safeCurrencyCode(u,t);return{info:e,id:s,timestamp:n,datetime:this.iso8601(n),currency:h,amount:i,fromAccount:d,toAccount:c,status:void 0}}parseTransferStatus(e){const t={1:"ok"};return this.safeString(t,e,"canceled")}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c={currency:r.id,fromPurse:o,toPurse:d,quantity:t},u=await this.privatePostAccountTransfer(this.extend(c,n)),h=this.safeValue(u,"data",{}),l=this.parseTransfer(h,r),p=this.safeValue(this.options,"transfer",{});return this.safeValue(p,"fillResponseFromRequest",!0)&&(l.fromAccount===void 0&&(l.fromAccount=s),l.toAccount===void 0&&(l.toAccount=i),l.amount===void 0&&(l.amount=t)),l.status=this.parseTransferStatus(this.safeString(u,"code")),l}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeString(e,"currentQty");let n;Mt.stringGt(i,"0")?n="long":Mt.stringLt(i,"0")&&(n="short");const r=this.safeString(e,"leverage"),a=this.safeString(e,"unrealisedPnl"),o=this.safeString(e,"currentQty"),d=this.safeString(t,"contractSize"),c=Mt.stringMul(o,d),u=this.safeString(e,"marketPrice"),h=this.safeInteger(e,"ts"),l=this.safeString(e,"liquidationPrice"),p=this.safeValue(t,"info"),m=this.safeString(p,"multiplier"),g=this.safeString(e,"settleType"),y=this.safeString(e,"avgEntryPrice"),b=this.safeString(e,"commission");let w,k,T;if(g==="VANILLA"){T=Mt.stringMul(c,u),w=Mt.stringDiv(Mt.stringMul(Mt.stringMul(o,y),m),r);const E=Mt.stringDiv(Mt.stringMul(o,m),Mt.stringMul(y,r));k=Mt.stringAdd(E,b)}else T=Mt.stringDiv(c,u),w=Mt.stringDiv(o,Mt.stringMul(r,y)),k=w;const O=this.safeString(e,"posMargin"),x=Mt.stringDiv(a,w),C=Mt.stringDiv(k,O);return{info:e,id:void 0,symbol:this.safeString(t,"symbol"),timestamp:h,datetime:this.iso8601(h),initialMargin:this.parseNumber(w),initialMarginPercentage:this.parseNumber(Mt.stringDiv(w,T)),maintenanceMargin:this.parseNumber(k),maintenanceMarginPercentage:this.parseNumber(Mt.stringDiv(k,T)),entryPrice:this.parseNumber(y),notional:this.parseNumber(T),leverage:this.parseNumber(r),unrealizedPnl:this.parseNumber(a),contracts:this.parseNumber(i),contractSize:this.parseNumber(d),marginRatio:this.parseNumber(C),liquidationPrice:l,markPrice:this.safeNumber(e,"marketPrice"),collateral:this.parseNumber(O),marginMode:"isolated",side:n,percentage:this.parseNumber(x)}}async fetchPosition(e=void 0,t={}){await this.loadMarkets();const i={symbol:this.market(e).id},n=await this.privateGetFuturesPosition(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeInteger(n,"ts"),o=this.safeValue(r,0),d=this.parsePosition(o);return this.extend(d,{timestamp:a,datetime:this.iso8601(a)})}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s={};if(e!==void 0){let o;if(Array.isArray(e)){if(e.length>1)throw new Ki(this.id+" fetchPositions() symbols argument cannot contain more than 1 symbol");o=e[0]}else o=e;e=this.marketSymbols(e);const d=this.market(o);s.symbol=d.id}const i=await this.privateGetFuturesPosition(this.extend(s,t)),n=[],r=this.safeValue(i,"data",[]),a=this.safeInteger(i,"ts");for(let o=0;o<r.length;o++){const d=this.parsePosition(r[o]);n.push(this.extend(d,{timestamp:a,datetime:this.iso8601(a)}))}return this.filterByArray(n,"symbol",e,!1)}async fetchOpenInterest(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.contract)throw new Ki(this.id+" fetchOpenInterest() supports contract markets only");const i={symbol:s.id},n=await this.publicGetFuturesPositionOpenInterest(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeInteger(n,"ts"),o=this.parseOpenInterest(r,s);return this.extend(o,{timestamp:a,datetime:this.iso8601(a)})}parseOpenInterest(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeNumber(e,"openInterest"),n=this.safeNumber(e,"openInterestUSD");return{symbol:this.safeSymbol(s),openInterestAmount:i,baseVolume:i,openInterestValue:n,quoteVolume:n,timestamp:void 0,datetime:void 0,info:e}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="v1")Object.keys(o).length&&(a+="?"+this.urlencode(o));else if(a="/"+this.version+a,t==="public")Object.keys(o).length&&(a+="?"+this.urlencode(o));else if(t==="private"){this.checkRequiredCredentials();const d=this.nonce().toString();n={"X-ACCESS-KEY":this.apiKey,"X-ACCESS-NONCE":d};let c=d+":"+s;s==="GET"?(Object.keys(o).length&&(a+="?"+this.urlencode(o)),c+=a):(n["Content-Type"]="application/json",r=this.json(o),c+=a+r);const u=this.hmac(this.encode(c),this.encode(this.secret));n["X-ACCESS-SIGN"]=u}return a=this.implodeHostname(this.urls.api[t])+a,{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"code");if(c!==void 0&&c!=="1"){const u=this.id+" "+this.json(a);this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,r,u)}}};const Dq=ge,{ExchangeError:Hq,BadRequest:ek,PermissionDenied:tk,BadSymbol:Gq,NotSupported:Uq,InsufficientFunds:$q,InvalidOrder:jq}=de,{TICK_SIZE:Wq}=me;var zq=class extends Dq{describe(){return this.deepExtend(super.describe(),{id:"alpaca",name:"Alpaca",countries:["US"],rateLimit:333,hostname:"alpaca.markets",urls:{logo:"https://user-images.githubusercontent.com/1294454/187234005-b864db3d-f1e3-447a-aaf9-a9fc7b955d07.jpg",www:"https://alpaca.markets",api:{public:"https://api.{hostname}/{version}",private:"https://api.{hostname}/{version}",cryptoPublic:"https://data.{hostname}/{version}",markets:"https://api.{hostname}/{version}"},test:{public:"https://paper-api.{hostname}/{version}",private:"https://paper-api.{hostname}/{version}",cryptoPublic:"https://data.{hostname}/{version}",markets:"https://api.{hostname}/{version}"},doc:"https://alpaca.markets/docs/",fees:"https://alpaca.markets/support/what-are-the-fees-associated-with-crypto-trading/"},has:{CORS:!1,spot:!0,margin:!1,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,fetchBalance:!0,fetchBidsAsks:!1,fetchClosedOrders:!1,fetchCurrencies:!1,fetchDepositAddress:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRates:!1,fetchL1OrderBook:!0,fetchL2OrderBook:!1,fetchMarkets:!0,fetchMyTrades:!1,fetchOHLCV:!1,fetchOpenOrder:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchPositions:!1,fetchStatus:!1,fetchTicker:!1,fetchTickers:!1,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfers:!1,fetchWithdrawals:!1,setLeverage:!1,setMarginMode:!1,transfer:!1,withdraw:!1},api:{markets:{get:["assets/public/beta"]},private:{get:["account","orders","orders/{order_id}","positions","positions/{symbol}","account/activities/{activity_type}"],post:["orders"],delete:["orders","orders/{order_id}"]},cryptoPublic:{get:["crypto/latest/orderbooks","crypto/trades","crypto/quotes","crypto/latest/quotes","crypto/bars","crypto/snapshots"]}},timeframes:{"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1H","2h":"2H","4h":"4H","6h":"6H","8h":"8H","12h":"12H","1d":"1D","3d":"3D","1w":"1W","1M":"1M"},precisionMode:Wq,requiredCredentials:{apiKey:!0,secret:!0},fees:{trading:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.003"),taker:this.parseNumber("0.003"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.003")],[this.parseNumber("500000"),this.parseNumber("0.0028")],[this.parseNumber("1000000"),this.parseNumber("0.0025")],[this.parseNumber("5000000"),this.parseNumber("0.002")],[this.parseNumber("10000000"),this.parseNumber("0.0018")],[this.parseNumber("25000000"),this.parseNumber("0.0015")],[this.parseNumber("50000000"),this.parseNumber("0.00125")],[this.parseNumber("100000000"),this.parseNumber("0.001")]],maker:[[this.parseNumber("0"),this.parseNumber("0.003")],[this.parseNumber("500000"),this.parseNumber("0.0028")],[this.parseNumber("1000000"),this.parseNumber("0.0025")],[this.parseNumber("5000000"),this.parseNumber("0.002")],[this.parseNumber("10000000"),this.parseNumber("0.0018")],[this.parseNumber("25000000"),this.parseNumber("0.0015")],[this.parseNumber("50000000"),this.parseNumber("0.00125")],[this.parseNumber("100000000"),this.parseNumber("0.001")]]}}},headers:{"APCA-PARTNER-ID":"ccxt"},options:{fetchTradesMethod:"cryptoPublicGetCryptoTrades",fetchOHLCVMethod:"cryptoPublicGetCryptoBars",versions:{public:"v2",private:"v2",cryptoPublic:"v1beta2",markets:"v2"},defaultExchange:"CBSE",exchanges:["CBSE","FTX","GNSS","ERSX"],defaultTimeInForce:"gtc",clientOrderId:"ccxt_{id}"},exceptions:{exact:{"forbidden.":tk,4041e4:jq,40010001:ek,4011e4:tk,4031e4:$q},broad:{"Invalid format for parameter":ek,"Invalid symbol":Gq}}})}async fetchMarkets(e={}){const t={asset_class:"crypto",tradeable:!0},s=await this.marketsGetAssetsPublicBeta(this.extend(t,e)),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=a.split("/"),d=this.safeString(o,0),c=this.safeString(o,1),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),l=u+"/"+h,m=this.safeString(r,"status")==="active",g=this.safeNumber(r,"min_order_size"),y=this.safeNumber(r,"min_trade_increment"),b=this.safeNumber(r,"price_increment");i.push({id:a,symbol:l,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:void 0,swap:!1,future:!1,option:!1,active:m,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:y,price:b},limits:{leverage:{min:void 0,max:void 0},amount:{min:g,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),a={symbols:n.id};t!==void 0&&(a.start=this.iso8601(t)),s!==void 0&&(a.limit=parseInt(s));const o=this.safeString(this.options,"fetchTradesMethod","cryptoPublicGetCryptoTrades"),d=await this[o](this.extend(a,i)),c=this.safeValue(d,"trades",{}),u=this.safeValue(c,n.id,{});return this.parseTrades(u,n,t,s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n=i.id,r={symbols:n},a=await this.cryptoPublicGetCryptoLatestOrderbooks(this.extend(r,s)),o=this.safeValue(a,"orderbooks",{}),d=this.safeValue(o,n,{}),c=this.parse8601(this.safeString(d,"t"));return this.parseOrderBook(d,i.symbol,c,"b","a","p","s")}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbols:r.id,timeframe:this.timeframes[t]};i!==void 0&&(a.limit=i),s!==void 0&&(a.start=parseInt(s/1e3));const o=this.safeString(this.options,"fetchOHLCVMethod","cryptoPublicGetCryptoBars"),d=await this[o](this.extend(a,n)),c=this.safeValue(d,"bars",{}),u=this.safeValue(c,r.id,{});return this.parseOHLCVs(u,r,t,s,i)}parseOHLCV(e,t=void 0){const s=this.safeString(e,"t");return[this.parse8601(s),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),d={symbol:a.id,qty:this.amountToPrecision(e,i),side:s,type:t},c=this.safeStringN(r,["triggerPrice","stop_price"]);if(c!==void 0){let w;if(t.indexOf("limit")>=0)w="stop_limit";else throw new Uq(this.id+" createOrder() does not support stop orders for "+t+" orders, only stop_limit orders are supported");d.stop_price=this.priceToPrecision(e,c),d.type=w}t.indexOf("limit")>=0&&(d.limit_price=this.priceToPrecision(e,n));const u=this.safeString(this.options,"defaultTimeInForce");d.time_in_force=this.safeString(r,"timeInForce",u),r=this.omit(r,["timeInForce","triggerPrice"]);const h=this.safeString(this.options,"clientOrderId"),m=this.uuid().split("-").join(""),g=this.implodeParams(h,{id:m}),y=this.safeString(r,"clientOrderId",g);d.client_order_id=y,r=this.omit(r,["clientOrderId"]);const b=await this.privatePostOrders(this.extend(d,r));return this.parseOrder(b,a)}async cancelOrder(e,t=void 0,s={}){const i={order_id:e},n=await this.privateDeleteOrdersOrderId(this.extend(i,s));return this.safeValue(n,"message",{})}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privateGetOrdersOrderId(this.extend(i,s)),r=this.safeString(n,"symbol"),a=this.safeMarket(r);return this.parseOrder(n,a)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));const r=await this.privateGetOrders(i);return this.parseOrders(r,n,t,s)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeString(e,"status"),r=this.parseOrderStatus(n),a=this.safeString(e,"commission");let o;a!==void 0&&(o={cost:a,currency:"USD"});let d=this.safeString(e,"order_type");d.indexOf("limit")>=0&&(d="limit");const c=this.safeString(e,"submitted_at"),u=this.parse8601(c);return this.safeOrder({id:this.safeString(e,"id"),clientOrderId:this.safeString(e,"client_order_id"),timestamp:u,datetime:c,lastTradeTimeStamp:void 0,status:r,symbol:i,type:d,timeInForce:this.parseTimeInForce(this.safeString(e,"time_in_force")),postOnly:void 0,side:this.safeString(e,"side"),price:this.safeNumber(e,"limit_price"),stopPrice:this.safeNumber(e,"stop_price"),cost:void 0,average:this.safeNumber(e,"filled_avg_price"),amount:this.safeNumber(e,"qty"),filled:this.safeNumber(e,"filled_qty"),remaining:void 0,trades:void 0,fee:o,info:e},t)}parseOrderStatus(e){const t={pending_new:"open",accepted:"open",new:"open",partially_filled:"open",activated:"open",filled:"closed"};return this.safeString(t,e,e)}parseTimeInForce(e){const t={day:"Day"};return this.safeString(t,e,e)}parseTrade(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeString(e,"t"),n=this.parse8601(i),r=this.safeString(e,"tks");let a;r==="B"?a="buy":r==="S"&&(a="sell");const o=this.safeString(e,"p"),d=this.safeString(e,"s");return this.safeTrade({info:e,id:this.safeString(e,"i"),timestamp:n,datetime:this.iso8601(n),symbol:s,order:void 0,type:void 0,side:a,takerOrMaker:"taker",price:o,amount:d,cost:void 0,fee:void 0},t)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.safeValue(this.options,"versions"),o=this.safeString(a,t);let d="/"+this.implodeParams(e,i),c=this.implodeParams(this.urls.api[t],{version:o});c=this.implodeHostname(c),n=n!==void 0?n:{},t==="private"&&(n["APCA-API-KEY-ID"]=this.apiKey,n["APCA-API-SECRET-KEY"]=this.secret);const u=this.omit(i,this.extractParams(e));return Object.keys(u).length&&(s==="GET"||s==="DELETE"?d+="?"+this.urlencode(u):(r=this.json(u),n["Content-Type"]="application/json")),c=c+d,{url:c,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.id+" "+r,u=this.safeString(a,"code");e!==void 0&&this.throwExactlyMatchedException(this.exceptions.exact,u,c);const h=this.safeValue(a,"message",void 0);if(h!==void 0)throw this.throwExactlyMatchedException(this.exceptions.exact,h,c),this.throwBroadlyMatchedException(this.exceptions.broad,h,c),new Hq(c)}};const Kq=ge,{ArgumentsRequired:km,AuthenticationError:ff,ExchangeError:Ks,InsufficientFunds:Sm,InvalidOrder:Ss,BadSymbol:Ma,PermissionDenied:sk,BadRequest:ni}=de,{TICK_SIZE:Xq}=me,ik=Se;var B_=class extends Kq{describe(){return this.deepExtend(super.describe(),{id:"ascendex",name:"AscendEX",countries:["SG"],rateLimit:400,certified:!1,pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!0,option:!1,addMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:"emulated",fetchFundingRateHistory:!1,fetchFundingRates:!0,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!0,fetchMarginMode:!1,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!1,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,reduceMargin:!0,setLeverage:!0,setMarginMode:!0,setPositionMode:!1,transfer:!0},timeframes:{"1m":"1","5m":"5","15m":"15","30m":"30","1h":"60","2h":"120","4h":"240","6h":"360","12h":"720","1d":"1d","1w":"1w","1M":"1m"},version:"v2",urls:{logo:"https://user-images.githubusercontent.com/1294454/112027508-47984600-8b48-11eb-9e17-d26459cc36c6.jpg",api:{rest:"https://ascendex.com"},test:{rest:"https://api-test.ascendex-sandbox.com"},www:"https://ascendex.com",doc:["https://ascendex.github.io/ascendex-pro-api/#ascendex-pro-api-documentation"],fees:"https://ascendex.com/en/feerate/transactionfee-traderate",referral:{url:"https://ascendex.com/en-us/register?inviteCode=EL6BXBQM",discount:.25}},api:{v1:{public:{get:{assets:1,products:1,ticker:1,"barhist/info":1,barhist:1,depth:1,trades:1,"cash/assets":1,"cash/products":1,"margin/assets":1,"margin/products":1,"futures/collateral":1,"futures/contracts":1,"futures/ref-px":1,"futures/market-data":1,"futures/funding-rates":1,"risk-limit-info":1,"exchange-info":1}},private:{get:{info:1,"wallet/transactions":1,"wallet/deposit/address":1,"data/balance/snapshot":1,"data/balance/history":1},accountCategory:{get:{balance:1,"order/open":1,"order/status":1,"order/hist/current":1,risk:1},post:{order:1,"order/batch":1},delete:{order:1,"order/all":1,"order/batch":1}},accountGroup:{get:{"cash/balance":1,"margin/balance":1,"margin/risk":1,"futures/collateral-balance":1,"futures/position":1,"futures/risk":1,"futures/funding-payments":1,"order/hist":1,"spot/fee":1},post:{transfer:1,"futures/transfer/deposit":1,"futures/transfer/withdraw":1}}}},v2:{public:{get:{assets:1,"futures/contract":1,"futures/collateral":1,"futures/pricing-data":1,"futures/ticker":1}},private:{get:{"account/info":1},accountGroup:{get:{"order/hist":1,"futures/position":1,"futures/free-margin":1,"futures/order/hist/current":1,"futures/order/open":1,"futures/order/status":1},post:{"futures/isolated-position-margin":1,"futures/margin-type":1,"futures/leverage":1,"futures/transfer/deposit":1,"futures/transfer/withdraw":1,"futures/order":1,"futures/order/batch":1,"futures/order/open":1,"subuser/subuser-transfer":1,"subuser/subuser-transfer-hist":1},delete:{"futures/order":1,"futures/order/batch":1,"futures/order/all":1}}}}},fees:{trading:{feeSide:"get",tierBased:!0,percentage:!0,taker:this.parseNumber("0.002"),maker:this.parseNumber("0.002")}},precisionMode:Xq,options:{"account-category":"cash","account-group":void 0,fetchClosedOrders:{method:"v1PrivateAccountGroupGetOrderHist"},defaultType:"spot",accountsByType:{spot:"cash",swap:"futures",future:"futures",margin:"margin"},transfer:{fillResponseFromRequest:!0}},exceptions:{exact:{1900:ni,2100:ff,5002:Ma,6001:Ma,6010:Sm,60060:Ss,600503:Ss,100001:ni,100002:ni,100003:ni,100004:ni,100005:ni,100006:ni,100007:ni,100008:Ma,100009:ff,100010:ni,100011:ni,100012:ni,100013:ni,100101:Ks,150001:ni,200001:ff,200002:Ks,200003:Ks,200004:Ks,200005:Ks,200006:Ks,200007:Ks,200008:Ks,200009:Ks,200010:ff,200011:Ks,200012:Ks,200013:Ks,200014:sk,200015:sk,300001:Ss,300002:Ss,300003:Ss,300004:Ss,300005:Ss,300006:Ss,300007:Ss,300008:Ss,300009:Ss,300011:Sm,300012:Ma,300013:Ss,300014:Ss,300020:Ss,300021:Ss,300031:Ss,310001:Sm,310002:Ss,310003:Ss,310004:Ma,310005:Ss,510001:Ks,900001:Ks},broad:{}},commonCurrencies:{BOND:"BONDED",BTCBEAR:"BEAR",BTCBULL:"BULL",BYN:"BeyondFi",PLN:"Pollen"}})}getAccount(e={}){const s=this.safeValue(e,"account",this.options.account).toLowerCase();return this.capitalize(s)}async fetchCurrencies(e={}){const t=await this.v1PublicGetAssets(e),s=await this.v1PublicGetMarginAssets(e),i=await this.v1PublicGetCashAssets(e),n=this.safeValue(t,"data",[]),r=this.safeValue(s,"data",[]),a=this.safeValue(i,"data",[]),o=this.indexBy(n,"assetCode"),d=this.indexBy(r,"assetCode"),c=this.indexBy(a,"assetCode"),u=this.deepExtend(o,d,c),h=Object.keys(u),l={};for(let p=0;p<h.length;p++){const m=h[p],g=u[m],y=this.safeCurrencyCode(m),b=this.safeString2(g,"precisionScale","nativeScale"),w=this.parseNumber(this.parsePrecision(b)),k=this.safeNumber2(g,"withdrawFee","withdrawalFee"),O=this.safeString2(g,"status","statusCode")==="Normal",x="borrowAssetCode"in g;l[y]={id:m,code:y,info:g,type:void 0,margin:x,name:this.safeString(g,"assetName"),active:O,deposit:void 0,withdraw:void 0,fee:k,precision:w,limits:{amount:{min:w,max:void 0},withdraw:{min:this.safeNumber(g,"minWithdrawalAmt"),max:void 0}}}}return l}async fetchMarkets(e={}){const t=await this.v1PublicGetProducts(e),s=await this.v1PublicGetCashProducts(e),i=await this.v2PublicGetFuturesContract(e),n=this.safeValue(t,"data",[]),r=this.indexBy(n,"symbol"),a=this.safeValue(s,"data",[]),o=this.safeValue(i,"data",[]),d=this.arrayConcat(a,o),c=this.indexBy(d,"symbol"),u=this.deepExtend(r,c),h=Object.keys(u),l=[];for(let p=0;p<h.length;p++){const m=h[p],g=u[m];let y=this.safeString(g,"baseAsset"),b=this.safeString(g,"quoteAsset");const w=this.safeValue(g,"settlementAsset");let k=this.safeCurrencyCode(y),T=this.safeCurrencyCode(b);const O=this.safeCurrencyCode(w),x=this.safeString(g,"status"),C=this.safeString(g,"domain");let E=!1;(x==="Normal"||x==="InternalTrading")&&C!=="LeveragedETF"&&(E=!0);const P=O===void 0,_=!P,S=_?!0:void 0;let I=this.safeNumber(g,"minQty"),v=this.safeNumber(g,"maxQty"),N=this.safeNumber(g,"tickSize"),q,R=k+"/"+T;if(_){const A=this.safeValue(g,"lotSizeFilter");I=this.safeNumber(A,"minQty"),v=this.safeNumber(A,"maxQty");const V=this.safeValue(g,"priceFilter");N=this.safeNumber(V,"minPrice"),q=this.safeNumber(V,"maxPrice");const J=this.safeString(g,"underlying").split("/");y=this.safeString(J,0),b=this.safeString(J,1),k=this.safeCurrencyCode(y),T=this.safeCurrencyCode(b),R=k+"/"+T+":"+O}const G=this.safeNumber(g,"commissionReserveRate"),F=this.safeValue(g,"marginTradable",!1);l.push({id:m,symbol:R,base:k,quote:T,settle:O,baseId:y,quoteId:b,settleId:w,type:_?"swap":"spot",spot:P,margin:P?F:void 0,swap:_,future:!1,option:!1,active:E,contract:_,linear:S,inverse:_?!S:void 0,taker:G,maker:G,contractSize:_?this.parseNumber("1"):void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(g,"lotSize"),price:this.safeNumber(g,"tickSize")},limits:{leverage:{min:void 0,max:void 0},amount:{min:I,max:v},price:{min:N,max:q},cost:{min:this.safeNumber(g,"minNotional"),max:this.safeNumber(g,"maxNotional")}},info:g})}return l}async fetchTime(e={}){const t={requestTime:this.milliseconds()},s=await this.v1PublicGetExchangeInfo(this.extend(t,e)),i=this.safeValue(s,"data");return this.safeInteger(i,"requestReceiveAt")}async fetchAccounts(e={}){let t=this.safeString(this.options,"account-group"),s;if(t===void 0){s=await this.v1PrivateGetInfo(e);const i=this.safeValue(s,"data",{});t=this.safeString(i,"accountGroup"),this.options["account-group"]=t}return[{id:t,type:void 0,currency:void 0,info:s}]}parseBalance(e){const t=this.milliseconds(),s={info:e,timestamp:t,datetime:this.iso8601(t)},i=this.safeValue(e,"data",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeCurrencyCode(this.safeString(r,"asset")),o=this.account();o.free=this.safeString(r,"availableBalance"),o.total=this.safeString(r,"totalBalance"),s[a]=o}return this.safeBalance(s)}parseSwapBalance(e){const t=this.milliseconds(),s={info:e,timestamp:t,datetime:this.iso8601(t)},i=this.safeValue(e,"data",{}),n=this.safeValue(i,"collaterals",[]);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeCurrencyCode(this.safeString(a,"asset")),d=this.account();d.total=this.safeString(a,"balance"),s[o]=d}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets(),await this.loadAccounts();const[t,s]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),i=this.safeValue(this.options,"fetchBalance",{}),n=this.safeValue(this.options,"accountsByType",{}),r=this.safeString(n,t,"cash"),a=this.safeValue(this.accounts,0,{}),d={"account-group":this.safeString(a,"id")},c=this.safeString(i,"method","v1PrivateAccountCategoryGetBalance"),u=this.getSupportedMapping(t,{spot:c,margin:c,swap:"v2PrivateAccountGroupGetFuturesPosition"});(r==="cash"||r==="margin")&&(d["account-category"]=r);const h=await this[u](this.extend(d,s));return t==="swap"?this.parseSwapBalance(h):this.parseBalance(h)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={symbol:this.market(e).id},r=await this.v1PublicGetDepth(this.extend(n,s)),a=this.safeValue(r,"data",{}),o=this.safeValue(a,"data",{}),d=this.safeInteger(o,"ts"),c=this.parseOrderBook(o,e,d);return c.nonce=this.safeInteger(o,"seqnum"),c}parseTicker(e,t=void 0){const i=this.safeString(e,"symbol"),r=this.safeString(e,"type")==="spot"?"/":void 0,a=this.safeSymbol(i,t,r),o=this.safeString(e,"close"),d=this.safeValue(e,"bid",[]),c=this.safeValue(e,"ask",[]),u=this.safeString(e,"open");return this.safeTicker({symbol:a,timestamp:void 0,datetime:void 0,high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(d,0),bidVolume:this.safeString(d,1),ask:this.safeString(c,0),askVolume:this.safeString(c,1),vwap:void 0,open:u,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.v1PublicGetTicker(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};let i;if(e!==void 0){const o=this.safeValue(e,0);i=this.market(o);const d=this.marketIds(e);s.symbol=d.join(",")}let n;[n,t]=this.handleMarketTypeAndParams("fetchTickers",i,t);let r;n==="spot"?r=await this.v1PublicGetTicker(this.extend(s,t)):r=await this.v2PublicGetFuturesTicker(this.extend(s,t));const a=this.safeValue(r,"data",[]);return Array.isArray(a)?this.parseTickers(a,e):this.parseTickers([a],e)}parseOHLCV(e,t=void 0){const s=this.safeValue(e,"data",{});return[this.safeInteger(s,"ts"),this.safeNumber(s,"o"),this.safeNumber(s,"h"),this.safeNumber(s,"l"),this.safeNumber(s,"c"),this.safeNumber(s,"v")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,interval:this.timeframes[t]},o=this.parseTimeframe(t),d=this.safeValue(this.options,"fetchOHLCV",{}),c=this.safeInteger(d,"limit",500);s!==void 0?(a.from=s,i===void 0?i=c:i=Math.min(i,c),a.to=this.sum(s,i*o*1e3,1)):i!==void 0&&(a.n=i);const u=await this.v1PublicGetBarhist(this.extend(a,n)),h=this.safeValue(u,"data",[]);return this.parseOHLCVs(h,r,t,s,i)}parseTrade(e,t=void 0){const s=this.safeInteger(e,"ts"),i=this.safeString2(e,"price","p"),n=this.safeString(e,"q"),r=this.safeValue(e,"bm",!1),a=r?"maker":"taker",o=r?"buy":"sell";return t=this.safeMarket(void 0,t),this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,id:void 0,order:void 0,type:void 0,takerOrMaker:a,side:o,price:i,amount:n,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.n=s);const a=await this.v1PublicGetTrades(this.extend(r,i)),o=this.safeValue(a,"data",[]),d=this.safeValue(o,"data",[]);return this.parseTrades(d,n,t,s)}parseOrderStatus(e){const t={PendingNew:"open",New:"open",PartiallyFilled:"open",Filled:"closed",Canceled:"canceled",Rejected:"rejected"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString(e,"status")),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t,"/");let r=this.safeInteger2(e,"timestamp","sendingTime");const a=this.safeInteger(e,"lastExecTime");r===void 0&&(r=a);const o=this.safeString(e,"price"),d=this.safeString(e,"orderQty"),c=this.safeString(e,"avgPx"),u=this.safeString2(e,"cumFilledQty","cumQty"),h=this.safeString(e,"orderId");let l=this.safeString(e,"id");l!==void 0&&l.length<1&&(l=void 0);const p=this.safeStringLower(e,"orderType");let m=p;p!==void 0&&(p==="stoplimit"&&(m="limit"),p==="stopmarket"&&(m="market"));const g=this.safeStringLower(e,"side"),y=this.safeNumber(e,"cumFee");let b;if(y!==void 0){const x=this.safeString(e,"feeAsset"),C=this.safeCurrencyCode(x);b={cost:y,currency:C}}const w=this.safeNumber(e,"stopPrice");let k;const T=this.safeString(e,"execInst");T==="reduceOnly"&&(k=!0);let O;return T==="Post"&&(O=!0),this.safeOrder({info:e,id:h,clientOrderId:l,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:a,symbol:n,type:m,timeInForce:void 0,postOnly:O,reduceOnly:k,side:g,price:o,stopPrice:w,amount:d,cost:void 0,average:c,filled:u,remaining:void 0,status:s,fee:b,trades:void 0},t)}async fetchTradingFees(e={}){await this.loadMarkets(),await this.loadAccounts();const t=this.safeValue(this.accounts,0,{}),i={"account-group":this.safeString(t,"id")},n=await this.v1PrivateAccountGroupGetSpotFee(this.extend(i,e)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"fees",[]),o={};for(let d=0;d<a.length;d++){const c=a[d],u=this.safeString(c,"symbol"),h=this.safeSymbol(u,void 0,"/"),l=this.safeValue(c,"fee",{});o[h]={info:c,symbol:h,maker:this.safeNumber(l,"maker"),taker:this.safeNumber(l,"taker")}}return o}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets(),await this.loadAccounts();const a=this.market(e);let o;[o,r]=this.handleMarketTypeAndParams("createOrder",a,r);const d=this.safeValue(this.options,"createOrder",{}),c=this.safeValue(this.options,"accountsByType",{}),u=this.safeString(c,o,"cash"),h=this.safeValue(this.accounts,0,{}),l=this.safeValue(h,"id"),p=this.safeString2(r,"clientOrderId","id"),m={"account-group":l,"account-category":u,symbol:a.id,time:this.milliseconds(),orderQty:this.amountToPrecision(e,i),orderType:t,side:s},g=t==="market"||t==="stop_market",y=t==="limit"||t==="stop_limit",b=this.safeString(r,"timeInForce"),w=this.isPostOnly(g,!1,r),k=this.safeValue(r,"reduceOnly",!1),T=this.safeValue2(r,"triggerPrice","stopPrice");if(r=this.omit(r,["timeInForce","postOnly","reduceOnly","stopPrice","triggerPrice"]),k){if(o!=="swap")throw new Ss(this.id+" createOrder() does not support reduceOnly for "+o+" orders, reduceOnly orders are supported for perpetuals only");m.execInst="ReduceOnly"}y&&(m.orderPrice=this.priceToPrecision(e,n)),b==="IOC"&&(m.timeInForce="IOC"),b==="FOK"&&(m.timeInForce="FOK"),w&&(m.postOnly=!0),T!==void 0&&(m.stopPrice=this.priceToPrecision(e,T),y?m.orderType="stop_limit":g&&(m.orderType="stop_market")),p!==void 0&&(m.id=p);const O=this.safeString(d,"method","v1PrivateAccountCategoryPostOrder"),x=this.getSupportedMapping(o,{spot:O,margin:O,swap:"v2PrivateAccountGroupPostFuturesOrder"});x==="v1PrivateAccountCategoryPostOrder"?u!==void 0&&(m.category=u):m["account-category"]=u;const C=await this[x](this.extend(m,r)),E=this.safeValue(C,"data",{}),P=this.safeValue2(E,"order","info",{});return this.parseOrder(P,a)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets(),await this.loadAccounts();let i;t!==void 0&&(i=this.market(t));const[n,r]=this.handleMarketTypeAndParams("fetchOrder",i,s),a=this.safeValue(this.options,"fetchOrder",{}),o=this.safeValue(this.options,"accountsByType",{}),d=this.safeString(o,n,"cash"),c=this.safeValue(this.accounts,0,{}),h={"account-group":this.safeValue(c,"id"),"account-category":d,orderId:e},l=this.safeString(a,"method","v1PrivateAccountCategoryGetOrderStatus"),p=this.getSupportedMapping(n,{spot:l,margin:l,swap:"v2PrivateAccountGroupGetFuturesOrderStatus"});p==="v1PrivateAccountCategoryGetOrderStatus"?d!==void 0&&(h.category=d):h["account-category"]=d;const m=await this[p](this.extend(h,r)),g=this.safeValue(m,"data",{});return this.parseOrder(g,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.loadAccounts();let n;e!==void 0&&(n=this.market(e),e=n.symbol);const r=this.safeValue(this.accounts,0,{}),a=this.safeValue(r,"id"),[o,d]=this.handleMarketTypeAndParams("fetchOpenOrders",n,i),c=this.safeValue(this.options,"accountsByType",{}),u=this.safeString(c,o,"cash"),h={"account-group":a,"account-category":u},l=this.safeValue(this.options,"fetchOpenOrders",{}),p=this.safeString(l,"method","v1PrivateAccountCategoryGetOrderOpen"),m=this.getSupportedMapping(o,{spot:p,margin:p,swap:"v2PrivateAccountGroupGetFuturesOrderOpen"});m==="v1PrivateAccountCategoryGetOrderOpen"?u!==void 0&&(h.category=u):h["account-category"]=u;const g=await this[m](this.extend(h,d)),y=this.safeValue(g,"data",[]);if(u==="futures")return this.parseOrders(y,n,t,s);const b=[];for(let w=0;w<y.length;w++){const k=this.parseOrder(y[w],n);b.push(k)}return this.filterBySymbolSinceLimit(b,e,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.loadAccounts();const n=this.safeValue(this.accounts,0,{}),a={"account-group":this.safeValue(n,"id")};let o;e!==void 0&&(o=this.market(e),a.symbol=o.id);const[d,c]=this.handleMarketTypeAndParams("fetchClosedOrders",o,i),u=this.safeValue(this.options,"fetchClosedOrders",{}),h=this.safeString(u,"method","v1PrivateAccountGroupGetOrderHist"),l=this.getSupportedMapping(d,{spot:h,margin:h,swap:"v2PrivateAccountGroupGetFuturesOrderHistCurrent"}),p=this.safeValue(this.options,"accountsByType",{}),m=this.safeString(p,d,"cash");l==="v1PrivateAccountGroupGetOrderHist"?m!==void 0&&(a.category=m):a["account-category"]=m,t!==void 0&&(a.startTime=t),s!==void 0&&(a.pageSize=s);const g=await this[l](this.extend(a,c));let y=this.safeValue(g,"data");return Array.isArray(y)||(y=this.safeValue(y,"data",[])),this.parseOrders(y,o,t,s)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new km(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets(),await this.loadAccounts();const i=this.market(t),[n,r]=this.handleMarketTypeAndParams("cancelOrder",i,s),a=this.safeValue(this.options,"cancelOrder",{}),o=this.safeValue(this.options,"accountsByType",{}),d=this.safeString(o,n,"cash"),c=this.safeValue(this.accounts,0,{}),h={"account-group":this.safeValue(c,"id"),"account-category":d,symbol:i.id,time:this.milliseconds(),id:"foobar"},l=this.safeString(a,"method","v1PrivateAccountCategoryDeleteOrder"),p=this.getSupportedMapping(n,{spot:l,margin:l,swap:"v2PrivateAccountGroupDeleteFuturesOrder"});p==="v1PrivateAccountCategoryDeleteOrder"?d!==void 0&&(h.category=d):h["account-category"]=d;const m=this.safeString2(s,"clientOrderId","id");m===void 0?h.orderId=e:(h.id=m,s=this.omit(s,["clientOrderId","id"]));const g=await this[p](this.extend(h,r)),y=this.safeValue(g,"data",{}),b=this.safeValue2(y,"order","info",{});return this.parseOrder(b,i)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets(),await this.loadAccounts();let s;e!==void 0&&(s=this.market(e));const[i,n]=this.handleMarketTypeAndParams("cancelAllOrders",s,t),r=this.safeValue(this.options,"cancelAllOrders",{}),a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,i,"cash"),d=this.safeValue(this.accounts,0,{}),u={"account-group":this.safeValue(d,"id"),"account-category":o,time:this.milliseconds()};e!==void 0&&(u.symbol=s.id);const h=this.safeString(r,"method","v1PrivateAccountCategoryDeleteOrderAll"),l=this.getSupportedMapping(i,{spot:h,margin:h,swap:"v2PrivateAccountGroupDeleteFuturesOrderAll"});return l==="v1PrivateAccountCategoryDeleteOrderAll"?o!==void 0&&(u.category=o):u["account-category"]=o,await this[l](this.extend(u,n))}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"tagId"),n=this.safeString(e,i);this.checkAddress(s);const r=t===void 0?void 0:t.code,a=this.safeString(e,"chainName"),o=this.safeNetwork(a);return{currency:r,address:s,tag:n,network:o,info:e}}safeNetwork(e){const t={TRC20:"TRC20",ERC20:"ERC20",GO20:"GO20",BEP2:"BEP2","BEP20 (BSC)":"BEP20",Bitcoin:"BTC","Bitcoin ABC":"BCH",Litecoin:"LTC","Matic Network":"MATIC",Solana:"SOL",xDai:"STAKE",Akash:"AKT"};return this.safeString(t,e,e)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i=this.safeString(t,"chainName");t=this.omit(t,"chainName");const n={asset:s.id},r=await this.v1PrivateGetWalletDepositAddress(this.extend(n,t)),a=this.safeValue(r,"data",{}),o=this.safeValue(a,"address",[]),d=o.length;let c;if(d>1){const h=this.indexBy(o,"chainName");if(i===void 0){const p=Object.keys(h).join(", ");throw new km(this.id+" fetchDepositAddress() returned more than one address, a chainName parameter is required, one of "+p)}c=this.safeValue(h,i,{})}else c=this.safeValue(o,0,{});const u=this.parseDepositAddress(c,s);return this.extend(u,{info:r})}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){const n={txType:"deposit"};return await this.fetchTransactions(e,t,s,this.extend(n,i))}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const n={txType:"withdrawal"};return await this.fetchTransactions(e,t,s,this.extend(n,i))}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.asset=r.id),t!==void 0&&(n.startTs=t),s!==void 0&&(n.pageSize=s);const a=await this.v1PrivateGetWalletTransactions(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"data",[]);return this.parseTransactions(d,r,t,s)}parseTransactionStatus(e){const t={reviewing:"pending",pending:"pending",confirmed:"ok",rejected:"rejected"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"requestId"),i=this.safeNumber(e,"amount"),n=this.safeValue(e,"destAddress",{}),r=this.safeString(n,"address"),a=this.safeString(n,"destTag"),o=this.safeString(e,"networkTransactionId"),d=this.safeString(e,"transactionType"),c=this.safeInteger(e,"time"),u=this.safeString(e,"asset"),h=this.safeCurrencyCode(u,t),l=this.parseTransactionStatus(this.safeString(e,"status")),p=this.safeNumber(e,"commission");return{info:e,id:s,currency:h,amount:i,network:void 0,address:r,addressTo:r,addressFrom:void 0,tag:a,tagTo:a,tagFrom:void 0,status:l,type:d,updated:void 0,txid:o,timestamp:c,datetime:this.iso8601(c),fee:{currency:h,cost:p}}}async fetchPositions(e=void 0,t={}){await this.loadMarkets(),await this.loadAccounts();const s=this.safeValue(this.accounts,0,{}),n={"account-group":this.safeString(s,"id")},r=await this.v2PrivateAccountGroupGetFuturesPosition(this.extend(n,t)),a=this.safeValue(r,"data",{}),o=this.safeValue(a,"contracts",[]),d=[];for(let c=0;c<o.length;c++)d.push(this.parsePosition(o[c]));return e=this.marketSymbols(e),this.filterByArray(d,"symbol",e,!1)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);let i=this.safeNumber(e,"buyOpenOrderNotional");i===0&&(i=this.safeNumber(e,"sellOpenOrderNotional"));const n=this.safeString(e,"marginType");let r;return n==="isolated"&&(r=this.safeNumber(e,"isolatedMargin")),{info:e,id:void 0,symbol:t.symbol,notional:i,marginMode:n,liquidationPrice:void 0,entryPrice:this.safeNumber(e,"avgOpenPrice"),unrealizedPnl:this.safeNumber(e,"unrealizedPnl"),percentage:void 0,contracts:this.safeNumber(e,"position"),contractSize:this.safeNumber(t,"contractSize"),markPrice:this.safeNumber(e,"markPrice"),side:this.safeStringLower(e,"side"),hedged:void 0,timestamp:void 0,datetime:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,collateral:r,initialMargin:void 0,initialMarginPercentage:void 0,leverage:this.safeInteger(e,"leverage"),marginRatio:void 0}}parseFundingRate(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeInteger(e,"time"),r=this.safeNumber(e,"fundingRate"),a=this.safeInteger(e,"nextFundingTime");return{info:e,symbol:i,markPrice:this.safeNumber(e,"markPrice"),indexPrice:this.safeNumber(e,"indexPrice"),interestRate:this.parseNumber("0"),estimatedSettlePrice:void 0,timestamp:n,datetime:this.iso8601(n),previousFundingRate:void 0,nextFundingRate:void 0,previousFundingTimestamp:void 0,nextFundingTimestamp:void 0,previousFundingDatetime:void 0,nextFundingDatetime:void 0,fundingRate:r,fundingTimestamp:a,fundingDatetime:this.iso8601(a)}}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.v2PublicGetFuturesPricingData(t),i=this.safeValue(s,"data",{}),n=this.safeValue(i,"contracts",[]),r=this.parseFundingRates(n);return this.filterByArray(r,"symbol",e)}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets(),await this.loadAccounts();const n=this.market(e),r=this.safeValue(this.accounts,0,{}),a=this.safeString(r,"id");t=this.amountToPrecision(e,t);const o={"account-group":a,symbol:n.id,amount:t},d=await this.v2PrivateAccountGroupPostFuturesIsolatedPositionMargin(this.extend(o,i));return s==="reduce"&&(t=ik.stringAbs(t)),this.extend(this.parseMarginModification(d,n),{amount:this.parseNumber(t),type:s})}parseMarginModification(e,t=void 0){const i=this.safeString(e,"code")==="0"?"ok":"failed";return{info:e,type:void 0,amount:void 0,code:t.quote,symbol:t.symbol,status:i}}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"reduce",s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"add",s)}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new km(this.id+" setLeverage() requires a symbol argument");if(e<1||e>100)throw new ni(this.id+" leverage should be between 1 and 100");await this.loadMarkets(),await this.loadAccounts();const i=this.market(t);if(i.type!=="future")throw new Ma(this.id+" setLeverage() supports futures contracts only");const n=this.safeValue(this.accounts,0,{}),a={"account-group":this.safeString(n,"id"),symbol:i.id,leverage:e};return await this.v2PrivateAccountGroupPostFuturesLeverage(this.extend(a,s))}async setMarginMode(e,t=void 0,s={}){if(e=e.toLowerCase(),e==="cross"&&(e="crossed"),e!=="isolated"&&e!=="crossed")throw new ni(this.id+" setMarginMode() marginMode argument should be isolated or cross");await this.loadMarkets(),await this.loadAccounts();const i=this.market(t),n=this.safeValue(this.accounts,0,{}),a={"account-group":this.safeString(n,"id"),symbol:i.id,marginMode:e};if(i.type!=="future")throw new Ma(this.id+" setMarginMode() supports futures contracts only");return await this.v2PrivateAccountGroupPostFuturesMarginType(this.extend(a,s))}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const s=await this.v2PublicGetFuturesContract(t),i=this.safeValue(s,"data");return e=this.marketSymbols(e),this.parseLeverageTiers(i,e,"symbol")}parseMarketLeverageTiers(e,t=void 0){const s=this.safeValue(e,"marginRequirements",[]),i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const n=[];for(let r=0;r<s.length;r++){const a=s[r],o=this.safeString(a,"initialMarginRate");n.push({tier:this.sum(r,1),currency:t.quote,minNotional:this.safeNumber(a,"positionNotionalLowerBound"),maxNotional:this.safeNumber(a,"positionNotionalUpperBound"),maintenanceMarginRate:this.safeNumber(a,"maintenanceMarginRate"),maxLeverage:this.parseNumber(ik.stringDiv("1",o)),info:a})}return n}async transfer(e,t,s,i,n={}){await this.loadMarkets(),await this.loadAccounts();const r=this.safeValue(this.accounts,0,{}),a=this.safeString(r,"id"),o=this.currency(e);t=this.currencyToPrecision(e,t);const d=this.safeValue(this.options,"accountsByType",{}),c=this.safeString(d,s,s),u=this.safeString(d,i,i);if(c!=="cash"&&u!=="cash")throw new Ks(this.id+" transfer() only supports direct balance transfer between spot and future, spot and margin");const h={"account-group":a,amount:t,asset:o.id,fromAccount:c,toAccount:u},l=await this.v1PrivateAccountGroupPostTransfer(this.extend(h,n)),p=this.safeValue(this.options,"transfer",{}),m=this.safeValue(p,"fillResponseFromRequest",!0),g=this.parseTransfer(l,o);return m&&(g.fromAccount=s,g.toAccount=i,g.amount=t,g.currency=e),g}parseTransfer(e,t=void 0){const s=this.safeInteger(e,"code"),i=this.safeCurrencyCode(void 0,t),n=this.milliseconds();return{info:e,id:void 0,timestamp:n,datetime:this.iso8601(n),currency:i,amount:void 0,fromAccount:void 0,toAccount:void 0,status:this.parseTransferStatus(s)}}parseTransferStatus(e){return e===0?"ok":"failed"}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=t[0],o=t[1],d=this.safeString(t,2);let c="";const u=d==="accountCategory";(u||d==="accountGroup")&&(c+=this.implodeParams("/{account-group}",i),i=this.omit(i,"account-group"));let h=this.implodeParams(e,i);if(c+="/api/pro/",a==="v2"?h=a+"/"+h:c+=a+"/",u&&(c+=this.implodeParams("{account-category}/",i)),i=this.omit(i,"account-category"),c+=h,(a==="v1"&&h==="cash/balance"||h==="margin/balance")&&(h="balance"),a==="v1"&&h==="spot/fee"&&(h="fee"),h.indexOf("subuser")>=0&&(h=h.split("/")[2]),i=this.omit(i,this.extractParams(e)),o==="public")Object.keys(i).length&&(c+="?"+this.urlencode(i));else{this.checkRequiredCredentials();const l=this.milliseconds().toString(),p=l+"+"+h,m=this.hmac(this.encode(p),this.encode(this.secret),"sha256","base64");n={"x-auth-key":this.apiKey,"x-auth-timestamp":l,"x-auth-signature":m},s==="GET"?Object.keys(i).length&&(c+="?"+this.urlencode(i)):(n["Content-Type"]="application/json",r=this.json(i))}return c=this.urls.api.rest+c,{url:c,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"code"),u=this.safeString(a,"message");if(c!==void 0&&c!=="0"||u!==void 0){const l=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,l),this.throwExactlyMatchedException(this.exceptions.exact,u,l),this.throwBroadlyMatchedException(this.exceptions.broad,u,l),new Ks(l)}}};const Yq=ge,{BadSymbol:nk,PermissionDenied:Qq,ExchangeError:Zd,ExchangeNotAvailable:Zq,OrderNotFound:vm,InsufficientFunds:Jq,InvalidOrder:xo,RequestTimeout:e4,AuthenticationError:t4}=de,{TRUNCATE:s4,TICK_SIZE:rk}=me,i4=Se;var $l=class extends Yq{describe(){return this.deepExtend(super.describe(),{id:"hitbtc",name:"HitBTC",countries:["HK"],rateLimit:3.333,version:"2",pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,createReduceOnlyOrder:!1,editOrder:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:void 0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:void 0,fetchOrderTrades:!0,fetchPosition:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactions:!0,fetchWithdrawals:void 0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"M1","3m":"M3","5m":"M5","15m":"M15","30m":"M30","1h":"H1","4h":"H4","1d":"D1","1w":"D7","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766555-8eaec20e-5edc-11e7-9c5b-6dc69fc42f5e.jpg",test:{public:"https://api.demo.hitbtc.com",private:"https://api.demo.hitbtc.com"},api:{public:"https://api.hitbtc.com",private:"https://api.hitbtc.com"},www:"https://hitbtc.com",referral:"https://hitbtc.com/?ref_id=5a5d39a65d466",doc:["https://api.hitbtc.com/v2"],fees:["https://hitbtc.com/fees-and-limits","https://support.hitbtc.com/hc/en-us/articles/115005148605-Fees-and-limits"]},api:{public:{get:{currency:3,"currency/{currency}":3,symbol:3,"symbol/{symbol}":3,ticker:3,"ticker/{symbol}":3,trades:3,"trades/{symbol}":3,orderbook:3,"orderbook/{symbol}":3,candles:3,"candles/{symbol}":3}},private:{get:{"trading/balance":15.0015,order:15.0015,"order/{clientOrderId}":15.0015,"trading/fee/all":15.0015,"trading/fee/{symbol}":15.0015,"margin/account":15.0015,"margin/account/{symbol}":15.0015,"margin/position":15.0015,"margin/position/{symbol}":15.0015,"margin/order":15.0015,"margin/order/{clientOrderId}":15.0015,"history/order":15.0015,"history/trades":15.0015,"history/order/{orderId}/trades":15.0015,"account/balance":15.0015,"account/crypto/address/{currency}":15.0015,"account/crypto/addresses/{currency}":15.0015,"account/crypto/used-addresses/{currency}":15.0015,"account/crypto/estimate-withdraw":15.0015,"account/crypto/is-mine/{address}":15.0015,"account/transactions":15.0015,"account/transactions/{id}":15.0015,"sub-acc":15.0015,"sub-acc/acl":15.0015,"sub-acc/balance/{subAccountUserID}":15.0015,"sub-acc/deposit-address/{subAccountUserId}/{currency}":15.0015},post:{order:1,"margin/order":1,"account/crypto/address/{currency}":1,"account/crypto/withdraw":1,"account/crypto/transfer-convert":1,"account/transfer":1,"account/transfer/internal":1,"sub-acc/freeze":1,"sub-acc/activate":1,"sub-acc/transfer":1},put:{"order/{clientOrderId}":1,"margin/account/{symbol}":1,"margin/order/{clientOrderId}":1,"account/crypto/withdraw/{id}":1,"sub-acc/acl/{subAccountUserId}":1},delete:{order:1,"order/{clientOrderId}":1,"margin/account":1,"margin/account/{symbol}":1,"margin/position":1,"margin/position/{symbol}":1,"margin/order":1,"margin/order/{clientOrderId}":1,"account/crypto/withdraw/{id}":1},patch:{"order/{clientOrderId}":1}}},precisionMode:rk,fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.002")}},options:{networks:{ETH:"T20",ERC20:"T20",TRX:"TTRX",TRC20:"TTRX",OMNI:""},defaultTimeInForce:"FOK",accountsByType:{funding:"bank",spot:"exchange"},fetchBalanceMethod:{account:"account",bank:"account",main:"account",funding:"account",exchange:"trading",spot:"trading",trade:"trading",trading:"trading"}},commonCurrencies:{AUTO:"Cube",BCC:"BCC",BDP:"BidiPass",BET:"DAO.Casino",BIT:"BitRewards",BOX:"BOX Token",CPT:"Cryptaur",GET:"Themis",GMT:"GMT Token",HSR:"HC",IQ:"IQ.Cash",LNC:"LinkerCoin",PLA:"PlayChip",PNT:"Penta",SBTC:"Super Bitcoin",STEPN:"GMT",STX:"STOX",TV:"Tokenville",USD:"USDT",XMT:"MTL",XPNT:"PNT"},exceptions:{504:e4,1002:t4,1003:Qq,2010:xo,2001:nk,2011:xo,2020:xo,20002:vm,20001:Jq,20010:nk,20045:xo}})}feeToPrecision(e,t){return this.decimalToPrecision(t,s4,1e-8,rk)}async fetchMarkets(e={}){const t=await this.publicGetSymbol(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"id"),a=this.safeString(n,"baseCurrency"),o=this.safeString(n,"quoteCurrency"),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o);let u=d+"/"+c;r.indexOf("_")>=0&&(u=r);const h=this.safeString(n,"quantityIncrement"),l=this.safeString(n,"tickSize"),p=this.parseNumber(h),m=this.parseNumber(l),g=this.safeString(n,"feeCurrency");s.push(this.extend(this.fees.trading,{id:r,symbol:u,base:d,quote:c,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(n,"takeLiquidityRate"),maker:this.safeNumber(n,"provideLiquidityRate"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,feeCurrency:this.safeCurrencyCode(g),precision:{amount:p,price:m},limits:{leverage:{min:void 0,max:void 0},amount:{min:p,max:void 0},price:{min:m,max:void 0},cost:{min:this.parseNumber(i4.stringMul(h,l)),max:void 0}},info:n}))}return s}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.currencyToPrecision(e,t),o={currency:r.id,amount:a};let d=this.safeString(n,"type");if(d===void 0){const h=this.safeValue(this.options,"accountsByType",{}),l=this.safeString(h,s,s),p=this.safeString(h,i,i);if(l===p)throw new Zd(this.id+" transfer() from and to cannot be the same account");d=l+"To"+this.capitalize(p)}o.type=d;const c=await this.privatePostAccountTransfer(this.extend(o,n)),u=this.parseTransfer(c,r);return this.extend(u,{fromAccount:s,toAccount:i,amount:this.parseNumber(a)})}parseTransfer(e,t=void 0){const s=this.milliseconds();return{id:this.safeString(e,"id"),timestamp:s,datetime:this.iso8601(s),currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0,info:e}}async fetchCurrencies(e={}){const t=await this.publicGetCurrency(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"id"),a=this.safeString(n,"precisionTransfer","8"),o=this.safeCurrencyCode(r),d=this.safeValue(n,"payinEnabled"),c=this.safeValue(n,"payoutEnabled"),u=this.safeValue(n,"transferEnabled");let h=d&&c&&u;"disabled"in n&&n.disabled&&(h=!1);let l="fiat";"crypto"in n&&n.crypto&&(l="crypto");const p=this.safeString(n,"fullName");s[o]={id:r,code:o,type:l,payin:d,payout:c,transfer:u,info:n,name:p,active:h,deposit:d,withdraw:c,fee:this.safeNumber(n,"payoutFee"),precision:this.parseNumber(this.parsePrecision(a)),limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}}}return s}parseTradingFee(e,t=void 0){return{info:e,symbol:this.safeSymbol(void 0,t),maker:this.safeNumber(e,"provideLiquidityRate"),taker:this.safeNumber(e,"takeLiquidityRate"),percentage:!0,tierBased:!0}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.privateGetTradingFeeSymbol(i);return this.parseTradingFee(n,s)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"available"),a.used=this.safeString(i,"reserved"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"type","trading"),s=this.safeValue(this.options,"fetchBalanceMethod",{}),i=this.safeString(s,t);if(i===void 0)throw new Zd(this.id+" fetchBalance() account type must be either main or trading");const n="privateGet"+this.capitalize(i)+"Balance",r=this.omit(e,"type"),a=await this[n](r);return this.parseBalance(a)}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"timestamp")),this.safeNumber(e,"open"),this.safeNumber(e,"max"),this.safeNumber(e,"min"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,period:this.timeframes[t]};s!==void 0&&(a.from=this.iso8601(s)),i!==void 0&&(a.limit=i);const o=await this.publicGetCandlesSymbol(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetOrderbookSymbol(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"bid","ask","price","size")}parseTicker(e,t=void 0){const s=this.parse8601(e.timestamp),i=this.safeSymbol(void 0,t),n=this.safeString(e,"volume"),r=this.safeString(e,"volumeQuote"),a=this.safeString(e,"open"),o=this.safeString(e,"last");return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:a,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:n,quoteVolume:r,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTicker(t),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeMarket(a),d=o.symbol;i[d]=this.parseTicker(r,o)}return this.filterByArray(i,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetTickerSymbol(this.extend(i,t));if("message"in n)throw new Zd(this.id+" "+n.message);return this.parseTicker(n,s)}parseTrade(e,t=void 0){const s=this.parse8601(e.timestamp),i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const n=t.symbol;let r;const a=this.safeString(e,"fee");if(a!==void 0){const l=t?t.feeCurrency:void 0;r={cost:a,currency:l}}const o=this.safeString(e,"clientOrderId"),d=this.safeString(e,"price"),c=this.safeString(e,"quantity"),u=this.safeString(e,"side"),h=this.safeString(e,"id");return this.safeTrade({info:e,id:h,order:o,timestamp:s,datetime:this.iso8601(s),symbol:n,type:void 0,side:u,takerOrMaker:void 0,price:d,amount:c,cost:void 0,fee:r},t)}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.asset=n.id),t!==void 0&&(r.startTime=t);const a=await this.privateGetAccountTransactions(this.extend(r,i));return this.parseTransactions(a,n,t,s)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.parse8601(this.safeString(e,"createdAt")),n=this.parse8601(this.safeString(e,"updatedAt")),r=this.safeString(e,"currency"),a=this.safeCurrencyCode(r,t),o=this.parseTransactionStatus(this.safeString(e,"status")),d=this.safeNumber(e,"amount"),c=this.safeString(e,"address"),u=this.safeString(e,"hash");let h;const l=this.safeNumber(e,"fee");l!==void 0&&(h={cost:l,currency:a});const p=this.parseTransactionType(this.safeString(e,"type"));return{info:e,id:s,txid:u,timestamp:i,datetime:this.iso8601(i),network:void 0,address:c,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:p,amount:d,currency:a,status:o,updated:n,fee:h}}parseTransactionStatus(e){const t={pending:"pending",failed:"failed",success:"ok"};return this.safeString(t,e,e)}parseTransactionType(e){const t={payin:"deposit",payout:"withdrawal",withdraw:"withdrawal"};return this.safeString(t,e,e)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s),t!==void 0&&(r.sort="ASC",r.from=this.iso8601(t));const a=await this.publicGetTradesSymbol(this.extend(r,i));return this.parseTrades(a,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);let c=this.uuid().split("-").join("");c=c.slice(0,32),i=parseFloat(i);const u={clientOrderId:c,symbol:a.id,side:s,quantity:this.amountToPrecision(e,i),type:t};t==="limit"?u.price=this.priceToPrecision(e,n):u.timeInForce=this.options.defaultTimeInForce;const h=await this.privatePostOrder(this.extend(u,r)),l=this.parseOrder(h);if(l.status==="rejected")throw new xo(this.id+" order was rejected by the exchange "+this.json(l));return l}async editOrder(e,t,s,i,n=void 0,r=void 0,a={}){await this.loadMarkets();let c=this.uuid().split("-").join("");c=c.slice(0,32);const u={clientOrderId:e,requestClientId:c};n!==void 0&&(u.quantity=this.amountToPrecision(t,n)),r!==void 0&&(u.price=this.priceToPrecision(t,r));const h=await this.privatePatchOrderClientOrderId(this.extend(u,a));return this.parseOrder(h)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={clientOrderId:e},n=await this.privateDeleteOrderClientOrderId(this.extend(i,s));return this.parseOrder(n)}parseOrderStatus(e){const t={new:"open",suspended:"open",partiallyFilled:"open",filled:"closed",canceled:"canceled",expired:"failed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parse8601(this.safeString(e,"createdAt")),i=this.parse8601(this.safeString(e,"updatedAt")),n=this.safeString(e,"symbol");t=this.safeMarket(n,t);const r=t.symbol,a=this.safeString(e,"quantity"),o=this.safeString(e,"cumQuantity"),d=this.parseOrderStatus(this.safeString(e,"status")),c=this.safeString(e,"clientOrderId"),u=c,h=this.safeString(e,"price"),l=this.safeString(e,"type"),p=this.safeString(e,"side"),m=this.safeValue(e,"tradesReport"),g=void 0,y=this.safeString(e,"avgPrice"),b=this.safeString(e,"timeInForce");return this.safeOrder({id:c,clientOrderId:u,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:i,status:d,symbol:r,type:l,timeInForce:b,side:p,price:h,stopPrice:void 0,average:y,amount:a,cost:void 0,filled:o,remaining:void 0,fee:g,trades:m,info:e},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={clientOrderId:e},n=await this.privateGetHistoryOrder(this.extend(i,s));if(n.length>0)return this.parseOrder(n[0]);throw new vm(this.id+" order "+e+" not found")}async fetchOpenOrder(e,t=void 0,s={}){await this.loadMarkets();const i={clientOrderId:e},n=await this.privateGetOrderClientOrderId(this.extend(i,s));return this.parseOrder(n)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id);const a=await this.privateGetOrder(this.extend(r,i));return this.parseOrders(a,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),s!==void 0&&(r.limit=s),t!==void 0&&(r.from=this.iso8601(t));const a=await this.privateGetHistoryOrder(this.extend(r,i)),o=this.parseOrders(a,n),d=[];for(let c=0;c<o.length;c++){const u=o[c],h=u.status;(h==="closed"||h==="canceled")&&d.push(u)}return this.filterBySinceLimit(d,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),t!==void 0&&(n.from=this.iso8601(t)),s!==void 0&&(n.limit=s);const a=await this.privateGetHistoryTrades(this.extend(n,i));return this.parseTrades(a,r,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;t!==void 0&&(r=this.market(t));const a={orderId:e},o=await this.privateGetHistoryOrderOrderIdTrades(this.extend(a,n));if(o.length>0)return this.parseTrades(o,r,s,i);throw new vm(this.id+" order "+e+" not found, "+this.id+'.fetchOrderTrades() requires an exchange-specific order id, you need to grab it from order["info"]["id"]')}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=await this.privatePostAccountCryptoAddressCurrency(this.extend(i,t)),r=this.safeString(n,"address");this.checkAddress(r);const a=this.safeString(n,"paymentId");return{currency:s,address:r,tag:a,info:n}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=this.safeString(t,"network");if(n!==void 0){t=this.omit(t,"network");const d=this.safeValue(this.options,"networks"),c=this.safeString(d,n,n);i.currency+=c}const r=await this.privateGetAccountCryptoAddressCurrency(this.extend(i,t)),a=this.safeString(r,"address");this.checkAddress(a);const o=this.safeString(r,"paymentId");return{currency:s.code,address:a,tag:o,network:void 0,info:r}}async convertCurrencyNetwork(e,t,s,i,n){await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"networks",{});if(s=this.safeString(a,s,s),i=this.safeString(a,i,i),s===i)throw new Zd(this.id+" convertCurrencyNetwork() fromNetwork cannot be the same as toNetwork");const o={fromCurrency:r.id+s,toCurrency:r.id+i,amount:parseFloat(this.currencyToPrecision(e,t))};return{info:await this.privatePostAccountCryptoTransferConvert(this.extend(o,n))}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets(),this.checkAddress(s);const r=this.currency(e),a={currency:r.id,amount:parseFloat(t),address:s};i&&(a.paymentId=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeString(o,d,d),d!==void 0&&(a.currency+=d,n=this.omit(n,"network"));const c=await this.privatePostAccountCryptoWithdraw(this.extend(a,n));return this.parseTransaction(c,r)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/api/"+this.version+"/";const o=this.omit(i,this.extractParams(e));if(t==="public")a+=t+"/"+this.implodeParams(e,i),Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials(),a+=this.implodeParams(e,i),s==="GET"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):Object.keys(o).length&&(r=this.json(o));const d=this.encode(this.apiKey+":"+this.secret),c=this.stringToBase64(d);n={Authorization:"Basic "+this.decode(c),"Content-Type":"application/json"}}return a=this.urls.api[t]+a,{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&e>=400){const c=this.id+" "+r;if(e===503||e===504)throw new Zq(c);if(e===429)return;if(r[0]==="{"&&"error"in a){const u=this.safeString(a.error,"code");if(this.throwExactlyMatchedException(this.exceptions,u,c),this.safeString(a.error,"message")==="Duplicate clientOrderId")throw new xo(c)}throw new Zd(c)}}};const n4=$l;var r4=class extends n4{describe(){return this.deepExtend(super.describe(),{id:"bequant",name:"Bequant",countries:["MT"],pro:!0,urls:{logo:"https://user-images.githubusercontent.com/1294454/55248342-a75dfe00-525a-11e9-8aa2-05e9dca943c6.jpg",api:{public:"https://api.bequant.io",private:"https://api.bequant.io"},www:"https://bequant.io",doc:["https://api.bequant.io/"],fees:["https://bequant.io/fees-and-limits"],referral:"https://bequant.io"}})}};const a4=ge,{ExchangeError:_o,AccountSuspended:o4,ArgumentsRequired:hf,AuthenticationError:lf,DDoSProtection:d4,ExchangeNotAvailable:c4,InvalidOrder:fr,OrderNotFound:u4,PermissionDenied:f4,InsufficientFunds:ak,BadSymbol:h4,RateLimitExceeded:ok,BadRequest:Ur}=de,{TICK_SIZE:l4}=me,pf=Se;var p4=class extends a4{describe(){return this.deepExtend(super.describe(),{id:"bibox",name:"Bibox",countries:["CN","US","KR"],rateLimit:166.667,version:"v3.1",hostname:"bibox.com",has:{CORS:void 0,spot:!0,margin:void 0,swap:void 0,future:void 0,option:void 0,cancelAllOrders:!0,cancelOrder:!0,createMarketOrder:void 0,createOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRates:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchDepositWithdrawFee:!0,fetchDepositWithdrawFees:!1,fetchLedger:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrdersByStatus:!0,fetchPositionMode:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!0,fetchWithdrawals:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/51840849/77257418-3262b000-6c85-11ea-8fb8-20bdf20b3592.jpg",api:{rest:"https://api.{hostname}"},www:"https://www.{hostname}",doc:["https://biboxcom.github.io/en/","https://biboxcom.github.io/v3/spot/en/","https://biboxcom.github.io/api/spot/v4"],fees:"https://bibox.zendesk.com/hc/en-us/articles/360002336133"},api:{v1:{public:{get:{cquery:1,mdata:1,cdata:1,orderpending:1},post:{mdata:1}},private:{post:{credit:1,cquery:1,ctrade:1,user:1,orderpending:1,transfer:1}}},"v1.1":{public:{get:["cquery"]},private:{post:["cquery","ctrade"]}},v2:{public:{get:["mdata/kline","mdata/depth"]},private:{post:["assets/transfer/spot"]}},v3:{public:{get:["mdata/ping","mdata/pairList","mdata/kline","mdata/marketAll","mdata/market","mdata/depth","mdata/deals","mdata/ticker","cbc/timestamp","cbu/timestamp"]},private:{post:["assets/transfer/spot","assets/transfer/cbc","cbc/order/open","cbc/order/close","cbc/order/closeBatch","cbc/order/closeAll","cbc/changeMargin","cbc/changeMode","cbc/assets","cbc/position","cbc/order/list","cbc/order/detail","cbc/order/listBatch","cbc/order/listBatchByClientOid","cbuassets/transfer","cbu/order/open","cbu/order/close","cbu/order/closeBatch","cbu/order/closeAll","cbu/order/planOpen","cbu/order/planOrderList","cbu/order/planClose","cbu/order/planCloseAll","cbu/changeMargin","cbu/changeMode","cbu/assets","cbu/position","cbu/order/list","bu/order/detail","cbu/order/listBatch","cbu/order/listBatchByClientOid"]}},"v3.1":{public:{get:["mdata/ping","cquery/buFundRate","cquery/buTagPrice","cquery/buValue","cquery/buUnit","cquery/bcFundRate","cquery/bcTagPrice","cquery/bcValue","cquery/bcUnit"]},private:{get:["orderpending/tradeLimit"],post:["transfer/mainAssets","spot/account/assets","transfer/transferIn","transfer/transferOut","transfer/transferInList","transfer/transferOutList","transfer/coinConfig","transfer/withdrawInfo","orderpending/trade","orderpending/cancelTrade","orderpending/orderPendingList","orderpending/pendingHistoryList","orderpending/orderDetail","orderpending/order","orderpending/orderHistoryList","orderpending/orderDetailsLast","credit/transferAssets/base2credit","credit/transferAssets/credit2base","credit/lendOrder/get","credit/borrowOrder/get","credit/lendOrderbook/get","credit/transferAssets/lendAssets","credit/transferAssets/borrowAssets","credit/borrowOrder/autobook","credit/borrowOrder/refund","credit/lendOrderbook/publish","credit/lendOrderbook/cancel","credit/trade/trade","credit/trade/cancel","cquery/base_u/dealLog","cquery/base_u/orderDetail","cquery/base_u/orderHistory","cquery/base_u/orderById","cquery/base_coin/dealLog","cquery/base_coin/orderDetail","cquery/base_coin/orderHistory","cquery/base_coin/orderById"]}},v4:{public:{get:["marketdata/pairs","marketdata/order_book","marketdata/candles","marketdata/trades","marketdata/ticker"]},private:{get:["userdata/accounts","userdata/ledger","userdata/order","userdata/orders","userdata/fills"],post:["userdata/order"],delete:["userdata/order","userdata/orders","userdata/fills"]}}},fees:{trading:{tierBased:!1,percentage:!0,taker:this.parseNumber("0.002"),maker:this.parseNumber("0.001")},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}},precisionMode:l4,exceptions:{2011:o4,2015:lf,2021:ak,2027:ak,2033:u4,2065:fr,2066:fr,2067:fr,2068:fr,2078:fr,2085:fr,2091:ok,2092:fr,2131:fr,3e3:Ur,3002:Ur,3012:lf,3016:h4,3024:f4,3025:lf,4e3:c4,4003:d4,"-2004":fr,"-2102":ok},commonCurrencies:{"APENFT(NFT)":"NFT",BOX:"DefiBox",BPT:"BlockPool Token",BUSDT:"USDT",GMT:"GMT Token",KEY:"Bihu",MTC:"MTC Mesh Network",NFT:"NFT Protocol",PAI:"PCHAIN",REVO:"Revo Network",STAR:"Starbase",TERN:"Ternio-ERC20"},options:{typesByAccount:{base:"main",credit:"margin"}}})}async fetchMarkets(e={}){const t=await this.v4PublicGetMarketdataPairs(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"symbol"),a=this.safeString(n,"base"),o=this.safeString(n,"quote"),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o),u=d+"/"+c,h="spot",l=!0,p=this.safeString(n,"quantity_scale"),m=this.safeString(n,"price_scale");s.push({id:r,symbol:u,baseId:a,quoteId:o,settleId:void 0,base:d,quote:c,settle:void 0,type:h,spot:l,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(p)),price:this.parseNumber(this.parsePrecision(m))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(n,"min_quantity"),max:this.safeNumber(n,"max_quantity")},price:{min:this.safeNumber(n,"min_price"),max:this.safeNumber(n,"max_price")},cost:{min:this.safeNumber(n,"min_order_value"),max:void 0}},info:n})}return s}parseTicker(e,t=void 0){const s=this.safeInteger2(e,"timestamp","t"),i=this.safeString(e,"coin_symbol"),n=this.safeString(e,"currency_symbol");let r=this.safeString(e,"s");r===void 0&&i!==void 0&&n!==void 0&&(r=i+"_"+n),t=this.safeMarket(r,t);const a=this.safeString2(e,"last","p");let o=this.safeString(e,"percent");return o!==void 0&&(o=o.replace("%","")),this.safeTicker({symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeString2(e,"high","h"),low:this.safeString2(e,"low","l"),bid:this.safeString(e,"bp"),bidVolume:this.safeString(e,"bq"),ask:this.safeString(e,"ap"),askVolume:this.safeString(e,"aq"),vwap:void 0,open:this.safeString(e,"o"),close:a,last:a,previousClose:void 0,change:this.safeString(e,"change"),percentage:o,average:void 0,baseVolume:this.safeString2(e,"a","vol24H"),quoteVolume:this.safeString2(e,"v","amount"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.v4PublicGetMarketdataTicker(this.extend(i,t)),r=this.safeValue(n,0);return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={cmd:"marketAll"},i=await this.v1PublicGetMdata(this.extend(s,t)),n=this.parseTickers(i.result,e),r=this.indexBy(n,"symbol");return this.filterByArray(r,"symbol",e)}parseTrade(e,t=void 0){const s=this.safeString(e,"i"),i=this.safeString(e,"s"),n=this.safeInteger(e,"t"),r=this.safeValue(e,"f"),a=this.safeString(r,"a"),o=this.safeString(e,"q");let d=this.safeString(e,"T"),c="buy";const u=this.safeString(e,"o");return t=this.safeMarket(i,t),i==="buy"||i==="sell"?c=i:pf.stringLt(o,"0")&&(c="sell"),pf.stringLt(s,"9999999999")&&(d=s),this.safeTrade({info:e,id:d,order:u,timestamp:n,datetime:this.iso8601(n),symbol:t.symbol,type:void 0,takerOrMaker:this.safeString(e,"l","taker"),side:c,price:this.safeString(e,"p"),amount:o,cost:void 0,fee:{cost:this.safeString(r,"m"),currency:this.safeCurrencyCode(a)}},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r=this.safeInteger(i,"until"),a={symbol:n.id};s!==void 0&&(a.limit=s),t!==void 0&&(a.start_time=t),r!==void 0&&(a.end_time=r);const o=await this.v4PublicGetMarketdataTrades(this.extend(a,i));return this.parseTrades(o,n,t,s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};if(t!==void 0){const a=[1,2,5,10,20,50,100,200,500,1e3];if(!this.inArray(t,a))throw new Ur(this.id+" fetchOrderBook limit argument by only be one of 1, 2, 5, 10, 20, 50, 100, 200, 500 or 1000");n.level=t}const r=await this.v4PublicGetMarketdataOrderBook(this.extend(n,s));return this.parseOrderBook(r,i.symbol,this.safeInteger(r,"t"),"b","a")}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.safeInteger(n,"until"),o={symbol:r.id,time_frame:this.timeframes[t]};if(i!==void 0&&(o.limit=i),s!==void 0&&a!==void 0)throw new Ur(this.id+' fetchOHLCV cannot take both a since parameter and params["until"]');s!==void 0?o.after=s:a!==void 0&&(o.before=a);const d=await this.v4PublicGetMarketdataCandles(this.extend(o,n));let c=this.safeValue(d,"e",[]);return c===void 0&&(Array.isArray(d)?c=d:c=[]),this.parseOHLCVs(c,r,t,s,i)}async fetchCurrencies(e={}){return this.checkRequiredCredentials(!1)?await this.fetchCurrenciesPrivate(e):await this.fetchCurrenciesPublic(e)}async fetchCurrenciesPublic(e={}){const t={cmd:"currencies"},s=await this.v1PublicGetCdata(this.extend(t,e)),i=this.safeValue(s,"result",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"symbol"),d=this.safeString(a,"name"),c=this.safeCurrencyCode(o),u=this.parseNumber(this.parsePrecision(this.safeString(a,"valid_decimals"))),h=this.safeValue(a,"enable_deposit"),l=this.safeValue(a,"enable_withdraw"),p=h&&l;n[c]={id:o,code:c,info:a,name:d,active:p,deposit:h,withdraw:l,fee:void 0,precision:u,limits:{amount:{min:u,max:void 0},withdraw:{min:this.safeNumber(a,"withdraw_min"),max:void 0}}}}return n}async fetchCurrenciesPrivate(e={}){if(!this.checkRequiredCredentials(!1))throw new lf(this.id+" fetchCurrencies is an authenticated endpoint, therefore it requires 'apiKey' and 'secret' credentials. If you don't need currency details, set exchange.has['fetchCurrencies'] = false before calling its methods.");const t={cmd:"transfer/coinList",body:{}},s=await this.v1PrivatePostTransfer(this.extend(t,e)),i=this.safeValue(s,"result"),n=this.safeValue(i,0,{}),r=this.safeValue(n,"result",[]),a={};for(let o=0;o<r.length;o++){const d=r[o],c=this.safeString(d,"symbol"),u=d.name,h=this.safeCurrencyCode(c),l=this.parseNumber("0.00000001"),p=this.safeValue(d,"enable_deposit"),m=this.safeValue(d,"enable_withdraw"),g=p&&m;a[h]={id:c,code:h,info:d,name:u,active:g,fee:void 0,precision:l,limits:{amount:{min:l,max:void 0},withdraw:{min:void 0,max:void 0}}}}return a}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString2(i,"s","coin_symbol"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString2(i,"a","balance"),a.used=this.safeString2(i,"h","freeze"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),i={};let n;if(t==="spot"){const r=this.safeString(s,"code"),a=this.omit(s,"code");if(r!==void 0){const o=this.currency(r);i.asset=o.id}n=await this.v4PrivateGetUserdataAccounts(this.extend(i,a))}else if(t==="main"||t==="wallet"||t==="funding"){const r="v3.1PrivatePostTransferMainAssets";i.select=1;const a=await this[r](this.extend(i,s)),o=this.safeValue(a,"result",{});n=this.safeValue(o,"assets_list",[])}return this.parseBalance(n)}parseLedgerEntry(e,t=void 0){const s={transfer_in:"transfer",transfer_out:"transfer",trade_finish_ask:"trade",trade_finish_bid:"trade"},i=this.safeString(e,"i"),n=this.safeString(e,"s"),r=this.safeString(e,"T"),a=this.safeInteger(e,"t"),o=this.safeString(e,"a");let d="in";return pf.stringLt(o,"0")&&(d="out"),{id:i,direction:d,account:void 0,referenceId:i,referenceAccount:void 0,type:this.safeString(s,r,r),currency:this.safeCurrencyCode(n,t),amount:this.parseNumber(o),timestamp:a,datetime:this.iso8601(a),before:void 0,after:this.safeNumber(e,"b"),status:void 0,fee:void 0,info:e}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r=this.safeInteger(i,"until");i=this.omit(i,"until");const a={};e!==void 0&&(n=this.currency(e),a.asset=n.id),t!==void 0&&(a.start_time=t),s!==void 0&&(a.limit=s),r!==void 0&&(a.end_time=r);const o=await this.v4PrivateGetUserdataLedger(this.extend(a,i));return this.parseLedger(o,n,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),s===void 0&&(s=50);const r={page:this.safeInteger(i,"page",1),size:s};let a;e!==void 0&&(a=this.currency(e),r.coin_symbol=a.id);const d=await this["v3.1PrivatePostTransferTransferInList"](this.extend(r,i)),c=this.safeValue(d,"result"),u=this.safeValue(c,"items");for(let h=0;h<u.length;h++)u[h].type="deposit";return this.parseTransactions(u,a,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),s===void 0&&(s=50);const r={page:this.safeInteger(i,"page",1),size:s};let a;e!==void 0&&(a=this.currency(e),r.coin_symbol=a.id);const d=await this["v3.1PrivatePostTransferTransferOutList"](this.extend(r,i)),c=this.safeValue(d,"result"),u=this.safeValue(c,"items");for(let h=0;h<u.length;h++)u[h].type="withdrawal";return this.parseTransactions(u,a,t,s)}parseTransaction(e,t=void 0){const s=this.safeString(e,"to_address"),i=this.safeString(e,"coin_symbol"),n=this.safeCurrencyCode(i,t),r=this.safeInteger(e,"createdAt");let a=this.safeString(e,"addr_remark");const o=this.safeString(e,"type"),d=this.safeNumber(e,"amount");let c=this.safeNumber(e,"fee");o==="deposit"&&(c=0,a=void 0);const u={cost:c,currency:n};return{info:e,id:this.safeString2(e,"id","result"),txid:this.safeString(e,"tx_id"),timestamp:r,datetime:this.iso8601(r),network:this.safeString(e,"chain_type"),address:s,addressTo:s,addressFrom:void 0,tag:a,tagTo:void 0,tagFrom:void 0,type:o,amount:d,currency:n,status:this.parseTransactionStatusByType(this.safeString(e,"status"),o),updated:void 0,fee:u}}parseTransactionStatusByType(e,t=void 0){const s={deposit:{1:"pending",2:"ok"},withdrawal:{0:"pending",3:"ok"}};return this.safeString(this.safeValue(s,t,{}),e,e)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);if(t=t.toLowerCase(),t==="market")throw new Ur(this.id+" createOrder () does not support market orders, only limit orders are allowed");if(n===void 0)throw new hf(this.id+" createOrder () requires a price argument for limit orders");const o={symbol:a.id,side:s,type:t,quantity:this.amountToPrecision(e,i),price:this.priceToPrecision(e,n)},d=this.safeStringLower(r,"timeInForce");d!==void 0&&(o.time_in_force=d);const c=this.isPostOnly(!1,void 0,r);c&&(o.post_only=c);const u=this.safeString(r,"clientOrderId");u!==void 0&&(o.client_order_id=u),r=this.omit(r,["postOnly","timeInForce","clientOrderId"]);const h=await this.v4PrivatePostUserdataOrder(this.deepExtend(o,r));return this.parseOrder(h,a)}async cancelAllOrders(e=void 0,t={}){if(await this.loadMarkets(),e===void 0)throw new hf(this.id+" cancelAllOrders requires a symbol argument");const s=this.market(e),i={symbol:s.id},n=await this.v4PrivateDeleteUserdataOrders(this.extend(i,t));return this.parseOrders(n,s)}async cancelOrder(e,t=void 0,s={}){const i={id:e},n=await this.v4PrivateDeleteUserdataOrder(this.extend(i,s));return this.parseOrder(n)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.v4PrivateGetUserdataOrder(this.extend(i,s));return this.parseOrder(n)}parseOrder(e,t=void 0){const s=this.safeString(e,"m");t=this.safeMarket(s,t);const i=this.safeInteger(e,"C");let n=this.safeString(e,"Q");n=pf.stringAbs(n);const r=this.safeString(e,"s"),a=[],o=this.safeValue(e,"f",[]);for(let u=0;u<o.length;u++)a.push({currency:this.safeCurrencyCode(this.safeString(o[u],"a")),cost:this.safeString(o[u],"m")});const d=this.safeValue(e,"F"),c=[];for(let u=0;u<d.length;u++){const h=this.parseTrade(d[u]);c.push(h)}return this.safeOrder({info:e,id:this.safeString(e,"i"),clientOrderId:this.omitZero(this.safeString(e,"I")),timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,symbol:t.symbol,type:this.safeString(e,"T"),timeInForce:this.safeStringUpper(e,"t"),postOnly:this.safeValue(e,"o"),side:r,price:this.safeString(e,"P"),stopPrice:void 0,amount:n,cost:this.safeString(e,"e"),average:void 0,filled:this.safeString(e,"E"),remaining:void 0,status:this.parseOrderStatus(this.safeString(e,"S")),fee:this.safeValue(a,0),fees:a,trades:c},t)}parseOrderStatus(e){const t={1:"open",2:"open",accepted:"open",3:"closed",4:"canceled",5:"canceled",6:"canceled",rejected:"rejected","-1":"rejected"};return this.safeString(t,e,e)}async fetchOrdersByStatus(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a;const o=this.safeInteger(n,"until"),d=e==="open",c=e==="unsettled";n=this.omit(n,"until"),o!==void 0&&(r.end_time=o),i!==void 0&&(r.limit=i),s!==void 0&&(r.start_time=s),r.status=d||c?"unsettled":"settled",t!==void 0&&(a=this.market(t),r.symbol=a.id);const u=await this.v4PrivateGetUserdataOrders(this.extend(r,n));return this.parseOrders(u,a,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("open",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new hf(this.id+" fetchClosedOrders requires a symbol argument");return await this.fetchOrdersByStatus("closed",e,t,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={},a=this.safeInteger(i,"until");if(i=this.omit(i,"until"),e===void 0&&this.safeString(i,"order_id")===void 0)throw new hf(this.id+' fetchMyTrades requires either a symbol parameter of params["order_id"]');e!==void 0&&(n=this.market(e),r.symbol=n.id),t!==void 0&&(r.start_time=t),s!==void 0&&(r.limit=s),a!==void 0&&(r.end_time=a);const o=await this.v4PrivateGetUserdataFills(this.extend(r,i));return this.parseTrades(o,n,t,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={cmd:"transfer/transferIn",body:this.extend({coin_symbol:s.id},t)},n=await this.v1PrivatePostTransfer(i),r=this.safeValue(n,"result"),a=this.safeValue(r,0,{}),o=this.safeValue(a,"result");let d=o,c;if(this.isJsonEncodedObject(o)){const u=JSON.parse(o);d=this.safeString(u,"account"),c=this.safeString(u,"memo")}return{currency:e,address:d,tag:c,network:void 0,info:n}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e);if(this.password===void 0&&!("trade_pwd"in n))throw new _o(this.id+" withdraw() requires this.password set on the exchange instance or a trade_pwd parameter");if(!("totp_code"in n))throw new _o(this.id+" withdraw() requires a totp_code parameter for 2FA authentication");const a={trade_pwd:this.password,coin_symbol:r.id,amount:t,addr:s};i!==void 0&&(a.address_remark=i);const o=await this.v1PrivatePostTransfer({cmd:"transfer/transferOut",body:this.extend(a,n)}),d=this.safeValue(o,"result"),c=this.safeValue(d,0,{});return this.parseTransaction(c,r)}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s={},i={};e===void 0&&(e=Object.keys(this.currencies));for(let n=0;n<e.length;n++){const r=e[n],a=this.currency(r),o={cmd:"transfer/coinConfig",body:this.extend({coin_symbol:a.id},t)},d=await this.v1PrivatePostTransfer(o),c=this.safeValue(d,"result",[]),u=this.safeValue(c,0,{}),h=this.safeValue(u,"result",[]),l=this.safeValue(h,0,{});i[r]=l,s[r]=this.safeNumber(l,"withdraw_fee")}return{info:i,withdraw:s,deposit:{}}}async fetchDepositWithdrawFee(e,t={}){await this.loadMarkets();const s=this.currency(e),i={cmd:"transfer/coinConfig",body:this.extend({coin_symbol:s.id},t)},n=await this.v1PrivatePostTransfer(i),r=this.safeValue(n,"result",[]),a=this.safeValue(r,0,{}),o=this.safeValue(a,"result",[]),d=this.safeValue(o,0,{});return this.parseDepositWithdrawFee(d,s)}parseDepositWithdrawFee(e,t=void 0){return{info:e,withdraw:{fee:this.safeNumber(e,"withdraw_fee"),percentage:void 0},deposit:{fee:void 0,percentage:void 0},networks:{}}}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=s==="main"||s==="wallet"||s==="funding",o=s==="spot",d=i==="main"||i==="wallet"||i==="funding",c=i==="spot",u=i==="cross",h=s==="cross",l=this.inArray(i,this.symbols),p=this.inArray(s,this.symbols),m=i==="swap",g=s==="swap";let y="v3PrivatePostAssetsTransferSpot";const b={amount:t};if(c||o)if(b.symbol=r.id,a)b.type=0;else if(d)b.type=1;else throw new Ur(this.id+" cannot transfer from "+s+" to "+i);else if((h||p)&&d)y="v3.1PrivatePostCreditTransferAssetsCredit2base",b.coin_symbol=r.id,b.pair=p?this.marketId(s):"*_USDT";else if((u||l)&&a)y="v3.1PrivatePostCreditTransferAssetsBase2credit",b.coin_symbol=r.id,b.pair=l?this.marketId(i):"*_USDT";else if(m||g){if(e==="USDT"?y="v3PrivatePostCbuassetsTransfer":y="v3PrivatePostAssetsTransferCbc",d)b.type=1;else if(a)b.type=0;else throw new Ur(this.id+" cannot transfer from "+s+" to "+i);b.symbol=r.id}else throw new Ur(this.id+" cannot transfer from "+s+" to "+i);const w=await this[y](this.extend(b,n));return this.parseTransfer(w,r)}parseTransfer(e,t=void 0){const s=this.safeString(e,"cmd");let i,n;if(s!==void 0){const a=this.safeString(s.split("/"),1).split("2");i=this.safeString(a,0),n=this.safeString(a,1),i=this.safeString(this.options.typesByAccount,i,i),n=this.safeString(this.options.typesByAccount,n,n)}return{info:e,id:this.safeString2(e,"id","result"),timestamp:void 0,datetime:void 0,currency:this.safeString(t,"code"),amount:void 0,fromAccount:i,toAccount:n,status:void 0}}sign(e,t="v1Public",s="GET",i={},n=void 0,r=void 0){const[a,o]=t,d=a==="v1",c=a==="v4",u=c?"/api":"";let h=this.implodeHostname(this.urls.api.rest)+u+"/"+a+"/"+e;const l=d?this.json([i]):this.json(i);if(n={"content-type":"application/json"},o==="public")s!=="GET"?d?r={cmds:l}:r={body:l}:Object.keys(i).length&&(h+="?"+this.urlencode(i));else if(this.checkRequiredCredentials(),a==="v3"||a==="v3.1"){const p=this.numberToString(this.milliseconds());let m=p;l!=="{}"&&(m+=l);const g=this.hmac(this.encode(m),this.encode(this.secret),"md5");n["bibox-api-key"]=this.apiKey,n["bibox-api-sign"]=g,n["bibox-timestamp"]=p,s==="GET"?h+="?"+this.urlencode(i):l!=="{}"&&(r=i)}else if(c){let p="";const m=this.keysort(i);s==="GET"?(h+="?"+this.urlencode(m),p=this.urlencode(m)):(l!=="{}"&&(r=m),p=this.json(r,{convertArraysToObjects:!0}));const g=this.hmac(this.encode(p),this.encode(this.secret),"sha256");n["Bibox-Api-Key"]=this.apiKey,n["Bibox-Api-Sign"]=g}else{const p=this.hmac(this.encode(l),this.encode(this.secret),"md5");r={apikey:this.apiKey,sign:p},d?r.cmds=l:r.body=l}return r!==void 0&&(r=this.json(r,{convertArraysToObjects:!0})),{url:h,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0){if("state"in a){if(this.safeNumber(a,"state")===0)return;throw new _o(this.id+" "+r)}if("error"in a)if(typeof a.error=="object"){if("code"in a.error){const c=this.safeString(a.error,"code"),u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions,c,u),new _o(u)}throw new _o(this.id+" "+r)}else{const c=this.safeString(a,"error"),u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions,c,u),new _o(u)}}}};const m4=ge,{ExchangeError:Pa,ArgumentsRequired:Tm,AuthenticationError:Om,InsufficientFunds:dk,PermissionDenied:ck,BadRequest:uk,BadSymbol:fk,RateLimitExceeded:g4,InvalidOrder:Co}=de,{TICK_SIZE:y4}=me;var b4=class extends m4{describe(){return this.deepExtend(super.describe(),{id:"bigone",name:"BigONE",countries:["CN"],version:"v3",rateLimit:1200,has:{CORS:void 0,spot:!0,margin:void 0,swap:void 0,future:void 0,option:void 0,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!1,fetchWithdrawals:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"min1","5m":"min5","15m":"min15","30m":"min30","1h":"hour1","3h":"hour3","4h":"hour4","6h":"hour6","12h":"hour12","1d":"day1","1w":"week1","1M":"month1"},hostname:"big.one",urls:{logo:"https://user-images.githubusercontent.com/1294454/69354403-1d532180-0c91-11ea-88ed-44c06cefdf87.jpg",api:{public:"https://{hostname}/api/v3",private:"https://{hostname}/api/v3/viewer"},www:"https://big.one",doc:"https://open.big.one/docs/api.html",fees:"https://bigone.zendesk.com/hc/en-us/articles/115001933374-BigONE-Fee-Policy",referral:"https://b1.run/users/new?code=D3LLBVFT"},api:{public:{get:["ping","asset_pairs","asset_pairs/{asset_pair_name}/depth","asset_pairs/{asset_pair_name}/trades","asset_pairs/{asset_pair_name}/ticker","asset_pairs/{asset_pair_name}/candles","asset_pairs/tickers"]},private:{get:["accounts","fund/accounts","assets/{asset_symbol}/address","orders","orders/{id}","orders/multi","trades","withdrawals","deposits"],post:["orders","orders/{id}/cancel","orders/cancel","withdrawals","transfer"]}},fees:{trading:{maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")},funding:{withdraw:{}}},options:{accountsByType:{spot:"SPOT",funding:"FUND",future:"CONTRACT",swap:"CONTRACT"},transfer:{fillResponseFromRequest:!0},exchangeMillisecondsCorrection:-100},precisionMode:y4,exceptions:{exact:{10001:uk,10005:Pa,"Amount's scale must greater than AssetPair's base scale":Co,"Price mulit with amount should larger than AssetPair's min_quote_value":Co,10007:uk,10011:Pa,10013:fk,10014:dk,10403:ck,10429:g4,40004:Om,40103:Om,40104:Om,40301:ck,40302:Pa,40601:Pa,40602:Pa,40603:dk,40604:Co,40605:Co,40120:Co,40121:Co,60100:fk},broad:{}},commonCurrencies:{CRE:"Cybereits",FXT:"FXTTOKEN",FREE:"FreeRossDAO",MBN:"Mobilian Coin",ONE:"BigONE Token"}})}async fetchMarkets(e={}){const t=await this.publicGetAssetPairs(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"name"),o=this.safeString(r,"id"),d=this.safeValue(r,"base_asset",{}),c=this.safeValue(r,"quote_asset",{}),u=this.safeString(d,"symbol"),h=this.safeString(c,"symbol"),l=this.safeCurrencyCode(u),p=this.safeCurrencyCode(h),m={id:a,uuid:o,symbol:l+"/"+p,base:l,quote:p,settle:void 0,baseId:u,quoteId:h,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"base_scale"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"quote_scale")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(r,"min_quote_value"),max:this.safeNumber(r,"max_quote_value")}},info:r};i.push(m)}return i}async loadMarkets(e=!1,t={}){const s=await super.loadMarkets(e,t);let i=this.safeValue(this.options,"marketsByUuid");if(i===void 0||e){i={};for(let n=0;n<this.symbols.length;n++){const r=this.symbols[n],a=this.markets[r],o=this.safeString(a,"uuid");i[o]=a}this.options.marketsByUuid=i}return s}parseTicker(e,t=void 0){const s=this.safeString(e,"asset_pair_name"),i=this.safeSymbol(s,t,"-"),n=void 0,r=this.safeString(e,"close"),a=this.safeValue(e,"bid",{}),o=this.safeValue(e,"ask",{});return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(a,"price"),bidVolume:this.safeString(a,"quantity"),ask:this.safeString(o,"price"),askVolume:this.safeString(o,"quantity"),vwap:void 0,open:this.safeString(e,"open"),close:r,last:r,previousClose:void 0,change:this.safeString(e,"daily_change"),percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={asset_pair_name:s.id},n=await this.publicGetAssetPairsAssetPairNameTicker(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};if(e=this.marketSymbols(e),e!==void 0){const a=this.marketIds(e);s.pair_names=a.join(",")}const i=await this.publicGetAssetPairsTickers(this.extend(s,t)),n=this.safeValue(i,"data",[]),r={};for(let a=0;a<n.length;a++){const o=this.parseTicker(n[a]),d=o.symbol;r[d]=o}return this.filterByArray(r,"symbol",e)}async fetchTime(e={}){const t=await this.publicGetPing(e),s=this.safeValue(t,"data",{}),i=this.safeInteger(s,"timestamp");return parseInt(i/1e6)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={asset_pair_name:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetAssetPairsAssetPairNameDepth(this.extend(n,s)),a=this.safeValue(r,"data",{});return this.parseOrderBook(a,i.symbol,void 0,"bids","asks","price","quantity")}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString2(e,"created_at","inserted_at")),i=this.safeString(e,"price"),n=this.safeString(e,"amount"),r=this.safeString(e,"asset_pair_name");t=this.safeMarket(r,t,"-");let a=this.safeString(e,"side");const o=this.safeString(e,"taker_side");let d;o!==void 0&&a!==void 0&&a!=="SELF_TRADING"&&(d=o===a?"taker":"maker"),a===void 0?a=o==="ASK"?"sell":"buy":a==="BID"?a="buy":a==="ASK"&&(a="sell");const c=this.safeString(e,"maker_order_id"),u=this.safeString(e,"taker_order_id");let h;c!==void 0?u!==void 0?h=[c,u]:h=c:u!==void 0&&(h=u);const p={id:this.safeString(e,"id"),timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:h,type:"limit",side:a,takerOrMaker:d,price:i,amount:n,cost:void 0,info:e};let m,g;d!==void 0?a==="buy"?d==="maker"?(m=t.base,g=t.quote):(m=t.quote,g=t.base):d==="maker"?(m=t.quote,g=t.base):(m=t.base,g=t.quote):a==="SELF_TRADING"&&(o==="BID"?(m=t.quote,g=t.base):o==="ASK"&&(m=t.base,g=t.quote));const y=this.safeString(e,"maker_fee"),b=this.safeString(e,"taker_fee");return y!==void 0?b!==void 0?p.fees=[{cost:y,currency:m},{cost:b,currency:g}]:p.fee={cost:y,currency:m}:b!==void 0?p.fee={cost:b,currency:g}:p.fee=void 0,this.safeTrade(p,t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={asset_pair_name:n.id},a=await this.publicGetAssetPairsAssetPairNameTrades(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"time")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);i===void 0&&(i=100);const a={asset_pair_name:r.id,period:this.timeframes[t],limit:i};if(s!==void 0){const c=this.parseTimeframe(t),u=this.sum(s,i*c*1e3);a.time=this.iso8601(u)}const o=await this.publicGetAssetPairsAssetPairNameCandles(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseOHLCVs(d,r,t,s,i)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"data",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeString(n,"asset_symbol"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(n,"balance"),o.used=this.safeString(n,"locked_balance"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"type","");e=this.omit(e,"type");const s="privateGet"+this.capitalize(t)+"Accounts",i=await this[s](e);return this.parseBalance(i)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"asset_pair_name"),n=this.safeSymbol(i,t,"-"),r=this.parse8601(this.safeString(e,"created_at")),a=this.safeString(e,"price"),o=this.safeString(e,"amount"),d=this.safeString(e,"avg_deal_price"),c=this.safeString(e,"filled_amount"),u=this.parseOrderStatus(this.safeString(e,"state"));let h=this.safeString(e,"side");h==="BID"?h="buy":h="sell";const l=this.parse8601(this.safeString(e,"updated_at"));return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:l,symbol:n,type:void 0,timeInForce:void 0,postOnly:void 0,side:h,price:a,stopPrice:void 0,amount:o,cost:void 0,average:d,filled:c,remaining:void 0,status:u,fee:void 0,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);s=s==="buy"?"BID":"ASK";const o=t.toUpperCase(),d={asset_pair_name:a.id,side:s,amount:this.amountToPrecision(e,i),type:o};if(o==="LIMIT")d.price=this.priceToPrecision(e,n);else{const h=o==="STOP_LIMIT";if(h||o==="STOP_MARKET"){const p=this.safeNumber2(r,"stop_price","stopPrice");if(p===void 0)throw new Tm(this.id+" createOrder() requires a stop_price parameter");d.stop_price=this.priceToPrecision(e,p),r=this.omit(r,["stop_price","stopPrice"])}h&&(d.price=this.priceToPrecision(e,n))}const c=await this.privatePostOrders(this.extend(d,r)),u=this.safeValue(c,"data");return this.parseOrder(u,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privatePostOrdersIdCancel(this.extend(i,s)),r=this.safeValue(n,"data");return this.parseOrder(r)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const i={asset_pair_name:this.market(e).id};return await this.privatePostOrdersCancel(this.extend(i,t))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetOrdersId(this.extend(i,s)),r=this.safeValue(n,"data",{});return this.parseOrder(r)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Tm(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={asset_pair_name:n.id};s!==void 0&&(r.limit=s);const a=await this.privateGetOrders(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseOrders(o,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),e===void 0)throw new Tm(this.id+" fetchMyTrades() requires a symbol argument");const n=this.market(e),r={asset_pair_name:n.id};s!==void 0&&(r.limit=s);const a=await this.privateGetTrades(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}parseOrderStatus(e){const t={PENDING:"open",FILLED:"closed",CANCELLED:"canceled"};return this.safeString(t,e)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={state:"PENDING"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={state:"FILLED"};return await this.fetchOrders(e,t,s,this.extend(n,i))}nonce(){const e=this.safeInteger(this.options,"exchangeMillisecondsCorrection",0)*1e6;return this.microseconds()*1e3+e}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.omit(i,this.extractParams(e));let d=this.implodeHostname(this.urls.api[t])+"/"+this.implodeParams(e,i);if(n={},t==="public")Object.keys(a).length&&(d+="?"+this.urlencode(a));else{this.checkRequiredCredentials();const c=this.nonce().toString(),u={type:"OpenAPIV2",sub:this.apiKey,nonce:c},h=this.jwt(u,this.encode(this.secret));n.Authorization="Bearer "+h,s==="GET"?Object.keys(a).length&&(d+="?"+this.urlencode(a)):s==="POST"&&(n["Content-Type"]="application/json",r=this.json(a))}return n["User-Agent"]="ccxt/"+this.id+"-"+this.version,{url:d,method:s,body:r,headers:n}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={asset_symbol:this.currency(e).id},n=await this.privateGetAssetsAssetSymbolAddress(this.extend(i,t)),r=this.safeValue(n,"data",[]);if(r.length<1)throw new Pa(this.id+" fetchDepositAddress() returned empty address response");const o=r[0],d=this.safeString(o,"value"),c=this.safeString(o,"memo");return this.checkAddress(d),{currency:e,address:d,tag:c,network:void 0,info:n}}parseTransactionStatus(e){const t={WITHHOLD:"ok",UNCONFIRMED:"pending",CONFIRMED:"ok",COMPLETED:"ok",PENDING:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"asset_symbol"),i=this.safeCurrencyCode(s),n=this.safeInteger(e,"id"),r=this.safeNumber(e,"amount"),a=this.parseTransactionStatus(this.safeString(e,"state")),o=this.parse8601(this.safeString(e,"inserted_at")),d=this.parse8601(this.safeString2(e,"updated_at","completed_at")),c=this.safeString(e,"txid"),u=this.safeString(e,"target_address"),h=this.safeString(e,"memo"),l="customer_id"in e?"deposit":"withdrawal";return{info:e,id:n,txid:c,timestamp:o,datetime:this.iso8601(o),network:void 0,addressFrom:void 0,address:void 0,addressTo:u,tagFrom:void 0,tag:h,tagTo:void 0,type:l,amount:r,currency:i,status:a,updated:d,fee:void 0}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.asset_symbol=r.id),s!==void 0&&(n.limit=s);const a=await this.privateGetDeposits(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.asset_symbol=r.id),s!==void 0&&(n.limit=s);const a=await this.privateGetWithdrawals(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,r,t,s)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c=this.safeString(n,"guid",this.uuid()),u={symbol:r.id,amount:this.currencyToPrecision(e,t),from:o,to:d,guid:c},h=await this.privatePostTransfer(this.extend(u,n)),l=this.parseTransfer(h,r),p=this.safeValue(this.options,"transfer",{});return this.safeValue(p,"fillResponseFromRequest",!0)&&(l.fromAccount=s,l.toAccount=i,l.amount=t,l.id=c),l}parseTransfer(e,t=void 0){const s=this.safeNumber(e,"code");return{info:e,id:void 0,timestamp:void 0,datetime:void 0,currency:s,amount:void 0,fromAccount:void 0,toAccount:void 0,status:this.parseTransferStatus(s)}}parseTransferStatus(e){const t={0:"ok"};return this.safeString(t,e,"failed")}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets();const r=this.currency(e),a={symbol:r.id,target_address:s,amount:this.currencyToPrecision(e,t)};i!==void 0&&(a.memo=i);const o=await this.privatePostWithdrawals(this.extend(a,n)),d=this.safeValue(o,"data",{});return this.parseTransaction(d,r)}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"code"),u=this.safeString(a,"message");if(c!=="0"){const h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwExactlyMatchedException(this.exceptions.exact,c,h),this.throwBroadlyMatchedException(this.exceptions.broad,u,h),new Pa(h)}}};const w4=ge,{ExchangeError:ft,ArgumentsRequired:ri,ExchangeNotAvailable:Jd,InsufficientFunds:Wt,OrderNotFound:hk,InvalidOrder:Bs,DDoSProtection:ec,InvalidNonce:k4,AuthenticationError:Ds,RateLimitExceeded:tc,PermissionDenied:Fn,NotSupported:ai,BadRequest:ye,BadSymbol:Mo,AccountSuspended:Po,OrderImmediatelyFillable:mf,OnMaintenance:S4,BadResponse:lk,RequestTimeout:v4,OrderNotFillable:T4,MarginModeAlreadySet:pk}=de,{TRUNCATE:gf,DECIMAL_PLACES:O4}=me,_e=Se;var Gu=class extends w4{describe(){return this.deepExtend(super.describe(),{id:"binance",name:"Binance",countries:["JP","MT"],rateLimit:50,certified:!0,pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!0,option:void 0,addMargin:!0,borrowMargin:!0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:void 0,createDepositAddress:!1,createOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!1,createStopOrder:!0,fetchAccounts:void 0,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowInterest:!0,fetchBorrowRate:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!0,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchCanceledOrders:!1,fetchClosedOrder:!1,fetchClosedOrders:"emulated",fetchCurrencies:!0,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!0,fetchL3OrderBook:!1,fetchLedger:void 0,fetchLeverage:!1,fetchLeverageTiers:!0,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!0,fetchOpenOrder:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:void 0,fetchPositions:!0,fetchPositionsRisk:!0,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTradingLimits:void 0,fetchTransactionFee:void 0,fetchTransactionFees:!0,fetchTransactions:!1,fetchTransfers:!0,fetchWithdrawal:!1,fetchWithdrawals:!0,fetchWithdrawalWhitelist:!1,reduceMargin:!0,repayMargin:!0,setLeverage:!0,setMargin:!1,setMarginMode:!0,setPositionMode:!0,signIn:!1,transfer:!0,withdraw:!0},timeframes:{"1s":"1s","1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/29604020-d5483cdc-87ee-11e7-94c7-d1a8d9169293.jpg",test:{dapiPublic:"https://testnet.binancefuture.com/dapi/v1",dapiPrivate:"https://testnet.binancefuture.com/dapi/v1",eapiPublic:"https://testnet.binanceops.com/eapi/v1",eapiPrivate:"https://testnet.binanceops.com/eapi/v1",fapiPublic:"https://testnet.binancefuture.com/fapi/v1",fapiPrivate:"https://testnet.binancefuture.com/fapi/v1",fapiPrivateV2:"https://testnet.binancefuture.com/fapi/v2",public:"https://testnet.binance.vision/api/v3",private:"https://testnet.binance.vision/api/v3",v1:"https://testnet.binance.vision/api/v1"},api:{wapi:"https://api.binance.com/wapi/v3",sapi:"https://api.binance.com/sapi/v1",sapiV3:"https://api.binance.com/sapi/v3",dapiPublic:"https://dapi.binance.com/dapi/v1",dapiPrivate:"https://dapi.binance.com/dapi/v1",eapiPublic:"https://eapi.binance.com/eapi/v1",eapiPrivate:"https://eapi.binance.com/eapi/v1",dapiPrivateV2:"https://dapi.binance.com/dapi/v2",dapiData:"https://dapi.binance.com/futures/data",fapiPublic:"https://fapi.binance.com/fapi/v1",fapiPrivate:"https://fapi.binance.com/fapi/v1",fapiData:"https://fapi.binance.com/futures/data",fapiPrivateV2:"https://fapi.binance.com/fapi/v2",public:"https://api.binance.com/api/v3",private:"https://api.binance.com/api/v3",v1:"https://api.binance.com/api/v1"},www:"https://www.binance.com",referral:{url:"https://accounts.binance.com/en/register?ref=D7YA7CLY",discount:.1},doc:["https://binance-docs.github.io/apidocs/spot/en"],api_management:"https://www.binance.com/en/usercenter/settings/api-management",fees:"https://www.binance.com/en/fee/schedule"},depth:1,api:{sapi:{get:{"system/status":.1,accountSnapshot:240,"margin/asset":1,"margin/pair":1,"margin/allAssets":.1,"margin/allPairs":.1,"margin/priceIndex":1,"asset/assetDividend":1,"asset/dribblet":.1,"asset/transfer":.1,"asset/assetDetail":.1,"asset/tradeFee":.1,"asset/ledger-transfer/cloud-mining/queryByPage":4,"margin/loan":1,"margin/repay":1,"margin/account":1,"margin/transfer":.1,"margin/interestHistory":.1,"margin/forceLiquidationRec":.1,"margin/order":1,"margin/openOrders":1,"margin/allOrders":20,"margin/myTrades":1,"margin/maxBorrowable":5,"margin/maxTransferable":5,"margin/tradeCoeff":1,"margin/isolated/transfer":.1,"margin/isolated/account":1,"margin/isolated/pair":1,"margin/isolated/allPairs":1,"margin/isolated/accountLimit":.1,"margin/interestRateHistory":.1,"margin/orderList":1,"margin/allOrderList":20,"margin/openOrderList":1,"margin/crossMarginData":{cost:.1,noCoin:.5},"margin/isolatedMarginData":{cost:.1,noCoin:1},"margin/isolatedMarginTier":.1,"margin/rateLimit/order":2,"margin/dribblet":.1,"loan/income":40,"loan/ongoing/orders":40,"loan/ltv/adjustment/history":40,"loan/borrow/history":40,"loan/repay/history":40,"loan/loanable/data":40,"loan/collateral/data":40,"loan/repay/collateral/rate":600,"loan/vip/ongoing/orders":40,"loan/vip/repay/history":40,"fiat/orders":600.03,"fiat/payments":.1,"futures/transfer":1,"futures/loan/borrow/history":1,"futures/loan/repay/history":1,"futures/loan/wallet":1,"futures/loan/adjustCollateral/history":1,"futures/loan/liquidationHistory":1,"rebate/taxQuery":20.001,"capital/config/getall":1,"capital/deposit/address":1,"capital/deposit/hisrec":.1,"capital/deposit/subAddress":.1,"capital/deposit/subHisrec":.1,"capital/withdraw/history":.1,"convert/tradeFlow":.6667,"convert/exchangeInfo":50,"convert/assetInfo":10,"convert/orderStatus":.6667,"account/status":.1,"account/apiTradingStatus":.1,"account/apiRestrictions/ipRestriction":.1,bnbBurn:.1,"sub-account/futures/account":1,"sub-account/futures/accountSummary":.1,"sub-account/futures/positionRisk":1,"sub-account/futures/internalTransfer":.1,"sub-account/list":.1,"sub-account/margin/account":1,"sub-account/margin/accountSummary":1,"sub-account/spotSummary":.1,"sub-account/status":1,"sub-account/sub/transfer/history":.1,"sub-account/transfer/subUserHistory":.1,"sub-account/universalTransfer":.1,"sub-account/apiRestrictions/ipRestriction/thirdPartyList":1,"managed-subaccount/asset":.1,"managed-subaccount/accountSnapshot":240,"lending/daily/product/list":.1,"lending/daily/userLeftQuota":.1,"lending/daily/userRedemptionQuota":.1,"lending/daily/token/position":.1,"lending/union/account":.1,"lending/union/purchaseRecord":.1,"lending/union/redemptionRecord":.1,"lending/union/interestHistory":.1,"lending/project/list":.1,"lending/project/position/list":.1,"mining/pub/algoList":.1,"mining/pub/coinList":.1,"mining/worker/detail":.5,"mining/worker/list":.5,"mining/payment/list":.5,"mining/statistics/user/status":.5,"mining/statistics/user/list":.5,"mining/payment/uid":.5,"bswap/pools":.1,"bswap/liquidity":{cost:.1,noPoolId:1},"bswap/liquidityOps":20.001,"bswap/quote":1.00005,"bswap/swap":20.001,"bswap/poolConfigure":1.00005,"bswap/addLiquidityPreview":1.00005,"bswap/removeLiquidityPreview":1.00005,"bswap/unclaimedRewards":6.667,"bswap/claimedHistory":6.667,"blvt/tokenInfo":.1,"blvt/subscribe/record":.1,"blvt/redeem/record":.1,"blvt/userLimit":.1,"apiReferral/ifNewUser":1,"apiReferral/customization":1,"apiReferral/userCustomization":1,"apiReferral/rebate/recentRecord":1,"apiReferral/rebate/historicalRecord":1,"apiReferral/kickback/recentRecord":1,"apiReferral/kickback/historicalRecord":1,"broker/subAccountApi":1,"broker/subAccount":1,"broker/subAccountApi/commission/futures":1,"broker/subAccountApi/commission/coinFutures":1,"broker/info":1,"broker/transfer":1,"broker/transfer/futures":1,"broker/rebate/recentRecord":1,"broker/rebate/historicalRecord":1,"broker/subAccount/bnbBurn/status":1,"broker/subAccount/depositHist":1,"broker/subAccount/spotSummary":1,"broker/subAccount/marginSummary":1,"broker/subAccount/futuresSummary":1,"broker/rebate/futures/recentRecord":1,"broker/subAccountApi/ipRestriction":1,"broker/universalTransfer":1,"account/apiRestrictions":.1,"c2c/orderMatch/listUserOrderHistory":.1,"nft/history/transactions":20.001,"nft/history/deposit":20.001,"nft/history/withdraw":20.001,"nft/user/getAsset":20.001,"pay/transactions":20.001,"giftcard/verify":.1,"giftcard/cryptography/rsa-public-key":.1,"giftcard/buyCode/token-limit":.1,"algo/futures/openOrders":.1,"algo/futures/historicalOrders":.1,"algo/futures/subOrders":.1,"portfolio/account":.1,"portfolio/collateralRate":5,"portfolio/pmLoan":3.3335,"staking/productList":.1,"staking/position":.1,"staking/stakingRecord":.1,"staking/personalLeftQuota":.1},post:{"asset/dust":1,"asset/dust-btc":.1,"asset/transfer":.1,"asset/get-funding-asset":.1,"asset/convert-transfer":.033335,"asset/convert-transfer/queryByPage":.033335,"account/disableFastWithdrawSwitch":.1,"account/enableFastWithdrawSwitch":.1,"capital/withdraw/apply":4.0002,"margin/transfer":1,"margin/loan":20.001,"margin/repay":20.001,"margin/order":.040002,"margin/order/oco":.040002,"margin/isolated/transfer":4.0002,"margin/isolated/account":2.0001,bnbBurn:.1,"sub-account/virtualSubAccount":.1,"sub-account/margin/transfer":4.0002,"sub-account/margin/enable":.1,"sub-account/futures/enable":.1,"sub-account/futures/transfer":.1,"sub-account/futures/internalTransfer":.1,"sub-account/transfer/subToSub":.1,"sub-account/transfer/subToMaster":.1,"sub-account/universalTransfer":.1,"managed-subaccount/deposit":.1,"managed-subaccount/withdraw":.1,userDataStream:.1,"userDataStream/isolated":.1,"futures/transfer":.1,"lending/customizedFixed/purchase":.1,"lending/daily/purchase":.1,"lending/daily/redeem":.1,"bswap/liquidityAdd":60,"bswap/liquidityRemove":60,"bswap/swap":60,"bswap/claimRewards":6.667,"blvt/subscribe":.1,"blvt/redeem":.1,"apiReferral/customization":1,"apiReferral/userCustomization":1,"apiReferral/rebate/historicalRecord":1,"apiReferral/kickback/historicalRecord":1,"broker/subAccount":1,"broker/subAccount/margin":1,"broker/subAccount/futures":1,"broker/subAccountApi":1,"broker/subAccountApi/permission":1,"broker/subAccountApi/commission":1,"broker/subAccountApi/commission/futures":1,"broker/subAccountApi/commission/coinFutures":1,"broker/transfer":1,"broker/transfer/futures":1,"broker/rebate/historicalRecord":1,"broker/subAccount/bnbBurn/spot":1,"broker/subAccount/bnbBurn/marginInterest":1,"broker/subAccount/blvt":1,"broker/subAccountApi/ipRestriction":1,"broker/subAccountApi/ipRestriction/ipList":1,"broker/universalTransfer":1,"broker/subAccountApi/permission/universalTransfer":1,"broker/subAccountApi/permission/vanillaOptions":1,"giftcard/createCode":.1,"giftcard/redeemCode":.1,"giftcard/buyCode":.1,"algo/futures/newOrderVp":20.001,"algo/futures/newOrderTwap":20.001,"staking/purchase":.1,"staking/redeem":.1,"staking/setAutoStaking":.1,"portfolio/repay":20.001,"loan/borrow":40,"loan/repay":40,"loan/adjust/ltv":40,"loan/customize/margin_call":40,"loan/vip/repay":40,"convert/getQuote":20.001,"convert/acceptQuote":3.3335},put:{userDataStream:.1,"userDataStream/isolated":.1},delete:{"margin/openOrders":.1,"margin/order":.0066667,"margin/orderList":.0066667,"margin/isolated/account":2.0001,userDataStream:.1,"userDataStream/isolated":.1,"broker/subAccountApi":1,"broker/subAccountApi/ipRestriction/ipList":1,"algo/futures/order":.1}},sapiV3:{get:{"sub-account/assets":1},post:{"asset/getUserAsset":.5}},wapi:{post:{withdraw:1,"sub-account/transfer":1},get:{depositHistory:1,withdrawHistory:1,depositAddress:1,accountStatus:1,systemStatus:1,apiTradingStatus:1,userAssetDribbletLog:1,tradeFee:1,assetDetail:1,"sub-account/list":1,"sub-account/transfer/history":1,"sub-account/assets":1}},dapiPublic:{get:{ping:1,time:1,exchangeInfo:1,depth:{cost:2,byLimit:[[50,2],[100,5],[500,10],[1e3,20]]},trades:5,historicalTrades:20,aggTrades:20,premiumIndex:10,fundingRate:1,klines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},continuousKlines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},indexPriceKlines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},markPriceKlines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},"ticker/24hr":{cost:1,noSymbol:40},"ticker/price":{cost:1,noSymbol:2},"ticker/bookTicker":{cost:1,noSymbol:2},openInterest:1,pmExchangeInfo:1}},dapiData:{get:{openInterestHist:1,topLongShortAccountRatio:1,topLongShortPositionRatio:1,globalLongShortAccountRatio:1,takerBuySellVol:1,basis:1}},dapiPrivate:{get:{"positionSide/dual":30,order:1,openOrder:1,openOrders:{cost:1,noSymbol:5},allOrders:{cost:20,noSymbol:40},balance:1,account:5,"positionMargin/history":1,positionRisk:1,userTrades:{cost:20,noSymbol:40},income:20,leverageBracket:1,forceOrders:{cost:20,noSymbol:50},adlQuantile:5,orderAmendment:1,pmAccountInfo:5},post:{"positionSide/dual":1,order:4,batchOrders:5,countdownCancelAll:10,leverage:1,marginType:1,positionMargin:1,listenKey:1},put:{listenKey:1,order:1,batchOrders:5},delete:{order:1,allOpenOrders:1,batchOrders:5,listenKey:1}},dapiPrivateV2:{get:{leverageBracket:1}},fapiPublic:{get:{ping:1,time:1,exchangeInfo:1,depth:{cost:2,byLimit:[[50,2],[100,5],[500,10],[1e3,20]]},trades:5,historicalTrades:20,aggTrades:20,klines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},continuousKlines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},markPriceKlines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},indexPriceKlines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},fundingRate:1,premiumIndex:1,"ticker/24hr":{cost:1,noSymbol:40},"ticker/price":{cost:1,noSymbol:2},"ticker/bookTicker":{cost:1,noSymbol:2},openInterest:1,indexInfo:1,apiTradingStatus:{cost:1,noSymbol:10},lvtKlines:1,pmExchangeInfo:1}},fapiData:{get:{openInterestHist:1,topLongShortAccountRatio:1,topLongShortPositionRatio:1,globalLongShortAccountRatio:1,takerlongshortRatio:1}},fapiPrivate:{get:{forceOrders:{cost:20,noSymbol:50},allOrders:5,openOrder:1,openOrders:1,order:1,account:5,balance:5,leverageBracket:1,"positionMargin/history":1,positionRisk:5,"positionSide/dual":30,userTrades:5,income:30,commissionRate:20,apiTradingStatus:1,multiAssetsMargin:30,"apiReferral/ifNewUser":1,"apiReferral/customization":1,"apiReferral/userCustomization":1,"apiReferral/traderNum":1,"apiReferral/overview":1,"apiReferral/tradeVol":1,"apiReferral/rebateVol":1,"apiReferral/traderSummary":1,adlQuantile:5,pmAccountInfo:5},post:{batchOrders:5,"positionSide/dual":1,positionMargin:1,marginType:1,order:4,leverage:1,listenKey:1,countdownCancelAll:10,multiAssetsMargin:1,"apiReferral/customization":1,"apiReferral/userCustomization":1},put:{listenKey:1},delete:{batchOrders:1,order:1,allOpenOrders:1,listenKey:1}},fapiPrivateV2:{get:{account:1,balance:1,positionRisk:1}},eapiPublic:{get:{ping:1,time:1,exchangeInfo:1,index:1,ticker:5,mark:5,depth:1,klines:1,trades:5,historicalTrades:20,exerciseHistory:3,openInterest:3}},eapiPrivate:{get:{account:3,position:5,openOrders:{cost:1,noSymbol:40},historyOrders:3,userTrades:5,exerciseRecord:5,bill:1,marginAccount:3,mmp:1,countdownCancelAll:1},post:{transfer:1,order:1,batchOrders:5,listenKey:1,mmpSet:1,mmpReset:1,countdownCancelAll:1,countdownCancelAllHeartBeat:10},put:{listenKey:1},delete:{order:1,batchOrders:1,allOpenOrders:1,allOpenOrdersByUnderlying:1,listenKey:1}},public:{get:{ping:1,time:1,depth:{cost:1,byLimit:[[100,1],[500,5],[1e3,10],[5e3,50]]},trades:1,aggTrades:1,historicalTrades:5,klines:1,"ticker/24hr":{cost:1,noSymbol:40},"ticker/price":{cost:1,noSymbol:2},"ticker/bookTicker":{cost:1,noSymbol:2},exchangeInfo:10},put:{userDataStream:1},post:{userDataStream:1},delete:{userDataStream:1}},private:{get:{allOrderList:10,openOrderList:3,orderList:2,order:2,openOrders:{cost:3,noSymbol:40},allOrders:10,account:10,myTrades:10,"rateLimit/order":20},post:{"order/oco":1,order:1,"order/test":1},delete:{openOrders:1,orderList:1,order:1}}},fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0.001")},future:{trading:{feeSide:"quote",tierBased:!0,percentage:!0,taker:this.parseNumber("0.000400"),maker:this.parseNumber("0.000200"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.000400")],[this.parseNumber("250"),this.parseNumber("0.000400")],[this.parseNumber("2500"),this.parseNumber("0.000350")],[this.parseNumber("7500"),this.parseNumber("0.000320")],[this.parseNumber("22500"),this.parseNumber("0.000300")],[this.parseNumber("50000"),this.parseNumber("0.000270")],[this.parseNumber("100000"),this.parseNumber("0.000250")],[this.parseNumber("200000"),this.parseNumber("0.000220")],[this.parseNumber("400000"),this.parseNumber("0.000200")],[this.parseNumber("750000"),this.parseNumber("0.000170")]],maker:[[this.parseNumber("0"),this.parseNumber("0.000200")],[this.parseNumber("250"),this.parseNumber("0.000160")],[this.parseNumber("2500"),this.parseNumber("0.000140")],[this.parseNumber("7500"),this.parseNumber("0.000120")],[this.parseNumber("22500"),this.parseNumber("0.000100")],[this.parseNumber("50000"),this.parseNumber("0.000080")],[this.parseNumber("100000"),this.parseNumber("0.000060")],[this.parseNumber("200000"),this.parseNumber("0.000040")],[this.parseNumber("400000"),this.parseNumber("0.000020")],[this.parseNumber("750000"),this.parseNumber("0")]]}}},delivery:{trading:{feeSide:"base",tierBased:!0,percentage:!0,taker:this.parseNumber("0.000500"),maker:this.parseNumber("0.000100"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.000500")],[this.parseNumber("250"),this.parseNumber("0.000450")],[this.parseNumber("2500"),this.parseNumber("0.000400")],[this.parseNumber("7500"),this.parseNumber("0.000300")],[this.parseNumber("22500"),this.parseNumber("0.000250")],[this.parseNumber("50000"),this.parseNumber("0.000240")],[this.parseNumber("100000"),this.parseNumber("0.000240")],[this.parseNumber("200000"),this.parseNumber("0.000240")],[this.parseNumber("400000"),this.parseNumber("0.000240")],[this.parseNumber("750000"),this.parseNumber("0.000240")]],maker:[[this.parseNumber("0"),this.parseNumber("0.000100")],[this.parseNumber("250"),this.parseNumber("0.000080")],[this.parseNumber("2500"),this.parseNumber("0.000050")],[this.parseNumber("7500"),this.parseNumber("0.0000030")],[this.parseNumber("22500"),this.parseNumber("0")],[this.parseNumber("50000"),this.parseNumber("-0.000050")],[this.parseNumber("100000"),this.parseNumber("-0.000060")],[this.parseNumber("200000"),this.parseNumber("-0.000070")],[this.parseNumber("400000"),this.parseNumber("-0.000080")],[this.parseNumber("750000"),this.parseNumber("-0.000090")]]}}},option:{}},commonCurrencies:{BCC:"BCC",YOYO:"YOYOW"},precisionMode:O4,options:{fetchCurrencies:!0,defaultTimeInForce:"GTC",defaultType:"spot",hasAlreadyAuthenticatedSuccessfully:!1,warnOnFetchOpenOrdersWithoutSymbol:!0,throwMarginModeAlreadySet:!1,fetchPositions:"positionRisk",recvWindow:10*1e3,timeDifference:0,adjustForTimeDifference:!1,newOrderRespType:{market:"FULL",limit:"FULL"},quoteOrderQty:!0,broker:{spot:"x-R4BD3S82",margin:"x-R4BD3S82",future:"x-xcKtGhcu",delivery:"x-xcKtGhcu"},accountsByType:{main:"MAIN",spot:"MAIN",funding:"FUNDING",margin:"MARGIN",cross:"MARGIN",future:"UMFUTURE",delivery:"CMFUTURE"},accountsById:{MAIN:"spot",FUNDING:"funding",MARGIN:"margin",UMFUTURE:"future",CMFUTURE:"delivery"},networks:{ERC20:"ETH",TRC20:"TRX",BEP2:"BNB",BEP20:"BSC",OMNI:"OMNI",EOS:"EOS",SPL:"SOL"},reverseNetworks:{"tronscan.org":"TRC20","etherscan.io":"ERC20","bscscan.com":"BSC","explorer.binance.org":"BEP2","bithomp.com":"XRP","bloks.io":"EOS","stellar.expert":"XLM","blockchair.com/bitcoin":"BTC","blockchair.com/bitcoin-cash":"BCH","blockchair.com/ecash":"XEC","explorer.litecoin.net":"LTC","explorer.avax.network":"AVAX","solscan.io":"SOL","polkadot.subscan.io":"DOT","dashboard.internetcomputer.org":"ICP","explorer.chiliz.com":"CHZ","cardanoscan.io":"ADA","mainnet.theoan.com":"AION","algoexplorer.io":"ALGO","explorer.ambrosus.com":"AMB","viewblock.io/zilliqa":"ZIL","viewblock.io/arweave":"AR","explorer.ark.io":"ARK","atomscan.com":"ATOM","www.mintscan.io":"CTK","explorer.bitcoindiamond.org":"BCD","btgexplorer.com":"BTG","bts.ai":"BTS","explorer.celo.org":"CELO","explorer.nervos.org":"CKB","cerebro.cortexlabs.ai":"CTXC","chainz.cryptoid.info":"VIA","explorer.dcrdata.org":"DCR","digiexplorer.info":"DGB","dock.subscan.io":"DOCK","dogechain.info":"DOGE","explorer.elrond.com":"EGLD","blockscout.com":"ETC","explore-fetchhub.fetch.ai":"FET","filfox.info":"FIL","fio.bloks.io":"FIO","explorer.firo.org":"FIRO","neoscan.io":"NEO","ftmscan.com":"FTM","explorer.gochain.io":"GO","block.gxb.io":"GXS","hash-hash.info":"HBAR","www.hiveblockexplorer.com":"HIVE","explorer.helium.com":"HNT","tracker.icon.foundation":"ICX","www.iostabc.com":"IOST","explorer.iota.org":"IOTA","iotexscan.io":"IOTX","irishub.iobscan.io":"IRIS","kava.mintscan.io":"KAVA","scope.klaytn.com":"KLAY","kmdexplorer.io":"KMD","kusama.subscan.io":"KSM","explorer.lto.network":"LTO","polygonscan.com":"POLYGON","explorer.ont.io":"ONT","minaexplorer.com":"MINA","nanolooker.com":"NANO","explorer.nebulas.io":"NAS","explorer.nbs.plus":"NBS","explorer.nebl.io":"NEBL","nulscan.io":"NULS","nxscan.com":"NXS","explorer.harmony.one":"ONE","explorer.poa.network":"POA","qtum.info":"QTUM","explorer.rsk.co":"RSK","www.oasisscan.com":"ROSE","ravencoin.network":"RVN","sc.tokenview.com":"SC","secretnodes.com":"SCRT","explorer.skycoin.com":"SKY","steemscan.com":"STEEM","explorer.stacks.co":"STX","www.thetascan.io":"THETA","scan.tomochain.com":"TOMO","explore.vechain.org":"VET","explorer.vite.net":"VITE","www.wanscan.org":"WAN","wavesexplorer.com":"WAVES","wax.eosx.io":"WAXP","waltonchain.pro":"WTC","chain.nem.ninja":"XEM","verge-blockchain.info":"XVG","explorer.yoyow.org":"YOYOW","explorer.zcha.in":"ZEC","explorer.zensystem.io":"ZEN"},impliedNetworks:{ETH:{ERC20:"ETH"},TRX:{TRC20:"TRX"}},legalMoney:{MXN:!0,UGX:!0,SEK:!0,CHF:!0,VND:!0,AED:!0,DKK:!0,KZT:!0,HUF:!0,PEN:!0,PHP:!0,USD:!0,TRY:!0,EUR:!0,NGN:!0,PLN:!0,BRL:!0,ZAR:!0,KES:!0,ARS:!0,RUB:!0,AUD:!0,NOK:!0,CZK:!0,GBP:!0,UAH:!0,GHS:!0,HKD:!0,CAD:!0,INR:!0,JPY:!0,NZD:!0}},exceptions:{exact:{"System is under maintenance.":S4,"System abnormality":ft,"You are not authorized to execute this request.":Fn,"API key does not exist":Ds,"Order would trigger immediately.":mf,"Stop price would trigger immediately.":mf,"Order would immediately match and take.":mf,"Account has insufficient balance for requested action.":Wt,"Rest API trading is not enabled.":Jd,"You don't have permission.":Fn,"Market is closed.":Jd,"Too many requests. Please try again later.":ec,"This action disabled is on this account.":Po,"This type of sub-account exceeds the maximum number limit":ye,"This symbol is not permitted for this account.":Fn,"-1000":Jd,"-1001":Jd,"-1002":Ds,"-1003":tc,"-1004":ec,"-1005":Fn,"-1006":lk,"-1007":v4,"-1010":lk,"-1011":Fn,"-1013":Bs,"-1014":Bs,"-1015":tc,"-1016":Jd,"-1020":ye,"-1021":k4,"-1022":Ds,"-1023":ye,"-1099":Ds,"-1100":ye,"-1101":ye,"-1102":ye,"-1103":ye,"-1104":ye,"-1105":ye,"-1106":ye,"-1108":ye,"-1109":Ds,"-1110":ye,"-1111":ye,"-1112":Bs,"-1113":ye,"-1114":ye,"-1115":ye,"-1116":ye,"-1117":ye,"-1118":ye,"-1119":ye,"-1120":ye,"-1121":Mo,"-1125":Ds,"-1127":ye,"-1128":ye,"-1130":ye,"-1131":ye,"-1136":ye,"-2008":Ds,"-2010":ft,"-2011":hk,"-2013":hk,"-2014":Ds,"-2015":Ds,"-2016":ye,"-2018":Wt,"-2019":Wt,"-2020":T4,"-2021":mf,"-2022":Bs,"-2023":Wt,"-2024":Wt,"-2025":Bs,"-2026":Bs,"-2027":Bs,"-2028":Wt,"-3000":ft,"-3001":Ds,"-3002":Mo,"-3003":ye,"-3004":ft,"-3005":Wt,"-3006":Wt,"-3007":ft,"-3008":Wt,"-3009":ye,"-3010":ye,"-3011":ye,"-3012":Wt,"-3013":ye,"-3014":Po,"-3015":ye,"-3016":ye,"-3017":ft,"-3018":Po,"-3019":Po,"-3020":Wt,"-3021":ye,"-3022":Po,"-3023":ye,"-3024":ft,"-3025":ye,"-3026":ye,"-3027":Mo,"-3028":Mo,"-3029":ft,"-3036":Po,"-3037":ft,"-3038":ye,"-3041":Wt,"-3042":ye,"-3043":ye,"-3044":ec,"-3045":ft,"-3999":ft,"-4001":ye,"-4002":ye,"-4003":ye,"-4004":Ds,"-4005":tc,"-4006":ye,"-4007":ye,"-4008":ye,"-4010":ye,"-4011":ye,"-4012":ye,"-4013":Ds,"-4014":Fn,"-4015":ft,"-4016":Fn,"-4017":Fn,"-4018":Mo,"-4019":Mo,"-4021":ye,"-4022":ye,"-4023":ft,"-4024":Wt,"-4025":Wt,"-4026":Wt,"-4027":ft,"-4028":ye,"-4029":ye,"-4030":ft,"-4031":ft,"-4032":ft,"-4033":ye,"-4034":ft,"-4035":Fn,"-4036":ye,"-4037":ft,"-4038":ft,"-4039":ye,"-4040":ye,"-4041":ft,"-4042":ft,"-4043":ye,"-4044":ye,"-4045":ft,"-4046":Ds,"-4047":ye,"-5001":ye,"-5002":Wt,"-5003":Wt,"-5004":ye,"-5005":Wt,"-5006":ye,"-5007":ye,"-5008":Wt,"-5009":ye,"-5010":ft,"-5011":ye,"-5012":ft,"-5013":Wt,"-5021":ye,"-6001":ye,"-6003":ye,"-6004":ft,"-6005":Bs,"-6006":ye,"-6007":ye,"-6008":ye,"-6009":tc,"-6011":ye,"-6012":Wt,"-6013":ft,"-6014":ye,"-6015":ye,"-6016":ye,"-6017":ye,"-6018":ye,"-6019":Ds,"-6020":ye,"-7001":ye,"-7002":ye,"-9000":Wt,"-10017":ye,"-11008":Wt,"-12014":tc,"-13000":ye,"-13001":ye,"-13002":ye,"-13003":ye,"-13004":ye,"-13005":ye,"-13006":Bs,"-13007":Ds,"-21001":ye,"-21002":ye,"-21003":ye,100001003:ye},broad:{"has no operation privilege":Fn,MAX_POSITION:Bs}}})}costToPrecision(e,t){return this.decimalToPrecision(t,gf,this.markets[e].precision.quote,this.precisionMode,this.paddingMode)}currencyToPrecision(e,t,s=void 0){return this.safeValue(this.currencies[e],"precision")!==void 0?this.decimalToPrecision(t,gf,this.currencies[e].precision,this.precisionMode,this.paddingMode):this.numberToString(t)}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchTime(e={}){const t=this.safeString2(this.options,"fetchTime","defaultType","spot"),s=this.safeString(e,"type",t),i=this.omit(e,"type");let n="publicGetTime";s==="future"?n="fapiPublicGetTime":s==="delivery"&&(n="dapiPublicGetTime");const r=await this[n](i);return this.safeInteger(r,"serverTime")}async fetchCurrencies(e={}){if(!this.safeValue(this.options,"fetchCurrencies")||!this.checkRequiredCredentials(!1)||this.safeString(this.urls,"apiBackup")!==void 0)return;const i=await this.sapiGetCapitalConfigGetall(e),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"coin"),d=this.safeString(a,"name"),c=this.safeCurrencyCode(o);let u,h=!0,l=!0;const p=this.safeValue(a,"networkList",[]),m={};let g;for(let k=0;k<p.length;k++){const T=p[k],O=this.safeString(T,"network"),x=this.safeNumber(T,"withdrawFee"),C=this.safeValue(T,"depositEnable"),E=this.safeValue(T,"withdrawEnable");l=l||C,h=h||E,m[O]=x,(this.safeValue(T,"isDefault")||g===void 0)&&(g=x);const _=this.safeString(T,"withdrawIntegerMultiple");_e.stringEq(_,"0")||(u=u===void 0?_:_e.stringMin(u,_))}const y=this.safeValue(a,"trading"),b=h&&l&&y;let w;u!==void 0&&(w=this.parseNumber(this.numberToString(this.precisionFromString(u)))),n[c]={id:o,name:d,code:c,precision:w,info:a,active:b,deposit:l,withdraw:h,networks:p,fee:g,fees:m,limits:this.limits}}return n}async fetchMarkets(e={}){const t=this.safeString2(this.options,"fetchMarkets","defaultType","spot"),s=this.safeString(e,"type",t),i=this.omit(e,"type"),n=s==="spot",r=s==="margin",a=s==="future",o=s==="delivery";if(!n&&!r&&!a&&!o)throw new ft(this.id+" does not support '"+s+"' type, set exchange.options['defaultType'] to 'spot', 'margin', 'delivery' or 'future'");let d="publicGetExchangeInfo";a?d="fapiPublicGetExchangeInfo":o&&(d="dapiPublicGetExchangeInfo");const c=await this[d](i);this.options.adjustForTimeDifference&&await this.loadTimeDifference();const u=this.safeValue(c,"symbols",[]),h=[];for(let l=0;l<u.length;l++){const p=u[l],m=this.safeString(p,"symbol"),g=this.safeStringLower(p,"symbol"),y=this.safeString(p,"baseAsset"),b=this.safeString(p,"quoteAsset"),w=this.safeString(p,"marginAsset"),k=this.safeCurrencyCode(y),T=this.safeCurrencyCode(b),O=this.safeCurrencyCode(w),x=a||o,C=this.safeString(p,"contractType"),E=x&&C!=="PERPETUAL";let P,_;E?(P=m,_=this.safeInteger(p,"deliveryDate")):P=k+"/"+T;const S=this.safeValue(p,"filters",[]),I=this.indexBy(S,"filterType"),v=this.safeString2(p,"status","contractStatus");let N,q=this.fees,R,G;x&&(N=this.safeNumber(p,"contractSize",this.parseNumber("1")),q=this.fees[s],R=O===T,G=O===k);let F=v==="TRADING";if(n){const Q=this.safeValue(p,"permissions",[]);for(let J=0;J<Q.length;J++)if(Q[J]==="TRD_GRP_003"){F=!1;break}}const A=this.safeValue(p,"isMarginTradingAllowed",!1),V={id:m,lowercaseId:g,symbol:P,base:k,quote:T,settle:O,baseId:y,quoteId:b,settleId:w,type:s,spot:n,margin:n&&A,swap:a,future:a,delivery:o,option:!1,active:F,contract:x,linear:R,inverse:G,taker:q.trading.taker,maker:q.trading.maker,contractSize:N,expiry:_,expiryDatetime:this.iso8601(_),strike:void 0,optionType:void 0,precision:{amount:this.safeInteger(p,"quantityPrecision"),price:this.safeInteger(p,"pricePrecision"),base:this.safeInteger(p,"baseAssetPrecision"),quote:this.safeInteger(p,"quotePrecision")},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:p};if("PRICE_FILTER"in I){const Q=this.safeValue(I,"PRICE_FILTER",{});V.limits.price={min:this.safeNumber(Q,"minPrice"),max:this.safeNumber(Q,"maxPrice")},V.precision.price=this.precisionFromString(Q.tickSize)}if("LOT_SIZE"in I){const Q=this.safeValue(I,"LOT_SIZE",{}),J=this.safeString(Q,"stepSize");V.precision.amount=this.precisionFromString(J),V.limits.amount={min:this.safeNumber(Q,"minQty"),max:this.safeNumber(Q,"maxQty")}}if("MARKET_LOT_SIZE"in I){const Q=this.safeValue(I,"MARKET_LOT_SIZE",{});V.limits.market={min:this.safeNumber(Q,"minQty"),max:this.safeNumber(Q,"maxQty")}}if("MIN_NOTIONAL"in I){const Q=this.safeValue(I,"MIN_NOTIONAL",{});V.limits.cost.min=this.safeNumber2(Q,"minNotional","notional")}h.push(V)}return h}parseBalanceHelper(e){const t=this.account();t.used=this.safeString(e,"locked"),t.free=this.safeString(e,"free");const s=this.safeString(e,"interest"),i=this.safeString(e,"borrowed");return t.debt=_e.stringAdd(i,s),t}parseBalance(e,t=void 0,s=void 0){const i={info:e};let n;const r=s==="isolated",a=t==="margin"||s==="cross";if(!r&&(t==="spot"||a)){n=this.safeInteger(e,"updateTime");const o=this.safeValue2(e,"balances","userAssets",[]);for(let d=0;d<o.length;d++){const c=o[d],u=this.safeString(c,"asset"),h=this.safeCurrencyCode(u),l=this.account();if(l.free=this.safeString(c,"free"),l.used=this.safeString(c,"locked"),a){const p=this.safeString(c,"borrowed"),m=this.safeString(c,"interest");l.debt=_e.stringAdd(p,m)}i[h]=l}}else if(r){const o=this.safeValue(e,"assets");for(let d=0;d<o.length;d++){const c=o[d],u=this.safeValue(c,"symbol"),h=this.safeSymbol(u),l=this.safeValue(c,"baseAsset",{}),p=this.safeValue(c,"quoteAsset",{}),m=this.safeCurrencyCode(this.safeString(l,"asset")),g=this.safeCurrencyCode(this.safeString(p,"asset")),y={};y[m]=this.parseBalanceHelper(l),y[g]=this.parseBalanceHelper(p),i[h]=this.safeBalance(y)}}else if(t==="savings"){const o=this.safeValue(e,"positionAmountVos",[]);for(let d=0;d<o.length;d++){const c=o[d],u=this.safeString(c,"asset"),h=this.safeCurrencyCode(u),l=this.account(),p=this.safeString(c,"amount");l.total=p,l.used=p,i[h]=l}}else if(t==="funding")for(let o=0;o<e.length;o++){const d=e[o],c=this.account(),u=this.safeString(d,"asset"),h=this.safeCurrencyCode(u);c.free=this.safeString(d,"free");const l=this.safeString(d,"freeze"),p=this.safeString(d,"withdrawing"),m=this.safeString(d,"locked");c.used=_e.stringAdd(l,_e.stringAdd(m,p)),i[h]=c}else{let o=e;Array.isArray(e)||(o=this.safeValue(e,"assets",[]));for(let d=0;d<o.length;d++){const c=o[d],u=this.safeString(c,"asset"),h=this.safeCurrencyCode(u),l=this.account();l.free=this.safeString(c,"availableBalance"),l.used=this.safeString(c,"initialMargin"),l.total=this.safeString2(c,"marginBalance","balance"),i[h]=l}}return i.timestamp=n,i.datetime=this.iso8601(n),r?i:this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString2(this.options,"fetchBalance","defaultType","spot"),s=this.safeString(e,"type",t),[i,n]=this.handleMarginModeAndParams("fetchBalance",e);let r="privateGetAccount";const a={};if(s==="future"){const c=this.safeValue(this.options,s,{}),u=this.safeValue(c,"fetchBalance",{});r=this.safeString(u,"method","fapiPrivateV2GetAccount")}else if(s==="delivery"){const c=this.safeValue(this.options,s,{}),u=this.safeValue(c,"fetchBalance",{});r=this.safeString(u,"method","dapiPrivateGetAccount")}else if(s==="margin"||i==="cross")r="sapiGetMarginAccount";else if(s==="savings")r="sapiGetLendingUnionAccount";else if(s==="funding")r="sapiPostAssetGetFundingAsset";else if(i==="isolated"){r="sapiGetMarginIsolatedAccount";const c=this.safeValue(e,"symbols");if(c!==void 0){let u="";if(this.isArray(c)){u=this.marketId(c[0]);for(let h=1;h<c.length;h++){const l=c[h],p=this.marketId(l);u+=","+p}}else u=c;a.symbols=u}}const o=this.omit(n,["type","symbols"]),d=await this[r](this.extend(a,o));return this.parseBalance(d,s,i)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit=t);let r="publicGetDepth";i.linear?r="fapiPublicGetDepth":i.inverse&&(r="dapiPublicGetDepth");const a=await this[r](this.extend(n,s)),o=this.safeInteger(a,"T"),d=this.parseOrderBook(a,e,o);return d.nonce=this.safeInteger(a,"lastUpdateId"),d}parseTicker(e,t=void 0){const s=this.safeInteger(e,"closeTime"),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.safeString(e,"lastPrice"),a="baseVolume"in e;let o,d;return a?(o=this.safeString(e,"baseVolume"),d=this.safeString(e,"volume")):(o=this.safeString(e,"volume"),d=this.safeString(e,"quoteVolume")),this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"highPrice"),low:this.safeString(e,"lowPrice"),bid:this.safeString(e,"bidPrice"),bidVolume:this.safeString(e,"bidQty"),ask:this.safeString(e,"askPrice"),askVolume:this.safeString(e,"askQty"),vwap:this.safeString(e,"weightedAvgPrice"),open:this.safeString(e,"openPrice"),close:r,last:r,previousClose:this.safeString(e,"prevClosePrice"),change:this.safeString(e,"priceChange"),percentage:this.safeString(e,"priceChangePercent"),average:void 0,baseVolume:o,quoteVolume:d,info:e},t)}async fetchStatus(e={}){const t=await this.sapiGetSystemStatus(e),s=this.safeString(t,"status");return{status:this.safeString({0:"ok",1:"maintenance"},s,s),updated:void 0,eta:void 0,url:void 0,info:t}}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let n="publicGetTicker24hr";s.linear?n="fapiPublicGetTicker24hr":s.inverse&&(n="dapiPublicGetTicker24hr");const r=await this[n](this.extend(i,t));if(Array.isArray(r)){const a=this.safeValue(r,0,{});return this.parseTicker(a,s)}return this.parseTicker(r,s)}async fetchBidsAsks(e=void 0,t={}){await this.loadMarkets();const s=this.safeString2(this.options,"fetchBidsAsks","defaultType","spot"),i=this.safeString(t,"type",s),n=this.omit(t,"type");let r;i==="future"?r="fapiPublicGetTickerBookTicker":i==="delivery"?r="dapiPublicGetTickerBookTicker":r="publicGetTickerBookTicker";const a=await this[r](n);return this.parseTickers(a,e)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=this.safeString2(this.options,"fetchTickers","defaultType","spot"),i=this.safeString(t,"type",s),n=this.omit(t,"type");let r;i==="future"?r="fapiPublicGetTicker24hr":i==="delivery"?r="dapiPublicGetTicker24hr":r="publicGetTicker24hr";const a=this.safeString(this.options,"fetchTickersMethod",r),o=await this[a](n);return this.parseTickers(o,e)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=500,o=1500,d=this.safeString(n,"price"),c=this.safeInteger(n,"until");n=this.omit(n,["price","until"]),i=i===void 0?a:Math.min(i,o);const u={interval:this.timeframes[t],limit:i};if(d==="index"?u.pair=r.id:u.symbol=r.id,s!==void 0&&(u.startTime=s,r.inverse&&s>0)){const p=this.parseTimeframe(t),m=this.sum(s,i*p*1e3-1),g=this.milliseconds();u.endTime=Math.min(g,m)}c!==void 0&&(u.endTime=c);let h="publicGetKlines";d==="mark"?r.inverse?h="dapiPublicGetMarkPriceKlines":h="fapiPublicGetMarkPriceKlines":d==="index"?r.inverse?h="dapiPublicGetIndexPriceKlines":h="fapiPublicGetIndexPriceKlines":r.linear?h="fapiPublicGetKlines":r.inverse&&(h="dapiPublicGetKlines");const l=await this[h](this.extend(u,n));return this.parseOHLCVs(l,r,t,s,i)}parseTrade(e,t=void 0){if("isDustTrade"in e)return this.parseDustTrade(e,t);const s=this.safeInteger2(e,"T","time"),i=this.safeString2(e,"p","price"),n=this.safeString2(e,"q","qty"),r=this.safeString2(e,"quoteQty","baseQty"),a=this.safeString(e,"symbol"),o=this.safeSymbol(a,t);let d=this.safeString2(e,"t","a");d=this.safeString2(e,"id","tradeId",d);let c;const u=this.safeString(e,"orderId"),h=this.safeValue2(e,"m","isBuyerMaker");let l;h!==void 0?c=h?"sell":"buy":"side"in e?c=this.safeStringLower(e,"side"):"isBuyer"in e&&(c=e.isBuyer?"buy":"sell");let p;return"commission"in e&&(p={cost:this.safeString(e,"commission"),currency:this.safeCurrencyCode(this.safeString(e,"commissionAsset"))}),"isMaker"in e&&(l=e.isMaker?"maker":"taker"),"maker"in e&&(l=e.maker?"maker":"taker"),this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:o,id:d,order:u,type:void 0,side:c,takerOrMaker:l,price:i,amount:n,cost:r,fee:p},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id},[a,o]=this.handleMarketTypeAndParams("fetchTrades",n,i);let d;a==="future"?n.linear?d="fapiPublicGetAggTrades":n.inverse&&(d="dapiPublicGetAggTrades"):a==="delivery"?d="dapiPublicGetAggTrades":d="publicGetAggTrades";let c=this.safeString(this.options,"fetchTradesMethod",d);c==="publicGetAggTrades"?a==="future"?n.linear?c="fapiPublicGetAggTrades":n.inverse&&(c="dapiPublicGetAggTrades"):a==="delivery"&&(c="dapiPublicGetAggTrades"):c==="publicGetHistoricalTrades"&&(a==="future"?n.linear?c="fapiPublicGetHistoricalTrades":n.inverse&&(c="dapiPublicGetHistoricalTrades"):a==="delivery"&&(c="dapiPublicGetHistoricalTrades")),t!==void 0&&(r.startTime=t,r.endTime=this.sum(t,36e5)),s!==void 0&&(r.limit=s);const u=await this[c](this.extend(r,o));return this.parseTrades(u,n,t,s)}parseOrderStatus(e){const t={NEW:"open",PARTIALLY_FILLED:"open",FILLED:"closed",CANCELED:"canceled",PENDING_CANCEL:"canceling",REJECTED:"rejected",EXPIRED:"expired"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString(e,"status")),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.safeString(e,"executedQty","0");let a,o;"time"in e?a=this.safeInteger(e,"time"):"transactTime"in e?a=this.safeInteger(e,"transactTime"):"updateTime"in e&&s==="open"&&(_e.stringGt(r,"0")?o=this.safeInteger(e,"updateTime"):a=this.safeInteger(e,"updateTime"));const d=this.safeString(e,"avgPrice"),c=this.safeString(e,"price"),u=this.safeString(e,"origQty");let h=this.safeString2(e,"cummulativeQuoteQty","cumQuote");h=this.safeString(e,"cumBase",h);const l=this.safeString(e,"orderId");let p=this.safeStringLower(e,"type");const m=this.safeStringLower(e,"side"),g=this.safeValue(e,"fills",[]),y=this.safeString(e,"clientOrderId");let b=this.safeString(e,"timeInForce");b==="GTX"&&(b="PO");const w=p==="limit_maker"||b==="PO";p==="limit_maker"&&(p="limit");const k=this.safeString(e,"stopPrice"),T=this.parseNumber(this.omitZero(k));return this.safeOrder({info:e,id:l,clientOrderId:y,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:o,symbol:n,type:p,timeInForce:b,postOnly:w,reduceOnly:this.safeValue(e,"reduceOnly"),side:m,price:c,stopPrice:T,amount:u,cost:h,average:d,filled:r,remaining:void 0,status:s,fee:void 0,trades:g},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeString2(this.options,"createOrder","defaultType","spot"),d=this.safeString(r,"type",o),c=this.safeString2(r,"newClientOrderId","clientOrderId"),u=this.safeValue(r,"postOnly",!1),[h,l]=this.handleMarginModeAndParams("createOrder",r),p={symbol:a.id,side:s.toUpperCase()};let m="privatePostOrder";d==="future"?m="fapiPrivatePostOrder":d==="delivery"?m="dapiPrivatePostOrder":(d==="margin"||h!==void 0)&&(m="sapiPostMarginOrder",this.safeValue(r,"reduceOnly")&&(p.sideEffectType="AUTO_REPAY",r=this.omit(r,"reduceOnly"))),(a.spot||d==="margin")&&(this.safeValue(l,"test",!1)&&(m+="Test"),u&&(t="LIMIT_MAKER"));const g=t.toUpperCase();let y=g;p.type=y;const b=this.safeNumber(l,"stopPrice");b!==void 0&&(y==="MARKET"?y=a.contract?"STOP_MARKET":"STOP_LOSS":y==="LIMIT"&&(y=a.contract?"STOP":"STOP_LOSS_LIMIT"));const w=this.safeValue(a.info,"orderTypes");if(!this.inArray(y,w))throw g!==y?new Bs(this.id+" stopPrice parameter is not allowed for "+e+" "+t+" orders"):new Bs(this.id+" "+t+" is not a valid order type for the "+e+" market");if(h==="isolated"&&(p.isIsolated=!0),c===void 0){const P=this.safeValue(this.options,"broker");if(P!==void 0){const _=this.safeString(P,d);_!==void 0&&(p.newClientOrderId=_+this.uuid22())}}else p.newClientOrderId=c;d==="spot"||d==="margin"?p.newOrderRespType=this.safeValue(this.options.newOrderRespType,t,"RESULT"):p.newOrderRespType="RESULT";let k=!1,T=!1,O=!1,x=!1;if(y==="MARKET")if(a.spot)if(this.safeValue(this.options,"quoteOrderQty",!0)){const _=this.safeValue2(l,"quoteOrderQty","cost"),S=a.precision.price;if(_!==void 0)p.quoteOrderQty=this.decimalToPrecision(_,gf,S,this.precisionMode);else if(n!==void 0){const I=this.numberToString(i),v=this.numberToString(n),N=_e.stringMul(I,v);p.quoteOrderQty=this.decimalToPrecision(N,gf,S,this.precisionMode)}else x=!0}else x=!0;else x=!0;else if(y==="LIMIT")T=!0,k=!0,x=!0;else if(y==="STOP_LOSS"||y==="TAKE_PROFIT")O=!0,x=!0,(a.linear||a.inverse)&&(T=!0);else if(y==="STOP_LOSS_LIMIT"||y==="TAKE_PROFIT_LIMIT")x=!0,O=!0,T=!0,k=!0;else if(y==="LIMIT_MAKER")T=!0,x=!0;else if(y==="STOP")x=!0,O=!0,T=!0;else if(y==="STOP_MARKET"||y==="TAKE_PROFIT_MARKET")this.safeValue(l,"closePosition")===void 0&&(x=!0),O=!0;else if(y==="TRAILING_STOP_MARKET"&&(x=!0,this.safeNumber(l,"callbackRate")===void 0))throw new Bs(this.id+" createOrder() requires a callbackRate extra param for a "+t+" order");if(x&&(p.quantity=this.amountToPrecision(e,i)),T){if(n===void 0)throw new Bs(this.id+" createOrder() requires a price argument for a "+t+" order");p.price=this.priceToPrecision(e,n)}if(k&&(p.timeInForce=this.options.defaultTimeInForce),O){if(b===void 0)throw new Bs(this.id+" createOrder() requires a stopPrice extra param for a "+t+" order");p.stopPrice=this.priceToPrecision(e,b)}const C=this.omit(r,["quoteOrderQty","cost","stopPrice","test","type","newClientOrderId","clientOrderId","postOnly"]),E=await this[m](this.extend(p,C));return this.parseOrder(E,a)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new ri(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=this.safeString2(this.options,"fetchOrder","defaultType","spot"),r=this.safeString(s,"type",n),[a,o]=this.handleMarginModeAndParams("fetchOrder",s),d={symbol:i.id};let c="privateGetOrder";r==="future"?c="fapiPrivateGetOrder":r==="delivery"?c="dapiPrivateGetOrder":(r==="margin"||a!==void 0)&&(c="sapiGetMarginOrder",a==="isolated"&&(d.isIsolated=!0));const u=this.safeValue2(s,"origClientOrderId","clientOrderId");u!==void 0?d.origClientOrderId=u:d.orderId=e;const h=this.omit(o,["type","clientOrderId","origClientOrderId"]),l=await this[c](this.extend(d,h));return this.parseOrder(l,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new ri(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=this.safeString2(this.options,"fetchOrders","defaultType","spot"),a=this.safeString(i,"type",r),[o,d]=this.handleMarginModeAndParams("fetchOrders",i),c={symbol:n.id};let u="privateGetAllOrders";a==="future"?u="fapiPrivateGetAllOrders":a==="delivery"?u="dapiPrivateGetAllOrders":(a==="margin"||o!==void 0)&&(u="sapiGetMarginAllOrders",o==="isolated"&&(c.isIsolated=!0)),t!==void 0&&(c.startTime=t),s!==void 0&&(c.limit=s);const h=this.omit(d,["type"]),l=await this[u](this.extend(c,h));return this.parseOrders(l,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r;const a={},[o,d]=this.handleMarginModeAndParams("fetchOpenOrders",i);if(e!==void 0){n=this.market(e),a.symbol=n.id;const l=this.safeString2(this.options,"fetchOpenOrders","defaultType","spot"),p="type"in n?n.type:l;r=this.safeString(d,"type",p)}else if(this.options.warnOnFetchOpenOrdersWithoutSymbol){const p=this.symbols.length,m=parseInt(p/2);throw new ft(this.id+" fetchOpenOrders() WARNING: fetching open orders without specifying a symbol is rate-limited to one call per "+m.toString()+" seconds. Do not call this method frequently to avoid ban. Set "+this.id+'.options["warnOnFetchOpenOrdersWithoutSymbol"] = false to suppress this warning message.')}else{const l=this.safeString2(this.options,"fetchOpenOrders","defaultType","spot");r=this.safeString(d,"type",l)}const c=this.omit(d,"type");let u="privateGetOpenOrders";if(r==="future")u="fapiPrivateGetOpenOrders";else if(r==="delivery")u="dapiPrivateGetOpenOrders";else if((r==="margin"||o!==void 0)&&(u="sapiGetMarginOpenOrders",o==="isolated"&&(a.isIsolated=!0,e===void 0)))throw new ri(this.id+" fetchOpenOrders() requires a symbol argument for isolated markets");const h=await this[u](this.extend(a,c));return this.parseOrders(h,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n=await this.fetchOrders(e,t,s,i);return this.filterBy(n,"status","closed")}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new ri(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=this.safeString2(this.options,"cancelOrder","defaultType","spot"),r=this.safeString(s,"type",n),a=this.safeValue2(s,"origClientOrderId","clientOrderId"),[o,d]=this.handleMarginModeAndParams("cancelOrder",s),c={symbol:i.id};a===void 0?c.orderId=e:c.origClientOrderId=a;let u="privateDeleteOrder";if(r==="future")u="fapiPrivateDeleteOrder";else if(r==="delivery")u="dapiPrivateDeleteOrder";else if((r==="margin"||o!==void 0)&&(u="sapiDeleteMarginOrder",o==="isolated"&&(c.isIsolated=!0,t===void 0)))throw new ri(this.id+" cancelOrder() requires a symbol argument for isolated markets");const h=this.omit(d,["type","origClientOrderId","clientOrderId"]),l=await this[u](this.extend(c,h));return this.parseOrder(l,i)}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new ri(this.id+" cancelAllOrders () requires a symbol argument");await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=this.safeString2(this.options,"cancelAllOrders","defaultType","spot"),r=this.safeString(t,"type",n);t=this.omit(t,["type"]);const[a,o]=this.handleMarginModeAndParams("cancelAllOrders",t);let d="privateDeleteOpenOrders";r==="future"?d="fapiPrivateDeleteAllOpenOrders":r==="delivery"?d="dapiPrivateDeleteAllOpenOrders":(r==="margin"||a!==void 0)&&(d="sapiDeleteMarginOpenOrders",a==="isolated"&&(i.isIsolated=!0));const c=await this[d](this.extend(i,o));return Array.isArray(c)?this.parseOrders(c,s):c}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){if(t===void 0)throw new ri(this.id+" fetchOrderTrades() requires a symbol argument");await this.loadMarkets();const r=this.market(t),a=this.safeString(n,"type",r.type);if(n=this.omit(n,"type"),a!=="spot")throw new ai(this.id+" fetchOrderTrades() supports spot markets only");const o={orderId:e};return await this.fetchMyTrades(t,s,i,this.extend(o,n))}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new ri(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=this.safeString(i,"type",n.type);i=this.omit(i,"type");let o;const d=a==="future",c=a==="delivery";let u;[u,i]=this.handleMarginModeAndParams("fetchMyTrades",i),a==="spot"||a==="margin"?(o="privateGetMyTrades",(a==="margin"||u!==void 0)&&(o="sapiGetMarginMyTrades",u==="isolated"&&(r.isIsolated=!0))):d?o="fapiPrivateGetUserTrades":c&&(o="dapiPrivateGetUserTrades");let h=this.safeInteger2(i,"until","endTime");if(t!==void 0){const p=parseInt(t);r.startTime=p;const m=this.milliseconds(),g=7*24*60*60*1e3;m-p>=g&&h===void 0&&d&&(h=this.sum(p,g),h=Math.min(h,m))}h!==void 0&&(r.endTime=h,i=this.omit(i,["endTime","until"])),s!==void 0&&((a==="future"||a==="delivery")&&(s=Math.min(s,1e3)),r.limit=s);const l=await this[o](this.extend(r,i));return this.parseTrades(l,n,t,s)}async fetchMyDustTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.startTime=t,n.endTime=this.sum(t,7776e6));const r=await this.sapiGetAssetDribblet(this.extend(n,i)),a=this.safeValue(r,"userAssetDribblets",[]),o=this.safeInteger(r,"total",0),d=[];for(let u=0;u<o;u++){const h=this.safeValue(a[u],"userAssetDribbletDetails",[]);for(let l=0;l<h.length;l++)h[l].isDustTrade=!0,d.push(h[l])}const c=this.parseTrades(d,void 0,t,s);return this.filterBySinceLimit(c,t,s)}parseDustTrade(e,t=void 0){const s=this.safeString(e,"transId"),i=this.safeInteger(e,"operateTime"),n=this.safeString(e,"fromAsset"),r=this.safeCurrencyCode(n),o=this.currency("BNB").code,d=o+"/"+r;let c=!1;d in this.markets&&(c=!0);const u=this.safeString(e,"serviceChargeAmount"),h={currency:o,cost:this.parseNumber(u)};let l,p,m,g;c?(l=d,p=this.safeString(e,"transferedAmount"),m=this.safeString(e,"amount"),g="buy"):(l=r+"/"+o,p=this.safeString(e,"amount"),m=this.safeString(e,"transferedAmount"),g="sell");let y;m!==void 0&&p&&(y=_e.stringDiv(m,p));const b=void 0,w=this.parseNumber(p),k=this.parseNumber(y),T=this.parseNumber(m),O=void 0,x=void 0;return{id:b,timestamp:i,datetime:this.iso8601(i),symbol:l,order:s,type:O,takerOrMaker:x,side:g,amount:w,price:k,cost:T,fee:h,info:e}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r;const a={},o=this.safeValue(this.options,"legalMoney",{}),d=this.safeInteger(i,"until");if(e in o){e!==void 0&&(n=this.currency(e)),a.transactionType=0,t!==void 0&&(a.beginTime=t),d!==void 0&&(a.endTime=d);const c=await this.sapiGetFiatOrders(this.extend(a,i));r=this.safeValue(c,"data")}else{if(e!==void 0&&(n=this.currency(e),a.coin=n.id),t!==void 0){a.startTime=t;let c=this.sum(t,7776e6);d!==void 0&&(c=Math.min(c,d)),a.endTime=c}s!==void 0&&(a.limit=s),r=await this.sapiGetCapitalDepositHisrec(this.extend(a,i))}return this.parseTransactions(r,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeValue(this.options,"legalMoney",{}),r={};let a,o;if(e in n){e!==void 0&&(o=this.currency(e)),r.transactionType=1,t!==void 0&&(r.beginTime=t);const d=await this.sapiGetFiatOrders(this.extend(r,i));a=this.safeValue(d,"data")}else e!==void 0&&(o=this.currency(e),r.coin=o.id),t!==void 0&&(r.startTime=t,r.endTime=this.sum(t,7776e6)),s!==void 0&&(r.limit=s),a=await this.sapiGetCapitalWithdrawHistory(this.extend(r,i));return this.parseTransactions(a,o,t,s)}parseTransactionStatusByType(e,t=void 0){const s={deposit:{0:"pending",1:"ok",Processing:"pending",Failed:"failed",Successful:"ok",Refunding:"canceled",Refunded:"canceled","Refund Failed":"failed"},withdrawal:{0:"pending",1:"canceled",2:"pending",3:"failed",4:"pending",5:"failed",6:"ok",Processing:"pending",Failed:"failed",Successful:"ok",Refunding:"canceled",Refunded:"canceled","Refund Failed":"failed"}},i=this.safeValue(s,t,{});return this.safeString(i,e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"id","orderNo"),i=this.safeString(e,"address");let n=this.safeString(e,"addressTag");n!==void 0&&n.length<1&&(n=void 0);let r=this.safeString(e,"txId");r!==void 0&&r.indexOf("Internal transfer ")>=0&&(r=r.slice(18));const a=this.safeString2(e,"coin","fiatCurrency"),o=this.safeCurrencyCode(a,t);let d;const c=this.safeInteger2(e,"insertTime","createTime"),u=this.parse8601(this.safeString(e,"applyTime"));let h=this.safeString(e,"type");h===void 0&&(c!==void 0&&u===void 0?(h="deposit",d=c):c===void 0&&u!==void 0&&(h="withdrawal",d=u));const l=this.parseTransactionStatusByType(this.safeString(e,"status"),h),p=this.safeNumber(e,"amount"),m=this.safeNumber2(e,"transactionFee","totalFee");let g;m!==void 0&&(g={currency:o,cost:m});const y=this.safeInteger2(e,"successTime","updateTime");let b=this.safeInteger(e,"transferType");b!==void 0&&(b=!!b);const w=this.safeString(e,"network");return{info:e,id:s,txid:r,timestamp:d,datetime:this.iso8601(d),network:w,address:i,addressTo:i,addressFrom:void 0,tag:n,tagTo:n,tagFrom:void 0,type:h,amount:p,currency:o,status:l,updated:y,internal:b,fee:g}}parseTransferStatus(e){const t={CONFIRMED:"ok"};return this.safeString(t,e,e)}parseTransfer(e,t=void 0){const s=this.safeString(e,"tranId"),i=this.safeString(e,"asset"),n=this.safeCurrencyCode(i,t),r=this.safeNumber(e,"amount"),a=this.safeString(e,"type");let o,d;const c=this.safeValue(this.options,"accountsById",{});if(a!==void 0){const l=a.split("_");o=this.safeValue(l,0),d=this.safeValue(l,1),o=this.safeString(c,o,o),d=this.safeString(c,d,d)}const u=this.safeInteger(e,"timestamp"),h=this.parseTransferStatus(this.safeString(e,"status"));return{info:e,id:s,timestamp:u,datetime:this.iso8601(u),currency:n,amount:r,fromAccount:o,toAccount:d,status:h}}parseIncome(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeNumber(e,"income"),r=this.safeString(e,"asset"),a=this.safeCurrencyCode(r),o=this.safeString(e,"tranId"),d=this.safeInteger(e,"time");return{info:e,symbol:i,code:a,timestamp:d,datetime:this.iso8601(d),id:o,amount:n}}parseIncomes(e,t=void 0,s=void 0,i=void 0){const n=[];for(let a=0;a<e.length;a++){const o=e[a],d=this.parseIncome(o,t);n.push(d)}const r=this.sortBy(n,"timestamp");return this.filterBySinceLimit(r,s,i)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a={asset:r.id,amount:this.currencyToPrecision(e,t)};a.type=this.safeString(n,"type");let o="sapiPostAssetTransfer";if(a.type===void 0){const u=this.safeString(n,"symbol");u!==void 0&&(n=this.omit(n,"symbol"));let h=this.convertTypeToAccount(s).toUpperCase(),l=this.convertTypeToAccount(i).toUpperCase();if(h==="ISOLATED"){if(u===void 0)throw new ri(this.id+' transfer () requires params["symbol"] when fromAccount is '+s);h=this.marketId(u)}if(l==="ISOLATED"){if(u===void 0)throw new ri(this.id+' transfer () requires params["symbol"] when toAccount is '+i);l=this.marketId(u)}const p=this.safeValue(this.options,"accountsById",{}),m=!(h in p),g=!(l in p);if(m||g){const y=h==="UMFUTURE"||h==="CMFUTURE",b=l==="UMFUTURE"||l==="CMFUTURE",w=h==="MAIN",k=l==="MAIN";if((m||g)&&(y||b||(h==="MINING"||l==="MINING")||(h==="FUNDING"||l==="FUNDING")))throw new ye(this.id+" transfer () does not allow transfers between "+s+" and "+i);k&&m?(o="sapiPostMarginIsolatedTransfer",a.transFrom="ISOLATED_MARGIN",a.transTo="SPOT",a.symbol=h):w&&g?(o="sapiPostMarginIsolatedTransfer",a.transFrom="SPOT",a.transTo="ISOLATED_MARGIN",a.symbol=l):(m&&(a.fromSymbol=h,h="ISOLATEDMARGIN"),g&&(a.toSymbol=l,l="ISOLATEDMARGIN"),a.type=h+"_"+l)}else a.type=h+"_"+l}n=this.omit(n,"type");const d=await this[o](this.extend(a,n)),c=this.parseTransfer(d,r);return this.extend(c,{amount:t,currency:e,fromAccount:s,toAccount:i})}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r=this.safeString2(this.options,"fetchTransfers","defaultType","spot"),a=this.safeString(i,"fromAccount",r),o=a==="future"?"spot":"future",d=this.safeString(i,"toAccount",o);let c=this.safeString(i,"type");const u=this.safeValue(this.options,"accountsByType",{}),h=this.safeString(u,a),l=this.safeString(u,d);if(c===void 0){if(h===void 0){const y=Object.keys(u);throw new ft(this.id+" fromAccount parameter must be one of "+y.join(", "))}if(l===void 0){const y=Object.keys(u);throw new ft(this.id+" toAccount parameter must be one of "+y.join(", "))}c=h+"_"+l}const p={type:c};t!==void 0&&(p.startTime=t),s!==void 0&&(p.size=s);const m=await this.sapiGetAssetTransfer(this.extend(p,i)),g=this.safeValue(m,"rows",[]);return this.parseTransfers(g,n,t,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={coin:this.currency(e).id},n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper(t,"network");r=this.safeString(n,r,r),r!==void 0&&(i.network=r,t=this.omit(t,"network"));const a=await this.sapiGetCapitalDepositAddress(this.extend(i,t)),o=this.safeString(a,"address"),d=this.safeString(a,"url");let c;if(d!==void 0){const h=this.safeValue(this.options,"reverseNetworks",{}),l=d.split("/");let p=this.safeString(l,2);if(p==="blockchair.com"||p==="viewblock.io"){const g=this.safeString(l,3);g!==void 0&&(p=p+"/"+g)}c=this.safeString(h,p);const m=this.safeValue(this.options,"impliedNetworks",{ETH:{ERC20:"ETH"},TRX:{TRC20:"TRX"}});if(e in m){const g=this.safeValue(m,e,{});c=this.safeString(g,c,c)}}let u=this.safeString(a,"tag","");return u.length===0&&(u=void 0),this.checkAddress(o),{currency:e,address:o,tag:u,network:c,info:a}}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.sapiGetCapitalConfigGetall(t),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"coin"),o=this.safeCurrencyCode(a),d=this.safeValue(r,"networkList",[]);i[o]={};for(let c=0;c<d.length;c++){const u=d[c],h=this.safeString(u,"network"),l=this.safeCurrencyCode(h),p=this.safeNumber(u,"withdrawFee");i[o][l]=p}}return{withdraw:i,deposit:{},info:s}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={coin:r.id,address:s,amount:t};i!==void 0&&(a.addressTag=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeString(o,d,d),d!==void 0&&(a.network=d,n=this.omit(n,"network"));const c=await this.sapiPostCapitalWithdrawApply(this.extend(a,n));return this.parseTransaction(c,r)}parseTradingFee(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s);return{info:e,symbol:i,maker:this.safeNumber(e,"makerCommission"),taker:this.safeNumber(e,"takerCommission")}}async fetchTradingFee(e,t={}){await this.loadMarkets();const i={symbol:this.market(e).id},n=await this.sapiGetAssetTradeFee(this.extend(i,t)),r=this.safeValue(n,0,{});return this.parseTradingFee(r)}async fetchTradingFees(e={}){await this.loadMarkets();let t;const s=this.safeString2(this.options,"fetchTradingFees","defaultType","future"),i=this.safeString(e,"type",s),n=this.omit(e,"type");i==="spot"||i==="margin"?t="sapiGetAssetTradeFee":i==="future"?t="fapiPrivateGetAccount":i==="delivery"&&(t="dapiPrivateGetAccount");const r=await this[t](n);if(i==="spot"||i==="margin"){const a={};for(let o=0;o<r.length;o++){const d=this.parseTradingFee(r[o]),c=d.symbol;a[c]=d}return a}else if(i==="future"){const a=Object.keys(this.markets),o={},d=this.safeInteger(r,"feeTier"),c=this.fees[i].trading.tiers,u=c.maker[d][1],h=c.taker[d][1];for(let l=0;l<a.length;l++){const p=a[l];o[p]={info:{feeTier:d},symbol:p,maker:u,taker:h}}return o}else if(i==="delivery"){const a=Object.keys(this.markets),o={},d=this.safeInteger(r,"feeTier"),c=this.fees[i].trading.tiers,u=c.maker[d][1],h=c.taker[d][1];for(let l=0;l<a.length;l++){const p=a[l];o[p]={info:{feeTier:d},symbol:p,maker:u,taker:h}}return o}}async futuresTransfer(e,t,s,i={}){if(s<1||s>4)throw new ri(this.id+" type must be between 1 and 4");await this.loadMarkets();const n=this.currency(e),r={asset:n.id,amount:t,type:s},a=await this.sapiPostFuturesTransfer(this.extend(r,i));return this.parseTransfer(a,n)}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let n;if(s.linear)n="fapiPublicGetPremiumIndex";else if(s.inverse)n="dapiPublicGetPremiumIndex";else throw new ai(this.id+" fetchFundingRate() supports linear and inverse contracts only");let r=await this[n](this.extend(i,t));return s.inverse&&(r=r[0]),this.parseFundingRate(r,s)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;const a=this.safeString2(this.options,"fetchFundingRateHistory","defaultType","future"),o=this.safeString(i,"type",a);if(i=this.omit(i,"type"),o==="future"?r="fapiPublicGetFundingRate":o==="delivery"&&(r="dapiPublicGetFundingRate"),e!==void 0){const p=this.market(e);e=p.symbol,n.symbol=p.id,p.linear?r="fapiPublicGetFundingRate":p.inverse&&(r="dapiPublicGetFundingRate")}if(r===void 0)throw new ai(this.id+" fetchFundingRateHistory() is not supported for "+o+" markets");t!==void 0&&(n.startTime=t);const d=this.safeInteger2(i,"until","till"),c=this.safeInteger(i,"endTime",d);i=this.omit(i,["endTime","till","until"]),c!==void 0&&(n.endTime=c),s!==void 0&&(n.limit=s);const u=await this[r](this.extend(n,i)),h=[];for(let p=0;p<u.length;p++){const m=u[p],g=this.safeInteger(m,"fundingTime");h.push({info:m,symbol:this.safeSymbol(this.safeString(m,"symbol")),fundingRate:this.safeNumber(m,"fundingRate"),timestamp:g,datetime:this.iso8601(g)})}const l=this.sortBy(h,"timestamp");return this.filterBySymbolSinceLimit(l,e,t,s)}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s;const i=this.safeString2(this.options,"fetchFundingRates","defaultType","future"),n=this.safeString(t,"type",i),r=this.omit(t,"type");if(n==="future")s="fapiPublicGetPremiumIndex";else if(n==="delivery")s="dapiPublicGetPremiumIndex";else throw new ai(this.id+" fetchFundingRates() supports linear and inverse contracts only");const a=await this[s](r),o=[];for(let d=0;d<a.length;d++){const c=a[d],u=this.parseFundingRate(c);o.push(u)}return this.filterByArray(o,"symbol",e)}parseFundingRate(e,t=void 0){const s=this.safeInteger(e,"time"),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.safeNumber(e,"markPrice"),a=this.safeNumber(e,"indexPrice"),o=this.safeNumber(e,"interestRate"),d=this.safeNumber(e,"estimatedSettlePrice"),c=this.safeNumber(e,"lastFundingRate"),u=this.safeInteger(e,"nextFundingTime");return{info:e,symbol:n,markPrice:r,indexPrice:a,interestRate:o,estimatedSettlePrice:d,timestamp:s,datetime:this.iso8601(s),fundingRate:c,fundingTimestamp:u,fundingDatetime:this.iso8601(u),nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}parseAccountPositions(e){const t=this.safeValue(e,"positions"),s=this.safeValue(e,"assets",[]),i={};for(let r=0;r<s.length;r++){const a=s[r],o=this.safeString(a,"asset"),d=this.safeCurrencyCode(o),c=this.safeString(a,"crossWalletBalance"),u=this.safeString(a,"crossUnPnl");i[d]={crossMargin:_e.stringAdd(c,u),crossWalletBalance:c}}const n=[];for(let r=0;r<t.length;r++){const a=t[r],o=this.safeString(a,"symbol"),d=this.safeMarket(o),c=this.options.defaultType==="future"?d.quote:d.base;if(c in i){const u=this.parseAccountPosition(this.extend(a,{crossMargin:i[c].crossMargin,crossWalletBalance:i[c].crossWalletBalance}),d);n.push(u)}}return n}parseAccountPosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeString(t,"symbol"),n=this.safeString(e,"leverage"),r=parseInt(n),a=this.safeString(e,"initialMargin"),o=this.parseNumber(a);let d=_e.stringDiv("1",n,8);1e3%r===0||(d=_e.stringDiv(_e.stringAdd(d,"1e-8"),"1",8));const u="notional"in e,h=this.safeString(e,"maintMargin"),l=this.parseNumber(h),p=this.safeString(e,"entryPrice");let m=this.parseNumber(p);const g=this.safeString2(e,"notional","notionalValue"),y=_e.stringAbs(g),b=this.parseNumber(y);let w=this.safeString(e,"positionAmt"),k=_e.stringAbs(w);if(w===void 0){const Oe=_e.stringMul(_e.stringMul(n,a),p),Ce=this.safeString(t,"contractSize");w=_e.stringDiv(Oe,Ce),k=_e.stringDiv(_e.stringAdd(w,"0.5"),"1",0)}const T=this.parseNumber(k),O=this.safeValue(this.options,"leverageBrackets",{}),x=this.safeValue(O,i,[]);let C;for(let Oe=0;Oe<x.length;Oe++){const Ce=x[Oe];if(_e.stringLt(y,Ce[0]))break;C=Ce[1]}const E=this.parseNumber(C),P=this.safeString(e,"unrealizedProfit"),_=this.parseNumber(P);let S=this.safeInteger(e,"updateTime");S===0&&(S=void 0);const I=this.safeValue(e,"isolated");let v,N,q;I?(v="isolated",q=this.safeString(e,"isolatedWallet"),N=_e.stringAdd(q,P)):(v="cross",q=this.safeString(e,"crossWalletBalance"),N=this.safeString(e,"crossMargin"));const R=this.parseNumber(N);let G,F,A,V,Q;const J=this.safeValue(t,"contractSize"),se=this.numberToString(J);if(_e.stringEquals(g,"0"))m=void 0;else{if(F=_e.stringLt(g,"0")?"short":"long",G=this.parseNumber(_e.stringDiv(_e.stringAdd(_e.stringDiv(h,N),"5e-5"),"1",4)),A=this.parseNumber(_e.stringMul(_e.stringDiv(P,a,4),"100")),u){let U,H=p;F==="short"?U=_e.stringAdd("1",C):(U=_e.stringAdd("-1",C),H=_e.stringMul("-1",H));const W=_e.stringDiv(q,_e.stringMul(k,U)),Y=_e.stringDiv(H,U);V=_e.stringAdd(W,Y)}else{let U,H=p;F==="short"?U=_e.stringSub("1",C):(U=_e.stringSub("-1",C),H=_e.stringMul("-1",H));const W=_e.stringMul(k,se),Y=_e.stringMul(W,U),z=_e.stringSub(_e.stringMul(_e.stringDiv("1",H),W),q);V=_e.stringDiv(Y,z)}const Oe=t.precision.price,Le=(Oe+1).toString(),At=new _e("5e-"+Le).toString(),D=_e.stringAdd(At,V);let j=_e.stringDiv(D,"1",Oe);j[0]==="-"&&(j=void 0),Q=this.parseNumber(j)}const le=this.safeString(e,"positionSide")!=="BOTH";return{info:e,id:void 0,symbol:i,timestamp:S,datetime:this.iso8601(S),initialMargin:o,initialMarginPercentage:this.parseNumber(d),maintenanceMargin:l,maintenanceMarginPercentage:E,entryPrice:m,notional:b,leverage:this.parseNumber(n),unrealizedPnl:_,contracts:T,contractSize:J,marginRatio:G,liquidationPrice:Q,markPrice:void 0,collateral:R,marginMode:v,side:F,hedged:le,percentage:A}}parsePositionRisk(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeString(t,"symbol"),n=this.safeValue(this.options,"leverageBrackets",{}),r=this.safeValue(n,i,[]),a=this.safeString2(e,"notional","notionalValue"),o=_e.stringAbs(a);let d;for(let we=0;we<r.length;we++){const le=r[we];if(_e.stringLt(o,le[0]))break;d=le[1]}const c=this.parseNumber(o),u=_e.stringAbs(this.safeString(e,"positionAmt")),h=this.parseNumber(u),l=this.safeString(e,"unRealizedProfit"),p=this.parseNumber(l),m=this.safeString(e,"leverage"),g=parseInt(m),y=this.omitZero(this.safeString(e,"liquidationPrice")),b=this.parseNumber(y);let w;const k=this.safeString(e,"marginType");let T;_e.stringGt(a,"0")?T="long":_e.stringLt(a,"0")&&(T="short");const O=this.safeString(e,"entryPrice"),x=this.parseNumber(O),C=this.safeValue(t,"contractSize"),E=this.numberToString(C),P="notional"in e;if(k==="cross"){const we=this.safeValue(t,"precision",{});if(P){let le,Oe=O;T==="short"?(le=_e.stringAdd("1",d),Oe=_e.stringMul("-1",Oe)):le=_e.stringAdd("-1",d);const Ce=_e.stringMul(y,le),Le=_e.stringAdd(Ce,Oe),Fe=this.safeInteger(we,"price"),At=this.safeInteger(we,"quote",Fe);At!==void 0&&(w=_e.stringDiv(_e.stringMul(Le,u),"1",At))}else{let le,Oe=O;T==="short"?le=_e.stringSub("1",d):(le=_e.stringSub("-1",d),Oe=_e.stringMul("-1",Oe));const Ce=_e.stringMul(u,E),Le=_e.stringSub(_e.stringDiv("1",Oe),_e.stringDiv(le,y)),Fe=this.safeInteger(we,"base");Fe!==void 0&&(w=_e.stringDiv(_e.stringMul(Ce,Le),"1",Fe))}}else w=this.safeString(e,"isolatedMargin");w=w===void 0?"0":w;const _=this.parseNumber(w),S=this.parseNumber(this.omitZero(this.safeString(e,"markPrice")));let I=this.safeInteger(e,"updateTime");I===0&&(I=void 0);const v=this.parseNumber(d),N=_e.stringMul(d,o),q=this.parseNumber(N);let R=_e.stringDiv("1",m,8);1e3%g===0||(R=_e.stringAdd(R,"1e-8"));const F=_e.stringDiv(_e.stringMul(o,R),"1",8),A=this.parseNumber(F);let V,Q;_e.stringEquals(w,"0")||(V=this.parseNumber(_e.stringDiv(_e.stringAdd(_e.stringDiv(N,w),"5e-5"),"1",4)),Q=this.parseNumber(_e.stringMul(_e.stringDiv(l,F,4),"100")));const se=this.safeString(e,"positionSide")!=="BOTH";return{info:e,id:void 0,symbol:i,contracts:h,contractSize:C,unrealizedPnl:p,leverage:this.parseNumber(m),liquidationPrice:b,collateral:_,notional:c,markPrice:S,entryPrice:x,timestamp:I,initialMargin:A,initialMarginPercentage:this.parseNumber(R),maintenanceMargin:q,maintenanceMarginPercentage:v,marginRatio:V,datetime:this.iso8601(I),marginMode:k,marginType:k,side:T,hedged:se,percentage:Q}}async loadLeverageBrackets(e=!1,t={}){if(await this.loadMarkets(),this.safeValue(this.options,"leverageBrackets")===void 0||e){let i;const n=this.safeString(this.options,"defaultType","future"),r=this.safeString(t,"type",n),a=this.omit(t,"type");if(r==="future")i="fapiPrivateGetLeverageBracket";else if(r==="delivery")i="dapiPrivateV2GetLeverageBracket";else throw new ai(this.id+" loadLeverageBrackets() supports linear and inverse contracts only");const o=await this[i](a);this.options.leverageBrackets={};for(let d=0;d<o.length;d++){const c=o[d],u=this.safeString(c,"symbol"),h=this.safeSymbol(u),l=this.safeValue(c,"brackets",[]),p=[];for(let m=0;m<l.length;m++){const g=l[m],y=this.safeString2(g,"notionalFloor","qtyFloor"),b=this.safeString(g,"maintMarginRatio");p.push([y,b])}this.options.leverageBrackets[h]=p}}return this.options.leverageBrackets}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const[s,i]=this.handleMarketTypeAndParams("fetchLeverageTiers",void 0,t);let n;if(s==="future")n="fapiPrivateGetLeverageBracket";else if(s==="delivery")n="dapiPrivateV2GetLeverageBracket";else throw new ai(this.id+" fetchLeverageTiers() supports linear and inverse contracts only");const r=await this[n](i);return this.parseLeverageTiers(r,e,"symbol")}parseMarketLeverageTiers(e,t){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeValue(e,"brackets",[]),n=[];for(let r=0;r<i.length;r++){const a=i[r];n.push({tier:this.safeNumber(a,"bracket"),currency:t.quote,minNotional:this.safeNumber2(a,"notionalFloor","qtyFloor"),maxNotional:this.safeNumber2(a,"notionalCap","qtyCap"),maintenanceMarginRate:this.safeNumber(a,"maintMarginRatio"),maxLeverage:this.safeNumber(a,"initialLeverage"),info:a})}return n}async fetchPositions(e=void 0,t={}){const s=this.safeString(this.options,"fetchPositions","positionRisk");if(s==="positionRisk")return await this.fetchPositionsRisk(e,t);if(s==="account")return await this.fetchAccountPositions(e,t);throw new ai(this.id+'.options["fetchPositions"] = "'+s+'" is invalid, please choose between "account" and "positionRisk"')}async fetchAccountPositions(e=void 0,t={}){if(e!==void 0&&!Array.isArray(e))throw new ri(this.id+" fetchPositions() requires an array argument for symbols");await this.loadMarkets(),await this.loadLeverageBrackets(!1,t);let s;const i=this.safeString(this.options,"defaultType","future"),n=this.safeString(t,"type",i),r=this.omit(t,"type");if(n==="future")s="fapiPrivateGetAccount";else if(n==="delivery")s="dapiPrivateGetAccount";else throw new ai(this.id+" fetchPositions() supports linear and inverse contracts only");const a=await this[s](r),o=this.parseAccountPositions(a);return e=this.marketSymbols(e),this.filterByArray(o,"symbol",e,!1)}async fetchPositionsRisk(e=void 0,t={}){if(e!==void 0&&!Array.isArray(e))throw new ri(this.id+" fetchPositionsRisk() requires an array argument for symbols");await this.loadMarkets(),await this.loadLeverageBrackets(!1,t);const s={};let i,n="future";n=this.safeString(this.options,"defaultType",n);const r=this.safeString(t,"type",n);if(t=this.omit(t,"type"),r==="future"||r==="linear")i="fapiPrivateGetPositionRisk";else if(r==="delivery"||r==="inverse")i="dapiPrivateGetPositionRisk";else throw new ai(this.id+" fetchPositionsRisk() supports linear and inverse contracts only");const a=await this[i](this.extend(s,t)),o=[];for(let d=0;d<a.length;d++){const c=this.parsePositionRisk(a[d]);o.push(c)}return e=this.marketSymbols(e),this.filterByArray(o,"symbol",e,!1)}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r,a="future";const o={incomeType:"FUNDING_FEE"};if(e!==void 0)if(n=this.market(e),o.symbol=n.id,n.linear)a="future";else if(n.inverse)a="delivery";else throw new ai(this.id+" fetchFundingHistory() supports linear and inverse contracts only");t!==void 0&&(o.startTime=t),s!==void 0&&(o.limit=s),a=this.safeString2(this.options,"fetchFundingHistory","defaultType",a);const d=this.safeString(i,"type",a);if(i=this.omit(i,"type"),d==="future"||d==="linear")r="fapiPrivateGetIncome";else if(d==="delivery"||d==="inverse")r="dapiPrivateGetIncome";else throw new ai(this.id+" fetchFundingHistory() supports linear and inverse contracts only");const c=await this[r](this.extend(o,i));return this.parseIncomes(c,n,t,s)}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new ri(this.id+" setLeverage() requires a symbol argument");if(e<1||e>125)throw new ye(this.id+" leverage should be between 1 and 125");await this.loadMarkets();const i=this.market(t);let n;if(i.linear)n="fapiPrivatePostLeverage";else if(i.inverse)n="dapiPrivatePostLeverage";else throw new ai(this.id+" setLeverage() supports linear and inverse contracts only");const r={symbol:i.id,leverage:e};return await this[n](this.extend(r,s))}async setMarginMode(e,t=void 0,s={}){if(t===void 0)throw new ri(this.id+" setMarginMode() requires a symbol argument");if(e=e.toUpperCase(),e==="CROSS"&&(e="CROSSED"),e!=="ISOLATED"&&e!=="CROSSED")throw new ye(this.id+" marginMode must be either isolated or cross");await this.loadMarkets();const i=this.market(t);let n;if(i.linear)n="fapiPrivatePostMarginType";else if(i.inverse)n="dapiPrivatePostMarginType";else throw new ai(this.id+" setMarginMode() supports linear and inverse contracts only");const r={symbol:i.id,marginType:e};let a;try{a=await this[n](this.extend(r,s))}catch(o){if(o instanceof pk){if(this.safeValue(this.options,"throwMarginModeAlreadySet",!1))throw o;a={code:-4046,msg:"No need to change margin type."}}}return a}async setPositionMode(e,t=void 0,s={}){const i=this.safeString(this.options,"defaultType","future"),n=this.safeString(s,"type",i);s=this.omit(s,["type"]);let r;e?r="true":r="false";const a={dualSidePosition:r};let o;return n==="delivery"?o="dapiPrivatePostPositionSideDual":o="fapiPrivatePostPositionSideDual",await this[o](this.extend(a,s))}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){if(!(t in this.urls.api))throw new ai(this.id+" does not have a testnet/sandbox URL for "+t+" endpoints");let a=this.urls.api[t];if(a+="/"+e,t==="wapi"&&(a+=".html"),e==="historicalTrades")if(this.apiKey)n={"X-MBX-APIKEY":this.apiKey};else throw new Ds(this.id+" historicalTrades endpoint requires `apiKey` credential");if(e==="userDataStream"||e==="listenKey")if(this.apiKey)n={"X-MBX-APIKEY":this.apiKey,"Content-Type":"application/x-www-form-urlencoded"},s!=="GET"&&(r=this.urlencode(i));else throw new Ds(this.id+" userDataStream endpoint requires `apiKey` credential");else if(t==="private"||t==="eapiPrivate"||t==="sapi"&&e!=="system/status"||t==="sapiV3"||t==="wapi"&&e!=="systemStatus"||t==="dapiPrivate"||t==="dapiPrivateV2"||t==="fapiPrivate"||t==="fapiPrivateV2"){this.checkRequiredCredentials();let d;const c=this.safeInteger(this.options,"recvWindow"),u=this.extend({timestamp:this.nonce()},i);c!==void 0&&(u.recvWindow=c);const h=this.safeInteger(i,"recvWindow");h!==void 0&&(u.recvWindow=h),t==="sapi"&&e==="asset/dust"?d=this.urlencodeWithArrayRepeat(u):e==="batchOrders"||e.indexOf("sub-account")>=0||e==="capital/withdraw/apply"||e.indexOf("staking")>=0?d=this.rawencode(u):d=this.urlencode(u);const l=this.hmac(this.encode(d),this.encode(this.secret));d+="&signature="+l,n={"X-MBX-APIKEY":this.apiKey},s==="GET"||s==="DELETE"||t==="wapi"?a+="?"+d:(r=d,n["Content-Type"]="application/x-www-form-urlencoded")}else Object.keys(i).length&&(a+="?"+this.urlencode(i));return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(e===418||e===429)throw new ec(this.id+" "+e.toString()+" "+t+" "+r);if(e>=400){if(r.indexOf("Price * QTY is zero or less")>=0)throw new Bs(this.id+" order cost = amount * price is zero or less "+r);if(r.indexOf("LOT_SIZE")>=0)throw new Bs(this.id+" order amount should be evenly divisible by lot size "+r);if(r.indexOf("PRICE_FILTER")>=0)throw new Bs(this.id+" order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid value in general, use this.priceToPrecision (symbol, amount) "+r)}if(a===void 0)return;const c=this.safeValue(a,"success",!0);if(!c){const l=this.safeString(a,"msg");let p;if(l!==void 0){try{p=JSON.parse(l)}catch{p=void 0}p!==void 0&&(a=p)}}const u=this.safeString(a,"msg");u!==void 0&&(this.throwExactlyMatchedException(this.exceptions.exact,u,this.id+" "+u),this.throwBroadlyMatchedException(this.exceptions.broad,u,this.id+" "+u));const h=this.safeString(a,"code");if(h!==void 0){if(h==="200"||_e.stringEquals(h,"0"))return;if(h==="-2015"&&this.options.hasAlreadyAuthenticatedSuccessfully)throw new ec(this.id+" "+r);const l=this.id+" "+r;throw u==="No need to change margin type."?new pk(l):(this.throwExactlyMatchedException(this.exceptions.exact,h,l),new ft(l))}if(!c)throw new ft(this.id+" "+r)}calculateRateLimiterCost(e,t,s,i,n={},r={}){if("noCoin"in n&&!("coin"in i))return n.noCoin;if("noSymbol"in n&&!("symbol"in i))return n.noSymbol;if("noPoolId"in n&&!("poolId"in i))return n.noPoolId;if("byLimit"in n&&"limit"in i){const a=i.limit,o=n.byLimit;for(let d=0;d<o.length;d++){const c=o[d];if(a<=c[0])return c[1]}}return this.safeValue(n,"cost",1)}async request(e,t="public",s="GET",i={},n=void 0,r=void 0,a={},o={}){const d=await this.fetch2(e,t,s,i,n,r,a,o);return(t==="private"||t==="wapi")&&(this.options.hasAlreadyAuthenticatedSuccessfully=!0),d}async modifyMarginHelper(e,t,s,i={}){let n=this.safeString(this.options,"defaultType","future");n==="spot"&&(n="future");const r=this.safeString(i,"type",n);if(r==="margin"||r==="spot")throw new ai(this.id+" add / reduce margin only supported with type future or delivery");await this.loadMarkets();const a=this.market(e);t=this.amountToPrecision(e,t);const o={type:s,symbol:a.id,amount:t};let d,c;r==="future"?(d="fapiPrivatePostPositionMargin",c=a.quote):(d="dapiPrivatePostPositionMargin",c=a.base);const u=await this[d](this.extend(o,i));return this.extend(this.parseMarginModification(u,a),{code:c})}parseMarginModification(e,t=void 0){const i=this.safeInteger(e,"type")===1?"add":"reduce",n=this.safeNumber(e,"amount"),a=this.safeString(e,"code")==="200"?"ok":"failed";return{info:e,type:i,amount:n,code:void 0,symbol:t.symbol,status:a}}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,2,s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,1,s)}async fetchBorrowRate(e,t={}){await this.loadMarkets();const i={asset:this.currency(e).id},n=await this.sapiGetMarginInterestRateHistory(this.extend(i,t)),r=this.safeValue(n,0);return this.parseBorrowRate(r)}async fetchBorrowRateHistory(e,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),s===void 0)s=93;else if(s>93)throw new ye(this.id+" fetchBorrowRateHistory() limit parameter cannot exceed 92");const r={asset:this.currency(e).id,limit:s};if(t!==void 0){r.startTime=t;const o=this.sum(t,s*864e5)-1,d=this.milliseconds();r.endTime=Math.min(o,d)}const a=await this.sapiGetMarginInterestRateHistory(this.extend(r,i));return this.parseBorrowRateHistory(a)}parseBorrowRateHistory(e,t,s,i){const n=[];for(let a=0;a<e.length;a++){const o=e[a],d=this.parseBorrowRate(o);n.push(d)}const r=this.sortBy(n,"timestamp");return this.filterByCurrencySinceLimit(r,t,s,i)}parseBorrowRate(e,t=void 0){const s=this.safeNumber(e,"timestamp");return t=this.safeString(e,"asset"),{currency:this.safeCurrencyCode(t),rate:this.safeNumber(e,"dailyInterestRate"),period:864e5,timestamp:s,datetime:this.iso8601(s),info:e}}async createGiftCode(e,t,s={}){await this.loadMarkets();const n={token:this.currency(e).id,amount:t},r=await this.sapiPostGiftcardCreateCode(this.extend(n,s)),a=this.safeValue(r,"data"),o=this.safeString(a,"code"),d=this.safeString(a,"referenceNo");return{info:r,id:d,code:o,currency:e,amount:t}}async redeemGiftCode(e,t={}){const s={code:e};return await this.sapiPostGiftcardRedeemCode(this.extend(s,t))}async verifyGiftCode(e,t={}){const s={referenceNo:e};return await this.sapiGetGiftcardVerify(this.extend(s,t))}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a;if(e!==void 0){const u=this.currency(e);r.asset=u.id}s!==void 0&&(r.startTime=s),i!==void 0&&(r.size=i),t!==void 0&&(a=this.market(t),r.isolatedSymbol=a.id);const o=await this.sapiGetMarginInterestHistory(this.extend(r,n)),d=this.safeValue(o,"rows"),c=this.parseBorrowInterests(d,a);return this.filterByCurrencySinceLimit(c,e,s,i)}parseBorrowInterest(e,t){const s=this.safeString(e,"isolatedSymbol"),i=this.safeNumber(e,"interestAccuredTime");return{account:s===void 0?"cross":s,symbol:s,marginMode:s===void 0?"cross":"isolated",currency:this.safeCurrencyCode(this.safeString(e,"asset")),interest:this.safeNumber(e,"interest"),interestRate:this.safeNumber(e,"interestRate"),amountBorrowed:this.safeNumber(e,"principal"),timestamp:i,datetime:this.iso8601(i),info:e}}async repayMargin(e,t,s=void 0,i={}){const[n,r]=this.handleMarginModeAndParams("repayMargin",i);this.checkRequiredMarginArgument("repayMargin",s,n),await this.loadMarkets();const a=this.currency(e),o={asset:a.id,amount:this.currencyToPrecision(e,t)};if(s!==void 0){const c=this.market(s);o.symbol=c.id,o.isIsolated="TRUE"}const d=await this.sapiPostMarginRepay(this.extend(o,r));return this.parseMarginLoan(d,a)}async borrowMargin(e,t,s=void 0,i={}){const[n,r]=this.handleMarginModeAndParams("borrowMargin",i);this.checkRequiredMarginArgument("borrowMargin",s,n),await this.loadMarkets();const a=this.currency(e),o={asset:a.id,amount:this.currencyToPrecision(e,t)};if(s!==void 0){const c=this.market(s);o.symbol=c.id,o.isIsolated="TRUE"}const d=await this.sapiPostMarginLoan(this.extend(o,r));return this.parseMarginLoan(d,a)}parseMarginLoan(e,t=void 0){return{id:this.safeInteger(e,"tranId"),currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}async fetchOpenInterestHistory(e,t="5m",s=void 0,i=void 0,n={}){if(t==="1m")throw new ye(this.id+"fetchOpenInterestHistory cannot use the 1m timeframe");await this.loadMarkets();const r=this.market(e),a={period:this.timeframes[t]};i!==void 0&&(a.limit=i);const o=r.linear?"symbol":"pair";a[o]=r.id,r.delivery&&(a.contractType=this.safeString(n,"contractType","CURRENT_QUARTER")),s!==void 0&&(a.startTime=s);const d=this.safeInteger2(n,"until","till"),c=this.safeInteger(n,"endTime",d);if(n=this.omit(n,["endTime","until","till"]),c)a.endTime=c;else if(s){i===void 0&&(i=30);const l=this.parseTimeframe(t);a.endTime=this.sum(s,l*i*1e3)}let u="fapiDataGetOpenInterestHist";r.inverse&&(u="dapiDataGetOpenInterestHist");const h=await this[u](this.extend(a,n));return this.parseOpenInterests(h,e,s,i)}parseOpenInterest(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const n=this.safeNumber(e,"sumOpenInterest"),r=this.safeNumber(e,"sumOpenInterestValue");return{symbol:this.safeSymbol(i),baseVolume:n,quoteVolume:r,openInterestAmount:n,openInterestValue:r,timestamp:s,datetime:this.iso8601(s),info:e}}};const I4=Gu;var x4=class extends I4{describe(){return this.deepExtend(super.describe(),{id:"binancecoinm",name:"Binance COIN-M",urls:{logo:"https://user-images.githubusercontent.com/1294454/117738721-668c8d80-b205-11eb-8c49-3fad84c4a07f.jpg",doc:["https://binance-docs.github.io/apidocs/delivery/en/","https://binance-docs.github.io/apidocs/spot/en"]},has:{CORS:void 0,spot:!1,margin:!1,swap:!0,future:!0,option:void 0,createStopMarketOrder:!0},options:{defaultType:"delivery",leverageBrackets:void 0}})}async transferIn(e,t,s={}){return await this.futuresTransfer(e,t,3,s)}async transferOut(e,t,s={}){return await this.futuresTransfer(e,t,4,s)}};const _4=Gu;var C4=class extends _4{describe(){return this.deepExtend(super.describe(),{id:"binanceus",name:"Binance US",countries:["US"],certified:!1,pro:!0,urls:{logo:"https://user-images.githubusercontent.com/1294454/65177307-217b7c80-da5f-11e9-876e-0b748ba0a358.jpg",api:{web:"https://www.binance.us",sapi:"https://api.binance.us/sapi/v1",wapi:"https://api.binance.us/wapi/v3",public:"https://api.binance.us/api/v3",private:"https://api.binance.us/api/v3"},www:"https://www.binance.us",referral:"https://www.binance.us/?ref=35005074",doc:"https://github.com/binance-us/binance-official-api-docs",fees:"https://www.binance.us/en/fee/schedule"},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0.001")}},options:{quoteOrderQty:!1}})}};const M4=Gu;var P4=class extends M4{describe(){return this.deepExtend(super.describe(),{id:"binanceusdm",name:"Binance USD\u24C8-M",urls:{logo:"https://user-images.githubusercontent.com/1294454/117738721-668c8d80-b205-11eb-8c49-3fad84c4a07f.jpg",doc:["https://binance-docs.github.io/apidocs/futures/en/","https://binance-docs.github.io/apidocs/spot/en"]},has:{CORS:void 0,spot:!1,margin:!1,swap:!0,future:!0,option:void 0,createStopMarketOrder:!0},options:{defaultType:"future",leverageBrackets:void 0,marginTypes:{},marginModes:{}}})}async transferIn(e,t,s={}){return await this.futuresTransfer(e,t,1,s)}async transferOut(e,t,s={}){return await this.futuresTransfer(e,t,2,s)}};const A4=ge,{ArgumentsRequired:B4,ExchangeError:mk,InvalidNonce:E4,AuthenticationError:N4,PermissionDenied:V4,NotSupported:q4}=de,{TICK_SIZE:L4}=me,gk=Se;var R4=class extends A4{describe(){return this.deepExtend(super.describe(),{id:"bit2c",name:"Bit2C",countries:["IL"],rateLimit:3e3,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchDepositAddress:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766119-3593220e-5ece-11e7-8b3a-5a041f6bcc3f.jpg",api:{rest:"https://bit2c.co.il"},www:"https://www.bit2c.co.il",referral:"https://bit2c.co.il/Aff/63bfed10-e359-420c-ab5a-ad368dab0baf",doc:["https://www.bit2c.co.il/home/api","https://github.com/OferE/bit2c"]},api:{public:{get:["Exchanges/{pair}/Ticker","Exchanges/{pair}/orderbook","Exchanges/{pair}/trades","Exchanges/{pair}/lasttrades"]},private:{post:["Merchant/CreateCheckout","Funds/AddCoinFundsRequest","Order/AddFund","Order/AddOrder","Order/AddOrderMarketPriceBuy","Order/AddOrderMarketPriceSell","Order/CancelOrder","Order/AddCoinFundsRequest","Order/AddStopOrder","Payment/GetMyId","Payment/Send","Payment/Pay"],get:["Account/Balance","Account/Balance/v2","Order/MyOrders","Order/GetById","Order/AccountHistory","Order/OrderHistory"]}},markets:{"BTC/NIS":{id:"BtcNis",symbol:"BTC/NIS",base:"BTC",quote:"NIS",baseId:"Btc",quoteId:"Nis",type:"spot",spot:!0},"ETH/NIS":{id:"EthNis",symbol:"ETH/NIS",base:"ETH",quote:"NIS",baseId:"Eth",quoteId:"Nis",type:"spot",spot:!0},"LTC/NIS":{id:"LtcNis",symbol:"LTC/NIS",base:"LTC",quote:"NIS",baseId:"Ltc",quoteId:"Nis",type:"spot",spot:!0},"USDC/NIS":{id:"UsdcNis",symbol:"USDC/NIS",base:"USDC",quote:"NIS",baseId:"Usdc",quoteId:"Nis",type:"spot",spot:!0}},fees:{trading:{maker:this.parseNumber("0.005"),taker:this.parseNumber("0.005")}},options:{fetchTradesMethod:"public_get_exchanges_pair_trades"},precisionMode:L4,exceptions:{exact:{"Please provide valid APIkey":N4},broad:{"Please provide valid nonce":E4,"please approve new terms of use on site":V4}}})}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=Object.keys(this.currencies);for(let i=0;i<s.length;i++){const n=s[i],r=this.account(),o=this.currency(n).id.toUpperCase();o in e&&(r.free=this.safeString(e,"AVAILABLE_"+o),r.total=this.safeString(e,o)),t[n]=r}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountBalanceV2(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id},r=await this.publicGetExchangesPairOrderbook(this.extend(n,s));return this.parseOrderBook(r,i.symbol)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.milliseconds(),n=this.safeString(e,"av"),r=this.safeString(e,"a"),a=this.safeString(e,"ll");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:void 0,low:void 0,bid:this.safeString(e,"h"),bidVolume:void 0,ask:this.safeString(e,"l"),askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:n,baseVolume:r,quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetExchangesPairTicker(this.extend(i,t));return this.parseTicker(n,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r=this.options.fetchTradesMethod,a={pair:n.id};t!==void 0&&(a.date=parseInt(t)),s!==void 0&&(a.limit=s);const o=await this[r](this.extend(a,i));if(typeof o=="string")throw new mk(o);return this.parseTrades(o,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetAccountBalance(e),s=this.safeValue(t,"Fees",{}),i=Object.keys(s),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeSymbol(a),d=this.safeValue(s,a),c=this.safeString(d,"FeeMaker"),u=this.safeString(d,"FeeTaker"),h=this.parseNumber(gk.stringDiv(c,"100")),l=this.parseNumber(gk.stringDiv(u,"100"));n[o]={info:d,symbol:o,taker:l,maker:h,percentage:!0,tierBased:!1}}return n}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();let a="privatePostOrderAddOrder";const o=this.market(e),d={Amount:i,Pair:o.id};t==="market"?a+="MarketPrice"+this.capitalize(s):(d.Price=n,d.Total=i*n,d.IsBid=s==="buy");const c=await this[a](this.extend(d,r));return{info:c,id:c.NewOrder.id}}async cancelOrder(e,t=void 0,s={}){const i={id:e};return await this.privatePostOrderCancelOrder(this.extend(i,s))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new B4(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={pair:n.id},a=await this.privateGetOrderMyOrders(this.extend(r,i)),o=this.safeValue(a,n.id,{}),d=this.safeValue(o,"ask",[]),c=this.safeValue(o,"bid",[]);return this.parseOrders(this.arrayConcat(d,c),n,t,s)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"created"),i=this.safeString(e,"price"),n=this.safeString(e,"amount");t=this.safeMarket(void 0,t);let r=this.safeValue(e,"type");r===0?r="buy":r===1&&(r="sell");const a=this.safeString(e,"id"),o=this.safeString(e,"status");return this.safeOrder({id:a,clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,status:o,symbol:t.symbol,type:void 0,timeInForce:void 0,postOnly:void 0,side:r,price:i,stopPrice:void 0,amount:n,filled:void 0,remaining:void 0,cost:void 0,trades:void 0,fee:void 0,info:e,average:void 0},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};s!==void 0&&(r.take=s),r.take=s,t!==void 0&&(r.toTime=this.yyyymmdd(this.milliseconds(),"."),r.fromTime=this.yyyymmdd(t,".")),e!==void 0&&(n=this.market(e),r.pair=n.id);const a=await this.privateGetOrderOrderHistory(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseTrade(e,t=void 0){let s,i,n,r,a,o,d;const c=this.safeString(e,"reference");if(c!==void 0){s=this.safeTimestamp(e,"ticks"),n=this.safeString(e,"price"),r=this.safeString(e,"firstAmount");const u=c.split("|"),h=this.safeString(e,"pair");t=this.safeMarket(h,t),t=this.safeMarket(u[0],t),a=u[1],i=u[2],d=this.safeInteger(e,"action"),d===0?d="buy":d===1&&(d="sell");const l=this.safeString(e,"feeAmount");l!==void 0&&(o={cost:l,currency:"NIS"})}else s=this.safeTimestamp(e,"date"),i=this.safeString(e,"tid"),n=this.safeString(e,"price"),r=this.safeString(e,"amount"),d=this.safeValue(e,"isBid"),d!==void 0&&(d?d="buy":d="sell");return t=this.safeMarket(void 0,t),this.safeTrade({info:e,id:i,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:a,type:void 0,side:d,takerOrMaker:void 0,price:n,amount:r,cost:void 0,fee:o},t)}isFiat(e){return e==="NIS"}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e);if(this.isFiat(e))throw new q4(this.id+" fetchDepositAddress() does not support fiat currencies");const i={Coin:s.id},n=await this.privatePostFundsAddCoinFundsRequest(this.extend(i,t));return this.parseDepositAddress(n,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address");return this.checkAddress(s),{currency:this.safeCurrencyCode(void 0,t),network:void 0,address:s,tag:void 0,info:e}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.implodeParams(e,i);if(t==="public")a+=".json";else{this.checkRequiredCredentials();const o=this.nonce(),d=this.extend({nonce:o},i),c=this.urlencode(d);s==="GET"?Object.keys(d).length&&(a+="?"+c):r=c;const u=this.hmac(this.encode(c),this.encode(this.secret),"sha512","base64");n={"Content-Type":"application/x-www-form-urlencoded",key:this.apiKey,sign:u}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"error");if(c!==void 0){const u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u),new mk(u)}}};const F4=ge,{ExchangeError:Im,AuthenticationError:yf,InvalidNonce:D4,InsufficientFunds:H4,InvalidOrder:xm,OrderNotFound:bf,PermissionDenied:G4}=de,{TICK_SIZE:U4}=me;var $4=class extends F4{describe(){return this.deepExtend(super.describe(),{id:"bitbank",name:"bitbank",countries:["JP"],version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchDepositAddress:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","4h":"4hour","8h":"8hour","12h":"12hour","1d":"1day","1w":"1week"},hostname:"bitbank.cc",urls:{logo:"https://user-images.githubusercontent.com/1294454/37808081-b87f2d9c-2e59-11e8-894d-c1900b7584fe.jpg",api:{public:"https://public.{hostname}",private:"https://api.{hostname}",markets:"https://api.{hostname}"},www:"https://bitbank.cc/",doc:"https://docs.bitbank.cc/",fees:"https://bitbank.cc/docs/fees/"},api:{public:{get:["{pair}/ticker","{pair}/depth","{pair}/transactions","{pair}/transactions/{yyyymmdd}","{pair}/candlestick/{candletype}/{yyyymmdd}"]},private:{get:["user/assets","user/spot/order","user/spot/active_orders","user/spot/trade_history","user/withdrawal_account"],post:["user/spot/order","user/spot/cancel_order","user/spot/cancel_orders","user/spot/orders_info","user/request_withdrawal"]},markets:{get:["spot/pairs"]}},precisionMode:U4,exceptions:{20001:yf,20002:yf,20003:yf,20005:yf,20004:D4,40020:xm,40021:xm,40025:Im,40013:bf,40014:bf,50008:G4,50009:bf,50010:bf,60001:H4,60005:xm}})}async fetchMarkets(e={}){const t=await this.marketsGetSpotPairs(e),s=this.safeValue(t,"data"),i=this.safeValue(s,"pairs",[]),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"name"),d=this.safeString(a,"base_asset"),c=this.safeString(a,"quote_asset"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c);n.push({id:o,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:this.safeValue(a,"is_enabled"),contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(a,"taker_fee_rate_quote"),maker:this.safeNumber(a,"maker_fee_rate_quote"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(a,"amount_digits"))),price:this.parseNumber(this.parsePrecision(this.safeString(a,"price_digits")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(a,"unit_amount"),max:this.safeNumber(a,"limit_max_amount")},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:a})}return n}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeInteger(e,"timestamp"),n=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"vol"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetPairTicker(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTicker(r,s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id},r=await this.publicGetPairDepth(this.extend(n,s)),a=this.safeValue(r,"data",{}),o=this.safeInteger(a,"timestamp");return this.parseOrderBook(a,i.symbol,o)}parseTrade(e,t=void 0){const s=this.safeInteger(e,"executed_at");t=this.safeMarket(void 0,t);const i=this.safeString(e,"price"),n=this.safeString(e,"amount"),r=this.safeString2(e,"transaction_id","trade_id"),a=this.safeString(e,"maker_taker");let o;const d=this.safeString(e,"fee_amount_quote");d!==void 0&&(o={currency:t.quote,cost:d});const c=this.safeString(e,"order_id"),u=this.safeString(e,"type"),h=this.safeString(e,"side");return this.safeTrade({timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,id:r,order:c,type:u,side:h,takerOrMaker:a,price:i,amount:n,cost:void 0,fee:o,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id},a=await this.publicGetPairTransactions(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"transactions",[]);return this.parseTrades(d,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.marketsGetSpotPairs(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"pairs",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"name"),c=this.safeMarket(o).symbol;n[c]={info:a,symbol:c,maker:this.safeNumber(a,"maker_fee_rate_quote"),taker:this.safeNumber(a,"taker_fee_rate_quote"),percentage:!0,tierBased:!1}}return n}parseOHLCV(e,t=void 0){return[this.safeInteger(e,5),this.safeNumber(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){if(s===void 0){i===void 0&&(i=1e3);const l=this.parseTimeframe(t);s=this.milliseconds()-l*1e3*i}await this.loadMarkets();const r=this.market(e),a={pair:r.id,candletype:this.timeframes[t],yyyymmdd:this.yyyymmdd(s,"")},o=await this.publicGetPairCandlestickCandletypeYyyymmdd(this.extend(a,n)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"candlestick",[]),u=this.safeValue(c,0,{}),h=this.safeValue(u,"ohlcv",[]);return this.parseOHLCVs(h,r,t,s,i)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"data",{}),i=this.safeValue(s,"assets",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"asset"),o=this.safeCurrencyCode(a),d=this.account();d.free=this.safeString(r,"free_amount"),d.used=this.safeString(r,"locked_amount"),d.total=this.safeString(r,"onhand_amount"),t[o]=d}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetUserAssets(e);return this.parseBalance(t)}parseOrderStatus(e){const t={UNFILLED:"open",PARTIALLY_FILLED:"open",FULLY_FILLED:"closed",CANCELED_UNFILLED:"canceled",CANCELED_PARTIALLY_FILLED:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"order_id"),i=this.safeString(e,"pair");t=this.safeMarket(i,t);const n=this.safeInteger(e,"ordered_at"),r=this.safeString(e,"price"),a=this.safeString(e,"start_amount"),o=this.safeString(e,"executed_amount"),d=this.safeString(e,"remaining_amount"),c=this.safeString(e,"average_price"),u=this.parseOrderStatus(this.safeString(e,"status")),h=this.safeStringLower(e,"type"),l=this.safeStringLower(e,"side");return this.safeOrder({id:s,clientOrderId:void 0,datetime:this.iso8601(n),timestamp:n,lastTradeTimestamp:void 0,status:u,symbol:t.symbol,type:h,timeInForce:void 0,postOnly:void 0,side:l,price:r,stopPrice:void 0,cost:void 0,average:c,amount:a,filled:o,remaining:d,trades:void 0,fee:void 0,info:e},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={pair:a.id,amount:this.amountToPrecision(e,i),side:s,type:t};t==="limit"&&(o.price=this.priceToPrecision(e,n));const d=await this.privatePostUserSpotOrder(this.extend(o,r)),c=this.safeValue(d,"data");return this.parseOrder(c,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(t),n={order_id:e,pair:i.id},r=await this.privatePostUserSpotCancelOrder(this.extend(n,s));return this.safeValue(r,"data")}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(t),n={order_id:e,pair:i.id},r=await this.privateGetUserSpotOrder(this.extend(n,s)),a=this.safeValue(r,"data");return this.parseOrder(a,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id};s!==void 0&&(r.count=s),t!==void 0&&(r.since=parseInt(t/1e3));const a=await this.privateGetUserSpotActiveOrders(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"orders",[]);return this.parseOrders(d,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.pair=r.id),s!==void 0&&(n.count=s),t!==void 0&&(n.since=parseInt(t/1e3));const a=await this.privateGetUserSpotTradeHistory(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"trades",[]);return this.parseTrades(d,r,t,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={asset:s.id},n=await this.privateGetUserWithdrawalAccount(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"accounts",[]),o=this.safeValue(a,0,{}),d=this.safeString(o,"address");return{currency:s,address:d,tag:void 0,network:void 0,info:n}}async withdraw(e,t,s,i=void 0,n={}){if([i,n]=this.handleWithdrawTagAndParams(i,n),!("uuid"in n))throw new Im(this.id+" uuid is required for withdrawal");await this.loadMarkets();const r=this.currency(e),a={asset:r.id,amount:t},o=await this.privatePostUserRequestWithdrawal(this.extend(a,n)),d=this.safeValue(o,"data",{});return this.parseTransaction(d,r)}parseTransaction(e,t=void 0){const s=this.safeString(e,"txid");return t=this.safeCurrency(void 0,t),{id:s,txid:s,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0,info:e}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.omit(i,this.extractParams(e)),o=this.implodeHostname(this.urls.api[t])+"/";if(t==="public"||t==="markets")o+=this.implodeParams(e,i),Object.keys(a).length&&(o+="?"+this.urlencode(a));else{this.checkRequiredCredentials();const d=this.nonce().toString();let c=d;o+=this.version+"/"+this.implodeParams(e,i),s==="POST"?(r=this.json(a),c+=r):(c+="/"+this.version+"/"+e,Object.keys(a).length&&(a=this.urlencode(a),o+="?"+a,c+="?"+a)),n={"Content-Type":"application/json","ACCESS-KEY":this.apiKey,"ACCESS-NONCE":d,"ACCESS-SIGNATURE":this.hmac(this.encode(c),this.encode(this.secret))}}return{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeInteger(a,"success"),u=this.safeValue(a,"data");if(!c||!u){const h={1e4:"URL does not exist",10001:"A system error occurred. Please contact support",10002:"Invalid JSON format. Please check the contents of transmission",10003:"A system error occurred. Please contact support",10005:"A timeout error occurred. Please wait for a while and try again",20001:"API authentication failed",20002:"Illegal API key",20003:"API key does not exist",20004:"API Nonce does not exist",20005:"API signature does not exist",20011:"Two-step verification failed",20014:"SMS authentication failed",30001:"Please specify the order quantity",30006:"Please specify the order ID",30007:"Please specify the order ID array",30009:"Please specify the stock",30012:"Please specify the order price",30013:"Trade Please specify either",30015:"Please specify the order type",30016:"Please specify asset name",30019:"Please specify uuid",30039:"Please specify the amount to be withdrawn",40001:"The order quantity is invalid",40006:"Count value is invalid",40007:"End time is invalid",40008:"end_id Value is invalid",40009:"The from_id value is invalid",40013:"The order ID is invalid",40014:"The order ID array is invalid",40015:"Too many specified orders",40017:"Incorrect issue name",40020:"The order price is invalid",40021:"The trading classification is invalid",40022:"Start date is invalid",40024:"The order type is invalid",40025:"Incorrect asset name",40028:"uuid is invalid",40048:"The amount of withdrawal is illegal",50003:"Currently, this account is in a state where you can not perform the operation you specified. Please contact support",50004:"Currently, this account is temporarily registered. Please try again after registering your account",50005:"Currently, this account is locked. Please contact support",50006:"Currently, this account is locked. Please contact support",50008:"User identification has not been completed",50009:"Your order does not exist",50010:"Can not cancel specified order",50011:"API not found",60001:"The number of possessions is insufficient",60002:"It exceeds the quantity upper limit of the tender buying order",60003:"The specified quantity exceeds the limit",60004:"The specified quantity is below the threshold",60005:"The specified price is above the limit",60006:"The specified price is below the lower limit",70001:"A system error occurred. Please contact support",70002:"A system error occurred. Please contact support",70003:"A system error occurred. Please contact support",70004:"We are unable to accept orders as the transaction is currently suspended",70005:"Order can not be accepted because purchase order is currently suspended",70006:"We can not accept orders because we are currently unsubscribed ",70009:"We are currently temporarily restricting orders to be carried out. Please use the limit order.",70010:"We are temporarily raising the minimum order quantity as the system load is now rising."},l=this.exceptions,p=this.safeString(u,"code"),m=this.safeString(h,p,"Error"),g=this.safeValue(l,p);throw g!==void 0?new g(m):new Im(this.id+" "+this.json(a))}}};const j4=ge,{InvalidNonce:yk,InsufficientFunds:bk,AuthenticationError:_m,InvalidOrder:$r,ExchangeError:Dn,OrderNotFound:W4,AccountSuspended:z4,BadSymbol:K4,OrderImmediatelyFillable:X4,RateLimitExceeded:Y4,OnMaintenance:Q4,PermissionDenied:Z4}=de,{TICK_SIZE:J4}=me,wk=Se;var E_=class extends j4{describe(){return this.deepExtend(super.describe(),{id:"zonda",name:"Zonda",countries:["EE"],rateLimit:1e3,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!1,cancelOrder:!0,cancelOrders:!1,createDepositAddress:!1,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:!0,fetchDeposits:void 0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!1,fetchOpenOrders:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:void 0,fetchTransfer:!1,fetchWithdrawal:!1,fetchWithdrawals:void 0,reduceMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,setPositionMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"60","3m":"180","5m":"300","15m":"900","30m":"1800","1h":"3600","2h":"7200","4h":"14400","6h":"21600","12h":"43200","1d":"86400","3d":"259200","1w":"604800"},hostname:"zonda.exchange",urls:{referral:"https://auth.zondaglobal.com/ref/jHlbB4mIkdS1",logo:"https://user-images.githubusercontent.com/1294454/159202310-a0e38007-5e7c-4ba9-a32f-c8263a0291fe.jpg",www:"https://zondaglobal.com",api:{public:"https://{hostname}/API/Public",private:"https://{hostname}/API/Trading/tradingApi.php",v1_01Public:"https://api.{hostname}/rest",v1_01Private:"https://api.{hostname}/rest"},doc:["https://docs.zonda.exchange/","https://github.com/BitBayNet/API"],support:"https://zondaglobal.com/en/helpdesk/zonda-exchange",fees:"https://zondaglobal.com/legal/zonda-exchange/fees"},api:{public:{get:["{id}/all","{id}/market","{id}/orderbook","{id}/ticker","{id}/trades"]},private:{post:["info","trade","cancel","orderbook","orders","transfer","withdraw","history","transactions"]},v1_01Public:{get:["trading/ticker","trading/ticker/{symbol}","trading/stats","trading/stats/{symbol}","trading/orderbook/{symbol}","trading/transactions/{symbol}","trading/candle/history/{symbol}/{resolution}"]},v1_01Private:{get:["api_payments/deposits/crypto/addresses","payments/withdrawal/{detailId}","payments/deposit/{detailId}","trading/offer","trading/stop/offer","trading/config/{symbol}","trading/history/transactions","balances/BITBAY/history","balances/BITBAY/balance","fiat_cantor/rate/{baseId}/{quoteId}","fiat_cantor/history"],post:["trading/offer/{symbol}","trading/stop/offer/{symbol}","trading/config/{symbol}","balances/BITBAY/balance","balances/BITBAY/balance/transfer/{source}/{destination}","fiat_cantor/exchange"],delete:["trading/offer/{symbol}/{id}/{side}/{price}","trading/stop/offer/{symbol}/{id}/{side}/{price}"],put:["balances/BITBAY/balance/{id}"]}},fees:{trading:{maker:this.parseNumber("0.0"),taker:this.parseNumber("0.001"),percentage:!0,tierBased:!1},fiat:{maker:this.parseNumber("0.0030"),taker:this.parseNumber("0.0043"),percentage:!0,tierBased:!0,tiers:{taker:[[this.parseNumber("0.0043"),this.parseNumber("0")],[this.parseNumber("0.0042"),this.parseNumber("1250")],[this.parseNumber("0.0041"),this.parseNumber("3750")],[this.parseNumber("0.0040"),this.parseNumber("7500")],[this.parseNumber("0.0039"),this.parseNumber("10000")],[this.parseNumber("0.0038"),this.parseNumber("15000")],[this.parseNumber("0.0037"),this.parseNumber("20000")],[this.parseNumber("0.0036"),this.parseNumber("25000")],[this.parseNumber("0.0035"),this.parseNumber("37500")],[this.parseNumber("0.0034"),this.parseNumber("50000")],[this.parseNumber("0.0033"),this.parseNumber("75000")],[this.parseNumber("0.0032"),this.parseNumber("100000")],[this.parseNumber("0.0031"),this.parseNumber("150000")],[this.parseNumber("0.0030"),this.parseNumber("200000")],[this.parseNumber("0.0029"),this.parseNumber("250000")],[this.parseNumber("0.0028"),this.parseNumber("375000")],[this.parseNumber("0.0027"),this.parseNumber("500000")],[this.parseNumber("0.0026"),this.parseNumber("625000")],[this.parseNumber("0.0025"),this.parseNumber("875000")]],maker:[[this.parseNumber("0.0030"),this.parseNumber("0")],[this.parseNumber("0.0029"),this.parseNumber("1250")],[this.parseNumber("0.0028"),this.parseNumber("3750")],[this.parseNumber("0.0028"),this.parseNumber("7500")],[this.parseNumber("0.0027"),this.parseNumber("10000")],[this.parseNumber("0.0026"),this.parseNumber("15000")],[this.parseNumber("0.0025"),this.parseNumber("20000")],[this.parseNumber("0.0025"),this.parseNumber("25000")],[this.parseNumber("0.0024"),this.parseNumber("37500")],[this.parseNumber("0.0023"),this.parseNumber("50000")],[this.parseNumber("0.0023"),this.parseNumber("75000")],[this.parseNumber("0.0022"),this.parseNumber("100000")],[this.parseNumber("0.0021"),this.parseNumber("150000")],[this.parseNumber("0.0021"),this.parseNumber("200000")],[this.parseNumber("0.0020"),this.parseNumber("250000")],[this.parseNumber("0.0019"),this.parseNumber("375000")],[this.parseNumber("0.0018"),this.parseNumber("500000")],[this.parseNumber("0.0018"),this.parseNumber("625000")],[this.parseNumber("0.0017"),this.parseNumber("875000")]]}},funding:{withdraw:{}}},options:{fiatCurrencies:["EUR","USD","GBP","PLN"],transfer:{fillResponseFromRequest:!0}},precisionMode:J4,exceptions:{400:Dn,401:$r,402:$r,403:$r,404:$r,405:$r,406:bk,408:$r,501:_m,502:_m,503:yk,504:Dn,505:_m,506:z4,509:Dn,510:K4,FUNDS_NOT_SUFFICIENT:bk,OFFER_FUNDS_NOT_EXCEEDING_MINIMUMS:$r,OFFER_NOT_FOUND:W4,OFFER_WOULD_HAVE_BEEN_PARTIALLY_FILLED:X4,ACTION_LIMIT_EXCEEDED:Y4,UNDER_MAINTENANCE:Q4,REQUEST_TIMESTAMP_TOO_OLD:yk,PERMISSIONS_NOT_SUFFICIENT:Z4,INVALID_STOP_RATE:$r},commonCurrencies:{GGC:"Global Game Coin"}})}async fetchMarkets(e={}){const t=await this.v1_01PublicGetTradingTicker(e),s=this.safeValue(this.options,"fiatCurrencies",[]),i=[],n=this.safeValue(t,"items",{}),r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=n[o],c=this.safeValue(d,"market",{}),u=this.safeValue(c,"first",{}),h=this.safeValue(c,"second",{}),l=this.safeString(u,"currency"),p=this.safeString(h,"currency"),m=this.safeCurrencyCode(l),g=this.safeCurrencyCode(p);let y=this.safeValue(this.fees,"trading",{});(this.inArray(m,s)||this.inArray(g,s))&&(y=this.safeValue(this.fees,"fiat",{})),i.push({id:o,symbol:m+"/"+g,base:m,quote:g,settle:void 0,baseId:l,quoteId:p,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(y,"taker"),maker:this.safeNumber(y,"maker"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,optionType:void 0,strike:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(u,"scale"))),price:this.parseNumber(this.parsePrecision(this.safeString(h,"scale")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(u,"minOffer"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(h,"minOffer"),max:void 0}},info:d})}return i}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={},r=await this.v1_01PrivateGetTradingOffer(this.extend(n,i)),a=this.safeValue(r,"items",[]);return this.parseOrders(a,void 0,t,s,{status:"open"})}parseOrder(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeSymbol(s,t,"-"),n=this.safeInteger(e,"time"),r=this.safeString(e,"startAmount"),a=this.safeString(e,"currentAmount"),o=this.safeValue(e,"postOnly");return this.safeOrder({id:this.safeString(e,"id"),clientOrderId:void 0,info:e,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,status:void 0,symbol:i,type:this.safeString(e,"mode"),timeInForce:void 0,postOnly:o,side:this.safeStringLower(e,"offerType"),price:this.safeString(e,"rate"),stopPrice:void 0,amount:r,cost:void 0,filled:void 0,remaining:a,average:void 0,fee:void 0,trades:void 0},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};if(e){const c=[this.marketId(e)];e=this.symbol(e),n.markets=c}const r={query:this.json(this.extend(n,i))},a=await this.v1_01PrivateGetTradingHistoryTransactions(r),o=this.safeValue(a,"items"),d=this.parseTrades(o,void 0,t,s);return e===void 0?d:this.filterBySymbol(d,e)}parseBalance(e){const t=this.safeValue(e,"balances");if(t===void 0)throw new Dn(this.id+" empty balance response "+this.json(e));const s={info:e};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.used=this.safeString(n,"lockedFunds"),o.free=this.safeString(n,"availableFunds"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.v1_01PrivateGetBalancesBITBAYBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id},r=await this.v1_01PublicGetTradingOrderbookSymbol(this.extend(n,s)),a=this.safeValue(r,"buy",[]),o=this.safeValue(r,"sell",[]),d=this.safeInteger(r,"timestamp");return{symbol:i.symbol,bids:this.parseBidsAsks(a,"ra","ca"),asks:this.parseBidsAsks(o,"ra","ca"),timestamp:d,datetime:this.iso8601(d),nonce:this.safeInteger(r,"seqNo")}}parseTicker(e,t=void 0){const s=this.safeString(e,"r24h"),i=this.safeString(e,"h"),n=this.safeString(e,"l"),r=this.safeString(e,"v"),a=this.safeString(e,"m");t=this.safeMarket(a,t,"-");const o=t.symbol;return this.safeTicker({symbol:o,timestamp:void 0,datetime:void 0,high:i,low:n,bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:s,close:void 0,last:void 0,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.v1_01PublicGetTradingStatsSymbol(this.extend(i,t)),r=this.safeValue(n,"stats");return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.v1_01PublicGetTradingStats(t),i=this.safeValue(s,"items");return this.parseTickers(i,e)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){const n=[];if(e!==void 0){const d=this.currency(e);n.push(d.id)}let r={balanceCurrencies:n};t!==void 0&&(r.fromTime=t),s!==void 0&&(r.limit=s),r=this.extend(r,i);const o=(await this.v1_01PrivateGetBalancesBITBAYHistory({query:this.json(r)})).items;return this.parseLedger(o,void 0,t,s)}parseLedgerEntry(e,t=void 0){const s=this.safeInteger(e,"time"),i=this.safeValue(e,"balance",{}),n=this.safeString(i,"currency"),r=this.safeValue(e,"change",{});let a=this.safeString(r,"total"),o="in";wk.stringLt(a,"0")&&(o="out",a=wk.stringNeg(a));const d=this.safeValue(e,"fundsBefore",{}),c=this.safeValue(e,"fundsAfter",{});return{info:e,id:this.safeString(e,"historyId"),direction:o,account:void 0,referenceId:this.safeString(e,"detailId"),referenceAccount:void 0,type:this.parseLedgerEntryType(this.safeString(e,"type")),currency:this.safeCurrencyCode(n),amount:a,before:this.safeNumber(d,"total"),after:this.safeNumber(c,"total"),status:"ok",timestamp:s,datetime:this.iso8601(s),fee:void 0}}parseLedgerEntryType(e){const t={ADD_FUNDS:"transaction",BITCOIN_GOLD_FORK:"transaction",CREATE_BALANCE:"transaction",FUNDS_MIGRATION:"transaction",WITHDRAWAL_LOCK_FUNDS:"transaction",WITHDRAWAL_SUBTRACT_FUNDS:"transaction",WITHDRAWAL_UNLOCK_FUNDS:"transaction",TRANSACTION_COMMISSION_OUTCOME:"fee",TRANSACTION_COMMISSION_RETURN:"fee",TRANSACTION_OFFER_ABORTED_RETURN:"trade",TRANSACTION_OFFER_COMPLETED_RETURN:"trade",TRANSACTION_POST_INCOME:"trade",TRANSACTION_POST_OUTCOME:"trade",TRANSACTION_PRE_LOCKING:"trade"};return this.safeString(t,e,e)}parseOHLCV(e,t=void 0){const s=this.safeValue(e,1,{});return[this.safeInteger(e,0),this.safeNumber(s,"o"),this.safeNumber(s,"h"),this.safeNumber(s,"l"),this.safeNumber(s,"c"),this.safeNumber(s,"v")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),o={symbol:r.baseId+"-"+r.quoteId,resolution:this.timeframes[t]};i===void 0&&(i=100);const d=this.parseTimeframe(t),c=i*d*1e3;s===void 0?(o.to=this.milliseconds(),o.from=o.to-c):(o.from=parseInt(s),o.to=this.sum(o.from,c));const u=await this.v1_01PublicGetTradingCandleHistorySymbolResolution(this.extend(o,n)),h=this.safeValue(u,"items",[]);return this.parseOHLCVs(h,r,t,s,i)}parseTrade(e,t=void 0){const s=this.safeInteger2(e,"time","t"),i=this.safeStringLower2(e,"userAction","ty"),n=this.safeValue(e,"wasTaker");let r;n!==void 0&&(r=n?"taker":"maker");const a=this.safeString2(e,"rate","r"),o=this.safeString2(e,"amount","a"),d=this.safeString(e,"commissionValue"),c=this.safeString(e,"market");t=this.safeMarket(c,t,"-");const u=t.symbol;let h;d!==void 0&&(h={currency:i==="buy"?t.base:t.quote,cost:d});const l=this.safeString(e,"offerId");let p;return l!==void 0&&(p=l?"limit":"market"),this.safeTrade({id:this.safeString(e,"id"),order:l,timestamp:s,datetime:this.iso8601(s),symbol:u,type:p,side:i,price:a,amount:o,cost:void 0,takerOrMaker:r,fee:h,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),a={symbol:n.baseId+"-"+n.quoteId};t!==void 0&&(a.fromTime=t-1),s!==void 0&&(a.limit=s);const o=await this.v1_01PublicGetTradingTransactionsSymbol(this.extend(a,i)),d=this.safeValue(o,"items");return this.parseTrades(d,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=a.baseId+"-"+a.quoteId;i=parseFloat(this.amountToPrecision(e,i));const d={symbol:o,offerType:s.toUpperCase(),amount:i},c=this.safeValue2(r,"stopPrice","stopLossPrice"),u=c!==void 0,h=t==="limit",l=t==="market",p=t==="stop-limit"||h&&u,m=t==="stop-market"||l&&u,g=p||m,y=g?"v1_01PrivatePostTradingStopOfferSymbol":"v1_01PrivatePostTradingOfferSymbol";if(h||p)d.rate=this.priceToPrecision(e,n),d.mode=p?"stop-limit":"limit";else if(l||m)d.mode=m?"stop-market":"market";else throw new Dn(this.id+" createOrder() invalid type");if(g){if(!u)throw new Dn(this.id+" createOrder() zonda requires `triggerPrice` or `stopPrice` parameter for stop-limit or stop-market orders");d.stopRate=this.priceToPrecision(e,c)}r=this.omit(r,["stopPrice","stopLossPrice"]);const b=await this[y](this.extend(d,r)),w=this.safeString2(b,"offerId","stopOfferId"),T=this.safeValue(b,"completed",!1)?"closed":"open",O=this.safeValue(b,"transactions");return this.safeOrder({id:w,info:b,timestamp:void 0,datetime:void 0,lastTradeTimestamp:void 0,status:T,symbol:e,type:t,side:s,price:n,amount:i,cost:void 0,filled:void 0,remaining:void 0,average:void 0,fee:void 0,trades:O,clientOrderId:void 0})}async cancelOrder(e,t=void 0,s={}){const i=this.safeString(s,"side");if(i===void 0)throw new Dn(this.id+' cancelOrder() requires a `side` parameter ("buy" or "sell")');const n=this.safeValue(s,"price");if(n===void 0)throw new Dn(this.id+" cancelOrder() requires a `price` parameter (float or string)");await this.loadMarkets();const r=this.market(t),o={symbol:r.baseId+"-"+r.quoteId,id:e,side:i,price:n};return await this.v1_01PrivateDeleteTradingOfferSymbolIdSidePrice(this.extend(o,s))}isFiat(e){const t={USD:!0,EUR:!0,PLN:!0};return this.safeValue(t,e,!1)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"currency"),i=this.safeString(e,"address");return this.checkAddress(i),{currency:this.safeCurrencyCode(s,t),address:i,tag:this.safeString(e,"tag"),network:void 0,info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=await this.v1_01PrivateGetApiPaymentsDepositsCryptoAddresses(this.extend(i,t)),r=this.safeValue(n,"data"),a=this.safeValue(r,0);return this.parseDepositAddress(a,s)}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s=await this.v1_01PrivateGetApiPaymentsDepositsCryptoAddresses(t),i=this.safeValue(s,"data");return this.parseDepositAddresses(i,e)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a={source:s,destination:i,currency:e,funds:this.currencyToPrecision(e,t)},o=await this.v1_01PrivatePostBalancesBITBAYBalanceTransferSourceDestination(this.extend(a,n)),d=this.parseTransfer(o,r),c=this.safeValue(this.options,"transfer",{});return this.safeValue(c,"fillResponseFromRequest",!0)&&(d.amount=t),d}parseTransfer(e,t=void 0){const s=this.safeString(e,"status"),i=this.safeValue(e,"from",{}),n=this.safeString(i,"id"),r=this.safeValue(e,"to",{}),a=this.safeString(r,"id"),o=this.safeString(i,"currency");return{info:e,id:void 0,timestamp:void 0,datetime:void 0,currency:this.safeCurrencyCode(o,t),amount:void 0,fromAccount:n,toAccount:a,status:this.parseTransferStatus(s)}}parseTransferStatus(e){const t={Ok:"ok",Fail:"failed"};return this.safeString(t,e,e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();let r;const a=this.currency(e),o={currency:a.id,quantity:t};this.isFiat(e)?r="privatePostWithdraw":(r="privatePostTransfer",i!==void 0&&(s+="?dt="+i.toString()),o.address=s);const d=await this[r](this.extend(o,n)),c=this.safeValue(d,"data");return this.parseTransaction(c,a)}parseTransaction(e,t=void 0){return t=this.safeCurrency(void 0,t),{id:this.safeString(e,"id"),txid:void 0,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0,info:e}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.implodeHostname(this.urls.api[t]);if(t==="public"){const o=this.omit(i,this.extractParams(e));a+="/"+this.implodeParams(e,i)+".json",Object.keys(o).length&&(a+="?"+this.urlencode(o))}else if(t==="v1_01Public"){const o=this.omit(i,this.extractParams(e));a+="/"+this.implodeParams(e,i),Object.keys(o).length&&(a+="?"+this.urlencode(o))}else if(t==="v1_01Private"){this.checkRequiredCredentials();const o=this.omit(i,this.extractParams(e));a+="/"+this.implodeParams(e,i);const d=this.milliseconds().toString();let c;s!=="POST"?(Object.keys(o).length&&(a+="?"+this.urlencode(o)),c=this.apiKey+d):r===void 0&&(r=this.json(o),c=this.apiKey+d+r),n={"Request-Timestamp":d,"Operation-Id":this.uuid(),"API-Key":this.apiKey,"API-Hash":this.hmac(this.encode(c),this.encode(this.secret),"sha512"),"Content-Type":"application/json"}}else this.checkRequiredCredentials(),r=this.urlencode(this.extend({method:e,moment:this.nonce()},i)),n={"Content-Type":"application/x-www-form-urlencoded","API-Key":this.apiKey,"API-Hash":this.hmac(this.encode(r),this.encode(this.secret),"sha512")};return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0){if("code"in a){const c=this.safeString(a,"code"),u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions,c,u),new Dn(u)}else if("status"in a&&this.safeString(a,"status")==="Fail"){const u=this.safeValue(a,"errors"),h=this.id+" "+r;for(let l=0;l<u.length;l++){const p=u[l];this.throwExactlyMatchedException(this.exceptions,p,h)}throw new Dn(h)}}}};const e5=E_;var t5=class extends e5{describe(){return this.deepExtend(super.describe(),{id:"bitbay",alias:!0})}};const s5=ge,{ExchangeError:wf,ArgumentsRequired:Aa,InsufficientFunds:i5,OrderNotFound:n5,BadRequest:r5,BadSymbol:a5}=de,{TICK_SIZE:o5}=me,d5=Se;var c5=class extends s5{describe(){return this.deepExtend(super.describe(),{id:"bitbns",name:"Bitbns",countries:["IN"],rateLimit:1e3,certified:!1,pro:!1,version:"v2",has:{CORS:void 0,spot:!0,margin:void 0,swap:!1,future:!1,option:void 0,cancelOrder:!0,createOrder:!0,fetchBalance:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:void 0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:"emulated",fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,transfer:!1,withdraw:!1},timeframes:{},urls:{logo:"https://user-images.githubusercontent.com/1294454/117201933-e7a6e780-adf5-11eb-9d80-98fc2a21c3d6.jpg",api:{www:"https://bitbns.com",v1:"https://api.bitbns.com/api/trade/v1",v2:"https://api.bitbns.com/api/trade/v2"},www:"https://bitbns.com",referral:"https://ref.bitbns.com/1090961",doc:["https://bitbns.com/trade/#/api-trading/"],fees:"https://bitbns.com/fees"},api:{www:{get:["order/fetchMarkets","order/fetchTickers","order/fetchOrderbook","order/getTickerWithVolume","exchangeData/ohlc","exchangeData/orderBook","exchangeData/tradedetails"]},v1:{get:["platform/status","tickers","orderbook/sell/{symbol}","orderbook/buy/{symbol}"],post:["currentCoinBalance/EVERYTHING","getApiUsageStatus/USAGE","getOrderSocketToken/USAGE","currentCoinBalance/{symbol}","orderStatus/{symbol}","depositHistory/{symbol}","withdrawHistory/{symbol}","withdrawHistoryAll/{symbol}","depositHistoryAll/{symbol}","listOpenOrders/{symbol}","listOpenStopOrders/{symbol}","getCoinAddress/{symbol}","placeSellOrder/{symbol}","placeBuyOrder/{symbol}","buyStopLoss/{symbol}","sellStopLoss/{symbol}","placeSellOrder/{symbol}","cancelOrder/{symbol}","cancelStopLossOrder/{symbol}","listExecutedOrders/{symbol}","placeMarketOrder/{symbol}","placeMarketOrderQnty/{symbol}"]},v2:{post:["orders","cancel","getordersnew","marginOrders"]}},fees:{trading:{feeSide:"quote",tierBased:!1,percentage:!0,taker:this.parseNumber("0.0025"),maker:this.parseNumber("0.0025")}},precisionMode:o5,exceptions:{exact:{400:r5,409:a5,416:i5,417:n5},broad:{}}})}async fetchStatus(e={}){const t=await this.v1GetPlatformStatus(e),s=this.safeString(t,"status");return{status:this.safeString({1:"ok"},s,s),updated:void 0,eta:void 0,url:void 0,info:t}}async fetchMarkets(e={}){const t=await this.wwwGetOrderFetchMarkets(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"id"),a=this.safeString(n,"base"),o=this.safeString(n,"quote"),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o),u=this.safeValue(n,"precision",{}),h=this.safeValue(n,"limits",{}),l=this.safeValue(h,"amount",{}),p=this.safeValue(h,"price",{}),m=this.safeValue(h,"cost",{}),y=o==="USDT"?a+"_"+o:a;s.push({id:r,uppercaseId:y,symbol:d+"/"+c,base:d,quote:c,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(u,"amount"))),price:this.parseNumber(this.parsePrecision(this.safeString(u,"price")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(l,"min"),max:this.safeNumber(l,"max")},price:{min:this.safeNumber(p,"min"),max:this.safeNumber(p,"max")},cost:{min:this.safeNumber(m,"min"),max:this.safeNumber(m,"max")}},info:n})}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit=t);const r=await this.wwwGetOrderFetchOrderbook(this.extend(n,s)),a=this.safeInteger(r,"timestamp");return this.parseOrderBook(r,i.symbol,a)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.safeString(e,"last");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:this.safeString(e,"bidVolume"),ask:this.safeString(e,"ask"),askVolume:this.safeString(e,"askVolume"),vwap:this.safeString(e,"vwap"),open:this.safeString(e,"open"),close:r,last:r,previousClose:this.safeString(e,"previousClose"),change:this.safeString(e,"change"),percentage:this.safeString(e,"percentage"),average:this.safeString(e,"average"),baseVolume:this.safeString(e,"baseVolume"),quoteVolume:this.safeString(e,"quoteVolume"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.wwwGetOrderFetchTickers(t);return this.parseTickers(s,e)}parseBalance(e){const s={info:e,timestamp:void 0,datetime:this.iso8601(void 0)},i=this.safeValue(e,"data",{}),n=Object.keys(i);for(let r=0;r<n.length;r++){const a=n[r],o=a.split("availableorder");if(o.length>1){let c=this.safeString(o,1);c==="Money"&&(c="INR");const u=this.safeCurrencyCode(c),h=this.account();h.free=this.safeString(i,a),h.used=this.safeString(i,"inorder"+c),s[u]=h}}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.v1PostCurrentCoinBalanceEVERYTHING(e);return this.parseBalance(t)}parseOrderStatus(e){const t={0:"open"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString2(e,"id","entry_id"),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.parse8601(this.safeString(e,"time")),a=this.safeString(e,"rate"),o=this.safeString2(e,"amount","btc"),d=this.safeString(e,"filled"),c=this.safeString(e,"remaining"),u=this.safeString(e,"avg_cost"),h=this.safeString(e,"cost");let l=this.safeStringLower(e,"type");l==="0"&&(l="limit");const p=this.parseOrderStatus(this.safeString(e,"status")),m=this.safeStringLower(e,"side"),g=this.safeNumber(e,"fee");let y;return g!==void 0&&(y={cost:g,currency:void 0}),this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,symbol:n,type:l,timeInForce:void 0,postOnly:void 0,side:m,price:a,stopPrice:void 0,amount:o,cost:h,average:u,filled:d,remaining:c,status:p,fee:y,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){if(t!=="limit"&&t!=="market")throw new wf(this.id+" allows limit and market orders only");await this.loadMarkets();const a=this.market(e),o={side:s.toUpperCase(),symbol:a.uppercaseId,quantity:this.amountToPrecision(e,i)};let d="v2PostOrders";if(t==="limit")o.rate=this.priceToPrecision(e,n);else if(t==="market")d="v1PostPlaceMarketOrderQntySymbol",o.market=a.quoteId;else throw new wf(this.id+" allows limit and market orders only");const c=await this[d](this.extend(o,r));return this.parseOrder(c,a)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Aa(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=i.quoteId==="USDT"?"usdtcancelOrder":"cancelOrder",r={entry_id:e,symbol:i.uppercaseId,side:n},a=await this.v2PostCancel(this.extend(r,s));return this.parseOrder(a,i)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Aa(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={symbol:i.id,entry_id:e},r=await this.v1PostOrderStatusSymbol(this.extend(n,s)),a=this.safeValue(r,"data",[]),o=this.safeValue(a,0);return this.parseOrder(o,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Aa(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=n.quoteId==="USDT"?"usdtListOpenOrders":"listOpenOrders",a={symbol:n.uppercaseId,side:r,page:0},o=await this.v2PostGetordersnew(this.extend(a,i)),d=this.safeValue(o,"data",[]);return this.parseOrders(d,n,t,s)}parseTrade(e,t=void 0){t=this.safeMarket(void 0,t);const s=this.safeString2(e,"id","tradeId");let i=this.parse8601(this.safeString(e,"date"));i=this.safeInteger(e,"timestamp",i);const n=this.safeString2(e,"rate","price");let r=this.safeString(e,"amount"),a=this.safeStringLower(e,"type");a!==void 0&&(a.indexOf("buy")>=0?a="buy":a.indexOf("sell")>=0&&(a="sell"));const o=this.safeString(e,"factor");let d;o!==void 0?r=d5.stringDiv(r,o):(r=this.safeString(e,"base_volume"),d=this.safeString(e,"quote_volume"));const c=t.symbol;let u;const h=this.safeString(e,"fee");if(h!==void 0){const l=t.quote;u={cost:h,currency:l}}return this.safeTrade({info:e,timestamp:i,datetime:this.iso8601(i),symbol:c,id:s,order:s,type:void 0,side:a,takerOrMaker:void 0,price:n,amount:r,cost:d,fee:u},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Aa(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id,page:0};t!==void 0&&(r.since=this.iso8601(t));const a=await this.v1PostListExecutedOrdersSymbol(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){if(e===void 0)throw new Aa(this.id+" fetchTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={coin:n.baseId,market:n.quoteId},a=await this.wwwGetExchangeDataTradedetails(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Aa(this.id+" fetchDeposits() requires a currency code argument");await this.loadMarkets();const n=this.currency(e),r={symbol:n.id,page:0},a=await this.v1PostDepositHistorySymbol(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Aa(this.id+" fetchWithdrawals() requires a currency code argument");await this.loadMarkets();const n=this.currency(e),r={symbol:n.id,page:0},a=await this.v1PostWithdrawHistorySymbol(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s)}parseTransactionStatusByType(e,t=void 0){const s={deposit:{0:"pending",1:"ok"},withdrawal:{0:"pending",1:"canceled",2:"pending",3:"failed",4:"pending",5:"failed",6:"ok"}},i=this.safeValue(s,t,{});return this.safeString(i,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"unit"),i=this.safeCurrencyCode(s,t),n=this.parse8601(this.safeString2(e,"date","timestamp"));let r=this.safeString(e,"type");const a=this.safeString(e,"expTime","");let o;r!==void 0&&(r.indexOf("deposit")>=0?(r="deposit",o="ok"):(r.indexOf("withdraw")>=0||a.indexOf("withdraw")>=0)&&(r="withdrawal"));const d=this.safeNumber(e,"amount"),c=this.safeNumber(e,"fee");let u;return c!==void 0&&(u={currency:i,cost:c}),{info:e,id:void 0,txid:void 0,timestamp:n,datetime:this.iso8601(n),network:void 0,address:void 0,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:r,amount:d,currency:i,status:o,updated:void 0,internal:void 0,fee:u}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={symbol:this.currency(e).id},n=await this.v1PostGetCoinAddressSymbol(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeString(r,"token"),o=this.safeString(r,"tag");return this.checkAddress(a),{currency:e,address:a,tag:o,network:void 0,info:n}}nonce(){return this.milliseconds()}sign(e,t="www",s="GET",i={},n=void 0,r=void 0){if(!(t in this.urls.api))throw new wf(this.id+" does not have a testnet/sandbox URL for "+t+" endpoints");t!=="www"&&(this.checkRequiredCredentials(),n={"X-BITBNS-APIKEY":this.apiKey});let o=this.implodeHostname(this.urls.api[t])+"/"+this.implodeParams(e,i);const d=this.omit(i,this.extractParams(e)),c=this.nonce().toString();if(s==="GET")Object.keys(d).length&&(o+="?"+this.urlencode(d));else if(s==="POST"){Object.keys(d).length?r=this.json(d):r="{}";const u={timeStamp_nonce:c,body:r},h=this.stringToBase64(this.json(u)),l=this.hmac(h,this.encode(this.secret),"sha512");n["X-BITBNS-PAYLOAD"]=this.decode(h),n["X-BITBNS-SIGNATURE"]=l,n["Content-Type"]="application/x-www-form-urlencoded"}return{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"code"),u=this.safeString(a,"msg");if(c!==void 0&&c!=="200"&&c!=="204"||u!==void 0){const l=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,l),this.throwExactlyMatchedException(this.exceptions.exact,u,l),this.throwBroadlyMatchedException(this.exceptions.broad,u,l),new wf(l)}}};const u5=$l;var N_=class extends u5{describe(){return this.deepExtend(super.describe(),{id:"fmfwio",name:"FMFW.io",countries:["KN"],urls:{logo:"https://user-images.githubusercontent.com/1294454/159177712-b685b40c-5269-4cea-ac83-f7894c49525d.jpg",api:{public:"https://api.fmfw.io",private:"https://api.fmfw.io"},www:"https://fmfw.io",doc:"https://api.fmfw.io/api/2/explore/",fees:"https://fmfw.io/fees-and-limits",referral:"https://fmfw.io/referral/da948b21d6c92d69"},fees:{trading:{maker:this.parseNumber("0.005"),taker:this.parseNumber("0.005")}}})}};const f5=N_;var h5=class extends f5{describe(){return this.deepExtend(super.describe(),{id:"bitcoincom",alias:!0})}};const l5=ge,{NotSupported:p5,RateLimitExceeded:kk,AuthenticationError:Sk,PermissionDenied:m5,ArgumentsRequired:vk,ExchangeError:Ba,ExchangeNotAvailable:Tk,InsufficientFunds:Cm,InvalidOrder:sc,OrderNotFound:Ok,InvalidNonce:g5,BadSymbol:y5}=de,{SIGNIFICANT_DIGITS:b5,DECIMAL_PLACES:Ik,TRUNCATE:xk,ROUND:w5}=me,_k=Se;var V_=class extends l5{describe(){return this.deepExtend(super.describe(),{id:"bitfinex",name:"Bitfinex",countries:["VG"],version:"v1",rateLimit:666.666,pro:!0,has:{CORS:void 0,spot:!0,margin:void 0,swap:void 0,future:void 0,option:void 0,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,editOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchDepositAddress:!0,fetchDeposits:void 0,fetchIndexOHLCV:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFees:!0,fetchTransactions:!0,fetchWithdrawals:void 0,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","3h":"3h","4h":"4h","6h":"6h","12h":"12h","1d":"1D","1w":"7D","2w":"14D","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg",api:{v2:"https://api-pub.bitfinex.com",public:"https://api.bitfinex.com",private:"https://api.bitfinex.com"},www:"https://www.bitfinex.com",referral:"https://www.bitfinex.com/?refcode=P61eYxFL",doc:["https://docs.bitfinex.com/v1/docs","https://github.com/bitfinexcom/bitfinex-api-node"]},api:{v2:{get:{"platform/status":3,tickers:1,"ticker/{symbol}":1,"tickers/hist":1,"trades/{symbol}/hist":1,"book/{symbol}/{precision}":.375,"book/{symbol}/P0":.375,"book/{symbol}/P1":.375,"book/{symbol}/P2":.375,"book/{symbol}/P3":.375,"book/{symbol}/R0":.375,"stats1/{key}:{size}:{symbol}:{side}/{section}":1,"stats1/{key}:{size}:{symbol}/{section}":1,"stats1/{key}:{size}:{symbol}:long/last":1,"stats1/{key}:{size}:{symbol}:long/hist":1,"stats1/{key}:{size}:{symbol}:short/last":1,"stats1/{key}:{size}:{symbol}:short/hist":1,"candles/trade:{timeframe}:{symbol}/{section}":1,"candles/trade:{timeframe}:{symbol}/last":1,"candles/trade:{timeframe}:{symbol}/hist":1}},public:{get:{"book/{symbol}":1,"lendbook/{currency}":6,"lends/{currency}":3,"pubticker/{symbol}":3,"stats/{symbol}":6,symbols:18,symbols_details:18,tickers:1,"trades/{symbol}":3}},private:{post:{account_fees:18,account_infos:6,balances:9.036,basket_manage:6,credits:6,"deposit/new":18,"funding/close":6,history:6,"history/movements":6,key_info:6,margin_infos:3,mytrades:3,mytrades_funding:6,"offer/cancel":6,"offer/new":6,"offer/status":6,offers:6,"offers/hist":90.03,"order/cancel":.2,"order/cancel/all":.2,"order/cancel/multi":.2,"order/cancel/replace":.2,"order/new":.2,"order/new/multi":.2,"order/status":.2,orders:.2,"orders/hist":90.03,"position/claim":18,"position/close":18,positions:18,summary:18,taken_funds:6,total_taken_funds:6,transfer:18,unused_taken_funds:6,withdraw:18}}},fees:{trading:{feeSide:"get",tierBased:!0,percentage:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.002"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.002")],[this.parseNumber("500000"),this.parseNumber("0.002")],[this.parseNumber("1000000"),this.parseNumber("0.002")],[this.parseNumber("2500000"),this.parseNumber("0.002")],[this.parseNumber("5000000"),this.parseNumber("0.002")],[this.parseNumber("7500000"),this.parseNumber("0.002")],[this.parseNumber("10000000"),this.parseNumber("0.0018")],[this.parseNumber("15000000"),this.parseNumber("0.0016")],[this.parseNumber("20000000"),this.parseNumber("0.0014")],[this.parseNumber("25000000"),this.parseNumber("0.0012")],[this.parseNumber("30000000"),this.parseNumber("0.001")]],maker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("500000"),this.parseNumber("0.0008")],[this.parseNumber("1000000"),this.parseNumber("0.0006")],[this.parseNumber("2500000"),this.parseNumber("0.0004")],[this.parseNumber("5000000"),this.parseNumber("0.0002")],[this.parseNumber("7500000"),this.parseNumber("0")],[this.parseNumber("10000000"),this.parseNumber("0")],[this.parseNumber("15000000"),this.parseNumber("0")],[this.parseNumber("20000000"),this.parseNumber("0")],[this.parseNumber("25000000"),this.parseNumber("0")],[this.parseNumber("30000000"),this.parseNumber("0")]]}},funding:{tierBased:!1,percentage:!1,deposit:{},withdraw:{}}},commonCurrencies:{ALG:"ALGO",AMP:"AMPL",ATO:"ATOM",BCHABC:"XEC",BCHN:"BCH",DAT:"DATA",DOG:"MDOGE",DSH:"DASH",EDO:"PNT",EUS:"EURS",EUT:"EURT",IDX:"ID",IOT:"IOTA",IQX:"IQ",LUNA:"LUNC",LUNA2:"LUNA",MNA:"MANA",ORS:"ORS Group",PAS:"PASS",QSH:"QASH",QTM:"QTUM",RBT:"RBTC",SNG:"SNGLS",STJ:"STORJ",TERRAUST:"USTC",TSD:"TUSD",YGG:"YEED",YYW:"YOYOW",UDC:"USDC",UST:"USDT",VSY:"VSYS",WAX:"WAXP",XCH:"XCHF",ZBT:"ZB"},exceptions:{exact:{temporarily_unavailable:Tk,"Order could not be cancelled.":Ok,"No such order found.":Ok,"Order price must be positive.":sc,"Could not find a key matching the given X-BFX-APIKEY.":Sk,'Key price should be a decimal number, e.g. "123.456"':sc,'Key amount should be a decimal number, e.g. "123.456"':sc,ERR_RATE_LIMIT:kk,Ratelimit:kk,"Nonce is too small.":g5,"No summary found.":Ba,"Cannot evaluate your available balance, please try again":Tk,"Unknown symbol":y5,"Cannot complete transfer. Exchange balance insufficient.":Cm,"Momentary balance check. Please wait few seconds and try the transfer again.":Ba},broad:{"Invalid X-BFX-SIGNATURE":Sk,"This API key does not have permission":m5,"not enough exchange balance for ":Cm,"minimum size for ":sc,"Invalid order":sc,"The available balance is only":Cm}},precisionMode:b5,options:{currencyNames:{AGI:"agi",AID:"aid",AIO:"aio",ANT:"ant",AVT:"aventus",BAT:"bat",BCH:"bab",BCI:"bci",BFT:"bft",BSV:"bsv",BTC:"bitcoin",BTG:"bgold",CFI:"cfi",COMP:"comp",DAI:"dai",DADI:"dad",DASH:"dash",DATA:"datacoin",DTH:"dth",EDO:"eidoo",ELF:"elf",EOS:"eos",ETC:"ethereumc",ETH:"ethereum",ETP:"metaverse",FUN:"fun",GNT:"golem",IOST:"ios",IOTA:"iota",LEO:"let",LINK:"link",LRC:"lrc",LTC:"litecoin",LYM:"lym",MANA:"mna",MIT:"mit",MKR:"mkr",MTN:"mtn",NEO:"neo",ODE:"ode",OMG:"omisego",OMNI:"mastercoin",QASH:"qash",QTUM:"qtum",RCN:"rcn",RDN:"rdn",REP:"rep",REQ:"req",RLC:"rlc",SAN:"santiment",SNGLS:"sng",SNT:"status",SPANK:"spk",STORJ:"stj",TNB:"tnb",TRX:"trx",TUSD:"tsd",USD:"wire",USDC:"udc",UTK:"utk",USDT:"tetheruso",VEE:"vee",WAX:"wax",XLM:"xlm",XMR:"monero",XRP:"ripple",XVG:"xvg",YOYOW:"yoyow",ZEC:"zcash",ZRX:"zrx",XTZ:"xtz"},orderTypes:{limit:"exchange limit",market:"exchange market"},fiat:{USD:"USD",EUR:"EUR",JPY:"JPY",GBP:"GBP",CNH:"CNH"},accountsByType:{spot:"exchange",margin:"trading",funding:"deposit",swap:"trading"}}})}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s={},i=await this.privatePostAccountFees(t),n=this.safeValue(i,"withdraw"),r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeCurrencyCode(o);e!==void 0&&!this.inArray(d,e)||(s[d]={withdraw:this.safeNumber(n,o),deposit:{},info:this.safeNumber(n,o)})}return s}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostSummary(e),s={},i=this.safeValue(this.options,"fiat",{}),n=this.safeNumber(t,"maker_fee"),r=this.safeNumber(t,"taker_fee"),a=this.safeNumber(t,"maker_fee_2fiat"),o=this.safeNumber(t,"taker_fee_2fiat"),d=this.safeNumber(t,"maker_fee_2deriv"),c=this.safeNumber(t,"taker_fee_2deriv");for(let u=0;u<this.symbols.length;u++){const h=this.symbols[u],l=this.market(h),p={info:t,symbol:h,percentage:!0,tierBased:!0};l.quote in i?(p.maker=a,p.taker=o):l.contract?(p.maker=d,p.taker=c):(p.maker=n,p.taker=r),s[h]=p}return s}async fetchMarkets(e={}){const t=await this.publicGetSymbols(),s=await this.publicGetSymbolsDetails(),i=[];for(let n=0;n<s.length;n++){const r=s[n];let a=this.safeString(r,"pair");if(!this.inArray(a,t))continue;a=a.toUpperCase();let o,d;if(a.indexOf(":")>=0){const h=a.split(":");o=h[0],d=h[1]}else o=a.slice(0,3),d=a.slice(3,6);const c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d);i.push({id:a,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:this.safeValue(r,"margin"),swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:parseInt("8"),price:this.safeInteger(r,"price_precision")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"minimum_order_size"),max:this.safeNumber(r,"maximum_order_size")},price:{min:this.parseNumber("1e-8"),max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}amountToPrecision(e,t){return this.decimalToPrecision(t,xk,this.markets[e].precision.amount,Ik)}priceToPrecision(e,t){return t=this.decimalToPrecision(t,w5,this.markets[e].precision.price,this.precisionMode),this.decimalToPrecision(t,xk,8,Ik)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeValue(this.options,"accountsByType",{}),s=this.safeString(e,"type","exchange"),i=this.safeString(t,s,s);if(i===void 0){const d=Object.keys(t);throw new Ba(this.id+" fetchBalance() type parameter must be one of "+d.join(", "))}const n=this.omit(e,"type"),r=await this.privatePostBalances(n),a={info:r},o=s==="derivatives";for(let d=0;d<r.length;d++){const c=r[d],u=this.safeString(c,"type"),h=this.safeStringLower(c,"currency",""),l=h.length-2,p=h.slice(l)==="f0";if(i===u&&(!o||p)){const g=this.safeCurrencyCode(h);if(!(g in a)){const y=this.account();y.free=this.safeString(c,"available"),y.total=this.safeString(c,"amount"),a[g]=y}}}return this.safeBalance(a)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.safeValue(this.options,"accountsByType",{}),a=this.safeString(r,s,s),o=this.safeString(r,i,i),d=this.currency(e),c=this.convertDerivativesId(d.id,s),u=this.convertDerivativesId(d.id,i),h=this.currencyToPrecision(e,t),l={amount:h,currency:c,currency_to:u,walletfrom:a,walletto:o},p=await this.privatePostTransfer(this.extend(l,n)),m=this.safeValue(p,0);if(this.safeString(m,"message")===void 0)throw new Ba(this.id+" transfer failed");return this.extend(this.parseTransfer(m,d),{fromAccount:s,toAccount:i,amount:this.parseNumber(h)})}parseTransfer(e,t=void 0){const s=this.milliseconds();return{info:e,id:void 0,timestamp:s,datetime:this.iso8601(s),currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:this.parseTransferStatus(this.safeString(e,"status"))}}parseTransferStatus(e){const t={SUCCESS:"ok"};return this.safeString(t,e,e)}convertDerivativesId(e,t){const s=e.length-2,i=e.slice(s)==="F0";return t!=="derivatives"&&t!=="trading"&&t!=="margin"&&i?e=e.slice(0,s):t==="derivatives"&&!i&&(e=e+"F0"),e}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit_bids=t,n.limit_asks=t);const r=await this.publicGetBookSymbol(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"bids","asks","price","amount")}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTickers(t),i={};for(let n=0;n<s.length;n++){const r=this.parseTicker(s[n]),a=r.symbol;i[a]=r}return this.filterByArray(i,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetPubtickerSymbol(this.extend(i,t));return this.parseTicker(n,s)}parseTicker(e,t=void 0){const s=this.safeTimestamp(e,"timestamp");let i;if(t!==void 0)i=t.symbol;else if("pair"in e){const r=this.safeString(e,"pair");if(r!==void 0)if(r in this.markets_by_id)t=this.markets_by_id[r],i=t.symbol;else{const a=r.slice(0,3),o=r.slice(3,6),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o);i=d+"/"+c}}const n=this.safeString(e,"last_price");return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeString(e,"mid"),baseVolume:this.safeString(e,"volume"),quoteVolume:void 0,info:e},t)}parseTrade(e,t=void 0){const s=this.safeString(e,"tid"),i=this.safeTimestamp(e,"timestamp"),n=void 0,r=this.safeStringLower(e,"type"),a=this.safeString(e,"order_id"),o=this.safeString(e,"price"),d=this.safeString(e,"amount");let c;if("fee_amount"in e){const u=_k.stringNeg(this.safeString(e,"fee_amount")),h=this.safeString(e,"fee_currency"),l=this.safeCurrencyCode(h);c={cost:u,currency:l}}return this.safeTrade({id:s,info:e,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,type:n,order:a,side:r,takerOrMaker:void 0,price:o,amount:d,cost:void 0,fee:c},t)}async fetchTrades(e,t=void 0,s=50,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id,limit_trades:s};t!==void 0&&(r.timestamp=parseInt(t/1e3));const a=await this.publicGetTradesSymbol(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new vk(this.id+" fetchMyTrades() requires a `symbol` argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit_trades=s),t!==void 0&&(r.timestamp=parseInt(t/1e3));const a=await this.privatePostMytrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeValue(r,"postOnly",!1);r=this.omit(r,["postOnly"]);const d={symbol:a.id,side:s,amount:this.amountToPrecision(e,i),type:this.safeString(this.options.orderTypes,t,t),ocoorder:!1,buy_price_oco:0,sell_price_oco:0};t==="market"?d.price=this.nonce().toString():d.price=this.priceToPrecision(e,n),o&&(d.is_postonly=!0);const c=await this.privatePostOrderNew(this.extend(d,r));return this.parseOrder(c,a)}async editOrder(e,t,s,i,n=void 0,r=void 0,a={}){await this.loadMarkets();const o={order_id:parseInt(e)};r!==void 0&&(o.price=this.priceToPrecision(t,r)),n!==void 0&&(o.amount=this.numberToString(n)),t!==void 0&&(o.symbol=this.marketId(t)),i!==void 0&&(o.side=i),s!==void 0&&(o.type=this.safeString(this.options.orderTypes,s,s));const d=await this.privatePostOrderCancelReplace(this.extend(o,a));return this.parseOrder(d)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:parseInt(e)};return await this.privatePostOrderCancel(this.extend(i,s))}async cancelAllOrders(e=void 0,t={}){return await this.privatePostOrderCancelAll(t)}parseOrder(e,t=void 0){const s=this.safeString(e,"side"),i=this.safeValue(e,"is_live"),n=this.safeValue(e,"is_cancelled");let r;i?r="open":n?r="canceled":r="closed";const a=this.safeStringUpper(e,"symbol"),o=this.safeSymbol(a,t);let d=this.safeString(e,"type","");d.indexOf("exchange ")>=0&&(d=e.type.split(" ")[1]);const u=this.safeTimestamp(e,"timestamp"),h=this.safeString(e,"id");return this.safeOrder({info:e,id:h,clientOrderId:void 0,timestamp:u,datetime:this.iso8601(u),lastTradeTimestamp:void 0,symbol:o,type:d,timeInForce:void 0,postOnly:void 0,side:s,price:this.safeString(e,"price"),stopPrice:void 0,average:this.safeString(e,"avg_execution_price"),amount:this.safeString(e,"original_amount"),remaining:this.safeString(e,"remaining_amount"),filled:this.safeString(e,"executed_amount"),status:r,fee:void 0,cost:void 0,trades:void 0},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),e!==void 0&&!(e in this.markets))throw new Ba(this.id+" has no symbol "+e);const n=await this.privatePostOrders(i);let r=this.parseOrders(n,void 0,t,s);return e!==void 0&&(r=this.filterBy(r,"symbol",e)),r}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n={};s!==void 0&&(n.limit=s);const r=await this.privatePostOrdersHist(this.extend(n,i));let a=this.parseOrders(r,void 0,t,s);return e!==void 0&&(a=this.filterBy(a,"symbol",e)),a=this.filterByArray(a,"status",["closed","canceled"],!1),a}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:parseInt(e)},n=await this.privatePostOrderStatus(this.extend(i,s));return this.parseOrder(n)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets(),i===void 0&&(i=100);const r=this.market(e),o={symbol:"t"+r.id,timeframe:this.timeframes[t],sort:1,limit:i};s!==void 0&&(o.start=s);const d=await this.v2GetCandlesTradeTimeframeSymbolHist(this.extend(o,n));return this.parseOHLCVs(d,r,t,s,i)}getCurrencyName(e){if(e in this.options.currencyNames)return this.options.currencyNames[e];throw new p5(this.id+" "+e+" not supported for withdrawal")}async createDepositAddress(e,t={}){await this.loadMarkets();const s={renew:1};return await this.fetchDepositAddress(e,this.extend(s,t))}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={method:this.getCurrencyName(e),wallet_name:"exchange",renew:0},n=await this.privatePostDepositNew(this.extend(i,t));let r=this.safeValue(n,"address"),a;return"address_pool"in n&&(a=r,r=n.address_pool),this.checkAddress(r),{currency:e,address:r,tag:a,network:void 0,info:n}}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n=this.safeString(i,"currency");const r=this.omit(i,"currency");let a;if(n===void 0){if(e===void 0)throw new vk(this.id+" fetchTransactions() requires a currency `code` argument or a `currency` parameter");a=this.currency(e),n=a.id}r.currency=n,t!==void 0&&(r.since=parseInt(t/1e3));const o=await this.privatePostHistoryMovements(this.extend(r,i));return this.parseTransactions(o,a,t,s)}parseTransaction(e,t=void 0){const s=this.safeTimestamp(e,"timestamp_created"),i=this.safeTimestamp(e,"timestamp"),n=this.safeString(e,"currency"),r=this.safeCurrencyCode(n,t),a=this.safeStringLower(e,"type"),o=this.parseTransactionStatus(this.safeString(e,"status"));let d=this.safeString(e,"fee");d!==void 0&&(d=_k.stringAbs(d));const c=this.safeString(e,"description");return{info:e,id:this.safeString2(e,"id","withdrawal_id"),txid:this.safeString(e,"txid"),timestamp:s,datetime:this.iso8601(s),network:void 0,address:this.safeString(e,"address"),addressTo:void 0,addressFrom:void 0,tag:c,tagTo:void 0,tagFrom:void 0,type:a,amount:this.safeNumber(e,"amount"),currency:r,status:o,updated:i,fee:{currency:r,cost:this.parseNumber(d),rate:void 0}}}parseTransactionStatus(e){const t={SENDING:"pending",CANCELED:"canceled",ZEROCONFIRMED:"failed",COMPLETED:"ok"};return this.safeString(t,e,e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.getCurrencyName(e),a=this.currency(e),o={withdraw_type:r,walletselected:"exchange",amount:this.numberToString(t),address:s};i!==void 0&&(o.payment_id=i);const d=await this.privatePostWithdraw(this.extend(o,n)),c=this.safeValue(d,0,{}),u=this.safeNumber(c,"withdrawal_id"),h=this.safeString(c,"message"),l=this.findBroadlyMatchedKey(this.exceptions.broad,h);if(u===0){if(l!==void 0){const p=this.exceptions.broad[l];throw new p(this.id+" "+h)}throw new Ba(this.id+" withdraw returned an id of zero: "+this.json(c))}return this.parseTransaction(c,a)}async fetchPositions(e=void 0,t={}){return await this.loadMarkets(),await this.privatePostPositions(t)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.implodeParams(e,i);t==="v2"?a="/"+t+a:a="/"+this.version+a;let o=this.omit(i,this.extractParams(e)),d=this.urls.api[t]+a;if((t==="public"||e.indexOf("/hist")>=0)&&Object.keys(o).length){const c="?"+this.urlencode(o);d+=c,a+=c}if(t==="private"){this.checkRequiredCredentials();const c=this.nonce();o=this.extend({nonce:c.toString(),request:a},o),r=this.json(o);const u=this.stringToBase64(r),h=this.encode(this.secret),l=this.hmac(u,h,"sha384");n={"X-BFX-APIKEY":this.apiKey,"X-BFX-PAYLOAD":this.decode(u),"X-BFX-SIGNATURE":l,"Content-Type":"application/json"}}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;let c=!1;if(e>=400)this.safeString(r,0)==="{"&&(c=!0);else{const u=this.safeValue(a,0,{});this.safeString(u,"status","")==="error"&&(c=!0)}if(c){const u=this.id+" "+r,h=this.safeString2(a,"message","error");throw this.throwExactlyMatchedException(this.exceptions.exact,h,u),this.throwBroadlyMatchedException(this.exceptions.broad,h,u),new Ba(u)}}};const k5=ge,{ExchangeError:Ea,InvalidAddress:S5,ArgumentsRequired:ic,InsufficientFunds:Ck,AuthenticationError:v5,OrderNotFound:Mm,InvalidOrder:kf,BadRequest:T5,InvalidNonce:O5,BadSymbol:I5,OnMaintenance:x5,NotSupported:Mk,PermissionDenied:_5,ExchangeNotAvailable:C5}=de,Xi=Se,{SIGNIFICANT_DIGITS:M5,DECIMAL_PLACES:Pk,TRUNCATE:Ak,ROUND:P5}=me;var q_=class extends k5{describe(){return this.deepExtend(super.describe(),{id:"bitfinex2",name:"Bitfinex",countries:["VG"],version:"v2",certified:!1,pro:!1,has:{CORS:void 0,spot:!0,margin:void 0,swap:void 0,future:void 0,option:void 0,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createLimitOrder:!0,createMarketOrder:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:void 0,fetchBalance:!0,fetchClosedOrder:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchIndexOHLCV:!1,fetchLedger:!0,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrder:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderTrades:!0,fetchPositionMode:!1,fetchStatus:!0,fetchTickers:!0,fetchTime:!1,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFees:void 0,fetchTransactions:!0,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","3h":"3h","4h":"4h","6h":"6h","12h":"12h","1d":"1D","1w":"7D","2w":"14D","1M":"1M"},rateLimit:250,urls:{logo:"https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg",api:{v1:"https://api.bitfinex.com",public:"https://api-pub.bitfinex.com",private:"https://api.bitfinex.com"},www:"https://www.bitfinex.com",doc:["https://docs.bitfinex.com/v2/docs/","https://github.com/bitfinexcom/bitfinex-api-node"],fees:"https://www.bitfinex.com/fees"},api:{public:{get:{"conf/{config}":2.66,"conf/pub:{action}:{object}":2.66,"conf/pub:{action}:{object}:{detail}":2.66,"conf/pub:map:{object}":2.66,"conf/pub:map:{object}:{detail}":2.66,"conf/pub:map:currency:{detail}":2.66,"conf/pub:map:currency:sym":2.66,"conf/pub:map:currency:label":2.66,"conf/pub:map:currency:unit":2.66,"conf/pub:map:currency:undl":2.66,"conf/pub:map:currency:pool":2.66,"conf/pub:map:currency:explorer":2.66,"conf/pub:map:currency:tx:fee":2.66,"conf/pub:map:tx:method":2.66,"conf/pub:list:{object}":2.66,"conf/pub:list:{object}:{detail}":2.66,"conf/pub:list:currency":2.66,"conf/pub:list:pair:exchange":2.66,"conf/pub:list:pair:margin":2.66,"conf/pub:list:pair:futures":2.66,"conf/pub:list:competitions":2.66,"conf/pub:info:{object}":2.66,"conf/pub:info:{object}:{detail}":2.66,"conf/pub:info:pair":2.66,"conf/pub:info:pair:futures":2.66,"conf/pub:info:tx:status":2.66,"conf/pub:fees":2.66,"platform/status":8,tickers:2.66,"ticker/{symbol}":2.66,"tickers/hist":2.66,"trades/{symbol}/hist":2.66,"book/{symbol}/{precision}":1,"book/{symbol}/P0":1,"book/{symbol}/P1":1,"book/{symbol}/P2":1,"book/{symbol}/P3":1,"book/{symbol}/R0":1,"stats1/{key}:{size}:{symbol}:{side}/{section}":2.66,"stats1/{key}:{size}:{symbol}:{side}/last":2.66,"stats1/{key}:{size}:{symbol}:{side}/hist":2.66,"stats1/{key}:{size}:{symbol}/{section}":2.66,"stats1/{key}:{size}:{symbol}/last":2.66,"stats1/{key}:{size}:{symbol}/hist":2.66,"stats1/{key}:{size}:{symbol}:long/last":2.66,"stats1/{key}:{size}:{symbol}:long/hist":2.66,"stats1/{key}:{size}:{symbol}:short/last":2.66,"stats1/{key}:{size}:{symbol}:short/hist":2.66,"candles/trade:{timeframe}:{symbol}:{period}/{section}":2.66,"candles/trade:{timeframe}:{symbol}/{section}":2.66,"candles/trade:{timeframe}:{symbol}/last":2.66,"candles/trade:{timeframe}:{symbol}/hist":2.66,"status/{type}":2.66,"status/deriv":2.66,"liquidations/hist":80,"rankings/{key}:{timeframe}:{symbol}/{section}":2.66,"rankings/{key}:{timeframe}:{symbol}/hist":2.66,"pulse/hist":2.66,"pulse/profile/{nickname}":2.66,"funding/stats/{symbol}/hist":10},post:{"calc/trade/avg":2.66,"calc/fx":2.66}},private:{post:{"auth/r/wallets":2.66,"auth/r/wallets/hist":2.66,"auth/r/orders":2.66,"auth/r/orders/{symbol}":2.66,"auth/w/order/submit":2.66,"auth/w/order/update":2.66,"auth/w/order/cancel":2.66,"auth/w/order/multi":2.66,"auth/w/order/cancel/multi":2.66,"auth/r/orders/{symbol}/hist":2.66,"auth/r/orders/hist":2.66,"auth/r/order/{symbol}:{id}/trades":2.66,"auth/r/trades/{symbol}/hist":2.66,"auth/r/trades/hist":2.66,"auth/r/ledgers/{currency}/hist":2.66,"auth/r/ledgers/hist":2.66,"auth/r/info/margin/{key}":2.66,"auth/r/info/margin/base":2.66,"auth/r/info/margin/sym_all":2.66,"auth/r/positions":2.66,"auth/w/position/claim":2.66,"auth/w/position/increase:":2.66,"auth/r/position/increase/info":2.66,"auth/r/positions/hist":2.66,"auth/r/positions/audit":2.66,"auth/r/positions/snap":2.66,"auth/w/deriv/collateral/set":2.66,"auth/w/deriv/collateral/limits":2.66,"auth/r/funding/offers":2.66,"auth/r/funding/offers/{symbol}":2.66,"auth/w/funding/offer/submit":2.66,"auth/w/funding/offer/cancel":2.66,"auth/w/funding/offer/cancel/all":2.66,"auth/w/funding/close":2.66,"auth/w/funding/auto":2.66,"auth/w/funding/keep":2.66,"auth/r/funding/offers/{symbol}/hist":2.66,"auth/r/funding/offers/hist":2.66,"auth/r/funding/loans":2.66,"auth/r/funding/loans/hist":2.66,"auth/r/funding/loans/{symbol}":2.66,"auth/r/funding/loans/{symbol}/hist":2.66,"auth/r/funding/credits":2.66,"auth/r/funding/credits/hist":2.66,"auth/r/funding/credits/{symbol}":2.66,"auth/r/funding/credits/{symbol}/hist":2.66,"auth/r/funding/trades/{symbol}/hist":2.66,"auth/r/funding/trades/hist":2.66,"auth/r/info/funding/{key}":2.66,"auth/r/info/user":2.66,"auth/r/summary":2.66,"auth/r/logins/hist":2.66,"auth/r/permissions":2.66,"auth/w/token":2.66,"auth/r/audit/hist":2.66,"auth/w/transfer":2.66,"auth/w/deposit/address":24,"auth/w/deposit/invoice":24,"auth/w/withdraw":24,"auth/r/movements/{currency}/hist":2.66,"auth/r/movements/hist":2.66,"auth/r/alerts":5.33,"auth/w/alert/set":2.66,"auth/w/alert/price:{symbol}:{price}/del":2.66,"auth/w/alert/{type}:{symbol}:{price}/del":2.66,"auth/calc/order/avail":2.66,"auth/w/settings/set":2.66,"auth/r/settings":2.66,"auth/w/settings/del":2.66,"auth/r/pulse/hist":2.66,"auth/w/pulse/add":16,"auth/w/pulse/del":2.66}}},fees:{trading:{feeSide:"get",percentage:!0,tierBased:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.002"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.002")],[this.parseNumber("500000"),this.parseNumber("0.002")],[this.parseNumber("1000000"),this.parseNumber("0.002")],[this.parseNumber("2500000"),this.parseNumber("0.002")],[this.parseNumber("5000000"),this.parseNumber("0.002")],[this.parseNumber("7500000"),this.parseNumber("0.002")],[this.parseNumber("10000000"),this.parseNumber("0.0018")],[this.parseNumber("15000000"),this.parseNumber("0.0016")],[this.parseNumber("20000000"),this.parseNumber("0.0014")],[this.parseNumber("25000000"),this.parseNumber("0.0012")],[this.parseNumber("30000000"),this.parseNumber("0.001")]],maker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("500000"),this.parseNumber("0.0008")],[this.parseNumber("1000000"),this.parseNumber("0.0006")],[this.parseNumber("2500000"),this.parseNumber("0.0004")],[this.parseNumber("5000000"),this.parseNumber("0.0002")],[this.parseNumber("7500000"),this.parseNumber("0")],[this.parseNumber("10000000"),this.parseNumber("0")],[this.parseNumber("15000000"),this.parseNumber("0")],[this.parseNumber("20000000"),this.parseNumber("0")],[this.parseNumber("25000000"),this.parseNumber("0")],[this.parseNumber("30000000"),this.parseNumber("0")]]}},funding:{withdraw:{}}},precisionMode:M5,options:{precision:"R0",exchangeTypes:{"EXCHANGE MARKET":"market","EXCHANGE LIMIT":"limit","EXCHANGE STOP":"market","EXCHANGE FOK":"limit","EXCHANGE STOP LIMIT":"limit","EXCHANGE IOC":"limit"},orderTypes:{market:"EXCHANGE MARKET",limit:"EXCHANGE LIMIT"},fiat:{USD:"USD",EUR:"EUR",JPY:"JPY",GBP:"GBP",CHN:"CHN"},v2AccountsByType:{spot:"exchange",exchange:"exchange",funding:"funding",margin:"margin",derivatives:"margin",future:"margin"}},exceptions:{exact:{10001:_5,10020:T5,10100:v5,10114:O5,20060:x5,temporarily_unavailable:C5},broad:{address:S5,"available balance is only":Ck,"not enough exchange balance":Ck,"Order not found":Mm,"symbol: invalid":I5,"Invalid order":kf}},commonCurrencies:{UST:"USDT",EUTF0:"EURT",USTF0:"USDT",ALG:"ALGO",AMP:"AMPL",ATO:"ATOM",BCHABC:"XEC",BCHN:"BCH",DAT:"DATA",DOG:"MDOGE",DSH:"DASH",EDO:"PNT",EUS:"EURS",EUT:"EURT",IDX:"ID",IOT:"IOTA",IQX:"IQ",LUNA:"LUNC",LUNA2:"LUNA",MNA:"MANA",ORS:"ORS Group",PAS:"PASS",QSH:"QASH",QTM:"QTUM",RBT:"RBTC",SNG:"SNGLS",STJ:"STORJ",TERRAUST:"USTC",TSD:"TUSD",YGG:"YEED",YYW:"YOYOW",UDC:"USDC",VSY:"VSYS",WAX:"WAXP",XCH:"XCHF",ZBT:"ZB"}})}isFiat(e){return e in this.options.fiat}getCurrencyId(e){return"f"+e}getCurrencyName(e){if(e in this.options.currencyNames)return this.options.currencyNames[e];throw new Mk(this.id+" "+e+" not supported for withdrawal")}amountToPrecision(e,t){return this.decimalToPrecision(t,Ak,this.markets[e].precision.amount,Pk)}priceToPrecision(e,t){return t=this.decimalToPrecision(t,P5,this.markets[e].precision.price,this.precisionMode),this.decimalToPrecision(t,Ak,8,Pk)}async fetchStatus(e={}){const t=await this.publicGetPlatformStatus(e),s=this.safeString(t,0);return{status:this.safeString({0:"maintenance",1:"ok"},s,s),updated:void 0,eta:void 0,url:void 0,info:t}}async fetchMarkets(e={}){let t=await this.publicGetConfPubInfoPair(e),s=await this.publicGetConfPubInfoPairFutures(e);t=this.safeValue(t,0,[]),s=this.safeValue(s,0,[]);const i=this.arrayConcat(t,s);let n=await this.publicGetConfPubListPairMargin(e);n=this.safeValue(n,0,[]);const r=[];for(let a=0;a<i.length;a++){const o=i[a],d=this.safeStringUpper(o,0),c=this.safeValue(o,1,{});let u=!0;d.indexOf("F0")>=0&&(u=!1);const h=!u;let l,p;if(d.indexOf(":")>=0){const C=d.split(":");l=C[0],p=C[1]}else l=d.slice(0,3),p=d.slice(3,6);let m=this.safeCurrencyCode(l),g=this.safeCurrencyCode(p);const y=m.split("F0"),b=g.split("F0");m=this.safeString(y,0),g=this.safeString(b,0);let w=m+"/"+g;l=this.getCurrencyId(l),p=this.getCurrencyId(p);let k;h&&(k=g,w=w+":"+k);const T=this.safeString(c,3),O=this.safeString(c,4);let x=!1;this.inArray(d,n)&&(x=!0),r.push({id:"t"+d,symbol:w,base:m,quote:g,settle:k,baseId:l,quoteId:p,settleId:p,type:u?"spot":"swap",spot:u,margin:x,swap:h,future:!1,option:!1,active:!0,contract:h,linear:h?!0:void 0,inverse:h?!1:void 0,contractSize:h?this.parseNumber("1"):void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:parseInt("8"),price:parseInt("5")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.parseNumber(T),max:this.parseNumber(O)},price:{min:this.parseNumber("1e-8"),max:void 0},cost:{min:void 0,max:void 0}},info:c})}return r}async fetchCurrencies(e={}){const i={config:["pub:list:currency","pub:map:currency:sym","pub:map:currency:label","pub:map:currency:unit","pub:map:currency:undl","pub:map:currency:pool","pub:map:currency:explorer","pub:map:currency:tx:fee","pub:map:tx:method"].join(",")},n=await this.publicGetConfConfig(this.extend(i,e)),r={sym:this.indexBy(this.safeValue(n,1,[]),0),label:this.indexBy(this.safeValue(n,2,[]),0),unit:this.indexBy(this.safeValue(n,3,[]),0),undl:this.indexBy(this.safeValue(n,4,[]),0),pool:this.indexBy(this.safeValue(n,5,[]),0),explorer:this.indexBy(this.safeValue(n,6,[]),0),fees:this.indexBy(this.safeValue(n,7,[]),0)},a=this.safeValue(n,0,[]),o={};for(let d=0;d<a.length;d++){const c=a[d];if(c.indexOf("F0")>=0)continue;const u=this.safeCurrencyCode(c),h=this.safeValue(r.label,c,[]),l=this.safeString(h,1),p=this.safeValue(r.pool,c,[]),m=this.safeString(p,1),g=this.safeValue(r.fees,c,[]),y=this.safeValue(g,1,[]),b=this.safeNumber(y,1),w=this.safeValue(r.undl,c,[]),k="8",T="f"+c;o[u]={id:T,uppercaseId:c,code:u,info:[c,h,p,g,w],type:m,name:l,active:!0,deposit:void 0,withdraw:void 0,fee:b,precision:parseInt(k),limits:{amount:{min:this.parseNumber(this.parsePrecision(k)),max:void 0},withdraw:{min:b,max:void 0}}};const O={},x=this.safeValue(n,8,[]),C=c.replace("F0","");for(let _=0;_<x.length;_++){const S=x[_],I=this.safeString(S,0);if(this.safeString(this.safeValue(S,1,[]),0)===C){const N=this.safeNetwork(I);O[N]={info:I,id:I.toLowerCase(),network:I,active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,precision:void 0,limits:{withdraw:{min:void 0,max:void 0}}}}}Object.keys(O).length>0&&(o[u].networks=O)}return o}safeNetwork(e){const t={BITCOIN:"BTC",LITECOIN:"LTC",ETHEREUM:"ERC20",TETHERUSE:"ERC20",TETHERUSO:"OMNI",TETHERUSL:"LIQUID",TETHERUSX:"TRC20",TETHERUSS:"EOS",TETHERUSDTAVAX:"AVAX",TETHERUSDTSOL:"SOL",TETHERUSDTALG:"ALGO",TETHERUSDTBCH:"BCH",TETHERUSDTKSM:"KSM",TETHERUSDTDVF:"DVF",TETHERUSDTOMG:"OMG"};return this.safeString(t,e,e)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeValue(this.options,"v2AccountsByType",{}),s=this.safeString(e,"type","exchange"),i=this.safeString(t,s,s);if(i===void 0){const d=Object.keys(t);throw new Ea(this.id+" fetchBalance() type parameter must be one of "+d.join(", "))}const n=s==="derivatives",r=this.omit(e,"type"),a=await this.privatePostAuthRWallets(r),o={info:a};for(let d=0;d<a.length;d++){const c=a[d],u=this.safeString(c,0),h=this.safeStringLower(c,1,""),l=h.length-2,p=h.slice(l)==="f0";if(i===u&&(!n||p)){const g=this.safeCurrencyCode(h),y=this.account();y.total=this.safeString(c,2),y.free=this.safeString(c,4),o[g]=y}}return this.safeBalance(o)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.safeValue(this.options,"v2AccountsByType",{}),a=this.safeString(r,s);if(a===void 0){const g=Object.keys(r);throw new ic(this.id+" transfer() fromAccount must be one of "+g.join(", "))}const o=this.safeString(r,i);if(o===void 0){const g=Object.keys(r);throw new ic(this.id+" transfer() toAccount must be one of "+g.join(", "))}const d=this.currency(e),c=this.convertDerivativesId(d,s),u=this.convertDerivativesId(d,i),l={amount:this.currencyToPrecision(e,t),currency:c,currency_to:u,from:a,to:o},p=await this.privatePostAuthWTransfer(this.extend(l,n));if(this.safeString(p,0)==="error"){const g=this.safeString(p,2,"");throw this.throwExactlyMatchedException(this.exceptions.exact,g,this.id+" "+g),new Ea(this.id+" "+g)}return this.parseTransfer(p,d)}parseTransfer(e,t=void 0){const s=this.safeInteger(e,0),i=this.safeValue(e,4),n=this.safeString(i,1),r=this.safeString(i,2),a=this.safeString(i,5),o=this.safeString(e,6);return{id:void 0,timestamp:s,datetime:this.iso8601(s),status:this.parseTransferStatus(o),amount:this.safeNumber(i,7),currency:this.safeCurrencyCode(a,t),fromAccount:n,toAccount:r,info:e}}parseTransferStatus(e){const t={SUCCESS:"ok",ERROR:"failed",FAILURE:"failed"};return this.safeString(t,e,e)}convertDerivativesId(e,t){const s=this.safeValue(e,"info"),i=this.safeString(s,0),n=this.safeValue(s,4,[]);let r;if(t==="derivatives"){r=this.safeString(n,0,i);const a=r.length-2;r.slice(a)==="F0"||(r=r+"F0")}else t!=="margin"?r=this.safeString(n,1,i):r=i;return r}async fetchOrder(e,t=void 0,s={}){throw new Mk(this.id+" fetchOrder() is not supported yet. Consider using fetchOpenOrder() or fetchClosedOrder() instead.")}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue(this.options,"precision","R0"),n=this.market(e),r={symbol:n.id,precision:i};t!==void 0&&(r.len=t);const a=this.extend(r,s),o=await this.publicGetBookSymbolPrecision(a),d=this.milliseconds(),c={symbol:n.symbol,bids:[],asks:[],timestamp:d,datetime:this.iso8601(d),nonce:void 0},u=a.precision==="R0"?1:0;for(let h=0;h<o.length;h++){const l=o[h],p=this.safeNumber(l,u),m=this.safeString(l,2),g=Xi.stringAbs(m),y=Xi.stringGt(m,"0")?"bids":"asks";c[y].push([p,this.parseNumber(g)])}return c.bids=this.sortBy(c.bids,0,!0),c.asks=this.sortBy(c.asks,0),c}parseTicker(e,t=void 0){const s=this.milliseconds(),i=this.safeSymbol(void 0,t),n=e.length,r=this.safeString(e,n-4),a=this.safeString(e,n-5);return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,n-2),low:this.safeString(e,n-1),bid:this.safeString(e,n-10),bidVolume:void 0,ask:this.safeString(e,n-8),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:this.safeString(e,n-6),percentage:Xi.stringMul(a,"100"),average:void 0,baseVolume:this.safeString(e,n-3),quoteVolume:void 0,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={};if(e!==void 0){const r=this.marketIds(e);s.symbols=r.join(",")}else s.symbols="ALL";const i=await this.publicGetTickers(this.extend(s,t)),n={};for(let r=0;r<i.length;r++){const a=i[r],o=a[0];if(o in this.markets_by_id){const d=this.markets_by_id[o],c=d.symbol;n[c]=this.parseTicker(a,d)}}return this.filterByArray(n,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetTickerSymbol(this.extend(i,t));return this.parseTicker(n,s)}parseSymbol(e){if(e===void 0)return e;e=e.replace("t","");let t,s;if(e.indexOf(":")>=0){const r=e.split(":");t=r[0],s=r[1]}else t=e.slice(0,3),s=e.slice(3,6);const i=this.safeCurrencyCode(t),n=this.safeCurrencyCode(s);return i+"/"+n}parseTrade(e,t=void 0){const i=e.length>5,n=this.safeString(e,0),r=i?4:2;let a,o=this.safeString(e,r);const d=i?5:3,c=this.safeString(e,d);o[0]==="-"?(a="sell",o=Xi.stringAbs(o)):a="buy";let u,h,l,p,m;const g=i?2:1,y=this.safeInteger(e,g);if(i){const b=e[1];b in this.markets_by_id?(t=this.markets_by_id[b],m=t.symbol):m=this.parseSymbol(b),u=this.safeString(e,3),h=this.safeInteger(e,8)===1?"maker":"taker";let k=this.safeString(e,9);k=Xi.stringNeg(k);const T=this.safeString(e,10),O=this.safeCurrencyCode(T);p={cost:k,currency:O};const x=e[6];l=this.safeString(this.options.exchangeTypes,x)}return m===void 0&&t!==void 0&&(m=t.symbol),this.safeTrade({id:n,timestamp:y,datetime:this.iso8601(y),symbol:m,order:u,side:a,type:l,takerOrMaker:h,price:c,amount:o,cost:void 0,fee:p,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);let r="-1";const a={symbol:n.id};t!==void 0&&(a.start=t,r="1"),s!==void 0&&(a.limit=s),a.sort=r;const o=await this.publicGetTradesSymbolHist(this.extend(a,i)),d=this.sortBy(o,1);return this.parseTrades(d,n,void 0,s)}async fetchOHLCV(e,t="1m",s=void 0,i=100,n={}){await this.loadMarkets();const r=this.market(e);if(i===void 0&&(i=100),s===void 0){const d=this.parseTimeframe(t);s=this.milliseconds()-d*i*1e3}const a={symbol:r.id,timeframe:this.timeframes[t],sort:1,start:s,limit:i},o=await this.publicGetCandlesTradeTimeframeSymbolHist(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,5)]}parseOrderStatus(e){if(e===void 0)return e;const t=e.split(" "),s=this.safeString(t,0),i={ACTIVE:"open",PARTIALLY:"open",EXECUTED:"closed",CANCELED:"canceled",INSUFFICIENT:"canceled","POSTONLY CANCELED":"canceled",RSN_DUST:"rejected",RSN_PAUSE:"rejected","IOC CANCELED":"canceled","FILLORKILL CANCELED":"canceled"};return this.safeString(i,s,e)}parseOrderFlags(e){const t={1024:["reduceOnly"],4096:["postOnly"],5120:["reduceOnly","postOnly"]};return this.safeValue(t,e,void 0)}parseTimeInForce(e){const t={"EXCHANGE IOC":"IOC","EXCHANGE FOK":"FOK",IOC:"IOC",FOK:"FOK"};return this.safeString(t,e,"GTC")}parseOrder(e,t=void 0){const s=this.safeString(e,0);let i;const n=this.safeString(e,3);n in this.markets_by_id?t=this.markets_by_id[n]:i=this.parseSymbol(n),i===void 0&&t!==void 0&&(i=t.symbol);const r=this.safeInteger(e,5),a=Xi.stringAbs(this.safeString(e,6)),o=this.safeString(e,7),d=Xi.stringAbs(o),c=Xi.stringLt(o,"0")?"sell":"buy",u=this.safeString(e,8),h=this.safeString(this.safeValue(this.options,"exchangeTypes"),u),l=this.parseTimeInForce(u),p=this.safeString(e,12),m=this.parseOrderFlags(p);let g=!1;if(m!==void 0)for(let x=0;x<m.length;x++)m[x]==="postOnly"&&(g=!0);let y=this.safeString(e,16),b;(u==="EXCHANGE STOP"||u==="EXCHANGE STOP LIMIT")&&(y=void 0,b=this.safeNumber(e,16),u==="EXCHANGE STOP LIMIT"&&(y=this.safeNumber(e,19)));let w;const k=this.safeString(e,13);if(k!==void 0){const x=k.split(" @ ");w=this.parseOrderStatus(this.safeString(x,0))}const T=this.safeString(e,17),O=this.safeString(e,2);return this.safeOrder({info:e,id:s,clientOrderId:O,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,symbol:i,type:h,timeInForce:l,postOnly:g,side:c,price:y,stopPrice:b,amount:d,cost:void 0,average:T,filled:void 0,remaining:a,status:w,fee:void 0,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeValue(this.options,"orderTypes",{}),d=this.safeStringUpper(o,t,t),c=this.safeString2(r,"stopPrice","triggerPrice"),u=this.safeString(r,"timeInForce"),h=this.safeValue(r,"postOnly",!1),l=this.safeValue(r,"reduceOnly",!1),p=this.safeValue2(r,"cid","clientOrderId");r=this.omit(r,["triggerPrice","stopPrice","timeInForce","postOnly","reduceOnly","price_aux_limit"]);let m=this.amountToPrecision(e,i);m=s==="buy"?m:Xi.stringNeg(m);const g={type:d,symbol:a.id,amount:m},y=d==="EXCHANGE STOP LIMIT"||d==="EXCHANGE LIMIT"&&c!==void 0,b=d==="EXCHANGE STOP",w=d==="EXCHANGE MARKET",k=b||w&&c!==void 0,T=d==="EXCHANGE IOC"||u==="IOC",O=d==="EXCHANGE FOK"||u==="FOK",x=h||u==="PO";if((T||O)&&n===void 0)throw new kf(this.id+" createOrder() requires a price argument with IOC and FOK orders");if((T||O)&&w)throw new kf(this.id+" createOrder() does not allow market IOC and FOK orders");d!=="MARKET"&&!w&&!b&&(g.price=this.priceToPrecision(e,n)),(y||k)&&(g.price=this.priceToPrecision(e,c),k?g.type="EXCHANGE STOP":y&&(g.type="EXCHANGE STOP LIMIT",g.price_aux_limit=this.priceToPrecision(e,n))),T?g.type="EXCHANGE IOC":O&&(g.type="EXCHANGE FOK");let C=0;x&&(C=this.sum(C,4096)),l&&(C=this.sum(C,1024)),C!==0&&(g.flags=C),p!==void 0&&(g.cid=p,r=this.omit(r,["cid","clientOrderId"]));const E=await this.privatePostAuthWOrderSubmit(this.extend(g,r));if(this.safeString(E,6)!=="SUCCESS"){const I=E[5],v=E[7];throw new Ea(this.id+" "+E[6]+": "+v+" (#"+I+")")}const _=this.safeValue(E,4,[]),S=this.safeValue(_,0);return this.parseOrder(S,a)}async cancelAllOrders(e=void 0,t={}){const s={all:1},i=await this.privatePostAuthWOrderCancelMulti(this.extend(s,t)),n=this.safeValue(i,4,[]);return this.parseOrders(n)}async cancelOrder(e,t=void 0,s={}){const i=this.safeValue2(s,"cid","clientOrderId");let n;if(i!==void 0){const o=this.safeValue(s,"cidDate");if(o===void 0)throw new kf(this.id+" canceling an order by clientOrderId ('cid') requires both 'cid' and 'cid_date' ('YYYY-MM-DD')");n={cid:i,cid_date:o},s=this.omit(s,["cid","clientOrderId"])}else n={id:parseInt(e)};const r=await this.privatePostAuthWOrderCancel(this.extend(n,s)),a=this.safeValue(r,4);return this.parseOrder(a)}async fetchOpenOrder(e,t=void 0,s={}){const i={id:[parseInt(e)]},n=await this.fetchOpenOrders(t,void 0,void 0,this.extend(i,s)),r=this.safeValue(n,0);if(r===void 0)throw new Mm(this.id+" order "+e+" not found");return r}async fetchClosedOrder(e,t=void 0,s={}){const i={id:[parseInt(e)]},n=await this.fetchClosedOrders(t,void 0,void 0,this.extend(i,s)),r=this.safeValue(n,0);if(r===void 0)throw new Mm(this.id+" order "+e+" not found");return r}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r,a;return e===void 0?a=await this.privatePostAuthROrders(this.extend(n,i)):(r=this.market(e),n.symbol=r.id,a=await this.privatePostAuthROrdersSymbol(this.extend(n,i))),this.parseOrders(a,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.start=t),s!==void 0&&(n.limit=s);let r,a;return e===void 0?a=await this.privatePostAuthROrdersHist(this.extend(n,i)):(r=this.market(e),n.symbol=r.id,a=await this.privatePostAuthROrdersSymbolHist(this.extend(n,i))),this.parseOrders(a,r,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){if(t===void 0)throw new ic(this.id+" fetchOrderTrades() requires a symbol argument");await this.loadMarkets();const r=this.market(t),o={id:parseInt(e),symbol:r.id},d=await this.privatePostAuthROrderSymbolIdTrades(this.extend(o,n));return this.parseTrades(d,r,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={end:this.milliseconds()};t!==void 0&&(r.start=t),s!==void 0&&(r.limit=s);let a="privatePostAuthRTradesHist";e!==void 0&&(n=this.market(e),r.symbol=n.id,a="privatePostAuthRTradesSymbolHist");const o=await this[a](this.extend(r,i));return this.parseTrades(o,n,t,s)}async createDepositAddress(e,t={}){await this.loadMarkets();const s={op_renew:1};return await this.fetchDepositAddress(e,this.extend(s,t))}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i=this.safeString(t,"network",e),n=this.safeValue(s,"networks",{}),r=this.safeValue(n,i),a=this.safeString(r,"id");if(a===void 0)throw new ic(this.id+" fetchDepositAddress() could not find a network for '"+e+"'. You can specify it by providing the 'network' value inside params");const o=this.safeString(t,"wallet","exchange");t=this.omit(t,"network","wallet");const d={method:a,wallet:o,op_renew:0},c=await this.privatePostAuthWDepositAddress(this.extend(d,t)),u=this.safeValue(c,4,[]),h=this.safeString(u,5),l=h===void 0?this.safeString(u,4):h,p=h===void 0?void 0:this.safeString(u,4);return this.checkAddress(l),{currency:e,address:l,tag:p,network:void 0,info:c}}parseTransactionStatus(e){const t={SUCCESS:"ok",ERROR:"failed",FAILURE:"failed",CANCELED:"canceled",COMPLETED:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=e.length;let i,n,r,a,o,d,c,u,h,l,p;if(s===8){const m=this.safeValue(e,4,[]);i=this.safeInteger(e,0),t!==void 0&&(r=t.code),h=this.safeString(m,8),h!==void 0&&(h=Xi.stringNeg(h)),a=this.safeNumber(m,5),o=this.safeValue(m,0),d="ok",o===0&&(o=void 0,d="failed"),c=this.safeString(m,3),u="withdrawal"}else if(s===22){o=this.safeString(e,0);const m=this.safeString(e,1);r=this.safeCurrencyCode(m,t),i=this.safeInteger(e,5),n=this.safeInteger(e,6),d=this.parseTransactionStatus(this.safeString(e,9)),a=this.safeString(e,12),a!==void 0&&(Xi.stringLt(a,"0")?u="withdrawal":u="deposit"),h=this.safeString(e,13),h!==void 0&&(h=Xi.stringNeg(h)),p=this.safeString(e,16),l=this.safeString(e,20)}return{info:e,id:o,txid:l,timestamp:i,datetime:this.iso8601(i),network:void 0,addressFrom:void 0,address:p,addressTo:p,tagFrom:void 0,tag:c,tagTo:c,type:u,amount:this.parseNumber(a),currency:r,status:d,updated:n,fee:{currency:r,cost:this.parseNumber(h),rate:void 0}}}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostAuthRSummary(e),s={},i=this.safeValue(this.options,"fiat",{}),n=this.safeValue(t,4,[]),r=this.safeValue(n,0,[]),a=this.safeValue(n,1,[]),o=this.safeNumber(r,0),d=this.safeNumber(r,2),c=this.safeNumber(r,5),u=this.safeNumber(a,0),h=this.safeNumber(a,2),l=this.safeNumber(a,5);for(let p=0;p<this.symbols.length;p++){const m=this.symbols[p],g=this.market(m),y={info:t,symbol:m,percentage:!0,tierBased:!0};g.quote in i?(y.maker=d,y.taker=h):g.contract?(y.maker=c,y.taker=l):(y.maker=o,y.taker=u),s[m]=y}return s}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};let a="privatePostAuthRMovementsHist";e!==void 0&&(n=this.currency(e),r.currency=n.uppercaseId,a="privatePostAuthRMovementsCurrencyHist"),t!==void 0&&(r.start=t),s!==void 0&&(r.limit=s);const o=await this[a](this.extend(r,i));return this.parseTransactions(o,n,t,s)}async withdraw(e,t,s,i=void 0,n={}){this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a=this.safeString(n,"network",e);n=this.omit(n,"network");const o=this.safeValue(r,"networks",{}),d=this.safeValue(o,a),c=this.safeString(d,"id");if(c===void 0)throw new ic(this.id+" fetchDepositAddress() could not find a network for '"+e+"'. You can specify it by providing the 'network' value inside params");const u=this.safeString(n,"wallet","exchange");n=this.omit(n,"network","wallet");const h={method:c,wallet:u,amount:this.numberToString(t),address:s};i!==void 0&&(h.payment_id=i);const l=await this.privatePostAuthWWithdraw(this.extend(h,n));if(this.safeString(l,0)==="error"){const y=this.id+" "+l,b=this.safeString(l,2,"");throw this.throwExactlyMatchedException(this.exceptions.exact,b,y),this.throwBroadlyMatchedException(this.exceptions.broad,b,y),new Ea(y)}const m=this.safeString(l,7);m!=="success"&&this.throwBroadlyMatchedException(this.exceptions.broad,m,m);const g=this.parseTransaction(l,r);return this.extend(g,{address:s})}async fetchPositions(e=void 0,t={}){return await this.loadMarkets(),await this.privatePostAuthRPositions(t)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));t==="v1"?a=t+a:a=this.version+a;let d=this.urls.api[t]+"/"+a;if(t==="public"&&Object.keys(o).length&&(d+="?"+this.urlencode(o)),t==="private"){this.checkRequiredCredentials();const c=this.nonce().toString();r=this.json(o);const u="/api/"+a+c+r,h=this.hmac(this.encode(u),this.encode(this.secret),"sha384");n={"bfx-nonce":c,"bfx-apikey":this.apiKey,"bfx-signature":h,"Content-Type":"application/json"}}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0){if(!Array.isArray(a)){const c=this.safeString2(a,"message","error"),u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u),new Ea(this.id+" "+r)}}else if(a==="")throw new Ea(this.id+" returned empty response");if(e===500){const c=this.numberToString(a[1]),u=a[2],h=this.id+" "+u;throw this.throwBroadlyMatchedException(this.exceptions.broad,u,h),this.throwExactlyMatchedException(this.exceptions.exact,c,h),this.throwExactlyMatchedException(this.exceptions.exact,u,h),new Ea(this.id+" "+u+" (#"+c+")")}return a}parseLedgerEntryType(e){if(e!==void 0)return e.indexOf("fee")>=0||e.indexOf("charged")>=0?"fee":e.indexOf("exchange")>=0||e.indexOf("position")>=0?"trade":e.indexOf("rebate")>=0?"rebate":e.indexOf("deposit")>=0||e.indexOf("withdrawal")>=0?"transaction":e.indexOf("transfer")>=0?"transfer":e.indexOf("payment")>=0?"payout":e}parseLedgerEntry(e,t=void 0){let s;const i=this.safeString(e,0),n=this.safeString(e,1),r=this.safeCurrencyCode(n,t),a=this.safeInteger(e,3),o=this.safeNumber(e,5),d=this.safeNumber(e,6),c=this.safeString(e,8);if(c!==void 0){const u=c.split(" @ "),h=this.safeStringLower(u,0);s=this.parseLedgerEntryType(h)}return{id:i,direction:void 0,account:void 0,referenceId:i,referenceAccount:void 0,type:s,currency:r,amount:o,timestamp:a,datetime:this.iso8601(a),before:void 0,after:d,status:void 0,fee:void 0,info:e}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.loadMarkets();let n;const r={};let a="privatePostAuthRLedgersHist";e!==void 0&&(n=this.currency(e),r.currency=n.uppercaseId,a="privatePostAuthRLedgersCurrencyHist"),t!==void 0&&(r.start=t),s!==void 0&&(r.limit=s);const o=await this[a](this.extend(r,i));return this.parseLedger(o,n,t,s)}};const A5=ge,{ExchangeError:B5,ArgumentsRequired:nc,OrderNotFound:E5}=de,{TICK_SIZE:N5}=me;var V5=class extends A5{describe(){return this.deepExtend(super.describe(),{id:"bitflyer",name:"bitFlyer",countries:["JP"],version:"v1",rateLimit:1e3,hostname:"bitflyer.com",has:{CORS:void 0,spot:!0,margin:!1,swap:void 0,future:void 0,option:!1,cancelOrder:!0,createOrder:!0,fetchBalance:!0,fetchClosedOrders:"emulated",fetchDeposits:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOpenOrders:"emulated",fetchOrder:"emulated",fetchOrderBook:!0,fetchOrders:!0,fetchPositionMode:!1,fetchPositions:!0,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawals:!0,transfer:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/28051642-56154182-660e-11e7-9b0d-6042d1e6edd8.jpg",api:{rest:"https://api.{hostname}"},www:"https://bitflyer.com",doc:"https://lightning.bitflyer.com/docs?lang=en"},api:{public:{get:["getmarkets/usa","getmarkets/eu","getmarkets","getboard","getticker","getexecutions","gethealth","getboardstate","getchats"]},private:{get:["getpermissions","getbalance","getbalancehistory","getcollateral","getcollateralhistory","getcollateralaccounts","getaddresses","getcoinins","getcoinouts","getbankaccounts","getdeposits","getwithdrawals","getchildorders","getparentorders","getparentorder","getexecutions","getpositions","gettradingcommission"],post:["sendcoin","withdraw","sendchildorder","cancelchildorder","sendparentorder","cancelparentorder","cancelallchildorders"]}},fees:{trading:{maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},precisionMode:N5})}parseExpiryDate(e){const t=e.slice(0,2),s=e.slice(2,5),i=e.slice(5,9),n={JAN:"01",FEB:"02",MAR:"03",APR:"04",MAY:"05",JUN:"06",JUL:"07",AUG:"08",SEP:"09",OCT:"10",NOV:"11",DEC:"12"},r=this.safeString(n,s);return this.parse8601(i+"-"+r+"-"+t+"T00:00:00Z")}async fetchMarkets(e={}){const t=await this.publicGetGetmarkets(e),s=await this.publicGetGetmarketsUsa(e),i=await this.publicGetGetmarketsEu(e);let n=this.arrayConcat(t,s);n=this.arrayConcat(n,i);const r=[];for(let a=0;a<n.length;a++){const o=n[a],d=this.safeString(o,"product_code"),c=d.split("_"),u=this.safeString(o,"market_type"),h=u==="FX",l=u==="Futures",p=!h&&!l;let m="spot",g,y,b,w;if(p)y=this.safeString(c,0),b=this.safeString(c,1);else if(h)m="swap",y=this.safeString(c,1),b=this.safeString(c,2);else if(l){const P=this.safeString(o,"alias");if(P===void 0){y=d.slice(0,3),b=d.slice(3,6);const _=d.slice(-9);w=this.parseExpiryDate(_)}else{const _=P.split("_"),S=this.safeString(_,0);y=S.slice(0,-3),b=S.slice(-3);const I=d.split(S),v=this.safeString(I,1);w=this.parseExpiryDate(v)}m="future"}const k=this.safeCurrencyCode(y),T=this.safeCurrencyCode(b);let O=k+"/"+T,x=this.fees.trading.taker,C=this.fees.trading.maker;const E=h||l;E&&(C=0,x=0,g="JPY",O=O+":"+g,l&&(O=O+"-"+this.yymmdd(w))),r.push({id:d,symbol:O,base:k,quote:T,settle:g,baseId:y,quoteId:b,settleId:void 0,type:m,spot:p,margin:!1,swap:h,future:l,option:!1,active:!0,contract:E,linear:p?void 0:!0,inverse:p?void 0:!1,taker:x,maker:C,contractSize:void 0,expiry:w,expiryDatetime:this.iso8601(w),strike:void 0,optionType:void 0,precision:{amount:void 0,price:void 0},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:o})}return r}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency_code"),r=this.safeCurrencyCode(n),a=this.account();a.total=this.safeString(i,"amount"),a.free=this.safeString(i,"available"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetGetbalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={product_code:i.id},r=await this.publicGetGetboard(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"bids","asks","price","size")}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.parse8601(this.safeString(e,"timestamp")),n=this.safeString(e,"ltp");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:void 0,low:void 0,bid:this.safeString(e,"best_bid"),bidVolume:void 0,ask:this.safeString(e,"best_ask"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume_by_product"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={product_code:s.id},n=await this.publicGetGetticker(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){let s=this.safeStringLower(e,"side");s!==void 0&&s.length<1&&(s=void 0);let i;if(s!==void 0){const d=s+"_child_order_acceptance_id";d in e&&(i=e[d])}i===void 0&&(i=this.safeString(e,"child_order_acceptance_id"));const n=this.parse8601(this.safeString(e,"exec_date")),r=this.safeString(e,"price"),a=this.safeString(e,"size"),o=this.safeString(e,"id");return t=this.safeMarket(void 0,t),this.safeTrade({id:o,info:e,timestamp:n,datetime:this.iso8601(n),symbol:t.symbol,order:i,type:void 0,side:s,takerOrMaker:void 0,price:r,amount:a,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={product_code:n.id};s!==void 0&&(r.count=s);const a=await this.publicGetGetexecutions(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={product_code:s.id},n=await this.privateGetGettradingcommission(this.extend(i,t)),r=this.safeNumber(n,"commission_rate");return{info:n,symbol:s.symbol,maker:r,taker:r}}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a={product_code:this.marketId(e),child_order_type:t.toUpperCase(),side:s.toUpperCase(),price:n,size:i},o=await this.privatePostSendchildorder(this.extend(a,r)),d=this.safeString(o,"child_order_acceptance_id");return{info:o,id:d}}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new nc(this.id+" cancelOrder() requires a `symbol` argument");await this.loadMarkets();const i={product_code:this.marketId(t),child_order_acceptance_id:e};return await this.privatePostCancelchildorder(this.extend(i,s))}parseOrderStatus(e){const t={ACTIVE:"open",COMPLETED:"closed",CANCELED:"canceled",EXPIRED:"canceled",REJECTED:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parse8601(this.safeString(e,"child_order_date")),i=this.safeString(e,"price"),n=this.safeString(e,"size"),r=this.safeString(e,"executed_size"),a=this.safeString(e,"outstanding_size"),o=this.parseOrderStatus(this.safeString(e,"child_order_state")),d=this.safeStringLower(e,"child_order_type"),c=this.safeStringLower(e,"side"),u=this.safeString(e,"product_code"),h=this.safeSymbol(u,t);let l;const p=this.safeNumber(e,"total_commission");p!==void 0&&(l={cost:p,currency:void 0,rate:void 0});const m=this.safeString(e,"child_order_acceptance_id");return this.safeOrder({id:m,clientOrderId:void 0,info:e,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,status:o,symbol:h,type:d,timeInForce:void 0,postOnly:void 0,side:c,price:i,stopPrice:void 0,cost:void 0,amount:n,filled:r,remaining:a,fee:l,average:void 0,trades:void 0},t)}async fetchOrders(e=void 0,t=void 0,s=100,i={}){if(e===void 0)throw new nc(this.id+" fetchOrders() requires a `symbol` argument");await this.loadMarkets();const n=this.market(e),r={product_code:n.id,count:s},a=await this.privateGetGetchildorders(this.extend(r,i));let o=this.parseOrders(a,n,t,s);return e!==void 0&&(o=this.filterBy(o,"symbol",e)),o}async fetchOpenOrders(e=void 0,t=void 0,s=100,i={}){const n={child_order_state:"ACTIVE"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=100,i={}){const n={child_order_state:"COMPLETED"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new nc(this.id+" fetchOrder() requires a `symbol` argument");const i=await this.fetchOrders(t),n=this.indexBy(i,"id");if(e in n)return n[e];throw new E5(this.id+" No order found with id "+e)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new nc(this.id+" fetchMyTrades() requires a `symbol` argument");await this.loadMarkets();const n=this.market(e),r={product_code:n.id};s!==void 0&&(r.count=s);const a=await this.privateGetGetexecutions(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchPositions(e=void 0,t={}){if(e===void 0)throw new nc(this.id+" fetchPositions() requires a `symbols` argument, exactly one symbol in an array");await this.loadMarkets();const s={product_code:this.marketIds(e)};return await this.privateGetpositions(this.extend(s,t))}async withdraw(e,t,s,i=void 0,n={}){if(this.checkAddress(s),await this.loadMarkets(),e!=="JPY"&&e!=="USD"&&e!=="EUR")throw new B5(this.id+" allows withdrawing JPY, USD, EUR only, "+e+" is not supported");const r=this.currency(e),a={currency_code:r.id,amount:t},o=await this.privatePostWithdraw(this.extend(a,n));return this.parseTransaction(o,r)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e)),s!==void 0&&(r.count=s);const a=await this.privateGetGetcoinins(this.extend(r,i));return this.parseTransactions(a,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e)),s!==void 0&&(r.count=s);const a=await this.privateGetGetcoinouts(this.extend(r,i));return this.parseTransactions(a,n,t,s)}parseDepositStatus(e){const t={PENDING:"pending",COMPLETED:"ok"};return this.safeString(t,e,e)}parseWithdrawalStatus(e){const t={PENDING:"pending",COMPLETED:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"id","message_id"),i=this.safeString(e,"address"),n=this.safeString(e,"currency_code"),r=this.safeCurrencyCode(n,t),a=this.parse8601(this.safeString(e,"event_date")),o=this.safeNumber(e,"amount"),d=this.safeString(e,"tx_hash"),c=this.safeString(e,"status");let u,h,l;if("fee"in e){u="withdrawal",h=this.parseWithdrawalStatus(c);const p=this.safeNumber(e,"fee"),m=this.safeNumber(e,"additional_fee");l={currency:r,cost:p+m}}else u="deposit",h=this.parseDepositStatus(c);return{info:e,id:s,txid:d,timestamp:a,datetime:this.iso8601(a),network:void 0,address:i,addressTo:i,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:u,amount:o,currency:r,status:h,updated:void 0,internal:void 0,fee:l}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.version+"/";t==="private"&&(a+="me/"),a+=e,s==="GET"&&Object.keys(i).length&&(a+="?"+this.urlencode(i));const d=this.implodeHostname(this.urls.api.rest)+a;if(t==="private"){this.checkRequiredCredentials();const c=this.nonce().toString();let u=[c,s,a].join("");Object.keys(i).length&&s!=="GET"&&(r=this.json(i),u+=r),n={"ACCESS-KEY":this.apiKey,"ACCESS-TIMESTAMP":c,"ACCESS-SIGN":this.hmac(this.encode(u),this.encode(this.secret)),"Content-Type":"application/json"}}return{url:d,method:s,body:r,headers:n}}};const q5=ge,{ExchangeError:L5,ArgumentsRequired:Bk,AuthenticationError:Ek,OrderNotFound:Nk,InsufficientFunds:R5,DDoSProtection:F5,PermissionDenied:D5,BadSymbol:Vk,InvalidOrder:qk}=de,{TICK_SIZE:H5}=me;var G5=class extends q5{describe(){return this.deepExtend(super.describe(),{id:"bitforex",name:"Bitforex",countries:["CN"],rateLimit:500,version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:void 0,future:!1,option:!1,cancelOrder:!0,createOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:void 0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:void 0,fetchPositionMode:!1,fetchTicker:!0,fetchTickers:void 0,fetchTrades:!0,fetchTransactionFees:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!1,transfer:!1,withdraw:!1},timeframes:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","2h":"2hour","4h":"4hour","12h":"12hour","1d":"1day","1w":"1week","1M":"1month"},urls:{logo:"https://user-images.githubusercontent.com/51840849/87295553-1160ec00-c50e-11ea-8ea0-df79276a9646.jpg",api:{rest:"https://api.bitforex.com"},www:"https://www.bitforex.com",doc:"https://github.com/githubdev2020/API_Doc_en/wiki",fees:"https://help.bitforex.com/en_us/?cat=13",referral:"https://www.bitforex.com/en/invitationRegister?inviterId=1867438"},api:{public:{get:{"api/v1/market/symbols":20,"api/v1/market/ticker":4,"api/v1/market/ticker-all":4,"api/v1/market/depth":4,"api/v1/market/depth-all":4,"api/v1/market/trades":20,"api/v1/market/kline":20}},private:{post:{"api/v1/fund/mainAccount":1,"api/v1/fund/allAccount":30,"api/v1/trade/placeOrder":1,"api/v1/trade/placeMultiOrder":10,"api/v1/trade/cancelOrder":1,"api/v1/trade/cancelMultiOrder":20,"api/v1/trade/cancelAllOrder":20,"api/v1/trade/orderInfo":1,"api/v1/trade/multiOrderInfo":10,"api/v1/trade/orderInfos":20}}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")},funding:{tierBased:!1,percentage:!0,deposit:{},withdraw:{}}},commonCurrencies:{BKC:"Bank Coin",CAPP:"Crypto Application Token",CREDIT:"TerraCredit",CTC:"Culture Ticket Chain",EWT:"EcoWatt Token",IQ:"IQ.Cash",MIR:"MIR COIN",NOIA:"METANOIA",TON:"To The Moon"},precisionMode:H5,exceptions:{1e3:Nk,1003:Vk,1013:Ek,1016:Ek,1017:D5,1019:Vk,3002:R5,4002:qk,4003:qk,4004:Nk,10204:F5}})}async fetchMarkets(e={}){const s=(await this.publicGetApiV1MarketSymbols(e)).data,i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=a.split("-"),d=o[2],c=o[1],u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c);i.push({id:a,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDateTime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"amountPrecision"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"pricePrecision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"minOrderAmount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}parseTrade(e,t=void 0){t=this.safeMarket(void 0,t);const s=this.safeInteger(e,"time"),i=this.safeString(e,"tid"),n=void 0,r=this.safeString(e,"price"),a=this.safeString(e,"amount"),o=this.safeInteger(e,"direction"),d=this.parseSide(o);return this.safeTrade({info:e,id:i,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:void 0,side:d,price:r,amount:a,cost:void 0,order:n,fee:void 0,takerOrMaker:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={symbol:this.marketId(e)};s!==void 0&&(n.size=s);const r=this.market(e),a=await this.publicGetApiV1MarketTrades(this.extend(n,i));return this.parseTrades(a.data,r,t,s)}parseBalance(e){const t=e.data,s={info:e};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.used=this.safeString(n,"frozen"),o.free=this.safeString(n,"active"),o.total=this.safeString(n,"fix"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostApiV1FundAllAccount(e);return this.parseBalance(t)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeInteger(e,"date");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:this.safeString(e,"last"),last:this.safeString(e,"last"),previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"vol"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.markets[e],i={symbol:s.id},n=await this.publicGetApiV1MarketTickerAll(this.extend(i,t)),r=this.safeValue(n,"data");return this.parseTicker(r,s)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"time"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"vol")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,ktype:this.timeframes[t]};i!==void 0&&(a.size=i);const o=await this.publicGetApiV1MarketKline(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseOHLCVs(d,r,t,s,i)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.size=t);const r=await this.publicGetApiV1MarketDepthAll(this.extend(n,s)),a=this.safeValue(r,"data"),o=this.safeInteger(r,"time");return this.parseOrderBook(a,i.symbol,o,"bids","asks","price","amount")}parseOrderStatus(e){const t={0:"open",1:"open",2:"closed",3:"canceled",4:"canceled"};return e in t?t[e]:e}parseSide(e){return e===1?"buy":e===2?"sell":void 0}parseOrder(e,t=void 0){const s=this.safeString(e,"orderId"),i=this.safeNumber(e,"createTime"),n=this.safeNumber(e,"lastTime"),r=t.symbol,a=this.safeInteger(e,"tradeType"),o=this.parseSide(a),d=void 0,c=this.safeString(e,"orderPrice"),u=this.safeString(e,"avgPrice"),h=this.safeString(e,"orderAmount"),l=this.safeString(e,"dealAmount"),p=this.parseOrderStatus(this.safeString(e,"orderState")),g=t[o==="buy"?"base":"quote"],y={cost:this.safeNumber(e,"tradeFee"),currency:g};return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:n,symbol:r,type:d,timeInForce:void 0,postOnly:void 0,side:o,price:c,stopPrice:void 0,cost:void 0,average:u,amount:h,filled:l,remaining:void 0,status:p,fee:y,trades:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(t),n={symbol:this.marketId(t),orderId:e},r=await this.privatePostApiV1TradeOrderInfo(this.extend(n,s));return this.parseOrder(r.data,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Bk(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:this.marketId(e),state:0},a=await this.privatePostApiV1TradeOrderInfos(this.extend(r,i));return this.parseOrders(a.data,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Bk(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:this.marketId(e),state:1},a=await this.privatePostApiV1TradeOrderInfos(this.extend(r,i));return this.parseOrders(a.data,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();let a;s==="buy"?a=1:s==="sell"&&(a=2);const d={symbol:this.market(e).id,price:n,amount:i,tradeType:a},c=await this.privatePostApiV1TradePlaceOrder(this.extend(d,r)),u=c.data;return{info:c,id:this.safeString(u,"orderId")}}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e};t!==void 0&&(i.symbol=this.marketId(t));const n=await this.privatePostApiV1TradeCancelOrder(this.extend(i,s)),r=n.success;return{info:n,success:r}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials();let d=this.urlencode({accessKey:this.apiKey});o.nonce=this.milliseconds(),Object.keys(o).length&&(d+="&"+this.urlencode(this.keysort(o)));const c="/"+e+"?"+d,u=this.hmac(this.encode(c),this.encode(this.secret));r=d+"&signData="+u,n={"Content-Type":"application/x-www-form-urlencoded"}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(typeof r=="string"&&(r[0]==="{"||r[0]==="[")){const c=this.id+" "+r,u=this.safeValue(a,"success");if(u!==void 0&&!u){const h=this.safeString(a,"code");throw this.throwExactlyMatchedException(this.exceptions,h,c),new L5(c)}}}};const U5=ge,{ExchangeError:ee,ExchangeNotAvailable:rc,NotSupported:$5,OnMaintenance:Pm,ArgumentsRequired:vs,BadRequest:qe,AccountSuspended:jr,InvalidAddress:Lk,PermissionDenied:St,DDoSProtection:Am,InsufficientFunds:wi,InvalidNonce:ac,CancelPending:j5,InvalidOrder:pe,OrderNotFound:Sf,AuthenticationError:bt,RequestTimeout:Rk,BadSymbol:hr,RateLimitExceeded:Bm}=de,{TICK_SIZE:W5}=me,oc=Se;var z5=class extends U5{describe(){return this.deepExtend(super.describe(),{id:"bitget",name:"Bitget",countries:["SG"],version:"v1",rateLimit:50,certified:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!0,future:!1,option:!1,addMargin:!0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchAccounts:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!0,fetchLeverageTiers:!1,fetchMarginMode:void 0,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:void 0,fetchWithdrawal:!1,fetchWithdrawals:!0,reduceMargin:!0,setLeverage:!0,setMarginMode:!0,setPositionMode:!1,transfer:!0,withdraw:!1},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},hostname:"bitget.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/195989417-4253ddb0-afbe-4a1c-9dea-9dbcd121fa5d.jpg",api:{spot:"https://api.{hostname}",mix:"https://api.{hostname}"},www:"https://www.bitget.com",doc:["https://bitgetlimited.github.io/apidoc/en/mix","https://bitgetlimited.github.io/apidoc/en/spot","https://bitgetlimited.github.io/apidoc/en/broker"],fees:"https://www.bitget.cc/zh-CN/rate?tab=1",referral:"https://www.bitget.com/expressly?languageType=0&channelCode=ccxt&vipCode=tg9j"},api:{public:{spot:{get:{"public/time":1,"public/currencies":1,"public/products":1,"public/product":1,"market/ticker":1,"market/tickers":1,"market/fills":1,"market/candles":1,"market/depth":1}},mix:{get:{"market/contracts":1,"market/depth":1,"market/ticker":1,"market/tickers":1,"market/fills":1,"market/candles":1,"market/index":1,"market/funding-time":1,"market/history-fundRate":1,"market/current-fundRate":1,"market/open-interest":1,"market/mark-price":1,"market/symbol-leverage":1}}},private:{spot:{get:{"account/getInfo":20,"account/assets":2,"account/transferRecords":4,"wallet/deposit-address":4,"wallet/withdrawal-inner":4,"wallet/withdrawal-list":1,"wallet/deposit-list":1},post:{"account/bills":2,"trade/orders":2,"trade/batch-orders":4,"trade/cancel-order":2,"trade/cancel-batch-orders":4,"trade/orderInfo":1,"trade/open-orders":1,"trade/history":1,"trade/fills":1,"wallet/transfer":4,"wallet/withdrawal":4,"wallet/subTransfer":10}},mix:{get:{"account/account":2,"account/accounts":2,"account/open-count":1,"order/current":2,"order/history":2,"order/detail":2,"order/fills":2,"order/historyProductType":8,"order/allFills":2,"plan/currentPlan":2,"plan/historyPlan":2,"position/singlePosition":2,"position/allPosition":2,"trace/currentTrack":2,"trace/followerOrder":2,"trace/historyTrack":2,"trace/summary":2,"trace/profitSettleTokenIdGroup":2,"trace/profitDateGroupList":2,"trade/profitDateList":2,"trace/waitProfitDateList":2,"trace/traderSymbols":2,"order/marginCoinCurrent":2},post:{"account/setLeverage":8,"account/setMargin":8,"account/setMarginMode":8,"order/placeOrder":2,"order/batch-orders":2,"order/cancel-order":2,"order/cancel-all-orders":2,"order/cancel-batch-orders":2,"plan/placePlan":2,"plan/modifyPlan":2,"plan/modifyPlanPreset":2,"plan/placeTPSL":2,"plan/placePositionsTPSL":2,"plan/modifyTPSLPlan":2,"plan/cancelPlan":2,"trace/closeTrackOrder":2,"trace/setUpCopySymbols":2}}}},fees:{spot:{taker:this.parseNumber("0.002"),maker:this.parseNumber("0.002")},swap:{taker:this.parseNumber("0.0006"),maker:this.parseNumber("0.0004")}},requiredCredentials:{apiKey:!0,secret:!0,password:!0},exceptions:{exact:{1:ee,"failure to get a peer from the ring-balancer":rc,4010:St,4001:ee,4002:ee,30001:bt,30002:bt,30003:bt,30004:bt,30005:ac,30006:bt,30007:qe,30008:Rk,30009:ee,30010:bt,30011:St,30012:bt,30013:bt,30014:Am,30015:bt,30016:ee,30017:ee,30018:ee,30019:rc,30020:qe,30021:qe,30022:St,30023:qe,30024:hr,30025:qe,30026:Am,30027:bt,30028:St,30029:jr,30030:ee,30031:qe,30032:hr,30033:qe,30034:ee,30035:ee,30036:ee,30037:rc,30038:Pm,32001:jr,32002:St,32003:j5,32004:ee,32005:pe,32006:pe,32007:pe,32008:pe,32009:pe,32010:ee,32011:ee,32012:ee,32013:ee,32014:ee,32015:ee,32016:ee,32017:ee,32018:ee,32019:ee,32020:ee,32021:ee,32022:ee,32023:ee,32024:ee,32025:ee,32026:ee,32027:ee,32028:jr,32029:ee,32030:pe,32031:vs,32038:bt,32040:ee,32044:ee,32045:ee,32046:ee,32047:ee,32048:pe,32049:ee,32050:pe,32051:pe,32052:ee,32053:ee,32057:ee,32054:ee,32055:pe,32056:ee,32058:ee,32059:pe,32060:pe,32061:pe,32062:pe,32063:pe,32064:ee,32065:ee,32066:ee,32067:ee,32068:ee,32069:ee,32070:ee,32071:ee,32072:ee,32073:ee,32074:ee,32075:ee,32076:ee,32077:ee,32078:ee,32079:ee,32080:ee,32083:ee,33001:St,33002:jr,33003:wi,33004:ee,33005:ee,33006:ee,33007:ee,33008:wi,33009:ee,33010:ee,33011:ee,33012:ee,33013:pe,33014:Sf,33015:pe,33016:ee,33017:wi,33018:ee,33020:ee,33021:qe,33022:pe,33023:ee,33024:pe,33025:pe,33026:ee,33027:pe,33028:pe,33029:pe,33034:ee,33035:ee,33036:ee,33037:ee,33038:ee,33039:ee,33040:ee,33041:ee,33042:ee,33043:ee,33044:ee,33045:ee,33046:ee,33047:ee,33048:ee,33049:ee,33050:ee,33051:ee,33059:qe,33060:qe,33061:ee,33062:ee,33063:ee,33064:ee,33065:ee,21009:ee,34001:St,34002:Lk,34003:ee,34004:ee,34005:ee,34006:ee,34007:ee,34008:wi,34009:ee,34010:ee,34011:ee,34012:ee,34013:ee,34014:ee,34015:ee,34016:St,34017:jr,34018:bt,34019:St,34020:St,34021:Lk,34022:ee,34023:St,34026:ee,34036:ee,34037:ee,34038:ee,34039:ee,35001:ee,35002:ee,35003:ee,35004:ee,35005:bt,35008:pe,35010:pe,35012:pe,35014:pe,35015:pe,35017:ee,35019:pe,35020:pe,35021:pe,35022:ee,35024:ee,35025:wi,35026:ee,35029:Sf,35030:pe,35031:pe,35032:ee,35037:ee,35039:ee,35040:pe,35044:ee,35046:wi,35047:wi,35048:ee,35049:pe,35050:pe,35052:wi,35053:ee,35055:wi,35057:ee,35058:ee,35059:qe,35060:qe,35061:qe,35062:pe,35063:pe,35064:pe,35066:pe,35067:pe,35068:pe,35069:pe,35070:pe,35071:pe,35072:pe,35073:pe,35074:pe,35075:pe,35076:pe,35077:pe,35078:pe,35079:pe,35080:pe,35081:pe,35082:pe,35083:pe,35084:pe,35085:pe,35086:pe,35087:pe,35088:pe,35089:pe,35090:ee,35091:ee,35092:ee,35093:ee,35094:ee,35095:qe,35096:ee,35097:ee,35098:ee,35099:ee,36001:qe,36002:qe,36005:ee,36101:bt,36102:St,36103:jr,36104:St,36105:St,36106:jr,36107:St,36108:wi,36109:St,36201:St,36202:St,36203:pe,36204:ee,36205:qe,36206:qe,36207:pe,36208:pe,36209:pe,36210:pe,36211:pe,36212:pe,36213:pe,36214:ee,36216:Sf,36217:pe,36218:pe,36219:pe,36220:pe,36221:pe,36222:pe,36223:pe,36224:pe,36225:pe,36226:pe,36227:pe,36228:pe,36229:pe,36230:pe,400:qe,401:bt,403:St,404:qe,405:qe,415:qe,429:Am,500:rc,1001:Bm,1002:ee,1003:ee,40001:bt,40002:bt,40003:bt,40004:ac,40005:ac,40006:bt,40007:qe,40008:ac,40009:bt,40010:bt,40011:bt,40012:bt,40013:ee,40014:St,40015:ee,40016:St,40017:ee,40018:St,40102:qe,40103:qe,40104:ee,40105:ee,40106:ee,40107:ee,40108:pe,40109:Sf,40200:Pm,40201:pe,40202:ee,40203:qe,40204:qe,40205:qe,40206:qe,40207:qe,40208:qe,40209:qe,40300:ee,40301:St,40302:qe,40303:qe,40304:qe,40305:qe,40306:ee,40308:Pm,40309:hr,40400:ee,40401:ee,40402:qe,40403:qe,40404:qe,40405:qe,40406:qe,40407:ee,40408:ee,40409:ee,40500:pe,40501:ee,40502:ee,40503:ee,40504:ee,40505:ee,40506:bt,40507:bt,40508:ee,40509:ee,40600:ee,40601:ee,40602:ee,40603:ee,40604:rc,40605:ee,40606:ee,40607:ee,40608:ee,40609:ee,40700:qe,40701:ee,40702:ee,40703:ee,40704:ee,40705:qe,40706:pe,40707:qe,40708:qe,40709:ee,40710:ee,40711:wi,40712:wi,40713:ee,40714:ee,"invalid sign":bt,"invalid currency":hr,"invalid symbol":hr,"invalid period":qe,"invalid user":ee,"invalid amount":pe,"invalid type":pe,"invalid orderId":pe,"invalid record":ee,"invalid accountId":qe,"invalid address":qe,"accesskey not null":bt,"illegal accesskey":bt,"sign not null":bt,"req_time is too much difference from server time":ac,"permissions not right":St,"illegal sign invalid":bt,"user locked":jr,"Request Frequency Is Too High":Bm,"more than a daily rate of cash":qe,"more than the maximum daily withdrawal amount":qe,"need to bind email or mobile":ee,"user forbid":St,"User Prohibited Cash Withdrawal":St,"Cash Withdrawal Is Less Than The Minimum Value":qe,"Cash Withdrawal Is More Than The Maximum Value":qe,"the account with in 24 hours ban coin":St,"order cancel fail":qe,"base symbol error":hr,"base date error":ee,"api signature not valid":bt,"gateway internal error":ee,"audit failed":ee,"order queryorder invalid":qe,"market no need price":pe,"limit need price":pe,"userid not equal to account_id":ee,"your balance is low":wi,"address invalid cointype":ee,"system exception":ee,50003:ee,50004:hr,50006:St,50007:St,50008:Rk,50009:Bm,50010:ee,50014:pe,50015:pe,50016:pe,50017:pe,50018:pe,50019:pe,50020:wi,50021:pe,50026:pe,"invalid order query time":ee,"invalid start time":qe,"invalid end time":qe,20003:ee,"01001":ee,43111:St},broad:{"invalid size, valid range":ee}},precisionMode:W5,commonCurrencies:{JADE:"Jade Protocol"},options:{timeframes:{spot:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"1h","4h":"4h","6h":"6h","12h":"12h","1d":"1day","3d":"3day","1w":"1week","1M":"1M"},swap:{"1m":"60","5m":"300","15m":"900","30m":"1800","1h":"3600","4h":"14400","12h":"43200","1d":"86400","1w":"604800"}},fetchMarkets:["spot","swap"],defaultType:"spot",defaultSubType:"linear",createMarketBuyOrderRequiresPrice:!0,broker:{spot:"CCXT#",swap:"CCXT#"},withdraw:{fillResponseFromRequest:!0}}})}async fetchTime(e={}){const t=await this.publicSpotGetPublicTime(e);return this.safeInteger(t,"data")}async fetchMarkets(e={}){const t=this.safeValue(this.options,"fetchMarkets",["spot","swap"]);let s=[];for(let i=0;i<t.length;i++){const n=t[i];if(n==="swap"){const r=["umcbl","dmcbl","cmcbl","sumcbl","sdmcbl","scmcbl"];for(let a=0;a<r.length;a++){const o=await this.fetchMarketsByType(n,this.extend(e,{productType:r[a]}));s=this.arrayConcat(s,o)}}else{const r=await this.fetchMarketsByType(t[i],e);s=this.arrayConcat(s,r)}}return s}parseMarkets(e){const t=[];for(let s=0;s<e.length;s++)t.push(this.parseMarket(e[s]));return t}parseMarket(e){const t=this.safeString(e,"symbol"),s=this.safeString(e,"quoteCoin"),i=this.safeString(e,"baseCoin"),n=this.safeCurrencyCode(s),r=this.safeCurrencyCode(i),a=this.safeValue(e,"supportMarginCoins",[]),o=this.safeString(a,0),d=this.safeCurrencyCode(o);let c=r+"/"+n;const u=t.split("_"),h=this.safeString(u,1);let l,p=!1,m=!1,g=!1,y=!1,b,w,k,T,O,x;if(h==="SPBL")l="spot",m=!0,b=this.parseNumber(this.parsePrecision(this.safeString(e,"priceScale"))),w=this.parseNumber(this.parsePrecision(this.safeString(e,"quantityScale")));else{const P=this.safeString(u,2);if(P!==void 0){const Q="20"+P.slice(0,2),J=P.slice(2,4),se=P.slice(4,6);x=Q+"-"+J+"-"+se+"T00:00:00Z",O=this.parse8601(x),l="future",g=!0,c=c+":"+d+"-"+P}else l="swap",p=!0,c=c+":"+d;y=!0;const _=h==="SUMCBL",S=h==="SDMCBL",I=h==="SCMCBL";k=h==="UMCBL"||h==="CMCBL"||_||I,T=!k,(_||S||I)&&(c=t);const v=this.safeInteger(e,"pricePlace"),N=this.safeInteger(e,"volumePlace"),q=this.safeString(e,"priceEndStep"),R=this.safeString(e,"minTradeNum"),G=new oc(q);G.decimals=Math.max(G.decimals,v),G.reduce();const F=G.toString();b=this.parseNumber(F);const A=new oc(R);A.decimals=Math.max(A.decimals,N),A.reduce();const V=A.toString();w=this.parseNumber(V)}const C=this.safeString(e,"status");let E;return C!==void 0&&(E=C==="online"),{id:t,symbol:c,base:r,quote:n,settle:d,baseId:i,quoteId:s,settleId:o,type:l,spot:m,margin:!1,swap:p,future:g,option:!1,active:E,contract:y,linear:k,inverse:T,taker:this.safeNumber(e,"takerFeeRate"),maker:this.safeNumber(e,"makerFeeRate"),contractSize:this.safeNumber(e,"sizeMultiplier"),expiry:O,expiryDatetime:x,strike:void 0,optionType:void 0,precision:{amount:w,price:b},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(e,"minTradeNum"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:e}}async fetchMarketsByType(e,t={}){const s=this.getSupportedMapping(e,{spot:"publicSpotGetPublicProducts",swap:"publicMixGetMarketContracts"}),i=await this[s](t),n=this.safeValue(i,"data",[]);return this.parseMarkets(n)}async fetchCurrencies(e={}){const t=await this.publicSpotGetPublicCurrencies(e),s={},i=this.safeValue(t,"data",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"coinId"),o=this.safeCurrencyCode(this.safeString(r,"coinName")),d=this.safeValue(r,"chains",[]),c={};for(let u=0;u<d.length;u++){const h=d[u],l=this.safeString(h,"chain"),p=this.safeCurrencyCode(l),m=this.safeString(h,"withdrawable"),g=this.safeString(h,"rechargeable");c[p]={info:h,id:l,network:p,limits:{withdraw:{min:this.safeNumber(h,"minWithdrawAmount"),max:void 0},deposit:{min:this.safeNumber(h,"minDepositAmount"),max:void 0}},active:void 0,withdraw:m==="true",deposit:g==="true",fee:this.safeNumber(h,"withdrawFee"),precision:void 0}}s[o]={info:r,id:a,code:o,networks:c,type:void 0,name:void 0,active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,precision:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}}}return s}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),e===void 0)throw new vs(this.id+" fetchDeposits() requires a `code` argument");const n=this.currency(e);t===void 0&&(t=this.milliseconds()-31556952e3);const r={coin:n.code,startTime:t,endTime:this.milliseconds()};s!==void 0&&(r.pageSize=s);const a=await this.privateSpotGetWalletDepositList(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s)}async withdraw(e,t,s,i=void 0,n={}){this.checkAddress(s);const r=this.safeString(n,"chain");if(r===void 0)throw new vs(this.id+" withdraw() requires a chain parameter");await this.loadMarkets();const o={coin:this.currency(e).code,address:s,chain:r,amount:t};i!==void 0&&(o.tag=i);const d=await this.privateSpotPostWalletWithdrawal(this.extend(o,n)),c={id:this.safeString(d,"data"),info:d,txid:void 0,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:"withdrawal",currency:void 0,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0},u=this.safeValue(this.options,"withdraw",{});return this.safeValue(u,"fillResponseFromRequest",!0)&&(c.currency=e,c.timestamp=this.milliseconds(),c.datetime=this.iso8601(this.milliseconds()),c.amount=t,c.tag=i,c.address=s,c.addressTo=s,c.network=r),c}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),e===void 0)throw new vs(this.id+" fetchWithdrawals() requires a `code` argument");const n=this.currency(e);t===void 0&&(t=this.milliseconds()-31556952e3);const r={coin:n.code,startTime:t,endTime:this.milliseconds()};s!==void 0&&(r.pageSize=s);const a=await this.privateSpotGetWalletWithdrawalList(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s)}parseTransaction(e,t=void 0){const s=this.safeInteger(e,"cTime"),i=this.safeString(e,"chain"),n=this.safeString(e,"coin"),r=this.safeString(e,"status");return{id:this.safeString(e,"id"),info:e,txid:this.safeString(e,"txId"),timestamp:s,datetime:this.iso8601(s),network:i,addressFrom:void 0,address:this.safeString(e,"toAddress"),addressTo:this.safeString(e,"toAddress"),amount:this.safeNumber(e,"amount"),type:this.safeString(e,"type"),currency:this.safeCurrencyCode(n),status:this.parseTransactionStatus(r),updated:this.safeNumber(e,"uTime"),tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0}}parseTransactionStatus(e){const t={success:"ok",Pending:"pending",pending_review:"pending",pending_review_fail:"failed",reject:"failed"};return this.safeString(t,e,e)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={coin:s.code},n=await this.privateSpotGetWalletDepositAddress(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseDepositAddress(r,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"coin"),i=this.safeString(e,"chain");return{currency:this.safeCurrencyCode(s,t),address:this.safeString(e,"address"),tag:this.safeString(e,"tag"),network:i,info:e}}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),[n,r]=this.handleMarketTypeAndParams("fetchOrderBook",i,s),a=this.getSupportedMapping(n,{spot:"publicSpotGetMarketDepth",swap:"publicMixGetMarketDepth"}),o={symbol:i.id};t!==void 0&&(o.limit=t);const d=await this[a](this.extend(o,r)),c=this.safeValue(d,"data"),u=this.safeInteger(c,"timestamp");return this.parseOrderBook(c,e,u)}parseTicker(e,t=void 0){let s=this.safeString(e,"symbol");s in this.markets_by_id||(s+="_SPBL");const i=this.safeSymbol(s,t),n=this.safeString(e,"high24h"),r=this.safeString(e,"low24h"),a=this.safeString2(e,"close","last"),o=this.safeString2(e,"quoteVol","quoteVolume"),d=this.safeString2(e,"baseVol","baseVolume"),c=this.safeInteger2(e,"ts","timestamp"),u=this.iso8601(c),h=this.safeString2(e,"buyOne","bestBid"),l=this.safeString2(e,"sellOne","bestAsk"),p=oc.stringMul(this.safeString(e,"priceChangePercent"),"100");return this.safeTicker({symbol:i,timestamp:c,datetime:u,high:n,low:r,bid:h,bidVolume:void 0,ask:l,askVolume:void 0,vwap:void 0,open:void 0,close:a,last:void 0,previousClose:void 0,change:void 0,percentage:p,average:void 0,baseVolume:d,quoteVolume:o,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},[n,r]=this.handleMarketTypeAndParams("fetchTicker",s,t),a=this.getSupportedMapping(n,{spot:"publicSpotGetMarketTicker",swap:"publicMixGetMarketTicker"}),o=await this[a](this.extend(i,r)),d=this.safeValue(o,"data");return this.parseTicker(d,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();let s,i;if(e!==void 0){const d=this.safeValue(e,0);i=this.market(d)}[s,t]=this.handleMarketTypeAndParams("fetchTickers",i,t);const n=this.getSupportedMapping(s,{spot:"publicSpotGetMarketTickers",swap:"publicMixGetMarketTickers"}),r={};if(n==="publicMixGetMarketTickers"){const d=this.safeString(this.options,"defaultSubType");r.productType=d==="linear"?"UMCBL":"DMCBL"}const a=await this[n](this.extend(r,t)),o=this.safeValue(a,"data");return this.parseTickers(o,e)}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeString2(e,"tradeId","fillId"),r=this.safeString(e,"orderId"),a=this.safeString(e,"side"),o=this.safeString2(e,"fillPrice","price");let d=this.safeString2(e,"fillQuantity","size");d=this.safeString(e,"sizeQty",d);let c=this.safeInteger2(e,"fillTime","timestamp");c=this.safeInteger(e,"cTime",c);let u;const h=this.safeString(e,"fees"),l=this.safeString(e,"orderType");if(h!==void 0){const m=this.safeCurrencyCode(this.safeString(e,"feeCcy"));u={code:m,currency:m,cost:h}}const p=this.iso8601(c);return this.safeTrade({info:e,id:n,order:r,symbol:i,side:a,type:l,takerOrMaker:void 0,price:o,amount:d,cost:void 0,fee:u,timestamp:c,datetime:p},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};t!==void 0&&(r.limit=t);const[a,o]=this.handleMarketTypeAndParams("fetchTrades",n,i),d=this.getSupportedMapping(a,{spot:"publicSpotGetMarketFills",swap:"publicMixGetMarketFills"}),c=await this[d](this.extend(r,o)),u=this.safeValue(c,"data",[]);return this.parseTrades(u,n,s,t)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicSpotGetPublicProduct(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTradingFee(r,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicSpotGetPublicProducts(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.parseTradingFee(r),o=a.symbol;i[o]=a}return i}parseTradingFee(e,t=void 0){const s=this.safeString(e,"symbol");return{info:e,symbol:this.safeSymbol(s,t),maker:this.safeNumber(e,"makerFeeRate"),taker:this.safeNumber(e,"takerFeeRate")}}parseOHLCV(e,t=void 0,s="1m"){return[this.safeInteger2(e,0,"ts"),this.safeNumber2(e,1,"open"),this.safeNumber2(e,2,"high"),this.safeNumber2(e,3,"low"),this.safeNumber2(e,4,"close"),this.safeNumber2(e,5,"baseVol")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id},[o,d]=this.handleMarketTypeAndParams("fetchOHLCV",r,n),c=this.getSupportedMapping(o,{spot:"publicSpotGetMarketCandles",swap:"publicMixGetMarketCandles"}),u=this.safeInteger2(n,"until","till");if(n=this.omit(n,["until","till"]),i===void 0&&(i=100),r.type==="spot"){if(a.period=this.options.timeframes.spot[t],a.limit=i,s!==void 0&&(a.after=s,u===void 0)){const p=this.options.timeframes.swap[t]*1e3;a.before=this.sum(s,p*i)}u!==void 0&&(a.before=u)}else if(r.type==="swap"){a.granularity=this.options.timeframes.swap[t];const p=this.parseTimeframe(t),m=this.milliseconds();s===void 0?(a.startTime=m-(i-1)*(p*1e3),a.endTime=m):(a.startTime=this.sum(s,p*1e3),u!==void 0?a.endTime=u:a.endTime=this.sum(s,i*p*1e3))}const h=await this[c](this.extend(a,d)),l=this.safeValue(h,"data",h);return this.parseOHLCVs(l,r,t,s,i)}async fetchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),i=this.getSupportedMapping(t,{spot:"privateSpotGetAccountAssets",swap:"privateMixGetAccountAccounts"}),n={};if(t==="swap"){const o=this.safeString(this.options,"defaultSubType");n.productType=o==="linear"?"UMCBL":"DMCBL"}const r=await this[i](this.extend(n,s)),a=this.safeValue(r,"data");return this.parseBalance(a)}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString2(i,"coinId","marginCoin"),r=this.safeCurrencyCode(n),a=this.account();a.used=this.safeString2(i,"lock","locked"),a.free=this.safeString(i,"available"),t[r]=a}return this.safeBalance(t)}parseOrderStatus(e){const t={new:"open",full_fill:"closed",filled:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s);const i=t.symbol,n=this.safeString(e,"orderId"),r=this.safeString2(e,"price","executePrice"),a=this.safeString2(e,"quantity","size"),o=this.safeString2(e,"fillQuantity","filledQty"),d=this.safeString2(e,"fillTotalAmount","filledAmount"),c=this.safeString(e,"fillPrice"),u=this.safeString(e,"orderType"),h=this.safeInteger(e,"cTime");let l=this.safeString2(e,"side","posSide");l==="open_long"||l==="close_short"?l="buy":(l==="close_long"||l==="open_short")&&(l="sell");const p=this.safeString2(e,"clientOrderId","clientOid"),m=void 0,g=this.safeString2(e,"status","state"),y=this.parseOrderStatus(g),b=this.safeInteger(e,"uTime");return this.safeOrder({info:e,id:n,clientOrderId:p,timestamp:h,datetime:this.iso8601(h),lastTradeTimestamp:b,symbol:i,type:u,timeInForce:void 0,postOnly:void 0,side:l,price:r,stopPrice:this.safeNumber(e,"triggerPrice"),average:c,cost:d,amount:a,filled:o,remaining:void 0,status:y,fee:m,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),[o,d]=this.handleMarketTypeAndParams("createOrder",a,r),c={symbol:a.id,orderType:t},u=t==="market",h=this.safeValue2(r,"stopPrice","triggerPrice"),l=h!==void 0,p=this.safeValue(r,"stopLossPrice"),m=p!==void 0,g=this.safeValue(r,"takeProfitPrice"),y=g!==void 0,b=m||y;if(this.sum(l,m,y)>1)throw new ee(this.id+" createOrder() params can only contain one of triggerPrice, stopLossPrice, takeProfitPrice");t==="limit"&&h===void 0&&(c.price=this.priceToPrecision(e,n));let w=this.safeString2(r,"client_oid","clientOrderId");if(w===void 0){const P=this.safeValue(this.options,"broker");if(P!==void 0){const _=this.safeString(P,a.type);_!==void 0&&(w=_+this.uuid22())}}let k=this.getSupportedMapping(o,{spot:"privateSpotPostTradeOrders",swap:"privateMixPostOrderPlaceOrder"});const T=this.safeString2(r,"force","timeInForceValue"),O=this.isPostOnly(u,T==="post_only",r);if(o==="spot"){if(b)throw new pe(this.id+" createOrder() does not support stop orders on spot markets, only swap markets");if(this.safeValue(this.options,"createMarketBuyOrderRequiresPrice",!0)&&u&&s==="buy"){if(n===void 0)throw new pe(this.id+" createOrder() requires price argument for market buy orders on spot markets to calculate the total amount to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option to false and pass in the cost to spend into the amount parameter");{const _=this.numberToString(i),S=this.numberToString(n),I=this.parseNumber(oc.stringMul(_,S));c.quantity=this.priceToPrecision(e,I)}}else c.quantity=this.amountToPrecision(e,i);c.clientOrderId=w,c.side=s,O?c.force="post_only":c.force="gtc"}else{c.clientOid=w,c.size=this.amountToPrecision(e,i),O&&(c.timeInForceValue="post_only");const P=this.safeValue(r,"reduceOnly",!1);if(h!==void 0){const _=this.safeString(r,"triggerType","market_price");c.triggerType=_,c.triggerPrice=this.priceToPrecision(e,h),c.executePrice=this.priceToPrecision(e,n),k="privateMixPostPlanPlacePlan"}if(b){if(!u)throw new ee(this.id+" createOrder() bitget stopLoss or takeProfit orders must be market orders");m?(c.triggerPrice=this.priceToPrecision(e,p),c.planType="loss_plan"):y&&(c.triggerPrice=this.priceToPrecision(e,g),c.planType="profit_plan"),c.holdSide=s==="buy"?"long":"short",k="privateMixPostPlanPlaceTPSL"}else P?c.side=s==="buy"?"close_short":"close_long":c.side=s==="buy"?"open_long":"open_short";c.marginCoin=a.settleId}const x=this.omit(d,["stopPrice","triggerType","stopLossPrice","takeProfitPrice","postOnly"]),C=await this[k](this.extend(c,x)),E=this.safeValue(C,"data");return this.parseOrder(E,a)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new vs(this.id+" cancelOrder() requires a symbol argument for spot orders");await this.loadMarkets();const i=this.market(t),[n,r]=this.handleMarketTypeAndParams("cancelOrder",i,s);let a=this.getSupportedMapping(n,{spot:"privateSpotPostTradeCancelOrder",swap:"privateMixPostOrderCancelOrder"});const o={symbol:i.id,orderId:e};if(this.safeValue(s,"stop")){const u=this.safeString(s,"planType");if(u===void 0)throw new vs(this.id+" cancelOrder() requires a planType parameter for stop orders, either normal_plan, profit_plan or loss_plan");o.planType=u,a="privateMixPostPlanCancelPlan",s=this.omit(s,["stop","planType"])}n==="swap"&&(o.marginCoin=i.settleId);const c=await this[a](this.extend(o,r));return this.parseOrder(c,i)}async cancelOrders(e,t=void 0,s={}){if(t===void 0)throw new vs(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=this.safeString(s,"type",i.type);if(n===void 0)throw new vs(this.id+" cancelOrders() requires a type parameter (one of 'spot', 'swap').");s=this.omit(s,"type");const r={};let a;if(n==="spot"){a="apiPostOrderOrdersBatchcancel",r.method="batchcancel";const c=this.json(e).split('"');r.order_ids=c.join("")}else n==="swap"&&(a="privateMixPostOrderCancelBatchOrders",r.symbol=i.id,r.marginCoin=i.quote,r.orderIds=e);return await this[a](this.extend(r,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s=this.safeString2(t,"code","marginCoin");if(s===void 0)throw new vs(this.id+" cancelAllOrders () requires a code argument in the params");let i,n=this.safeString(this.options,"defaultSubType");e!==void 0&&(i=this.market(e),n=i.linear?"linear":"inverse");const r=n==="linear"?"UMCBL":"DMCBL",[a,o]=this.handleMarketTypeAndParams("cancelAllOrders",i,t);if(a==="spot")throw new $5(this.id+" cancelAllOrders () does not support spot markets");const d=this.currency(s),c={marginCoin:this.safeCurrencyCode(s,d),productType:r};return t=this.omit(o,["code","marginCoin"]),await this.privateMixPostOrderCancelAllOrders(this.extend(c,t))}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new vs(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),[n,r]=this.handleMarketTypeAndParams("fetchOrder",i,s),a=this.getSupportedMapping(n,{spot:"privateSpotPostTradeOrderInfo",swap:"privateMixGetOrderDetail"}),o={symbol:i.id,orderId:e},d=await this[a](this.extend(o,r)),c=this.safeValue(d,"data"),u=this.safeValue(c,0,c);return this.parseOrder(u,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new vs(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),[r,a]=this.handleMarketTypeAndParams("fetchOpenOrders",n,i),o={symbol:n.id};let d=this.getSupportedMapping(r,{spot:"privateSpotPostTradeOpenOrders",swap:"privateMixGetOrderCurrent"});this.safeValue(i,"stop")&&(d="privateMixGetPlanCurrentPlan",i=this.omit(i,"stop"));const u=await this[d](this.extend(o,a)),h=this.safeValue(u,"data",[]);return this.parseOrders(h,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new vs(this.id+" fetchClosedOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),[r,a]=this.handleMarketTypeAndParams("fetchClosedOrders",n,i),o={symbol:n.id},d=this.getSupportedMapping(r,{spot:"privateSpotPostTradeHistory",swap:"privateMixGetOrderHistory"});r==="swap"&&(s===void 0&&(s=100),o.pageSize=s,t===void 0&&(t=0),o.startTime=t,o.endTime=this.milliseconds());const c=await this[d](this.extend(o,a)),u=this.safeValue(c,"data"),h=this.safeValue(u,"orderList",u);return this.parseOrders(h,n,t,s)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.coinId=n.id);const a=await this.privateSpotPostAccountBills(this.extend(r,i)),o=this.safeValue(a,"data");return this.parseLedger(o,n,t,s)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"billId"),i=this.safeString(e,"coinId"),n=this.safeCurrencyCode(i),r=this.parseNumber(oc.stringAbs(this.safeString(e,"quantity"))),a=this.safeInteger(e,"cTime"),o=this.safeString(e,"bizType");let d;o!==void 0&&o.indexOf("-")>=0&&(d=o.split("-")[1]);const c=this.safeString(e,"groupType"),u=this.safeNumber(e,"fees"),h=this.safeNumber(e,"balance");return{info:e,id:s,timestamp:a,datetime:this.iso8601(a),direction:d,account:void 0,referenceId:void 0,referenceAccount:void 0,type:c,currency:n,amount:r,before:void 0,after:h,status:void 0,fee:u}}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new vs(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e);if(n.swap)throw new hr(this.id+" fetchMyTrades() only supports spot markets");const r={symbol:n.id};s!==void 0&&(r.limit=s);const a=await this.privateSpotPostTradeFills(this.extend(r,i)),o=this.safeValue(a,"data");return this.parseTrades(o,n,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){if(t===void 0)throw new vs(this.id+" fetchOrderTrades() requires a symbol argument");await this.loadMarkets();const r=this.market(t),[a,o]=this.handleMarketTypeAndParams("fetchOrderTrades",r,n),d=this.getSupportedMapping(a,{spot:"privateSpotPostTradeFills",swap:"privateMixGetOrderFills"}),c={symbol:r.id,orderId:e},u=await this[d](this.extend(c,o)),h=this.safeValue(u,"data");return await this.parseTrades(h,r,s,i)}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id,marginCoin:s.settleId},n=await this.privateMixGetPositionSinglePosition(this.extend(i,t)),r=this.safeValue(n,"data",[]);return this.parsePosition(r[0],s)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const i={productType:this.safeString(this.options,"defaultSubType")==="linear"?"UMCBL":"DMCBL"},n=await this.privateMixGetPositionAllPosition(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=[];for(let o=0;o<r.length;o++)a.push(this.parsePosition(r[o]));return e=this.marketSymbols(e),this.filterByArray(a,"symbol",e,!1)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeInteger(e,"cTime");let n=this.safeString(e,"marginMode");n==="fixed"?n="isolated":n==="crossed"&&(n="cross");let r=this.safeString(e,"holdMode");r==="double_hold"?r=!0:r==="single_hold"&&(r=!1);let a=this.safeInteger(e,"openDelegateCount"),o=this.safeNumber(e,"liquidationPrice");return a===0&&(a=void 0),o===0&&(o=void 0),{info:e,id:void 0,symbol:t.symbol,notional:void 0,marginMode:n,liquidationPrice:o,entryPrice:this.safeNumber(e,"averageOpenPrice"),unrealizedPnl:this.safeNumber(e,"unrealizedPL"),percentage:void 0,contracts:a,contractSize:this.safeNumber(e,"total"),markPrice:void 0,side:this.safeString(e,"holdSide"),hedged:r,timestamp:i,datetime:this.iso8601(i),maintenanceMargin:void 0,maintenanceMarginPercentage:this.safeNumber(e,"keepMarginRate"),collateral:this.safeNumber(e,"margin"),initialMargin:void 0,initialMarginPercentage:void 0,leverage:this.safeNumber(e,"leverage"),marginRatio:void 0}}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new vs(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.pageSize=s);const a=await this.publicMixGetMarketHistoryFundRate(this.extend(r,i)),o=this.safeValue(a,"data",[]),d=[];for(let u=0;u<o.length;u++){const h=o[u],l=this.safeString(h,"symbol"),p=this.safeSymbol(l,n),m=this.safeInteger(h,"settleTime");d.push({info:h,symbol:p,fundingRate:this.safeString(h,"fundingRate"),timestamp:m,datetime:this.iso8601(m)})}const c=this.sortBy(d,"timestamp");return this.filterBySymbolSinceLimit(c,n.symbol,t,s)}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new hr(this.id+" fetchFundingRate() supports swap contracts only");const i={symbol:s.id},n=await this.publicMixGetMarketCurrentFundRate(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseFundingRate(r,s)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t);return{info:e,symbol:i,markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeNumber(e,"fundingRate"),fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets();const n=this.safeString(i,"holdSide"),r=this.market(e),a=r.linear?r.quote:r.base,o={symbol:r.id,marginCoin:a,amount:this.amountToPrecision(e,t),holdSide:n};i=this.omit(i,"holdSide");const d=await this.privateMixPostAccountSetMargin(this.extend(o,i));return this.extend(this.parseMarginModification(d,r),{amount:this.parseNumber(t),type:s})}parseMarginModification(e,t=void 0){const i=this.safeString(e,"code")==="00000"?"ok":"failed",n=t.linear?t.quote:t.base;return{info:e,type:void 0,amount:void 0,code:n,symbol:t.symbol,status:i}}async reduceMargin(e,t,s={}){if(t>0)throw new qe(this.id+" reduceMargin() amount parameter must be a negative value");if(this.safeString(s,"holdSide")===void 0)throw new vs(this.id+" reduceMargin() requires a holdSide parameter, either long or short");return await this.modifyMarginHelper(e,t,"reduce",s)}async addMargin(e,t,s={}){if(this.safeString(s,"holdSide")===void 0)throw new vs(this.id+" addMargin() requires a holdSide parameter, either long or short");return await this.modifyMarginHelper(e,t,"add",s)}async fetchLeverage(e,t={}){await this.loadMarkets();const i={symbol:this.market(e).id};return await this.publicMixGetMarketSymbolLeverage(this.extend(i,t))}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new vs(this.id+" setLeverage() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={symbol:i.id,marginCoin:i.settleId,leverage:e};return await this.privateMixPostAccountSetLeverage(this.extend(n,s))}async setMarginMode(e,t=void 0,s={}){if(t===void 0)throw new vs(this.id+" setMarginMode() requires a symbol argument");if(e=e.toLowerCase(),e!=="fixed"&&e!=="crossed")throw new vs(this.id+' setMarginMode() marginMode must be "fixed" or "crossed"');await this.loadMarkets();const i=this.market(t),n={symbol:i.id,marginCoin:i.settleId,marginMode:e};return await this.privateMixPostAccountSetMarginMode(this.extend(n,s))}async fetchOpenInterest(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.contract)throw new qe(this.id+" fetchOpenInterest() supports contract markets only");const i={symbol:s.id},n=await this.publicMixGetMarketOpenInterest(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseOpenInterest(r,s)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=s==="swap",o=i==="swap",d=r.code==="USDT";a?s=d?"mix_usdt":"mix_usd":o&&(i=d?"mix_usdt":"mix_usd");const c={fromType:s,toType:i,amount:t,coin:r.info.coinName},u=await this.privateSpotPostWalletTransfer(this.extend(c,n));return this.parseTransfer(u,r)}parseTransfer(e,t=void 0){const s=this.safeInteger(e,"requestTime"),i=this.safeString(e,"msg");return{info:e,id:this.safeString(e,"id"),timestamp:s,datetime:this.iso8601(s),currency:this.safeString(t,"code"),amount:this.safeNumber(e,"size"),fromAccount:void 0,toAccount:void 0,status:i==="success"?"ok":i}}parseTransferStatus(e){const t={success:"ok"};return this.safeString(t,e,e)}parseOpenInterest(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const n=this.safeNumber(e,"amount");return{symbol:this.safeSymbol(i),baseVolume:n,quoteVolume:void 0,openInterestAmount:n,openInterestValue:void 0,timestamp:s,datetime:this.iso8601(s),info:e}}handleErrors(e,t,s,i,n,r,a,o,d){if(!a)return;const c=this.safeString(a,"err_msg"),u=this.safeString2(a,"code","err_code"),h=this.id+" "+r,l=c!==void 0&&c!=="";l&&(this.throwExactlyMatchedException(this.exceptions.exact,c,h),this.throwBroadlyMatchedException(this.exceptions.broad,c,h));const p=u!==void 0&&u!=="00000";if(p&&this.throwExactlyMatchedException(this.exceptions.exact,u,h),p||l)throw new ee(h)}sign(e,t=[],s="GET",i={},n=void 0,r=void 0){const a=t[0]==="private",o=t[1],d=o==="spot"?"/api/spot/v1":"/api/mix/v1",c="/"+this.implodeParams(e,i),u=d+c;let h=this.implodeHostname(this.urls.api[o])+u;const l=this.omit(i,this.extractParams(e));if(!a&&s==="GET"&&Object.keys(l).length>0&&(h=h+"?"+this.urlencode(l)),a){this.checkRequiredCredentials();const p=this.milliseconds().toString();let m=p+s+u;if(s==="POST")r=this.json(i),m+=r;else if(Object.keys(i).length){const y="?"+this.urlencode(this.keysort(i));h+=y,m+=y}const g=this.hmac(this.encode(m),this.encode(this.secret),"sha256","base64");n={"ACCESS-KEY":this.apiKey,"ACCESS-SIGN":g,"ACCESS-TIMESTAMP":p,"ACCESS-PASSPHRASE":this.password},s==="POST"&&(n["Content-Type"]="application/json")}return{url:h,method:s,body:r,headers:n}}};const K5=ge,{ExchangeError:vf,ExchangeNotAvailable:X5,AuthenticationError:Em,BadRequest:Nm,PermissionDenied:Fk,InvalidAddress:Y5,ArgumentsRequired:dc,InvalidOrder:Q5}=de,{DECIMAL_PLACES:Z5,SIGNIFICANT_DIGITS:J5,TRUNCATE:e6}=me,t6=Se;var s6=class extends K5{describe(){return this.deepExtend(super.describe(),{id:"bithumb",name:"Bithumb",countries:["KR"],rateLimit:500,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTransfer:!1,fetchTransfers:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},hostname:"bithumb.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/30597177-ea800172-9d5e-11e7-804c-b9d4fa9b56b0.jpg",api:{public:"https://api.{hostname}/public",private:"https://api.{hostname}"},www:"https://www.bithumb.com",doc:"https://apidocs.bithumb.com",fees:"https://en.bithumb.com/customer_support/info_fee"},api:{public:{get:["ticker/{currency}","ticker/all","ticker/ALL_BTC","ticker/ALL_KRW","orderbook/{currency}","orderbook/all","transaction_history/{currency}","transaction_history/all","candlestick/{currency}/{interval}"]},private:{post:["info/account","info/balance","info/wallet_address","info/ticker","info/orders","info/user_transactions","info/order_detail","trade/place","trade/cancel","trade/btc_withdrawal","trade/krw_deposit","trade/krw_withdrawal","trade/market_buy","trade/market_sell"]}},fees:{trading:{maker:this.parseNumber("0.0025"),taker:this.parseNumber("0.0025")}},precisionMode:J5,exceptions:{"Bad Request(SSL)":Nm,"Bad Request(Bad Method)":Nm,"Bad Request.(Auth Data)":Em,"Not Member":Em,"Invalid Apikey":Em,"Method Not Allowed.(Access IP)":Fk,"Method Not Allowed.(BTC Adress)":Y5,"Method Not Allowed.(Access)":Fk,"Database Fail":X5,"Invalid Parameter":Nm,5600:vf,"Unknown Error":vf,"After May 23th, recent_transactions is no longer, hence users will not be able to connect to recent_transactions":vf},timeframes:{"1m":"1m","3m":"3m","5m":"5m","10m":"10m","30m":"30m","1h":"1h","6h":"6h","12h":"12h","1d":"24h"},options:{quoteCurrencies:{BTC:{limits:{cost:{min:2e-4,max:100}}},KRW:{limits:{cost:{min:500,max:5e9}}}}},commonCurrencies:{FTC:"FTC2",SOC:"Soda Coin"}})}amountToPrecision(e,t){return this.decimalToPrecision(t,e6,this.markets[e].precision.amount,Z5)}async fetchMarkets(e={}){const t=[],s=this.safeValue(this.options,"quoteCurrencies",{}),i=Object.keys(s);for(let n=0;n<i.length;n++){const r=i[n],a=r,o=this.safeValue(s,r,{}),d="publicGetTickerALL"+r,c=await this[d](e),u=this.safeValue(c,"data"),h=Object.keys(u);for(let l=0;l<h.length;l++){const p=h[l];if(p==="date")continue;const m=u[p],g=this.safeCurrencyCode(p);let y=!0;Array.isArray(m)&&m.length===0&&(y=!1);const b=this.deepExtend({id:p,symbol:g+"/"+r,base:g,quote:r,settle:void 0,baseId:p,quoteId:a,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:y,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDateTime:void 0,strike:void 0,optionType:void 0,precision:{amount:parseInt("4"),price:parseInt("4")},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{}},info:m},o);t.push(b)}}return t}parseBalance(e){const t={info:e},s=this.safeValue(e,"data"),i=Object.keys(this.currencies);for(let n=0;n<i.length;n++){const r=i[n],a=this.account(),o=this.currency(r),d=this.safeStringLower(o,"id");a.total=this.safeString(s,"total_"+d),a.used=this.safeString(s,"in_use_"+d),a.free=this.safeString(s,"available_"+d),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t={currency:"ALL"},s=await this.privatePostInfoBalance(this.extend(t,e));return this.parseBalance(s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={currency:i.base+"_"+i.quote};t!==void 0&&(n.count=t);const r=await this.publicGetOrderbookCurrency(this.extend(n,s)),a=this.safeValue(r,"data",{}),o=this.safeInteger(a,"timestamp");return this.parseOrderBook(a,e,o,"bids","asks","price","quantity")}parseTicker(e,t=void 0){const s=this.safeInteger(e,"date"),i=this.safeSymbol(void 0,t),n=this.safeString(e,"opening_price"),r=this.safeString(e,"closing_price"),a=this.safeString(e,"units_traded_24H"),o=this.safeString(e,"acc_trade_value_24H");return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"max_price"),low:this.safeString(e,"min_price"),bid:this.safeString(e,"buy_price"),bidVolume:void 0,ask:this.safeString(e,"sell_price"),askVolume:void 0,vwap:void 0,open:n,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:a,quoteVolume:o,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTickerAll(t),i={},n=this.safeValue(s,"data",{}),r=this.safeInteger(n,"date"),a=this.omit(n,"date"),o=Object.keys(a);for(let d=0;d<o.length;d++){const c=o[d],u=this.safeMarket(c),h=u.symbol,l=a[c];Array.isArray(l)||(l.date=r,i[h]=this.parseTicker(l,u))}return this.filterByArray(i,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={currency:s.base},n=await this.publicGetTickerCurrency(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTicker(r,s)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={currency:r.base,interval:this.timeframes[t]},o=await this.publicGetCandlestickCurrencyInterval(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseOHLCVs(d,r,t,s,i)}parseTrade(e,t=void 0){let s;const i=this.safeString(e,"transaction_date");if(i!==void 0){const l=i.split(" ");if(l.length>1){const m=l[0];let g=l[1];g.length<8&&(g="0"+g),s=this.parse8601(m+" "+g)}else s=this.safeIntegerProduct(e,"transaction_date",.001)}s!==void 0&&(s-=9*36e5);const n=void 0;let r=this.safeString(e,"type");r=r==="ask"?"sell":"buy";const a=this.safeString(e,"cont_no");t=this.safeMarket(void 0,t);const o=this.safeString(e,"price"),d=this.fixCommaNumber(this.safeString2(e,"units_traded","units")),c=this.safeString(e,"total");let u;const h=this.safeString(e,"fee");if(h!==void 0){const l=this.safeString(e,"fee_currency"),p=this.commonCurrencyCode(l);u={cost:h,currency:p}}return this.safeTrade({id:a,info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:void 0,type:n,side:r,takerOrMaker:void 0,price:o,amount:d,cost:c,fee:u},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={currency:n.base};s===void 0&&(r.count=s);const a=await this.publicGetTransactionHistoryCurrency(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={order_currency:a.id,payment_currency:a.quote,units:i};let d="privatePostTradePlace";t==="limit"?(o.price=n,o.type=s==="buy"?"bid":"ask"):d="privatePostTradeMarket"+this.capitalize(s);const c=await this[d](this.extend(o,r)),u=this.safeString(c,"order_id");if(u===void 0)throw new Q5(this.id+" createOrder() did not return an order id");return{info:c,symbol:e,type:t,side:s,id:u}}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new dc(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={order_id:e,count:1,order_currency:i.base,payment_currency:i.quote},r=await this.privatePostInfoOrderDetail(this.extend(n,s)),a=this.safeValue(r,"data");return this.parseOrder(this.extend(a,{order_id:e}),i)}parseOrderStatus(e){const t={Pending:"open",Completed:"closed",Cancel:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeIntegerProduct(e,"order_date",.001),n=this.safeValue2(e,"type","side")==="bid"?"buy":"sell",r=this.parseOrderStatus(this.safeString(e,"order_status")),a=this.safeString2(e,"order_price","price");let o="limit";t6.stringEquals(a,"0")&&(o="market");const d=this.fixCommaNumber(this.safeString2(e,"order_qty","units"));let c=this.fixCommaNumber(this.safeString(e,"units_remaining"));c===void 0&&(r==="closed"?c="0":r!=="canceled"&&(c=d));let u;const h=this.safeString(e,"order_currency"),l=this.safeString(e,"payment_currency"),p=this.safeCurrencyCode(h),m=this.safeCurrencyCode(l);p!==void 0&&m!==void 0&&(u=p+"/"+m),u===void 0&&(t=this.safeMarket(void 0,t),u=t.symbol);const g=this.safeString(e,"order_id"),y=this.safeValue(e,"contract",[]);return this.safeOrder({info:e,id:g,clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,symbol:u,type:o,timeInForce:void 0,postOnly:void 0,side:n,price:a,stopPrice:void 0,amount:d,cost:void 0,average:void 0,filled:void 0,remaining:c,status:r,fee:void 0,trades:y},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new dc(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e);s===void 0&&(s=100);const r={count:s,order_currency:n.base,payment_currency:n.quote};t!==void 0&&(r.after=t);const a=await this.privatePostInfoOrders(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseOrders(o,n,t,s)}async cancelOrder(e,t=void 0,s={}){if(!("side"in s))throw new dc(this.id+" cancelOrder() requires a `side` parameter (sell or buy)");if(t===void 0)throw new dc(this.id+" cancelOrder() requires a `symbol` argument");const n=this.market(t),r=s.side==="buy"?"bid":"ask";s=this.omit(s,["side","currency"]);const a={order_id:e,type:r,order_currency:n.base,payment_currency:n.quote};return await this.privatePostTradeCancel(this.extend(a,s))}cancelUnifiedOrder(e,t={}){const s={side:e.side};return this.cancelOrder(e.id,e.symbol,this.extend(s,t))}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={units:t,address:s,currency:r.id};if(r==="XRP"||r==="XMR"||r==="EOS"||r==="STEEM"){const d=this.safeString(n,"destination");if(i===void 0&&d===void 0)throw new dc(this.id+" "+e+" withdraw() requires a tag argument or an extra destination param");i!==void 0&&(a.destination=i)}const o=await this.privatePostTradeBtcWithdrawal(this.extend(a,n));return this.parseTransaction(o,r)}parseTransaction(e,t=void 0){return t=this.safeCurrency(void 0,t),{id:void 0,txid:void 0,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0,info:e}}fixCommaNumber(e){if(e===void 0)return;let t=e;for(;t.indexOf(",")>-1;)t=t.replace(",","");return t}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a="/"+this.implodeParams(e,i);let o=this.implodeHostname(this.urls.api[t])+a;const d=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(d).length&&(o+="?"+this.urlencode(d));else{this.checkRequiredCredentials(),r=this.urlencode(this.extend({endpoint:a},d));const c=this.nonce().toString(),u=a+"\0"+r+"\0"+c,h=this.hmac(this.encode(u),this.encode(this.secret),"sha512"),l=this.decode(this.stringToBase64(h));n={Accept:"application/json","Content-Type":"application/x-www-form-urlencoded","Api-Key":this.apiKey,"Api-Sign":l,"Api-Nonce":c}}return{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&"status"in a){const c=this.safeString(a,"status"),u=this.safeString(a,"message");if(c!==void 0){if(c==="0000")return;if(u==="\uAC70\uB798 \uC9C4\uD589\uC911\uC778 \uB0B4\uC5ED\uC774 \uC874\uC7AC\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4")return;const h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions,c,h),this.throwExactlyMatchedException(this.exceptions,u,h),new vf(h)}}}};const i6=ge,{AuthenticationError:lr,ExchangeNotAvailable:Dk,AccountSuspended:Vm,PermissionDenied:Na,RateLimitExceeded:n6,InvalidNonce:r6,InvalidAddress:Hk,ArgumentsRequired:wn,ExchangeError:xt,InvalidOrder:Bt,InsufficientFunds:cc,BadRequest:zt,OrderNotFound:Gk,BadSymbol:uc,NotSupported:kn}=de,{TICK_SIZE:a6,TRUNCATE:o6}=me,qm=Se;var L_=class extends i6{describe(){return this.deepExtend(super.describe(),{id:"bitmart",name:"BitMart",countries:["US","CN","HK","KR"],rateLimit:33.34,version:"v2",certified:!0,pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:void 0,future:!1,option:void 0,borrowMargin:!0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!1,createOrder:!0,createPostOnlyOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowInterest:!0,fetchBorrowRate:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!0,fetchCanceledOrders:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchFundingHistory:void 0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchOrderTrades:!0,fetchPositionMode:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactionFee:!0,fetchTransactionFees:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawAddressesByNetwork:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,reduceMargin:!1,repayMargin:!0,setLeverage:!1,setMarginMode:!1,transfer:!0,withdraw:!0},hostname:"bitmart.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/129991357-8f47464b-d0f4-41d6-8a82-34122f0d1398.jpg",api:{rest:"https://api-cloud.{hostname}"},www:"https://www.bitmart.com/",doc:"https://developer-pro.bitmart.com/",referral:{url:"http://www.bitmart.com/?r=rQCFLh",discount:.3},fees:"https://www.bitmart.com/fee/en"},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},api:{public:{get:{"system/time":3,"system/service":3,"spot/v1/currencies":7.5,"spot/v1/symbols":7.5,"spot/v1/symbols/details":5,"spot/v1/ticker":5,"spot/v2/ticker":5,"spot/v1/steps":30,"spot/v1/symbols/kline":5,"spot/v1/symbols/book":5,"spot/v1/symbols/trades":5,"contract/v1/tickers":15,"contract/public/details":5,"contract/public/depth":5,"contract/public/open-interest":30,"contract/public/funding-rate":30,"contract/public/kline":5}},private:{get:{"account/sub-account/v1/transfer-list":7.5,"account/sub-account/v1/transfer-history":7.5,"account/sub-account/main/v1/wallet":5,"account/sub-account/main/v1/subaccount-list":7.5,"account/v1/wallet":5,"account/v1/currencies":30,"spot/v1/wallet":5,"account/v1/deposit/address":30,"account/v1/withdraw/charge":32,"account/v2/deposit-withdraw/history":7.5,"account/v1/deposit-withdraw/detail":7.5,"spot/v1/order_detail":1,"spot/v2/orders":5,"spot/v1/trades":5,"spot/v2/trades":5,"spot/v3/orders":5,"spot/v2/order_detail":1,"spot/v1/margin/isolated/borrow_record":1,"spot/v1/margin/isolated/repay_record":1,"spot/v1/margin/isolated/pairs":1,"spot/v1/margin/isolated/account":6,"spot/v1/trade_fee":6,"spot/v1/user_fee":6,"contract/private/assets-detail":5,"contract/private/order":2,"contract/private/order-history":10,"contract/private/position":10},post:{"account/sub-account/main/v1/sub-to-main":30,"account/sub-account/sub/v1/sub-to-main":30,"account/sub-account/main/v1/main-to-sub":30,"account/sub-account/sub/v1/sub-to-sub":30,"account/sub-account/main/v1/sub-to-sub":30,"account/v1/withdraw/apply":7.5,"spot/v1/submit_order":1,"spot/v1/batch_orders":1,"spot/v2/cancel_order":1,"spot/v1/cancel_orders":15,"spot/v3/cancel_order":1,"spot/v2/batch_orders":1,"spot/v2/submit_order":1,"spot/v1/margin/submit_order":1,"spot/v1/margin/isolated/borrow":6,"spot/v1/margin/isolated/repay":6,"spot/v1/margin/isolated/transfer":6,"contract/private/trades":10}}},timeframes:{"1m":1,"3m":3,"5m":5,"15m":15,"30m":30,"45m":45,"1h":60,"2h":120,"3h":180,"4h":240,"1d":1440,"1w":10080,"1M":43200},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0025"),maker:this.parseNumber("0.0025"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.0020")],[this.parseNumber("10"),this.parseNumber("0.18")],[this.parseNumber("50"),this.parseNumber("0.0016")],[this.parseNumber("250"),this.parseNumber("0.0014")],[this.parseNumber("1000"),this.parseNumber("0.0012")],[this.parseNumber("5000"),this.parseNumber("0.0010")],[this.parseNumber("25000"),this.parseNumber("0.0008")],[this.parseNumber("50000"),this.parseNumber("0.0006")]],maker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("10"),this.parseNumber("0.0009")],[this.parseNumber("50"),this.parseNumber("0.0008")],[this.parseNumber("250"),this.parseNumber("0.0007")],[this.parseNumber("1000"),this.parseNumber("0.0006")],[this.parseNumber("5000"),this.parseNumber("0.0005")],[this.parseNumber("25000"),this.parseNumber("0.0004")],[this.parseNumber("50000"),this.parseNumber("0.0003")]]}}},precisionMode:a6,exceptions:{exact:{3e4:xt,30001:lr,30002:lr,30003:Vm,30004:lr,30005:lr,30006:lr,30007:lr,30008:lr,30010:Na,30011:lr,30012:lr,30013:n6,30014:Dk,6e4:zt,60001:zt,60002:zt,60003:xt,60004:xt,60005:xt,60006:xt,60007:Hk,60008:cc,60009:xt,60010:xt,60011:Hk,60012:xt,60020:Na,60021:Na,60022:Na,60030:zt,60031:zt,60050:xt,60051:xt,61001:cc,61003:zt,5e4:zt,50001:uc,50002:zt,50003:zt,50004:zt,50005:Gk,50006:Bt,50007:Bt,50008:Bt,50009:Bt,50010:Bt,50011:Bt,50012:Bt,50013:Bt,50014:zt,50015:zt,50016:zt,50017:zt,50018:zt,50019:zt,51004:cc,50020:cc,50021:zt,50022:Dk,50023:uc,50029:Bt,50030:Bt,50032:Gk,50035:Bt,50034:Bt,53e3:Vm,53001:Vm,57001:zt,58001:zt,59001:xt,59002:xt,40001:xt,40002:xt,40003:xt,40004:xt,40005:xt,40006:Na,40007:zt,40008:r6,40009:zt,40010:zt,40011:zt,40012:xt,40013:xt,40014:uc,40015:uc,40016:Bt,40017:Bt,40018:Bt,40019:xt,40020:Bt,40021:xt,40022:xt,40023:xt,40024:xt,40025:xt,40026:xt,40027:cc,40028:Na,40029:Bt,40030:Bt,40031:Bt,40032:Bt,40033:Bt,40034:uc,53002:Na},broad:{}},commonCurrencies:{$GM:"GOLDMINER",$HERO:"Step Hero",$PAC:"PAC",BP:"BEYOND",GDT:"Gorilla Diamond",GLD:"Goldario",MVP:"MVP Coin",TRU:"Truebit"},options:{networks:{TRX:"TRC20",ETH:"ERC20"},defaultNetworks:{USDT:"ERC20"},defaultType:"spot",fetchBalance:{type:"spot"},createMarketBuyOrderRequiresPrice:!0}})}async fetchTime(e={}){const t=await this.publicGetSystemTime(e),s=this.safeValue(t,"data",{});return this.safeInteger(s,"server_time")}async fetchStatus(e={}){const t=this.safeValue(this.options,"fetchStatus",{}),s=this.safeString(this.options,"defaultType");let i=this.safeString(t,"type",s);i=this.safeString(e,"type",i),e=this.omit(e,"type");const n=await this.publicGetSystemService(e),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"service",[]),o=this.indexBy(a,"service_type");i==="swap"&&(i="contract");const d=this.safeValue(o,i);let c,u;return d!==void 0&&(this.safeInteger(d,"status")===2?c="ok":(c="maintenance",u=this.safeInteger(d,"end_time"))),{status:c,updated:void 0,eta:u,url:void 0,info:n}}async fetchSpotMarkets(e={}){const t=await this.publicGetSpotV1SymbolsDetails(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"symbols",[]),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"symbol"),d=this.safeInteger(a,"symbol_id"),c=this.safeString(a,"base_currency"),u=this.safeString(a,"quote_currency"),h=this.safeCurrencyCode(c),l=this.safeCurrencyCode(u),p=h+"/"+l,m=this.safeString(a,"min_buy_amount"),g=this.safeString(a,"min_sell_amount"),y=qm.stringMax(m,g),b=this.safeNumber(a,"base_min_size");n.push({id:o,numericId:d,symbol:p,base:h,quote:l,settle:void 0,baseId:c,quoteId:u,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:b,price:this.parseNumber(this.parsePrecision(this.safeString(a,"price_max_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:b,max:this.safeNumber(a,"base_max_size")},price:{min:void 0,max:void 0},cost:{min:this.parseNumber(y),max:void 0}},info:a})}return n}async fetchContractMarkets(e={}){const t=await this.publicGetContractV1Tickers(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"tickers",[]),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"contract_symbol"),d=o.slice(0,-4),c=o.slice(-4),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),l="USDT",p=u+"/"+h+":"+l;n.push({id:o,numericId:void 0,symbol:p,base:u,quote:h,settle:l,baseId:d,quoteId:c,settleId:void 0,type:"swap",spot:!1,margin:!1,swap:!0,future:!1,option:!1,active:!0,contract:!0,linear:!0,inverse:!1,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:void 0,price:void 0},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:a})}return n}async fetchMarkets(e={}){const t=await this.fetchSpotMarkets(e),s=await this.fetchContractMarkets(e);return this.arrayConcat(t,s)}async fetchCurrencies(e={}){const t=await this.publicGetSpotV1Currencies(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"currencies",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"id"),d=this.safeCurrencyCode(o),c=this.safeString(a,"name"),u=this.safeValue(a,"withdraw_enabled"),h=this.safeValue(a,"deposit_enabled"),l=u&&h;n[d]={id:o,code:d,name:c,info:a,active:l,deposit:h,withdraw:u,fee:void 0,precision:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}}}return n}async fetchTransactionFee(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.privateGetAccountV1WithdrawCharge(this.extend(i,t)),r=n.data,a={};return a[e]=this.safeNumber(r,"withdraw_fee"),{info:n,withdraw:a,deposit:{}}}parseTicker(e,t=void 0){const s=this.safeInteger(e,"timestamp",this.milliseconds()),i=this.safeString2(e,"symbol","contract_symbol");t=this.safeMarket(i,t);const n=t.symbol,r=this.safeString2(e,"close_24h","last_price");let a=this.safeString(e,"price_change_percent_24h");if(a===void 0){const l=this.safeString(e,"fluctuation");if(l!==void 0&&l!=="0"){const p=l[0];a=p+qm.stringMul(l.replace(p,""),"100")}else l==="0"&&(a="0")}const o=this.safeString(e,"base_volume_24h");let d=this.safeString(e,"quote_volume_24h");d=this.safeString(e,"volume_24h",d);const c=this.safeString2(e,"avg_price","index_price"),u=this.safeString2(e,"high_24h","high_price"),h=this.safeString2(e,"low_24h","low_price");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:u,low:h,bid:this.safeString(e,"best_bid"),bidVolume:this.safeString(e,"best_bid_size"),ask:this.safeString(e,"best_ask"),askVolume:this.safeString(e,"best_ask_size"),vwap:void 0,open:this.safeString(e,"open_24h"),close:r,last:r,previousClose:void 0,change:void 0,percentage:a,average:c,baseVolume:o,quoteVolume:d,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={};let n;s.swap?(n="publicGetContractV1Tickers",i.contract_symbol=s.id):s.spot&&(n="publicGetSpotV1Ticker",i.symbol=s.id);const r=await this[n](this.extend(i,t)),a=this.safeValue(r,"data",{}),o=this.safeValue(a,"tickers",[]);let d;s.spot?d=this.indexBy(o,"symbol"):s.swap&&(d=this.indexBy(o,"contract_symbol"));const c=this.safeValue(d,s.id);return this.parseTicker(c,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s,i;if(e!==void 0){const c=this.safeValue(e,0);i=this.market(c)}[s,t]=this.handleMarketTypeAndParams("fetchTickers",i,t);const n=this.getSupportedMapping(s,{spot:"publicGetSpotV2Ticker",swap:"publicGetContractV1Tickers"}),r=await this[n](t),a=this.safeValue(r,"data",{}),o=this.safeValue(a,"tickers",[]),d={};for(let c=0;c<o.length;c++){const u=this.parseTicker(o[c]),h=u.symbol;d[h]=u}return this.filterByArray(d,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);if(!i.spot)throw new kn(this.id+" fetchOrderBook() does not support "+i.type+" markets, only spot markets are accepted");const n={symbol:i.id};t!==void 0&&(n.size=t);const r=await this.publicGetSpotV1SymbolsBook(this.extend(n,s)),a=this.safeValue(r,"data",{}),o=this.safeInteger(a,"timestamp");return this.parseOrderBook(a,e,o,"buys","sells","price","amount")}parseTrade(e,t=void 0){const s=this.safeString(e,"detail_id"),i=this.safeInteger2(e,"order_time","create_time"),n=void 0,r=this.safeStringLower2(e,"type","side");let a;const o=this.safeString(e,"exec_type");o!==void 0&&(a=o==="M"?"maker":"taker");let d=this.safeString(e,"price");d=this.safeString(e,"price_avg",d);let c=this.safeString(e,"count");c=this.safeString(e,"size",c);const u=this.safeString2(e,"amount","notional"),h=this.safeString(e,"order_id"),l=this.safeString(e,"symbol");t=this.safeMarket(l,t,"_");const p=this.safeString(e,"fees");let m;if(p!==void 0){const g=this.safeString(e,"fee_coin_name");let y=this.safeCurrencyCode(g);y===void 0&&(y=r==="buy"?t.base:t.quote),m={cost:p,currency:y}}return this.safeTrade({info:e,id:s,order:h,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,type:n,side:r,price:d,amount:c,cost:u,takerOrMaker:a,fee:m},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);if(!n.spot)throw new kn(this.id+" fetchTrades() does not support "+n.type+" orders, only spot orders are accepted");const r={symbol:n.id},a=await this.publicGetSpotV1SymbolsTrades(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"trades",[]);return this.parseTrades(d,n,t,s)}parseOHLCV(e,t=void 0){return Array.isArray(e)?[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]:[this.safeTimestamp(e,"timestamp"),this.safeNumber2(e,"open","open_price"),this.safeNumber2(e,"high","high_price"),this.safeNumber2(e,"low","low_price"),this.safeNumber2(e,"close","close_price"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=r.type,o=this.parseTimeframe(t),d={symbol:r.id,step:this.timeframes[t]},c=500;i===void 0&&(i=c),i=Math.min(c,i);const u=parseInt(this.milliseconds()/1e3),h=a==="spot"?"from":"start_time",l=a==="spot"?"to":"end_time";if(s===void 0){const w=u-i*o;d[h]=w,d[l]=u}else{const w=parseInt(s/1e3)-1,k=this.sum(w,i*o);d[h]=w,d[l]=Math.min(k,u)}let p="publicGetSpotV1SymbolsKline";a==="swap"&&(p="publicGetContractPublicKline");const m=await this[p](this.extend(d,n)),g=this.safeValue(m,"data",{}),y=this.safeValue(g,"klines",[]),b=a==="spot"?y:g;return this.parseOHLCVs(b,r,t,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new wn(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e);if(!n.spot)throw new kn(this.id+" fetchMyTrades() does not support "+n.type+" orders, only spot orders are accepted");const r=this.safeValue(this.options,"fetchMyTrades",{}),a=this.safeInteger(r,"limit",200);s===void 0&&(s=a);const o={symbol:n.id,N:s},d=await this.privateGetSpotV2Trades(this.extend(o,i)),c=this.safeValue(d,"data",{}),u=this.safeValue(c,"trades",[]);return this.parseTrades(u,n,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){if(t===void 0)throw new wn(this.id+" fetchOrderTrades() requires a symbol argument");await this.loadMarkets();const r=this.market(t);if(!r.spot)throw new kn(this.id+" fetchOrderTrades() does not support "+r.type+" orders, only spot orders are accepted");const a=this.safeValue(this.options,"fetchOrderTrades",{}),o=this.safeInteger(a,"limit",200);i===void 0&&(i=o);const d={symbol:r.id,order_id:e,N:i},c=await this.privateGetSpotV2Trades(this.extend(d,n)),u=this.safeValue(c,"data",{}),h=this.safeValue(u,"trades",[]);return this.parseTrades(h,r,s,i)}parseBalance(e,t){let s;if(t==="swap")s=this.safeValue(e,"data",[]);else{const n=this.safeValue(e,"data",{});s=this.safeValue(n,"wallet",[])}const i={info:e};for(let n=0;n<s.length;n++){const r=s[n];let a=this.safeString2(r,"id","currency");a=this.safeString(r,"coin_code",a);const o=this.safeCurrencyCode(a),d=this.account();d.free=this.safeString2(r,"available","available_balance"),d.used=this.safeString2(r,"frozen","frozen_balance"),i[o]=d}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),i=this.getSupportedMapping(t,{spot:"privateGetSpotV1Wallet",swap:"privateGetContractPrivateAssetsDetail",account:"privateGetAccountV1Wallet"}),n=await this[i](s);return this.parseBalance(n,t)}parseTradingFee(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s);return{info:e,symbol:i,maker:this.safeNumber(e,"maker_fee_rate"),taker:this.safeNumber(e,"taker_fee_rate")}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.spot)throw new kn(this.id+" fetchTradingFee() does not support "+s.type+" orders, only spot orders are accepted");const i={symbol:s.id},n=await this.privateGetSpotV1TradeFee(this.extend(i,t)),r=this.safeValue(n,"data");return this.parseTradingFee(r)}parseOrder(e,t=void 0){let s;typeof e=="string"&&(s=e,e={}),s=this.safeString(e,"order_id",s);const i=this.safeInteger(e,"create_time"),n=this.safeString(e,"symbol"),r=this.safeSymbol(n,t,"_");let a;t!==void 0&&(a=this.parseOrderStatusByType(t.type,this.safeString(e,"status")));const o=this.safeString(e,"size"),d=this.safeString(e,"filled_size"),c=this.safeString(e,"price_avg"),u=this.safeString(e,"price"),h=this.safeString(e,"side");let l=this.safeString(e,"type"),p,m;return l==="limit_maker"&&(l="limit",m=!0,p="PO"),l==="ioc"&&(l="limit",p="IOC"),this.safeOrder({id:s,clientOrderId:void 0,info:e,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,symbol:r,type:l,timeInForce:p,postOnly:m,side:h,price:u,stopPrice:void 0,amount:o,cost:void 0,average:c,filled:d,remaining:void 0,status:a,fee:void 0,trades:void 0},t)}parseOrderStatusByType(e,t){const s={spot:{1:"failed",2:"open",3:"failed",4:"open",5:"open",6:"closed",7:"canceling",8:"canceled"},swap:{1:"open",2:"open",4:"closed"}},i=this.safeValue(s,e,{});return this.safeString(i,t,t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={},d=this.safeString(r,"timeInForce");if(d==="FOK")throw new Bt(this.id+" createOrder() only accepts timeInForce parameter values of IOC or PO");const c=t==="market",u=this.isPostOnly(c,t==="limit_maker",r);r=this.omit(r,["timeInForce","postOnly"]);const h=d==="IOC"||t==="ioc",l=t==="limit"||u||h;let p;if(a.spot){if(o.symbol=a.id,o.side=s,o.type=t,p="privatePostSpotV2SubmitOrder",l)o.size=this.amountToPrecision(e,i),o.price=this.priceToPrecision(e,n);else if(c)if(s==="buy"){let k=this.safeNumber(r,"notional");if(this.safeValue(this.options,"createMarketBuyOrderRequiresPrice",!0)){if(n!==void 0){if(k===void 0){const O=this.numberToString(i),x=this.numberToString(n);k=this.parseNumber(qm.stringMul(O,x))}}else if(k===void 0)throw new Bt(this.id+" createOrder () requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total cost value in the 'amount' argument or in the 'notional' extra parameter (the exchange-specific behaviour)")}else k=k===void 0?i:k;o.notional=this.decimalToPrecision(k,o6,a.precision.price,this.precisionMode)}else s==="sell"&&(o.size=this.amountToPrecision(e,i))}else if(a.swap)throw new kn(this.id+" createOrder() does not accept swap orders, only spot orders are allowed");u&&(o.type="limit_maker"),h&&(o.type="ioc");const[m,g]=this.handleMarginModeAndParams("createOrder",r);m!==void 0&&(p="privatePostSpotV1MarginSubmitOrder");const y=await this[p](this.extend(o,g)),b=this.safeValue(y,"data",{}),w=this.parseOrder(b,a);return this.extend(w,{type:t,side:s,amount:i,price:n})}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new wn(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t);if(!i.spot)throw new kn(this.id+" cancelOrder() does not support "+i.type+" orders, only spot orders are accepted");const n={order_id:e.toString(),symbol:i.id},r=await this.privatePostSpotV3CancelOrder(this.extend(n,s)),a=this.safeValue(r,"data");if(a===!0)return this.parseOrder(e,i);const o=this.safeValue(a,"succeed");if(o!==void 0){if(e=this.safeString(o,0),e===void 0)throw new Bt(this.id+" cancelOrder() failed to cancel "+t+" order id "+e)}else if(!this.safeValue(a,"result"))throw new Bt(this.id+" cancelOrder() "+t+" order id "+e+" is filled or canceled");const d=this.parseOrder(e,i);return this.extend(d,{id:e})}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new wn(this.id+" cancelAllOrders() requires a symbol argument");const s=this.safeString(t,"side");if(s===void 0)throw new wn(this.id+" cancelAllOrders() requires a `side` parameter ('buy' or 'sell')");await this.loadMarkets();const i=this.market(e);if(!i.spot)throw new kn(this.id+" cancelAllOrders() does not support "+i.type+" orders, only spot orders are accepted");const n={symbol:i.id,side:s};return await this.privatePostSpotV1CancelOrders(this.extend(n,t))}async fetchOrdersByStatus(e,t=void 0,s=void 0,i=void 0,n={}){if(t===void 0)throw new wn(this.id+" fetchOrdersByStatus() requires a symbol argument");await this.loadMarkets();const r=this.market(t);if(!r.spot)throw new kn(this.id+" fetchOrdersByStatus() does not support "+r.type+" orders, only spot orders are accepted");const a={symbol:r.id,offset:1,N:100};e==="open"?a.status=9:e==="closed"?a.status=6:e==="canceled"?a.status=8:a.status=e;const o=await this.privateGetSpotV3Orders(this.extend(a,n)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"orders",[]);return this.parseOrders(c,r,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("open",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("closed",e,t,s,i)}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("canceled",e,t,s,i)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new wn(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t);if(!i.spot)throw new kn(this.id+" fetchOrder() does not support "+i.type+" orders, only spot orders are accepted");typeof e!="string"&&(e=e.toString());const n={symbol:i.id,order_id:e},r=await this.privateGetSpotV2OrderDetail(this.extend(n,s)),a=this.safeValue(r,"data",{});return this.parseOrder(a,i)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id};if(e==="USDT"){const u=this.safeValue(this.options,"defaultNetworks"),h=this.safeStringUpper(u,e),l=this.safeValue(this.options,"networks",{});let p=this.safeStringUpper(t,"network",h);p=this.safeString(l,p,p),p!==void 0&&(i.currency+="-"+p,t=this.omit(t,"network"))}const n=await this.privateGetAccountV1DepositAddress(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeString(r,"address"),o=this.safeString(r,"address_memo"),d=this.safeString(r,"chain");let c;if(d!==void 0){const u=d.split("-"),h=this.safeString(u,1);c=this.safeNetwork(h)}return this.checkAddress(a),{currency:e,address:a,tag:o,network:c,info:n}}safeNetwork(e){return e}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,amount:t,destination:"To Digital Address",address:s};if(i!==void 0&&(a.address_memo=i),e==="USDT"){const u=this.safeValue(this.options,"defaultNetworks"),h=this.safeStringUpper(u,e),l=this.safeValue(this.options,"networks",{});let p=this.safeStringUpper(n,"network",h);p=this.safeString(l,p,p),p!==void 0&&(a.currency+="-"+p,n=this.omit(n,"network"))}const o=await this.privatePostAccountV1WithdrawApply(this.extend(a,n)),d=this.safeValue(o,"data"),c=this.parseTransaction(d,r);return this.extend(c,{code:e,address:s,tag:i})}async fetchTransactionsByType(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets(),i===void 0&&(i=50);const r={operation_type:e,offset:1,N:i};let a;if(t!==void 0&&(a=this.currency(t),r.currency=a.id),t==="USDT"){const u=this.safeValue(this.options,"defaultNetworks"),h=this.safeStringUpper(u,t),l=this.safeValue(this.options,"networks",{});let p=this.safeStringUpper(n,"network",h);p=this.safeString(l,p,p),p!==void 0&&(r.currency+="-"+p,a.code=r.currency,n=this.omit(n,"network"))}const o=await this.privateGetAccountV2DepositWithdrawHistory(this.extend(r,n)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"records",[]);return this.parseTransactions(c,a,s,i)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetAccountV1DepositWithdrawDetail(this.extend(i,s)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"record",{});return this.parseTransaction(a)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByType("deposit",e,t,s,i)}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateAccountGetDepositWithdrawDetail(this.extend(i,s)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"record",{});return this.parseTransaction(a)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByType("withdraw",e,t,s,i)}parseTransactionStatus(e){const t={0:"pending",1:"pending",2:"pending",3:"ok",4:"canceled",5:"failed"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){let s;const i=this.safeString(e,"withdraw_id"),n=this.safeString(e,"deposit_id");let r;i!==void 0&&i!==""?(r="withdraw",s=i):n!==void 0&&n!==""&&(r="deposit",s=n);const a=this.safeNumber(e,"arrival_amount"),o=this.safeInteger(e,"apply_time"),d=this.safeString(e,"currency"),c=this.safeCurrencyCode(d,t),u=this.parseTransactionStatus(this.safeString(e,"status")),h=this.safeNumber(e,"fee");let l;h!==void 0&&(l={cost:h,currency:c});const p=this.safeString(e,"tx_id"),m=this.safeString(e,"address"),g=this.safeString(e,"address_memo");return{info:e,id:s,currency:c,amount:a,network:void 0,address:m,addressFrom:void 0,addressTo:void 0,tag:g,tagFrom:void 0,tagTo:void 0,status:u,type:r,updated:void 0,txid:p,timestamp:o!==0?o:void 0,datetime:o!==0?this.iso8601(o):void 0,fee:l}}async repayMargin(e,t,s=void 0,i={}){if(await this.loadMarkets(),s===void 0)throw new wn(this.id+" repayMargin() requires a symbol argument");let n;[n,i]=this.handleMarginModeAndParams("repayMargin",i),n===void 0&&(n="isolated");const r=this.market(s),a=this.currency(e),o={symbol:r.id,currency:a.id,amount:this.currencyToPrecision(e,t)},d=await this.privatePostSpotV1MarginIsolatedRepay(this.extend(o,i)),c=this.safeValue(d,"data",{}),u=this.parseMarginLoan(c,a);return this.extend(u,{amount:t,symbol:s})}async borrowMargin(e,t,s=void 0,i={}){if(await this.loadMarkets(),s===void 0)throw new wn(this.id+" borrowMargin() requires a symbol argument");let n;[n,i]=this.handleMarginModeAndParams("borrowMargin",i),n===void 0&&(n="isolated");const r=this.market(s),a=this.currency(e),o={symbol:r.id,currency:a.id,amount:this.currencyToPrecision(e,t)},d=await this.privatePostSpotV1MarginIsolatedBorrow(this.extend(o,i)),c=this.safeValue(d,"data",{}),u=this.parseMarginLoan(c,a);return this.extend(u,{amount:t,symbol:s})}parseMarginLoan(e,t=void 0){const s=this.milliseconds();return{id:this.safeString2(e,"borrow_id","repay_id"),currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:s,datetime:this.iso8601(s),info:e}}async fetchBorrowRate(e,t={}){await this.loadMarkets();let s;if(e in this.markets)s=this.market(e);else{const d=this.safeString(this.options,"defaultSettle","USDT");e==="USDT"?s=this.market("BTC/"+d):s=this.market(e+"/"+d)}const i={symbol:s.id},n=await this.privateGetSpotV1MarginIsolatedPairs(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"symbols",[]),o=e==="USDT"?s.quote:s.base;return this.parseBorrowRate(a,o)}parseBorrowRate(e,t=void 0){const s=this.milliseconds(),i=t==="USDT"?this.safeValue(e[0],"quote",{}):this.safeValue(e[0],"base",{});return{currency:this.safeCurrencyCode(t),rate:this.safeNumber(i,"hourly_interest"),period:36e5,timestamp:s,datetime:this.iso8601(s),info:e}}async fetchBorrowRates(e={}){await this.loadMarkets();const t=await this.privateGetSpotV1MarginIsolatedPairs(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"symbols",[]);return this.parseBorrowRates(i,void 0)}parseBorrowRates(e,t){const s=this.milliseconds(),i=[];for(let n=0;n<e.length;n++){const r=e[n],a=this.safeValue(r,"base",{});i.push({currency:this.safeCurrencyCode(this.safeString(a,"currency")),rate:this.safeNumber(a,"hourly_interest"),period:36e5,timestamp:s,datetime:this.iso8601(s),info:r})}return i}async transfer(e,t,s,i,n={}){const r=this.safeString(n,"symbol");if(r===void 0)throw new wn(this.id+" transfer() requires a symbol argument");await this.loadMarkets();const a=this.market(r),o=this.currency(e),d=this.currencyToPrecision(e,t),c={amount:d,currency:o.id,symbol:a.id};s==="spot"&&i==="margin"?c.side="in":s==="margin"&&i==="spot"&&(c.side="out"),n=this.omit(n,"symbol");const u=await this.privatePostSpotV1MarginIsolatedTransfer(this.extend(c,n));return this.extend(this.parseTransfer(u,o),{amount:this.parseNumber(d),fromAccount:s,toAccount:i})}parseTransferStatus(e){const t={1e3:"ok",OK:"ok"};return this.safeString(t,e,e)}parseTransfer(e,t=void 0){const s=this.safeValue(e,"data",{});return{id:this.safeString(s,"transfer_id"),timestamp:void 0,datetime:void 0,currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:this.parseTransferStatus(this.safeString2(e,"code","message"))}}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){if(t===void 0)throw new wn(this.id+" fetchBorrowInterest() requires a symbol argument");await this.loadMarkets();const r=this.market(t),a={symbol:r.id};i!==void 0&&(a.N=i),s!==void 0&&(a.start_time=s);const o=await this.privateGetSpotV1MarginIsolatedBorrowRecord(this.extend(a,n)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"records",[]),u=this.parseBorrowInterests(c,r);return this.filterByCurrencySinceLimit(u,e,s,i)}parseBorrowInterest(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeInteger(e,"create_time");return{symbol:this.safeString(t,"symbol"),marginMode:"isolated",currency:this.safeCurrencyCode(this.safeString(e,"currency")),interest:this.safeNumber(e,"interest_amount"),interestRate:this.safeNumber(e,"hourly_interest"),amountBorrowed:this.safeNumber(e,"borrow_amount"),timestamp:i,datetime:this.iso8601(i),info:e}}handleMarginModeAndParams(e,t={},s=void 0){const i=this.safeString(this.options,"defaultType"),n=this.safeValue(t,"margin",!1);let r;if([r,t]=super.handleMarginModeAndParams(e,t,s),r!==void 0){if(r!=="isolated")throw new kn(this.id+" only isolated margin is supported")}else(i==="margin"||n===!0)&&(r="isolated");return[r,t]}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let o=this.implodeHostname(this.urls.api.rest)+"/"+this.implodeParams(e,i);const d=this.omit(i,this.extractParams(e));let c="";const u=s==="GET"||s==="DELETE";if(u&&Object.keys(d).length&&(c=this.urlencode(d),o+="?"+c),t==="private"){this.checkRequiredCredentials();const h=this.milliseconds().toString();n={"X-BM-KEY":this.apiKey,"X-BM-TIMESTAMP":h,"Content-Type":"application/json"},u||(r=this.json(d),c=r);const l=h+"#"+this.uid+"#"+c,p=this.hmac(this.encode(l),this.encode(this.secret));n["X-BM-SIGN"]=p}return{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeStringLower(a,"message"),u=this.safeString(a,"code");if(u!==void 0&&u!=="1000"||c!==void 0&&c!=="ok"){const h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwBroadlyMatchedException(this.exceptions.broad,u,h),this.throwExactlyMatchedException(this.exceptions.exact,c,h),this.throwBroadlyMatchedException(this.exceptions.broad,c,h),new xt(h)}}};const d6=ge,{TICK_SIZE:c6}=me,{AuthenticationError:Uk,BadRequest:Lm,DDoSProtection:u6,ExchangeError:Rm,ExchangeNotAvailable:$k,InsufficientFunds:f6,InvalidOrder:Ao,OrderNotFound:jk,PermissionDenied:Fm,ArgumentsRequired:Dm,BadSymbol:Hm}=de,Hs=Se;var R_=class extends d6{describe(){return this.deepExtend(super.describe(),{id:"bitmex",name:"BitMEX",countries:["SC"],version:"v1",userAgent:void 0,rateLimit:100,pro:!0,has:{CORS:void 0,spot:!1,margin:!1,swap:!0,future:!0,option:!1,addMargin:void 0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createOrder:!0,createReduceOnlyOrder:!0,editOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchDepositAddress:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTransactions:"emulated",fetchTransfer:!1,fetchTransfers:!1,reduceMargin:void 0,setLeverage:!0,setMargin:void 0,setMarginMode:!0,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","1h":"1h","1d":"1d"},urls:{test:{public:"https://testnet.bitmex.com",private:"https://testnet.bitmex.com"},logo:"https://user-images.githubusercontent.com/1294454/27766319-f653c6e6-5ed4-11e7-933d-f0bc3699ae8f.jpg",api:{public:"https://www.bitmex.com",private:"https://www.bitmex.com"},www:"https://www.bitmex.com",doc:["https://www.bitmex.com/app/apiOverview","https://github.com/BitMEX/api-connectors/tree/master/official-http"],fees:"https://www.bitmex.com/app/fees",referral:"https://www.bitmex.com/register/upZpOX"},api:{public:{get:{announcement:5,"announcement/urgent":5,funding:5,instrument:5,"instrument/active":5,"instrument/activeAndIndices":5,"instrument/activeIntervals":5,"instrument/compositeIndex":5,"instrument/indices":5,insurance:5,leaderboard:5,liquidation:5,orderBook:5,"orderBook/L2":5,quote:5,"quote/bucketed":5,schema:5,"schema/websocketHelp":5,settlement:5,stats:5,"stats/history":5,trade:5,"trade/bucketed":5,"wallet/assets":5,"wallet/networks":5}},private:{get:{apiKey:5,chat:5,"chat/channels":5,"chat/connected":5,execution:5,"execution/tradeHistory":5,notification:5,order:5,position:5,user:5,"user/affiliateStatus":5,"user/checkReferralCode":5,"user/commission":5,"user/depositAddress":5,"user/executionHistory":5,"user/margin":5,"user/minWithdrawalFee":5,"user/wallet":5,"user/walletHistory":5,"user/walletSummary":5,"wallet/assets":5,"wallet/networks":5,userEvent:5},post:{apiKey:5,"apiKey/disable":5,"apiKey/enable":5,chat:5,order:1,"order/bulk":5,"order/cancelAllAfter":5,"order/closePosition":5,"position/isolate":1,"position/leverage":1,"position/riskLimit":5,"position/transferMargin":1,"user/cancelWithdrawal":5,"user/confirmEmail":5,"user/confirmEnableTFA":5,"user/confirmWithdrawal":5,"user/disableTFA":5,"user/logout":5,"user/logoutAll":5,"user/preferences":5,"user/requestEnableTFA":5,"user/requestWithdrawal":5},put:{order:1,"order/bulk":5,user:5},delete:{apiKey:5,order:1,"order/all":1}}},exceptions:{exact:{"Invalid API Key.":Uk,"This key is disabled.":Fm,"Access Denied":Fm,"Duplicate clOrdID":Ao,"orderQty is invalid":Ao,"Invalid price":Ao,"Invalid stopPx for ordType":Ao},broad:{"Signature not valid":Uk,overloaded:$k,"Account has insufficient Available Balance":f6,"Service unavailable":$k,"Server Error":Rm,"Unable to cancel order due to existing state":Ao,"We require all new traders to verify":Fm}},precisionMode:c6,options:{"api-expires":5,fetchOHLCVOpenTimestamp:!0},commonCurrencies:{USDt:"USDT",XBt:"BTC",XBT:"BTC",Gwei:"ETH",GWEI:"ETH"}})}async fetchMarkets(e={}){const t=await this.publicGetInstrumentActiveAndIndices(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"symbol"),a=this.safeString(n,"underlying"),o=this.safeString(n,"quoteCurrency"),d=this.safeString(n,"settlCurrency",""),c=this.safeCurrencyCode(a),u=this.safeCurrencyCode(o),h=this.safeCurrencyCode(d),l=a+o,p=r===l;let m,g=!1,y=!1,b=!1,w=c+"/"+u+":"+h;const k=this.safeString(n,"expiry"),T=this.parse8601(k),O=this.safeValue(n,"isInverse");let C=this.safeString(n,"state")!=="Unlisted";p?m="swap":r.indexOf("B_")>=0?(y=!0,m="prediction",w=r):T!==void 0?(g=!0,m="future",w=w+"-"+this.yymmdd(T)):(b=!0,m="index",w=r,C=!1);const E=this.safeString2(n,"positionCurrency","underlying"),_=this.safeCurrencyCode(E)===u,S=this.safeNumber(n,"maxOrderQty"),I=!b,v=this.safeString(n,"initMargin","1"),N=this.parseNumber(Hs.stringDiv("1",v)),q=Hs.stringAbs(this.safeString(n,"multiplier"));s.push({id:r,symbol:w,base:c,quote:u,settle:h,baseId:a,quoteId:o,settleId:d,type:m,spot:!1,margin:!1,swap:p,future:g,option:!1,prediction:y,index:b,active:C,contract:I,linear:I?!O:void 0,inverse:I?O:void 0,taker:this.safeNumber(n,"takerFee"),maker:this.safeNumber(n,"makerFee"),contractSize:this.parseNumber(q),expiry:T,expiryDatetime:k,strike:this.safeNumber(n,"optionStrikePrice"),optionType:void 0,precision:{amount:this.safeNumber(n,"lotSize"),price:this.safeNumber(n,"tickSize"),quote:this.safeNumber(n,"tickSize"),base:this.safeNumber(n,"tickSize")},limits:{leverage:{min:I?this.parseNumber("1"):void 0,max:I?N:void 0},amount:{min:void 0,max:_?void 0:S},price:{min:void 0,max:this.safeNumber(n,"maxPrice")},cost:{min:void 0,max:_?S:void 0}},info:n})}return s}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();let o=this.safeString(i,"availableMargin"),d=this.safeString(i,"marginBalance");r!=="USDT"?(o=Hs.stringDiv(o,"1e8"),d=Hs.stringDiv(d,"1e8")):(o=Hs.stringDiv(o,"1e6"),d=Hs.stringDiv(d,"1e6")),a.free=o,a.total=d,t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t={currency:"all"},s=await this.privateGetUserMargin(this.extend(t,e));return this.parseBalance(s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={symbol:this.market(e).id};t!==void 0&&(n.depth=t);const r=await this.publicGetOrderBookL2(this.extend(n,s)),a={symbol:e,bids:[],asks:[],timestamp:void 0,datetime:void 0,nonce:void 0};for(let o=0;o<r.length;o++){const d=r[o],c=d.side==="Sell"?"asks":"bids",u=this.safeNumber(d,"size"),h=this.safeNumber(d,"price");h!==void 0&&a[c].push([h,u])}return a.bids=this.sortBy(a.bids,0,!0),a.asks=this.sortBy(a.asks,0),a}async fetchOrder(e,t=void 0,s={}){const i={filter:{orderID:e}},n=await this.fetchOrders(t,void 0,void 0,this.deepExtend(i,s));if(n.length===1)return n[0];throw new jk(this.id+": The order "+e+" not found.")}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),t!==void 0&&(r.startTime=this.iso8601(t)),s!==void 0&&(r.count=s),r=this.deepExtend(r,i),"filter"in r&&(r.filter=this.json(r.filter));const a=await this.privateGetOrder(r);return this.parseOrders(a,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={filter:{open:!0}};return await this.fetchOrders(e,t,s,this.deepExtend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n=await this.fetchOrders(e,t,s,i);return this.filterBy(n,"status","closed")}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),t!==void 0&&(r.startTime=this.iso8601(t)),s!==void 0&&(r.count=s),r=this.deepExtend(r,i),"filter"in r&&(r.filter=this.json(r.filter));const a=await this.privateGetExecutionTradeHistory(r);return this.parseTrades(a,n,t,s)}parseLedgerEntryType(e){const t={Withdrawal:"transaction",RealisedPNL:"margin",UnrealisedPNL:"margin",Deposit:"transaction",Transfer:"transfer",AffiliatePayout:"referral"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"transactID"),i=this.safeString(e,"account"),n=this.safeString(e,"tx"),r=void 0,a=this.parseLedgerEntryType(this.safeString(e,"transactType")),o=this.safeString(e,"currency"),d=this.safeCurrencyCode(o,t);let c=this.safeNumber(e,"amount");c!==void 0&&(c=c/1e8);let u=this.parse8601(this.safeString(e,"transactTime"));u===void 0&&(u=0);let h=this.safeNumber(e,"fee",0);h!==void 0&&(h=h/1e8);const l={cost:h,currency:d};let p=this.safeNumber(e,"walletBalance");p!==void 0&&(p=p/1e8);const m=this.sum(p,-c);let g;c<0?(g="out",c=Math.abs(c)):g="in";const y=this.parseTransactionStatus(this.safeString(e,"transactStatus"));return{id:s,info:e,timestamp:u,datetime:this.iso8601(u),direction:g,account:i,referenceId:n,referenceAccount:r,type:a,currency:d,amount:c,before:m,after:p,status:y,fee:l}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r={};s!==void 0&&(r.count=s);const a=await this.privateGetUserWalletHistory(this.extend(r,i));return this.parseLedger(a,n,t,s)}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={currency:"all"};s!==void 0&&(n.count=s);const r=await this.privateGetUserWalletHistory(this.extend(n,i)),a=this.filterByArray(r,"transactType",["Withdrawal","Deposit"],!1);let o;return e!==void 0&&(o=this.currency(e)),this.parseTransactions(a,o,t,s)}parseTransactionStatus(e){const t={Canceled:"canceled",Completed:"ok",Pending:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"transactID"),i=this.safeString(e,"currency");t=this.safeCurrency(i,t);const n=this.parse8601(this.safeString(e,"transactTime")),r=this.parse8601(this.safeString(e,"timestamp")),a=this.safeStringLower(e,"transactType");let o,d,c;a==="withdrawal"&&(o=this.safeString(e,"address"),d=this.safeString(e,"tx"),c=o);let u=this.safeString(e,"amount");const h=t.code==="BTC"?"1e8":"1e6";u=Hs.stringDiv(Hs.stringAbs(u),h);let l=this.safeString(e,"fee");l=Hs.stringDiv(l,h);const p={cost:this.parseNumber(l),currency:t.code};let m=this.safeString(e,"transactStatus");return m!==void 0&&(m=this.parseTransactionStatus(m)),{info:e,id:s,txid:void 0,timestamp:n,datetime:this.iso8601(n),network:void 0,addressFrom:d,address:o,addressTo:c,tagFrom:void 0,tag:void 0,tagTo:void 0,type:a,amount:this.parseNumber(u),currency:t.code,status:m,updated:r,comment:void 0,fee:p}}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=await this.fetchTickers([s.symbol],t),n=this.safeValue(i,s.symbol);if(n===void 0)throw new Hm(this.id+" fetchTicker() symbol "+e+" not found");return n}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetInstrumentActiveAndIndices(t),i={};for(let n=0;n<s.length;n++){const r=this.parseTicker(s[n]),a=this.safeString(r,"symbol");a!==void 0&&(i[a]=r)}return this.filterByArray(i,"symbol",e)}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.parse8601(this.safeString(e,"timestamp")),r=this.safeString(e,"prevPrice24h"),a=this.safeString(e,"lastPrice");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"highPrice"),low:this.safeString(e,"lowPrice"),bid:this.safeString(e,"bidPrice"),bidVolume:void 0,ask:this.safeString(e,"askPrice"),askVolume:void 0,vwap:this.safeString(e,"vwap"),open:r,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"homeNotional24h"),quoteVolume:this.safeString(e,"foreignNotional24h"),info:e},t)}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"timestamp")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,binSize:this.timeframes[t],partial:!0};i!==void 0&&(a.count=i);const o=this.parseTimeframe(t)*1e3,d=this.safeValue(this.options,"fetchOHLCVOpenTimestamp",!0);if(s!==void 0){let h=s;d&&(h=this.sum(h,o));const l=this.ymdhms(h);a.startTime=l}else a.reverse=!0;const c=await this.publicGetTradeBucketed(this.extend(a,n)),u=this.parseOHLCVs(c,r,t,s,i);if(d)for(let h=0;h<u.length;h++)u[h][0]=u[h][0]-o;return u}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"timestamp")),i=this.safeString2(e,"avgPx","price"),n=this.safeString2(e,"size","lastQty"),r=this.safeString(e,"execCost"),a=Hs.stringDiv(Hs.stringAbs(r),"1e8"),o=this.safeString(e,"trdMatchID"),d=this.safeString(e,"orderID"),c=this.safeStringLower(e,"side");let u;const h=Hs.stringDiv(this.safeString(e,"execComm"),"1e8");if(h!==void 0){const b=this.safeString(e,"settlCurrency"),w=this.safeCurrencyCode(b),k=this.safeString(e,"commission");u={cost:h,currency:w,rate:k}}const l=this.safeString(e,"execType");let p;h!==void 0&&l==="Trade"&&(p=Hs.stringLt(h,"0")?"maker":"taker");const m=this.safeString(e,"symbol"),g=this.safeSymbol(m,t),y=this.safeStringLower(e,"ordType");return this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:g,id:o,order:d,type:y,takerOrMaker:p,side:c,price:i,cost:a,amount:n,fee:u},t)}parseOrderStatus(e){const t={New:"open",PartiallyFilled:"open",Filled:"closed",DoneForDay:"open",Canceled:"canceled",PendingCancel:"open",PendingNew:"open",Rejected:"rejected",Expired:"expired",Stopped:"open",Untriggered:"open",Triggered:"open"};return this.safeString(t,e,e)}parseTimeInForce(e){const t={Day:"Day",GoodTillCancel:"GTC",ImmediateOrCancel:"IOC",FillOrKill:"FOK"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString(e,"ordStatus")),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.parse8601(this.safeString(e,"timestamp")),a=this.parse8601(this.safeString(e,"transactTime")),o=this.safeString(e,"price"),d=this.safeString(e,"orderQty"),c=this.safeString(e,"cumQty"),u=this.safeString(e,"avgPx"),h=this.safeString(e,"orderID"),l=this.safeStringLower(e,"ordType"),p=this.safeStringLower(e,"side"),m=this.safeString(e,"clOrdID"),g=this.parseTimeInForce(this.safeString(e,"timeInForce")),y=this.safeNumber(e,"stopPx"),b=this.safeString(e,"execInst");let w;return b!==void 0&&(w=b==="ParticipateDoNotInitiate"),this.safeOrder({info:e,id:h,clientOrderId:m,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:a,symbol:n,type:l,timeInForce:g,postOnly:w,side:p,price:o,stopPrice:y,amount:d,cost:void 0,average:u,filled:c,remaining:void 0,status:s,fee:void 0,trades:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};t!==void 0?r.startTime=this.iso8601(t):r.reverse=!0,s!==void 0&&(r.count=s);const a=await this.publicGetTrade(this.extend(r,i));return this.parseTrades(a,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.capitalize(t),d=this.safeValue(r,"reduceOnly");if(d!==void 0&&a.type!=="swap"&&a.type!=="future")throw new Ao(this.id+" createOrder() does not support reduceOnly for "+a.type+" orders, reduceOnly orders are supported for swap and future markets only");const c={symbol:a.id,side:this.capitalize(s),orderQty:parseFloat(this.amountToPrecision(e,i)),ordType:o};if(d&&(c.execInst="ReduceOnly"),o==="Stop"||o==="StopLimit"||o==="MarketIfTouched"||o==="LimitIfTouched"){const l=this.safeNumber2(r,"stopPx","stopPrice");if(l===void 0)throw new Dm(this.id+" createOrder() requires a stopPx or stopPrice parameter for the "+o+" order type");c.stopPx=parseFloat(this.priceToPrecision(e,l)),r=this.omit(r,["stopPx","stopPrice"])}(o==="Limit"||o==="StopLimit"||o==="LimitIfTouched")&&(c.price=parseFloat(this.priceToPrecision(e,n)));const u=this.safeString2(r,"clOrdID","clientOrderId");u!==void 0&&(c.clOrdID=u,r=this.omit(r,["clOrdID","clientOrderId"]));const h=await this.privatePostOrder(this.extend(c,r));return this.parseOrder(h,a)}async editOrder(e,t,s,i,n=void 0,r=void 0,a={}){await this.loadMarkets();const o={},d=this.safeString2(a,"origClOrdID","clientOrderId");if(d!==void 0){o.origClOrdID=d;const u=this.safeString(a,"clOrdID","clientOrderId");u!==void 0&&(o.clOrdID=u),a=this.omit(a,["origClOrdID","clOrdID","clientOrderId"])}else o.orderID=e;n!==void 0&&(o.orderQty=n),r!==void 0&&(o.price=r);const c=await this.privatePutOrder(this.extend(o,a));return this.parseOrder(c)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue2(s,"clOrdID","clientOrderId"),n={};i===void 0?n.orderID=e:(n.clOrdID=i,s=this.omit(s,["clOrdID","clientOrderId"]));const r=await this.privateDeleteOrder(this.extend(n,s)),a=this.safeValue(r,0,{}),o=this.safeString(a,"error");if(o!==void 0&&o.indexOf("Unable to cancel order due to existing state")>=0)throw new jk(this.id+" cancelOrder() failed: "+o);return this.parseOrder(a)}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue2(s,"clOrdID","clientOrderId"),n={};i===void 0?n.orderID=e:(n.clOrdID=i,s=this.omit(s,["clOrdID","clientOrderId"]));const r=await this.privateDeleteOrder(this.extend(n,s));return this.parseOrders(r)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;e!==void 0&&(i=this.market(e),s.symbol=i.id);const n=await this.privateDeleteOrderAll(this.extend(s,t));return this.parseOrders(n,i)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetPosition(t);return this.parsePositions(s,e)}parsePosition(e,t=void 0){t=this.safeMarket(this.safeString(e,"symbol"),t);const s=t.symbol,i=this.safeString(e,"timestamp"),r=this.safeValue(e,"crossMargin")===!0?"cross":"isolated";let a;t.quote==="USDT"||t.quote==="USD"||t.quote==="EUR"?a=Hs.stringMul(this.safeString(e,"foreignNotional"),"-1"):a=this.safeString(e,"homeNotional");const o=this.safeNumber(e,"maintMargin"),d=this.safeNumber(e,"unrealisedPnl"),c=this.omitZero(this.safeNumber(e,"currentQty"));return{info:e,id:this.safeString(e,"account"),symbol:s,timestamp:this.parse8601(i),datetime:i,hedged:void 0,side:void 0,contracts:this.convertValue(c,t),contractSize:void 0,entryPrice:this.safeNumber(e,"avgEntryPrice"),markPrice:this.safeNumber(e,"markPrice"),notional:a,leverage:this.safeNumber(e,"leverage"),collateral:void 0,initialMargin:this.safeNumber(e,"initMargin"),initialMarginPercentage:this.safeNumber(e,"initMarginReq"),maintenanceMargin:this.convertValue(o,t),maintenanceMarginPercentage:this.safeNumber(e,"maintMarginReq"),unrealizedPnl:this.convertValue(d,t),liquidationPrice:this.safeNumber(e,"liquidationPrice"),marginMode:r,marginRatio:void 0,percentage:this.safeNumber(e,"unrealisedPnlPcnt")}}convertValue(e,t=void 0){if(e===void 0||t===void 0)return e;let s;if(e=this.numberToString(e),t.quote==="USD"||t.quote==="EUR")s=Hs.stringMul(e,"0.00000001");else if(t.quote==="USDT")s=Hs.stringMul(e,"0.000001");else{let i;t.quote!==void 0&&(i=this.currency(t.quote)),i!==void 0&&(s=Hs.stringMul(e,this.numberToString(i.precision)))}return s=s!==void 0?parseFloat(s):void 0,s}isFiat(e){return e==="EUR"||e==="PLN"}async withdraw(e,t,s,i=void 0,n={}){if([i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets(),e!=="BTC")throw new Rm(this.id+" supoprts BTC withdrawals only, other currencies coming soon...");const r=this.currency(e),a={currency:"XBt",amount:t,address:s},o=await this.privatePostUserRequestWithdrawal(this.extend(a,n));return this.parseTransaction(o,r)}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetInstrumentActiveAndIndices(t),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeMarket(a);this.safeValue(o,"swap",!1)&&i.push(r)}return this.parseFundingRates(i,e)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"timestamp"),i=this.safeString(e,"symbol"),n=this.safeString(e,"fundingTimestamp");return{info:e,symbol:this.safeSymbol(i,t),markPrice:this.safeNumber(e,"markPrice"),indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:this.safeNumber(e,"indicativeSettlePrice"),timestamp:this.parse8601(s),datetime:s,fundingRate:this.safeNumber(e,"fundingRate"),fundingTimestamp:this.iso8601(n),fundingDatetime:n,nextFundingRate:this.safeNumber(e,"indicativeFundingRate"),nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e in this.currencies){const d=this.currency(e);n.symbol=d.id}else if(e!==void 0){const d=e.split(":"),c=d.length,u=["nearest","daily","weekly","monthly","quarterly","biquarterly","perpetual"];c>1&&this.inArray(d[1],u)?(e=this.currency(d[0]).id+":"+d[1],n.symbol=e):(r=this.market(e),n.symbol=r.id)}t!==void 0&&(n.startTime=this.iso8601(t)),s!==void 0&&(n.count=s);const a=this.safeInteger2(i,"until","till");i=this.omit(i,["until","till"]),a!==void 0&&(n.endTime=this.iso8601(a));const o=await this.publicGetFunding(this.extend(n,i));return this.parseFundingRateHistories(o,r,t,s)}parseFundingRateHistory(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeString(e,"timestamp");return{info:e,symbol:this.safeSymbol(s,t),fundingRate:this.safeNumber(e,"fundingRate"),timestamp:this.parse8601(i),datetime:i}}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new Dm(this.id+" setLeverage() requires a symbol argument");if(e<.01||e>100)throw new Lm(this.id+" leverage should be between 0.01 and 100");await this.loadMarkets();const i=this.market(t);if(i.type!=="swap"&&i.type!=="future")throw new Hm(this.id+" setLeverage() supports future and swap contracts only");const n={symbol:i.id,leverage:e};return await this.privatePostPositionLeverage(this.extend(n,s))}async setMarginMode(e,t=void 0,s={}){if(t===void 0)throw new Dm(this.id+" setMarginMode() requires a symbol argument");if(e=e.toLowerCase(),e!=="isolated"&&e!=="cross")throw new Lm(this.id+" setMarginMode() marginMode argument should be isolated or cross");await this.loadMarkets();const i=this.market(t);if(i.type!=="swap"&&i.type!=="future")throw new Hm(this.id+" setMarginMode() supports swap and future contracts only");const n=e!=="cross",r={symbol:i.id,enabled:n};return await this.privatePostPositionIsolate(this.extend(r,s))}calculateRateLimiterCost(e,t,s,i,n={},r={}){const a=this.checkRequiredCredentials(!1),o=this.safeValue(n,"cost",1);return o!==1?a?o:20:o}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0){if(e===429)throw new u6(this.id+" "+r);if(e>=400){const c=this.safeValue(a,"error",{}),u=this.safeString(c,"message"),h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwBroadlyMatchedException(this.exceptions.broad,u,h),e===400?new Lm(h):new Rm(h)}}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/api/"+this.version+"/"+e;if(s==="GET")Object.keys(i).length&&(a+="?"+this.urlencode(i));else{const c=this.safeString(i,"_format");c!==void 0&&(a+="?"+this.urlencode({_format:c}),i=this.omit(i,"_format"))}const o=this.urls.api[t]+a,d=this.checkRequiredCredentials(!1);if(t==="private"||t==="public"&&d){this.checkRequiredCredentials();let c=s+a,u=this.safeInteger(this.options,"api-expires");n={"Content-Type":"application/json","api-key":this.apiKey},u=this.sum(this.seconds(),u),u=u.toString(),c+=u,n["api-expires"]=u,(s==="POST"||s==="PUT"||s==="DELETE")&&Object.keys(i).length&&(r=this.json(i),c+=r),n["api-signature"]=this.hmac(this.encode(c),this.encode(this.secret))}return{url:o,method:s,body:r,headers:n}}};const h6=ge,{ExchangeError:Wk,ArgumentsRequired:Wr,AuthenticationError:l6,InvalidOrder:Gm,InsufficientFunds:p6,BadRequest:Bo}=de,{TICK_SIZE:m6}=me,g6=Se;var F_=class extends h6{describe(){return this.deepExtend(super.describe(),{id:"bitopro",name:"BitoPro",countries:["TW"],version:"v3",rateLimit:100,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createOrder:!0,editOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchOrderTrades:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,setLeverage:!1,setMarginMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","3h":"3h","6h":"6h","12h":"12h","1d":"1d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/158227251-3a92a220-9222-453c-9277-977c6677fe71.jpg",api:{rest:"https://api.bitopro.com/v3"},www:"https://www.bitopro.com",doc:["https://github.com/bitoex/bitopro-offical-api-docs/blob/master/v3-1/rest-1/rest.md"],fees:"https://www.bitopro.com/fees"},requiredCredentials:{apiKey:!0,secret:!0},api:{public:{get:["order-book/{pair}","tickers","tickers/{pair}","trades/{pair}","provisioning/currencies","provisioning/trading-pairs","provisioning/limitations-and-fees","trading-history/{pair}"]},private:{get:["accounts/balance","orders/history","orders/all/{pair}","orders/trades/{pair}","orders/{pair}/{orderId}","wallet/withdraw/{currency}/{serial}","wallet/withdraw/{currency}/id/{id}","wallet/depositHistory/{currency}","wallet/withdrawHistory/{currency}"],post:["orders/{pair}","orders/batch","wallet/withdraw/{currency}"],put:["orders"],delete:["orders/{pair}/{id}","orders/all","orders/{pair}"]}},fees:{trading:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.002"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.002")],[this.parseNumber("3000000"),this.parseNumber("0.00194")],[this.parseNumber("5000000"),this.parseNumber("0.0015")],[this.parseNumber("30000000"),this.parseNumber("0.0014")],[this.parseNumber("300000000"),this.parseNumber("0.0013")],[this.parseNumber("550000000"),this.parseNumber("0.0012")],[this.parseNumber("1300000000"),this.parseNumber("0.0011")]],maker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("3000000"),this.parseNumber("0.00097")],[this.parseNumber("5000000"),this.parseNumber("0.0007")],[this.parseNumber("30000000"),this.parseNumber("0.0006")],[this.parseNumber("300000000"),this.parseNumber("0.0005")],[this.parseNumber("550000000"),this.parseNumber("0.0004")],[this.parseNumber("1300000000"),this.parseNumber("0.0003")]]}}},options:{networks:{ERC20:"ERC20",ETH:"ERC20",TRX:"TRX",TRC20:"TRX"}},precisionMode:m6,exceptions:{exact:{"Unsupported currency.":Bo,"Unsupported order type":Bo,"Invalid body":Bo,"Invalid Signature":l6,"Address not in whitelist.":Bo},broad:{"Invalid amount":Gm,"Balance for ":p6,"Invalid ":Bo,"Wrong parameter":Bo}},commonCurrencies:{}})}async fetchCurrencies(e={}){const t=await this.publicGetProvisioningCurrencies(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.safeValue(r,"deposit"),c=this.safeValue(r,"withdraw"),u=this.safeNumber(r,"withdrawFee"),h=this.safeNumber(r,"minWithdraw"),l=this.safeNumber(r,"maxWithdraw"),p={withdraw:{min:h,max:l},amount:{min:void 0,max:void 0}};i[o]={id:a,code:o,info:r,type:void 0,name:void 0,active:d&&c,deposit:d,withdraw:c,fee:u,precision:void 0,limits:p}}return i}async fetchMarkets(e={}){const t=await this.publicGetProvisioningTradingPairs(),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=!this.safeValue(r,"maintain"),o=this.safeString(r,"pair"),d=o.toUpperCase(),c=this.safeString(r,"base"),u=this.safeString(r,"quote"),h=this.safeCurrencyCode(c),l=this.safeCurrencyCode(u),p=h+"/"+l,m={amount:{min:this.safeNumber(r,"minLimitBaseAmount"),max:this.safeNumber(r,"maxLimitBaseAmount")},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0},leverage:{min:void 0,max:void 0}};i.push({id:o,uppercaseId:d,symbol:p,base:h,quote:l,baseId:h,quoteId:l,settle:void 0,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,derivative:!1,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,limits:m,precision:{price:this.parseNumber(this.parsePrecision(this.safeString(r,"quotePrecision"))),amount:this.parseNumber(this.parsePrecision(this.safeString(r,"basePrecision")))},active:a,info:r})}return i}parseTicker(e,t=void 0){const s=this.safeString(e,"pair");t=this.safeMarket(s,t);const i=this.safeString(t,"symbol");return this.safeTicker({symbol:i,timestamp:void 0,datetime:void 0,high:this.safeString(e,"high24hr"),low:this.safeString(e,"low24hr"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:this.safeString(e,"lastPrice"),last:this.safeString(e,"lastPrice"),previousClose:void 0,change:void 0,percentage:this.safeString(e,"priceChange24hr"),average:void 0,baseVolume:this.safeString(e,"volume24hr"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetTickersPair(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickers(),i=this.safeValue(s,"data",[]);return this.parseTickers(i,e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetOrderBookPair(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"bids","asks","price","amount")}parseTrade(e,t){const s=this.safeString(e,"tradeId"),i=this.safeString(e,"orderId");let n;s===void 0?n=this.safeTimestamp(e,"timestamp"):n=this.safeInteger(e,"timestamp");const r=this.safeString(e,"pair");t=this.safeMarket(r,t);const a=this.safeString(t,"symbol"),o=this.safeString(e,"price"),d=this.safeStringLower(e,"type");let c=this.safeStringLower(e,"action");c===void 0&&(this.safeValue(e,"isBuyer")?c="buy":c="sell");let u=this.safeString(e,"amount");u===void 0&&(u=this.safeString(e,"baseAmount"));let h;const l=this.safeString(e,"fee"),p=this.safeCurrencyCode(this.safeString(e,"feeSymbol"));l!==void 0&&(h={cost:l,currency:p,rate:void 0});const m=this.safeValue(e,"isTaker");let g;return m!==void 0&&(m?g="taker":g="maker"),this.safeTrade({id:s,info:e,order:i,timestamp:n,datetime:this.iso8601(n),symbol:a,takerOrMaker:g,type:d,side:c,price:o,amount:u,cost:void 0,fee:h},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id},a=await this.publicGetTradesPair(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetProvisioningLimitationsAndFees(e),s=this.safeValue(t,"tradingFeeRate",{}),i=this.safeValue(s,0),n={},r=this.safeNumber(i,"makerFee"),a=this.safeNumber(i,"takerFee");for(let o=0;o<this.symbols.length;o++){const d=this.symbols[o];n[d]={info:i,symbol:d,maker:r,taker:a,percentage:!0,tierBased:!0}}return n}parseOHLCV(e,t=void 0,s="1m",i=void 0,n=void 0){return[this.safeInteger(e,"timestamp"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.timeframes[t],o={pair:r.id,resolution:a};i===void 0&&(i=500);const d=this.parseTimeframe(t);let c;if(s===void 0)o.to=this.seconds(),o.from=o.to-i*d;else{const p=d*1e3;c=Math.floor(s/p)*p,o.from=Math.floor(s/1e3),o.to=this.sum(o.from,i*d)}const u=await this.publicGetTradingHistoryPair(this.extend(o,n)),h=this.safeValue(u,"data",[]),l=this.parseOHLCVs(h,r,t,s,i);return this.insertMissingCandles(l,d,c,i)}insertMissingCandles(e,t,s,i){if(e.length===0)return e;const r=[];let a=e[0],o;s===void 0?o=a[0]:o=s;let d=0;const c=e.length;let u=0;for(;u<i&&d<c;){const h=e[d];if(h[0]===o)r.push(h),d=this.sum(d,1);else{const l=this.arrayConcat([],a);l[0]=o,l[1]=l[4],l[2]=l[4],l[3]=l[4],l[5]=this.parseNumber("0"),r.push(l)}o=this.sum(o,t*1e3),u=r.length,a=r[u-1]}return r}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.safeString(i,"amount"),d={free:this.safeString(i,"available"),total:a};t[r]=d}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountsBalance(e),s=this.safeValue(t,"data",[]);return this.parseBalance(s)}parseOrderStatus(e){const t={"-1":"open",0:"open",1:"open",2:"closed",3:"closed",4:"canceled"};return this.safeString(t,e,void 0)}parseOrder(e,t=void 0){const s=this.safeString2(e,"id","orderId"),i=this.safeInteger2(e,"timestamp","createdTimestamp");let n=this.safeString(e,"action");n=n.toLowerCase();const r=this.safeString2(e,"amount","originalAmount"),a=this.safeString(e,"price"),o=this.safeString(e,"pair");t=this.safeMarket(o,t,"_");const d=this.safeString(t,"symbol"),c=this.safeString(e,"status"),u=this.parseOrderStatus(c),h=this.safeStringLower(e,"type"),l=this.safeString(e,"avgExecutionPrice"),p=this.safeString(e,"executedAmount"),m=this.safeString(e,"remainingAmount"),g=this.safeString(e,"timeInForce");let y;const b=this.safeString(e,"fee"),w=this.safeCurrencyCode(this.safeString(e,"feeSymbol"));return g6.stringGt(b,"0")&&(y={currency:w,cost:b}),this.safeOrder({id:s,clientOrderId:void 0,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:this.safeInteger(e,"updatedTimestamp"),symbol:d,type:h,timeInForce:g,postOnly:void 0,side:n,price:a,stopPrice:void 0,amount:r,cost:void 0,average:l,filled:p,remaining:m,status:u,fee:y,trades:void 0,info:e},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={type:t,pair:a.id,action:s,amount:this.amountToPrecision(e,i),timestamp:this.milliseconds()},d=t.toUpperCase();if(d==="LIMIT"&&(o.price=this.priceToPrecision(e,n)),d==="STOP_LIMIT"){o.price=this.priceToPrecision(e,n);const u=this.safeValue2(r,"triggerPrice","stopPrice");if(r=this.omit(r,["triggerPrice","stopPrice"]),u===void 0)throw new Gm(this.id+" createOrder() requires a stopPrice parameter for "+d+" orders");o.stopPrice=this.priceToPrecision(e,u);const h=this.safeString(r,"condition");if(h===void 0)throw new Gm(this.id+" createOrder() requires a condition parameter for "+d+" orders");o.condition=h}const c=await this.privatePostOrdersPair(this.extend(o,r),r);return this.parseOrder(c,a)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Wr(this.id+" cancelOrder() requires the symbol argument");await this.loadMarkets();const i=this.market(t),n={id:e,pair:i.id},r=await this.privateDeleteOrdersPairId(this.extend(n,s));return this.parseOrder(r,i)}async cancelOrders(e,t=void 0,s={}){if(t===void 0)throw new Wr(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(t).uppercaseId,r={};return r[n]=e,await this.privatePutOrders(this.extend(r,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i=this.safeString(this.options,"privateDeleteOrdersPair","privateDeleteOrdersAll");if(e!==void 0){const a=this.market(e);s.pair=a.id,i="privateDeleteOrdersPair"}const n=await this[i](this.extend(s,t));return this.safeValue(n,"data",{})}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Wr(this.id+" fetchOrder() requires the symbol argument");await this.loadMarkets();const i=this.market(t),n={orderId:e,pair:i.id},r=await this.privateGetOrdersPairOrderId(this.extend(n,s));return this.parseOrder(r,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Wr(this.id+" fetchOrders() requires the symbol argument");await this.loadMarkets();const n=this.market(e),r={pair:n.id};t!==void 0&&(r.startTimestamp=t),s!==void 0&&(r.limit=s);const a=await this.privateGetOrdersAllPair(this.extend(r,i),i);let o=this.safeValue(a,"data");return o===void 0&&(o=[]),this.parseOrders(o,n,t,s)}fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={statusKind:"OPEN"};return this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={statusKind:"DONE"};return this.fetchOrders(e,t,s,this.extend(n,i))}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Wr(this.id+" fetchMyTrades() requires the symbol argument");await this.loadMarkets();const n=this.market(e),r={pair:n.id},a=await this.privateGetOrdersTradesPair(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}parseTransactionStatus(e){const t={COMPLETE:"ok",INVALID:"failed",PROCESSING:"pending",WAIT_PROCESS:"pending",FAILED:"failed",EXPIRED:"failed",CANCELLED:"failed",EMAIL_VERIFICATION:"pending",WAIT_CONFIRMATION:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"coin"),i=this.safeCurrencyCode(s,t),n=this.safeString(e,"serial"),r=this.safeString(e,"txid"),a=this.safeInteger(e,"timestamp"),o=this.safeNumber(e,"total"),d=this.safeString(e,"address"),c=this.safeString(e,"message"),u=this.safeString(e,"status"),h=this.safeNumber(e,"fee");return{info:e,id:n,txid:r,timestamp:a,datetime:this.iso8601(a),network:void 0,addressFrom:void 0,address:d,addressTo:d,tagFrom:void 0,tag:c,tagTo:c,type:void 0,amount:o,currency:i,status:this.parseTransactionStatus(u),updated:void 0,fee:{currency:i,cost:h,rate:void 0}}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Wr(this.id+" fetchDeposits() requires the code argument");await this.loadMarkets();const n=this.safeCurrency(e),r={currency:n.id};t!==void 0&&(r.startTimestamp=t),s!==void 0&&(r.limit=s);const a=await this.privateGetWalletDepositHistoryCurrency(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Wr(this.id+" fetchWithdrawals() requires the code argument");await this.loadMarkets();const n=this.safeCurrency(e),r={currency:n.id};t!==void 0&&(r.startTimestamp=t),s!==void 0&&(r.limit=s);const a=await this.privateGetWalletWithdrawHistoryCurrency(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s,{type:"withdrawal"})}async fetchWithdrawal(e,t=void 0,s={}){if(t===void 0)throw new Wr(this.id+" fetchWithdrawal() requires the code argument");await this.loadMarkets();const i=this.safeCurrency(t),n={serial:e,currency:i.id},r=await this.privateGetWalletWithdrawCurrencySerial(this.extend(n,s)),a=this.safeValue(r,"data",{});return this.parseTransaction(a,i)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets(),this.checkAddress(s);const r=this.currency(e),a={currency:r.id,amount:this.numberToString(t),address:s};if("network"in n){const c=this.safeValue(this.options,"networks",{}),u=this.safeStringUpper(n,"network");n=this.omit(n,["network"]);const h=this.safeString(c,u);if(h===void 0)throw new Wk(this.id+" invalid network "+u);a.protocol=h}i!==void 0&&(a.message=i);const o=await this.privatePostWalletWithdrawCurrency(this.extend(a,n)),d=this.safeValue(o,"data",{});return this.parseTransaction(d,r)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(n===void 0&&(n={}),n["X-BITOPRO-API"]="ccxt",t==="private"){if(this.checkRequiredCredentials(),s==="POST"||s==="PUT"){r=this.json(i);const d=this.stringToBase64(r),c=this.hmac(d,this.encode(this.secret),"sha384");n["X-BITOPRO-APIKEY"]=this.apiKey,n["X-BITOPRO-PAYLOAD"]=d,n["X-BITOPRO-SIGNATURE"]=c}else if(s==="GET"||s==="DELETE"){Object.keys(o).length&&(a+="?"+this.urlencode(o));let c={nonce:this.milliseconds()};c=this.json(c);const u=this.stringToBase64(c),h=this.hmac(u,this.encode(this.secret),"sha384");n["X-BITOPRO-APIKEY"]=this.apiKey,n["X-BITOPRO-PAYLOAD"]=u,n["X-BITOPRO-SIGNATURE"]=h}}else t==="public"&&s==="GET"&&Object.keys(o).length&&(a+="?"+this.urlencode(o));return a=this.urls.api.rest+a,{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0||e>=200&&e<300)return;const c=this.id+" "+r,u=this.safeString(a,"error");throw this.throwExactlyMatchedException(this.exceptions.exact,u,c),this.throwBroadlyMatchedException(this.exceptions.broad,u,c),new Wk(c)}};const y6=ge,{AuthenticationError:ki,ExchangeError:zk,PermissionDenied:Kk,BadRequest:vt,ArgumentsRequired:Yi,OrderNotFound:Um,InsufficientFunds:Xk,ExchangeNotAvailable:$m,DDoSProtection:Yk,InvalidAddress:Qk,InvalidOrder:Qi}=de,{TICK_SIZE:b6}=me,Tf=Se;var w6=class extends y6{describe(){return this.deepExtend(super.describe(),{id:"bitpanda",name:"Bitpanda Pro",countries:["AT"],rateLimit:300,version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createDepositAddress:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchAccounts:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,privateAPI:!0,publicAPI:!0,reduceMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1/MINUTES","5m":"5/MINUTES","15m":"15/MINUTES","30m":"30/MINUTES","1h":"1/HOURS","4h":"4/HOURS","1d":"1/DAYS","1w":"1/WEEKS","1M":"1/MONTHS"},urls:{logo:"https://user-images.githubusercontent.com/51840849/87591171-9a377d80-c6f0-11ea-94ac-97a126eac3bc.jpg",api:{public:"https://api.exchange.bitpanda.com/public",private:"https://api.exchange.bitpanda.com/public"},www:"https://www.bitpanda.com/en/pro",doc:["https://developers.bitpanda.com/exchange/"],fees:"https://www.bitpanda.com/en/pro/fees"},api:{public:{get:["currencies","candlesticks/{instrument_code}","fees","instruments","order-book/{instrument_code}","market-ticker","market-ticker/{instrument_code}","price-ticks/{instrument_code}","time"]},private:{get:["account/balances","account/deposit/crypto/{currency_code}","account/deposit/fiat/EUR","account/deposits","account/deposits/bitpanda","account/withdrawals","account/withdrawals/bitpanda","account/fees","account/orders","account/orders/{order_id}","account/orders/{order_id}/trades","account/trades","account/trades/{trade_id}","account/trading-volume"],post:["account/deposit/crypto","account/withdraw/crypto","account/withdraw/fiat","account/fees","account/orders"],delete:["account/orders","account/orders/{order_id}","account/orders/client/{client_id}"]}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0015"),maker:this.parseNumber("0.001"),tiers:[{taker:[[this.parseNumber("0"),this.parseNumber("0.0015")],[this.parseNumber("100"),this.parseNumber("0.0013")],[this.parseNumber("250"),this.parseNumber("0.0013")],[this.parseNumber("1000"),this.parseNumber("0.001")],[this.parseNumber("5000"),this.parseNumber("0.0009")],[this.parseNumber("10000"),this.parseNumber("0.00075")],[this.parseNumber("20000"),this.parseNumber("0.00065")]],maker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("100"),this.parseNumber("0.001")],[this.parseNumber("250"),this.parseNumber("0.0009")],[this.parseNumber("1000"),this.parseNumber("0.00075")],[this.parseNumber("5000"),this.parseNumber("0.0006")],[this.parseNumber("10000"),this.parseNumber("0.0005")],[this.parseNumber("20000"),this.parseNumber("0.0005")]]}]}},requiredCredentials:{apiKey:!0,secret:!1},precisionMode:b6,exceptions:{exact:{INVALID_CLIENT_UUID:Qi,ORDER_NOT_FOUND:Um,ONLY_ONE_ERC20_ADDRESS_ALLOWED:Qk,DEPOSIT_ADDRESS_NOT_USED:Qk,INVALID_CREDENTIALS:ki,MISSING_CREDENTIALS:ki,INVALID_APIKEY:ki,INVALID_SCOPES:ki,INVALID_SUBJECT:ki,INVALID_ISSUER:ki,INVALID_AUDIENCE:ki,INVALID_DEVICE_ID:ki,INVALID_IP_RESTRICTION:ki,APIKEY_REVOKED:ki,APIKEY_EXPIRED:ki,SYNCHRONIZER_TOKEN_MISMATCH:ki,SESSION_EXPIRED:ki,INTERNAL_ERROR:ki,CLIENT_IP_BLOCKED:Kk,MISSING_PERMISSION:Kk,ILLEGAL_CHARS:vt,UNSUPPORTED_MEDIA_TYPE:vt,ACCOUNT_HISTORY_TIME_RANGE_TOO_BIG:vt,CANDLESTICKS_TIME_RANGE_TOO_BIG:vt,INVALID_INSTRUMENT_CODE:vt,INVALID_ORDER_TYPE:vt,INVALID_UNIT:vt,INVALID_PERIOD:vt,INVALID_TIME:vt,INVALID_DATE:vt,INVALID_CURRENCY:vt,INVALID_AMOUNT:vt,INVALID_PRICE:vt,INVALID_LIMIT:vt,INVALID_QUERY:vt,INVALID_CURSOR:vt,INVALID_ACCOUNT_ID:vt,INVALID_SIDE:Qi,INVALID_ACCOUNT_HISTORY_FROM_TIME:vt,INVALID_ACCOUNT_HISTORY_MAX_PAGE_SIZE:vt,INVALID_ACCOUNT_HISTORY_TIME_PERIOD:vt,INVALID_ACCOUNT_HISTORY_TO_TIME:vt,INVALID_CANDLESTICKS_GRANULARITY:vt,INVALID_CANDLESTICKS_UNIT:vt,INVALID_ORDER_BOOK_DEPTH:vt,INVALID_ORDER_BOOK_LEVEL:vt,INVALID_PAGE_CURSOR:vt,INVALID_TIME_RANGE:vt,INVALID_TRADE_ID:vt,INVALID_UI_ACCOUNT_SETTINGS:vt,NEGATIVE_AMOUNT:Qi,NEGATIVE_PRICE:Qi,MIN_SIZE_NOT_SATISFIED:Qi,BAD_AMOUNT_PRECISION:Qi,BAD_PRICE_PRECISION:Qi,BAD_TRIGGER_PRICE_PRECISION:Qi,MAX_OPEN_ORDERS_EXCEEDED:vt,MISSING_PRICE:Qi,MISSING_ORDER_TYPE:Qi,MISSING_SIDE:Qi,MISSING_CANDLESTICKS_PERIOD_PARAM:Yi,MISSING_CANDLESTICKS_UNIT_PARAM:Yi,MISSING_FROM_PARAM:Yi,MISSING_INSTRUMENT_CODE:Yi,MISSING_ORDER_ID:Qi,MISSING_TO_PARAM:Yi,MISSING_TRADE_ID:Yi,INVALID_ORDER_ID:Um,NOT_FOUND:Um,INSUFFICIENT_LIQUIDITY:Xk,INSUFFICIENT_FUNDS:Xk,NO_TRADING:$m,SERVICE_UNAVAILABLE:$m,GATEWAY_TIMEOUT:$m,RATELIMIT:Yk,CF_RATELIMIT:Yk,INTERNAL_SERVER_ERROR:zk},broad:{}},commonCurrencies:{MIOTA:"IOTA"},options:{fetchTradingFees:{method:"fetchPrivateTradingFees"},fiat:["EUR","CHF"]}})}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeInteger(t,"epoch_millis")}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"code"),a=this.safeCurrencyCode(r);s[a]={id:r,code:a,name:void 0,info:n,active:void 0,fee:void 0,precision:this.parseNumber(this.parsePrecision(this.safeString(n,"precision"))),limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}}}return s}async fetchMarkets(e={}){const t=await this.publicGetInstruments(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeValue(n,"base",{}),a=this.safeValue(n,"quote",{}),o=this.safeString(r,"code"),d=this.safeString(a,"code"),c=o+"_"+d,u=this.safeCurrencyCode(o),h=this.safeCurrencyCode(d),l=this.safeString(n,"state");s.push({id:c,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:l==="ACTIVE",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(n,"amount_precision"))),price:this.parseNumber(this.parsePrecision(this.safeString(n,"market_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(n,"min_size"),max:void 0}},info:n})}return s}async fetchTradingFees(e={}){let t=this.safeString(e,"method");if(e=this.omit(e,"method"),t===void 0){const s=this.safeValue(this.options,"fetchTradingFees",{});t=this.safeString(s,"method","fetchPrivateTradingFees")}return await this[t](e)}async fetchPublicTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetFees(e),s=this.safeValue(t,0,{}),i=this.safeValue(s,"fee_tiers"),n=this.parseFeeTiers(i),r=this.safeValue(i,0,{}),a={};for(let o=0;o<this.symbols.length;o++){const d=this.symbols[o];a[d]={info:s,symbol:d,maker:this.safeNumber(r,"maker_fee"),taker:this.safeNumber(r,"taker_fee"),percentage:!0,tierBased:!0,tiers:n}}return a}async fetchPrivateTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetAccountFees(e),s=this.safeValue(t,"active_fee_tier",{});let i=this.safeString(s,"maker_fee"),n=this.safeString(s,"taker_fee");i=Tf.stringDiv(i,"100"),n=Tf.stringDiv(n,"100");const r=this.safeValue(t,"fee_tiers"),a={},o=this.parseFeeTiers(r);for(let d=0;d<this.symbols.length;d++){const c=this.symbols[d];a[c]={info:t,symbol:c,maker:this.parseNumber(i),taker:this.parseNumber(n),percentage:!0,tierBased:!0,tiers:o}}return a}parseFeeTiers(e,t=void 0){const s=[],i=[];for(let n=0;n<e.length;n++){const r=e[n],a=this.safeNumber(r,"volume");let o=this.safeString(r,"taker_fee"),d=this.safeString(r,"maker_fee");d=Tf.stringDiv(d,"100"),o=Tf.stringDiv(o,"100"),i.push([a,this.parseNumber(d)]),s.push([a,this.parseNumber(o)])}return{maker:i,taker:s}}parseTicker(e,t=void 0){const s=this.parse8601(this.safeString(e,"time")),i=this.safeString(e,"instrument_code"),n=this.safeSymbol(i,t,"_"),r=this.safeString(e,"last_price"),a=this.safeString(e,"price_change_percentage"),o=this.safeString(e,"price_change"),d=this.safeString(e,"base_volume"),c=this.safeString(e,"quote_volume");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"best_bid"),bidVolume:void 0,ask:this.safeString(e,"best_ask"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:o,percentage:a,average:void 0,baseVolume:d,quoteVolume:c,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={instrument_code:s.id},n=await this.publicGetMarketTickerInstrumentCode(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetMarketTicker(t),i={};for(let n=0;n<s.length;n++){const r=this.parseTicker(s[n]),a=r.symbol;i[a]=r}return this.filterByArray(i,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={instrument_code:i.id};t!==void 0&&(n.depth=t);const r=await this.publicGetOrderBookInstrumentCode(this.extend(n,s)),a=this.parse8601(this.safeString(r,"time"));return this.parseOrderBook(r,i.symbol,a,"bids","asks","price","amount")}parseOHLCV(e,t=void 0){const s=this.safeValue(e,"granularity"),i=this.safeString(s,"unit"),n=this.safeString(s,"period"),r={MINUTES:"m",HOURS:"h",DAYS:"d",WEEKS:"w",MONTHS:"M"},a=this.safeString(r,i),o=n+a,c=this.parseTimeframe(o)*1e3,u=this.parse8601(this.safeString(e,"time")),h=c*parseInt(u/c),l=this.safeValue(this.options,"fetchOHLCV",{}),p=this.safeString(l,"volume","total_amount");return[h,this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,p)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.safeString(this.timeframes,t),[o,d]=a.split("/"),u=this.parseTimeframe(t)*1e3;i===void 0&&(i=1500);const h={instrument_code:r.id,period:o,unit:d};if(s===void 0){const p=this.milliseconds();h.to=this.iso8601(p),h.from=this.iso8601(p-i*u)}else h.from=this.iso8601(s),h.to=this.iso8601(this.sum(s,i*u));const l=await this.publicGetCandlesticksInstrumentCode(this.extend(h,n));return this.parseOHLCVs(l,r,t,s,i)}parseTrade(e,t=void 0){const s=this.safeValue(e,"fee",{});e=this.safeValue(e,"trade",e);let i=this.safeInteger(e,"trade_timestamp");i===void 0&&(i=this.parse8601(this.safeString(e,"time")));const n=this.safeStringLower2(e,"side","taker_side"),r=this.safeString(e,"price"),a=this.safeString(e,"amount"),o=this.safeString(e,"volume"),d=this.safeString(e,"instrument_code"),c=this.safeSymbol(d,t,"_"),u=this.safeString(s,"fee_amount");let h,l;if(u!==void 0){const p=this.safeString(s,"fee_currency"),m=this.safeCurrencyCode(p),g=this.safeString(s,"fee_percentage");l={cost:u,currency:m,rate:g},h=this.safeStringLower(s,"fee_type")}return this.safeTrade({id:this.safeString2(e,"trade_id","sequence"),order:this.safeString(e,"order_id"),timestamp:i,datetime:this.iso8601(i),symbol:c,type:void 0,side:n,price:r,amount:a,cost:o,takerOrMaker:h,fee:l,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={instrument_code:n.id};t!==void 0&&(r.from=this.iso8601(t),r.to=this.iso8601(this.sum(t,144e5)));const a=await this.publicGetPriceTicksInstrumentCode(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseBalance(e){const t=this.safeValue(e,"balances",[]),s={info:e};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency_code"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(n,"available"),o.used=this.safeString(n,"locked"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountBalances(e);return this.parseBalance(t)}parseDepositAddress(e,t=void 0){let s;t!==void 0&&(s=t.code);const i=this.safeString(e,"address"),n=this.safeString(e,"destination_tag");return this.checkAddress(i),{currency:s,address:i,tag:n,network:void 0,info:e}}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=await this.privatePostAccountDepositCrypto(this.extend(i,t));return this.parseDepositAddress(n,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency_code:s.id},n=await this.privateGetAccountDepositCryptoCurrencyCode(this.extend(i,t));return this.parseDepositAddress(n,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.currency(e),n.currency_code=r.id),s!==void 0&&(n.max_page_size=s),t!==void 0){if(this.safeString(i,"to")===void 0)throw new Yi(this.id+' fetchDeposits() requires a "to" iso8601 string param with the since argument is specified');n.from=this.iso8601(t)}const a=await this.privateGetAccountDeposits(this.extend(n,i)),o=this.safeValue(a,"deposit_history",[]);return this.parseTransactions(o,r,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.currency(e),n.currency_code=r.id),s!==void 0&&(n.max_page_size=s),t!==void 0){if(this.safeString(i,"to")===void 0)throw new Yi(this.id+' fetchWithdrawals() requires a "to" iso8601 string param with the since argument is specified');n.from=this.iso8601(t)}const a=await this.privateGetAccountWithdrawals(this.extend(n,i)),o=this.safeValue(a,"withdrawal_history",[]);return this.parseTransactions(o,r,t,s,{type:"withdrawal"})}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency:e,amount:this.currencyToPrecision(e,t)},o=this.safeValue(this.options,"fiat",[]),d=this.inArray(e,o),c=d?"privatePostAccountWithdrawFiat":"privatePostAccountWithdrawCrypto";if(d){if(this.safeString(n,"payout_account_id")===void 0)throw new Yi(this.id+" withdraw() requires a payout_account_id param for fiat "+e+" withdrawals")}else{const h={address:s};i!==void 0&&(h.destination_tag=i),a.recipient=h}const u=await this[c](this.extend(a,n));return this.parseTransaction(u,r)}parseTransaction(e,t=void 0){const s=this.safeString(e,"transaction_id"),i=this.safeNumber(e,"amount"),n=this.parse8601(this.safeString(e,"time")),r=this.safeString(e,"currency");t=this.safeCurrency(r,t);const a="ok",o=this.safeNumber2(e,"fee_amount","fee");let d;const c=this.safeString(e,"recipient"),u=this.safeString(e,"destination_tag");if(o!==void 0){const h=this.safeString(e,"fee_currency",r),l=this.safeCurrencyCode(h);d={cost:o,currency:l}}return{info:e,id:s,currency:t.code,amount:i,network:void 0,address:c,addressFrom:void 0,addressTo:c,tag:u,tagFrom:void 0,tagTo:u,status:a,type:void 0,updated:void 0,txid:this.safeString(e,"blockchain_transaction_id"),timestamp:n,datetime:this.iso8601(n),fee:d}}parseOrderStatus(e){const t={FILLED:"open",FILLED_FULLY:"closed",FILLED_CLOSED:"canceled",FILLED_REJECTED:"rejected",OPEN:"open",REJECTED:"rejected",CLOSED:"canceled",FAILED:"failed",STOP_TRIGGERED:"triggered"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeValue(e,"order",e),i=this.safeString(s,"order_id"),n=this.safeString(s,"client_id"),r=this.parse8601(this.safeString(s,"time")),a=this.parseOrderStatus(this.safeString(s,"status")),o=this.parseOrderStatus(a),d=this.safeString(s,"instrument_code"),c=this.safeSymbol(d,t,"_"),u=this.safeString(s,"price"),h=this.safeString(s,"amount"),l=this.safeString(s,"filled_amount"),p=this.safeStringLower(s,"side"),m=this.safeStringLower(s,"type"),g=this.parseTimeInForce(this.safeString(s,"time_in_force")),y=this.safeNumber(s,"trigger_price"),b=this.safeValue(s,"is_post_only"),w=this.safeValue(e,"trades",[]);return this.safeOrder({id:i,clientOrderId:n,info:e,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,symbol:c,type:m,timeInForce:g,postOnly:b,side:p,price:u,stopPrice:y,amount:h,cost:void 0,average:void 0,filled:l,remaining:void 0,status:o,trades:w},t)}parseTimeInForce(e){const t={GOOD_TILL_CANCELLED:"GTC",GOOD_TILL_TIME:"GTT",IMMEDIATE_OR_CANCELLED:"IOC",FILL_OR_KILL:"FOK"};return this.safeString(t,e,e)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=t.toUpperCase(),d={instrument_code:a.id,type:o,side:s.toUpperCase(),amount:this.amountToPrecision(e,i)};let c=!1;if((o==="LIMIT"||o==="STOP")&&(c=!0),o==="STOP"){const l=this.safeNumber(r,"trigger_price");if(l===void 0)throw new Yi(this.id+" createOrder() requires a trigger_price param for "+t+" orders");d.trigger_price=this.priceToPrecision(e,l),r=this.omit(r,"trigger_price")}c&&(d.price=this.priceToPrecision(e,n));const u=this.safeString2(r,"clientOrderId","client_id");u!==void 0&&(d.client_id=u,r=this.omit(r,["clientOrderId","client_id"]));const h=await this.privatePostAccountOrders(this.extend(d,r));return this.parseOrder(h,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeString2(s,"clientOrderId","client_id");s=this.omit(s,["clientOrderId","client_id"]);let n="privateDeleteAccountOrdersOrderId";const r={};return i!==void 0?(n="privateDeleteAccountOrdersClientClientId",r.client_id=i):r.order_id=e,await this[n](this.extend(r,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};if(e!==void 0){const n=this.market(e);s.instrument_code=n.id}return await this.privateDeleteAccountOrders(this.extend(s,t))}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i={ids:e.join(",")};return await this.privateDeleteAccountOrders(this.extend(i,s))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privateGetAccountOrdersOrderId(this.extend(i,s));return this.parseOrder(n)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.market(e),n.instrument_code=r.id),t!==void 0){if(this.safeString(i,"to")===void 0)throw new Yi(this.id+' fetchOpenOrders() requires a "to" iso8601 string param with the since argument is specified, max range is 100 days');n.from=this.iso8601(t)}s!==void 0&&(n.max_page_size=s);const a=await this.privateGetAccountOrders(this.extend(n,i)),o=this.safeValue(a,"order_history",[]);return this.parseOrders(o,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={with_cancelled_and_rejected:!0};return await this.fetchOpenOrders(e,t,s,this.extend(n,i))}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={order_id:e};i!==void 0&&(r.max_page_size=i);const a=await this.privateGetAccountOrdersOrderIdTrades(this.extend(r,n)),o=this.safeValue(a,"trade_history",[]);let d;return t!==void 0&&(d=this.market(t)),this.parseTrades(o,d,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.market(e),n.instrument_code=r.id),t!==void 0){if(this.safeString(i,"to")===void 0)throw new Yi(this.id+' fetchMyTrades() requires a "to" iso8601 string param with the since argument is specified, max range is 100 days');n.from=this.iso8601(t)}s!==void 0&&(n.max_page_size=s);const a=await this.privateGetAccountTrades(this.extend(n,i)),o=this.safeValue(a,"trade_history",[]);return this.parseTrades(o,r,t,s)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));return t==="public"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):t==="private"&&(this.checkRequiredCredentials(),n={Accept:"application/json",Authorization:"Bearer "+this.apiKey},s==="POST"?(r=this.json(o),n["Content-Type"]="application/json"):Object.keys(o).length&&(a+="?"+this.urlencode(o))),{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"error");if(c!==void 0){const u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u),new zk(u)}}};const k6=ge,{ExchangeError:Va,ArgumentsRequired:zr,ExchangeNotAvailable:fc,InsufficientFunds:Hn,OrderNotFound:Zk,InvalidOrder:Kr,DDoSProtection:jm,InvalidNonce:S6,AuthenticationError:qa,RateLimitExceeded:Jk,PermissionDenied:Wm,BadRequest:us,BadSymbol:v6,AccountSuspended:T6,OrderImmediatelyFillable:zm,OnMaintenance:O6}=de,{TRUNCATE:eS,TICK_SIZE:I6}=me,tS=Se;var x6=class extends k6{describe(){return this.deepExtend(super.describe(),{id:"bitrue",name:"Bitrue",countries:["SG"],rateLimit:1e3,certified:!1,version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:void 0,future:void 0,option:!1,cancelAllOrders:!1,cancelOrder:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!1,fetchDeposits:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchPositionMode:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfers:!1,fetchWithdrawals:!0,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1H","2h":"2H","4h":"4H","1d":"1D","1w":"1W"},urls:{logo:"https://user-images.githubusercontent.com/1294454/139516488-243a830d-05dd-446b-91c6-c1f18fe30c63.jpg",api:{v1:"https://www.bitrue.com/api/v1",v2:"https://www.bitrue.com/api/v2",kline:"https://www.bitrue.com/kline-api"},www:"https://www.bitrue.com",referral:"https://www.bitrue.com/activity/task/task-landing?inviteCode=EZWETQE&cn=900000",doc:["https://github.com/Bitrue-exchange/bitrue-official-api-docs"],fees:"https://bitrue.zendesk.com/hc/en-001/articles/4405479952537"},api:{kline:{public:{get:{"public.json":1,"public{currency}.json":1}}},v1:{public:{get:{ping:1,time:1,exchangeInfo:1,depth:{cost:1,byLimit:[[100,1],[500,5],[1e3,10]]},trades:1,historicalTrades:5,aggTrades:1,"ticker/24hr":{cost:1,noSymbol:40},"ticker/price":{cost:1,noSymbol:2},"ticker/bookTicker":{cost:1,noSymbol:2},"market/kline":1}},private:{get:{order:1,openOrders:1,allOrders:5,account:5,myTrades:{cost:5,noSymbol:40},"etf/net-value/{symbol}":1,"withdraw/history":1,"deposit/history":1},post:{order:4,"withdraw/commit":1},delete:{order:1}}},v2:{private:{get:{myTrades:5}}}},fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,taker:this.parseNumber("0.00098"),maker:this.parseNumber("0.00098")},future:{trading:{feeSide:"quote",tierBased:!0,percentage:!0,taker:this.parseNumber("0.000400"),maker:this.parseNumber("0.000200"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.000400")],[this.parseNumber("250"),this.parseNumber("0.000400")],[this.parseNumber("2500"),this.parseNumber("0.000350")],[this.parseNumber("7500"),this.parseNumber("0.000320")],[this.parseNumber("22500"),this.parseNumber("0.000300")],[this.parseNumber("50000"),this.parseNumber("0.000270")],[this.parseNumber("100000"),this.parseNumber("0.000250")],[this.parseNumber("200000"),this.parseNumber("0.000220")],[this.parseNumber("400000"),this.parseNumber("0.000200")],[this.parseNumber("750000"),this.parseNumber("0.000170")]],maker:[[this.parseNumber("0"),this.parseNumber("0.000200")],[this.parseNumber("250"),this.parseNumber("0.000160")],[this.parseNumber("2500"),this.parseNumber("0.000140")],[this.parseNumber("7500"),this.parseNumber("0.000120")],[this.parseNumber("22500"),this.parseNumber("0.000100")],[this.parseNumber("50000"),this.parseNumber("0.000080")],[this.parseNumber("100000"),this.parseNumber("0.000060")],[this.parseNumber("200000"),this.parseNumber("0.000040")],[this.parseNumber("400000"),this.parseNumber("0.000020")],[this.parseNumber("750000"),this.parseNumber("0")]]}}},delivery:{trading:{feeSide:"base",tierBased:!0,percentage:!0,taker:this.parseNumber("0.000500"),maker:this.parseNumber("0.000100"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.000500")],[this.parseNumber("250"),this.parseNumber("0.000450")],[this.parseNumber("2500"),this.parseNumber("0.000400")],[this.parseNumber("7500"),this.parseNumber("0.000300")],[this.parseNumber("22500"),this.parseNumber("0.000250")],[this.parseNumber("50000"),this.parseNumber("0.000240")],[this.parseNumber("100000"),this.parseNumber("0.000240")],[this.parseNumber("200000"),this.parseNumber("0.000240")],[this.parseNumber("400000"),this.parseNumber("0.000240")],[this.parseNumber("750000"),this.parseNumber("0.000240")]],maker:[[this.parseNumber("0"),this.parseNumber("0.000100")],[this.parseNumber("250"),this.parseNumber("0.000080")],[this.parseNumber("2500"),this.parseNumber("0.000050")],[this.parseNumber("7500"),this.parseNumber("0.0000030")],[this.parseNumber("22500"),this.parseNumber("0")],[this.parseNumber("50000"),this.parseNumber("-0.000050")],[this.parseNumber("100000"),this.parseNumber("-0.000060")],[this.parseNumber("200000"),this.parseNumber("-0.000070")],[this.parseNumber("400000"),this.parseNumber("-0.000080")],[this.parseNumber("750000"),this.parseNumber("-0.000090")]]}}}},options:{fetchMyTradesMethod:"v2PrivateGetMyTrades",hasAlreadyAuthenticatedSuccessfully:!1,recvWindow:5*1e3,timeDifference:0,adjustForTimeDifference:!1,parseOrderToPrecision:!1,newOrderRespType:{market:"FULL",limit:"FULL"},networks:{ERC20:"ETH",TRC20:"TRX",TRON:"TRX"}},commonCurrencies:{MIM:"MIM Swarm"},precisionMode:I6,exceptions:{exact:{"System is under maintenance.":O6,"System abnormality":Va,"You are not authorized to execute this request.":Wm,"API key does not exist":qa,"Order would trigger immediately.":zm,"Stop price would trigger immediately.":zm,"Order would immediately match and take.":zm,"Account has insufficient balance for requested action.":Hn,"Rest API trading is not enabled.":fc,"You don't have permission.":Wm,"Market is closed.":fc,"Too many requests. Please try again later.":jm,"-1000":fc,"-1001":fc,"-1002":qa,"-1003":Jk,"-1013":Kr,"-1015":Jk,"-1016":fc,"-1020":us,"-1021":S6,"-1022":qa,"-1100":us,"-1101":us,"-1102":us,"-1103":us,"-1104":us,"-1105":us,"-1106":us,"-1111":us,"-1112":Kr,"-1114":us,"-1115":us,"-1116":us,"-1117":us,"-1118":us,"-1119":us,"-1120":us,"-1121":v6,"-1125":qa,"-1127":us,"-1128":us,"-1130":us,"-1131":us,"-2008":qa,"-2010":Va,"-2011":Zk,"-2013":Zk,"-2014":qa,"-2015":qa,"-2019":Hn,"-3005":Hn,"-3006":Hn,"-3008":Hn,"-3010":Va,"-3015":Va,"-3022":T6,"-4028":us,"-3020":Hn,"-3041":Hn,"-5013":Hn,"-11008":Hn,"-4051":Hn},broad:{"has no operation privilege":Wm,MAX_POSITION:Kr}}})}costToPrecision(e,t){return this.decimalToPrecision(t,eS,this.markets[e].precision.quote,this.precisionMode,this.paddingMode)}currencyToPrecision(e,t,s=void 0){return this.safeValue(this.currencies[e],"precision")!==void 0?this.decimalToPrecision(t,eS,this.currencies[e].precision,this.precisionMode,this.paddingMode):this.numberToString(t)}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchStatus(e={}){const t=await this.v1PublicGetPing(e);return{status:Object.keys(t).length?"maintenance":"ok",updated:void 0,eta:void 0,url:void 0,info:t}}async fetchTime(e={}){const t=await this.v1PublicGetTime(e);return this.safeInteger(t,"serverTime")}safeNetwork(e){const t=e.toUpperCase(),s={Aeternity:"Aeternity",AION:"AION",Algorand:"Algorand",ASK:"ASK",ATOM:"ATOM","AVAX C-Chain":"AVAX C-Chain",bch:"bch",BCH:"BCH",BEP2:"BEP2",BEP20:"BEP20",Bitcoin:"Bitcoin",BRP20:"BRP20",Cardano:"ADA",CasinoCoin:"CasinoCoin","CasinoCoin XRPL":"CasinoCoin XRPL",Contentos:"Contentos",Dash:"Dash",Decoin:"Decoin",DeFiChain:"DeFiChain",DGB:"DGB",Divi:"Divi",dogecoin:"DOGE",EOS:"EOS",ERC20:"ERC20",ETC:"ETC",Filecoin:"Filecoin",FREETON:"FREETON",HBAR:"HBAR","Hedera Hashgraph":"Hedera Hashgraph",HRC20:"HRC20",ICON:"ICON",ICP:"ICP",Ignis:"Ignis","Internet Computer":"Internet Computer",IOTA:"IOTA",KAVA:"KAVA",KSM:"KSM",LiteCoin:"LiteCoin",Luna:"Luna",MATIC:"MATIC","Mobile Coin":"Mobile Coin",MonaCoin:"MonaCoin",Monero:"Monero",NEM:"NEM",NEP5:"NEP5",OMNI:"OMNI",PAC:"PAC",Polkadot:"Polkadot",Ravencoin:"Ravencoin",Safex:"Safex",SOLANA:"SOL",Songbird:"Songbird","Stellar Lumens":"Stellar Lumens",Symbol:"Symbol",Tezos:"XTZ",theta:"theta",THETA:"THETA",TRC20:"TRC20",VeChain:"VeChain",VECHAIN:"VECHAIN",Wanchain:"Wanchain","XinFin Network":"XinFin Network",XRP:"XRP",XRPL:"XRPL",ZIL:"ZIL"};return this.safeString2(s,e,t,e)}async fetchCurrencies(e={}){const t=await this.v1PublicGetExchangeInfo(e),s={},i=this.safeValue(t,"coins",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"coin"),o=this.safeString(r,"coinFulName"),d=this.safeCurrencyCode(a),c=this.safeValue(r,"enableDeposit"),u=this.safeValue(r,"enableWithdraw"),h=this.safeValue(r,"chains",[]),l={};for(let m=0;m<h.length;m++){const g=h[m],y=this.safeNetwork(g);l[y]={info:g,id:g,network:y,active:void 0,fee:void 0,precision:void 0,limits:{withdraw:{min:void 0,max:void 0}}}}const p=u&&c;s[d]={id:a,name:o,code:d,precision:void 0,info:r,active:p,deposit:c,withdraw:u,networks:l,fee:this.safeNumber(r,"withdrawFee"),limits:{withdraw:{min:this.safeNumber(r,"minWithdraw"),max:this.safeNumber(r,"maxWithdraw")}}}}return s}async fetchMarkets(e={}){const t=await this.v1PublicGetExchangeInfo(e);this.options.adjustForTimeDifference&&await this.loadTimeDifference();const s=this.safeValue(t,"symbols",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeStringLower(r,"symbol"),d=this.safeString(r,"baseAsset"),c=this.safeString(r,"quoteAsset"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),l=this.safeValue(r,"filters",[]),p=this.indexBy(l,"filterType"),m=this.safeString(r,"status"),g=this.safeValue(p,"PRICE_FILTER",{}),y=this.safeValue(p,"LOT_SIZE",{}),b=this.safeString(r,"pricePrecision"),w=this.safeString(r,"quantityPrecision"),k=this.safeString(g,"priceScale",b),T=this.safeString(y,"volumeScale",w),O={id:a,lowercaseId:o,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:m==="TRADING",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(T)),price:this.parseNumber(this.parsePrecision(k)),base:this.parseNumber(this.parsePrecision(this.safeString(r,"baseAssetPrecision"))),quote:this.parseNumber(this.parsePrecision(this.safeString(r,"quotePrecision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(y,"minQty"),max:this.safeNumber(y,"maxQty")},price:{min:this.safeNumber(g,"minPrice"),max:this.safeNumber(g,"maxPrice")},cost:{min:this.safeNumber(y,"minVal"),max:void 0}},info:r};i.push(O)}return i}parseBalance(e){const t={info:e},s=this.safeInteger(e,"updateTime"),i=this.safeValue(e,"balances",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"asset"),o=this.safeCurrencyCode(a),d=this.account();d.free=this.safeString(r,"free"),d.used=this.safeString(r,"locked"),t[o]=d}return t.timestamp=s,t.datetime=this.iso8601(s),this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.v1PrivateGetAccount(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={symbol:this.market(e).id};t!==void 0&&(n.limit=t);const r=await this.v1PublicGetDepth(this.extend(n,s)),a=this.parseOrderBook(r,e);return a.nonce=this.safeInteger(r,"lastUpdateId"),a}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:void 0,datetime:void 0,high:this.safeString(e,"high24hr"),low:this.safeString(e,"low24hr"),bid:this.safeString(e,"highestBid"),bidVolume:void 0,ask:this.safeString(e,"lowestAsk"),askVolume:void 0,vwap:void 0,open:void 0,close:i,last:i,previousClose:void 0,change:void 0,percentage:this.safeString(e,"percentChange"),average:void 0,baseVolume:this.safeString(e,"baseVolume"),quoteVolume:this.safeString(e,"quoteVolume"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=this.safeStringUpper(s,"baseId"),n=this.safeStringUpper(s,"quoteId"),r={currency:n,command:"returnTicker"},a=await this.klinePublicGetPublicCurrencyJson(this.extend(r,t)),o=this.safeValue(a,"data",{}),d=i+"_"+n,c=this.safeValue(o,d);if(c===void 0)throw new Va(this.id+" fetchTicker() could not find the ticker for "+s.symbol);return this.parseTicker(c,s)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,scale:this.timeframes[t]};i!==void 0&&(a.limit=i);const o=await this.v1PublicGetMarketKline(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseOHLCVs(d,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"i"),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}async fetchBidsAsks(e=void 0,t={}){await this.loadMarkets();const s=this.safeString2(this.options,"fetchBidsAsks","defaultType","spot"),i=this.safeString(t,"type",s),n=this.omit(t,"type");let r;i==="future"?r="fapiPublicGetTickerBookTicker":i==="delivery"?r="dapiPublicGetTickerBookTicker":r="publicGetTickerBookTicker";const a=await this[r](n);return this.parseTickers(a,e)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={command:"returnTicker"},i=await this.klinePublicGetPublicJson(this.extend(s,t)),n=this.safeValue(i,"data",{}),r={},a=Object.keys(n);for(let o=0;o<a.length;o++){const d=a[o].replace("_","");r[d]=n[a[o]]}return this.parseTickers(r,e)}parseTrade(e,t=void 0){const s=this.safeInteger2(e,"T","time"),i=this.safeString2(e,"p","price"),n=this.safeString2(e,"q","qty"),r=this.safeString(e,"symbol"),a=this.safeSymbol(r,t);let o=this.safeString2(e,"t","a");o=this.safeString2(e,"id","tradeId",o);let d;const c=this.safeString(e,"orderId");"m"in e?d=e.m?"sell":"buy":"isBuyerMaker"in e?d=e.isBuyerMaker?"sell":"buy":"side"in e?d=this.safeStringLower(e,"side"):"isBuyer"in e&&(d=e.isBuyer?"buy":"sell");let u;"commission"in e&&(u={cost:this.safeString(e,"commission"),currency:this.safeCurrencyCode(this.safeString(e,"commissionAssert"))});let h;return"isMaker"in e&&(h=e.isMaker?"maker":"taker"),"maker"in e&&(h=e.maker?"maker":"taker"),this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:a,id:o,order:c,type:void 0,side:d,takerOrMaker:h,price:i,amount:n,cost:void 0,fee:u},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=this.safeString(this.options,"fetchTradesMethod","v1PublicGetAggTrades");s!==void 0&&(r.limit=s);const o=await this[a](this.extend(r,i));return this.parseTrades(o,n,t,s)}parseOrderStatus(e){const t={NEW:"open",PARTIALLY_FILLED:"open",FILLED:"closed",CANCELED:"canceled",PENDING_CANCEL:"canceling",REJECTED:"rejected",EXPIRED:"expired"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString(e,"status")),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.safeString(e,"executedQty");let a,o;"time"in e?a=this.safeInteger(e,"time"):"transactTime"in e?a=this.safeInteger(e,"transactTime"):"updateTime"in e&&s==="open"&&(tS.stringGt(r,"0")?o=this.safeInteger(e,"updateTime"):a=this.safeInteger(e,"updateTime"));const d=this.safeString(e,"avgPrice"),c=this.safeString(e,"price"),u=this.safeString(e,"origQty"),h=this.safeString2(e,"cummulativeQuoteQty","cumQuote"),l=this.safeString(e,"orderId");let p=this.safeStringLower(e,"type");const m=this.safeStringLower(e,"side"),g=this.safeValue(e,"fills",[]),y=this.safeString(e,"clientOrderId"),b=this.safeString(e,"timeInForce"),w=p==="limit_maker"||b==="GTX";p==="limit_maker"&&(p="limit");const k=this.safeString(e,"stopPrice"),T=this.parseNumber(this.omitZero(k));return this.safeOrder({info:e,id:l,clientOrderId:y,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:o,symbol:n,type:p,timeInForce:b,postOnly:w,side:m,price:c,stopPrice:T,amount:u,cost:h,average:d,filled:r,remaining:void 0,status:s,fee:void 0,trades:g},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=t.toUpperCase(),d=this.safeValue(a.info,"orderTypes");if(!this.inArray(o,d))throw new Kr(this.id+" "+t+" is not a valid order type in market "+e);const c={symbol:a.id,side:s.toUpperCase(),type:o,quantity:this.amountToPrecision(e,i)},u=this.safeString2(r,"newClientOrderId","clientOrderId");if(u!==void 0&&(r=this.omit(r,["newClientOrderId","clientOrderId"]),c.newClientOrderId=u),o==="LIMIT"){if(n===void 0)throw new Kr(this.id+" createOrder() requires a price argument");c.price=this.priceToPrecision(e,n)}const h=this.safeValue2(r,"triggerPrice","stopPrice");h!==void 0&&(r=this.omit(r,["triggerPrice","stopPrice"]),c.stopPrice=this.priceToPrecision(e,h));const l=await this.v1PrivatePostOrder(this.extend(c,r));return this.parseOrder(l,a)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new zr(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={symbol:i.id},r=this.safeValue2(s,"origClientOrderId","clientOrderId");r!==void 0?n.origClientOrderId=r:n.orderId=e;const a=this.omit(s,["type","clientOrderId","origClientOrderId"]),o=await this.v1PrivateGetOrder(this.extend(n,a));return this.parseOrder(o,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new zr(this.id+" fetchClosedOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=s);const a=await this.v1PrivateGetAllOrders(this.extend(r,i));return this.parseOrders(a,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new zr(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.v1PrivateGetOpenOrders(this.extend(r,i));return this.parseOrders(a,n,t,s)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new zr(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=this.safeValue2(s,"origClientOrderId","clientOrderId"),r={symbol:i.id};n===void 0?r.orderId=e:r.origClientOrderId=n;const a=this.omit(s,["type","origClientOrderId","clientOrderId"]),o=await this.v1PrivateDeleteOrder(this.extend(r,a));return this.parseOrder(o,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeString(this.options,"fetchMyTradesMethod","v2PrivateGetMyTrades");if(e===void 0&&n==="v2PrivateGetMyTrades")throw new zr(this.id+" v2PrivateGetMyTrades() requires a symbol argument");await this.loadMarkets();const r={};let a;e!==void 0&&(a=this.market(e),r.symbol=a.id),t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=s);const o=await this[n](this.extend(r,i));return this.parseTrades(o,a,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new zr(this.id+" fetchDeposits() requires a code argument");await this.loadMarkets();const n=this.currency(e),r={coin:n.id,status:1};t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=s);const a=await this.v1PrivateGetDepositHistory(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new zr(this.id+" fetchWithdrawals() requires a code argument");await this.loadMarkets();const n=this.currency(e),r={coin:n.id,status:5};t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=s);const a=await this.v1PrivateGetWithdrawHistory(this.extend(r,i)),o=this.safeValue(a,"data",{});return this.parseTransactions(o,n)}parseTransactionStatusByType(e,t=void 0){const s={deposit:{0:"pending",1:"ok"},withdrawal:{0:"pending",5:"ok",6:"canceled"}},i=this.safeValue(s,t,{});return this.safeString(i,e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"id","withdrawId"),i=this.safeString(e,"tagType");let n=this.safeString(e,"addressTo"),r=this.safeString(e,"addressFrom"),a,o;if(i!==void 0){if(n!==void 0){const O=n.split("_");n=this.safeString(O,0),a=this.safeString(O,1)}if(r!==void 0){const O=r.split("_");r=this.safeString(O,0),o=this.safeString(O,1)}}const d=this.safeString(e,"txid"),c=this.safeInteger(e,"createdAt"),u=this.safeInteger(e,"updatedAt"),h="payAmount"in e,l="ctime"in e,p=h||l?"withdrawal":"deposit",m=this.parseTransactionStatusByType(this.safeString(e,"status"),p),g=this.safeNumber(e,"amount");let y,b=this.safeString2(e,"symbol","coin");if(b!==void 0){const O=b.split("_");b=this.safeString(O,0);const x=this.safeString(O,1);x!==void 0&&(y=x.toUpperCase())}const w=this.safeCurrencyCode(b,t),k=this.safeNumber(e,"fee");let T;return k!==void 0&&(T={currency:w,cost:k}),{info:e,id:s,txid:d,timestamp:c,datetime:this.iso8601(c),network:y,address:n,addressTo:n,addressFrom:r,tag:a,tagTo:a,tagFrom:o,type:p,amount:g,currency:w,status:m,updated:u,internal:!1,fee:T}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e);let a=this.safeString(n,"chainName");if(a===void 0){const u=this.safeValue(r,"networks",{}),h=this.safeValue(this.options,"networks",{});let l=this.safeStringUpper(n,"network");l=this.safeString(h,l,l);const p=this.safeValue(u,l,{});if(a=this.safeString(p,"id"),a===void 0)throw new zr(this.id+" withdraw() requires a network parameter or a chainName parameter");n=this.omit(n,"network")}const o={coin:r.id.toUpperCase(),amount:t,addressTo:s,chainName:a};i!==void 0&&(o.tag=i);const d=await this.v1PrivatePostWithdrawCommit(this.extend(o,n)),c=this.safeValue(d,"data");return this.parseTransaction(c,r)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const[a,o]=t;let d=this.urls.api[a]+"/"+this.implodeParams(e,i);if(i=this.omit(i,this.extractParams(e)),o==="private"){this.checkRequiredCredentials();const c=this.safeInteger(this.options,"recvWindow",5e3);let u=this.urlencode(this.extend({timestamp:this.nonce(),recvWindow:c},i));const h=this.hmac(this.encode(u),this.encode(this.secret));u+="&signature="+h,n={"X-MBX-APIKEY":this.apiKey},s==="GET"||s==="DELETE"?d+="?"+u:(r=u,n["Content-Type"]="application/x-www-form-urlencoded")}else Object.keys(i).length&&(d+="?"+this.urlencode(i));return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(e===418||e===429)throw new jm(this.id+" "+e.toString()+" "+t+" "+r);if(e>=400){if(r.indexOf("Price * QTY is zero or less")>=0)throw new Kr(this.id+" order cost = amount * price is zero or less "+r);if(r.indexOf("LOT_SIZE")>=0)throw new Kr(this.id+" order amount should be evenly divisible by lot size "+r);if(r.indexOf("PRICE_FILTER")>=0)throw new Kr(this.id+" order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid float value in general, use this.priceToPrecision (symbol, amount) "+r)}if(a===void 0)return;const c=this.safeValue(a,"success",!0);if(!c){const l=this.safeString(a,"msg");let p;if(l!==void 0){try{p=JSON.parse(l)}catch{p=void 0}p!==void 0&&(a=p)}}const u=this.safeString(a,"msg");u!==void 0&&(this.throwExactlyMatchedException(this.exceptions.exact,u,this.id+" "+u),this.throwBroadlyMatchedException(this.exceptions.broad,u,this.id+" "+u));const h=this.safeString(a,"code");if(h!==void 0){if(h==="200"||tS.stringEquals(h,"0"))return;if(h==="-2015"&&this.options.hasAlreadyAuthenticatedSuccessfully)throw new jm(this.id+" temporary banned: "+r);const l=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,h,l),new Va(l)}if(!c)throw new Va(this.id+" "+r)}calculateRateLimiterCost(e,t,s,i,n={},r={}){if("noSymbol"in n&&!("symbol"in i))return n.noSymbol;if("byLimit"in n&&"limit"in i){const a=i.limit,o=n.byLimit;for(let d=0;d<o.length;d++){const c=o[d];if(a<=c[0])return c[1]}}return this.safeValue(n,"cost",1)}};const _6=ge,{ExchangeError:hc,InvalidNonce:C6,AuthenticationError:M6,OrderNotFound:P6,NotSupported:A6,BadRequest:B6,ArgumentsRequired:E6}=de,{TICK_SIZE:N6}=me,Eo=Se;var V6=class extends _6{describe(){return this.deepExtend(super.describe(),{id:"bitso",name:"Bitso",countries:["MX"],rateLimit:2e3,version:"v3",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createDepositAddress:!1,createOrder:!0,createReduceOnlyOrder:!1,fetchAccounts:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchDeposit:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!1,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFee:!1,fetchTransactionFees:!0,fetchTransactions:!1,fetchTransfer:!1,fetchTransfers:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/51840849/87295554-11f98280-c50e-11ea-80d6-15b3bafa8cbf.jpg",api:{rest:"https://api.bitso.com"},www:"https://bitso.com",doc:"https://bitso.com/api_info",fees:"https://bitso.com/fees",referral:"https://bitso.com/?ref=itej"},precisionMode:N6,options:{precision:{XRP:1e-6,MXN:.01,TUSD:.01},defaultPrecision:1e-8},timeframes:{"1m":"60","5m":"300","15m":"900","30m":"1800","1h":"3600","4h":"14400","12h":"43200","1d":"86400","1w":"604800"},api:{public:{get:["available_books","ticker","order_book","trades","ohlc"]},private:{get:["account_status","balance","fees","fundings","fundings/{fid}","funding_destination","kyc_documents","ledger","ledger/trades","ledger/fees","ledger/fundings","ledger/withdrawals","mx_bank_codes","open_orders","order_trades/{oid}","orders/{oid}","user_trades","user_trades/{tid}","withdrawals/","withdrawals/{wid}"],post:["bitcoin_withdrawal","debit_card_withdrawal","ether_withdrawal","ripple_withdrawal","bcash_withdrawal","litecoin_withdrawal","orders","phone_number","phone_verification","phone_withdrawal","spei_withdrawal","ripple_withdrawal","bcash_withdrawal","litecoin_withdrawal"],delete:["orders","orders/{oid}","orders/all"]}},exceptions:{"0201":M6,104:C6,"0304":B6}})}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){const n={};s!==void 0&&(n.limit=s);const r=await this.privateGetLedger(this.extend(n,i)),a=this.safeValue(r,"payload",[]);return this.parseLedger(a,e,t,s)}parseLedgerEntryType(e){const t={funding:"transaction",withdrawal:"transaction",trade:"trade",fee:"fee"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"operation"),i=this.parseLedgerEntryType(s),n=this.safeValue(e,"balance_updates",[]),r=this.safeValue(n,0,{});let a,o;const d=this.safeString(r,"amount"),c=this.safeString(r,"currency"),u=this.safeCurrencyCode(c,t),h=this.safeValue(e,"details",{});let l=this.safeString2(h,"fid","wid");l===void 0&&(l=this.safeString(h,"tid")),s==="funding"?a="in":s==="withdrawal"?a="out":s==="trade"?a=void 0:s==="fee"&&(a="out",o={cost:Eo.stringAbs(d),currency:t});const p=this.parse8601(this.safeString(e,"created_at"));return this.safeLedgerEntry({id:this.safeString(e,"eid"),direction:a,account:void 0,referenceId:l,referenceAccount:void 0,type:i,currency:u,amount:d,timestamp:p,datetime:this.iso8601(p),before:void 0,after:void 0,status:"ok",fee:o,info:e},t)}async fetchMarkets(e={}){const t=await this.publicGetAvailableBooks(e),s=this.safeValue(t,"payload",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"book"),[o,d]=a.split("_");let c=o.toUpperCase(),u=d.toUpperCase();c=this.safeCurrencyCode(c),u=this.safeCurrencyCode(u);const h=this.safeValue(r,"fees",{}),l=this.safeValue(h,"flat_rate",{}),p=this.safeString(l,"taker"),m=this.safeString(l,"maker"),g=this.parseNumber(Eo.stringDiv(p,"100")),y=this.parseNumber(Eo.stringDiv(m,"100")),b=this.safeValue(h,"structure",[]),w={taker:g,maker:y,percentage:!0,tierBased:!0},k=[],T=[];for(let C=0;C<b.length;C++){const E=b[C],P=this.safeNumber(E,"volume"),_=this.safeNumber(E,"taker"),S=this.safeNumber(E,"maker");k.push([P,_]),T.push([P,S]),C===0&&(w.taker=_,w.maker=S)}const O={taker:k,maker:T};w.tiers=O;const x=this.safeNumber(this.options.precision,u,this.options.defaultPrecision);i.push(this.extend({id:a,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,taker:g,maker:y,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(this.options.precision,c,this.options.defaultPrecision),price:this.safeNumber(r,"tick_size",x)},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"minimum_amount"),max:this.safeNumber(r,"maximum_amount")},price:{min:this.safeNumber(r,"minimum_price"),max:this.safeNumber(r,"maximum_price")},cost:{min:this.safeNumber(r,"minimum_value"),max:this.safeNumber(r,"maximum_value")}},info:r},w))}return i}parseBalance(e){const t=this.safeValue(e,"payload",{}),s=this.safeValue(t,"balances",[]),i={info:e,timestamp:void 0,datetime:void 0};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.account();d.free=this.safeString(r,"available"),d.used=this.safeString(r,"locked"),d.total=this.safeString(r,"total"),i[o]=d}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={book:i.id},r=await this.publicGetOrderBook(this.extend(n,s)),a=this.safeValue(r,"payload"),o=this.parse8601(this.safeString(a,"updated_at"));return this.parseOrderBook(a,i.symbol,o,"bids","asks","price","amount")}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.parse8601(this.safeString(e,"created_at")),n=this.safeString(e,"vwap"),r=this.safeString(e,"volume"),a=Eo.stringMul(r,n),o=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:n,open:void 0,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:a,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={book:s.id},n=await this.publicGetTicker(this.extend(i,t)),r=this.safeValue(n,"payload");return this.parseTicker(r,s)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={book:r.id,time_bucket:this.timeframes[t]};if(s!==void 0){if(a.start=s,i!==void 0){const c=this.parseTimeframe(t);a.end=this.sum(s,c*i*1e3)}}else if(i!==void 0){const c=this.milliseconds();a.end=c,a.start=c-this.parseTimeframe(t)*1e3*i}const o=await this.publicGetOhlc(this.extend(a,n)),d=this.safeValue(o,"payload",[]);return this.parseOHLCVs(d,r,t,s,i)}parseOHLCV(e,t=void 0,s="1m"){return[this.safeInteger(e,"bucket_start_time"),this.safeNumber(e,"first_rate"),this.safeNumber(e,"max_rate"),this.safeNumber(e,"min_rate"),this.safeNumber(e,"last_rate"),this.safeNumber(e,"volume")]}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"created_at")),i=this.safeString(e,"book"),n=this.safeSymbol(i,t,"_"),r=this.safeString2(e,"side","maker_side"),a=this.safeString(e,"maker_side");let o;r===a?o="maker":o="taker";let d=this.safeString2(e,"amount","major");d!==void 0&&(d=Eo.stringAbs(d));let c;const u=this.safeString(e,"fees_amount");if(u!==void 0){const g=this.safeString(e,"fees_currency"),y=this.safeCurrencyCode(g);c={cost:u,currency:y}}let h=this.safeString(e,"minor");h!==void 0&&(h=Eo.stringAbs(h));const l=this.safeString(e,"price"),p=this.safeString(e,"oid"),m=this.safeString(e,"tid");return this.safeTrade({id:m,info:e,timestamp:s,datetime:this.iso8601(s),symbol:n,order:p,type:void 0,side:r,takerOrMaker:o,price:l,amount:d,cost:h,fee:c},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={book:n.id},a=await this.publicGetTrades(this.extend(r,i));return this.parseTrades(a.payload,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetFees(e),s=this.safeValue(t,"payload",{}),i=this.safeValue(s,"fees",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"book"),d=this.safeSymbol(o,void 0,"_");n[d]={info:a,symbol:d,maker:this.safeNumber(a,"maker_fee_decimal"),taker:this.safeNumber(a,"taker_fee_decimal"),percentage:!0,tierBased:!0}}return n}async fetchMyTrades(e=void 0,t=void 0,s=25,i={}){await this.loadMarkets();const n=this.market(e),r="marker"in i;if(t!==void 0&&!r)throw new hc(this.id+" fetchMyTrades() does not support fetching trades starting from a timestamp with the `since` argument, use the `marker` extra param to filter starting from an integer trade id");r&&(i=this.extend(i,{marker:parseInt(i.marker)}));const a={book:n.id,limit:s},o=await this.privateGetUserTrades(this.extend(a,i));return this.parseTrades(o.payload,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={book:a.id,side:s,type:t,major:this.amountToPrecision(a.symbol,i)};t==="limit"&&(o.price=this.priceToPrecision(a.symbol,n));const d=await this.privatePostOrders(this.extend(o,r)),c=this.safeString(d.payload,"oid");return{info:d,id:c}}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={oid:e};return await this.privateDeleteOrdersOid(this.extend(i,s))}async cancelOrders(e,t=void 0,s={}){if(!Array.isArray(e))throw new E6(this.id+" cancelOrders() ids argument should be an array");let i;t!==void 0&&(i=this.market(t));const r={oids:e.join(",")},a=await this.privateDeleteOrders(this.extend(r,s)),o=this.safeValue(a,"payload",[]),d=[];for(let c=0;c<o.length;c++){const u=o[c];d.push(this.parseOrder(u,i))}return d}async cancelAllOrders(e=void 0,t={}){if(e!==void 0)throw new A6(this.id+" cancelAllOrders() deletes all orders for user, it does not support filtering by symbol.");const s=await this.privateDeleteOrdersAll(t),i=this.safeValue(s,"payload",[]),n=[];for(let r=0;r<i.length;r++){const a=this.parseOrder(i[r]);n.push(a)}return n}parseOrderStatus(e){const t={"partial-fill":"open",completed:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){let s;typeof e=="string"?s=e:s=this.safeString(e,"oid");const i=this.safeString(e,"side"),n=this.parseOrderStatus(this.safeString(e,"status")),r=this.safeString(e,"book"),a=this.safeSymbol(r,t,"_"),o=this.safeString(e,"type"),d=this.parse8601(this.safeString(e,"created_at")),c=this.safeString(e,"price"),u=this.safeString(e,"original_amount"),h=this.safeString(e,"unfilled_amount"),l=this.safeString(e,"client_id");return this.safeOrder({info:e,id:s,clientOrderId:l,timestamp:d,datetime:this.iso8601(d),lastTradeTimestamp:void 0,symbol:a,type:o,timeInForce:void 0,postOnly:void 0,side:i,price:c,stopPrice:void 0,amount:u,cost:void 0,remaining:h,filled:void 0,status:n,fee:void 0,average:void 0,trades:void 0},t)}async fetchOpenOrders(e=void 0,t=void 0,s=25,i={}){await this.loadMarkets();const n=this.market(e),r="marker"in i;if(t!==void 0&&!r)throw new hc(this.id+" fetchOpenOrders() does not support fetching orders starting from a timestamp with the `since` argument, use the `marker` extra param to filter starting from an integer trade id");r&&(i=this.extend(i,{marker:parseInt(i.marker)}));const a={book:n.id,limit:s},o=await this.privateGetOpenOrders(this.extend(a,i));return this.parseOrders(o.payload,n,t,s)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=await this.privateGetOrdersOid({oid:e}),n=this.safeValue(i,"payload");if(Array.isArray(n)&&i.payload.length===1)return this.parseOrder(n[0]);throw new P6(this.id+": The order "+e+" not found.")}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(t),a={oid:e},o=await this.privateGetOrderTradesOid(this.extend(a,n));return this.parseTrades(o.payload,r)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const i={fid:e},n=await this.privateGetFundingsFid(this.extend(i,s)),r=this.safeValue(n,"payload",[]),a=this.safeValue(r,0,{});return this.parseTransaction(a)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r=await this.privateGetFundings(i),a=this.safeValue(r,"payload",[]);return this.parseTransactions(a,n,t,s,i)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={fund_currency:this.currency(e).id},n=await this.privateGetFundingDestination(this.extend(i,t));let r=this.safeString(n.payload,"account_identifier"),a;if(r.indexOf("?dt=")>=0){const o=r.split("?dt=");r=this.safeString(o,0),a=this.safeString(o,1)}return this.checkAddress(r),{currency:e,address:r,tag:a,network:void 0,info:n}}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetFees(t),i={},n=this.safeValue(s,"payload",{}),r=this.safeValue(n,"deposit_fees",[]);for(let d=0;d<r.length;d++){const c=r[d],u=this.safeString(c,"currency"),h=this.safeCurrencyCode(u);e!==void 0&&!this.inArray(h,e)||(i[h]={deposit:this.safeNumber(c,"fee"),withdraw:void 0,info:{deposit:c,withdraw:void 0}})}const a=this.safeValue(n,"withdrawal_fees",[]),o=Object.keys(a);for(let d=0;d<o.length;d++){const c=o[d],u=this.safeCurrencyCode(c);e!==void 0&&!this.inArray(u,e)||(i[u]={deposit:this.safeValue(i[u],"deposit"),withdraw:this.safeNumber(a,c),info:{deposit:this.safeValue(i[u].info,"deposit"),withdraw:this.safeNumber(a,c)}})}return i}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r={BTC:"Bitcoin",ETH:"Ether",XRP:"Ripple",BCH:"Bcash",LTC:"Litecoin"},a=this.currency(e),o=e in r?r[e]:void 0;if(o===void 0)throw new hc(this.id+" not valid withdraw coin: "+e);const d={amount:t,address:s,destination_tag:i},c="privatePost"+o+"Withdrawal",u=await this[c](this.extend(d,n)),h=this.safeValue(u,"payload",[]),l=this.safeValue(h,0);return this.parseTransaction(l,a)}safeNetwork(e){if(e===void 0)return;e=e.toUpperCase();const t={trx:"TRC20",erc20:"ERC20",bsc:"BEP20",bep2:"BEP2"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"currency","asset");t=this.safeCurrency(s,t);const i=this.safeValue(e,"details",{}),n=this.safeString(e,"created_at"),r=this.safeString(i,"withdrawal_address"),a=this.safeString(i,"receiving_address"),o=this.safeString2(e,"network","method"),d=this.safeString(e,"status"),c=this.safeString(e,"wid");return{id:this.safeString2(e,"wid","fid"),txid:this.safeString(i,"tx_hash"),timestamp:this.parse8601(n),datetime:n,network:this.safeNetwork(o),addressFrom:a,address:r!==void 0?r:a,addressTo:r,amount:this.safeString(e,"amount"),type:c===void 0?"deposit":"withdrawal",currency:this.safeCurrencyCode(s,t),status:this.parseTransactionStatus(d),updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0,info:e}}parseTransactionStatus(e){const t={pending:"pending",in_progress:"pending",complete:"ok",failed:"failed"};return this.safeString(t,e,e)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));(s==="GET"||s==="DELETE")&&Object.keys(o).length&&(a+="?"+this.urlencode(o));const d=this.urls.api.rest+a;if(t==="private"){this.checkRequiredCredentials();const c=this.nonce().toString();let u=[c,s,a].join("");s!=="GET"&&s!=="DELETE"&&Object.keys(o).length&&(r=this.json(o),u+=r);const h=this.hmac(this.encode(u),this.encode(this.secret));n={Authorization:"Bitso "+(this.apiKey+":"+c+":"+h),"Content-Type":"application/json"}}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&"success"in a){let c=this.safeValue(a,"success",!1);if(typeof c=="string"&&(c==="true"||c==="1"?c=!0:c=!1),!c){const u=this.id+" "+this.json(a),h=this.safeValue(a,"error");if(h===void 0)throw new hc(u);const l=this.safeString(h,"code");throw this.throwExactlyMatchedException(this.exceptions,l,u),new hc(u)}}}};const q6=ge,{AuthenticationError:No,BadRequest:L6,ExchangeError:sS,NotSupported:R6,PermissionDenied:Of,InvalidNonce:F6,OrderNotFound:D6,InsufficientFunds:H6,InvalidAddress:G6,InvalidOrder:Km,OnMaintenance:U6,ExchangeNotAvailable:$6}=de,{TICK_SIZE:j6}=me,Xr=Se;var D_=class extends q6{describe(){return this.deepExtend(super.describe(),{id:"bitstamp",name:"Bitstamp",countries:["GB"],rateLimit:75,version:"v2",userAgent:this.userAgents.chrome,pro:!0,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransactionFees:!0,fetchTransactions:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27786377-8c8ab57e-5fe9-11e7-8ea4-2b05b6bcceec.jpg",api:{public:"https://www.bitstamp.net/api",private:"https://www.bitstamp.net/api"},www:"https://www.bitstamp.net",doc:"https://www.bitstamp.net/api"},timeframes:{"1m":"60","3m":"180","5m":"300","15m":"900","30m":"1800","1h":"3600","2h":"7200","4h":"14400","6h":"21600","12h":"43200","1d":"86400","1w":"259200"},requiredCredentials:{apiKey:!0,secret:!0},api:{public:{get:{"ohlc/{pair}/":1,"order_book/{pair}/":1,"ticker_hour/{pair}/":1,"ticker/{pair}/":1,"transactions/{pair}/":1,"trading-pairs-info/":1}},private:{post:{"balance/":1,"balance/{pair}/":1,"bch_withdrawal/":1,"bch_address/":1,"user_transactions/":1,"user_transactions/{pair}/":1,"open_orders/all/":1,"open_orders/{pair}/":1,"order_status/":1,"cancel_order/":1,"cancel_all_orders/":1,"cancel_all_orders/{pair}/":1,"buy/{pair}/":1,"buy/market/{pair}/":1,"buy/instant/{pair}/":1,"sell/{pair}/":1,"sell/market/{pair}/":1,"sell/instant/{pair}/":1,"transfer-to-main/":1,"transfer-from-main/":1,"withdrawal-requests/":1,"withdrawal/open/":1,"withdrawal/status/":1,"withdrawal/cancel/":1,"liquidation_address/new/":1,"liquidation_address/info/":1,"btc_unconfirmed/":1,"websockets_token/":1,"btc_withdrawal/":1,"btc_address/":1,"ripple_withdrawal/":1,"ripple_address/":1,"ltc_withdrawal/":1,"ltc_address/":1,"eth_withdrawal/":1,"eth_address/":1,"xrp_withdrawal/":1,"xrp_address/":1,"xlm_withdrawal/":1,"xlm_address/":1,"pax_withdrawal/":1,"pax_address/":1,"link_withdrawal/":1,"link_address/":1,"usdc_withdrawal/":1,"usdc_address/":1,"omg_withdrawal/":1,"omg_address/":1,"dai_withdrawal/":1,"dai_address/":1,"knc_withdrawal/":1,"knc_address/":1,"mkr_withdrawal/":1,"mkr_address/":1,"zrx_withdrawal/":1,"zrx_address/":1,"gusd_withdrawal/":1,"gusd_address/":1,"aave_withdrawal/":1,"aave_address/":1,"bat_withdrawal/":1,"bat_address/":1,"uma_withdrawal/":1,"uma_address/":1,"snx_withdrawal/":1,"snx_address/":1,"uni_withdrawal/":1,"uni_address/":1,"yfi_withdrawal/":1,yfi_address:1,"audio_withdrawal/":1,"audio_address/":1,"crv_withdrawal/":1,"crv_address/":1,"algo_withdrawal/":1,"algo_address/":1,"comp_withdrawal/":1,"comp_address/":1,grt_withdrawal:1,"grt_address/":1,"usdt_withdrawal/":1,"usdt_address/":1,"eurt_withdrawal/":1,"eurt_address/":1,"matic_withdrawal/":1,"matic_address/":1,"sushi_withdrawal/":1,"sushi_address/":1,"chz_withdrawal/":1,"chz_address/":1,"enj_withdrawal/":1,"enj_address/":1,"alpha_withdrawal/":1,"alpha_address/":1,"ftt_withdrawal/":1,"ftt_address/":1,"storj_withdrawal/":1,"storj_address/":1,"axs_withdrawal/":1,"axs_address/":1,"sand_withdrawal/":1,"sand_address/":1,"hbar_withdrawal/":1,"hbar_address/":1,"rgt_withdrawal/":1,"rgt_address/":1,"fet_withdrawal/":1,"fet_address/":1,"skl_withdrawal/":1,"skl_address/":1,"cel_withdrawal/":1,"cel_address/":1,"sxp_withdrawal/":1,"sxp_address/":1,"ada_withdrawal/":1,"ada_address/":1,"slp_withdrawal/":1,"slp_address/":1,"ftm_withdrawal/":1,"ftm_address/":1,"perp_withdrawal/":1,"perp_address/":1,"dydx_withdrawal/":1,"dydx_address/":1,"gala_withdrawal/":1,"gala_address/":1,"shib_withdrawal/":1,"shib_address/":1,"amp_withdrawal/":1,"amp_address/":1,"sgb_withdrawal/":1,"sgb_address/":1,"avax_withdrawal/":1,"avax_address/":1,"wbtc_withdrawal/":1,"wbtc_address/":1,"ctsi_withdrawal/":1,"ctsi_address/":1,"cvx_withdrawal/":1,"cvx_address/":1,"imx_withdrawal/":1,"imx_address/":1,"nexo_withdrawal/":1,"nexo_address/":1,"ust_withdrawal/":1,"ust_address/":1,"ant_withdrawal/":1,"ant_address/":1,"gods_withdrawal/":1,"gods_address/":1,"rad_withdrawal/":1,"rad_address/":1,"band_withdrawal/":1,"band_address/":1,"inj_withdrawal/":1,"inj_address/":1,"rly_withdrawal/":1,"rly_address/":1,"rndr_withdrawal/":1,"rndr_address/":1,"vega_withdrawal/":1,"vega_address/":1,"1inch_withdrawal/":1,"1inch_address/":1,"ens_withdrawal/":1,"ens_address/":1,"mana_withdrawal/":1,"mana_address/":1,"lrc_withdrawal/":1,"lrc_address/":1,"ape_withdrawal/":1,"ape_address/":1,"mpl_withdrawal/":1,"mpl_address/":1,"euroc_withdrawal/":1,"euroc_address/":1,"sol_withdrawal/":1,"sol_address/":1,"dot_withdrawal/":1,"dot_address/":1,"near_withdrawal/":1,"near_address/":1}}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.005"),maker:this.parseNumber("0.005"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.005")],[this.parseNumber("20000"),this.parseNumber("0.0025")],[this.parseNumber("100000"),this.parseNumber("0.0024")],[this.parseNumber("200000"),this.parseNumber("0.0022")],[this.parseNumber("400000"),this.parseNumber("0.0020")],[this.parseNumber("600000"),this.parseNumber("0.0015")],[this.parseNumber("1000000"),this.parseNumber("0.0014")],[this.parseNumber("2000000"),this.parseNumber("0.0013")],[this.parseNumber("4000000"),this.parseNumber("0.0012")],[this.parseNumber("20000000"),this.parseNumber("0.0011")],[this.parseNumber("50000000"),this.parseNumber("0.0010")],[this.parseNumber("100000000"),this.parseNumber("0.0007")],[this.parseNumber("500000000"),this.parseNumber("0.0005")],[this.parseNumber("2000000000"),this.parseNumber("0.0003")],[this.parseNumber("6000000000"),this.parseNumber("0.0001")],[this.parseNumber("20000000000"),this.parseNumber("0.00005")],[this.parseNumber("20000000001"),this.parseNumber("0")]],maker:[[this.parseNumber("0"),this.parseNumber("0.005")],[this.parseNumber("20000"),this.parseNumber("0.0025")],[this.parseNumber("100000"),this.parseNumber("0.0024")],[this.parseNumber("200000"),this.parseNumber("0.0022")],[this.parseNumber("400000"),this.parseNumber("0.0020")],[this.parseNumber("600000"),this.parseNumber("0.0015")],[this.parseNumber("1000000"),this.parseNumber("0.0014")],[this.parseNumber("2000000"),this.parseNumber("0.0013")],[this.parseNumber("4000000"),this.parseNumber("0.0012")],[this.parseNumber("20000000"),this.parseNumber("0.0011")],[this.parseNumber("50000000"),this.parseNumber("0.0010")],[this.parseNumber("100000000"),this.parseNumber("0.0007")],[this.parseNumber("500000000"),this.parseNumber("0.0005")],[this.parseNumber("2000000000"),this.parseNumber("0.0003")],[this.parseNumber("6000000000"),this.parseNumber("0.0001")],[this.parseNumber("20000000000"),this.parseNumber("0.00005")],[this.parseNumber("20000000001"),this.parseNumber("0")]]}},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{BTC:0,BCH:0,LTC:0,ETH:0,XRP:0,XLM:0,PAX:0,USD:7.5,EUR:0}}},precisionMode:j6,commonCurrencies:{UST:"USTC"},exceptions:{exact:{"No permission found":Of,"API key not found":No,"IP address not allowed":Of,"Invalid nonce":F6,"Invalid signature":No,"Authentication failed":No,"Missing key, signature and nonce parameters":No,"Wrong API key format":No,"Your account is frozen":Of,"Please update your profile with your FATCA information, before using API.":Of,"Order not found.":D6,"Price is more than 20% below market price.":Km,"Bitstamp.net is under scheduled maintenance. We'll be back soon.":U6,"Order could not be placed.":$6,"Invalid offset.":L6},broad:{"Minimum order size is":Km,"Check your account balance for details.":H6,"Ensure this value has at least":G6,"Ensure that there are no more than":Km}}})}async fetchMarkets(e={}){const t=await this.fetchMarketsFromCache(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"name");let[a,o]=r.split("/");const d=a.toLowerCase(),c=o.toLowerCase();a=this.safeCurrencyCode(a),o=this.safeCurrencyCode(o);const h=this.safeString(n,"minimum_order").split(" "),l=this.safeString(n,"trading");s.push({id:this.safeString(n,"url_symbol"),marketId:d+"_"+c,symbol:a+"/"+o,base:a,quote:o,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,future:!1,swap:!1,option:!1,active:l==="Enabled",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(n,"base_decimals"))),price:this.parseNumber(this.parsePrecision(this.safeString(n,"counter_decimals")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(h,0),max:void 0}},info:n})}return s}constructCurrencyObject(e,t,s,i,n,r){let a="crypto";const o=this.describe();this.isFiat(t)&&(a="fiat");const d=this.parseNumber(this.parsePrecision(this.numberToString(i)));return{id:e,code:t,info:r,type:a,name:s,active:!0,deposit:void 0,withdraw:void 0,fee:this.safeNumber(o.fees.funding.withdraw,t),precision:d,limits:{amount:{min:d,max:void 0},price:{min:d,max:void 0},cost:{min:n,max:void 0},withdraw:{min:void 0,max:void 0}}}}async fetchMarketsFromCache(e={}){const t=this.safeValue(this.options,"fetchMarkets",{}),s=this.safeInteger(t,"timestamp"),i=this.safeInteger(t,"expires",1e3),n=this.milliseconds();if(s===void 0||n-s>i){const r=await this.publicGetTradingPairsInfo(e);this.options.fetchMarkets=this.extend(t,{response:r,timestamp:n})}return this.safeValue(this.options.fetchMarkets,"response")}async fetchCurrencies(e={}){const t=await this.fetchMarketsFromCache(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"name");let[a,o]=r.split("/");const d=a.toLowerCase(),c=o.toLowerCase();a=this.safeCurrencyCode(a),o=this.safeCurrencyCode(o);const u=this.safeString(n,"description"),[h,l]=u.split(" / "),g=this.safeString(n,"minimum_order").split(" ")[0];if(!(a in s)){const y=this.safeInteger(n,"base_decimals");s[a]=this.constructCurrencyObject(d,a,h,y,void 0,n)}if(!(o in s)){const y=this.safeInteger(n,"counter_decimals");s[o]=this.constructCurrencyObject(c,o,l,y,this.parseNumber(g),n)}}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id},r=await this.publicGetOrderBookPair(this.extend(n,s)),a=this.safeInteger(r,"microtimestamp"),o=parseInt(a/1e3),d=this.parseOrderBook(r,i.symbol,o);return d.nonce=a,d}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeTimestamp(e,"timestamp"),n=this.safeString(e,"vwap"),r=this.safeString(e,"volume"),a=Xr.stringMul(r,n),o=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:n,open:this.safeString(e,"open"),close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:a,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetTickerPair(this.extend(i,t));return this.parseTicker(n,s)}getCurrencyIdFromTransaction(e){const t=this.safeStringLower(e,"currency");if(t!==void 0)return t;e=this.omit(e,["fee","price","datetime","type","status","id"]);const s=Object.keys(e);for(let i=0;i<s.length;i++){const n=s[i];if(n.indexOf("_")<0){const r=this.safeNumber(e,n);if(r!==void 0&&r!==0)return n}}}getMarketFromTrade(e){e=this.omit(e,["fee","price","datetime","tid","type","order_id","side"]);const t=Object.keys(e),s=t.length;if(s>2)throw new sS(this.id+" getMarketFromTrade() too many keys: "+this.json(t)+" in the trade: "+this.json(e));if(s===2){let i=t[0]+t[1];if(i in this.markets_by_id)return this.markets_by_id[i];if(i=t[1]+t[0],i in this.markets_by_id)return this.markets_by_id[i]}}parseTrade(e,t=void 0){const s=this.safeString2(e,"id","tid");let i,n,r=this.safeString(e,"price"),a=this.safeString(e,"amount");const o=this.safeString(e,"order_id"),d=void 0;let c=this.safeString(e,"cost"),u,h,l;if(t===void 0){const O=Object.keys(e);for(let x=0;x<O.length;x++){const C=O[x];if(C!=="order_id"&&C.indexOf("_")>=0){const E=C.replace("_","");if(E in this.markets_by_id)t=this.markets_by_id[E];else{l=C;const P=C.split("_");u=this.safeString(P,0),h=this.safeString(P,1),t=this.safeMarket(E)}}}}t===void 0&&(t=this.getMarketFromTrade(e));const p=this.safeString(e,"fee"),m=t.quote!==void 0?t.quote:h,g=t.baseId!==void 0?t.baseId:u,y=t.quoteId!==void 0?t.quoteId:h,b=l!==void 0?l:t.marketId;r=this.safeString(e,b,r),a=this.safeString(e,g,a),c=this.safeString(e,y,c),i=t.symbol;const w=this.safeString2(e,"date","datetime");let k;w!==void 0&&(w.indexOf(" ")>=0?k=this.parse8601(w):(k=parseInt(w),k=k*1e3)),"id"in e?a!==void 0&&(Xr.stringLt(a,"0")?(n="sell",a=Xr.stringNeg(a)):n="buy"):(n=this.safeString(e,"type"),n==="1"?n="sell":n==="0"?n="buy":n=void 0),c!==void 0&&(c=Xr.stringAbs(c));let T;return p!==void 0&&(T={cost:p,currency:m}),this.safeTrade({id:s,info:e,timestamp:k,datetime:this.iso8601(k),symbol:i,order:o,type:d,side:n,takerOrMaker:void 0,price:r,amount:a,cost:c,fee:T},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id,time:"hour"},a=await this.publicGetTransactionsPair(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"timestamp"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id,step:this.timeframes[t]},o=this.parseTimeframe(t);if(i===void 0)if(s===void 0)a.limit=1e3;else{i=1e3;const h=parseInt(s/1e3);a.start=h,a.end=this.sum(h,i*o),a.limit=i}else{if(s!==void 0){const h=parseInt(s/1e3);a.start=h,a.end=this.sum(h,i*o)}a.limit=Math.min(i,1e3)}const d=await this.publicGetOhlcPair(this.extend(a,n)),c=this.safeValue(d,"data",{}),u=this.safeValue(c,"ohlc",[]);return this.parseOHLCVs(u,r,t,s,i)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=Object.keys(this.currencies);for(let i=0;i<s.length;i++){const n=s[i],a=this.currency(n).id,o=this.account();o.free=this.safeString(e,a+"_available"),o.used=this.safeString(e,a+"_reserved"),o.total=this.safeString(e,a+"_balance"),t[n]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalance(e);return this.parseBalance(t)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.privatePostBalancePair(this.extend(i,t));return this.parseTradingFee(n,s)}parseTradingFee(e,t=void 0){t=this.safeMarket(void 0,t);const s=this.safeString(e,t.id+"_fee"),i=Xr.stringDiv(s,"100"),n=this.parseNumber(i);return{info:e,symbol:t.symbol,maker:n,taker:n}}parseTradingFees(e){const t={info:e},s=this.symbols;for(let i=0;i<s.length;i++){const n=s[i],r=this.market(n),a=this.parseTradingFee(e,r);t[n]=a}return t}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostBalance(e);return this.parseTradingFees(t)}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.privatePostBalance(t);return this.parseTransactionFees(s,e)}parseTransactionFees(e,t=void 0){t===void 0&&(t=Object.keys(this.currencies));const s={};let i;const n=Object.keys(e);for(let r=0;r<n.length;r++){const a=n[r],o=a.split("_")[0],d=this.safeCurrencyCode(o);t!==void 0&&!this.inArray(d,t)||(a.indexOf("_available")>=0&&(i=o,s[d]={deposit:void 0,withdraw:void 0,info:{}}),o===i&&(s[d].info[a]=this.safeNumber(e,a)),a.indexOf("_withdrawal_fee")>=0&&(s[d].withdraw=this.safeNumber(e,a)))}return s}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o="privatePost"+this.capitalize(s);const d={pair:a.id,amount:this.amountToPrecision(e,i)};t==="market"?o+="Market":t==="instant"?o+="Instant":d.price=this.priceToPrecision(e,n),o+="Pair";const c=this.safeString2(r,"client_order_id","clientOrderId");c!==void 0&&(d.client_order_id=c,r=this.omit(r,["client_order_id","clientOrderId"]));const u=await this[o](this.extend(d,r)),h=this.parseOrder(u,a);return this.extend(h,{type:t})}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e};return await this.privatePostCancelOrder(this.extend(i,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();let s;const i={};let n="privatePostCancelAllOrders";return e!==void 0&&(s=this.market(e),i.pair=s.id,n="privatePostCancelAllOrdersPair"),await this[n](this.extend(i,t))}parseOrderStatus(e){const t={"In Queue":"open",Open:"open",Finished:"closed",Canceled:"canceled"};return this.safeString(t,e,e)}async fetchOrderStatus(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue2(s,"client_order_id","clientOrderId"),n={};i!==void 0?(n.client_order_id=i,s=this.omit(s,["client_order_id","clientOrderId"])):n.id=e;const r=await this.privatePostOrderStatus(this.extend(n,s));return this.parseOrderStatus(this.safeString(r,"status"))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));const n=this.safeValue2(s,"client_order_id","clientOrderId"),r={};n!==void 0?(r.client_order_id=n,s=this.omit(s,["client_order_id","clientOrderId"])):r.id=e;const a=await this.privatePostOrderStatus(this.extend(r,s));return this.parseOrder(a,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r="privatePostUserTransactions",a;e!==void 0&&(a=this.market(e),n.pair=a.id,r+="Pair"),s!==void 0&&(n.limit=s);const o=await this[r](this.extend(n,i)),d=this.filterBy(o,"type","2");return this.parseTrades(d,a,t,s)}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};s!==void 0&&(n.limit=s);const r=await this.privatePostUserTransactions(this.extend(n,i));let a;e!==void 0&&(a=this.currency(e));const o=this.filterByArray(r,"type",["0","1"],!1);return this.parseTransactions(o,a,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0?n.timedelta=this.milliseconds()-t:n.timedelta=5e7;const r=await this.privatePostWithdrawalRequests(this.extend(n,i));return this.parseTransactions(r,void 0,t,s)}parseTransaction(e,t=void 0){const s=this.parse8601(this.safeString(e,"datetime")),i=this.safeString(e,"id"),n=this.getCurrencyIdFromTransaction(e),r=this.safeCurrencyCode(n,t),a=this.safeString(e,"fee");let o,d;"amount"in e?d=this.safeString(e,"amount"):t!==void 0?(d=this.safeString(e,t.id,d),o=t.code):r!==void 0&&n!==void 0&&(d=this.safeString(e,n,d),o=r),d!==void 0&&(d=Xr.stringAbs(d));let c="ok";"status"in e&&(c=this.parseTransactionStatus(this.safeString(e,"status")));let u;if("type"in e){const k=this.safeString(e,"type");k==="0"?u="deposit":k==="1"&&(u="withdrawal")}else u="withdrawal";const h=this.safeString(e,"transaction_id");let l,p=this.safeString(e,"address");if(p!==void 0){const k=p.split("?dt=");k.length>1&&(p=k[0],l=k[1])}const m=void 0,g=p,y=void 0,b=l;let w;return a!==void 0&&(w={currency:o,cost:a,rate:void 0}),{info:e,id:i,txid:h,timestamp:s,datetime:this.iso8601(s),network:void 0,addressFrom:m,addressTo:g,address:p,tagFrom:y,tagTo:b,tag:l,type:u,amount:this.parseNumber(d),currency:r,status:c,updated:void 0,fee:w}}parseTransactionStatus(e){const t={0:"pending",1:"pending",2:"ok",3:"canceled",4:"failed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"client_order_id");let n=this.safeString(e,"type");n!==void 0&&(n=n==="1"?"sell":"buy");const r=this.parse8601(this.safeString(e,"datetime")),a=this.safeStringLower(e,"currency_pair"),o=this.safeSymbol(a,t,"/"),d=this.parseOrderStatus(this.safeString(e,"status")),c=this.safeString(e,"amount"),u=this.safeValue(e,"transactions",[]),h=this.safeString(e,"price");return this.safeOrder({id:s,clientOrderId:i,datetime:this.iso8601(r),timestamp:r,lastTradeTimestamp:void 0,status:d,symbol:o,type:void 0,timeInForce:void 0,postOnly:void 0,side:n,price:h,stopPrice:void 0,cost:void 0,amount:c,filled:void 0,remaining:void 0,trades:u,fee:void 0,info:e,average:void 0},t)}parseLedgerEntryType(e){const t={0:"transaction",1:"transaction",2:"trade",14:"transfer"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.parseLedgerEntryType(this.safeString(e,"type"));if(s==="trade"){const i=this.parseTrade(e);let n;const r=Object.keys(e);for(let o=0;o<r.length;o++)if(r[o].indexOf("_")>=0){const d=r[o].replace("_","");d in this.markets_by_id&&(n=this.markets_by_id[d])}n===void 0&&(n=this.getMarketFromTrade(e));const a=i.side==="buy"?"in":"out";return{id:i.id,info:e,timestamp:i.timestamp,datetime:i.datetime,direction:a,account:void 0,referenceId:i.order,referenceAccount:void 0,type:s,currency:n.base,amount:i.amount,before:void 0,after:void 0,status:"ok",fee:i.fee}}else{const i=this.parseTransaction(e,t);let n;if("amount"in e){const r=this.safeString(e,"amount");n=Xr.stringGt(r,"0")?"in":"out"}else if("currency"in i&&i.currency!==void 0){const r=this.safeString(i,"currency");t=this.currency(r);const a=this.safeString(e,t.id);n=Xr.stringGt(a,"0")?"in":"out"}return{id:i.id,info:e,timestamp:i.timestamp,datetime:i.datetime,direction:n,account:void 0,referenceId:i.txid,referenceAccount:void 0,type:s,currency:i.currency,amount:i.amount,before:void 0,after:void 0,status:i.status,fee:i.fee}}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};s!==void 0&&(n.limit=s);const r=await this.privatePostUserTransactions(this.extend(n,i));let a;return e!==void 0&&(a=this.currency(e)),this.parseLedger(r,a,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){let n;await this.loadMarkets(),e!==void 0&&(n=this.market(e));const r=await this.privatePostOpenOrdersAll(i);return this.parseOrders(r,n,t,s,{status:"open",type:"limit"})}getCurrencyName(e){return e.toLowerCase()}isFiat(e){return e==="USD"||e==="EUR"||e==="GBP"}async fetchDepositAddress(e,t={}){if(this.isFiat(e))throw new R6(this.id+" fiat fetchDepositAddress() for "+e+" is not supported!");const s=this.getCurrencyName(e),i="privatePost"+this.capitalize(s)+"Address",n=await this[i](t),r=this.safeString(n,"address"),a=this.safeString2(n,"memo_id","destination_tag");return this.checkAddress(r),{currency:e,address:r,tag:a,network:void 0,info:n}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets(),this.checkAddress(s);const r={amount:t};let a,o;if(this.isFiat(e))o="privatePostWithdrawalOpen",a=this.currency(e),r.iban=s,r.account_currency=a.id;else{const c=this.getCurrencyName(e);o="privatePost"+this.capitalize(c)+"Withdrawal",e==="XRP"?i!==void 0&&(r.destination_tag=i):(e==="XLM"||e==="HBAR")&&i!==void 0&&(r.memo_id=i),r.address=s}const d=await this[o](this.extend(r,n));return this.parseTransaction(d,a)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/";a+=this.version+"/",a+=this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials();const d="BITSTAMP "+this.apiKey,c=this.uuid(),u=this.milliseconds().toString(),h="v2";let l="";n={"X-Auth":d,"X-Auth-Nonce":c,"X-Auth-Timestamp":u,"X-Auth-Version":h},s==="POST"&&(Object.keys(o).length?(r=this.urlencode(o),l="application/x-www-form-urlencoded",n["Content-Type"]=l):(r=this.urlencode({foo:"bar"}),l="application/x-www-form-urlencoded",n["Content-Type"]=l));const p=r||"",m=d+s+a.replace("https://","")+l+c+u+h+p,g=this.hmac(this.encode(m),this.encode(this.secret));n["X-Auth-Signature"]=g}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"status"),u=this.safeValue(a,"error");if(c==="error"||u!==void 0){let h=[];if(typeof u=="string")h.push(u);else if(u!==void 0){const g=Object.keys(u);for(let y=0;y<g.length;y++){const b=g[y],w=this.safeValue(u,b);Array.isArray(w)?h=this.arrayConcat(h,w):h.push(w)}}const l=this.safeValue(a,"reason",{});if(typeof l=="string")h.push(l);else{const g=this.safeValue(l,"__all__",[]);for(let y=0;y<g.length;y++)h.push(g[y])}if(this.safeString(a,"code")==="API0005")throw new No(this.id+" invalid signature, use the uid for the main account if you have subaccounts");const m=this.id+" "+r;for(let g=0;g<h.length;g++){const y=h[g];this.throwExactlyMatchedException(this.exceptions.exact,y,m),this.throwBroadlyMatchedException(this.exceptions.broad,y,m)}throw new sS(m)}}};const W6=ge,{BadSymbol:z6,ExchangeError:lc}=de,{TICK_SIZE:K6}=me,X6=Se;var Y6=class extends W6{describe(){return this.deepExtend(super.describe(),{id:"bitstamp1",name:"Bitstamp",countries:["GB"],rateLimit:1e3,version:"v1",has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOrder:void 0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/27786377-8c8ab57e-5fe9-11e7-8ea4-2b05b6bcceec.jpg",api:{rest:"https://www.bitstamp.net/api"},www:"https://www.bitstamp.net",doc:"https://www.bitstamp.net/api"},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},api:{public:{get:["ticker","ticker_hour","order_book","transactions","eur_usd"]},private:{post:["balance","user_transactions","open_orders","order_status","cancel_order","cancel_all_orders","buy","sell","bitcoin_deposit_address","unconfirmed_btc","ripple_withdrawal","ripple_address","withdrawal_requests","bitcoin_withdrawal"]}},precisionMode:K6,markets:{"BTC/USD":{id:"btcusd",symbol:"BTC/USD",base:"BTC",quote:"USD",baseId:"btc",quoteId:"usd",maker:.005,taker:.005,type:"spot",spot:!0},"BTC/EUR":{id:"btceur",symbol:"BTC/EUR",base:"BTC",quote:"EUR",baseId:"btc",quoteId:"eur",maker:.005,taker:.005,type:"spot",spot:!0},"EUR/USD":{id:"eurusd",symbol:"EUR/USD",base:"EUR",quote:"USD",baseId:"eur",quoteId:"usd",maker:.005,taker:.005,type:"spot",spot:!0},"XRP/USD":{id:"xrpusd",symbol:"XRP/USD",base:"XRP",quote:"USD",baseId:"xrp",quoteId:"usd",maker:.005,taker:.005,type:"spot",spot:!0},"XRP/EUR":{id:"xrpeur",symbol:"XRP/EUR",base:"XRP",quote:"EUR",baseId:"xrp",quoteId:"eur",maker:.005,taker:.005,type:"spot",spot:!0},"XRP/BTC":{id:"xrpbtc",symbol:"XRP/BTC",base:"XRP",quote:"BTC",baseId:"xrp",quoteId:"btc",maker:.005,taker:.005,type:"spot",spot:!0},"LTC/USD":{id:"ltcusd",symbol:"LTC/USD",base:"LTC",quote:"USD",baseId:"ltc",quoteId:"usd",maker:.005,taker:.005,type:"spot",spot:!0},"LTC/EUR":{id:"ltceur",symbol:"LTC/EUR",base:"LTC",quote:"EUR",baseId:"ltc",quoteId:"eur",maker:.005,taker:.005,type:"spot",spot:!0},"LTC/BTC":{id:"ltcbtc",symbol:"LTC/BTC",base:"LTC",quote:"BTC",baseId:"ltc",quoteId:"btc",maker:.005,taker:.005,type:"spot",spot:!0},"ETH/USD":{id:"ethusd",symbol:"ETH/USD",base:"ETH",quote:"USD",baseId:"eth",quoteId:"usd",maker:.005,taker:.005,type:"spot",spot:!0},"ETH/EUR":{id:"etheur",symbol:"ETH/EUR",base:"ETH",quote:"EUR",baseId:"eth",quoteId:"eur",maker:.005,taker:.005,type:"spot",spot:!0},"ETH/BTC":{id:"ethbtc",symbol:"ETH/BTC",base:"ETH",quote:"BTC",baseId:"eth",quoteId:"btc",maker:.005,taker:.005,type:"spot",spot:!0}}})}async fetchOrderBook(e,t=void 0,s={}){if(e!=="BTC/USD")throw new lc(this.id+" "+this.version+" fetchOrderBook doesn't support "+e+", use it for BTC/USD only");await this.loadMarkets();const i=await this.publicGetOrderBook(s),n=this.safeTimestamp(i,"timestamp");return this.parseOrderBook(i,e,n)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeTimestamp(e,"timestamp"),n=this.safeString(e,"vwap"),r=this.safeString(e,"volume"),a=X6.stringMul(r,n),o=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:n,open:this.safeString(e,"open"),close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:a,info:e},t)}async fetchTicker(e,t={}){if(e!=="BTC/USD")throw new lc(this.id+" "+this.version+" fetchTicker doesn't support "+e+", use it for BTC/USD only");await this.loadMarkets();const s=this.market(e),i=await this.publicGetTicker(t);return this.parseTicker(i,s)}parseTrade(e,t=void 0){const s=this.safeTimestamp2(e,"date","datetime"),i=e.type===0?"buy":"sell",n=this.safeString(e,"order_id"),r=this.safeString(e,"tid"),a=this.safeString(e,"price"),o=this.safeString(e,"amount"),d=this.safeString(e,"currency_pair");return t=this.safeMarket(d,t),this.safeTrade({id:r,info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:n,type:void 0,side:i,takerOrMaker:void 0,price:a,amount:o,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){if(e!=="BTC/USD")throw new z6(this.id+" "+this.version+" fetchTrades doesn't support "+e+", use it for BTC/USD only");await this.loadMarkets();const n=this.market(e),r={time:"minute"},a=await this.publicGetTransactions(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseBalance(e){const t={info:e},s=Object.keys(this.currencies);for(let i=0;i<s.length;i++){const n=s[i],a=this.currency(n).id,o=this.account();o.free=this.safeString(e,a+"_available"),o.used=this.safeString(e,a+"_reserved"),o.total=this.safeString(e,a+"_balance"),t[n]=o}return this.safeBalance(t)}async fetchBalance(e={}){const t=await this.privatePostBalance(e);return this.parseBalance(t)}async createOrder(e,t,s,i,n=void 0,r={}){if(t!=="limit")throw new lc(this.id+" "+this.version+" accepts limit orders only");if(e!=="BTC/USD")throw new lc(this.id+" v1 supports BTC/USD orders only");await this.loadMarkets();const a="privatePost"+this.capitalize(s),o={amount:i,price:n},d=await this[a](this.extend(o,r)),c=this.safeString(d,"id");return{info:d,id:c}}async cancelOrder(e,t=void 0,s={}){return await this.privatePostCancelOrder({id:e})}parseOrderStatus(e){const t={"In Queue":"open",Open:"open",Finished:"closed",Canceled:"canceled"};return this.safeString(t,e,e)}async fetchOrderStatus(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privatePostOrderStatus(this.extend(i,s));return this.parseOrderStatus(n)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));const a={id:n?n.id:"all"},o=await this.privatePostOpenOrdersId(this.extend(a,i));return this.parseTrades(o,n,t,s)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.implodeParams(e,i),o=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials();const d=this.nonce().toString(),c=d+this.uid+this.apiKey,u=this.encode(this.hmac(this.encode(c),this.encode(this.secret)));o=this.extend({key:this.apiKey,signature:u.toUpperCase(),nonce:d},o),r=this.urlencode(o),n={"Content-Type":"application/x-www-form-urlencoded"}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;if(this.safeString(a,"status")==="error")throw new lc(this.id+" "+this.json(a))}};const Q6=ge,{ArgumentsRequired:Z6,BadSymbol:iS,ExchangeError:nS,ExchangeNotAvailable:J6,AuthenticationError:pc,InvalidOrder:Yr,InsufficientFunds:eL,OrderNotFound:Vo,DDoSProtection:rS,PermissionDenied:tL,AddressPending:aS,OnMaintenance:sL,BadRequest:Xm,InvalidAddress:iL}=de,{TRUNCATE:nL,TICK_SIZE:rL}=me;var H_=class extends Q6{describe(){return this.deepExtend(super.describe(),{id:"bittrex",name:"Bittrex",countries:["US"],version:"v3",rateLimit:1500,certified:!1,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createMarketOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransactionFees:void 0,fetchTransactions:void 0,fetchWithdrawal:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},timeframes:{"1m":"MINUTE_1","5m":"MINUTE_5","1h":"HOUR_1","1d":"DAY_1"},hostname:"bittrex.com",urls:{logo:"https://user-images.githubusercontent.com/51840849/87153921-edf53180-c2c0-11ea-96b9-f2a9a95a455b.jpg",api:{public:"https://api.bittrex.com",private:"https://api.bittrex.com"},www:"https://bittrex.com",doc:["https://bittrex.github.io/api/v3"],fees:["https://bittrex.zendesk.com/hc/en-us/articles/115003684371-BITTREX-SERVICE-FEES-AND-WITHDRAWAL-LIMITATIONS","https://bittrex.zendesk.com/hc/en-us/articles/115000199651-What-fees-does-Bittrex-charge-"],referral:"https://bittrex.com/Account/Register?referralCode=1ZE-G0G-M3B"},api:{public:{get:["ping","currencies","currencies/{symbol}","markets","markets/tickers","markets/summaries","markets/{marketSymbol}","markets/{marketSymbol}/summary","markets/{marketSymbol}/orderbook","markets/{marketSymbol}/trades","markets/{marketSymbol}/ticker","markets/{marketSymbol}/candles/{candleInterval}/recent","markets/{marketSymbol}/candles/{candleInterval}/historical/{year}/{month}/{day}","markets/{marketSymbol}/candles/{candleInterval}/historical/{year}/{month}","markets/{marketSymbol}/candles/{candleInterval}/historical/{year}"]},private:{get:["account","account/fees/fiat","account/fees/fiat/{currencySymbol}","account/fees/trading","account/fees/trading/{marketSymbol}","account/volume","account/permissions/markets","account/permissions/markets/{marketSymbol}","account/permissions/currencies","account/permissions/currencies/{currencySymbol}","addresses","addresses/{currencySymbol}","balances","balances/{currencySymbol}","deposits/open","deposits/closed","deposits/ByTxId/{txId}","deposits/{depositId}","executions","executions/last-id","executions/{executionId}","orders/closed","orders/open","orders/{orderId}","orders/{orderId}/executions","ping","subaccounts/{subaccountId}","subaccounts","subaccounts/withdrawals/open","subaccounts/withdrawals/closed","subaccounts/deposits/open","subaccounts/deposits/closed","withdrawals/open","withdrawals/closed","withdrawals/ByTxId/{txId}","withdrawals/{withdrawalId}","withdrawals/allowed-addresses","conditional-orders/{conditionalOrderId}","conditional-orders/closed","conditional-orders/open","transfers/sent","transfers/received","transfers/{transferId}","funds-transfer-methods/{fundsTransferMethodId}"],post:["addresses","orders","subaccounts","withdrawals","conditional-orders","transfers","batch"],delete:["orders/open","orders/{orderId}","withdrawals/{withdrawalId}","conditional-orders/{conditionalOrderId}"]}},fees:{trading:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.0075"),taker:this.parseNumber("0.0075")},funding:{tierBased:!1,percentage:!1}},precisionMode:rL,exceptions:{exact:{BAD_REQUEST:Xm,STARTDATE_OUT_OF_RANGE:Xm,APISIGN_NOT_PROVIDED:pc,APIKEY_INVALID:pc,INVALID_SIGNATURE:pc,INVALID_CURRENCY:nS,INVALID_PERMISSION:pc,INSUFFICIENT_FUNDS:eL,INVALID_CEILING_MARKET_BUY:Yr,INVALID_FIAT_ACCOUNT:Yr,INVALID_ORDER_TYPE:Yr,QUANTITY_NOT_PROVIDED:Yr,MIN_TRADE_REQUIREMENT_NOT_MET:Yr,NOT_FOUND:Vo,ORDER_NOT_OPEN:Vo,INVALID_ORDER:Yr,UUID_INVALID:Vo,RATE_NOT_PROVIDED:Yr,INVALID_MARKET:iS,WHITELIST_VIOLATION_IP:tL,DUST_TRADE_DISALLOWED_MIN_VALUE:Yr,RESTRICTED_MARKET:iS,"We are down for scheduled maintenance, but we\u2019ll be back up shortly.":sL},broad:{throttled:rS,problem:J6}},options:{fetchTicker:{method:"publicGetMarketsMarketSymbolTicker"},fetchTickers:{method:"publicGetMarketsTickers"},fetchDeposits:{status:"ok"},fetchWithdrawals:{status:"ok"},parseOrderStatus:!1,hasAlreadyAuthenticatedSuccessfully:!1,tag:{NXT:!0,CRYPTO_NOTE_PAYMENTID:!0,BITSHAREX:!0,RIPPLE:!0,NEM:!0,STELLAR:!0,STEEM:!0},subaccountId:void 0,fetchClosedOrdersFilterBySince:!0},commonCurrencies:{BIFI:"Bifrost Finance",BTR:"BTRIPS",GMT:"GMT Token",MEME:"Memetic",MER:"Mercury",PROS:"Pros.Finance",REPV2:"REP",TON:"Tokamak Network"}})}feeToPrecision(e,t){return this.decimalToPrecision(t,nL,this.markets[e].precision.price,this.precisionMode)}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"baseCurrencySymbol"),a=this.safeString(n,"quoteCurrencySymbol"),o=this.safeCurrencyCode(r),d=this.safeCurrencyCode(a),c=this.safeString(n,"status");s.push({id:this.safeString(n,"symbol"),symbol:o+"/"+d,base:o,quote:d,settle:void 0,baseId:r,quoteId:a,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:c==="ONLINE",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber("0.00000001"),price:this.parseNumber(this.parsePrecision(this.safeString(n,"precision","8")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(n,"minTradeSize"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:n})}return s}parseBalance(e){const t={info:e},s=this.indexBy(e,"currencySymbol"),i=Object.keys(s);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeCurrencyCode(r),o=this.account(),d=s[r];o.free=this.safeString(d,"available"),o.total=this.safeString(d,"total"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalances(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={marketSymbol:i.id};if(t!==void 0){if(t!==1&&t!==25&&t!==500)throw new Xm(this.id+" fetchOrderBook() limit argument must be undefined, 1, 25 or 500, default is 25");n.depth=t}const r=await this.publicGetMarketsMarketSymbolOrderbook(this.extend(n,s)),a=this.safeInteger(this.last_response_headers,"Sequence"),o=this.parseOrderBook(r,i.symbol,void 0,"bid","ask","rate","quantity");return o.nonce=a,o}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"symbol"),a=this.safeCurrencyCode(r),o=this.parseNumber("0.00000001"),d=this.safeNumber(n,"txFee"),c=this.safeString(n,"status");s[a]={id:r,code:a,address:this.safeString(n,"baseAddress"),info:n,type:this.safeString(n,"coinType"),name:this.safeString(n,"name"),active:c==="ONLINE",deposit:void 0,withdraw:void 0,fee:d,precision:o,limits:{amount:{min:o,max:void 0},withdraw:{min:d,max:void 0}}}}return s}parseTicker(e,t=void 0){const s=this.parse8601(this.safeString(e,"updatedAt")),i=this.safeString(e,"symbol");t=this.safeMarket(i,t,"-");const n=t.symbol,r=this.safeString(e,"percentChange"),a=this.safeString(e,"lastTradeRate");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bidRate"),bidVolume:void 0,ask:this.safeString(e,"askRate"),askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:r,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:this.safeString(e,"quoteVolume"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeValue(this.options,"fetchTickers",{}),i=this.safeString(s,"method","publicGetMarketsTickers"),n=this.safeString(t,"method",i);t=this.omit(t,"method");const r=await this[n](t),a=[];for(let o=0;o<r.length;o++){const d=this.parseTicker(r[o]);a.push(d)}return this.filterByArray(a,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={marketSymbol:s.id},n=this.safeValue(this.options,"fetchTicker",{}),r=this.safeString(n,"method","publicGetMarketsMarketSymbolTicker"),a=this.safeString(t,"method",r);t=this.omit(t,"method");const o=await this[a](this.extend(i,t));return this.parseTicker(o,s)}async fetchBidsAsks(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetMarketsTickers(t);return this.parseTickers(s,e)}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"executedAt")),i=this.safeString(e,"id"),n=this.safeString(e,"orderId"),r=this.safeString(e,"marketSymbol");t=this.safeMarket(r,t,"-");const a=this.safeString(e,"rate"),o=this.safeString(e,"quantity");let d,c=this.safeStringLower2(e,"takerSide","direction");const u=this.safeValue(e,"isTaker");u!==void 0&&(d=u?"taker":"maker",u||(c==="buy"?c="sell":c==="sell"&&(c="buy")));let h;const l=this.safeString(e,"commission");return l!==void 0&&(h={cost:l,currency:t.quote}),this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,id:i,order:n,takerOrMaker:d,type:void 0,side:c,price:a,amount:o,cost:void 0,fee:h},t)}async fetchTime(e={}){const t=await this.publicGetPing(e);return this.safeInteger(t,"serverTime")}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={marketSymbol:n.id},a=await this.publicGetMarketsMarketSymbolTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={marketSymbol:s.id},n=await this.privateGetAccountFeesTradingMarketSymbol(this.extend(i,t));return this.parseTradingFee(n,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetAccountFeesTrading(e);return this.parseTradingFees(t)}parseTradingFee(e,t=void 0){const s=this.safeString(e,"marketSymbol"),i=this.safeNumber(e,"makerRate"),n=this.safeNumber(e,"takerRate");return{info:e,symbol:this.safeSymbol(s,t),maker:i,taker:n}}parseTradingFees(e){const t={info:e};for(let s=0;s<e.length;s++){const i=this.parseTradingFee(e[s]),n=i.symbol;t[n]=i}return t}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"startsAt")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=r.baseId+"-"+r.quoteId,o={candleInterval:this.timeframes[t],marketSymbol:a};let d="publicGetMarketsMarketSymbolCandlesCandleIntervalRecent";if(s!==void 0){const u=this.milliseconds(),h=Math.abs(u-s),p=this.yyyymmdd(s).split("-"),m=this.safeInteger(p,0),g=this.safeInteger(p,1),y=this.safeInteger(p,2);t==="1d"?h>316224e5&&(d="publicGetMarketsMarketSymbolCandlesCandleIntervalHistoricalYear",o.year=m):t==="1h"?h>26784e5&&(d="publicGetMarketsMarketSymbolCandlesCandleIntervalHistoricalYearMonth",o.year=m,o.month=g):h>864e5&&(d="publicGetMarketsMarketSymbolCandlesCandleIntervalHistoricalYearMonthDay",o.year=m,o.month=g,o.day=y)}const c=await this[d](this.extend(o,n));return this.parseOHLCVs(c,r,t,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;const a=this.safeValue(i,"stop");e!==void 0&&(r=this.market(e),n.marketSymbol=r.id);let o="privateGetOrdersOpen";a&&(o="privateGetConditionalOrdersOpen");const d=this.omit(i,"stop"),c=await this[o](this.extend(n,d));return this.parseOrders(c,r,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={orderId:e},a=await this.privateGetOrdersOrderIdExecutions(this.extend(r,n));let o;return t!==void 0&&(o=this.market(t)),this.parseTrades(a,o,s,i)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o;t!==void 0&&(o=t.toUpperCase());const d=a.baseId+"-"+a.quoteId,c=this.safeValue(r,"stop"),u=this.safeNumber2(r,"triggerPrice","stopPrice"),h={marketSymbol:d};let l="privatePostOrders";if(c||u){l="privatePostConditionalOrders";const g=this.safeString(r,"operand");if(g===void 0)throw new Z6(this.id+" createOrder() requires an operand parameter");const y=this.safeNumber(r,"trailingStopPercent"),b=this.safeValue(r,"orderToCreate"),w=this.safeValue(r,"orderToCancel");if(u===void 0&&(h.trailingStopPercent=this.priceToPrecision(e,y)),b){const k=o==="CEILING_LIMIT",T=o==="CEILING_MARKET",O=k||T;let x,C,E;if(O){let P;k?(C=this.priceToPrecision(e,n),P=this.safeNumber2(r,"ceiling","cost",i)):T&&(P=this.safeNumber2(r,"ceiling","cost"),P===void 0&&(n===void 0?P=i:P=i*n)),x=this.costToPrecision(e,P),E="IMMEDIATE_OR_CANCEL"}else o==="LIMIT"?(C=this.priceToPrecision(e,n),E="GOOD_TIL_CANCELLED"):E="IMMEDIATE_OR_CANCEL";h.orderToCreate={marketSymbol:d,direction:s.toUpperCase(),type:o,quantity:this.amountToPrecision(e,i),ceiling:x,limit:C,timeInForce:E,clientOrderId:this.safeString(r,"clientOrderId"),useAwards:this.safeValue(r,"useAwards")}}w&&(h.orderToCancel=w),h.triggerPrice=this.priceToPrecision(e,u),h.operand=g}else{s!==void 0&&(h.direction=s.toUpperCase()),h.type=o;const g=o==="CEILING_LIMIT",y=o==="CEILING_MARKET";if(g||y){let w;g?(h.limit=this.priceToPrecision(e,n),w=this.safeNumber2(r,"ceiling","cost",i)):y&&(w=this.safeNumber2(r,"ceiling","cost"),w===void 0&&(n===void 0?w=i:w=i*n)),h.ceiling=this.costToPrecision(e,w),h.timeInForce="IMMEDIATE_OR_CANCEL"}else h.quantity=this.amountToPrecision(e,i),o==="LIMIT"?(h.limit=this.priceToPrecision(e,n),h.timeInForce="GOOD_TIL_CANCELLED"):h.timeInForce="IMMEDIATE_OR_CANCEL"}const p=this.omit(r,["stop","stopPrice","ceiling","cost","operand","trailingStopPercent","orderToCreate","orderToCancel"]),m=await this[l](this.extend(h,p));return this.parseOrder(m,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue(s,"stop");let n={},r,a;t!==void 0&&(a=this.market(t)),i?(r="privateDeleteConditionalOrdersConditionalOrderId",n={conditionalOrderId:e}):(r="privateDeleteOrdersOrderId",n={orderId:e});const o=this.omit(s,"stop"),d=await this[r](this.extend(n,o));return this.extend(this.parseOrder(d,a),{id:e,info:d,status:"canceled"})}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;e!==void 0&&(i=this.market(e),s.marketSymbol=i.id);const n=await this.privateDeleteOrdersOpen(this.extend(s,t)),r=[];for(let a=0;a<n.length;a++){const o=this.safeValue(n[a],"result",{});r.push(o)}return this.parseOrders(r,i)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const i={txId:e};let n;t!==void 0&&(n=this.currency(t));const r=await this.privateGetDepositsByTxIdTxId(this.extend(i,s)),a=this.parseTransactions(r,n,void 0,void 0);return this.safeValue(a,0)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.currency(e),n.currencySymbol=r.id),t!==void 0){const h=parseInt(t/1e3)*1e3;n.startDate=this.iso8601(h)}s!==void 0&&(n.pageSize=s);let a;const o=this.safeValue(this.options,"fetchDeposits",{}),d=this.safeString(o,"status","ok");this.safeString(i,"status",d)==="pending"?a="privateGetDepositsOpen":a="privateGetDepositsClosed",i=this.omit(i,"status");const u=await this[a](this.extend(n,i));return this.parseTransactions(u,r,void 0,s)}async fetchPendingDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.loadMarkets(),this.fetchDeposits(e,t,s,this.extend(i,{status:"pending"}))}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const i={txId:e};let n;t!==void 0&&(n=this.currency(t));const r=await this.privateGetWithdrawalsByTxIdTxId(this.extend(i,s)),a=this.parseTransactions(r,n,void 0,void 0);return this.safeValue(a,0)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.currency(e),n.currencySymbol=r.id),t!==void 0){const h=parseInt(t/1e3)*1e3;n.startDate=this.iso8601(h)}s!==void 0&&(n.pageSize=s);let a;const o=this.safeValue(this.options,"fetchWithdrawals",{}),d=this.safeString(o,"status","ok");this.safeString(i,"status",d)==="pending"?a="privateGetWithdrawalsOpen":a="privateGetWithdrawalsClosed",i=this.omit(i,"status");const u=await this[a](this.extend(n,i));return this.parseTransactions(u,r,t,s)}async fetchPendingWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.loadMarkets(),this.fetchWithdrawals(e,t,s,this.extend(i,{status:"pending"}))}parseTransaction(e,t=void 0){const s=this.safeString2(e,"id","clientWithdrawalId"),i=this.safeNumber(e,"quantity"),n=this.safeString(e,"cryptoAddress");let r,a;this.safeString(e,"source")==="BLOCKCHAIN"?a=n:r=n;const d=this.safeString(e,"txId"),c=this.parse8601(this.safeString(e,"updatedAt")),u=this.parse8601(this.safeString(e,"createdAt")),h=u||c,l=u===void 0?"deposit":"withdrawal",p=this.safeString(e,"currencySymbol"),m=this.safeCurrencyCode(p,t);let g="pending";if(l==="deposit")g="ok";else{const b=this.safeString(e,"status");b==="ERROR_INVALID_ADDRESS"?g="failed":b==="CANCELLED"?g="canceled":b==="PENDING"?g="pending":(b==="COMPLETED"||b==="AUTHORIZED"&&d!==void 0)&&(g="ok")}let y=this.safeNumber(e,"txCost");return y===void 0&&l==="deposit"&&(y=0),{info:e,id:s,currency:m,amount:i,network:void 0,address:n,addressTo:r,addressFrom:a,tag:void 0,tagTo:void 0,tagFrom:void 0,status:g,type:l,updated:c,txid:d,timestamp:h,datetime:this.iso8601(h),fee:{currency:m,cost:y}}}parseTimeInForce(e){const t={GOOD_TIL_CANCELLED:"GTC",IMMEDIATE_OR_CANCEL:"IOC",FILL_OR_KILL:"FOK",POST_ONLY_GOOD_TIL_CANCELLED:"PO"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"marketSymbol");t=this.safeMarket(s,t,"-");const i=t.symbol,n=t.quote,r=this.safeString(e,"createdAt"),a=this.safeString(e,"updatedAt"),o=this.safeString(e,"closedAt"),d=this.safeString(e,"clientOrderId");let c;o!==void 0?c=this.parse8601(o):a&&(c=this.parse8601(a));const u=this.parse8601(r);let h=this.safeStringLower(e,"direction");if(h===void 0){let O=this.safeValue(e,"orderToCreate");O===void 0&&(O=this.safeValue(e,"orderToCancel")),h=this.safeStringLower(O,"direction")}let l=this.safeStringLower(e,"type");if(l===void 0){let O=this.safeValue(e,"orderToCreate");O===void 0&&(O=this.safeValue(e,"orderToCancel")),l=this.safeStringLower(O,"type")}let p=this.safeString(e,"quantity");if(p===void 0){let O=this.safeValue(e,"orderToCreate");O===void 0&&(O=this.safeValue(e,"orderToCancel")),p=this.safeString(O,"quantity")}let m=this.safeString(e,"limit");if(m===void 0){let O=this.safeValue(e,"orderToCreate");O===void 0&&(O=this.safeValue(e,"orderToCancel")),m=this.safeString(O,"limit")}let g=this.parseTimeInForce(this.safeString(e,"timeInForce"));if(g===void 0){let O=this.safeValue(e,"orderToCreate");O===void 0&&(O=this.safeValue(e,"orderToCancel")),g=this.parseTimeInForce(this.safeString(O,"timeInForce"))}const y=this.safeString(e,"fillQuantity"),b=this.safeNumber(e,"commission"),w=this.safeString(e,"proceeds"),k=this.safeStringLower(e,"status"),T=g==="PO";return this.safeOrder({id:this.safeString(e,"id"),clientOrderId:d,timestamp:u,datetime:this.iso8601(u),lastTradeTimestamp:c,symbol:i,type:l,timeInForce:g,postOnly:T,side:h,price:m,stopPrice:this.safeString(e,"triggerPrice"),cost:w,average:void 0,amount:p,filled:y,remaining:void 0,status:k,fee:{cost:b,currency:n},info:e,trades:void 0},t)}parseOrders(e,t=void 0,s=void 0,i=void 0,n={}){return this.options.fetchClosedOrdersFilterBySince?super.parseOrders(e,t,s,i,n):super.parseOrders(e,t,void 0,i,n)}parseOrderStatus(e){const t={CLOSED:"closed",OPEN:"open",CANCELLED:"canceled",CANCELED:"canceled"};return this.safeString(t,e,e)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue(s,"stop");let n;t!==void 0&&(n=this.market(t));let r,a;try{const o={};i?(a="privateGetConditionalOrdersConditionalOrderId",o.conditionalOrderId=e):(a="privateGetOrdersOrderId",o.orderId=e);const d=this.omit(s,"stop");r=await this[a](this.extend(o,d))}catch(o){throw this.last_json_response&&this.safeString(this.last_json_response,"message")==="UUID_INVALID"?new Vo(this.id+" fetchOrder() error: "+this.last_http_response):o}return this.parseOrder(r,n)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};s!==void 0&&(n.pageSize=s),t!==void 0&&(n.startDate=this.ymdhms(t,"T")+"Z");let r;e!==void 0&&(r=this.market(e),e=r.symbol,n.marketSymbol=r.id);const a=await this.privateGetExecutions(this.extend(n,i)),o=this.parseTrades(a,r);return this.filterBySymbolSinceLimit(o,e,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeValue(i,"stop"),r={};s!==void 0&&(r.pageSize=s),t!==void 0&&(r.startDate=this.ymdhms(t,"T")+"Z");let a;e!==void 0&&(a=this.market(e),r.marketSymbol=a.base+"-"+a.quote);let o="privateGetOrdersClosed";n&&(o="privateGetConditionalOrdersClosed");const d=this.omit(i,"stop"),c=await this[o](this.extend(r,d));return this.parseOrders(c,a,t,s)}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currencySymbol:s.id},n=await this.privatePostAddresses(this.extend(i,t));let r=this.safeString(n,"cryptoAddress");const a=this.safeString(n,"status");if(!r||a==="REQUESTED")throw new aS(this.id+" the address for "+e+" is being generated (pending, not ready yet, retry again later)");let o=this.safeString(n,"cryptoAddressTag");return o===void 0&&s.type in this.options.tag&&(o=r,r=s.address),this.checkAddress(r),{currency:e,address:r,tag:o,info:n}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currencySymbol:s.id},n=await this.privateGetAddressesCurrencySymbol(this.extend(i,t));let r=this.safeString(n,"cryptoAddress");const a=this.safeString(n,"status");if(!r||a==="REQUESTED")throw new aS(this.id+" the address for "+e+" is being generated (pending, not ready yet, retry again later)");let o=this.safeString(n,"cryptoAddressTag");return o===void 0&&s.type in this.options.tag&&(o=r,r=s.address),this.checkAddress(r),{currency:e,address:r,tag:o,network:void 0,info:n}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currencySymbol:r.id,quantity:t,cryptoAddress:s};i!==void 0&&(a.cryptoAddressTag=i);const o=await this.privatePostWithdrawals(this.extend(a,n));return this.parseTransaction(o,r)}sign(e,t="v3",s="GET",i={},n=void 0,r=void 0){let a=this.implodeParams(this.urls.api[t],{hostname:this.hostname})+"/";if(t==="private"){a+=this.version+"/",this.checkRequiredCredentials(),a+=this.implodeParams(e,i),i=this.omit(i,this.extractParams(e));let o="";s==="POST"?(r=this.json(i),o=r):Object.keys(i).length&&(a+="?"+this.rawencode(i));const d=this.hash(this.encode(o),"sha512","hex"),c=this.milliseconds().toString();let u=c+a+s+d;const h=this.safeValue(this.options,"subaccountId");h!==void 0&&(u+=h);const l=this.hmac(this.encode(u),this.encode(this.secret),"sha512");n={"Api-Key":this.apiKey,"Api-Timestamp":c,"Api-Content-Hash":d,"Api-Signature":l},h!==void 0&&(n["Api-Subaccount-Id"]=h),s==="POST"&&(n["Content-Type"]="application/json")}else t==="public"&&(a+=this.version+"/"),a+=this.implodeParams(e,i),i=this.omit(i,this.extractParams(e)),Object.keys(i).length&&(a+="?"+this.urlencode(i));return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&r[0]==="{"){const c=this.id+" "+r;let u=this.safeValue(a,"success");if(u===void 0){const h=this.safeString(a,"code");if(h==="NOT_FOUND"&&s.indexOf("addresses")>=0)throw new iL(c);h!==void 0&&(this.throwExactlyMatchedException(this.exceptions.exact,h,c),this.throwBroadlyMatchedException(this.exceptions.broad,h,c));return}if(typeof u=="string"&&(u=u==="true"),!u){const h=this.safeString(a,"message");if(h==="APIKEY_INVALID")throw this.options.hasAlreadyAuthenticatedSuccessfully?new rS(c):new pc(c);if(h==="INVALID_ORDER"){const l="cancel";if(s.indexOf(l)>=0){const m=s.split("?");if(m.length>1){const b=m[1].split("&"),w=b.length;let k;for(let T=0;T<w;T++){const x=b[T].split("=");if(x[0]==="uuid"){k=x[1];break}}throw k!==void 0?new Vo(this.id+" cancelOrder "+k+" "+this.json(a)):new Vo(this.id+" cancelOrder "+this.json(a))}}}throw this.throwExactlyMatchedException(this.exceptions.exact,h,c),h!==void 0&&this.throwBroadlyMatchedException(this.exceptions.broad,h,c),new nS(c)}}}};const aL=ge,{ExchangeError:Sn,BadSymbol:oS,AuthenticationError:pr,InsufficientFunds:dS,InvalidOrder:vn,ArgumentsRequired:mc,OrderNotFound:oL,InvalidAddress:Ym,BadRequest:Si,RateLimitExceeded:cS,PermissionDenied:La,ExchangeNotAvailable:Qm,AccountSuspended:dL,OnMaintenance:cL}=de,{SIGNIFICANT_DIGITS:uL,DECIMAL_PLACES:Zm,TRUNCATE:Jm,ROUND:fL}=me;var G_=class extends aL{describe(){return this.deepExtend(super.describe(),{id:"bitvavo",name:"Bitvavo",countries:["NL"],rateLimit:60,version:"v2",certified:!0,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d"},urls:{logo:"https://user-images.githubusercontent.com/1294454/169202626-bd130fc5-fcf9-41bb-8d97-6093225c73cd.jpg",api:{public:"https://api.bitvavo.com",private:"https://api.bitvavo.com"},www:"https://bitvavo.com/",doc:"https://docs.bitvavo.com/",fees:"https://bitvavo.com/en/fees",referral:"https://bitvavo.com/?a=24F34952F7"},api:{public:{get:{time:1,markets:1,assets:1,"{market}/book":1,"{market}/trades":5,"{market}/candles":1,"ticker/price":1,"ticker/book":1,"ticker/24h":{cost:1,noMarket:25}}},private:{get:{account:1,order:1,orders:5,ordersOpen:{cost:1,noMarket:25},trades:5,balance:5,deposit:1,depositHistory:5,withdrawalHistory:5},post:{order:1,withdrawal:1},put:{order:1},delete:{order:1,orders:1}}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0025"),maker:this.parseNumber("0.002"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.0025")],[this.parseNumber("100000"),this.parseNumber("0.0020")],[this.parseNumber("250000"),this.parseNumber("0.0016")],[this.parseNumber("500000"),this.parseNumber("0.0012")],[this.parseNumber("1000000"),this.parseNumber("0.0010")],[this.parseNumber("2500000"),this.parseNumber("0.0008")],[this.parseNumber("5000000"),this.parseNumber("0.0006")],[this.parseNumber("10000000"),this.parseNumber("0.0005")],[this.parseNumber("25000000"),this.parseNumber("0.0004")]],maker:[[this.parseNumber("0"),this.parseNumber("0.0015")],[this.parseNumber("100000"),this.parseNumber("0.0010")],[this.parseNumber("250000"),this.parseNumber("0.0008")],[this.parseNumber("500000"),this.parseNumber("0.0006")],[this.parseNumber("1000000"),this.parseNumber("0.0005")],[this.parseNumber("2500000"),this.parseNumber("0.0004")],[this.parseNumber("5000000"),this.parseNumber("0.0004")],[this.parseNumber("10000000"),this.parseNumber("0.0003")],[this.parseNumber("25000000"),this.parseNumber("0.0003")]]}}},requiredCredentials:{apiKey:!0,secret:!0},exceptions:{exact:{101:Sn,102:Si,103:cS,104:cS,105:La,107:Qm,108:Qm,109:Qm,110:Si,200:Si,201:Si,202:Si,203:oS,204:Si,205:Si,206:Si,210:vn,211:vn,212:vn,213:vn,214:vn,215:vn,216:dS,217:vn,230:Sn,231:Sn,232:Si,233:vn,234:vn,235:Sn,236:Si,240:oL,300:pr,301:pr,302:pr,303:pr,304:pr,305:pr,306:pr,307:La,308:pr,309:pr,310:La,311:La,312:La,315:Si,317:dL,400:Sn,401:Sn,402:La,403:La,404:cL,405:Sn,406:Si,407:Sn,408:dS,409:Ym,410:Sn,411:Si,412:Ym,413:Ym,414:Sn},broad:{"start parameter is invalid":Si,"symbol parameter is invalid":oS,"amount parameter is invalid":vn,"orderId parameter is invalid":vn}},options:{"BITVAVO-ACCESS-WINDOW":1e4,fetchCurrencies:{expires:1e3}},precisionMode:uL,commonCurrencies:{MIOTA:"IOTA"}})}currencyToPrecision(e,t,s=void 0){return this.decimalToPrecision(t,0,this.currencies[e].precision,Zm)}amountToPrecision(e,t){return this.decimalToPrecision(t,Jm,this.markets[e].precision.amount,Zm)}priceToPrecision(e,t){return t=this.decimalToPrecision(t,fL,this.markets[e].precision.price,this.precisionMode),this.decimalToPrecision(t,Jm,8,Zm)}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeInteger(t,"time")}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=await this.fetchCurrenciesFromCache(e),i=this.indexBy(s,"symbol"),n=[];for(let r=0;r<t.length;r++){const a=t[r],o=this.safeString(a,"market"),d=this.safeString(a,"base"),c=this.safeString(a,"quote"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),l=this.safeString(a,"status"),p=this.safeValue(i,d);n.push({id:o,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:l==="trading",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeInteger(p,"decimals",8),price:this.safeInteger(a,"pricePrecision")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(a,"minOrderInBaseAsset"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(a,"minOrderInQuoteAsset"),max:void 0}},info:a})}return n}async fetchCurrenciesFromCache(e={}){const t=this.safeValue(this.options,"fetchCurrencies",{}),s=this.safeInteger(t,"timestamp"),i=this.safeInteger(t,"expires",1e3),n=this.milliseconds();if(s===void 0||n-s>i){const r=await this.publicGetAssets(e);this.options.fetchCurrencies=this.extend(t,{response:r,timestamp:n})}return this.safeValue(this.options.fetchCurrencies,"response")}async fetchCurrencies(e={}){const t=await this.fetchCurrenciesFromCache(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"symbol"),a=this.safeCurrencyCode(r),d=this.safeValue(n,"depositStatus")==="OK",u=this.safeValue(n,"withdrawalStatus")==="OK",h=d&&u,l=this.safeString(n,"name");s[a]={id:r,info:n,code:a,name:l,active:h,deposit:d,withdraw:u,fee:this.safeNumber(n,"withdrawalFee"),precision:this.safeInteger(n,"decimals",8),limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.safeNumber(n,"withdrawalMinAmount"),max:void 0}}}}return s}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id},n=await this.publicGetTicker24h(this.extend(i,t));return this.parseTicker(n,s)}parseTicker(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeSymbol(s,t,"-"),n=this.safeInteger(e,"timestamp"),r=this.safeString(e,"last"),a=this.safeString(e,"volume"),o=this.safeString(e,"volumeQuote"),d=this.safeString(e,"open");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:this.safeString(e,"bidSize"),ask:this.safeString(e,"ask"),askVolume:this.safeString(e,"askSize"),vwap:void 0,open:d,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:a,quoteVolume:o,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTicker24h(t);return this.parseTickers(s,e)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market:n.id};s!==void 0&&(r.limit=s),t!==void 0&&(r.start=t);const a=await this.publicGetMarketTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"price"),i=this.safeString(e,"amount"),n=this.safeInteger(e,"timestamp"),r=this.safeString(e,"side"),a=this.safeString2(e,"id","fillId"),o=this.safeString(e,"market"),d=this.safeSymbol(o,t,"-"),c=this.safeValue(e,"taker");let u;c!==void 0&&(u=c?"taker":"maker");const h=this.safeString(e,"fee");let l;if(h!==void 0){const m=this.safeString(e,"feeCurrency"),g=this.safeCurrencyCode(m);l={cost:h,currency:g}}const p=this.safeString(e,"orderId");return this.safeTrade({info:e,id:a,symbol:d,timestamp:n,datetime:this.iso8601(n),order:p,type:void 0,side:r,takerOrMaker:u,price:s,amount:i,cost:void 0,fee:l},t)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetAccount(e),s=this.safeValue(t,"fees"),i=this.safeNumber(s,"maker"),n=this.safeNumber(s,"taker"),r={};for(let a=0;a<this.symbols.length;a++){const o=this.symbols[a];r[o]={info:t,symbol:o,maker:i,taker:n,percentage:!0,tierBased:!0}}return r}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={market:i.id};t!==void 0&&(n.depth=t);const r=await this.publicGetMarketBook(this.extend(n,s)),a=this.parseOrderBook(r,i.symbol);return a.nonce=this.safeInteger(r,"nonce"),a}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={market:r.id,interval:this.timeframes[t]};if(s!==void 0){const d=this.parseTimeframe(t);a.start=s,i===void 0&&(i=1440),a.end=this.sum(s,i*d*1e3)}i!==void 0&&(a.limit=i);const o=await this.publicGetMarketCandles(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"symbol"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"available"),a.used=this.safeString(i,"inOrder"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalance(e);return this.parseBalance(t)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={symbol:this.currency(e).id},n=await this.privateGetDeposit(this.extend(i,t)),r=this.safeString(n,"address"),a=this.safeString(n,"paymentId");return this.checkAddress(r),{currency:e,address:r,tag:a,network:void 0,info:n}}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={market:a.id,side:s,orderType:t},d=t==="market"||t==="stopLoss"||t==="takeProfit",c=t==="limit"||t==="stopLossLimit"||t==="takeProfitLimit",u=this.safeString(r,"timeInForce");let h=this.safeStringN(r,["triggerPrice","stopPrice","triggerAmount"]);const l=this.isPostOnly(d,!1,r),p=this.safeValue(r,"stopLossPrice"),m=this.safeValue(r,"takeProfitPrice");if(r=this.omit(r,["timeInForce","triggerPrice","stopPrice","stopLossPrice","takeProfitPrice"]),d){let w;if(n!==void 0?w=i*n:w=this.safeNumber2(r,"cost","amountQuote"),w!==void 0){const k=a.precision.price;o.amountQuote=this.decimalToPrecision(w,Jm,k,this.precisionMode)}else o.amount=this.amountToPrecision(e,i);r=this.omit(r,["cost","amountQuote"])}else c&&(o.price=this.priceToPrecision(e,n),o.amount=this.amountToPrecision(e,i));const g=m!==void 0||t==="takeProfit"||t==="takeProfitLimit";p!==void 0||h!==void 0&&!g||t==="stopLoss"||t==="stopLossLimit"?(p!==void 0&&(h=p),o.orderType=d?"stopLoss":"stopLossLimit"):g&&(m!==void 0&&(h=m),o.orderType=d?"takeProfit":"takeProfitLimit"),h!==void 0&&(o.triggerAmount=this.priceToPrecision(e,h),o.triggerType="price",o.triggerReference="lastTrade"),u!==void 0&&u!=="PO"&&(o.timeInForce=u),l&&(o.postOnly=!0);const b=await this.privatePostOrder(this.extend(o,r));return this.parseOrder(b,a)}async editOrder(e,t,s,i,n=void 0,r=void 0,a={}){await this.loadMarkets();const o=this.market(t);let d={};const c=this.safeNumber(a,"amountRemaining");if(a=this.omit(a,"amountRemaining"),r!==void 0&&(d.price=this.priceToPrecision(t,r)),n!==void 0&&(d.amount=this.amountToPrecision(t,n)),c!==void 0&&(d.amountRemaining=this.amountToPrecision(t,c)),d=this.extend(d,a),Object.keys(d).length){d.orderId=e,d.market=o.id;const u=await this.privatePutOrder(this.extend(d,a));return this.parseOrder(u,o)}else throw new mc(this.id+" editOrder() requires an amount argument, or a price argument, or non-empty params")}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new mc(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={orderId:e,market:i.id},r=await this.privateDeleteOrder(this.extend(n,s));return this.parseOrder(r,i)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;e!==void 0&&(i=this.market(e),s.market=i.id);const n=await this.privateDeleteOrders(this.extend(s,t));return this.parseOrders(n,i)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new mc(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={orderId:e,market:i.id},r=await this.privateGetOrder(this.extend(n,s));return this.parseOrder(r,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new mc(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={market:n.id};t!==void 0&&(r.start=t),s!==void 0&&(r.limit=s);const a=await this.privateGetOrders(this.extend(r,i));return this.parseOrders(a,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.market=r.id);const a=await this.privateGetOrdersOpen(this.extend(n,i));return this.parseOrders(a,r,t,s)}parseOrderStatus(e){const t={new:"open",canceled:"canceled",canceledAuction:"canceled",canceledSelfTradePrevention:"canceled",canceledIOC:"canceled",canceledFOK:"canceled",canceledMarketProtection:"canceled",canceledPostOnly:"canceled",filled:"closed",partiallyFilled:"open",expired:"canceled",rejected:"canceled",awaitingTrigger:"open"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"orderId"),i=this.safeInteger(e,"created"),n=this.safeString(e,"market");t=this.safeMarket(n,t,"-");const r=t.symbol,a=this.parseOrderStatus(this.safeString(e,"status")),o=this.safeString(e,"side"),d=this.safeString(e,"orderType"),c=this.safeString(e,"price"),u=this.safeString(e,"amount"),h=this.safeString(e,"amountRemaining"),l=this.safeString(e,"filledAmount"),p=this.safeString(e,"filledAmountQuote");let m;const g=this.safeNumber(e,"feePaid");if(g!==void 0){const T=this.safeString(e,"feeCurrency"),O=this.safeCurrencyCode(T);m={cost:g,currency:O}}const y=this.safeValue(e,"fills",[]),b=this.safeString(e,"timeInForce"),w=this.safeValue(e,"postOnly"),k=this.safeNumber(e,"triggerPrice");return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,symbol:r,type:d,timeInForce:b,postOnly:w,side:o,price:c,stopPrice:k,amount:u,cost:p,average:void 0,filled:l,remaining:h,status:a,fee:m,trades:y},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new mc(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={market:n.id};t!==void 0&&(r.start=t),s!==void 0&&(r.limit=s);const a=await this.privateGetTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={symbol:r.id,amount:this.currencyToPrecision(e,t),address:s};i!==void 0&&(a.paymentId=i);const o=await this.privatePostWithdrawal(this.extend(a,n));return this.parseTransaction(o,r)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.symbol=r.id),t!==void 0&&(n.start=t),s!==void 0&&(n.limit=s);const a=await this.privateGetWithdrawalHistory(this.extend(n,i));return this.parseTransactions(a,r,t,s,{type:"withdrawal"})}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.symbol=r.id),t!==void 0&&(n.start=t),s!==void 0&&(n.limit=s);const a=await this.privateGetDepositHistory(this.extend(n,i));return this.parseTransactions(a,r,t,s,{type:"deposit"})}parseTransactionStatus(e){const t={awaiting_processing:"pending",awaiting_email_confirmation:"pending",awaiting_bitvavo_inspection:"pending",approved:"pending",sending:"pending",in_mempool:"pending",processed:"pending",completed:"ok",canceled:"canceled"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const i=this.safeInteger(e,"timestamp"),n=this.safeString(e,"symbol"),r=this.safeCurrencyCode(n,t),a=this.parseTransactionStatus(this.safeString(e,"status")),o=this.safeNumber(e,"amount"),d=this.safeString(e,"address"),c=this.safeString(e,"txId");let u;const h=this.safeNumber(e,"fee");h!==void 0&&(u={cost:h,currency:r});let l;"success"in e||"address"in e?l="withdrawal":l="deposit";const p=this.safeString(e,"paymentId");return{info:e,id:void 0,txid:c,timestamp:i,datetime:this.iso8601(i),addressFrom:void 0,address:d,addressTo:d,tagFrom:void 0,tag:p,tagTo:p,type:l,amount:o,currency:r,status:a,updated:void 0,fee:u}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.omit(i,this.extractParams(e));let o="/"+this.version+"/"+this.implodeParams(e,i);const d=s==="GET"||s==="DELETE";if(d&&Object.keys(a).length&&(o+="?"+this.urlencode(a)),t==="private"){this.checkRequiredCredentials();let c="";d||Object.keys(a).length&&(r=this.json(a),c=r);const u=this.milliseconds().toString(),h=u+s+o+c,l=this.hmac(this.encode(h),this.encode(this.secret)),p=this.safeString(this.options,"BITVAVO-ACCESS-WINDOW","10000");n={"BITVAVO-ACCESS-KEY":this.apiKey,"BITVAVO-ACCESS-SIGNATURE":l,"BITVAVO-ACCESS-TIMESTAMP":u,"BITVAVO-ACCESS-WINDOW":p},d||(n["Content-Type"]="application/json")}return o=this.urls.api[t]+o,{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"errorCode"),u=this.safeString(a,"error");if(c!==void 0){const h=this.id+" "+r;throw this.throwBroadlyMatchedException(this.exceptions.broad,u,h),this.throwExactlyMatchedException(this.exceptions.exact,c,h),new Sn(h)}}calculateRateLimiterCost(e,t,s,i,n={},r={}){return"noMarket"in n&&!("market"in i)?n.noMarket:this.safeValue(n,"cost",1)}};const hL=ge,{ExchangeError:lL,BadRequest:uS,ArgumentsRequired:gc,InsufficientFunds:fS,InvalidOrder:pL}=de,{TICK_SIZE:mL}=me;var gL=class extends hL{describe(){return this.deepExtend(super.describe(),{id:"bkex",name:"BKEX",countries:["BVI"],rateLimit:100,version:"v2",certified:!1,has:{CORS:void 0,spot:void 0,margin:void 0,swap:void 0,future:void 0,option:void 0,addMargin:void 0,cancelAllOrders:void 0,cancelOrder:!0,cancelOrders:!0,createDepositAddress:void 0,createLimitOrder:void 0,createMarketOrder:void 0,createOrder:!0,editOrder:void 0,fetchAccounts:void 0,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowRate:void 0,fetchBorrowRateHistory:void 0,fetchBorrowRates:void 0,fetchBorrowRatesPerSymbol:void 0,fetchCanceledOrders:void 0,fetchClosedOrder:void 0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:void 0,fetchDepositAddressesByNetwork:void 0,fetchDeposits:!0,fetchFundingHistory:void 0,fetchFundingRate:void 0,fetchFundingRateHistory:void 0,fetchFundingRates:void 0,fetchIndexOHLCV:void 0,fetchL2OrderBook:void 0,fetchLedger:void 0,fetchLedgerEntry:void 0,fetchLeverageTiers:void 0,fetchMarginMode:!1,fetchMarketLeverageTiers:void 0,fetchMarkets:!0,fetchMarkOHLCV:void 0,fetchMyTrades:void 0,fetchOHLCV:!0,fetchOpenOrder:!0,fetchOpenOrders:!0,fetchOrder:!1,fetchOrderBook:!0,fetchOrderBooks:void 0,fetchOrders:void 0,fetchOrderTrades:void 0,fetchPosition:void 0,fetchPositionMode:!1,fetchPositions:void 0,fetchPositionsRisk:void 0,fetchPremiumIndexOHLCV:void 0,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTradingLimits:void 0,fetchTransactionFee:"emulated",fetchTransactionFees:!0,fetchTransactions:void 0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,privateAPI:!0,publicAPI:!0,reduceMargin:void 0,setLeverage:void 0,setMarginMode:void 0,setPositionMode:void 0,signIn:void 0,transfer:!1,withdraw:!1},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","1w":"1w"},urls:{logo:"https://user-images.githubusercontent.com/1294454/158043180-bb079a65-69e8-45a2-b393-f094d334e610.jpg",api:{public:"https://api.bkex.com",private:"https://api.bkex.com"},www:"https://www.bkex.com/",doc:["https://bkexapi.github.io/docs/api_en.htm"],fees:["https://www.bkex.com/help/instruction/33"]},api:{public:{get:{"/common/symbols":1,"/common/currencys":1,"/common/timestamp":1,"/q/kline":1,"/q/tickers":1,"/q/ticker/price":1,"/q/depth":1,"/q/deals":1,"/contract/common/brokerInfo":1,"/contract/q/index":1,"/contract/q/depth":1,"/contract/q/depthMerged":1,"/contract/q/trades":1,"/contract/q/kline":1,"/contract/q/ticker24hr":1}},private:{get:{"/u/api/info":1,"/u/account/balance":1,"/u/wallet/address":1,"/u/wallet/depositRecord":1,"/u/wallet/withdrawRecord":1,"/u/order/openOrders":1,"/u/order/openOrder/detail":1,"/u/order/historyOrders":1,"/contract/trade/getOrder":1,"/contract/trade/openOrders":1,"/contract/trade/historyOrders":1,"/contract/trade/myTrades":1,"/contract/trade/positions":1,"/contract/u/account":1},post:{"/u/account/transfer":1,"/u/wallet/withdraw":1,"/u/order/create":1,"/u/order/cancel":1,"/u/order/batchCreate":1,"/u/order/batchCancel":1,"/contract/trade/order":1,"/contract/trade/orderCancel":1,"/contract/trade/modifyMargin":1,"/contract/ws/dataStream/create":1,"/contract/ws/dataStream/update":1,"/contract/ws/dataStream/delete":1},delete:{}}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.0015"),taker:this.parseNumber("0.002")}},options:{timeframes:{spot:{},contract:{}},defaultType:"spot",networks:{TRX:"TRC-20",TRC20:"TRC-20",ETH:"ERC-20",ERC20:"ERC-20",BEP20:"BEP-20(BSC)"}},commonCurrencies:{},precisionMode:mL,exceptions:{exact:{1005:fS},broad:{"Not Enough balance":fS,"Order does not exist":pL,"System busy, please try again later":uS}}})}async fetchMarkets(e={}){const t=await this.publicGetCommonSymbols(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),[o,d]=a.split("_"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d);i.push({id:a,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,future:!1,swap:!1,option:!1,active:this.safeValue(r,"supportTrade"),contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"volumePrecision"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"pricePrecision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"minimumOrderSize"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(r,"minimumTradeVolume"),max:void 0}},info:r})}return i}async fetchCurrencies(e={}){const t=await this.publicGetCommonCurrencys(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.safeString(r,"name"),c=this.safeValue(r,"supportWithdraw"),u=this.safeValue(r,"supportDeposit"),h=this.safeValue(r,"supportTrade"),l=c&&u&&h;i[o]={id:a,code:o,name:d,deposit:u,withdraw:c,active:l,fee:this.safeNumber(r,"withdrawFee"),precision:void 0,limits:{amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0},withdraw:{min:this.safeNumber(r,"minWithdrawSingle"),max:this.safeNumber(r,"maxWithdrawSingle")}},info:r}}return i}async fetchTime(e={}){const t=await this.publicGetCommonTimestamp(e);return this.safeInteger(t,"data")}async fetchStatus(e={}){const t=await this.publicGetCommonTimestamp(e),s=this.safeInteger(t,"status"),i=this.safeInteger(t,"code"),n=this.safeInteger(t,"data");return{status:s===0&&i===0?"ok":s,updated:n,eta:void 0,url:void 0,info:t}}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,period:this.timeframes[t]};if(i!==void 0&&(a.size=i),s!==void 0){a.from=s,i===void 0&&(i=500);const c=this.parseTimeframe(t),u=i*c*1e3;a.to=this.sum(a.from,u)}const o=await this.publicGetQKline(a),d=this.safeValue(o,"data",[]);return this.parseOHLCVs(d,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"ts"),this.safeFloat(e,"open"),this.safeFloat(e,"high"),this.safeFloat(e,"low"),this.safeFloat(e,"close"),this.safeFloat(e,"volume")]}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetQTickers(this.extend(i,t)),r=this.safeValue(n,"data"),a=this.safeValue(r,0);return this.parseTicker(a,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};if(e!==void 0&&!Array.isArray(e))throw new uS(this.id+" fetchTickers () symbols argument should be an array");if(e!==void 0){const r=this.marketIds(e);s.symbol=r.join(",")}const i=await this.publicGetQTickers(this.extend(s,t)),n=this.safeValue(i,"data");return this.parseTickers(n,e,t)}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeInteger(e,"ts"),r=this.safeString(e,"close");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:r,last:r,previousClose:void 0,change:void 0,percentage:this.safeString(e,"change"),average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:this.safeString(e,"quoteVolume"),info:e},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.depth=Math.min(t,50));const r=await this.publicGetQDepth(this.extend(n,s)),a=this.safeValue(r,"data");return this.parseOrderBook(a,i.symbol,void 0,"bid","ask")}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.size=Math.min(s,50));const a=await this.publicGetQDeals(this.extend(r,i)),o=this.safeValue(a,"data");return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){const s=this.safeInteger(e,"ts"),i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const n=this.parseTradeSide(this.safeString(e,"direction")),r=this.safeNumber(e,"volume"),a=this.safeNumber(e,"price"),o=void 0,d="taker";let c=this.safeString(e,"tid");return c===void 0&&(c=this.syntheticTradeId(t,s,n,r,a,o,d)),this.safeTrade({id:c,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:void 0,type:o,side:n,takerOrMaker:d,price:a,amount:r,cost:void 0,fee:void 0,info:e},t)}parseTradeSide(e){const t={B:"buy",S:"sell"};return this.safeString(t,e,e)}syntheticTradeId(e=void 0,t=void 0,s=void 0,i=void 0,n=void 0,r=void 0,a=void 0){let o="";return t!==void 0&&(o=this.numberToString(t)+"-"+this.safeString(e,"id","_"),s!==void 0&&(o+="-"+s),r!==void 0&&(o+="-"+r),a!==void 0&&(o+="-"+a),i!==void 0&&(o+="-"+this.numberToString(i)),n!==void 0&&(o+="-"+this.numberToString(n))),o}async fetchBalance(e={}){await this.loadMarkets();const t=this.omit(e,"type"),s=await this.privateGetUAccountBalance(t),i=this.safeValue(s,"data"),n=this.safeValue(i,"WALLET",[]),r={info:n};for(let a=0;a<n.length;a++){const o=n[a],d=o.currency,c=this.safeCurrencyCode(d),u=this.account();u.free=this.safeNumber(o,"available"),u.used=this.safeNumber(o,"frozen"),u.total=this.safeNumber(o,"total"),r[c]=u}return this.safeBalance(r)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=await this.privateGetUWalletAddress(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseDepositAddress(r,s)}parseDepositAddress(e,t=void 0){const s=this.safeValue(e,0),i=this.safeString(s,"address"),n=this.safeString(s,"memo"),r=this.safeString(s,"currency");return t=this.safeCurrency(r,t),{currency:t.code,address:i,tag:n,network:void 0,info:e}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new gc(this.id+" fetchDeposits() requires code argument");await this.loadMarkets();const n=this.currency(e),r={currency:n.id};if(t!==void 0){r.startTime=t;const c=this.milliseconds();r.endTime=c}s!==void 0&&(r.Size=s);const a=await this.privateGetUWalletDepositRecord(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"data",[]);for(let c=0;c<d.length;c++)d[c].transactType="deposit";return this.parseTransactions(d,n,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new gc(this.id+" fetchWithdrawals() requires code argument");await this.loadMarkets();const n=this.currency(e),r={currency:n.id};if(t!==void 0){r.startTime=t;const c=this.milliseconds();r.endTime=c}s!==void 0&&(r.Size=s);const a=await this.privateGetUWalletWithdrawRecord(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"data",[]);for(let c=0;c<d.length;c++)d[c].transactType="withdrawal";return this.parseTransactions(d,n,t,s,i)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeNumber(e,"volume"),n=this.safeValue(e,"toAddress",{}),r=this.safeString(e,"fromAddress"),a=this.safeString(e,"hash"),o=this.safeString(e,"transactType"),d=this.safeInteger(e,"createTime"),c=this.safeString(e,"currency"),u=this.safeCurrencyCode(c,t),h=this.parseTransactionStatus(this.safeString(e,"status"));return{id:s,currency:u,amount:i,network:void 0,address:n,addressTo:n,addressFrom:r,tag:void 0,tagTo:void 0,tagFrom:void 0,status:h,type:o,updated:void 0,txid:a,timestamp:d,datetime:this.iso8601(d),fee:{currency:u,cost:void 0},info:e}}parseTransactionStatus(e){const t={"-1":"failed",0:"ok",3:"pending",5:"pending"};return this.safeString(t,e,e)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=s==="buy"?"BID":"ASK",d={symbol:a.id,type:t.toUpperCase(),volume:this.amountToPrecision(e,i),direction:o};t!=="market"&&n!==void 0&&(d.price=this.priceToPrecision(e,n));const c=await this.privatePostUOrderCreate(this.extend(d,r));return this.parseOrder(c,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=t!==void 0?this.market(t):void 0,n={orderId:e},r=await this.privatePostUOrderCancel(this.extend(n,s));return this.parseOrder(r,i)}async cancelOrders(e,t=void 0,s={}){if(!Array.isArray(e))throw new gc(this.id+" cancelOrders() ids argument should be an array");await this.loadMarkets();const i={orders:this.json(e)},n=await this.privatePostUOrderBatchCancel(this.extend(i,s)),r=this.safeValue(n,"data"),a=this.safeValue(r,"results"),o=t!==void 0?this.market(t):void 0;return this.parseOrders(a,o,void 0,void 0,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new gc(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.size=s);const a=await this.privateGetUOrderOpenOrders(this.extend(r,i)),o=this.safeValue(a,"data"),d=this.safeValue(o,"data");return this.parseOrders(d,n,t,s,i)}async fetchOpenOrder(e,t=void 0,s={}){const i={orderId:e},n=await this.privateGetUOrderOpenOrderDetail(this.extend(i,s)),r=this.safeValue(n,"data"),a=t!==void 0?this.market(t):void 0;return this.parseOrder(r,a)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new gc(this.id+" fetchClosedOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.size=s),t!==void 0&&(r.startTime=t);const a=await this.privateGetUOrderHistoryOrders(this.extend(r,i)),o=this.safeValue(a,"data"),d=this.safeValue(o,"data");return this.parseOrders(d,n,t,s,i)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"createdTime"),i=this.safeInteger(e,"updateTime"),n=this.safeString(e,"dealVolume"),r=this.parseOrderSide(this.safeString(e,"direction")),a=this.safeString2(e,"id","data"),o=this.safeString(e,"price"),d=this.safeString(e,"status"),c=this.safeString(e,"type"),u=this.parseOrderType(c);let h=!1;c==="LIMIT_MAKER"&&(h=!0);let l;s!==void 0&&(l=this.parseOrderStatus(d));const p=this.safeString(e,"symbol");t=this.safeMarket(p,t);const m=this.safeString(e,"totalVolume"),g=this.safeNumber(e,"stopPrice"),y=this.safeString(e,"dealAvgPrice");return this.safeOrder({id:a,clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:i,status:l,symbol:t.symbol,type:u,timeInForce:void 0,postOnly:h,side:r,price:o,stopPrice:g,average:y,amount:m,filled:n,remaining:void 0,cost:void 0,trades:void 0,fee:void 0,info:e},t)}parseOrderSide(e){const t={BID:"buy",ASK:"sell"};return this.safeString(t,e,e)}parseOrderStatus(e){const t={0:"open",1:"closed",2:"canceled",3:"open"};return this.safeString(t,e,e)}parseOrderType(e){const t={MARKET:"market",LIMIT:"limit",LIMIT_MAKER:"limit",STOP_LIMIT:"limit"};return this.safeString(t,e,e)}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetCommonCurrencys(t);return this.parseTransactionFees(s,e)}parseTransactionFees(e,t=void 0){const s=this.safeValue(e,"data"),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrency(a),d=this.safeString(o,"code");(t===void 0||this.inArray(d,t))&&(i[d]={withdraw:this.parseTransactionFee(r),deposit:void 0,info:r})}return i}parseTransactionFee(e,t=void 0){return this.safeNumber(e,"withdrawFee")}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/"+this.version+this.implodeParams(e,i);i=this.omit(i,this.extractParams(e));let o="";if(Object.keys(i).length&&(o=this.rawencode(this.keysort(i)),s==="GET"&&(a+="?"+o)),t==="private"){this.checkRequiredCredentials();const d=this.hmac(this.encode(o),this.encode(this.secret),"sha256");n={"Cache-Control":"no-cache","Content-type":"application/x-www-form-urlencoded",X_ACCESS_KEY:this.apiKey,X_SIGNATURE:d},s!=="GET"&&(r=o)}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0||this.safeValue(a,"msg")==="success")return;const u=this.safeString(a,"code");if(u!=="0"){const h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwBroadlyMatchedException(this.exceptions.broad,r,h),new lL(h)}}};const yL=ge,{TICK_SIZE:bL}=me,Ra=Se;var wL=class extends yL{describe(){return this.deepExtend(super.describe(),{id:"bl3p",name:"BL3P",countries:["NL"],rateLimit:1e3,version:"1",comment:"An exchange market by BitonicNL",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchOpenInterestHistory:!1,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/28501752-60c21b82-6feb-11e7-818b-055ee6d0e754.jpg",api:{rest:"https://api.bl3p.eu"},www:"https://bl3p.eu",doc:["https://github.com/BitonicNL/bl3p-api/tree/master/docs","https://bl3p.eu/api","https://bitonic.nl/en/api"]},api:{public:{get:["{market}/ticker","{market}/orderbook","{market}/trades"]},private:{post:["{market}/money/depth/full","{market}/money/order/add","{market}/money/order/cancel","{market}/money/order/result","{market}/money/orders","{market}/money/orders/history","{market}/money/trades/fetch","GENMKT/money/info","GENMKT/money/deposit_address","GENMKT/money/new_deposit_address","GENMKT/money/wallet/history","GENMKT/money/withdraw"]}},markets:{"BTC/EUR":{id:"BTCEUR",symbol:"BTC/EUR",base:"BTC",quote:"EUR",baseId:"BTC",quoteId:"EUR",maker:.0025,taker:.0025,type:"spot",spot:!0}},precisionMode:bL})}parseBalance(e){const t=this.safeValue(e,"data",{}),s=this.safeValue(t,"wallets",{}),i={info:t},n=Object.keys(this.currencies);for(let r=0;r<n.length;r++){const a=n[r],d=this.currency(a).id,c=this.safeValue(s,d,{}),u=this.safeValue(c,"available",{}),h=this.safeValue(c,"balance",{}),l=this.account();l.free=this.safeString(u,"value"),l.total=this.safeString(h,"value"),i[a]=l}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGENMKTMoneyInfo(e);return this.parseBalance(t)}parseBidAsk(e,t=0,s=1){const i=this.safeString(e,t),n=this.safeString(e,s);return[this.parseNumber(Ra.stringDiv(i,"100000.0")),this.parseNumber(Ra.stringDiv(n,"100000000.0"))]}async fetchOrderBook(e,t=void 0,s={}){const i=this.market(e),n={market:i.id},r=await this.publicGetMarketOrderbook(this.extend(n,s)),a=this.safeValue(r,"data");return this.parseOrderBook(a,i.symbol,void 0,"bids","asks","price_int","amount_int")}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeTimestamp(e,"timestamp"),n=this.safeString(e,"last"),r=this.safeValue(e,"volume",{});return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(r,"24h"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){const s=this.market(e),i={market:s.id},n=await this.publicGetMarketTicker(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"trade_id"),i=this.safeInteger(e,"date"),n=this.safeString(e,"price_int"),r=this.safeString(e,"amount_int");return t=this.safeMarket(void 0,t),this.safeTrade({id:s,info:e,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,type:void 0,side:void 0,order:void 0,takerOrMaker:void 0,price:Ra.stringDiv(n,"100000"),amount:Ra.stringDiv(r,"100000000"),cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){const n=this.market(e),r=await this.publicGetMarketTrades(this.extend({market:n.id},i));return this.parseTrades(r.data.trades,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostGENMKTMoneyInfo(e),s=this.safeValue(t,"data",{}),i=this.safeString(s,"trade_fee"),n=this.parseNumber(Ra.stringDiv(i,"100")),r={};for(let a=0;a<this.symbols.length;a++){const o=this.symbols[a];r[o]={info:s,symbol:o,maker:n,taker:n,percentage:!0,tierBased:!1}}return r}async createOrder(e,t,s,i,n=void 0,r={}){const a=this.market(e),o=this.numberToString(i),d=this.numberToString(n),c={market:a.id,amount_int:parseInt(Ra.stringMul(o,"100000000")),fee_currency:a.quote,type:s==="buy"?"bid":"ask"};t==="limit"&&(c.price_int=parseInt(Ra.stringMul(d,"100000.0")));const u=await this.privatePostMarketMoneyOrderAdd(this.extend(c,r)),h=this.safeString(u.data,"order_id");return{info:u,id:h}}async cancelOrder(e,t=void 0,s={}){const i={order_id:e};return await this.privatePostMarketMoneyOrderCancel(this.extend(i,s))}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.implodeParams(e,i);let o=this.urls.api.rest+"/"+this.version+"/"+a;const d=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(d).length&&(o+="?"+this.urlencode(d));else{this.checkRequiredCredentials();const c=this.nonce();r=this.urlencode(this.extend({nonce:c},d));const u=this.base64ToBinary(this.secret),h=a+"\0"+r,l=this.hmac(this.encode(h),u,"sha512","base64");n={"Content-Type":"application/x-www-form-urlencoded","Rest-Key":this.apiKey,"Rest-Sign":l}}return{url:o,method:s,body:r,headers:n}}};const kL=ge,{ExchangeError:SL,AuthenticationError:vL,OrderNotFound:TL,InsufficientFunds:OL,ArgumentsRequired:IL}=de,{TICK_SIZE:xL}=me,If=Se;var _L=class extends kL{describe(){return this.deepExtend(super.describe(),{id:"blockchaincom",secret:void 0,name:"Blockchain.com",countries:["LX"],rateLimit:500,version:"v3",has:{CORS:!1,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchCanceledOrders:!0,fetchClosedOrders:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchL2OrderBook:!0,fetchL3OrderBook:!0,fetchLedger:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!1,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,fetchWithdrawalWhitelist:!0,transfer:!1,withdraw:!0},timeframes:void 0,urls:{logo:"https://user-images.githubusercontent.com/1294454/147515585-1296e91b-7398-45e5-9d32-f6121538533f.jpeg",test:{public:"https://testnet-api.delta.exchange",private:"https://testnet-api.delta.exchange"},api:{public:"https://api.blockchain.com/v3/exchange",private:"https://api.blockchain.com/v3/exchange"},www:"https://blockchain.com",doc:["https://api.blockchain.com/v3"],fees:"https://exchange.blockchain.com/fees"},api:{public:{get:{tickers:1,"tickers/{symbol}":1,symbols:1,"symbols/{symbol}":1,"l2/{symbol}":1,"l3/{symbol}":1}},private:{get:{fees:1,orders:1,"orders/{orderId}":1,trades:1,fills:1,deposits:1,"deposits/{depositId}":1,accounts:1,"accounts/{account}/{currency}":1,whitelist:1,"whitelist/{currency}":1,withdrawals:1,"withdrawals/{withdrawalId}":1},post:{orders:1,"deposits/{currency}":1,withdrawals:1},delete:{orders:1,"orders/{orderId}":1}}},fees:{trading:{feeSide:"get",tierBased:!0,percentage:!0,tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.004")],[this.parseNumber("10000"),this.parseNumber("0.0022")],[this.parseNumber("50000"),this.parseNumber("0.002")],[this.parseNumber("100000"),this.parseNumber("0.0018")],[this.parseNumber("500000"),this.parseNumber("0.0018")],[this.parseNumber("1000000"),this.parseNumber("0.0018")],[this.parseNumber("2500000"),this.parseNumber("0.0018")],[this.parseNumber("5000000"),this.parseNumber("0.0016")],[this.parseNumber("25000000"),this.parseNumber("0.0014")],[this.parseNumber("100000000"),this.parseNumber("0.0011")],[this.parseNumber("500000000"),this.parseNumber("0.0008")],[this.parseNumber("1000000000"),this.parseNumber("0.0006")]],maker:[[this.parseNumber("0"),this.parseNumber("0.002")],[this.parseNumber("10000"),this.parseNumber("0.0012")],[this.parseNumber("50000"),this.parseNumber("0.001")],[this.parseNumber("100000"),this.parseNumber("0.0008")],[this.parseNumber("500000"),this.parseNumber("0.0007000000000000001")],[this.parseNumber("1000000"),this.parseNumber("0.0006")],[this.parseNumber("2500000"),this.parseNumber("0.0005")],[this.parseNumber("5000000"),this.parseNumber("0.0004")],[this.parseNumber("25000000"),this.parseNumber("0.0003")],[this.parseNumber("100000000"),this.parseNumber("0.0002")],[this.parseNumber("500000000"),this.parseNumber("0.0001")],[this.parseNumber("1000000000"),this.parseNumber("0")]]}}},requiredCredentials:{apiKey:!1,secret:!0},precisionMode:xL,exceptions:{exact:{401:vL,404:TL},broad:{}}})}async fetchMarkets(e={}){const t=await this.publicGetSymbols(e),s=Object.keys(t),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeValue(t,r),o=this.safeString(a,"base_currency"),d=this.safeString(a,"counter_currency"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d),h=this.safeNumber(a,"id");let l;this.safeString(a,"status")==="open"?l=!0:l=!1;const m=this.safeString(a,"min_price_increment"),g=this.safeString(a,"min_price_increment_scale"),y=this.parsePrecision(g),b=If.stringMul(m,y),w=this.safeString(a,"lot_size"),k=this.safeString(a,"lot_size_scale"),T=this.parsePrecision(k),O=If.stringMul(w,T),x=this.safeString(a,"min_order_size"),C=this.safeString(a,"min_order_size_scale"),E=this.parsePrecision(C),P=If.stringMul(x,E),_=this.parseNumber(P);let S;if(S=this.safeString(a,"max_order_size"),S!=="0"){const I=this.safeString(a,"max_order_size_scale"),v=this.parsePrecision(I),N=If.stringMul(S,v);S=this.parseNumber(N)}else S=void 0;i.push({info:a,id:r,numericId:h,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:l,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(O),price:this.parseNumber(b)},limits:{leverage:{min:void 0,max:void 0},amount:{min:_,max:S},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}}})}return i}async fetchOrderBook(e,t=void 0,s={}){return await this.fetchL3OrderBook(e,t,s)}async fetchL3OrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.depth=t);const r=await this.publicGetL3Symbol(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"bids","asks","px","qty")}async fetchL2OrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.depth=t);const r=await this.publicGetL2Symbol(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"bids","asks","px","qty")}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t,"-"),n=this.safeString(e,"last_trade_price"),r=this.safeString(e,"volume_24h"),a=this.safeString(e,"price_24h");return this.safeTicker({symbol:i,timestamp:void 0,datetime:void 0,high:void 0,low:void 0,bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:a,close:void 0,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetTickersSymbol(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickers(t);return this.parseTickers(s,e)}parseOrderState(e){const t={OPEN:"open",REJECTED:"rejected",FILLED:"closed",CANCELED:"canceled",PART_FILLED:"open",EXPIRED:"expired"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"clOrdId"),i=this.safeStringLower(e,"ordType"),n=this.safeString(e,"ordStatus"),r=this.parseOrderState(n),a=this.safeStringLower(e,"side"),o=this.safeString(e,"symbol"),d=this.safeSymbol(o,t,"-"),c=this.safeString(e,"exOrdId"),u=i!=="market"?this.safeString(e,"price"):void 0,h=this.safeNumber(e,"avgPx"),l=this.safeInteger(e,"timestamp"),p=this.iso8601(l),m=this.safeString(e,"cumQty"),g=this.safeString(e,"leavesQty");return this.safeOrder({id:c,clientOrderId:s,datetime:p,timestamp:l,lastTradeTimestamp:void 0,status:r,symbol:d,type:i,timeInForce:void 0,side:a,price:u,average:h,amount:void 0,filled:m,remaining:g,cost:void 0,trades:[],fees:{},info:e})}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),d=this.safeString(r,"ordType",t).toUpperCase(),c=this.safeString2(r,"clientOrderId","clOrdId",this.uuid16());r=this.omit(r,["ordType","clientOrderId","clOrdId"]);const u={ordType:d,symbol:a.id,side:s.toUpperCase(),orderQty:this.amountToPrecision(e,i),clOrdId:c},h=this.safeValue2(r,"stopPx","stopPrice");if(r=this.omit(r,["stopPx","stopPrice"]),(d==="STOP"||d==="STOPLIMIT")&&h===void 0)throw new IL(this.id+" createOrder() requires a stopPx or stopPrice param for a "+d+" order");h!==void 0&&(d==="MARKET"?u.ordType="STOP":d==="LIMIT"&&(u.ordType="STOPLIMIT"));let l=!1,p=!1;(u.ordType==="LIMIT"||u.ordType==="STOPLIMIT")&&(l=!0),(u.ordType==="STOP"||u.ordType==="STOPLIMIT")&&(p=!0),l&&(u.price=this.priceToPrecision(e,n)),p&&(u.stopPx=this.priceToPrecision(e,h));const m=await this.privatePostOrders(this.extend(u,r));return this.parseOrder(m,a)}async cancelOrder(e,t=void 0,s={}){const i={orderId:e},n=await this.privateDeleteOrdersOrderId(this.extend(i,s));return{id:e,info:n}}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};if(e!==void 0){const n=this.marketId(e);s.symbol=n}const i=await this.privateDeleteOrders(this.extend(s,t));return{symbol:e,info:i}}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetFees(e),s=this.safeNumber(t,"makerRate"),i=this.safeNumber(t,"takerRate"),n={};for(let r=0;r<this.symbols.length;r++){const a=this.symbols[r];n[a]={info:t,symbol:a,maker:s,taker:i}}return n}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){const n="CANCELED";return await this.fetchOrdersByState(n,e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n="FILLED";return await this.fetchOrdersByState(n,e,t,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n="OPEN";return await this.fetchOrdersByState(n,e,t,s,i)}async fetchOrdersByState(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={status:e,limit:100};let a;t!==void 0&&(a=this.market(t),r.symbol=a.id);const o=await this.privateGetOrders(this.extend(r,n));return this.parseOrders(o,a,s,i)}parseTrade(e,t=void 0){const s=this.safeString(e,"exOrdId"),i=this.safeString(e,"tradeId"),n=this.safeString(e,"side").toLowerCase(),r=this.safeString(e,"symbol"),a=this.safeString(e,"price"),o=this.safeString(e,"qty"),d=this.safeInteger(e,"timestamp"),c=this.iso8601(d);t=this.safeMarket(r,t,"-");const u=t.symbol;let h;const l=this.safeString(e,"fee");if(l!==void 0){const p=t.quote;h={cost:l,currency:p}}return this.safeTrade({id:i,timestamp:d,datetime:c,symbol:u,order:s,type:void 0,side:n,takerOrMaker:void 0,price:a,amount:o,cost:void 0,fee:h,info:e},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};s!==void 0&&(n.limit=s);let r;e!==void 0&&(n.symbol=this.marketId(e),r=this.market(e));const a=await this.privateGetFills(this.extend(n,i));return this.parseTrades(a,r,t,s,i)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=await this.privatePostDepositsCurrency(this.extend(i,t)),r=this.safeString(n,"address");let a,o;r!==void 0&&([o,a]=r.split(":"));const d={info:n};return d.currency=s.code,d.address=o,a!==void 0&&(d.tag=a),d}parseTransactionState(e){const t={COMPLETED:"ok",REJECTED:"failed",PENDING:"pending",FAILED:"failed",REFUNDED:"refunded"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){let s,i;const n=this.safeNumber(e,"amount"),r=this.safeInteger(e,"timestamp"),a=this.safeString(e,"currency"),o=this.safeCurrencyCode(a,t),d=this.safeString(e,"state");"depositId"in e?(s="deposit",i=this.safeString(e,"depositId")):"withdrawalId"in e&&(s="withdrawal",i=this.safeString(e,"withdrawalId"));const c=s==="withdrawal"?this.safeNumber(e,"fee"):void 0;let u;c!==void 0&&(u={currency:o,cost:c});const h=this.safeString(e,"address"),l=this.safeString(e,"txhash");return{info:e,id:i,txid:l,timestamp:r,datetime:this.iso8601(r),network:void 0,addressFrom:void 0,address:h,addressTo:h,tagFrom:void 0,tag:void 0,tagTo:void 0,type:s,amount:n,currency:o,status:this.parseTransactionState(d),updated:void 0,comment:void 0,fee:u}}async fetchWithdrawalWhitelist(e={}){await this.loadMarkets();const t=await this.privateGetWhitelist(),s=[];for(let i=0;i<t.length;i++){const n=t[i];s.push({beneficiaryId:this.safeString(n,"whitelistId"),name:this.safeString(n,"name"),currency:this.safeString(n,"currency"),info:n})}return s}async fetchWithdrawalWhitelistByCurrency(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.privateGetWhitelistCurrency(this.extend(i,t)),r=[];for(let a=0;a<n.length;a++){const o=n[a];r.push({beneficiaryId:this.safeString(o,"whitelistId"),name:this.safeString(o,"name"),currency:this.safeString(o,"currency"),info:o})}return r}async withdraw(e,t,s,i=void 0,n={}){await this.loadMarkets();const r=this.currency(e),a={amount:t,currency:r.id,beneficiary:s,sendMax:!1},o=await this.privatePostWithdrawals(this.extend(a,n));return this.parseTransaction(o,r)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.from=t);let r;e!==void 0&&(r=this.currency(e));const a=await this.privateGetWithdrawals(this.extend(n,i));return this.parseTransactions(a,r,t,s)}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const i={withdrawalId:e},n=await this.privateGetWithdrawalsWithdrawalId(this.extend(i,s));return this.parseTransaction(n)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.from=t);let r;e!==void 0&&(r=this.currency(e));const a=await this.privateGetDeposits(this.extend(n,i));return this.parseTransactions(a,r,t,s)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const n={depositId:this.safeString(s,"depositId",e)},r=await this.privateGetDepositsDepositId(this.extend(n,s));return this.parseTransaction(r)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"account","primary");e=this.omit(e,"account");const s={account:t},i=await this.privateGetAccounts(this.extend(s,e)),n=this.safeValue(i,t);if(n===void 0)throw new SL(this.id+' fetchBalance() could not find the "'+t+'" account');const r={info:i};for(let a=0;a<n.length;a++){const o=n[a],d=this.safeString(o,"currency"),c=this.safeCurrencyCode(d),u=this.account();u.free=this.safeString(o,"available"),u.total=this.safeString(o,"balance"),r[c]=u}return this.safeBalance(r)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e},n=await this.privateGetOrdersOrderId(this.extend(i,s));return this.parseOrder(n)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a="/"+this.implodeParams(e,i);let o=this.urls.api[t]+a;const d=this.omit(i,this.extractParams(e));return t==="public"?Object.keys(d).length&&(o+="?"+this.urlencode(d)):t==="private"&&(this.checkRequiredCredentials(),n={"X-API-Token":this.secret},s==="GET"?Object.keys(d).length&&(o+="?"+this.urlencode(d)):(r=this.json(d),n["Content-Type"]="application/json")),{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"text");if(c!==void 0&&c==="Insufficient Balance")throw new OL(this.id+" "+r);const u=this.safeString(a,"status"),h=this.safeString(a,"error");if(e!==void 0){const l=this.id+" "+this.json(a);this.throwExactlyMatchedException(this.exceptions.exact,u,l),this.throwBroadlyMatchedException(this.exceptions.broad,h,l)}}};const CL=ge,{ExchangeError:ML,AuthenticationError:PL,DDoSProtection:AL,InvalidOrder:BL,InsufficientFunds:EL}=de,{TICK_SIZE:NL}=me,e0=Se;var VL=class extends CL{describe(){return this.deepExtend(super.describe(),{id:"btcalpha",name:"BTC-Alpha",countries:["US"],version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchDeposit:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchL2OrderBook:!0,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:void 0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!1},timeframes:{"5m":"5","15m":"15","30m":"30","1h":"60","4h":"240","1d":"D"},urls:{logo:"https://user-images.githubusercontent.com/1294454/42625213-dabaa5da-85cf-11e8-8f99-aa8f8f7699f0.jpg",api:{rest:"https://btc-alpha.com/api"},www:"https://btc-alpha.com",doc:"https://btc-alpha.github.io/api-docs",fees:"https://btc-alpha.com/fees/",referral:"https://btc-alpha.com/?r=123788"},api:{public:{get:["currencies/","pairs/","orderbook/{pair_name}","exchanges/","charts/{pair}/{type}/chart/"]},private:{get:["wallets/","orders/own/","order/{id}/","exchanges/own/","deposits/","withdraws/"],post:["order/","order-cancel/"]}},fees:{trading:{maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")},funding:{withdraw:{}}},commonCurrencies:{CBC:"Cashbery"},precisionMode:NL,exceptions:{exact:{},broad:{"Out of balance":EL}}})}async fetchMarkets(e={}){const t=await this.publicGetPairs(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"name"),a=this.safeString(n,"currency1"),o=this.safeString(n,"currency2"),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o),u=this.safeString(n,"price_precision"),h=this.parsePrecision(u),l=this.safeString(n,"minimum_order_size");s.push({id:r,symbol:d+"/"+c,base:d,quote:c,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(n,"amount_precision"))),price:this.parseNumber(this.parsePrecision(u))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.parseNumber(l),max:this.safeNumber(n,"maximum_order_size")},price:{min:this.parseNumber(h),max:void 0},cost:{min:this.parseNumber(e0.stringMul(h,l)),max:void 0}},info:n})}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair_name:i.id};t&&(n.limit_sell=t,n.limit_buy=t);const r=await this.publicGetOrderbookPairName(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"buy","sell","price","amount")}parseBidsAsks(e,t=0,s=1){const i=[];for(let n=0;n<e.length;n++){const r=e[n];r&&i.push(this.parseBidAsk(r,t,s))}return i}parseTrade(e,t=void 0){const s=this.safeString(e,"pair");t=this.safeMarket(s,t,"_");const i=this.safeString(e,"timestamp"),n=this.parseNumber(e0.stringMul(i,"1000000")),r=this.safeString(e,"price"),a=this.safeString(e,"amount"),o=this.safeString(e,"id"),d=this.safeString2(e,"my_side","type");return this.safeTrade({id:o,info:e,timestamp:n,datetime:this.iso8601(n),symbol:t.symbol,order:o,type:"limit",side:d,takerOrMaker:void 0,price:r,amount:a,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.pair=n.id),s!==void 0&&(r.limit=s);const a=await this.publicGetExchanges(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r=await this.privateGetDeposits(i);return this.parseTransactions(r,n,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.currency_id=n.id);const a=await this.privateGetWithdraws(this.extend(r,i));return this.parseTransactions(a,n,t,s,{type:"withdrawal"})}parseTransaction(e,t=void 0){const s=this.safeTimestamp(e,"timestamp"),i=this.safeString(e,"currency"),n=this.safeString(e,"status");return{id:this.safeString(e,"id"),info:e,timestamp:s,datetime:this.iso8601(s),network:void 0,address:void 0,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,currency:this.safeCurrencyCode(i,t),amount:this.safeNumber(e,"amount"),txid:void 0,type:void 0,status:this.parseTransactionStatus(n),comment:void 0,fee:void 0,updated:void 0}}parseTransactionStatus(e){const t={10:"pending",20:"pending",30:"ok",40:"failed",50:"canceled"};return this.safeString(t,e,e)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"time"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="5m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id,type:this.timeframes[t]};i!==void 0&&(a.limit=i),s!==void 0&&(a.since=parseInt(s/1e3));const o=await this.publicGetChartsPairTypeChart(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.used=this.safeString(i,"reserve"),a.total=this.safeString(i,"balance"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetWallets(e);return this.parseBalance(t)}parseOrderStatus(e){const t={1:"open",2:"canceled",3:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"pair");t=this.safeMarket(s,t,"_");const i=t.symbol,n=this.safeValue(e,"success",!1);let r;n?r=this.safeTimestamp(e,"date"):r=this.safeInteger(e,"date");const a=this.safeString(e,"price"),o=this.safeString(e,"amount"),d=this.safeString(e,"amount_filled"),c=this.safeString(e,"amount_original"),u=this.parseOrderStatus(this.safeString(e,"status")),h=this.safeString2(e,"oid","id"),l=this.safeValue(e,"trades"),p=this.safeString2(e,"my_side","type");return this.safeOrder({id:h,clientOrderId:void 0,datetime:this.iso8601(r),timestamp:r,status:u,symbol:i,type:"limit",timeInForce:void 0,postOnly:void 0,side:p,price:a,stopPrice:void 0,cost:void 0,amount:c,filled:d,remaining:o,trades:l,fee:void 0,info:e,lastTradeTimestamp:void 0,average:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={pair:a.id,type:s,amount:i,price:this.priceToPrecision(e,n)},d=await this.privatePostOrder(this.extend(o,r));if(!d.success)throw new BL(this.id+" "+this.json(d));const c=this.parseOrder(d,a),u=c.amount.toString();return i=e0.stringGt(u,"0")?c.amount:i,this.extend(c,{amount:this.parseNumber(i)})}async cancelOrder(e,t=void 0,s={}){const i={order:e};return await this.privatePostOrderCancel(this.extend(i,s))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetOrderId(this.extend(i,s));return this.parseOrder(n)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.pair=r.id),s!==void 0&&(n.limit=s);const a=await this.privateGetOrdersOwn(this.extend(n,i));return this.parseOrders(a,r,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"1"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"3"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};if(e!==void 0){const a=this.market(e);n.pair=a.id}s!==void 0&&(n.limit=s);const r=await this.privateGetExchangesOwn(this.extend(n,i));return this.parseTrades(r,void 0,t,s)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.urlencode(this.keysort(this.omit(i,this.extractParams(e))));let o=this.urls.api.rest+"/";if(e!=="charts/{pair}/{type}/chart/"&&(o+="v1/"),o+=this.implodeParams(e,i),n={Accept:"application/json"},t==="public")a.length&&(o+="?"+a);else{this.checkRequiredCredentials();let d=this.apiKey;s==="POST"?(n["Content-Type"]="application/x-www-form-urlencoded",r=a,d+=r):a.length&&(o+="?"+a),n["X-KEY"]=this.apiKey,n["X-SIGN"]=this.hmac(this.encode(d),this.encode(this.secret)),n["X-NONCE"]=this.nonce().toString()}return{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"error"),u=this.id+" "+r;if(c!==void 0&&(this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u)),e===401||e===403)throw new PL(u);if(e===429)throw new AL(u);if(!(e<400))throw new ML(u)}};const qL=ge,{ExchangeError:hS,InsufficientFunds:LL,InvalidOrder:t0,AuthenticationError:RL,PermissionDenied:FL,InvalidNonce:DL,OrderNotFound:lS,DDoSProtection:HL}=de,{TICK_SIZE:GL}=me,UL=Se;var $L=class extends qL{describe(){return this.deepExtend(super.describe(),{id:"btcbox",name:"BtcBox",countries:["JP"],rateLimit:1e3,version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:void 0,fetchTrades:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!1},urls:{logo:"https://user-images.githubusercontent.com/51840849/87327317-98c55400-c53c-11ea-9a11-81f7d951cc74.jpg",api:{rest:"https://www.btcbox.co.jp/api"},www:"https://www.btcbox.co.jp/",doc:"https://blog.btcbox.jp/en/archives/8762",fees:"https://support.btcbox.co.jp/hc/en-us/articles/360001235694-Fees-introduction"},api:{public:{get:["depth","orders","ticker"]},private:{post:["balance","trade_add","trade_cancel","trade_list","trade_view","wallet"]}},markets:{"BTC/JPY":{id:"btc",symbol:"BTC/JPY",base:"BTC",quote:"JPY",baseId:"btc",quoteId:"jpy",taker:this.parseNumber("0.0005"),maker:this.parseNumber("0.0005"),type:"spot",spot:!0},"ETH/JPY":{id:"eth",symbol:"ETH/JPY",base:"ETH",quote:"JPY",baseId:"eth",quoteId:"jpy",taker:this.parseNumber("0.0010"),maker:this.parseNumber("0.0010"),type:"spot",spot:!0},"LTC/JPY":{id:"ltc",symbol:"LTC/JPY",base:"LTC",quote:"JPY",baseId:"ltc",quoteId:"jpy",taker:this.parseNumber("0.0010"),maker:this.parseNumber("0.0010"),type:"spot",spot:!0},"BCH/JPY":{id:"bch",symbol:"BCH/JPY",base:"BCH",quote:"JPY",baseId:"bch",quoteId:"jpy",taker:this.parseNumber("0.0010"),maker:this.parseNumber("0.0010"),type:"spot",spot:!0}},precisionMode:GL,exceptions:{104:RL,105:FL,106:DL,107:t0,200:LL,201:t0,202:t0,203:lS,401:lS,402:HL}})}parseBalance(e){const t={info:e},s=Object.keys(this.currencies);for(let i=0;i<s.length;i++){const n=s[i],a=this.currency(n).id,o=a+"_balance";if(o in e){const d=this.account(),c=a+"_lock";d.free=this.safeString(e,o),d.used=this.safeString(e,c),t[n]=d}}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={};this.symbols.length>1&&(n.coin=i.baseId);const a=await this.publicGetDepth(this.extend(n,s));return this.parseOrderBook(a,i.symbol)}parseTicker(e,t=void 0){const s=this.milliseconds(),i=this.safeSymbol(void 0,t),n=this.safeString(e,"last");return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"vol"),quoteVolume:this.safeString(e,"volume"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={};this.symbols.length>1&&(i.coin=s.baseId);const r=await this.publicGetTicker(this.extend(i,t));return this.parseTicker(r,s)}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"date");t=this.safeMarket(void 0,t);const i=this.safeString(e,"tid"),n=this.safeString(e,"price"),r=this.safeString(e,"amount"),a=void 0,o=this.safeString(e,"type");return this.safeTrade({info:e,id:i,order:void 0,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:a,side:o,takerOrMaker:void 0,price:n,amount:r,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={};this.symbols.length>1&&(r.coin=n.baseId);const o=await this.publicGetOrders(this.extend(r,i));return this.parseTrades(o,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={amount:i,price:n,type:s,coin:a.baseId},d=await this.privatePostTradeAdd(this.extend(o,r));return this.parseOrder(d,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets(),t===void 0&&(t="BTC/JPY");const i=this.market(t),n={id:e,coin:i.baseId},r=await this.privatePostTradeCancel(this.extend(n,s));return this.parseOrder(r,i)}parseOrderStatus(e){const t={part:"open",all:"closed",cancelled:"canceled",closed:"closed",no:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"datetime");let n;i!==void 0&&(n=this.parse8601(e.datetime+"+09:00"));const r=this.safeString(e,"amount_original"),a=this.safeString(e,"amount_outstanding"),o=this.safeString(e,"price");let d=this.parseOrderStatus(this.safeString(e,"status"));d===void 0&&UL.stringEquals(a,"0")&&(d="closed");const c=void 0;t=this.safeMarket(void 0,t);const u=this.safeString(e,"type");return this.safeOrder({id:s,clientOrderId:void 0,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,amount:r,remaining:a,filled:void 0,side:u,type:void 0,timeInForce:void 0,postOnly:void 0,status:d,symbol:t.symbol,price:o,stopPrice:void 0,cost:void 0,trades:c,fee:void 0,info:e,average:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets(),t===void 0&&(t="BTC/JPY");const i=this.market(t),n=this.extend({id:e,coin:i.baseId},s),r=await this.privatePostTradeView(this.extend(n,s));return this.parseOrder(r,i)}async fetchOrdersByType(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets(),t===void 0&&(t="BTC/JPY");const r=this.market(t),a={type:e,coin:r.baseId},o=await this.privatePostTradeList(this.extend(a,n)),d=this.parseOrders(o,r,s,i);if(e==="open")for(let c=0;c<d.length;c++)d[c].status="open";return d}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByType("all",e,t,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByType("open",e,t,s,i)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.version+"/"+e;if(t==="public")Object.keys(i).length&&(a+="?"+this.urlencode(i));else{this.checkRequiredCredentials();const o=this.nonce().toString(),d=this.extend({key:this.apiKey,nonce:o},i),c=this.urlencode(d),u=this.hash(this.encode(this.secret));d.signature=this.hmac(this.encode(c),this.encode(u)),r=this.urlencode(d),n={"Content-Type":"application/x-www-form-urlencoded"}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0||e>=400)return;const c=this.safeValue(a,"result");if(c===void 0||c===!0)return;const u=this.safeValue(a,"code"),h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions,u,h),new hS(h)}async request(e,t="public",s="GET",i={},n=void 0,r=void 0,a={},o={}){let d=await this.fetch2(e,t,s,i,n,r,a,o);if(typeof d=="string"){if(d=this.strip(d),!this.isJsonEncodedObject(d))throw new hS(this.id+" "+d);d=JSON.parse(d)}return d}};const jL=ge,{TICK_SIZE:WL}=me,{ExchangeError:xf,NotSupported:s0,RequestTimeout:pS,DDoSProtection:_f,InvalidOrder:fs,InvalidAddress:i0,BadRequest:ct,InsufficientFunds:mS,OrderNotFound:zL,AuthenticationError:Cs,ExchangeNotAvailable:gS,ArgumentsRequired:Qr}=de,Zr=Se;var KL=class extends jL{describe(){return this.deepExtend(super.describe(),{id:"btcex",name:"BTCEX",countries:["CA"],version:"v1",certified:!1,pro:!1,requiredCredentials:{apiKey:!0,secret:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/173489620-d49807a4-55cd-4f4e-aca9-534921298bbf.jpg",www:"https://www.btcex.com/",api:{rest:"https://api.btcex.com"},doc:"https://docs.btcex.com/",fees:"https://support.btcex.com/hc/en-us/articles/4415995130647",referral:{url:"https://www.btcex.com/en-us/register?i=48biatg1",discount:.1}},has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!0,option:!0,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,editOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchClosedOrders:!0,fetchCurrencies:!1,fetchDepositAddress:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!1,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:void 0,fetchWithdrawal:!0,fetchWithdrawals:!0,signIn:!0,withdraw:!1},timeframes:{"15s":"15","1m":"60","5m":"300","15m":"900","1h":"3600","4h":"14400","1d":"86400","3d":"259200","1w":"604800","2w":"1209600","1M":"2592000"},api:{public:{get:["get_last_trades_by_currency","get_last_trades_by_instrument","get_order_book","tickers","get_instruments","get_tradingview_chart_data","cmc_spot_summary","cmc_spot_ticker","cmc_spot_orderbook","cmc_market_trades","cmc_contracts","cmc_contract_orderbook","coin_gecko_spot_pairs","coin_gecko_spot_ticker","coin_gecko_spot_orderbook","coin_gecko_market_trades","coin_gecko_contracts","coin_gecko_contract_orderbook"],post:["auth"]},private:{get:["get_deposit_record","get_withdraw_record","get_position","get_positions","get_open_orders_by_currency","get_open_orders_by_instrument","get_order_history_by_currency","get_order_history_by_instrument","get_order_state","get_user_trades_by_currency","get_user_trades_by_instrument","get_user_trades_by_order"],post:["logout","get_assets_info","add_withdraw_address","buy","sell","cancel","cancel_all_by_currency","cancel_all_by_instrument","close_position"],delete:[]}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")},margin:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")},perpetual:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},exceptions:{exact:{9999:xf,9900:gS,401:Cs,403:Cs,1e3:gS,1001:ct,2e3:Cs,2001:Cs,2002:Cs,2003:Cs,3e3:Cs,3002:Cs,3003:Cs,3004:ct,3005:s0,3007:Cs,3008:Cs,3009:Cs,3011:Cs,3012:Cs,3013:pS,3015:Cs,3016:Cs,3018:ct,3019:ct,3020:ct,3021:ct,3022:ct,3023:ct,3024:ct,3025:ct,3026:ct,3027:ct,3028:ct,3029:_f,3030:_f,3031:ct,3032:ct,3033:ct,3034:Cs,3035:ct,3036:ct,3037:ct,3038:ct,3039:ct,3040:Cs,3041:ct,4e3:ct,4001:i0,4002:i0,4003:ct,4004:s0,4005:xf,4006:mS,4007:ct,4008:s0,4009:i0,4010:ct,4011:ct,5001:fs,5002:zL,5003:fs,5004:fs,5005:fs,5006:fs,5007:fs,5008:fs,5009:fs,5010:fs,5011:fs,5012:fs,5013:fs,5014:fs,5109:fs,5135:fs,5901:fs,5902:fs,5903:fs,5904:fs,5905:fs,5906:fs,5907:mS,8e3:ct,8001:ct,8100:ct,8101:pS,8102:_f,8103:ct,8104:ct,8105:ct,8106:_f,8107:xf,11e3:ct},broad:{}},precisionMode:WL,options:{accountsByType:{wallet:"WALLET",spot:"SPOT",perpetual:"PERPETUAL",margin:"MARGIN",swap:"PERPETUAL",BTC:"BTC",ETH:"ETH"}},commonCurrencies:{}})}async fetchMarkets(e={}){const t=await this.publicGetGetInstruments(e),s=this.safeValue(t,"result",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"instrument_name"),o=this.safeString(r,"kind");let d=o;o==="perpetual"&&(d="swap");let c=this.safeString(r,"quote_currency");const u=this.safeString(r,"base_currency"),h=o==="perpetual",l=o==="spot",p=o==="margin",m=o==="option",g=o==="future",y=h||g||m;let b;(m||g)&&(c=this.safeString(r,"currency"),b=this.safeInteger(r,"expiration_timestamp"));let w,k,T;y&&(k=u,T=this.safeCurrencyCode(k));let O,x;m&&(O=this.safeString(r,"option_type"),x=this.safeNumber(r,"strike"));const C=this.safeCurrencyCode(c),E=this.safeCurrencyCode(u);let P;if(p?P=a:P=C+"/"+E,y&&(w=this.safeNumber(r,"contract_size"),P=P+":"+T,(g||m)&&(P=P+"-"+this.yymmdd(b),m))){const q=O==="call"?"C":"P";P=P+":"+this.numberToString(x)+":"+q}const _=this.safeNumber(r,"min_trade_amount"),S=this.safeNumber(r,"tick_size"),I=this.safeNumber(r,"maker_commission"),v=this.safeNumber(r,"taker_commission"),N=!(m||g);i.push({id:a,symbol:P,base:C,quote:E,baseId:c,quoteId:u,settleId:k,settle:T,type:d,maker:I,taker:v,percentage:N,spot:l,margin:p,swap:h,future:g,option:m,active:this.safeValue(r,"is_active"),contract:y,linear:y?!0:void 0,inverse:y?!1:void 0,contractSize:w,expiry:b,expiryDatetime:this.iso8601(b),strike:x,optionType:O,precision:{amount:_,price:S},limits:{leverage:{min:void 0,max:this.safeString(r,"leverage")},amount:{min:_,max:void 0},price:{min:S,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}parseTicker(e,t=void 0){const s=this.safeString(e,"instrument_name");t=this.safeMarket(s,t);const i=this.safeSymbol(s,t),n=this.safeInteger(e,"timestamp"),r=this.safeValue(e,"stats");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(r,"high"),low:this.safeString(r,"low"),bid:this.safeString(e,"best_bid_price"),bidVolume:this.safeString(e,"best_bid_amount"),ask:this.safeString(e,"best_ask_price"),askVolume:this.safeString(e,"best_ask_amount"),vwap:void 0,open:void 0,close:this.safeString(e,"last_price"),last:this.safeString(e,"last_price"),previousClose:void 0,change:void 0,percentage:this.safeString(r,"price_change"),average:void 0,baseVolume:this.safeString(r,"volume"),quoteVolume:this.safeString(r,"turnover"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={instrument_name:s.id},n=await this.publicGetTickers(this.extend(i,t)),r=this.safeValue(n,"result",{}),a=this.safeValue(r,0);return this.parseTicker(a,s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={instrument_name:i.id},r=await this.publicGetGetOrderBook(this.extend(n,s)),a=this.safeValue(r,"result",{}),o=this.safeInteger(a,"timestamp");return this.parseOrderBook(a,i.symbol,o)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"tick"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);i===void 0&&(i=10);const a={resolution:this.timeframes[t]};let o=r.id;if((r.spot||r.margin)&&(o=r.baseId+"-"+r.quoteId),a.instrument_name=o,s===void 0)a.end_timestamp=this.milliseconds(),a.start_timestamp=0;else{const h=this.parseTimeframe(t)*1e3;a.start_timestamp=s,a.end_timestamp=this.sum(a.start_timestamp,i*h)}const d=await this.publicGetGetTradingviewChartData(this.extend(a,n)),c=this.safeValue(d,"result",[]);return this.parseOHLCVs(c,r,t,s,i)}parseTrade(e,t=void 0){const s=this.safeString(e,"trade_id"),i=this.safeString(e,"instrument_name"),n=this.safeSymbol(i,t),r=this.safeInteger(e,"timestamp"),a=this.safeString(e,"direction"),o=this.safeString(e,"price"),d=this.safeString(e,"amount"),c=this.safeString(e,"role"),u=this.safeString(e,"fee");let h;if(u!==void 0){const l=this.safeString(e,"fee_coin_type"),p=this.safeCurrencyCode(l);h={cost:u,currency:p}}return this.safeTrade({info:e,id:s,timestamp:r,datetime:this.iso8601(r),symbol:n,order:this.safeString(e,"order_id"),type:this.safeString(e,"order_type"),side:a,takerOrMaker:c,price:o,amount:d,cost:void 0,fee:h},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={instrument_name:n.id};s!==void 0&&(r.count=s);const a=await this.publicGetGetLastTradesByInstrument(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"trades",[]);return this.parseTrades(d,n,t,s)}async signIn(e={}){let t=this.safeString(this.options,"accessToken");if(t!==void 0)return t;this.checkRequiredCredentials();const s={grant_type:"client_credentials",client_id:this.apiKey,client_secret:this.secret},i=await this.publicPostAuth(this.extend(s,e)),n=this.safeValue(i,"result");return t=this.safeString(n,"access_token"),this.options.accessToken=t,t}parseBalance(e){const t={info:e},s=Object.keys(e);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeValue(e,n);if(n==="WALLET"||n==="SPOT"){const a=this.safeValue(r,"details");if(a!==void 0)for(let o=0;o<a.length;o++){const d=a[o],c=this.safeString(d,"coin_type"),u=this.safeCurrencyCode(c),h=this.safeValue(t,u,this.account());h.free=this.safeString(d,"available"),h.used=this.safeString(d,"freeze"),h.total=this.safeString(d,"total"),t[u]=h}}else{const a="USDT",o=this.account();o.total=this.safeString(r,"wallet_balance"),o.free=this.safeString(r,"available_withdraw_funds"),t[a]=o}}return this.safeBalance(t)}async fetchBalance(e={}){await this.signIn(),await this.loadMarkets();const t=this.safeStringLower(e,"type","spot"),s=this.safeValue(this.options,"accountsByType",{}),i=this.safeString(s,t,t);e=this.omit(e,"type");const n={asset_type:[i]},r=await this.privatePostGetAssetsInfo(this.extend(n,e)),a=this.safeValue(r,"result",[]);return this.parseBalance(a)}parseOrderStatus(e){const t={open:"open",cancelled:"canceled",filled:"closed",rejected:"rejected"};return this.safeString(t,e,e)}parseTimeInForce(e){if(e==="-")return;const t={good_til_cancelled:"GTC",good_til_date:"GTD",fill_or_kill:"FOK",immediate_or_cancel:"IOC"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"creation_timestamp"),i=this.safeInteger(e,"last_update_timestamp"),n=this.safeString(e,"order_id"),r=this.safeString(e,"price"),a=this.safeString(e,"average_price"),o=this.safeString(e,"amount"),d=this.safeString(e,"filled_amount");let c;d!==void 0&&Zr.stringGt(d,"0")&&(c=i);const u=this.parseOrderStatus(this.safeString(e,"order_state")),h=this.safeString(e,"instrument_name");t=this.safeMarket(h,t);const l=this.safeStringLower(e,"direction");let p=this.safeString(e,"commission"),m;p!==void 0&&(p=Zr.stringAbs(p),m={cost:p,currency:t.base});const g=this.safeString(e,"order_type"),y=this.safeValue(e,"trades"),b=this.parseTimeInForce(this.safeString(e,"time_in_force")),w=this.safeValue(e,"trigger_price"),k=this.safeValue(e,"post_only");return this.safeOrder({info:e,id:n,clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:c,symbol:t.symbol,type:g,timeInForce:b,postOnly:k,side:l,price:r,stopPrice:w,amount:o,cost:void 0,average:a,filled:d,remaining:void 0,status:u,fee:m,trades:y},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privateGetGetOrderState(this.extend(i,s)),r=this.safeValue(n,"result");return this.parseOrder(r)}async createOrder(e,t,s,i,n=void 0,r={}){await this.signIn(),await this.loadMarkets();const a=this.market(e),o={instrument_name:a.id,amount:this.amountToPrecision(e,i),type:t};if(t==="limit"&&(o.price=this.priceToPrecision(e,n)),a.contract){const l=this.safeStringUpper(r,"timeInForce");l==="GTC"?o.time_in_force="good_till_cancelled":l==="FOK"?o.time_in_force="fill_or_kill":l==="IOC"&&(o.time_in_force="immediate_or_cancel");const p=t==="market",m=this.safeValue(r,"post_only",!1);this.isPostOnly(p,m,r)&&(o.post_only=!0),this.safeValue(r,"reduceOnly",!1)&&(o.reduce_only=!0),r=this.omit(r,["timeInForce","postOnly","reduceOnly"])}const d="privatePost"+this.capitalize(s),c=await this[d](this.extend(o,r)),u=this.safeValue(c,"result",{}),h=this.safeValue(u,"order");return this.parseOrder(h,a)}async cancelOrder(e,t=void 0,s={}){await this.signIn(),await this.loadMarkets();const i={order_id:e},n=await this.privatePostCancel(this.extend(i,s)),r=this.safeValue(n,"result",{});return this.parseOrder(r)}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new Qr(this.id+" cancelAllOrders() requires a symbol argument");await this.signIn(),await this.loadMarkets();const i={instrument_name:this.market(e).id};return await this.privatePostCancelAllByInstrument(this.extend(i,t))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Qr(this.id+" fetchOpenOrders() requires a symbol argument");await this.signIn(),await this.loadMarkets();const n=this.market(e),r={instrument_name:n.id},a=await this.privateGetGetOpenOrdersByInstrument(this.extend(r,i)),o=this.safeValue(a,"result",[]);return this.parseOrders(o,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Qr(this.id+" fetchClosedOrders() requires a symbol argument");await this.signIn(),await this.loadMarkets();const n=this.market(e),r={instrument_name:n.id};s!==void 0&&(r.count=s);const a=await this.privateGetGetOrderHistoryByInstrument(this.extend(r,i)),o=this.safeValue(a,"result",[]);return this.parseOrders(o,n,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){if(e===void 0)throw new Qr(this.id+" fetchOrderTrades() requires a id argument");await this.loadMarkets();const r={order_id:e};i!==void 0&&(r.count=i);const a=await this.privateGetGetUserTradesByOrder(this.extend(r,n)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"trades",[]);return this.parseTrades(d,void 0,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Qr(this.id+" fetchMyTrades() requires a id argument");await this.signIn(),await this.loadMarkets();const n={};let r;const a=this.market(e);n.instrument_name=a.id,t===void 0?r="privateGetGetUserTradesByInstrument":r="privateGetGetUserTradesByInstrumentAndTime",s!==void 0&&(n.count=s);const o=await this[r](this.extend(n,i)),d=this.safeValue(o,"result",{}),c=this.safeValue(d,"trades",[]);return this.parseTrades(c,a,t,s)}parsePosition(e,t=void 0){const s=this.safeString(e,"instrument_name");t=this.safeMarket(s,t);const i=this.safeString(e,"size");let n=this.safeString(e,"direction");n=n==="buy"?"long":"short";const r=this.safeString(e,"maintenance_margin"),a=this.safeString(e,"risk_level"),o=Zr.stringDiv(r,a),d=this.safeString(e,"mark_price"),c=Zr.stringMul(d,i),u=this.safeString(e,"floating_profit_loss"),h=this.safeString(e,"initial_margin"),l=Zr.stringMul(Zr.stringDiv(u,h),"100"),p=this.safeString(e,"margin_type");return{info:e,id:void 0,symbol:this.safeString(t,"symbol"),timestamp:void 0,datetime:void 0,initialMargin:this.parseNumber(h),initialMarginPercentage:this.parseNumber(Zr.stringDiv(h,c)),maintenanceMargin:this.parseNumber(r),maintenanceMarginPercentage:this.parseNumber(Zr.stringDiv(r,c)),entryPrice:this.safeNumber(e,"average_price"),notional:this.parseNumber(c),leverage:this.safeNumber(e,"leverage"),unrealizedPnl:this.parseNumber(u),contracts:this.parseNumber(i),contractSize:this.safeValue(t,"contractSize"),marginRatio:this.parseNumber(a),liquidationPrice:this.safeNumber(e,"liquid_price"),markPrice:this.parseNumber(d),collateral:this.parseNumber(o),marginType:p,side:n,percentage:this.parseNumber(l)}}async fetchPosition(e,t={}){await this.signIn(),await this.loadMarkets();const i={instrument_name:this.market(e).id},n=await this.privateGetGetPosition(this.extend(i,t)),r=this.safeValue(n,"result");return this.parsePosition(r)}async fetchPositions(e=void 0,t={}){await this.signIn(),await this.loadMarkets();const s={currency:"PERPETUAL"},i=await this.privateGetGetPositions(this.extend(s,t)),n=this.safeValue(i,"result");return this.parsePositions(n,e)}parseTransactionStatus(e){const t={deposit_confirmed:"ok",deposit_waiting_confirm:"pending",withdraw_init:"pending",withdraw_noticed_block_chain:"pending",withdraw_waiting_confirm:"pending",withdraw_confirmed:"ok",withdraw_failed:"failed",withdraw_auditing:"pending",withdraw_audit_reject:"failed"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"coin_type"),i=this.safeCurrencyCode(s,t),n=this.safeString(e,"id"),r=this.safeString(e,"tx_hash"),a=this.safeInteger(e,"create_time"),o=this.safeInteger(e,"update_time"),d=this.safeNumber(e,"amount"),c=this.safeString(e,"state");return{info:e,id:n,txid:r,timestamp:a,datetime:this.iso8601(a),network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,type:void 0,amount:d,currency:i,status:this.parseTransactionStatus(c),updated:o,fee:void 0}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Qr(this.id+" fetchDeposits() requires the code argument");await this.signIn(),await this.loadMarkets();const n=this.safeCurrency(e),r={coin_type:n.id},a=await this.privateGetGetDepositRecord(this.extend(r,i)),o=this.safeValue(a,"result",[]);return this.parseTransactions(o,n,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Qr(this.id+" fetchWithdrawals() requires the code argument");await this.signIn(),await this.loadMarkets();const n=this.safeCurrency(e),r={coin_type:n.id},a=await this.privateGetGetWithdrawRecord(this.extend(r,i)),o=this.safeValue(a,"result",[]);return this.parseTransactions(o,n,t,s,{type:"withdrawal"})}async fetchWithdrawal(e,t=void 0,s={}){if(t===void 0)throw new Qr(this.id+" fetchWithdrawal() requires the code argument");await this.signIn(),await this.loadMarkets();const i=this.safeCurrency(t),n={coin_type:i.id,withdraw_id:e},r=await this.privateGetGetWithdrawRecord(this.extend(n,s)),a=this.safeValue(r,"result",[]),o=this.filterBy(a,"id",e),d=this.safeValue(o,0);return this.parseTransaction(d,i)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/api/"+this.version+"/"+t+"/"+e;if(t==="public"&&Object.keys(i).length&&(a+="?"+this.urlencode(i)),t==="private"){this.checkRequiredCredentials(),s==="GET"&&Object.keys(i).length&&(a+="?"+this.urlencode(i));const d=this.safeString(this.options,"accessToken");if(d===void 0)throw new Cs(this.id+" sign() requires access token");if(n={Authorization:"bearer "+d},s==="POST"&&(n["Content-Type"]="application/json",Object.keys(i).length)){const c={jsonrpc:"2.0",id:this.nonce(),method:"/"+t+"/"+e,params:i};r=this.json(c)}}return{url:this.urls.api.rest+a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeValue(a,"error");if(c){const u=this.id+" "+r,h=this.safeString(c,"code"),l=this.safeString(c,"message");throw this.throwExactlyMatchedException(this.exceptions.exact,h,u),this.throwBroadlyMatchedException(this.exceptions.broad,l,u),new xf(u)}}};const XL=ge,{ArgumentsRequired:yS,ExchangeError:bS,OrderNotFound:YL,InvalidOrder:qo,InsufficientFunds:QL,DDoSProtection:ZL,BadRequest:JL}=de,{TICK_SIZE:e8}=me,wS=Se;var t8=class extends XL{describe(){return this.deepExtend(super.describe(),{id:"btcmarkets",name:"BTC Markets",countries:["AU"],rateLimit:1e3,version:"v3",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,cancelOrders:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:"emulated",fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTime:!0,fetchTrades:!0,fetchTransactions:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/51840849/89731817-b3fb8480-da52-11ea-817f-783b08aaf32b.jpg",api:{public:"https://api.btcmarkets.net",private:"https://api.btcmarkets.net"},www:"https://btcmarkets.net",doc:["https://api.btcmarkets.net/doc/v3","https://github.com/BTCMarkets/API"]},api:{public:{get:["markets","markets/{marketId}/ticker","markets/{marketId}/trades","markets/{marketId}/orderbook","markets/{marketId}/candles","markets/tickers","markets/orderbooks","time"]},private:{get:["orders","orders/{id}","batchorders/{ids}","trades","trades/{id}","withdrawals","withdrawals/{id}","deposits","deposits/{id}","transfers","transfers/{id}","addresses","withdrawal-fees","assets","accounts/me/trading-fees","accounts/me/withdrawal-limits","accounts/me/balances","accounts/me/transactions","reports/{id}"],post:["orders","batchorders","withdrawals","reports"],delete:["orders","orders/{id}","batchorders/{ids}"],put:["orders/{id}"]}},timeframes:{"1m":"1m","1h":"1h","1d":"1d"},precisionMode:e8,exceptions:{3:qo,6:ZL,InsufficientFund:QL,InvalidPrice:qo,InvalidAmount:qo,MissingArgument:qo,OrderAlreadyCancelled:qo,OrderNotFound:YL,OrderStatusIsFinal:qo,InvalidPaginationParameter:JL},fees:{percentage:!0,tierBased:!0,maker:this.parseNumber("-0.0005"),taker:this.parseNumber("0.0020")},options:{fees:{AUD:{maker:this.parseNumber("0.0085"),taker:this.parseNumber("0.0085")}}}})}async fetchTransactionsWithMethod(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};i!==void 0&&(r.limit=i),s!==void 0&&(r.after=s);let a;t!==void 0&&(a=this.currency(t));const o=await this[e](this.extend(r,n));return this.parseTransactions(o,a,s,i)}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsWithMethod("privateGetTransfers",e,t,s,i)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsWithMethod("privateGetDeposits",e,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsWithMethod("privateGetWithdrawals",e,t,s,i)}parseTransactionStatus(e){const t={Accepted:"pending","Pending Authorization":"pending",Complete:"ok",Cancelled:"cancelled",Failed:"failed"};return this.safeString(t,e,e)}parseTransactionType(e){const t={Withdraw:"withdrawal",Deposit:"deposit"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.parse8601(this.safeString(e,"creationTime")),i=this.parse8601(this.safeString(e,"lastUpdate"));let n=this.parseTransactionType(this.safeStringLower(e,"type"));n==="withdraw"&&(n="withdrawal");const r=this.safeValue(e,"paymentDetail",{}),a=this.safeString(r,"txId");let o=this.safeString(r,"address"),d;if(o!==void 0){const w=o.split("?dt=");w.length>1&&(o=w[0],d=w[1])}const c=o,u=d,h=void 0,l=void 0,p=this.safeNumber(e,"fee"),m=this.parseTransactionStatus(this.safeString(e,"status")),g=this.safeString(e,"assetName"),y=this.safeCurrencyCode(g);let b=this.safeNumber(e,"amount");return p&&(b-=p),{id:this.safeString(e,"id"),txid:a,timestamp:s,datetime:this.iso8601(s),network:void 0,address:o,addressTo:c,addressFrom:h,tag:d,tagTo:u,tagFrom:l,type:n,amount:b,currency:y,status:m,updated:i,fee:{currency:y,cost:p},info:e}}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"baseAssetName"),a=this.safeString(n,"quoteAssetName"),o=this.safeString(n,"marketId"),d=this.safeCurrencyCode(r),c=this.safeCurrencyCode(a),u=d+"/"+c,h=this.safeValue(this.safeValue(this.options,"fees",{}),c,this.fees),l=this.parseNumber(this.parsePrecision(this.safeString(n,"priceDecimals"))),p=this.safeNumber(n,"minOrderAmount"),m=this.safeNumber(n,"maxOrderAmount");let g;c==="AUD"&&(g=l),s.push({id:o,symbol:u,base:d,quote:c,settle:void 0,baseId:r,quoteId:a,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,taker:h.taker,maker:h.maker,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(n,"amountDecimals"))),price:l},limits:{leverage:{min:void 0,max:void 0},amount:{min:p,max:m},price:{min:g,max:void 0},cost:{min:void 0,max:void 0}},info:n})}return s}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.parse8601(this.safeString(t,"timestamp"))}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"assetName"),r=this.safeCurrencyCode(n),a=this.account();a.used=this.safeString(i,"locked"),a.total=this.safeString(i,"balance"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountsMeBalances(e);return this.parseBalance(t)}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,0)),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={marketId:r.id,timeWindow:this.timeframes[t]};s!==void 0&&(a.from=this.iso8601(s)),i!==void 0&&(a.limit=i);const o=await this.publicGetMarketsMarketIdCandles(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={marketId:this.market(e).id},r=await this.publicGetMarketsMarketIdOrderbook(this.extend(n,s)),a=this.safeIntegerProduct(r,"snapshotId",.001),o=this.parseOrderBook(r,e,a);return o.nonce=this.safeInteger(r,"snapshotId"),o}parseTicker(e,t=void 0){const s=this.safeString(e,"marketId");t=this.safeMarket(s,t,"-");const i=t.symbol,n=this.parse8601(this.safeString(e,"timestamp")),r=this.safeString(e,"lastPrice"),a=this.safeString(e,"volume24h"),o=this.safeString(e,"volumeQte24h"),d=this.safeString(e,"price24h"),c=this.safeString(e,"pricePct24h");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high24h"),low:this.safeString(e,"low"),bid:this.safeString(e,"bestBid"),bidVolume:void 0,ask:this.safeString(e,"bestAsk"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:d,percentage:c,average:void 0,baseVolume:a,quoteVolume:o,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={marketId:s.id},n=await this.publicGetMarketsMarketIdTicker(this.extend(i,t));return this.parseTicker(n,s)}async fetchTicker2(e,t={}){await this.loadMarkets();const s=this.market(e),i={id:s.id},n=await this.publicGetMarketIdTick(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"timestamp")),i=this.safeString(e,"marketId");t=this.safeMarket(i,t,"-");const n=t.quote==="AUD"?t.quote:t.base;let r=this.safeString(e,"side");r==="Bid"?r="buy":r==="Ask"&&(r="sell");const a=this.safeString(e,"id"),o=this.safeString(e,"price"),d=this.safeString(e,"amount"),c=this.safeString(e,"orderId");let u;const h=this.safeString(e,"fee");h!==void 0&&(u={cost:h,currency:n});const l=this.safeStringLower(e,"liquidityType");return this.safeTrade({info:e,id:a,timestamp:s,datetime:this.iso8601(s),order:c,symbol:t.symbol,type:void 0,side:r,price:o,amount:d,cost:void 0,takerOrMaker:l,fee:u},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={marketId:n.id},a=await this.publicGetMarketsMarketIdTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={marketId:a.id,amount:this.amountToPrecision(e,i),side:s==="buy"?"Bid":"Ask"},d=t.toLowerCase(),c=this.safeValue(this.options,"orderTypes",{limit:"Limit",market:"Market",stop:"Stop","stop limit":"Stop Limit","take profit":"Take Profit"});o.type=this.safeString(c,d,t);let u=!1,h=!1;if(d==="limit"?u=!0:d==="stop limit"?(h=!0,u=!0):(d==="take profit"||d==="stop")&&(h=!0),u){if(n===void 0)throw new yS(this.id+" createOrder() requires a price argument for a "+t+"order");o.price=this.priceToPrecision(e,n)}if(h){const m=this.safeNumber(r,"triggerPrice");if(r=this.omit(r,"triggerPrice"),m===void 0)throw new yS(this.id+" createOrder() requires a triggerPrice parameter for a "+t+"order");o.triggerPrice=this.priceToPrecision(e,m)}const l=this.safeString(r,"clientOrderId");l!==void 0&&(o.clientOrderId=l),r=this.omit(r,"clientOrderId");const p=await this.privatePostOrders(this.extend(o,r));return this.parseOrder(p,a)}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();for(let n=0;n<e.length;n++)e[n]=parseInt(e[n]);const i={ids:e};return await this.privateDeleteBatchordersIds(this.extend(i,s))}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e};return await this.privateDeleteOrdersId(this.extend(i,s))}calculateFee(e,t,s,i,n,r="taker",a={}){const o=this.markets[e];let d,c;if(o.quote==="AUD"){d=o.quote;const l=this.numberToString(i),p=this.numberToString(n),m=wS.stringMul(l,p);c=this.costToPrecision(e,m)}else d=o.base,c=this.amountToPrecision(e,i);const u=o[r],h=wS.stringMul(this.numberToString(u),c);return{type:r,currency:d,rate:u,cost:parseFloat(this.feeToPrecision(e,h))}}parseOrderStatus(e){const t={Accepted:"open",Placed:"open","Partially Matched":"open","Fully Matched":"closed",Cancelled:"canceled","Partially Cancelled":"canceled",Failed:"rejected"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parse8601(this.safeString(e,"creationTime")),i=this.safeString(e,"marketId");t=this.safeMarket(i,t,"-");let n=this.safeString(e,"side");n==="Bid"?n="buy":n==="Ask"&&(n="sell");const r=this.safeStringLower(e,"type"),a=this.safeString(e,"price"),o=this.safeString(e,"amount"),d=this.safeString(e,"openAmount"),c=this.parseOrderStatus(this.safeString(e,"status")),u=this.safeString(e,"orderId"),h=this.safeString(e,"clientOrderId"),l=this.safeString(e,"timeInForce"),p=this.safeNumber(e,"triggerPrice"),m=this.safeValue(e,"postOnly");return this.safeOrder({info:e,id:u,clientOrderId:h,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,symbol:t.symbol,type:r,timeInForce:l,postOnly:m,side:n,price:a,stopPrice:p,cost:void 0,amount:o,filled:void 0,remaining:d,average:void 0,status:c,trades:void 0,fee:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetOrdersId(this.extend(i,s));return this.parseOrder(n)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={status:"all"};let r;e!==void 0&&(r=this.market(e),n.marketId=r.id),t!==void 0&&(n.after=t),s!==void 0&&(n.limit=s);const a=await this.privateGetOrders(this.extend(n,i));return this.parseOrders(a,r,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"open"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n=await this.fetchOrders(e,t,s,i);return this.filterBy(n,"status","closed")}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.marketId=r.id),t!==void 0&&(n.after=t),s!==void 0&&(n.limit=s);const a=await this.privateGetTrades(this.extend(n,i));return this.parseTrades(a,r,t,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets();const r=this.currency(e),a={currency_id:r.id,amount:this.currencyToPrecision(e,t)};e!=="AUD"&&(this.checkAddress(s),a.toAddress=s),i!==void 0&&(a.toAddress=s+"?dt="+i);const o=await this.privatePostWithdrawals(this.extend(a,n));return this.parseTransaction(o,r)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.version+"/"+this.implodeParams(e,i);const o=this.keysort(this.omit(i,this.extractParams(e)));if(t==="private"){this.checkRequiredCredentials();const c=this.nonce().toString(),u=this.base64ToBinary(this.encode(this.secret));let h=s+a+c;s==="GET"||s==="DELETE"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):(r=this.json(o),h+=r);const l=this.hmac(this.encode(h),u,"sha512","base64");n={Accept:"application/json","Accept-Charset":"UTF-8","Content-Type":"application/json","BM-AUTH-APIKEY":this.apiKey,"BM-AUTH-TIMESTAMP":c,"BM-AUTH-SIGNATURE":l}}else t==="public"&&Object.keys(o).length&&(a+="?"+this.urlencode(o));return{url:this.urls.api[t]+a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0){if("success"in a&&!a.success){const c=this.safeString(a,"errorCode"),u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions,c,u),new bS(u)}if(e>=400){const c=this.safeString(a,"code"),u=this.safeString(a,"message"),h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions,c,h),this.throwExactlyMatchedException(this.exceptions,u,h),new bS(h)}}}};const s8=ge,{ExchangeError:kS,ArgumentsRequired:i8}=de,{TICK_SIZE:n8}=me,n0=Se;var r8=class extends s8{describe(){return this.deepExtend(super.describe(),{id:"btctradeua",name:"BTC Trade UA",countries:["UA"],rateLimit:3e3,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,signIn:!0},urls:{referral:"https://btc-trade.com.ua/registration/22689",logo:"https://user-images.githubusercontent.com/1294454/27941483-79fc7350-62d9-11e7-9f61-ac47f28fcd96.jpg",api:{rest:"https://btc-trade.com.ua/api"},www:"https://btc-trade.com.ua",doc:"https://docs.google.com/document/d/1ocYA0yMy_RXd561sfG3qEPZ80kyll36HUxvCRe5GbhE/edit"},api:{public:{get:["deals/{symbol}","trades/sell/{symbol}","trades/buy/{symbol}","japan_stat/high/{symbol}"]},private:{post:["auth","ask/{symbol}","balance","bid/{symbol}","buy/{symbol}","my_orders/{symbol}","order/status/{id}","remove/order/{id}","sell/{symbol}"]}},precisionMode:n8,markets:{"BCH/UAH":{id:"bch_uah",symbol:"BCH/UAH",base:"BCH",quote:"UAH",baseId:"bch",quoteId:"uah",type:"spot",spot:!0},"BTC/UAH":{id:"btc_uah",symbol:"BTC/UAH",base:"BTC",quote:"UAH",baseId:"btc",quoteId:"uah",precision:{price:this.parseNumber("0.1")},limits:{amount:{min:this.parseNumber("0.0000000001")}},type:"spot",spot:!0},"DASH/BTC":{id:"dash_btc",symbol:"DASH/BTC",base:"DASH",quote:"BTC",baseId:"dash",quoteId:"btc",type:"spot",spot:!0},"DASH/UAH":{id:"dash_uah",symbol:"DASH/UAH",base:"DASH",quote:"UAH",baseId:"dash",quoteId:"uah",type:"spot",spot:!0},"DOGE/BTC":{id:"doge_btc",symbol:"DOGE/BTC",base:"DOGE",quote:"BTC",baseId:"doge",quoteId:"btc",type:"spot",spot:!0},"DOGE/UAH":{id:"doge_uah",symbol:"DOGE/UAH",base:"DOGE",quote:"UAH",baseId:"doge",quoteId:"uah",type:"spot",spot:!0},"ETH/UAH":{id:"eth_uah",symbol:"ETH/UAH",base:"ETH",quote:"UAH",baseId:"eth",quoteId:"uah",type:"spot",spot:!0},"ITI/UAH":{id:"iti_uah",symbol:"ITI/UAH",base:"ITI",quote:"UAH",baseId:"iti",quoteId:"uah",type:"spot",spot:!0},"KRB/UAH":{id:"krb_uah",symbol:"KRB/UAH",base:"KRB",quote:"UAH",baseId:"krb",quoteId:"uah",type:"spot",spot:!0},"LTC/BTC":{id:"ltc_btc",symbol:"LTC/BTC",base:"LTC",quote:"BTC",baseId:"ltc",quoteId:"btc",type:"spot",spot:!0},"LTC/UAH":{id:"ltc_uah",symbol:"LTC/UAH",base:"LTC",quote:"UAH",baseId:"ltc",quoteId:"uah",type:"spot",spot:!0},"NVC/BTC":{id:"nvc_btc",symbol:"NVC/BTC",base:"NVC",quote:"BTC",baseId:"nvc",quoteId:"btc",type:"spot",spot:!0},"NVC/UAH":{id:"nvc_uah",symbol:"NVC/UAH",base:"NVC",quote:"UAH",baseId:"nvc",quoteId:"uah",type:"spot",spot:!0},"PPC/BTC":{id:"ppc_btc",symbol:"PPC/BTC",base:"PPC",quote:"BTC",baseId:"ppc",quoteId:"btc",type:"spot",spot:!0},"SIB/UAH":{id:"sib_uah",symbol:"SIB/UAH",base:"SIB",quote:"UAH",baseId:"sib",quoteId:"uah",type:"spot",spot:!0},"XMR/UAH":{id:"xmr_uah",symbol:"XMR/UAH",base:"XMR",quote:"UAH",baseId:"xmr",quoteId:"uah",type:"spot",spot:!0},"ZEC/UAH":{id:"zec_uah",symbol:"ZEC/UAH",base:"ZEC",quote:"UAH",baseId:"zec",quoteId:"uah",type:"spot",spot:!0}},fees:{trading:{maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")}}})}async signIn(e={}){return await this.privatePostAuth(e)}parseBalance(e){const t={info:e},s=this.safeValue(e,"accounts",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(n,"balance"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id},r=await this.publicGetTradesBuySymbol(this.extend(n,s)),a=await this.publicGetTradesSellSymbol(this.extend(n,s)),o={bids:[],asks:[]};return r&&"list"in r&&(o.bids=r.list),a&&"list"in a&&(o.asks=a.list),this.parseOrderBook(o,i.symbol,void 0,"bids","asks","price","currency_trade")}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.milliseconds(),n={symbol:s,timestamp:i,datetime:this.iso8601(i),high:void 0,low:void 0,bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:void 0,last:void 0,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:void 0,info:e},r=e.length;if(r>0){const a=Math.max(r-48,0);for(let d=a;d<e.length;d++){const c=e[d];n.open===void 0&&(n.open=this.safeString(c,1));const u=this.safeString(c,2);(n.high===void 0||u!==void 0&&n0.stringLt(n.high,u))&&(n.high=u);const h=this.safeString(c,3);(n.low===void 0||h!==void 0&&n0.stringLt(n.low,h))&&(n.low=h);const l=this.safeString(c,5);n.baseVolume===void 0?n.baseVolume=l:n.baseVolume=n0.stringAdd(n.baseVolume,l)}const o=r-1;n.last=this.safeString(e[o],4),n.close=n.last}return this.safeTicker(n,t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetJapanStatHighSymbol(this.extend(i,t)),r=this.safeValue(n,"trades");return this.parseTicker(r,s)}convertMonthNameToString(e){const t={Jan:"01",Feb:"02",Mar:"03",Apr:"04",May:"05",Jun:"06",Jul:"07",Aug:"08",Sept:"09",Oct:"10",Nov:"11",Dec:"12"};return this.safeString(t,e)}parseExchangeSpecificDatetime(e){const t=e.split(" ");let s=t[0],i=t[1].replace(",","");i.length<2&&(i="0"+i);const n=t[2].replace(",","");if(s=s.replace(",",""),s=s.replace(".",""),s=this.convertMonthNameToString(s),!s)throw new kS(this.id+" parseTrade() unrecognized month name: "+e);const a=t[3].split(":");let o=this.safeString(a,0),d="00";const c=this.safeString(t,4);if(o==="noon")o="12";else{let m=parseInt(o);c!==void 0&&c[0]==="p"&&(m=12+m,m>23&&(m=0)),o=m.toString(),o.length<2&&(o="0"+o),d=this.safeString(a,1,"00"),d.length<2&&(d="0"+d)}const h=[n,s,i].join("-")+"T"+o+":"+d+":00",l=this.parse8601(h),p=parseInt(d);return p<11||p>2?l-72e5:l-108e5}parseTrade(e,t=void 0){const s=this.parseExchangeSpecificDatetime(this.safeString(e,"pub_date")),i=this.safeString(e,"id"),n="limit",r=this.safeString(e,"type"),a=this.safeString(e,"price"),o=this.safeString(e,"amnt_trade");return t=this.safeMarket(void 0,t),this.safeTrade({id:i,info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:n,side:r,order:void 0,takerOrMaker:void 0,price:a,amount:o,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.publicGetDealsSymbol(this.extend(r,i)),o=[];for(let d=0;d<a.length;d++)this.safeInteger(a[d],"id")%2&&o.push(a[d]);return this.parseTrades(o,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){if(t==="market")throw new kS(this.id+" createOrder() allows limit orders only");await this.loadMarkets();const a=this.market(e),o="privatePost"+this.capitalize(s)+"Id",d={count:i,currency1:a.quoteId,currency:a.baseId,price:n};return this[o](this.extend(d,r))}async cancelOrder(e,t=void 0,s={}){const i={id:e};return await this.privatePostRemoveOrderId(this.extend(i,s))}parseOrder(e,t=void 0){const s=this.milliseconds(),i=this.safeSymbol(void 0,t),n=this.safeString(e,"type"),r=this.safeString(e,"price"),a=this.safeString(e,"amnt_trade"),o=this.safeString(e,"amnt_trade");return this.safeOrder({id:this.safeString(e,"id"),clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,status:"open",symbol:i,type:void 0,timeInForce:void 0,postOnly:void 0,side:n,price:r,stopPrice:void 0,amount:a,filled:void 0,remaining:o,trades:void 0,info:e,cost:void 0,average:void 0,fee:void 0},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new i8(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.privatePostMyOrdersSymbol(this.extend(r,i)),o=this.safeValue(a,"your_open_orders");return this.parseOrders(o,n,t,s)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(o).length&&(a+=this.implodeParams(e,o));else{this.checkRequiredCredentials();const d=this.nonce();r=this.urlencode(this.extend({out_order_id:d,nonce:d},o));const c=r+this.secret;n={"public-key":this.apiKey,"api-sign":this.hash(this.encode(c),"sha256"),"Content-Type":"application/x-www-form-urlencoded"}}return{url:a,method:s,body:r,headers:n}}};const a8=ge,{BadRequest:o8,ExchangeError:SS,InsufficientFunds:d8,InvalidOrder:vS}=de,{TICK_SIZE:c8}=me,r0=Se;var u8=class extends a8{describe(){return this.deepExtend(super.describe(),{id:"btcturk",name:"BTCTurk",countries:["TR"],rateLimit:100,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},timeframes:{"1m":1,"15m":15,"30m":30,"1h":60,"4h":240,"1d":"1 day","1w":"1 week","1y":"1 year"},urls:{logo:"https://user-images.githubusercontent.com/51840849/87153926-efbef500-c2c0-11ea-9842-05b63612c4b9.jpg",api:{public:"https://api.btcturk.com/api/v2",private:"https://api.btcturk.com/api/v1",graph:"https://graph-api.btcturk.com/v1"},www:"https://www.btcturk.com",doc:"https://github.com/BTCTrader/broker-api-docs"},api:{public:{get:{orderbook:1,ticker:.1,trades:1,"server/exchangeinfo":1}},private:{get:{"users/balances":1,openOrders:1,allOrders:1,"users/transactions/trade":1},post:{order:1,cancelOrder:1},delete:{order:1}},graph:{get:{ohlcs:1,"klines/history":1}}},fees:{trading:{maker:this.parseNumber("0.0005"),taker:this.parseNumber("0.0009")}},exceptions:{exact:{FAILED_ORDER_WITH_OPEN_ORDERS:d8,FAILED_LIMIT_ORDER:vS,FAILED_MARKET_ORDER:vS}},precisionMode:c8})}async fetchMarkets(e={}){const t=await this.publicGetServerExchangeinfo(e),s=this.safeValue(t,"data"),i=this.safeValue(s,"symbols",[]),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"name"),d=this.safeString(a,"numerator"),c=this.safeString(a,"denominator"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),l=this.safeValue(a,"filters",[]);let p,m,g,y,b;for(let k=0;k<l.length;k++){const T=l[k];this.safeString(T,"filterType")==="PRICE_FILTER"&&(p=this.safeNumber(T,"minPrice"),m=this.safeNumber(T,"maxPrice"),g=this.safeNumber(T,"minAmount"),y=this.safeNumber(T,"maxAmount"),b=this.safeNumber(T,"minExchangeValue"))}const w=this.safeString(a,"status");n.push({id:o,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:w==="TRADING",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(a,"numeratorScale"))),price:this.parseNumber(this.parsePrecision(this.safeString(a,"denominatorScale")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:g,max:y},price:{min:p,max:m},cost:{min:b,max:void 0}},info:a})}return n}parseBalance(e){const t=this.safeValue(e,"data",[]),s={info:e,timestamp:void 0,datetime:void 0};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"asset"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(n,"balance"),o.free=this.safeString(n,"free"),o.used=this.safeString(n,"locked"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetUsersBalances(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pairSymbol:i.id},r=await this.publicGetOrderbook(this.extend(n,s)),a=this.safeValue(r,"data"),o=this.safeInteger(a,"timestamp");return this.parseOrderBook(a,i.symbol,o,"bids","asks",0,1)}parseTicker(e,t=void 0){const s=this.safeString(e,"pair");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeInteger(e,"timestamp"),r=this.safeString(e,"last");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:r,last:r,previousClose:void 0,change:this.safeString(e,"daily"),percentage:this.safeString(e,"dailyPercent"),average:this.safeString(e,"average"),baseVolume:this.safeString(e,"volume"),quoteVolume:void 0,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTicker(t),i=this.safeValue(s,"data");return this.parseTickers(i,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=await this.fetchTickers([e],t);return this.safeValue(s,e)}parseTrade(e,t=void 0){const s=this.safeInteger2(e,"date","timestamp"),i=this.safeString2(e,"tid","id"),n=this.safeString(e,"orderId"),r=this.safeString(e,"price"),a=r0.stringAbs(this.safeString(e,"amount")),o=this.safeString(e,"pair"),d=this.safeSymbol(o,t),c=this.safeString2(e,"side","orderType");let u;const h=this.safeString(e,"fee");if(h!==void 0){const l=this.safeString(e,"denominatorSymbol");u={cost:r0.stringAbs(h),currency:this.safeCurrencyCode(l)}}return this.safeTrade({info:e,id:i,order:n,timestamp:s,datetime:this.iso8601(s),symbol:d,type:void 0,side:c,takerOrMaker:void 0,price:r,amount:a,cost:void 0,fee:u},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pairSymbol:n.id};s!==void 0&&(r.last=s);const a=await this.publicGetTrades(this.extend(r,i)),o=this.safeValue(a,"data");return this.parseTrades(o,n,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"timestamp"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1h",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,resolution:this.safeValue(this.timeframes,t,t)},o=this.safeInteger(n,"until",this.milliseconds());if(a.to=parseInt(o/1e3),s!==void 0?a.from=parseInt(s/1e3):i===void 0&&(i=100),i!==void 0){if(t==="1y")throw new o8(this.id+' fetchOHLCV () does not accept a limit parameter when timeframe == "1y"');const u=this.parseTimeframe(t)*(i-1);if(s!==void 0){const h=parseInt(s/1e3)+u;a.to=Math.min(a.to,h)}else a.from=parseInt(o/1e3)-u}const d=await this.graphGetKlinesHistory(this.extend(a,n));return this.parseOHLCVs(d,r,t,s,i)}parseOHLCVs(e,t=void 0,s="1m",i=void 0,n=void 0){const r=[],a=this.safeValue(e,"t"),o=this.safeValue(e,"h"),d=this.safeValue(e,"o"),c=this.safeValue(e,"l"),u=this.safeValue(e,"c"),h=this.safeValue(e,"v");for(let m=0;m<a.length;m++){const g={timestamp:this.safeValue(a,m),high:this.safeValue(o,m),open:this.safeValue(d,m),low:this.safeValue(c,m),close:this.safeValue(u,m),volume:this.safeValue(h,m)};r.push(this.parseOHLCV(g,t))}const l=this.sortBy(r,0),p=i===void 0;return this.filterBySinceLimit(l,i,n,0,p)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={orderType:s,orderMethod:t,pairSymbol:a.id,quantity:this.amountToPrecision(e,i)};t!=="market"&&(o.price=this.priceToPrecision(e,n)),"clientOrderId"in r?o.newClientOrderId=r.clientOrderId:"newClientOrderId"in r||(o.newClientOrderId=this.uuid());const d=await this.privatePostOrder(this.extend(o,r)),c=this.safeValue(d,"data");return this.parseOrder(c,a)}async cancelOrder(e,t=void 0,s={}){const i={id:e};return await this.privateDeleteOrder(this.extend(i,s))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.pairSymbol=r.id);const a=await this.privateGetOpenOrders(this.extend(n,i)),o=this.safeValue(a,"data"),d=this.safeValue(o,"bids",[]),c=this.safeValue(o,"asks",[]);return this.parseOrders(this.arrayConcat(d,c),r,t,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pairSymbol:n.id};s!==void 0&&(r.last=s),t!==void 0&&(r.startTime=Math.floor(t/1e3));const a=await this.privateGetAllOrders(this.extend(r,i)),o=this.safeValue(a,"data");return this.parseOrders(o,n,t,s)}parseOrderStatus(e){const t={Untouched:"open",Partial:"open",Canceled:"canceled",Closed:"closed"};return this.safeString(t,e,e)}parseOrder(e,t){const s=this.safeString(e,"id"),i=this.safeString(e,"price"),n=this.safeString2(e,"amount","quantity"),r=r0.stringAbs(n),a=this.safeString(e,"leftAmount"),o=this.safeString(e,"pairSymbol"),d=this.safeSymbol(o,t),c=this.safeString(e,"type"),u=this.safeString(e,"method"),h=this.safeString(e,"orderClientId"),l=this.safeInteger2(e,"updateTime","datetime"),p=this.safeString(e,"status"),m=this.parseOrderStatus(p);return this.safeOrder({info:e,id:s,price:i,amount:r,remaining:a,filled:void 0,cost:void 0,average:void 0,status:m,side:c,type:u,clientOrderId:h,timestamp:l,datetime:this.iso8601(l),symbol:d,fee:void 0},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));const r=await this.privateGetUsersTransactionsTrade(),a=this.safeValue(r,"data");return this.parseTrades(a,n,t,s)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){if(this.id==="btctrader")throw new SS(this.id+" is an abstract base API for BTCExchange, BTCTurk");let a=this.urls.api[t]+"/"+e;if(s==="GET"||s==="DELETE"?Object.keys(i).length&&(a+="?"+this.urlencode(i)):r=this.json(i),t==="private"){this.checkRequiredCredentials();const o=this.nonce().toString(),d=this.base64ToBinary(this.secret),c=this.apiKey+o;n={"X-PCK":this.apiKey,"X-Stamp":o,"X-Signature":this.hmac(this.encode(c),d,"sha256","base64"),"Content-Type":"application/json"}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){const c=this.safeString(a,"code","0"),u=this.safeString(a,"message"),h=u===void 0?r:u;if(this.throwExactlyMatchedException(this.exceptions.exact,u,this.id+" "+h),c!=="0"&&c!=="SUCCESS")throw new SS(this.id+" "+h)}};const f8=ge,{AddressPending:h8,AuthenticationError:l8,ExchangeError:yc,NotSupported:TS,PermissionDenied:p8,ArgumentsRequired:OS}=de,{TICK_SIZE:m8}=me,a0=Se;var g8=class extends f8{describe(){return this.deepExtend(super.describe(),{id:"buda",name:"Buda",countries:["AR","CL","CO","PE"],rateLimit:1e3,version:"v2",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:void 0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/47380619-8a029200-d706-11e8-91e0-8a391fe48de3.jpg",api:{rest:"https://www.buda.com/api"},www:"https://www.buda.com",doc:"https://api.buda.com",fees:"https://www.buda.com/comisiones"},status:{status:"error",updated:void 0,eta:void 0,url:void 0},api:{public:{get:["pairs","markets","currencies","markets/{market}","markets/{market}/ticker","markets/{market}/volume","markets/{market}/order_book","markets/{market}/trades","currencies/{currency}/fees/deposit","currencies/{currency}/fees/withdrawal","tv/history"],post:["markets/{market}/quotations"]},private:{get:["balances","balances/{currency}","currencies/{currency}/balances","orders","orders/{id}","markets/{market}/orders","deposits","currencies/{currency}/deposits","withdrawals","currencies/{currency}/withdrawals","currencies/{currency}/receive_addresses","currencies/{currency}/receive_addresses/{id}"],post:["markets/{market}/orders","currencies/{currency}/deposits","currencies/{currency}/withdrawals","currencies/{currency}/simulated_withdrawals","currencies/{currency}/receive_addresses"],put:["orders/{id}"]}},timeframes:{"1m":"1","5m":"5","30m":"30","1h":"60","2h":"120","1d":"D","1w":"W"},fees:{trading:{tierBased:!0,percentage:!0,taker:.008,maker:.004,tiers:{taker:[[0,.008],[2e3,.007],[2e4,.006],[1e5,.005],[5e5,.004],[25e5,.003],[125e5,.002]],maker:[[0,.004],[2e3,.0035],[2e4,.003],[1e5,.0025],[5e5,.002],[25e5,.0015],[125e5,.001]]}}},precisionMode:m8,exceptions:{not_authorized:l8,forbidden:p8,invalid_record:yc,not_found:yc,parameter_missing:yc,bad_parameter:yc}})}async fetchCurrencyInfo(e,t=void 0){if(!t){const s=await this.publicGetCurrencies();t=this.safeValue(s,"currencies")}for(let s=0;s<t.length;s++){const i=t[s];if(i.id===e)return i}}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=this.safeValue(t,"markets",[]),i=await this.publicGetCurrencies(),n=this.safeValue(i,"currencies"),r=[];for(let a=0;a<s.length;a++){const o=s[a],d=this.safeString(o,"base_currency"),c=this.safeString(o,"quote_currency"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),l=await this.fetchCurrencyInfo(d,n),p=await this.fetchCurrencyInfo(c,n),m=this.safeValue(o,"minimum_order_amount",[]),g=this.safeString(o,"taker_fee"),y=this.safeString(o,"maker_fee");r.push({id:this.safeString(o,"id"),symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,taker:this.parseNumber(a0.stringDiv(g,"1000")),maker:this.parseNumber(a0.stringDiv(y,"1000")),precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(l,"input_decimals"))),price:this.parseNumber(this.parsePrecision(this.safeString(p,"input_decimals")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(m,0),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:o})}return r}async fetchCurrencies(e={}){const s=(await this.publicGetCurrencies()).currencies,i={};for(let n=0;n<s.length;n++){const r=s[n];if(!this.safeValue(r,"managed",!1))continue;const o=this.safeString(r,"id"),d=this.safeCurrencyCode(o),c=this.parseNumber(this.parsePrecision(this.safeString(r,"input_decimals"))),u=this.safeValue(r,"deposit_minimum",[]),h=this.safeValue(r,"withdrawal_minimum",[]),l=this.safeNumber(u,0),p=this.safeNumber(h,0);i[d]={id:o,code:d,info:r,name:void 0,active:!0,deposit:void 0,withdraw:void 0,fee:void 0,precision:c,limits:{amount:{min:c,max:void 0},deposit:{min:l,max:void 0},withdraw:{min:p}}}}return i}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s={},i={},n={};e===void 0&&(e=Object.keys(this.currencies));for(let r=0;r<e.length;r++){const a=e[r],d={currency:this.currency(a).id},c=await this.publicGetCurrenciesCurrencyFeesWithdrawal(d),u=await this.publicGetCurrenciesCurrencyFeesDeposit(d);s[a]=this.parseTransactionFee(c.fee),i[a]=this.parseTransactionFee(u.fee),n[a]={withdraw:c,deposit:u}}return{withdraw:s,deposit:i,info:n}}parseTransactionFee(e,t=void 0){return t===void 0&&(t=e.name),t==="withdrawal"&&(t="withdraw"),{type:t,currency:e.base[1],rate:e.percent,cost:parseFloat(e.base[0])}}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id},n=await this.publicGetMarketsMarketTicker(this.extend(i,t)),r=this.safeValue(n,"ticker");return this.parseTicker(r,s)}parseTicker(e,t=void 0){const s=this.milliseconds(),i=this.safeString(e,"market_id"),n=this.safeSymbol(i,t,"-"),r=this.safeValue(e,"last_price",[]),a=this.safeString(r,0);let o=this.safeString(e,"price_variation_24h");o=a0.stringMul(o,"100");const d=this.safeValue(e,"max_bid",[]),c=this.safeValue(e,"min_ask",[]),u=this.safeValue(e,"volume",[]);return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:void 0,low:void 0,bid:this.safeString(d,0),bidVolume:void 0,ask:this.safeString(c,0),askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:o,average:void 0,baseVolume:this.safeString(u,0),quoteVolume:void 0,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetMarketsMarketTrades(this.extend(r,i));return this.parseTrades(a.trades.entries,n,t,s)}parseTrade(e,t=void 0){let s,i,r,a,o,u;return t&&(u=t.symbol),Array.isArray(e)&&(s=this.safeInteger(e,0),r=this.safeString(e,1),a=this.safeString(e,2),i=this.safeString(e,3),o=this.safeString(e,4)),this.safeTrade({id:o,order:void 0,info:e,timestamp:s,datetime:this.iso8601(s),symbol:u,type:void 0,side:i,takerOrMaker:void 0,price:r,amount:a,cost:void 0,fee:void 0},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={market:i.id},r=await this.publicGetMarketsMarketOrderBook(this.extend(n,s)),a=this.safeValue(r,"order_book");return this.parseOrderBook(a,i.symbol)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);s===void 0&&(s=this.milliseconds()-864e5);const a={symbol:r.id,resolution:this.timeframes[t],from:s/1e3,to:this.seconds()},o=await this.publicGetTvHistory(this.extend(a,n));return this.parseTradingViewOHLCV(o,r,t,s,i)}parseBalance(e){const t={info:e},s=this.safeValue(e,"balances",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeString(n,"id"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(n.available_amount,0),o.total=this.safeString(n.amount,0),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalances(e);return this.parseBalance(t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:parseInt(e)},n=await this.privateGetOrdersId(this.extend(i,s)),r=this.safeValue(n,"order");return this.parseOrder(r)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));const r={market:n.id,per:s},a=await this.privateGetMarketsMarketOrders(this.extend(r,i)),o=this.safeValue(a,"orders");return this.parseOrders(o,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={state:"pending"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={state:"traded"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets(),s=s==="buy"?"Bid":"Ask";const o={market:this.market(e).id,price_type:t,type:s,amount:this.amountToPrecision(e,i)};t==="limit"&&(o.limit=this.priceToPrecision(e,n));const d=await this.privatePostMarketsMarketOrders(this.extend(o,r)),c=this.safeValue(d,"order");return this.parseOrder(c)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:parseInt(e),state:"canceling"},n=await this.privatePutOrdersId(this.extend(i,s)),r=this.safeValue(n,"order");return this.parseOrder(r)}parseOrderStatus(e){const t={traded:"closed",received:"open",canceling:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.parse8601(this.safeString(e,"created_at")),n=this.iso8601(i),r=this.safeString(e,"market_id"),a=this.safeSymbol(r,t,"-"),o=this.safeString(e,"price_type"),d=this.safeStringLower(e,"type"),c=this.parseOrderStatus(this.safeString(e,"state")),u=this.safeValue(e,"original_amount",[]),h=this.safeString(u,0),l=this.safeValue(e,"amount",[]),p=this.safeString(l,0),m=this.safeValue(e,"traded_amount",[]),g=this.safeString(m,0),y=this.safeValue(e,"total_exchanged",[]),b=this.safeString(y,0),w=this.safeValue(e,"limit",[]);let k=this.safeString(w,0);k===void 0&&w!==void 0&&(k=w);const T=this.safeValue(e,"paid_fee",[]),O=this.safeString(T,0);let x;if(O!==void 0){const C=this.safeString(T,1),E=this.safeCurrencyCode(C);x={cost:O,code:E,currency:E}}return this.safeOrder({info:e,id:s,clientOrderId:void 0,datetime:n,timestamp:i,lastTradeTimestamp:void 0,status:c,symbol:a,type:o,timeInForce:void 0,postOnly:void 0,side:d,price:k,stopPrice:void 0,average:void 0,cost:b,amount:h,filled:g,remaining:p,trades:void 0,fee:x},t)}isFiat(e){const t={ARS:!0,CLP:!0,COP:!0,PEN:!0};return this.safeValue(t,e,!1)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e);if(this.isFiat(e))throw new TS(this.id+" fetchDepositAddress() for fiat "+e+" is not supported");const i={currency:s.id},n=await this.privateGetCurrenciesCurrencyReceiveAddresses(this.extend(i,t)),r=this.safeValue(n,"receive_addresses"),a=[];for(let c=1;c<r.length;c++){const u=r[c];if(u.ready){const h=u.address;this.checkAddress(h),a.push(h)}}if(a.length<1)throw new h8(this.id+": there are no addresses ready for receiving "+e+", retry again later)");const d=a[0];return{currency:e,address:d,tag:void 0,network:void 0,info:r}}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e);if(this.isFiat(e))throw new TS(this.id+" createDepositAddress() of fiat for "+e+" is not supported");const i={currency:s.id},n=await this.privatePostCurrenciesCurrencyReceiveAddresses(this.extend(i,t)),r=this.safeString(n.receive_address,"address");return{currency:e,address:r,tag:void 0,info:n}}parseTransactionStatus(e){const t={rejected:"failed",confirmed:"ok",anulled:"canceled",retained:"canceled",pending_confirmation:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.parse8601(this.safeString(e,"created_at")),n=this.safeString(e,"currency"),r=this.safeCurrencyCode(n,t),a=parseFloat(e.amount[0]),o=parseFloat(e.fee[0]),d=e.fee[1],c=this.parseTransactionStatus(this.safeString(e,"state")),u="deposit_data"in e?"deposit":"withdrawal",h=this.safeValue(e,u+"_data",{}),l=this.safeValue(h,"target_address"),p=this.safeString(h,"tx_hash"),m=this.parse8601(this.safeString(h,"updated_at"));return{info:e,id:s,txid:p,timestamp:i,datetime:this.iso8601(i),network:void 0,address:l,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:u,amount:a,currency:r,status:c,updated:m,fee:{cost:o,rate:d}}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),e===void 0)throw new OS(this.id+" fetchDeposits() requires a currency code argument");const n=this.currency(e),r={currency:n.id,per:s},a=await this.privateGetCurrenciesCurrencyDeposits(this.extend(r,i)),o=this.safeValue(a,"deposits");return this.parseTransactions(o,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),e===void 0)throw new OS(this.id+" fetchWithdrawals() requires a currency code argument");const n=this.currency(e),r={currency:n.id,per:s},a=await this.privateGetCurrenciesCurrencyWithdrawals(this.extend(r,i)),o=this.safeValue(a,"withdrawals");return this.parseTransactions(o,n,t,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const a={currency:this.currency(e).id,amount:t,withdrawal_data:{target_address:s}},o=await this.privatePostCurrenciesCurrencyWithdrawals(this.extend(a,n)),d=this.safeValue(o,"withdrawal");return this.parseTransaction(d)}nonce(){return this.microseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));Object.keys(o).length&&(s==="GET"?a+="?"+this.urlencode(o):r=this.json(o));const d=this.urls.api.rest+"/"+this.version+"/"+a;if(t==="private"){this.checkRequiredCredentials();const c=this.nonce().toString(),u=[s,"/api/"+this.version+"/"+a];if(r){const p=this.stringToBase64(r);u.push(this.decode(p))}u.push(c);const h=u.join(" "),l=this.hmac(this.encode(h),this.encode(this.secret),"sha384");n={"X-SBTC-APIKEY":this.apiKey,"X-SBTC-SIGNATURE":l,"X-SBTC-NONCE":c,"Content-Type":"application/json"}}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&e>=400){const c=this.safeString(a,"code"),u=this.safeString(a,"message",r),h=this.id+" "+u;if(c!==void 0)throw this.throwExactlyMatchedException(this.exceptions,c,h),new yc(h)}}};const y8=ge,{TICK_SIZE:b8}=me,{AuthenticationError:Fa,ExchangeError:Es,ArgumentsRequired:Gs,PermissionDenied:Lo,InvalidOrder:Re,OrderNotFound:Cf,InsufficientFunds:Gn,BadRequest:Tt,RateLimitExceeded:bc,InvalidNonce:w8,NotSupported:Tn}=de,vi=Se;var U_=class extends y8{describe(){return this.deepExtend(super.describe(),{id:"bybit",name:"Bybit",countries:["VG"],version:"v2",userAgent:void 0,rateLimit:20,hostname:"bybit.com",pro:!0,certified:!0,has:{CORS:!0,spot:!0,margin:!0,swap:!0,future:!0,option:void 0,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!0,fetchBalance:!0,fetchBorrowInterest:!1,fetchBorrowRate:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchFundingRate:!0,fetchFundingRateHistory:!1,fetchIndexOHLCV:!0,fetchLedger:!0,fetchMarketLeverageTiers:!0,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenInterestHistory:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPositions:!0,fetchPremiumIndexOHLCV:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactions:void 0,fetchTransfers:!0,fetchWithdrawals:!0,setLeverage:!0,setMarginMode:!0,setPositionMode:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"1","3m":"3","5m":"5","15m":"15","30m":"30","1h":"60","2h":"120","4h":"240","6h":"360","12h":"720","1d":"D","1w":"W","1M":"M","1y":"Y"},urls:{test:{spot:"https://api-testnet.{hostname}",futures:"https://api-testnet.{hostname}",v2:"https://api-testnet.{hostname}",public:"https://api-testnet.{hostname}",private:"https://api-testnet.{hostname}"},logo:"https://user-images.githubusercontent.com/51840849/76547799-daff5b80-649e-11ea-87fb-3be9bac08954.jpg",api:{spot:"https://api.{hostname}",futures:"https://api.{hostname}",v2:"https://api.{hostname}",public:"https://api.{hostname}",private:"https://api.{hostname}"},www:"https://www.bybit.com",doc:["https://bybit-exchange.github.io/docs/inverse/","https://bybit-exchange.github.io/docs/linear/","https://github.com/bybit-exchange"],fees:"https://help.bybit.com/hc/en-us/articles/360039261154",referral:"https://www.bybit.com/register?affiliate_id=35953"},api:{public:{get:{"v2/public/orderBook/L2":1,"v2/public/kline/list":3,"v2/public/tickers":1,"v2/public/trading-records":1,"v2/public/symbols":1,"v2/public/mark-price-kline":3,"v2/public/index-price-kline":3,"v2/public/premium-index-kline":2,"v2/public/open-interest":1,"v2/public/big-deal":1,"v2/public/account-ratio":1,"v2/public/funding-rate":1,"v2/public/elite-ratio":1,"v2/public/funding/prev-funding-rate":1,"v2/public/risk-limit/list":1,"public/linear/kline":3,"public/linear/recent-trading-records":1,"public/linear/risk-limit":1,"public/linear/funding/prev-funding-rate":1,"public/linear/mark-price-kline":1,"public/linear/index-price-kline":1,"public/linear/premium-index-kline":1,"spot/v1/time":1,"spot/v1/symbols":1,"spot/quote/v1/depth":1,"spot/quote/v1/depth/merged":1,"spot/quote/v1/trades":1,"spot/quote/v1/kline":1,"spot/quote/v1/ticker/24hr":1,"spot/quote/v1/ticker/price":1,"spot/quote/v1/ticker/book_ticker":1,"spot/v3/public/symbols":1,"spot/v3/public/quote/depth":1,"spot/v3/public/quote/depth/merged":1,"spot/v3/public/quote/trades":1,"spot/v3/public/quote/kline":1,"spot/v3/public/quote/ticker/24hr":1,"spot/v3/public/quote/ticker/price":1,"spot/v3/public/quote/ticker/bookTicker":1,"spot/v3/public/server-time":1,"spot/v3/public/infos":1,"v2/public/time":1,"v3/public/time":1,"v2/public/announcement":1,"option/usdc/openapi/public/v1/order-book":1,"option/usdc/openapi/public/v1/symbols":1,"option/usdc/openapi/public/v1/tick":1,"option/usdc/openapi/public/v1/delivery-price":1,"option/usdc/openapi/public/v1/query-trade-latest":1,"option/usdc/openapi/public/v1/query-historical-volatility":1,"option/usdc/openapi/public/v1/all-tickers":1,"perpetual/usdc/openapi/public/v1/order-book":1,"perpetual/usdc/openapi/public/v1/symbols":1,"perpetual/usdc/openapi/public/v1/tick":1,"perpetual/usdc/openapi/public/v1/kline/list":1,"perpetual/usdc/openapi/public/v1/mark-price-kline":1,"perpetual/usdc/openapi/public/v1/index-price-kline":1,"perpetual/usdc/openapi/public/v1/premium-index-kline":1,"perpetual/usdc/openapi/public/v1/open-interest":1,"perpetual/usdc/openapi/public/v1/big-deal":1,"perpetual/usdc/openapi/public/v1/account-ratio":1,"perpetual/usdc/openapi/public/v1/prev-funding-rate":1,"perpetual/usdc/openapi/public/v1/risk-limit/list":1,"asset/v1/public/deposit/allowed-deposit-list":1,"contract/v3/public/copytrading/symbol/list":1,"derivatives/v3/public/order-book/L2":1,"derivatives/v3/public/kline":1,"derivatives/v3/public/tickers":1,"derivatives/v3/public/instruments-info":1,"derivatives/v3/public/mark-price-kline":1,"derivatives/v3/public/index-price-kline":1,"derivatives/v3/public/funding/history-funding-rate":1,"derivatives/v3/public/risk-limit/list":1,"derivatives/v3/public/delivery-price":1,"derivatives/v3/public/recent-trade":1,"derivatives/v3/public/open-interest":1}},private:{get:{"v2/private/order/list":5,"v2/private/order":5,"v2/private/stop-order/list":5,"v2/private/stop-order":1,"v2/private/position/list":25,"v2/private/position/fee-rate":40,"v2/private/execution/list":25,"v2/private/trade/closed-pnl/list":1,"v2/public/risk-limit/list":1,"v2/public/funding/prev-funding-rate":25,"v2/private/funding/prev-funding":25,"v2/private/funding/predicted-funding":25,"v2/private/account/api-key":5,"v2/private/account/lcp":1,"v2/private/wallet/balance":25,"v2/private/wallet/fund/records":25,"v2/private/wallet/withdraw/list":25,"v2/private/exchange-order/list":1,"private/linear/order/list":5,"private/linear/order/search":5,"private/linear/stop-order/list":5,"private/linear/stop-order/search":5,"private/linear/position/list":25,"private/linear/trade/execution/list":25,"private/linear/trade/closed-pnl/list":25,"public/linear/risk-limit":1,"private/linear/funding/predicted-funding":25,"private/linear/funding/prev-funding":25,"futures/private/order/list":5,"futures/private/order":5,"futures/private/stop-order/list":5,"futures/private/stop-order":5,"futures/private/position/list":25,"futures/private/execution/list":25,"futures/private/trade/closed-pnl/list":1,"spot/v1/account":2.5,"spot/v1/order":2.5,"spot/v1/open-orders":2.5,"spot/v1/history-orders":2.5,"spot/v1/myTrades":2.5,"spot/v1/cross-margin/order":10,"spot/v1/cross-margin/accounts/balance":10,"spot/v1/cross-margin/loan-info":10,"spot/v1/cross-margin/repay/history":10,"spot/v3/private/order":2.5,"spot/v3/private/open-orders":2.5,"spot/v3/private/history-orders":2.5,"spot/v3/private/my-trades":2.5,"spot/v3/private/account":2.5,"spot/v3/private/reference":2.5,"spot/v3/private/record":2.5,"spot/v3/private/cross-margin-orders":10,"spot/v3/private/cross-margin-account":10,"spot/v3/private/cross-margin-loan-info":10,"spot/v3/private/cross-margin-repay-history":10,"asset/v1/private/transfer/list":50,"asset/v3/private/transfer/inter-transfer/list/query":.84,"asset/v1/private/sub-member/transfer/list":50,"asset/v3/private/transfer/sub-member/list/query":.84,"asset/v3/private/transfer/sub-member-transfer/list/query":.84,"asset/v3/private/transfer/universal-transfer/list/query":.84,"asset/v1/private/sub-member/member-ids":50,"asset/v1/private/deposit/record/query":50,"asset/v1/private/withdraw/record/query":25,"asset/v1/private/coin-info/query":25,"asset/v3/private/coin-info/query":25,"asset/v1/private/asset-info/query":50,"asset/v1/private/deposit/address":100,"asset/v3/private/deposit/address/query":.17,"asset/v1/private/universal/transfer/list":50,"contract/v3/private/copytrading/order/list":1,"contract/v3/private/copytrading/position/list":1,"contract/v3/private/copytrading/wallet/balance":1,"contract/v3/private/position/limit-info":25,"contract/v3/private/order/unfilled-orders":1,"unified/v3/private/order/unfilled-orders":1,"unified/v3/private/order/list":1,"unified/v3/private/position/list":1,"unified/v3/private/execution/list":1,"unified/v3/private/delivery-record":1,"unified/v3/private/settlement-record":1,"unified/v3/private/account/wallet/balance":1,"unified/v3/private/account/transaction-log":1,"asset/v2/private/exchange/exchange-order-all":1,"unified/v3/private/account/borrow-history":1,"unified/v3/private/account/borrow-rate":1,"user/v3/private/frozen-sub-member":10,"user/v3/private/query-sub-members":5,"user/v3/private/query-api":5,"asset/v3/private/transfer/transfer-coin/list/query":.84,"asset/v3/private/transfer/account-coin/balance/query":.84,"asset/v3/private/transfer/asset-info/query":.84,"asset/v3/public/deposit/allowed-deposit-list/query":.17,"asset/v3/private/deposit/record/query":.17,"asset/v3/private/withdraw/record/query":.17},post:{"v2/private/order/create":30,"v2/private/order/cancel":30,"v2/private/order/cancelAll":300,"v2/private/order/replace":30,"v2/private/stop-order/create":30,"v2/private/stop-order/cancel":30,"v2/private/stop-order/cancelAll":300,"v2/private/stop-order/replace":30,"v2/private/position/change-position-margin":40,"v2/private/position/trading-stop":40,"v2/private/position/leverage/save":40,"v2/private/tpsl/switch-mode":40,"v2/private/position/switch-isolated":2.5,"v2/private/position/risk-limit":2.5,"v2/private/position/switch-mode":2.5,"private/linear/order/create":30,"private/linear/order/cancel":30,"private/linear/order/cancel-all":300,"private/linear/order/replace":30,"private/linear/stop-order/create":30,"private/linear/stop-order/cancel":30,"private/linear/stop-order/cancel-all":300,"private/linear/stop-order/replace":30,"private/linear/position/set-auto-add-margin":40,"private/linear/position/switch-isolated":40,"private/linear/position/switch-mode":40,"private/linear/tpsl/switch-mode":2.5,"private/linear/position/add-margin":40,"private/linear/position/set-leverage":40,"private/linear/position/trading-stop":40,"private/linear/position/set-risk":2.5,"futures/private/order/create":30,"futures/private/order/cancel":30,"futures/private/order/cancelAll":30,"futures/private/order/replace":30,"futures/private/stop-order/create":30,"futures/private/stop-order/cancel":30,"futures/private/stop-order/cancelAll":30,"futures/private/stop-order/replace":30,"futures/private/position/change-position-margin":40,"futures/private/position/trading-stop":40,"futures/private/position/leverage/save":40,"futures/private/position/switch-mode":40,"futures/private/tpsl/switch-mode":40,"futures/private/position/switch-isolated":40,"futures/private/position/risk-limit":2.5,"spot/v1/order":2.5,"spot/v1/cross-margin/loan":10,"spot/v1/cross-margin/repay":10,"spot/v3/private/order":2.5,"spot/v3/private/cancel-order":2.5,"spot/v3/private/cancel-orders":2.5,"spot/v3/private/cancel-orders-by-ids":2.5,"spot/v3/private/purchase":2.5,"spot/v3/private/redeem":2.5,"spot/v3/private/cross-margin-loan":10,"spot/v3/private/cross-margin-repay":10,"asset/v1/private/transfer":150,"asset/v3/private/transfer/inter-transfer":2.5,"asset/v1/private/sub-member/transfer":150,"asset/v1/private/withdraw":50,"asset/v3/private/withdraw/create":1,"asset/v1/private/withdraw/cancel":50,"asset/v3/private/withdraw/cancel":.84,"asset/v1/private/transferable-subs/save":3e3,"asset/v1/private/universal/transfer":1500,"asset/v3/private/transfer/sub-member-transfer":2.5,"asset/v3/private/transfer/transfer-sub-member-save":2.5,"asset/v3/private/transfer/universal-transfer":2.5,"user/v3/private/create-sub-member":10,"user/v3/private/create-sub-api":10,"user/v3/private/update-api":10,"user/v3/private/delete-api":10,"user/v3/private/update-sub-api":10,"user/v3/private/delete-sub-api":10,"option/usdc/openapi/private/v1/place-order":2.5,"option/usdc/openapi/private/v1/batch-place-order":2.5,"option/usdc/openapi/private/v1/replace-order":2.5,"option/usdc/openapi/private/v1/batch-replace-orders":2.5,"option/usdc/openapi/private/v1/cancel-order":2.5,"option/usdc/openapi/private/v1/batch-cancel-orders":2.5,"option/usdc/openapi/private/v1/cancel-all":2.5,"option/usdc/openapi/private/v1/query-active-orders":2.5,"option/usdc/openapi/private/v1/query-order-history":2.5,"option/usdc/openapi/private/v1/execution-list":2.5,"option/usdc/openapi/private/v1/query-transaction-log":2.5,"option/usdc/openapi/private/v1/query-wallet-balance":2.5,"option/usdc/openapi/private/v1/query-asset-info":2.5,"option/usdc/openapi/private/v1/query-margin-info":2.5,"option/usdc/openapi/private/v1/query-position":2.5,"option/usdc/openapi/private/v1/query-delivery-list":2.5,"option/usdc/openapi/private/v1/query-position-exp-date":2.5,"option/usdc/openapi/private/v1/mmp-modify":2.5,"option/usdc/openapi/private/v1/mmp-reset":2.5,"perpetual/usdc/openapi/private/v1/place-order":2.5,"perpetual/usdc/openapi/private/v1/replace-order":2.5,"perpetual/usdc/openapi/private/v1/cancel-order":2.5,"perpetual/usdc/openapi/private/v1/cancel-all":2.5,"perpetual/usdc/openapi/private/v1/position/leverage/save":2.5,"option/usdc/openapi/private/v1/session-settlement":2.5,"option/usdc/private/asset/account/setMarginMode":2.5,"perpetual/usdc/openapi/public/v1/risk-limit/list":2.5,"perpetual/usdc/openapi/private/v1/position/set-risk-limit":2.5,"perpetual/usdc/openapi/private/v1/predicted-funding":2.5,"contract/v3/private/copytrading/order/create":2.5,"contract/v3/private/copytrading/order/cancel":2.5,"contract/v3/private/copytrading/order/close":2.5,"contract/v3/private/copytrading/position/close":2.5,"contract/v3/private/copytrading/position/set-leverage":2.5,"contract/v3/private/copytrading/wallet/transfer":2.5,"contract/v3/private/copytrading/order/trading-stop":2.5,"unified/v3/private/order/create":2.5,"unified/v3/private/order/replace":2.5,"unified/v3/private/order/cancel":2.5,"unified/v3/private/order/create-batch":2.5,"unified/v3/private/order/replace-batch":2.5,"unified/v3/private/order/cancel-batch":2.5,"unified/v3/private/order/cancel-all":2.5,"unified/v3/private/position/set-leverage":2.5,"unified/v3/private/position/tpsl/switch-mode":2.5,"unified/v3/private/position/set-risk-limit":2.5,"unified/v3/private/position/trading-stop":2.5,"unified/v3/private/account/upgrade-unified-account":2.5},delete:{"spot/v1/order":2.5,"spot/v1/order/fast":2.5,"spot/order/batch-cancel":2.5,"spot/order/batch-fast-cancel":2.5,"spot/order/batch-cancel-by-ids":2.5}}},httpExceptions:{403:bc},exceptions:{exact:{"-10009":Tt,"-1004":Tt,"-1021":Tt,"-1103":Tt,"-1140":Re,"-1197":Re,"-2013":Re,"-2015":Fa,"-6017":Tt,"-6025":Tt,"-6029":Tt,5004:Es,7001:Tt,10001:Tt,10002:w8,10003:Fa,10004:Fa,10005:Lo,10006:bc,10007:Fa,10010:Lo,10016:Es,10017:Tt,10018:bc,10020:Lo,12201:Tt,131001:Gn,20001:Cf,20003:Re,20004:Re,20005:Re,20006:Re,20007:Re,20008:Re,20009:Re,20010:Re,20011:Re,20012:Re,20013:Re,20014:Re,20015:Re,20016:Re,20017:Re,20018:Re,20019:Re,20020:Re,20021:Re,20022:Tt,20023:Tt,20031:Tt,20070:Tt,20071:Tt,20084:Tt,30001:Tt,30003:Re,30004:Re,30005:Re,30007:Re,30008:Re,30009:Es,30010:Gn,30011:Lo,30012:Lo,30013:Lo,30014:Re,30015:Re,30016:Es,30017:Re,30018:Re,30019:Re,30020:Re,30021:Re,30022:Re,30023:Re,30024:Re,30025:Re,30026:Re,30027:Re,30028:Re,30029:Re,30030:Re,30031:Gn,30032:Re,30033:bc,30034:Cf,30035:bc,30036:Es,30037:Re,30041:Es,30042:Gn,30043:Re,30044:Re,30045:Re,30049:Gn,30050:Es,30051:Es,30052:Es,30054:Es,30057:Es,30063:Es,30067:Gn,30068:Es,30074:Re,30075:Re,30078:Es,33004:Fa,34026:Es,34036:Tt,35015:Tt,130006:Re,130021:Gn,130074:Re,3100116:Tt,3100198:Tt,3200300:Gn},broad:{"unknown orderInfo":Cf,"invalid api_key":Fa,oc_diff:Gn,new_oc:Gn,"openapi sign params error!":Fa}},precisionMode:b8,options:{createMarketBuyOrderRequiresPrice:!0,defaultType:"swap",defaultSubType:"linear",defaultSettle:"USDT",code:"BTC",recvWindow:5*1e3,timeDifference:0,adjustForTimeDifference:!1,brokerId:"CCXT",accountsByType:{spot:"SPOT",margin:"SPOT",future:"CONTRACT",swap:"CONTRACT",option:"OPTION",investment:"INVESTMENT",unified:"UNIFIED",funding:"FUND"},accountsById:{SPOT:"spot",MARGIN:"spot",CONTRACT:"contract",OPTION:"option",INVESTMENT:"investment",UNIFIED:"unified"},networks:{ERC20:"ETH",TRC20:"TRX",BEP20:"BSC",OMNI:"OMNI",SPL:"SOL"},networksById:{ETH:"ERC20",TRX:"TRC20",BSC:"BEP20",OMNI:"OMNI",SPL:"SOL"},defaultNetwork:"ERC20",defaultNetworks:{USDT:"TRC20"}},fees:{trading:{feeSide:"get",tierBased:!0,percentage:!0,taker:75e-5,maker:1e-4},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}}})}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchTime(e={}){const t=await this.publicGetV3PublicTime(e);return this.safeInteger(t,"time")}async fetchCurrencies(e={}){if(!this.checkRequiredCredentials(!1))return;const t=await this.privateGetAssetV3PrivateCoinInfoQuery(e),s=this.safeValue(t,"result",[]),i=this.safeValue(s,"rows",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"coin"),d=this.safeCurrencyCode(o),c=this.safeString(a,"name"),u=this.safeValue(a,"chains",[]),h={};let l;for(let p=0;p<u.length;p++){const m=u[p],g=this.safeString(m,"chain"),y=this.networkIdToCode(g),b=this.parseNumber(this.parsePrecision(this.safeString(m,"minAccuracy")));l=l===void 0?b:Math.min(l,b);const w=this.safeInteger(m,"chainDeposit")===1,k=this.safeInteger(m,"chainWithdraw")===1;h[y]={info:m,id:g,network:y,active:void 0,deposit:w,withdraw:k,fee:this.safeNumber(m,"withdrawFee"),precision:b,limits:{withdraw:{min:this.safeNumber(m,"withdrawMin"),max:void 0},deposit:{min:this.safeNumber(m,"depositMin"),max:void 0}}}}n[d]={info:a,code:d,id:o,name:c,active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,precision:l,limits:{amount:{min:void 0,max:void 0}},networks:h}}return n}async fetchMarkets(e={}){this.options.adjustForTimeDifference&&await this.loadTimeDifference();let t;if([t,e]=this.handleMarketTypeAndParams("fetchMarkets",void 0,e),t==="spot")return await this.fetchSpotMarkets(e);let s=[this.fetchSwapAndFutureMarkets(e),this.fetchUSDCMarkets(e)];s=await Promise.all(s);const i=s[0],n=s[1];let r=i;return r=this.arrayConcat(r,n),r}async fetchSpotMarkets(e){const t=await this.publicGetSpotV3PublicSymbols(e),s=this.safeValue(t,"result",{}),i=this.safeValue(s,"list",[]),n=[],r=this.parseNumber("0.001"),a=this.parseNumber("0.001");for(let o=0;o<i.length;o++){const d=i[o],c=this.safeString(d,"name"),u=this.safeString(d,"baseCoin"),h=this.safeString(d,"quoteCoin"),l=this.safeCurrencyCode(u),p=this.safeCurrencyCode(h),m=l+"/"+p,g=this.safeInteger(d,"showStatus")===1,y=this.safeNumber(d,"quotePrecision");n.push({id:c,symbol:m,base:l,quote:p,settle:void 0,baseId:u,quoteId:h,settleId:void 0,type:"spot",spot:!0,margin:void 0,swap:!1,future:!1,option:!1,active:g,contract:!1,linear:void 0,inverse:void 0,taker:r,maker:a,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(d,"basePrecision"),price:this.safeNumber(d,"minPricePrecision",y)},limits:{leverage:{min:this.parseNumber("1"),max:void 0},amount:{min:this.safeNumber(d,"minTradeQty"),max:this.safeNumber(d,"maxTradeQty")},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(d,"minTradeAmt"),max:this.safeNumber(d,"maxTradeAmt")}},info:d})}return n}async fetchSwapAndFutureMarkets(e){const t=await this.publicGetV2PublicSymbols(e),s=this.safeValue(t,"result",[]),i=[],n=this.safeValue(this.options,"fetchMarkets",{}),r=this.safeValue(n,"linear",{USDT:!0});for(let a=0;a<s.length;a++){const o=s[a],d=this.safeString(o,"name"),c=this.safeString(o,"base_currency"),u=this.safeString(o,"quote_currency"),h=this.safeCurrencyCode(c),l=this.safeCurrencyCode(u),p=l in r;let m=h+"/"+l;const g=h+l;let y="swap";g!==d&&(y="future");const b=this.safeValue(o,"lot_size_filter",{}),w=this.safeValue(o,"price_filter",{}),k=this.safeValue(o,"leverage_filter",{}),T=this.safeString(o,"status");let O;T!==void 0&&(O=T==="Trading");const x=y==="swap",C=y==="future";let E,P;const _=p?u:c,S=this.safeCurrencyCode(_);if(m=m+":"+S,C){const q=this.safeString(o,"alias").slice(-4),R=q.slice(0,2),G=q.slice(2,4),A=this.yyyymmdd(this.milliseconds()).split("-");P=this.safeValue(A,0)+"-"+R+"-"+G+"T00:00:00.000Z",E=this.parse8601(P),m=m+"-"+this.yymmdd(E)}const I=!p,v=I?this.safeNumber(b,"min_trading_qty"):this.parseNumber("1");i.push({id:d,symbol:m,base:h,quote:l,settle:S,baseId:c,quoteId:u,settleId:_,type:y,spot:!1,margin:void 0,swap:x,future:C,option:!1,active:O,contract:!0,linear:p,inverse:I,taker:this.safeNumber(o,"taker_fee"),maker:this.safeNumber(o,"maker_fee"),contractSize:v,expiry:E,expiryDatetime:P,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(b,"qty_step"),price:this.safeNumber(w,"tick_size")},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(k,"max_leverage",1)},amount:{min:this.safeNumber(b,"min_trading_qty"),max:this.safeNumber(b,"max_trading_qty")},price:{min:this.safeNumber(w,"min_price"),max:this.safeNumber(w,"max_price")},cost:{min:void 0,max:void 0}},info:o})}return i}async fetchUSDCMarkets(e){const t=await this.publicGetOptionUsdcOpenapiPublicV1Symbols(e),s=await this.publicGetPerpetualUsdcOpenapiPublicV1Symbols(e),i=this.safeValue(t,"result",[]),n=this.safeValue(i,"dataList",[]),r=this.safeValue(s,"result",[]),a=this.arrayConcat(n,r),o=[],d=!0;for(let c=0;c<a.length;c++){const u=a[c],h=this.safeString(u,"symbol"),l=this.safeString(u,"baseCoin"),p=this.safeString(u,"quoteCoin");let m=this.safeString(u,"settleCoin");const g=this.safeCurrencyCode(l),y=this.safeCurrencyCode(p);let b=this.safeCurrencyCode(m),w=g+"/"+y,k="swap";m!==void 0&&(k="option");const T=k==="swap",O=k==="option",x=this.safeValue(u,"leverage_filter",{}),C=this.safeString(u,"status");let E;C!==void 0&&(E=C==="ONLINE");let P,_,S,I;if(b===void 0&&(m="USDC",b="USDC"),w=w+":"+b,O){P=this.safeInteger(u,"deliveryTime"),_=this.iso8601(P);const v=h.split("-");S=this.safeString(v,2);const N=this.safeString(v,3);w=w+"-"+this.yymmdd(P)+"-"+S+"-"+N,N==="P"?I="put":N==="C"&&(I="call")}o.push({id:h,symbol:w,base:g,quote:y,settle:b,baseId:l,quoteId:p,settleId:m,type:k,spot:!1,margin:void 0,swap:T,future:!1,option:O,active:E,contract:!0,linear:d,inverse:!d,taker:this.safeNumber2(u,"taker_fee","takerFeeRate"),maker:this.safeNumber2(u,"maker_fee","makerFeeRate"),contractSize:this.parseNumber("1"),expiry:P,expiryDatetime:_,strike:S,optionType:I,precision:{amount:this.safeNumber2(u,"minOrderSizeIncrement","qtyStep"),price:this.safeNumber(u,"tickSize")},limits:{leverage:{min:this.safeNumber(x,"minLeverage",1),max:this.safeNumber(x,"maxLeverage",1)},amount:{min:this.safeNumber2(u,"minOrderSize","minTradingQty"),max:this.safeNumber2(u,"maxOrderSize","maxTradingQty")},price:{min:this.safeNumber2(u,"minOrderPrice","minPrice"),max:this.safeNumber2(u,"maxOrderPrice","maxPrice")},cost:{min:void 0,max:void 0}},info:u})}return o}parseTicker(e,t=void 0){return"s"in e?this.parseSpotTicker(e,t):this.parseContractTicker(e,t)}parseSpotTicker(e,t=void 0){const s=this.safeString(e,"s"),i=this.safeSymbol(s,t),n=this.safeInteger(e,"t");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"h"),low:this.safeString(e,"l"),bid:this.safeString(e,"bp"),bidVolume:void 0,ask:this.safeString(e,"ap"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"o"),close:this.safeString(e,"lp"),last:void 0,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"v"),quoteVolume:this.safeString(e,"qv"),info:e},t)}parseContractTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeString2(e,"last_price","lastPrice"),r=this.safeString2(e,"prev_price_24h","openPrice");let a=this.safeString2(e,"price_24h_pcnt","change24h");a=vi.stringMul(a,"100");const o=this.safeStringN(e,["turnover_24h","turnover24h","quoteVolume"]),d=this.safeStringN(e,["volume_24h","volume24h","volume"]),c=this.safeStringN(e,["bid_price","bid","bestBidPrice"]),u=this.safeStringN(e,["ask_price","ask","bestAskPrice"]),h=this.safeStringN(e,["high_price_24h","high24h","highPrice"]),l=this.safeStringN(e,["low_price_24h","low24h","lowPrice"]);return this.safeTicker({symbol:i,timestamp:void 0,datetime:void 0,high:h,low:l,bid:c,bidVolume:this.safeString(e,"bidSize"),ask:u,askVolume:this.safeString(e,"askSize"),vwap:void 0,open:r,close:n,last:n,previousClose:void 0,change:void 0,percentage:a,average:void 0,baseVolume:d,quoteVolume:o,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);let i;const n=s.settle==="USDC";s.spot?i="publicGetSpotV3PublicQuoteTicker24hr":n?s.option?i="publicGetOptionUsdcOpenapiPublicV1Tick":i="publicGetPerpetualUsdcOpenapiPublicV1Tick":i="publicGetV2PublicTickers";const r={symbol:s.id},a=await this[i](this.extend(r,t)),o=this.safeValue(a,"result",[]);let d;return Array.isArray(o)?d=this.safeValue(o,0):d=o,this.parseTicker(d,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s,i,n;if(e!==void 0){const d=this.safeValue(e,0);i=this.market(d),s=i.type,n=i.settle==="USDC"}else if([s,t]=this.handleMarketTypeAndParams("fetchTickers",i,t),s!=="spot"){let d=this.safeString(this.options,"defaultSettle","USDT");d=this.safeString2(t,"settle","defaultSettle",n),t=this.omit(t,["settle","defaultSettle"]),n=d==="USDC"}let r;if(s==="spot")r="publicGetSpotV3PublicQuoteTicker24hr";else if(!n)r="publicGetV2PublicTickers";else throw new Tn(this.id+" fetchTickers() is not supported for USDC markets");const a=await this[r](t);let o=this.safeValue(a,"result",[]);return Array.isArray(o)||(o=this.safeValue(o,"list",[])),this.parseTickers(o,e,t)}parseOHLCV(e,t=void 0){return"t"in e?this.parseSpotOHLCV(e,t):this.parseContractOHLCV(e,t)}parseSpotOHLCV(e,t=void 0){return[this.safeInteger(e,"t"),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}parseContractOHLCV(e,t=void 0){if(Array.isArray(e))return[this.safeNumber(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)];let s=this.safeTimestamp2(e,"open_time","openTime");return s===void 0&&(s=this.safeTimestamp(e,"start_at")),[s,this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber2(e,"volume","turnover")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.safeString(n,"price");n=this.omit(n,"price");const o={symbol:r.id},d=this.parseTimeframe(t),c=this.seconds();let u;i===void 0&&(i=200),s===void 0?u=c-i*d:u=parseInt(s/1e3),i!==void 0&&(o.limit=i);let h,l="interval",p="from";const m=r.settle==="USDC";if(r.spot)h="publicGetSpotV3PublicQuoteKline";else if(r.contract&&!m)if(r.linear){const b={mark:"publicGetPublicLinearMarkPriceKline",index:"publicGetPublicLinearIndexPriceKline",premiumIndex:"publicGetPublicLinearPremiumIndexKline"};h=this.safeValue(b,a,"publicGetPublicLinearKline")}else{const b={mark:"publicGetV2PublicMarkPriceKline",index:"publicGetV2PublicIndexPriceKline",premiumIndex:"publicGetV2PublicPremiumPriceKline"};h=this.safeValue(b,a,"publicGetV2PublicKlineList")}else{if(r.option)throw new Tn(this.id+" fetchOHLCV() is not supported for USDC options markets");l="period",p="startTime";const b={mark:"publicGetPerpetualUsdcOpenapiPublicV1MarkPriceKline",index:"publicGetPerpetualUsdcOpenapiPublicV1IndexPriceKline",premiumIndex:"publicGetPerpetualUsdcOpenapiPublicV1PremiumPriceKline"};h=this.safeValue(b,a,"publicGetPerpetualUsdcOpenapiPublicV1KlineList")}o[l]=r.spot?t:this.timeframes[t],o[p]=u;const g=await this[h](this.extend(o,n));let y=this.safeValue(g,"result",{});return"list"in y&&(y=this.safeValue(y,"list",{})),this.parseOHLCVs(y,r,t,s,i)}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=s.settle==="USDC";let r;n?r="privatePostPerpetualUsdcOpenapiPrivateV1PredictedFunding":r=s.linear?"privateGetPrivateLinearFundingPredictedFunding":"privateGetV2PrivateFundingPredictedFunding";const a=await this[r](this.extend(i,t)),o=this.safeValue(a,"result",{}),d=this.safeNumber2(o,"predicted_funding_rate","predictedFundingRate"),c=this.safeTimestamp(a,"time_now");return{info:a,symbol:e,markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:c,datetime:this.iso8601(c),fundingRate:d,fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchIndexOHLCV(e,t="1m",s=void 0,i=void 0,n={}){const r={price:"index"};return await this.fetchOHLCV(e,t,s,i,this.extend(r,n))}async fetchMarkOHLCV(e,t="1m",s=void 0,i=void 0,n={}){const r={price:"mark"};return await this.fetchOHLCV(e,t,s,i,this.extend(r,n))}async fetchPremiumIndexOHLCV(e,t="1m",s=void 0,i=void 0,n={}){const r={price:"premiumIndex"};return await this.fetchOHLCV(e,t,s,i,this.extend(r,n))}parseTrade(e,t=void 0){return"isBuyerMaker"in e||"feeTokenId"in e?this.parseSpotTrade(e,t):this.parseContractTrade(e,t)}parseSpotTrade(e,t=void 0){const s=this.safeIntegerN(e,["time","creatTime"]);let i,n;const r=this.safeInteger(e,"isBuyerMaker");if(r!==void 0)i="taker",n=r===1?"buy":"sell";else{const c=this.safeInteger(e,"isBuyer");i=this.safeInteger(e,"isMaker")===1?"maker":"taker",n=c===1?"buy":"sell"}const a=this.safeString(e,"symbol");t=this.safeMarket(a,t);let o={};const d=this.safeString(e,"feeTokenId");if(d!==void 0){const c=this.safeCurrencyCode(d);o={cost:this.safeString(e,"execFee"),currency:c}}return this.safeTrade({id:this.safeString(e,"id"),info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:this.safeString(e,"orderId"),type:void 0,side:n,takerOrMaker:i,price:this.safeString2(e,"price","orderPrice"),amount:this.safeString2(e,"qty","orderQty"),cost:void 0,fee:o},t)}parseContractTrade(e,t=void 0){const s=this.safeString2(e,"id","exec_id"),i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const n=t.symbol;let r=this.safeString2(e,"qty","exec_qty");r===void 0&&(r=this.safeString(e,"orderQty"));let a=this.safeString2(e,"exec_price","price");a===void 0&&(a=this.safeString(e,"orderPrice"));const o=this.safeString(e,"exec_value");let d=this.parse8601(this.safeString(e,"time"));d===void 0&&(d=this.safeInteger2(e,"trade_time_ms","time"));let c=this.safeStringLower(e,"side");if(c===void 0){const m=this.safeValue(e,"isBuyer");m!==void 0&&(c=m?"buy":"sell")}const u=this.safeValue(e,"isMaker");let h;u!==void 0?h=u?"maker":"taker":h=this.safeString(e,"last_liquidity_ind")==="AddedLiquidity"?"maker":"taker";const l=this.safeString2(e,"exec_fee","commission");let p;if(l!==void 0){let m;t.spot?m=this.safeString(e,"commissionAsset"):m=t.inverse?t.base:t.quote,p={cost:l,currency:m,rate:this.safeString(e,"fee_rate")}}return this.safeTrade({id:s,info:e,timestamp:d,datetime:this.iso8601(d),symbol:n,order:this.safeString2(e,"order_id","orderId"),type:this.safeStringLower(e,"order_type"),side:c,takerOrMaker:h,price:a,amount:r,cost:o,fee:p},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);let r;const a={symbol:n.id},o=n.settle==="USDC";n.type==="spot"?r="publicGetSpotV3PublicQuoteTrades":o?(r="publicGetOptionUsdcOpenapiPublicV1QueryTradeLatest",a.category=n.option?"OPTION":"PERPETUAL"):r=n.linear?"publicGetPublicLinearRecentTradingRecords":"publicGetV2PublicTradingRecords",s!==void 0&&(a.limit=s);const d=await this[r](this.extend(a,i));let c=this.safeValue(d,"result",{});return Array.isArray(c)||(c=this.safeValue2(c,"dataList","list",[])),this.parseTrades(c,n,t,s)}parseOrderBook(e,t,s=void 0,i="bids",n="asks",r=0,a=1){if(this.market(t).spot)return super.parseOrderBook(e,t,s,i,n,r,a);const d=[],c=[];for(let u=0;u<e.length;u++){const h=e[u],l=this.safeString(h,"side");if(l==="Buy")d.push(this.parseBidAsk(h,r,a));else if(l==="Sell")c.push(this.parseBidAsk(h,r,a));else throw new Es(this.id+" parseOrderBook() encountered an unrecognized bidask format: "+this.json(h))}return{symbol:t,bids:this.sortBy(d,0,!0),asks:this.sortBy(c,0),timestamp:s,datetime:this.iso8601(s),nonce:void 0}}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id},r=i.settle==="USDC";let a;i.spot?a="publicGetSpotV3PublicQuoteDepth":r?a=i.option?"publicGetOptionUsdcOpenapiPublicV1OrderBook":"publicGetPerpetualUsdcOpenapiPublicV1OrderBook":a="publicGetV2PublicOrderBookL2",t!==void 0&&(n.limit=t);const o=await this[a](this.extend(n,s)),d=this.safeValue(o,"result",[]);let c=this.safeTimestamp(o,"time_now");c===void 0&&(c=this.safeInteger(d,"time"));const u=i.spot?"bids":"Buy",h=i.spot?"asks":"Sell",l=i.spot?0:"price",p=i.spot?1:"size";return this.parseOrderBook(d,e,c,u,h,l,p)}parseBalance(e){const t={info:e},s=this.safeValue(e,"result",{}),i=this.safeValue(s,"balances");if(Array.isArray(i))for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"coin"),o=this.safeCurrencyCode(a),d=this.account();d.free=this.safeString(r,"availableBalance"),d.used=this.safeString(r,"locked"),d.total=this.safeString(r,"total"),t[o]=d}else if("walletBalance"in s){const n="USDC",r=this.account();r.free=this.safeString(s,"availableBalance"),r.total=this.safeString(s,"walletBalance"),t[n]=r}else{const n=Object.keys(s);for(let r=0;r<n.length;r++){const a=n[r],o=s[a],d=this.safeCurrencyCode(a),c=this.account();c.free=this.safeString(o,"available_balance"),c.total=this.safeString(o,"wallet_balance"),t[d]=c}}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t={};let s;[s,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e);let i;if(s==="spot")i="privateGetSpotV3PrivateAccount";else{let r=this.safeString(this.options,"defaultSettle");if(r=this.safeString2(e,"settle","defaultSettle",r),e=this.omit(e,["settle","defaultSettle"]),r==="USDC")i="privatePostOptionUsdcOpenapiPrivateV1QueryWalletBalance";else{i="privateGetV2PrivateWalletBalance";const o=this.safeString2(e,"coin","code");if(e=this.omit(e,["coin","code"]),o!==void 0){const d=this.currency(o);t.coin=d.id}}}const n=await this[i](this.extend(t,e));return this.parseBalance(n)}parseOrderStatus(e){const t={Created:"open",Rejected:"rejected",New:"open",Partiallyfilled:"open",PartiallyFilled:"open",Filled:"closed",Cancelled:"canceled",Pendingcancel:"canceling",CREATED:"open",REJECTED:"rejected",NEW:"open",PENDING_NEW:"open",PARTIALLYFILLED:"open",PARTIALLY_FILLED:"open",FILLED:"closed",CANCELED:"canceled",PENDINGCANCEL:"canceling",PENDING_CANCEL:"canceling",Active:"open",Untriggered:"open",Triggered:"closed",Deactivated:"canceled"};return this.safeString(t,e,e)}parseTimeInForce(e){const t={GoodTillCancel:"GTC",ImmediateOrCancel:"IOC",FillOrKill:"FOK",PostOnly:"PO"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){return"orderCategory"in e?this.parseSpotOrder(e,t):this.parseContractOrder(e,t)}parseContractOrder(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=t.symbol;let n=this.parse8601(this.safeStringN(e,["created_at","created_time","create_time","timestamp"]));n===void 0&&(n=this.safeNumber2(e,"time","transactTime"),n===void 0&&(n=this.safeIntegerProduct(e,"createdAt",.001)));const r=this.safeStringN(e,["order_id","stop_order_id","orderId"]),a=this.safeStringLowerN(e,["order_type","type","orderType"]),o=this.safeString2(e,"price","orderPrice"),d=this.safeString2(e,"average_price","avgPrice"),c=this.safeStringN(e,["qty","origQty","orderQty"]),u=this.safeString2(e,"cum_exec_value","cumExecValue"),h=this.safeStringN(e,["cum_exec_qty","executedQty","cumExecQty"]),l=this.safeString2(e,"leaves_qty","leavesQty");let p=this.safeTimestamp(e,"last_exec_time");p===0?p=void 0:p===void 0&&(p=this.parse8601(this.safeStringN(e,["updated_time","updated_at","update_time"])),p===void 0&&(p=this.safeNumber(e,"updateTime")));const m=this.safeStringN(e,["order_status","stop_order_status","status","orderStatus"]),g=this.parseOrderStatus(m),y=this.safeStringLower(e,"side");let b;if(this.safeValue(t,"contract")){const C=this.safeString2(e,"cum_exec_fee","cumExecFee");if(C!==void 0){const E=t.linear?t.quote:t.base;b={cost:C,currency:E}}}let k=this.safeString2(e,"order_link_id","orderLinkId");k!==void 0&&k.length<1&&(k=void 0);const T=this.parseTimeInForce(this.safeString2(e,"time_in_force","timeInForce")),O=this.safeStringN(e,["trigger_price","stop_px","stopPrice","triggerPrice"]),x=T==="PO";return this.safeOrder({info:e,id:r,clientOrderId:k,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:p,symbol:i,type:a,timeInForce:T,postOnly:x,side:y,price:o,triggerPrice:O,stopPrice:O,amount:c,cost:u,average:d,filled:h,remaining:l,status:g,fee:b,trades:void 0},t)}parseSpotOrder(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeInteger(e,"createTime"),n=this.safeStringLower(e,"orderType");let r=this.safeString(e,"orderPrice");r==="0"&&n==="market"&&(r=void 0);const a=this.safeString(e,"execQty"),o=this.safeStringLower(e,"side"),d=this.parseTimeInForce(this.safeString(e,"timeInForce")),c=this.safeString(e,"triggerPrice"),u=d==="PO";let h=this.safeString(e,"orderQty");return(h===void 0||h==="0")&&t.spot&&n==="market"&&o==="buy"&&(h=a),this.safeOrder({id:this.safeString(e,"orderId"),clientOrderId:this.safeString(e,"orderLinkId"),timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:this.safeInteger(e,"updateTime"),symbol:t.symbol,type:n,timeInForce:d,postOnly:u,side:o,price:r,triggerPrice:c,stopPrice:c,amount:h,cost:this.safeString(e,"cummulativeQuoteQty"),average:this.safeString(e,"avgPrice"),filled:a,remaining:void 0,status:this.parseOrderStatus(this.safeString(e,"status")),fee:void 0,trades:void 0,info:e},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));let n;if([n,s]=this.handleMarketTypeAndParams("fetchOrder",i,s),n!=="spot"&&t===void 0)throw new Gs(this.id+" fetchOrder() requires a symbol argument for "+n+" markets");if(n==="spot"){const u={orderId:e},h=await this.privateGetSpotV3PrivateOrder(this.extend(s,u)),l=this.safeValue(h,"result",{});return this.parseOrder(l,i)}const r=i.settle==="USDC",a=this.safeString(s,"stop_order_id"),o=this.safeValue(s,"stop",!1),d=this.safeStringLower(s,"orderType"),c=o||a!==void 0||d==="stop"||d==="conditional";if(a===void 0){let u;c?u="stop_order_id":u=r?"orderId":"order_id",e!==void 0&&(s[u]=e)}if(r||i.future||i.inverse)throw new Tn(this.id+" fetchOrder() supports spot markets and linear non-USDC perpetual swap markets only");{const u=await this.fetchOrders(t,void 0,void 0,s),h=this.safeValue(u,0);if(h===void 0)throw new Cf(this.id+" fetchOrder() order "+e+" not found");return h}}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);e=a.symbol;const o=a.settle==="USDC";return a.spot?await this.createSpotOrder(e,t,s,i,n,r):o?await this.createUsdcOrder(e,t,s,i,n,r):await this.createContractOrder(e,t,s,i,n,r)}async createSpotOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);if(t==="market"&&s==="buy"&&this.options.createMarketBuyOrderRequiresPrice){const g=this.safeNumber(r,"cost");if(r=this.omit(r,"cost"),n===void 0&&g===void 0)throw new Re(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)");{const y=this.numberToString(i),b=this.numberToString(n),w=vi.stringMul(y,b);i=g!==void 0?g:this.parseNumber(w)}}const o=t.toUpperCase(),d={symbol:a.id,side:this.capitalize(s),orderType:o,timeInForce:"GTC",orderQty:this.amountToPrecision(e,i)};if(o==="LIMIT"||o==="LIMIT_MAKER"){if(n===void 0)throw new Re(this.id+" createOrder requires a price argument for a "+t+" order");d.orderPrice=this.priceToPrecision(e,n)}this.isPostOnly(o==="MARKET",t==="LIMIT_MAKER",r)&&(d.orderType="LIMIT_MAKER");const u=this.safeString2(r,"clientOrderId","orderLinkId");u!==void 0&&(d.orderLinkId=u),r=this.omit(r,["clientOrderId","orderLinkId","postOnly"]);const h=this.safeString(this.options,"brokerId");h!==void 0&&(d.agentSource=h);const l=this.safeNumber2(r,"triggerPrice","stopPrice");l!==void 0&&(r.triggerPrice=this.priceToPrecision(e,l)),r=this.omit(r,"stopPrice");const p=await this.privatePostSpotV3PrivateOrder(this.extend(d,r)),m=this.safeValue(p,"result",{});return this.parseOrder(m)}async createUsdcOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);if(t==="market")throw new Tn(this.id+"createOrder does not allow market orders for "+e+" markets");if(n===void 0&&t==="limit")throw new Gs(this.id+" createOrder requires a price argument for limit orders");const o=t.toLowerCase(),d={symbol:a.id,side:this.capitalize(s),orderType:this.capitalize(o),timeInForce:"GoodTillCancel",orderQty:this.amountToPrecision(e,i)},c=o==="market";o==="limit"!==void 0&&(d.orderPrice=this.priceToPrecision(e,n));const h=this.safeString(r,"time_in_force"),l=this.safeStringLower(r,"timeInForce");if(this.isPostOnly(c,h==="PostOnly",r)?d.time_in_force="PostOnly":l==="gtc"?d.time_in_force="GoodTillCancel":l==="fok"?d.time_in_force="FillOrKill":l==="ioc"&&(d.time_in_force="ImmediateOrCancel"),a.swap){const w=this.safeValue2(r,"stopPrice","triggerPrice"),k=this.safeValue(r,"stopLossPrice",w),T=k!==void 0,O=this.safeValue(r,"takeProfitPrice");if(T||O!==void 0){d.orderFilter="StopOrder",d.trigger_by="LastPrice";const E=T?k:O,P=this.priceToPrecision(e,E);d.triggerPrice=P;const _=this.numberToString(a.precision.price);d.basePrice=T?vi.stringSub(P,_):vi.stringAdd(P,_)}else d.orderFilter="Order"}const m=this.safeString(r,"clientOrderId");m!==void 0?d.orderLinkId=m:a.option&&(d.orderLinkId=this.uuid16()),r=this.omit(r,["stopPrice","timeInForce","triggerPrice","stopLossPrice","takeProfitPrice","postOnly","clientOrderId"]);const g=a.option?"privatePostOptionUsdcOpenapiPrivateV1PlaceOrder":"privatePostPerpetualUsdcOpenapiPrivateV1PlaceOrder",y=await this[g](this.extend(d,r)),b=this.safeValue(y,"result",{});return this.parseOrder(b)}async createContractOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);if(n===void 0&&t==="limit")throw new Gs(this.id+" createOrder requires a price argument for limit orders");i=this.amountToPrecision(e,i),i=a.linear?parseFloat(i):parseInt(i);const o=t.toLowerCase(),d={symbol:a.id,side:this.capitalize(s),order_type:this.capitalize(o),time_in_force:"GoodTillCancel",qty:i};if(a.future){const E=this.safeInteger(r,"position_idx",0);d.position_idx=E,r=this.omit(r,"position_idx")}a.linear&&(d.reduce_only=this.safeValue2(r,"reduce_only","reduceOnly",!1),d.close_on_trigger=!1);const c=o==="market";if(o==="limit"){if(n===void 0)throw new Es(this.id+" createOrder() requires price argument for limit orders");d.price=parseFloat(this.priceToPrecision(e,n))}const h=this.safeString(r,"time_in_force"),l=this.safeStringLower(r,"timeInForce");this.isPostOnly(c,h==="PostOnly",r)?d.time_in_force="PostOnly":l==="gtc"?d.time_in_force="GoodTillCancel":l==="fok"?d.time_in_force="FillOrKill":l==="ioc"&&(d.time_in_force="ImmediateOrCancel");const m=this.safeValueN(r,["stopPrice","triggerPrice","stop_px"]),g=m!==void 0,y=this.safeValue(r,"stopLossPrice"),b=y!==void 0,w=this.safeValue(r,"takeProfitPrice"),k=w!==void 0;if(g){d.trigger_by="LastPrice";const E=this.priceToPrecision(e,m);d.stop_px=parseFloat(E);const P=this.safeValue2(r,"base_price","basePrice");if(P===void 0)throw new Gs(this.id+" createOrder() requires a base_price parameter for trigger orders, your triggerPrice > max(market price, base_price) or triggerPrice < min(market price, base_price)");d.base_price=parseFloat(this.priceToPrecision(e,P))}k&&(d.tp_trigger_by="LastPrice",d.take_profit=parseFloat(this.priceToPrecision(e,w))),b&&(d.sl_trigger_by="LastPrice",d.stop_loss=parseFloat(this.priceToPrecision(e,y)));const T=this.safeString(r,"clientOrderId");T!==void 0&&(d.order_link_id=T),r=this.omit(r,["stop_px","stopPrice","base_price","basePrice","timeInForce","triggerPrice","stopLossPrice","takeProfitPrice","postOnly","reduceOnly","clientOrderId"]);let O;a.future?O=g?"privatePostFuturesPrivateStopOrderCreate":"privatePostFuturesPrivateOrderCreate":a.linear?O=g?"privatePostPrivateLinearStopOrderCreate":"privatePostPrivateLinearOrderCreate":O=g?"privatePostV2PrivateStopOrderCreate":"privatePostV2PrivateOrderCreate";const x=await this[O](this.extend(d,r)),C=this.safeValue(x,"result",{});return this.parseOrder(C,a)}async editUsdcOrder(e,t,s,i,n=void 0,r=void 0,a={}){await this.loadMarkets();const o=this.market(t),d={symbol:o.id,orderId:e};n!==void 0&&(d.orderQty=this.amountToPrecision(t,n)),r!==void 0&&(d.orderPrice=this.priceToPrecision(t,r));const c=o.option?"privatePostOptionUsdcOpenApiPrivateV1ReplaceOrder":"privatePostPerpetualUsdcOpenApiPrivateV1ReplaceOrder";return{info:await this[c](this.extend(d,a)),id:e}}async editContractOrder(e,t,s,i,n=void 0,r=void 0,a={}){if(t===void 0)throw new Gs(this.id+" editOrder() requires an symbol argument");await this.loadMarkets();const o=this.market(t),d={symbol:o.id};n!==void 0&&(d.p_r_qty=this.amountToPrecision(t,n)),r!==void 0&&(d.p_r_price=this.priceToPrecision(t,r));let c=!1,u="order_id";const h=this.safeValueN(a,["stopPrice","triggerPrice"]);h!==void 0&&(c=!0,u="stop_order_id",d.p_r_trigger_price=this.priceToPrecision(t,h),a=this.omit(a,["stopPrice","triggerPrice"])),d[u]=e;let l;o.linear?l=c?"privatePostPrivateLinearStopOrderReplace":"privatePostPrivateLinearOrderReplace":o.future?l=c?"privatePostFuturesPrivateStopOrderReplace":"privatePostFuturesPrivateOrderReplace":l=c?"privatePostV2PrivateStopOrderReplace":"privatePostV2PrivateOrderReplace";const p=await this[l](this.extend(d,a)),m=this.safeValue(p,"result",{});return{info:p,id:this.safeString2(m,"order_id","stop_order_id"),order_id:this.safeString(m,"order_id"),stop_order_id:this.safeString(m,"stop_order_id")}}async editOrder(e,t,s,i,n=void 0,r=void 0,a={}){if(t===void 0)throw new Gs(this.id+" editOrder() requires an symbol argument");await this.loadMarkets();const o=this.market(t),d=o.settle==="USDC";if(o.spot)throw new Tn(this.id+" editOrder() does not support spot markets");return d?await this.editUsdcOrder(e,t,s,i,n,r,a):await this.editContractOrder(e,t,s,i,n,r,a)}async cancelOrder(e,t=void 0,s={}){let i;const n=t!==void 0;n&&(i=this.market(t));let r;if([r,s]=this.handleMarketTypeAndParams("cancelOrder",i,s),!n&&r!=="spot")throw new Gs(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const a={};n&&(a.symbol=i.id);const o=n&&i.spot||!n&&r==="spot",d=this.safeStringLower(s,"orderType"),u=this.safeValue(s,"stop",!1)||d==="stop"||d==="conditional";s=this.omit(s,["orderType","stop"]);const h=n&&i.settle==="USDC";let l;o?(l="privatePostSpotV3PrivateCancelOrder",e!==void 0&&(a.orderId=e)):h?(e!==void 0&&(a.orderId=e),i.option?l="privatePostOptionUsdcOpenapiPrivateV1CancelOrder":(l="privatePostPerpetualUsdcOpenapiPrivateV1CancelOrder",a.orderFilter=u?"StopOrder":"Order")):i.linear?l=u?"privatePostPrivateLinearStopOrderCancel":"privatePostPrivateLinearOrderCancel":i.swap?l=u?"privatePostV2PrivateStopOrderCancel":"privatePostV2PrivateOrderCancel":l=u?"privatePostFuturesPrivateStopOrderCancel":"privatePostFuturesPrivateOrderCancel",n&&i.contract&&!h&&e!==void 0&&(u?a.stop_order_id=e:a.order_id=e);const p=await this[l](this.extend(a,s)),m=this.safeValue(p,"result",{});return this.parseOrder(m,i)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();let s,i;if(e!==void 0)s=this.market(e),i=s.settle==="USDC";else{let l=this.safeString(this.options,"defaultSettle");l=this.safeString2(t,"settle","defaultSettle",l),t=this.omit(t,["settle","defaultSettle"]),i=l==="USDC"}let n;if([n,t]=this.handleMarketTypeAndParams("cancelAllOrders",s,t),!i&&e===void 0)throw new Gs(this.id+" cancelAllOrders() requires a symbol argument for "+n+" markets");const r={};i||(r.symbol=s.id);const a=this.safeStringLower(t,"orderType"),d=this.safeValue(t,"stop",!1)||a==="stop"||a==="conditional";t=this.omit(t,["stop","orderType"]);let c;n==="spot"?c="privateDeleteSpotOrderBatchCancel":i?c=n==="option"?"privatePostOptionUsdcOpenapiPrivateV1CancelAll":"privatePostPerpetualUsdcOpenapiPrivateV1CancelAll":n==="future"?c=d?"privatePostFuturesPrivateStopOrderCancelAll":"privatePostFuturesPrivateOrderCancelAll":s.linear?c=d?"privatePostPrivateLinearStopOrderCancelAll":"privatePostPrivateLinearOrderCancelAll":c=d?"privatePostV2PrivateStopOrderCancelAll":"privatePostV2PrivateOrderCancelAll";const u=await this[c](this.extend(r,t)),h=this.safeValue(u,"result",[]);return Array.isArray(h)?this.parseOrders(h,s):u}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Gs(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e);if(n.spot||n.settle==="USDC")throw new Tn(this.id+" fetchOrders() does not support "+n.type+" markets or USDC markets, use exchange.fetchOpenOrders () and exchange.fetchClosedOrders () instead");let r;const a=this.safeValue(i,"stop",!1),o=this.safeStringLower(i,"orderType"),d=this.safeString(i,"stop_order_id"),c=a||d!==void 0||o==="stop"||o==="conditional";i=this.omit(i,["orderType","stop","orderType"]),n.linear?r=c?"privateGetPrivateLinearStopOrderList":"privateGetPrivateLinearOrderList":n.future?r=c?"privateGetFuturesPrivateStopOrderList":"privateGetFuturesPrivateOrderList":r=c?"privateGetV2PrivateStopOrderList":"privateGetV2PrivateOrderList";const u={symbol:n.id};s!==void 0&&(u.limit=s);const h=await this[r](this.extend(u,i)),l=this.safeValue(h,"result",{}),p=this.safeValue(l,"data",[]);return this.parseOrders(p,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r;if(e!==void 0)n=this.market(e),r=n.settle==="USDC";else{let h=this.safeString(this.options,"defaultSettle");h=this.safeString2(i,"settle","defaultSettle",h),i=this.omit(i,["settle","defaultSettle"]),r=h==="USDC"}let a;if([a,i]=this.handleMarketTypeAndParams("fetchClosedOrders",n,i),(a==="swap"||a==="future")&&!r){if(e===void 0)throw new Gs(this.id+" fetchClosedOrders requires a symbol argument for "+e+" markets");const h=this.safeStringLower(i,"orderType"),p=this.safeValue(i,"stop",!1)||h==="stop"||h==="conditional";i=this.omit(i,["orderType","stop"]);let m;p?m=["Active","Triggered","Cancelled","Rejected","Deactivated"]:m=["Rejected","Filled","Cancelled"];const g=m.join(","),y=this.safeString2(i,"order_status","status",g);return i=this.omit(i,["order_status","status"]),i.order_status=y,await this.fetchOrders(e,t,s,i)}const o={};let d;a==="spot"?d="privateGetSpotV3PrivateHistoryOrders":(d="privatePostOptionUsdcOpenapiPrivateV1QueryOrderHistory",o.category=a==="swap"?"perpetual":"option");const c=await this[d](this.extend(o,i));let u=this.safeValue(c,"result",[]);return Array.isArray(u)||(u=this.safeValue2(u,"list","dataList",[])),this.parseOrders(u,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r;if(e!==void 0)n=this.market(e),r=n.settle==="USDC";else{let h=this.safeString(this.options,"defaultSettle");h=this.safeString2(i,"settle","defaultSettle",h),i=this.omit(i,["settle","defaultSettle"]),r=h==="USDC"}let a;[a,i]=this.handleMarketTypeAndParams("fetchOpenOrders",n,i);const o={};let d;if((a==="swap"||a==="future")&&!r){if(e===void 0)throw new Gs(this.id+" fetchOpenOrders requires a symbol argument for "+e+" markets");o.symbol=n.id;const h=this.safeStringLower(i,"orderType"),p=this.safeValue(i,"stop",!1)||h==="stop"||h==="conditional";i=this.omit(i,["stop","orderType"]),n.future?d=p?"privateGetFuturesPrivateStopOrder":"privateGetFuturesPrivateOrder":n.linear?d=p?"privateGetPrivateLinearStopOrderSearch":"privateGetPrivateLinearOrderSearch":d=p?"privateGetV2PrivateStopOrder":"privateGetV2PrivateOrder"}else a==="spot"?(e!==void 0&&(o.symbol=n.id),d="privateGetSpotV3PrivateOpenOrders"):(d="privatePostOptionUsdcOpenapiPrivateV1QueryActiveOrders",o.category=a==="swap"?"perpetual":"option");const c=await this[d](this.extend(o,i));let u=this.safeValue(c,"result",[]);if(a==="spot")u=this.safeValue(u,"list",[]);else if(!Array.isArray(u)){const h=this.safeValue(u,"dataList");if(h===void 0)return this.parseOrder(u,n);u=h}return this.parseOrders(u,n,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){const r={order_id:e};return await this.fetchMyTrades(t,s,i,this.extend(r,n))}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Gs(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n={};let r;const a=this.safeString(i,"order_id");if(a!==void 0&&(n.order_id=a,i=this.omit(i,"order_id")),r=this.market(e),r.settle==="USDC")throw new Tn(this.id+" fetchMyTrades() is not supported for market "+e);n.symbol=r.id,t!==void 0&&(n.start_time=t),s!==void 0&&(n.limit=s);let d;r.spot?d="privateGetSpotV3PrivateMyTrades":r.future?d="privateGetFuturesPrivateExecutionList":d=r.linear?"privateGetPrivateLinearTradeExecutionList":"privateGetV2PrivateExecutionList";const c=await this[d](this.extend(n,i));let u=this.safeValue(c,"result",{});return Array.isArray(u)||(u=this.safeValueN(u,["trade_list","data","list"],[])),this.parseTrades(u,r,t,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"addressDeposit"),i=this.safeString(e,"tagDeposit"),n=this.safeString(t,"code"),r=this.safeString(e,"chain");return this.checkAddress(s),{currency:n,address:s,tag:i,network:r,info:e}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();let s=this.currency(e);const i={coin:s.id},n=await this.privateGetAssetV3PrivateDepositAddressQuery(this.extend(i,t)),r=this.safeValue(n,"result",[]),a=this.safeValue(r,"chains",[]),o=this.safeString(r,"coin");s=this.currency(o);const d=this.parseDepositAddresses(a,[e],!1,{currency:s.id});return this.indexBy(d,"network")}async fetchDepositAddress(e,t={}){const[s,i]=this.handleNetworkCodeAndParams(t),n=this.networkCodeToId(s),r=this.currency(e),a={coin:r.id};n!==void 0&&(a.chainType=n);const o=await this.privateGetAssetV3PrivateDepositAddressQuery(this.extend(a,i)),d=this.safeValue(o,"result",{}),c=this.safeValue(d,"chains",[]),u=this.indexBy(c,"chain"),h=this.selectNetworkIdFromAvailableNetworks(e,s,u),l=this.safeValue(u,h,{});return this.parseDepositAddress(l,r)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={wallet_fund_type:"Deposit"};let r;e!==void 0&&(r=this.currency(e),n.coin=r.id),t!==void 0&&(n.startTime=t),s!==void 0&&(n.limit=s);const a=await this.privateGetAssetV3PrivateDepositRecordQuery(this.extend(n,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"rows",[]);return this.parseTransactions(d,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.coin=r.id),t!==void 0&&(n.startTime=this.yyyymmdd(t)),s!==void 0&&(n.limit=s);const a=await this.privateGetAssetV3PrivateWithdrawRecordQuery(this.extend(n,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"rows",[]);return this.parseTransactions(d,r,t,s)}parseTransactionStatus(e){const t={ToBeConfirmed:"pending",UnderReview:"pending",Success:"ok",Expire:"expired",0:"unknown",1:"pending",2:"processing",3:"ok",4:"fail",SecurityCheck:"pending",Pending:"pending",success:"ok",CancelByUser:"canceled",Reject:"rejected",Fail:"failed",BlockchainConfirmed:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"coin"),i=this.safeCurrencyCode(s,t),n=this.safeInteger2(e,"createTime","successAt"),r=this.safeInteger(e,"updateTime"),a=this.parseTransactionStatus(this.safeString(e,"status")),o=this.safeNumber2(e,"depositFee","withdrawFee",0),d="depositFee"in e?"deposit":"withdrawal";let c;o!==void 0&&(c={cost:o,currency:i});const u=this.safeString(e,"toAddress");return{info:e,id:this.safeString2(e,"id","withdrawId"),txid:this.safeString(e,"txID"),timestamp:n,datetime:this.iso8601(n),network:this.networkIdToCode(this.safeString(e,"chain")),address:void 0,addressTo:u,addressFrom:void 0,tag:this.safeString(e,"tag"),tagTo:void 0,tagFrom:void 0,type:d,amount:this.safeNumber(e,"amount"),currency:i,status:a,updated:r,fee:c}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.coin=r.id),t!==void 0&&(n.start_date=this.yyyymmdd(t)),s!==void 0&&(n.limit=s);const a=await this.privateGetV2PrivateWalletFundRecords(this.extend(n,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"data",[]);return this.parseLedger(d,r,t,s)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"coin"),i=this.safeCurrencyCode(s,t),n=this.safeString(e,"amount"),r=this.safeString(e,"wallet_balance"),a=vi.stringLt(n,"0")?"out":"in";let o;if(r!==void 0&&n!==void 0){const l=a==="out"?n:vi.stringNeg(n);o=vi.stringAdd(r,l)}const d=this.parse8601(this.safeString(e,"exec_time")),c=this.parseLedgerEntryType(this.safeString(e,"type")),u=this.safeString(e,"id"),h=this.safeString(e,"tx_id");return{id:u,currency:i,account:this.safeString(e,"wallet_id"),referenceAccount:void 0,referenceId:h,status:void 0,amount:this.parseNumber(n),before:this.parseNumber(o),after:this.parseNumber(r),fee:void 0,direction:a,timestamp:d,datetime:this.iso8601(d),type:c,info:e}}parseLedgerEntryType(e){const t={Deposit:"transaction",Withdraw:"transaction",RealisedPNL:"trade",Commission:"fee",Refund:"cashback",Prize:"prize",ExchangeOrderWithdraw:"transaction",ExchangeOrderDeposit:"transaction"};return this.safeString(t,e,e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets(),this.checkAddress(s);const r=this.currency(e),a={coin:r.id,amount:this.numberToString(t),address:s};i!==void 0&&(a.tag=i);const[o,d]=this.handleNetworkCodeAndParams(n),c=this.networkCodeToId(o);c!==void 0&&(a.chain=c);const u=await this.privatePostAssetV3PrivateWithdrawCreate(this.extend(a,d)),h=this.safeValue(u,"result",{});return this.parseTransaction(h,r)}async fetchPositions(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={};let i,n,r,a;if(Array.isArray(e)){if(e.length!==1)throw new Gs(this.id+" fetchPositions() takes an array with exactly one symbol");const p=this.safeString(e,0);i=this.market(p),n=i.type,r=i.linear,a=i.settle==="USDC",s.symbol=i.id}else{[n,t]=this.handleMarketTypeAndParams("fetchPositions",void 0,t);const l=this.safeValue(this.options,"fetchPositions",{}),p=this.safeString(this.options,"defaultSubType","linear");let m=this.safeString(l,"subType",p);m=this.safeString(t,"subType",m),r=m==="linear";let g=this.safeString(this.options,"defaultSettle");g=this.safeString2(t,"settle","defaultSettle",g),a=g==="USDC"}t=this.omit(t,["settle","defaultSettle","subType"]);let o;a?(o="privatePostOptionUsdcOpenapiPrivateV1QueryPosition",s.category=n==="option"?"OPTION":"PERPETUAL"):n==="future"?o="privateGetFuturesPrivatePositionList":r?o="privateGetPrivateLinearPositionList":o="privateGetV2PrivatePositionList";let d=await this[o](this.extend(s,t));typeof d=="string"&&this.isJsonEncodedObject(d)&&(d=JSON.parse(d));let c=this.safeValue(d,"result",{});"dataList"in c&&(c=this.safeValue(c,"dataList",[]));let u;Array.isArray(c)?u=c:u=[c];const h=[];for(let l=0;l<u.length;l++){let p=u[l];"data"in p&&"is_valid"in p&&(p=this.safeValue(p,"data")),h.push(this.parsePosition(p,i))}return this.filterByArray(h,"symbol",e,!1)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeString(e,"size");let n=this.safeString(e,"side");n=n==="Buy"?"long":"short";const r=this.safeString2(e,"position_value","positionValue"),a=this.omitZero(this.safeString2(e,"unrealised_pnl","unrealisedPnl"));let o=this.safeString(e,"positionIM");const d=this.safeString(e,"positionMM");let c=this.parse8601(this.safeString(e,"updated_at"));c===void 0&&(c=this.safeInteger(e,"createdAt"));const u=this.safeValue(e,"is_isolated",!1),h=u?"isolated":"cross";let l=this.safeString(e,"position_margin");const p=this.omitZero(this.safeString2(e,"entry_price","entryPrice")),m=this.omitZero(this.safeString2(e,"liq_price","liqPrice")),g=this.safeString(e,"leverage");t.settle==="USDT"?o=vi.stringDiv(vi.stringMul(i,p),g):t.inverse&&(o=vi.stringDiv(i,vi.stringMul(p,g)),u||(l=this.safeString(e,"wallet_balance")));const y=vi.stringMul(vi.stringDiv(a,o),"100");return{info:e,id:void 0,symbol:t.symbol,timestamp:c,datetime:this.iso8601(c),initialMargin:this.parseNumber(o),initialMarginPercentage:this.parseNumber(vi.stringDiv(o,r)),maintenanceMargin:d,maintenanceMarginPercentage:void 0,entryPrice:this.parseNumber(p),notional:this.parseNumber(r),leverage:this.parseNumber(g),unrealizedPnl:this.parseNumber(a),contracts:this.parseNumber(i),contractSize:this.safeNumber(t,"contractSize"),marginRatio:void 0,liquidationPrice:this.parseNumber(m),markPrice:this.safeNumber(e,"markPrice"),collateral:this.parseNumber(l),marginMode:h,side:n,percentage:this.parseNumber(y)}}async setMarginMode(e,t=void 0,s={}){if(t===void 0)throw new Gs(this.id+" setMarginMode() requires a symbol argument");await this.loadMarkets();const i=this.market(t);if(i.settle==="USDC")throw new Tn(this.id+" setMarginMode() does not support market "+t);if(e=e.toUpperCase(),e!=="ISOLATED"&&e!=="CROSS")throw new Tt(this.id+" setMarginMode() marginMode must be either isolated or cross");const n=this.safeNumber(s,"leverage");let r,a;if(n===void 0){if(r=this.safeNumber2(s,"sell_leverage","sellLeverage"),a=this.safeNumber2(s,"buy_leverage","buyLeverage"),r===void 0||a===void 0)throw new Gs(this.id+" setMarginMode() requires a leverage parameter or sell_leverage and buy_leverage parameters");s=this.omit(s,["buy_leverage","sell_leverage","sellLeverage","buyLeverage"])}else s=this.omit(s,"leverage"),r=n,a=n;const o=e==="ISOLATED",d={symbol:i.id,is_isolated:o,buy_leverage:n,sell_leverage:n};let c;return i.future?c="privatePostFuturesPrivatePositionSwitchIsolated":i.inverse?c="privatePostV2PrivatePositionSwitchIsolated":c="privatePostPrivateLinearPositionSwitchIsolated",await this[c](this.extend(d,s))}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new Gs(this.id+" setLeverage() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=i.settle==="USDC";let r;n?r="privatePostPerpetualUsdcOpenapiPrivateV1PositionLeverageSave":i.future?r="privatePostFuturesPrivatePositionLeverageSave":i.linear?r="privatePostPrivateLinearPositionSetLeverage":r="privatePostV2PrivatePositionLeverageSave";const a={symbol:i.id};e=n?e.toString():parseInt(e);const o=i.swap&&i.linear;if(!n&&(o||i.future)){const c=this.safeNumber(s,"buy_leverage"),u=this.safeNumber(s,"sell_leverage");if(c!==void 0&&u!==void 0){if(c<1||c>100||u<1||u>100)throw new Tt(this.id+" setLeverage() leverage should be between 1 and 100")}else a.buy_leverage=e,a.sell_leverage=e}else a.leverage=e;if(e<1||e>100)throw new Tt(this.id+" setLeverage() leverage should be between 1 and 100");return await this[r](this.extend(a,s))}async setPositionMode(e,t=void 0,s={}){if(t===void 0)throw new Gs(this.id+" setPositionMode() requires a symbol argument");await this.loadMarkets();const i=this.market(t);if(i.settle==="USDC")throw new Tn(this.id+" setPositionMode() does not support market "+t);if(i.inverse&&!i.future)throw new Tt(this.id+" setPositionMode() must be either a linear swap or an inverse future");let n,r;i.future?(n="privatePostFuturesPrivatePositionSwitchMode",e?r="3":r="0"):(n="privatePostPrivateLinearPositionSwitchMode",e?r="BothSide":r="MergedSingle");const a={symbol:i.id,mode:r};return await this[n](this.extend(a,s))}async fetchOpenInterestHistory(e,t="1h",s=void 0,i=void 0,n={}){if(t==="1m")throw new Tt(this.id+" fetchOpenInterestHistory() cannot use the 1m timeframe");await this.loadMarkets();let r=this.market(e);const a=r.linear?"linear":"inverse",o=this.safeString(n,"category",a),d={symbol:r.id,interval:t,category:o};s!==void 0&&(d.since=s),i!==void 0&&(d.limit=i);const c=await this.publicGetDerivativesV3PublicOpenInterest(this.extend(d,n)),u=this.safeValue(c,"result",{}),h=this.safeString(u,"symbol");r=this.safeMarket(h,r);const l=this.safeValue(u,"list",[]);return this.parseOpenInterests(l,r,s,i)}async fetchOpenInterest(e,t={}){await this.loadMarkets();let s=this.market(e);if(!s.contract)throw new Tt(this.id+" fetchOpenInterest() supports contract markets only");const i=this.safeString(t,"interval","1h");if(i==="1m")throw new Tt(this.id+" fetchOpenInterest() cannot use the 1m timeframe");const n=s.linear?"linear":"inverse",r=this.safeString(t,"category",n),a={symbol:s.id,interval:i,category:r},o=await this.publicGetDerivativesV3PublicOpenInterest(this.extend(a,t)),d=this.safeValue(o,"result",{}),c=this.safeString(d,"symbol");s=this.safeMarket(c,s);const u=this.safeValue(d,"list",[]);return this.parseOpenInterest(u[0],s)}parseOpenInterest(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeNumber(e,"openInterest");return{symbol:this.safeSymbol(t.id),baseVolume:i,quoteVolume:void 0,openInterestAmount:void 0,openInterestValue:i,timestamp:s,datetime:this.iso8601(s),info:e}}async fetchBorrowRate(e,t={}){await this.loadMarkets();const s=this.currency(e),i={coin:s.id},n=await this.privateGetSpotV3PrivateCrossMarginLoanInfo(this.extend(i,t)),r=this.safeValue(n,"result",{});return this.parseBorrowRate(r,s)}parseBorrowRate(e,t=void 0){const s=this.milliseconds(),i=this.safeString(e,"coin");return{currency:this.safeCurrencyCode(i,t),rate:this.safeNumber(e,"interestRate"),period:864e5,timestamp:s,datetime:this.iso8601(s),info:e}}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={},a=await this.privateGetSpotV3PrivateCrossMarginAccount(this.extend(r,n)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"loanAccountList",[]),c=this.parseBorrowInterests(d,void 0);return this.filterByCurrencySinceLimit(c,e,s,i)}parseBorrowInterest(e,t){return{symbol:void 0,marginMode:"cross",currency:this.safeCurrencyCode(this.safeString(e,"tokenId")),interest:this.safeNumber(e,"interest"),interestRate:void 0,amountBorrowed:this.safeNumber(e,"loan"),timestamp:void 0,datetime:void 0,info:e}}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.safeString(n,"transferId",this.uuid()),a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c=this.currency(e),u=this.currencyToPrecision(e,t);let h;[h,n]=this.handleOptionAndParams(n,"transfer","method","privatePostAssetV1PrivateTransfer");let l;h==="privatePostAssetV3PrivateTransferInterTransfer"?l={transferId:r,fromAccountType:o,toAccountType:d,coin:c.id,amount:u}:l={transfer_id:r,from_account_type:o,to_account_type:d,coin:c.id,amount:u};const p=await this[h](this.extend(l,n)),m=this.safeInteger2(p,"time","time_now"),g=this.safeValue(p,"result",{}),y=this.safeStringN(p,["retCode","retMsg","ret_code","ret_msg"]),b=this.parseTransferStatus(y);return this.extend(this.parseTransfer(g,c),{timestamp:m,datetime:this.iso8601(m),amount:this.parseNumber(u),fromAccount:s,toAccount:i,status:b})}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.safeCurrencyCode(e),r.coin=n.id),t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=s);const a=await this.privateGetAssetV3PrivateTransferInterTransferListQuery(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"list",[]);return this.parseTransfers(d,n,t,s)}async borrowMargin(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.currency(e),[r,a]=this.handleMarginModeAndParams("borrowMargin",i);if(r==="isolated")throw new Tn(this.id+" borrowMargin () cannot use isolated margin");const o={coin:n.id,qty:this.currencyToPrecision(e,t)},d=await this.privatePostSpotV3PrivateCrossMarginLoan(this.extend(o,a)),c=this.safeValue(d,"result",{}),u=this.parseMarginLoan(c,n);return this.extend(u,{symbol:s,amount:t})}async repayMargin(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.currency(e),[r,a]=this.handleMarginModeAndParams("repayMargin",i);if(r==="isolated")throw new Tn(this.id+" repayMargin () cannot use isolated margin");const o={coin:n.id,qty:this.currencyToPrecision(e,t)},d=await this.privatePostSpotV3PrivateCrossMarginRepay(this.extend(o,a)),c=this.safeValue(d,"result",{}),u=this.parseMarginLoan(c,n);return this.extend(u,{symbol:s,amount:t})}parseMarginLoan(e,t=void 0){return{id:this.safeString2(e,"transactId","repayId"),currency:this.safeString(t,"code"),amount:void 0,symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}parseTransferStatus(e){const t={0:"ok",OK:"ok",SUCCESS:"ok"};return this.safeString(t,e,e)}parseTransfer(e,t=void 0){const s=this.safeString(e,"coin"),i=this.safeTimestamp(e,"timestamp"),n=this.safeString2(e,"fromAccountType","from_account_type"),r=this.safeString2(e,"toAccountType","to_account_type"),a=this.safeValue(this.options,"accountsById",{}),o=this.safeString(a,n,n),d=this.safeString(a,r,r);return{info:e,id:this.safeString2(e,"transferId","transfer_id"),timestamp:i,datetime:this.iso8601(i),currency:this.safeCurrencyCode(s,t),amount:this.safeNumber(e,"amount"),fromAccount:o,toAccount:d,status:this.parseTransferStatus(this.safeString(e,"status"))}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.implodeHostname(this.urls.api[t])+"/"+e;if(t==="public")Object.keys(i).length&&(a+="?"+this.rawencode(i));else if(t==="private"){this.checkRequiredCredentials();const o=a.indexOf("openapi")>=0,d=a.indexOf("unified/v3")>=0,c=this.nonce().toString();if(o){Object.keys(i).length?r=this.json(i):r="{}";const u=c+this.apiKey+r,h=this.hmac(this.encode(u),this.encode(this.secret),"sha256","hex");n={"Content-Type":"application/json","X-BAPI-API-KEY":this.apiKey,"X-BAPI-TIMESTAMP":c,"X-BAPI-SIGN":h}}else if(d){n={"Content-Type":"application/json","X-BAPI-API-KEY":this.apiKey,"X-BAPI-SIGN-TYPE":"2","X-BAPI-TIMESTAMP":c,"X-BAPI-RECV-WINDOW":this.options.recvWindow.toString()};const u=i,h=this.rawencode(u),l=c.toString()+this.apiKey+this.options.recvWindow.toString();let p;if(s==="POST"){r=this.json(u),p=l+r;const g=this.safeString(this.options,"brokerId");g!==void 0&&(n.Referer=g)}else p=l+h,a+="?"+this.urlencode(u);const m=this.hmac(this.encode(p),this.encode(this.secret));n["X-BAPI-SIGN"]=m}else{const u=this.extend(i,{api_key:this.apiKey,recv_window:this.options.recvWindow,timestamp:c}),h=this.keysort(u),l=this.rawencode(h),p=this.hmac(this.encode(l),this.encode(this.secret));if(s==="POST"){const m=a.indexOf("spot")>=0,g=this.extend(u,{sign:p});if(m)r=this.urlencode(g),n={"Content-Type":"application/x-www-form-urlencoded"};else{r=this.json(g),n={"Content-Type":"application/json"};const y=this.safeString(this.options,"brokerId");y!==void 0&&(n.Referer=y)}}else a+="?"+this.urlencode(h)+"&sign="+p}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(!a)return;const c=this.safeString2(a,"ret_code","retCode");if(c!=="0"){if(c==="30084")return;const u=this.id+" "+r;throw this.throwBroadlyMatchedException(this.exceptions.broad,r,u),this.throwExactlyMatchedException(this.exceptions.exact,c,u),new Es(u)}}async fetchMarketLeverageTiers(e,t={}){await this.loadMarkets();const s={};let i;if(i=this.market(e),i.spot||i.option)throw new Tt(this.id+" fetchMarketLeverageTiers() symbol does not support market "+e);s.symbol=i.id;const n=i.settle==="USDC";let r;n?r="publicGetPerpetualUsdcOpenapiPublicV1RiskLimitList":i.linear?r="publicGetPublicLinearRiskLimit":r="publicGetV2PublicRiskLimitList";const a=await this[r](this.extend(s,t)),o=this.safeValue(a,"result");return this.parseMarketLeverageTiers(o,i)}parseMarketLeverageTiers(e,t){let s=0;const i=[];for(let n=0;n<e.length;n++){const r=e[n],a=this.safeNumber(r,"limit");i.push({tier:this.sum(n,1),currency:t.base,minNotional:s,maxNotional:a,maintenanceMarginRate:this.safeNumber2(r,"maintain_margin","maintainMargin"),maxLeverage:this.safeNumber2(r,"max_leverage","maxLeverage"),info:r}),s=a}return i}};const k8=ge,{ExchangeError:S8,ArgumentsRequired:Zi,BadRequest:IS,AuthenticationError:xS,DDoSProtection:v8,BadResponse:T8}=de,{TICK_SIZE:O8}=me,Ti=Se;var I8=class extends k8{describe(){return this.deepExtend(super.describe(),{id:"bytetrade",name:"ByteTrade",countries:["HK"],rateLimit:100,requiresWeb3:!0,certified:!1,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:void 0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","1d":"1d","5d":"5d","1w":"1w","1M":"1M"},urls:{test:{market:"https://api-v2-test.byte-trade.com",public:"https://api-v2-test.byte-trade.com"},logo:"https://user-images.githubusercontent.com/1294454/67288762-2f04a600-f4e6-11e9-9fd6-c60641919491.jpg",api:{market:"https://api-v2.bttcdn.com",public:"https://api-v2.bttcdn.com"},www:"https://www.byte-trade.com",doc:"https://docs.byte-trade.com/#description"},api:{market:{get:{klines:1,depth:1,trades:1,tickers:1}},public:{get:{symbols:1,currencies:1,balance:1,"orders/open":1,"orders/closed":1,"orders/all":1,orders:1,"orders/trades":1,depositaddress:1,withdrawals:1,deposits:1,transfers:1},post:{"transaction/createorder":1,"transaction/cancelorder":1,"transaction/withdraw":1,"transaction/transfer":1}}},fees:{trading:{tierBased:!1,percentage:!0,taker:8e-4,maker:8e-4}},commonCurrencies:{1:"ByteTrade",44:"ByteHub",48:"Blocktonic",133:"TerraCredit"},precisionMode:O8,exceptions:{"vertify error":xS,"verify error":xS,"transaction already in network":IS,"invalid argument":IS},options:{orderExpiration:31536e6}})}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"code");let a;r in this.commonCurrencies?a=this.commonCurrencies[r]:a=this.safeString(n,"name");const o=this.safeString(n,"fullname"),d=this.safeValue(n,"active"),c=this.safeValue(n,"limits"),u=this.safeValue(c,"deposit");let h=this.safeString(u,"max");Ti.stringEquals(h,"-1")&&(h=void 0);const l=this.safeValue(c,"withdraw");let p=this.safeString(l,"max");Ti.stringEquals(p,"-1")&&(p=void 0),s[a]={id:r,code:a,name:o,active:d,deposit:void 0,withdraw:void 0,precision:this.parseNumber(this.parsePrecision(this.safeString(n,"basePrecision"))),fee:void 0,limits:{amount:{min:void 0,max:void 0},deposit:{min:this.safeNumber(u,"min"),max:this.parseNumber(h)},withdraw:{min:this.safeNumber(l,"min"),max:this.parseNumber(p)}},info:n}}return s}async fetchMarkets(e={}){const t=await this.publicGetSymbols(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"symbol");let a=this.safeString(n,"baseName",""),o=this.safeString(n,"quoteName","");const d=this.safeString(n,"base"),c=this.safeString(n,"quote"),u=a.split("@"+d)[0];let h=o.split("@"+c)[0];c==="126"&&(h="ZAR");const l=u+"/"+h;d in this.commonCurrencies&&(a=this.commonCurrencies[d]),c in this.commonCurrencies&&(o=this.commonCurrencies[c]);const p=this.safeValue(n,"limits",{}),m=this.safeValue(p,"amount",{}),g=this.safeValue(p,"price",{}),y=this.safeValue(n,"precision",{});let b=this.safeString(m,"max");Ti.stringEquals(b,"-1")&&(b=void 0);let w=this.safeString(g,"max");Ti.stringEquals(w,"-1")&&(w=void 0);const k={id:r,symbol:a+"/"+o,normalSymbol:l,base:a,quote:o,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:this.safeValue(n,"active"),contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(n,"taker"),maker:this.safeNumber(n,"maker"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(y,"amount"))),price:this.parseNumber(this.parsePrecision(this.safeString(y,"price")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(m,"min"),max:this.parseNumber(b)},price:{min:this.safeNumber(g,"min"),max:this.parseNumber(w)},cost:{min:void 0,max:void 0}},info:n};s.push(k)}return s}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"code"),r=this.safeCurrencyCode(n,void 0),a=this.account();a.free=this.safeString(i,"free"),a.used=this.safeString(i,"used"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){if(!("userid"in e)&&this.apiKey===void 0)throw new Zi(this.id+" fetchBalance() requires this.apiKey or userid argument");await this.loadMarkets();const t={userid:this.apiKey},s=await this.publicGetBalance(this.extend(t,e));return this.parseBalance(s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit=t);const r=await this.marketGetDepth(this.extend(n,s)),a=this.safeInteger(r,"timestamp");return this.parseOrderBook(r,i.symbol,a)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const n=t.symbol;return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:this.safeString(e,"weightedAvgPrice"),open:this.safeString(e,"open"),close:this.safeString(e,"close"),last:this.safeString(e,"last"),previousClose:void 0,change:this.safeString(e,"change"),percentage:this.safeString(e,"percentage"),average:void 0,baseVolume:this.safeString(e,"baseVolume"),quoteVolume:this.safeString(e,"quoteVolume"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.marketGetTickers(this.extend(i,t));if(Array.isArray(n)){const r=this.safeValue(n,0);if(r===void 0)throw new T8(this.id+" fetchTicker() returned an empty response");return this.parseTicker(r,s)}return this.parseTicker(n,s)}async fetchBidsAsks(e=void 0,t={}){await this.loadMarkets();const s=await this.marketGetDepth(t);return this.parseTickers(s,e)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.marketGetTickers(t);return this.parseTickers(s,e)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,timeframe:this.timeframes[t]};s!==void 0&&(a.since=s),i!==void 0&&(a.limit=i);const o=await this.marketGetKlines(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}parseTrade(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"price"),n=this.safeString(e,"amount"),r=this.safeString(e,"cost"),a=this.safeString(e,"id"),o=this.safeString(e,"type"),d=this.safeString(e,"takerOrMaker"),c=this.safeString(e,"side"),u=this.iso8601(s),h=this.safeString(e,"order"),l=this.safeString(e,"symbol");t=this.safeMarket(l,t);const p=this.safeValue(e,"fee"),m=this.safeString(p,"cost"),g=this.safeString(p,"rate"),y=this.safeString(p,"code"),w={currency:this.safeCurrencyCode(y),cost:m,rate:g};return this.safeTrade({info:e,timestamp:s,datetime:u,symbol:t.symbol,id:a,order:h,type:o,takerOrMaker:d,side:c,price:i,amount:n,cost:r,fee:w},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};t!==void 0&&(r.since=t),s!==void 0&&(r.limit=s);const a=await this.marketGetTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetSymbols(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"name"),a=this.safeSymbol(r);s[a]={info:n,symbol:a,maker:this.safeNumber(n,"maker"),taker:this.safeNumber(n,"taker"),percentage:!0}}return s}parseOrder(e,t=void 0){const s=this.safeString(e,"status"),i=this.safeString(e,"base"),n=this.safeString(e,"quote"),r=this.safeCurrencyCode(i),a=this.safeCurrencyCode(n),o=r+"/"+a,d=this.safeInteger(e,"timestamp"),c=this.safeString(e,"datetime"),u=this.safeInteger(e,"lastTradeTimestamp"),h=this.safeString(e,"price"),l=this.safeString(e,"amount"),p=this.safeString(e,"filled"),m=this.safeString(e,"remaining"),g=this.safeString(e,"cost"),y=this.safeString(e,"average"),b=this.safeString(e,"id"),w=this.safeString(e,"type"),k=this.safeString(e,"side"),T=this.safeValue(e,"fee"),O=this.safeNumber(T,"cost"),x=this.safeNumber(T,"rate"),C=this.safeString(T,"code"),P={currency:this.safeCurrencyCode(C),cost:O,rate:x};return this.safeOrder({info:e,id:b,clientOrderId:void 0,timestamp:d,datetime:c,lastTradeTimestamp:u,symbol:o,type:w,timeInForce:void 0,postOnly:void 0,side:k,price:h,stopPrice:void 0,amount:l,cost:g,average:y,filled:p,remaining:m,status:s,fee:P,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){if(this.checkRequiredDependencies(),this.apiKey===void 0)throw new Zi("createOrder() requires this.apiKey or userid in params");await this.loadMarkets();const a=this.market(e);let o,d;s==="sell"?o=1:o=2,t==="limit"?d=1:(d=2,n=0);const c=a.normalSymbol,u=a.baseId,h=this.currency(a.base),l=this.amountToPrecision(e,i),p=new Ti(l);p.reduce(),p.decimals-=this.precisionFromString(this.numberToString(h.precision));const m=p.toString(),g=this.numberToString(m),y=a.quoteId,b=this.currency(a.quote),w=this.priceToPrecision(e,n),k=new Ti(w);k.reduce(),k.decimals-=this.precisionFromString(this.numberToString(b.precision));const T=k.toString(),O=this.numberToString(T),x=this.milliseconds(),C=this.safeInteger(this.options,"orderExpiration",31536e6),E=this.milliseconds()+C;let P=this.iso8601(x);P=P.split(".")[0];let _=this.iso8601(E);_=_.split(".")[0];const S="Sagittarius",I=this.safeString(r,"dappId",S),v=this.safeString(this.options,"fee","300000000000000"),N=this.safeString(r,"totalFeeRate","8"),q=this.safeString(r,"chainFeeRate","1"),R=this.safeString(r,"fee",v),G="18446744073709551616",F=[this.numberToBE(1,32),this.numberToLE(Math.floor(x/1e3),4),this.numberToLE(1,1),this.numberToLE(Math.floor(E/1e3),4),this.numberToLE(1,1),this.numberToLE(32,1),this.numberToLE(0,8),this.numberToLE(R,8),this.numberToLE(this.apiKey.length,1),this.stringToBinary(this.encode(this.apiKey)),this.numberToLE(o,1),this.numberToLE(d,1),this.numberToLE(c.length,1),this.stringToBinary(this.encode(c)),this.numberToLE(Ti.stringDiv(g,G,0),8),this.numberToLE(Ti.stringMod(g,G),8),this.numberToLE(Ti.stringDiv(O,G,0),8),this.numberToLE(Ti.stringMod(O,G),8),this.numberToLE(0,2),this.numberToLE(Math.floor(x/1e3),4),this.numberToLE(Math.floor(E/1e3),4),this.numberToLE(1,1),this.numberToLE(parseInt(q),2),this.numberToLE(1,1),this.numberToLE(parseInt(N),2),this.numberToLE(parseInt(y),4),this.numberToLE(parseInt(u),4),this.numberToLE(0,1),this.numberToLE(1,1),this.numberToLE(I.length,1),this.stringToBinary(this.encode(I)),this.numberToLE(0,1)],A=[this.numberToLE(Math.floor(x/1e3),4),this.numberToLE(1,1),this.numberToLE(Math.floor(E/1e3),4),this.numberToLE(1,1),this.numberToLE(32,1),this.numberToLE(0,8),this.numberToLE(R,8),this.numberToLE(this.apiKey.length,1),this.stringToBinary(this.encode(this.apiKey)),this.numberToLE(o,1),this.numberToLE(d,1),this.numberToLE(c.length,1),this.stringToBinary(this.encode(c)),this.numberToLE(Ti.stringDiv(g,G,0),8),this.numberToLE(Ti.stringMod(g,G),8),this.numberToLE(Ti.stringDiv(O,G,0),8),this.numberToLE(Ti.stringMod(O,G),8),this.numberToLE(0,2),this.numberToLE(Math.floor(x/1e3),4),this.numberToLE(Math.floor(E/1e3),4),this.numberToLE(1,1),this.numberToLE(parseInt(q),2),this.numberToLE(1,1),this.numberToLE(parseInt(N),2),this.numberToLE(parseInt(y),4),this.numberToLE(parseInt(u),4),this.numberToLE(0,1),this.numberToLE(1,1),this.numberToLE(I.length,1),this.stringToBinary(this.encode(I)),this.numberToLE(0,1)],V=this.binaryConcatArray(A),J=this.hash(V,"sha256","hex").slice(0,40),se=[this.numberToLE(J.length,1),this.stringToBinary(this.encode(J)),this.numberToBE(0,4)],we=this.binaryConcatArray(se),Oe=this.hash(we,"sha256","hex").slice(0,40),Ce=this.binaryConcatArray(F),Le=this.hash(Ce,"sha256","hex"),Fe=this.ecdsa(Le,this.secret,"secp256k1",void 0,!0),D=this.binaryToBase16(this.numberToLE(this.sum(Fe.v,31),1))+Fe.r+Fe.s,j={now:P,expiration:_,fee:R,creator:this.apiKey,side:o,order_type:d,market_name:c,amount:m,price:T,use_btt_as_fee:!1,money_id:parseInt(y),stock_id:parseInt(u),custom_no_btt_fee_rate:parseInt(N),custom_btt_fee_rate:parseInt(q)},U={timestamp:P,expiration:_,operations:[[32,j]],validate_type:0,dapp:I,signatures:[D]},H={trObj:this.json(U)},W=await this.publicPostTransactionCreateorder(H),Y=this.milliseconds(),X=this.safeString(W,"code")==="0"?"open":"failed";return{info:W,id:Oe,timestamp:Y,datetime:this.iso8601(Y),lastTradeTimestamp:void 0,status:X,symbol:void 0,type:void 0,side:void 0,price:void 0,amount:void 0,filled:void 0,remaining:void 0,cost:void 0,trades:void 0,fee:void 0,clientOrderId:void 0,average:void 0}}async fetchOrder(e,t=void 0,s={}){if(!("userid"in s)&&this.apiKey===void 0)throw new Zi("fetchOrder() requires this.apiKey or userid argument");await this.loadMarkets();const i={userid:this.apiKey};let n;t!==void 0&&(n=this.markets[t],i.symbol=n.id),i.id=e;const r=await this.publicGetOrders(this.extend(i,s));return this.parseOrder(r,n)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(!("userid"in i)&&this.apiKey===void 0)throw new Zi("fetchOpenOrders() requires this.apiKey or userid argument");await this.loadMarkets();const n={userid:this.apiKey};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),s!==void 0&&(n.limit=s),t!==void 0&&(n.since=t);const a=await this.publicGetOrdersOpen(this.extend(n,i));return this.parseOrders(a,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(!("userid"in i)&&this.apiKey===void 0)throw new Zi("fetchClosedOrders() requires this.apiKey or userid argument");await this.loadMarkets();let n;const r={userid:this.apiKey};e!==void 0&&(n=this.market(e),r.symbol=n.id),s!==void 0&&(r.limit=s),t!==void 0&&(r.since=t);const a=await this.publicGetOrdersClosed(this.extend(r,i));return this.parseOrders(a,n,t,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(!("userid"in i)&&this.apiKey===void 0)throw new Zi("fetchOrders() requires this.apiKey or userid argument");await this.loadMarkets();let n;const r={userid:this.apiKey};e!==void 0&&(n=this.market(e),r.symbol=n.id),s!==void 0&&(r.limit=s),t!==void 0&&(r.since=t);const a=await this.publicGetOrdersAll(this.extend(r,i));return this.parseOrders(a,n,t,s)}async cancelOrder(e,t=void 0,s={}){if(this.apiKey===void 0)throw new Zi("cancelOrder() requires hasAlreadyAuthenticatedSuccessfully");if(t===void 0)throw new Zi(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=i.baseId,r=i.quoteId,a=i.normalSymbol,o="300000000000000",d=this.milliseconds(),c=0;let u=this.iso8601(d);u=u.split(".")[0];let h=this.iso8601(c);h=h.split(".")[0];const l="Sagittarius",p=this.safeString(s,"dappId",l),m=[this.numberToBE(1,32),this.numberToLE(Math.floor(d/1e3),4),this.numberToLE(1,1),this.numberToLE(c,4),this.numberToLE(1,1),this.numberToLE(33,1),this.numberToLE(0,8),this.numberToLE(o,8),this.numberToLE(this.apiKey.length,1),this.stringToBinary(this.encode(this.apiKey)),this.numberToLE(a.length,1),this.stringToBinary(this.encode(a)),this.base16ToBinary(e),this.numberToLE(parseInt(r),4),this.numberToLE(parseInt(n),4),this.numberToLE(0,1),this.numberToLE(1,1),this.numberToLE(p.length,1),this.stringToBinary(this.encode(p)),this.numberToLE(0,1)],g=this.binaryConcatArray(m),y=this.hash(g,"sha256","hex"),b=this.ecdsa(y,this.secret,"secp256k1",void 0,!0),k=this.binaryToBase16(this.numberToLE(this.sum(b.v,31),1))+b.r+b.s,T={fee:o,creator:this.apiKey,order_id:e,market_name:a,money_id:parseInt(r),stock_id:parseInt(n)},O={timestamp:u,expiration:h,operations:[[33,T]],validate_type:0,dapp:p,signatures:[k]},x={trObj:this.json(O)},C=await this.publicPostTransactionCancelorder(x),E=this.milliseconds(),_=this.safeString(C,"code")==="0"?"canceled":"failed";return{info:C,id:void 0,timestamp:E,datetime:this.iso8601(E),lastTradeTimestamp:void 0,status:_,symbol:void 0,type:void 0,side:void 0,price:void 0,amount:void 0,filled:void 0,remaining:void 0,cost:void 0,trades:void 0,fee:void 0,clientOrderId:void 0,average:void 0}}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(!("userid"in i)&&this.apiKey===void 0)throw new Zi("fetchMyTrades() requires this.apiKey or userid argument");await this.loadMarkets();const n=this.market(e),r={userid:this.apiKey};e!==void 0&&(r.symbol=n.id),s!==void 0&&(r.limit=s),t!==void 0&&(r.since=t);const a=await this.publicGetOrdersTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),!("userid"in i)&&this.apiKey===void 0)throw new Zi("fetchDeposits() requires this.apiKey or userid argument");let n;const r={userid:this.apiKey};e!==void 0&&(n=this.currency(e),r.currency=n.id),t!==void 0&&(r.since=t),s!==void 0&&(r.limit=s);const a=await this.publicGetDeposits(this.extend(r,i));return this.parseTransactions(a,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),!("userid"in i)&&this.apiKey===void 0)throw new Zi("fetchWithdrawals() requires this.apiKey or userid argument");let n;const r={userid:this.apiKey};e!==void 0&&(n=this.currency(e),r.currency=n.id),t!==void 0&&(r.since=t),s!==void 0&&(r.limit=s);const a=await this.publicGetWithdrawals(this.extend(r,i));return this.parseTransactions(a,n,t,s)}parseTransactionStatus(e){const t={DEPOSIT_FAILED:"failed",FEE_SEND_FAILED:"failed",FEE_FAILED:"failed",PAY_SEND_FAILED:"failed",PAY_FAILED:"failed",BTT_FAILED:"failed",WITHDDRAW_FAILED:"failed",USER_FAILED:"failed",FEE_EXECUED:"pending",PAY_EXECUED:"pending",WITHDDRAW_EXECUTED:"pending",USER_EXECUED:"pending",BTT_SUCCED:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"address");let n=this.safeString(e,"tag");n!==void 0&&n.length<1&&(n=void 0);const r=this.safeValue(e,"txid"),a=this.safeString(e,"code"),o=this.safeCurrencyCode(a,t),d=this.safeInteger(e,"timestamp"),c=this.safeString(e,"datetime"),u=this.safeString(e,"type"),h=this.parseTransactionStatus(this.safeString(e,"status")),l=this.safeNumber(e,"amount"),p=this.safeValue(e,"fee"),m=this.safeNumber(p,"cost"),g=this.safeString(p,"code"),y=this.safeCurrencyCode(g,t);return{info:e,id:s,txid:r,timestamp:d,datetime:c,address:i,tag:n,type:u,amount:l,currency:o,status:h,updated:void 0,fee:{cost:m,currency:y}}}async fetchDepositAddress(e,t={}){if(await this.loadMarkets(),!("userid"in t)&&this.apiKey===void 0)throw new Zi("fetchDepositAddress() requires this.apiKey or userid argument");const s=this.currency(e),i={userid:this.apiKey,code:s.id},n=await this.publicGetDepositaddress(i),r=this.safeValue(n,0),a=this.safeString(r,"address"),o=this.safeString(r,"tag"),d=this.safeStringUpper(r,"chainType");return this.checkAddress(a),{currency:e,address:a,tag:o,network:d,info:n}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t];return a+="/"+e,Object.keys(i).length&&(a+="?"+this.urlencode(i)),{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(e===503)throw new v8(this.id+" "+e.toString()+" "+t+" "+r);if(a!==void 0&&"code"in a&&this.safeString(a,"code")==="1"){const u=this.safeString(a,"msg"),h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions,u,h),new S8(h)}}};const x8=ge,{ExchangeError:_S,ArgumentsRequired:o0,AuthenticationError:_8,NullResponse:CS,InvalidOrder:d0,InsufficientFunds:C8,InvalidNonce:M8,OrderNotFound:P8,RateLimitExceeded:A8,DDoSProtection:B8,BadSymbol:MS}=de,{TICK_SIZE:E8}=me,c0=Se;var $_=class extends x8{describe(){return this.deepExtend(super.describe(),{id:"cex",name:"CEX.IO",countries:["GB","EU","CY","RU"],rateLimit:1500,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,cancelOrders:!1,createDepositAddress:!1,createOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,editOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDeposits:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!1,fetchWithdrawalWhitelist:!1,reduceMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,transfer:!1,withdraw:!1},timeframes:{"1m":"1m","1h":"1h","1d":"1d"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766442-8ddc33b0-5ed8-11e7-8b98-f786aef0f3c9.jpg",api:{rest:"https://cex.io/api"},www:"https://cex.io",doc:"https://cex.io/cex-api",fees:["https://cex.io/fee-schedule","https://cex.io/limits-commissions"],referral:"https://cex.io/r/0/up105393824/0/"},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},api:{public:{get:["currency_profile","currency_limits/","last_price/{pair}/","last_prices/{currencies}/","ohlcv/hd/{yyyymmdd}/{pair}","order_book/{pair}/","ticker/{pair}/","tickers/{currencies}/","trade_history/{pair}/"],post:["convert/{pair}","price_stats/{pair}"]},private:{post:["active_orders_status/","archived_orders/{pair}/","balance/","cancel_order/","cancel_orders/{pair}/","cancel_replace_order/{pair}/","close_position/{pair}/","get_address/","get_crypto_address","get_myfee/","get_order/","get_order_tx/","open_orders/{pair}/","open_orders/","open_position/{pair}/","open_positions/{pair}/","place_order/{pair}/","raw_tx_history"]}},fees:{trading:{maker:this.parseNumber("0.0016"),taker:this.parseNumber("0.0025")},funding:{withdraw:{},deposit:{BTC:0,ETH:0,BCH:0,DASH:0,BTG:0,ZEC:0,XRP:0,XLM:0}}},precisionMode:E8,exceptions:{exact:{},broad:{"Insufficient funds":C8,"Nonce must be incremented":M8,"Invalid Order":d0,"Order not found":P8,"limit exceeded":A8,"Invalid API key":_8,"There was an error while placing your order":d0,"Sorry, too many clients already":B8,"Invalid Symbols Pair":MS,"Wrong currency pair":MS}},options:{fetchOHLCVWarning:!0,createMarketBuyOrderRequiresPrice:!0,order:{status:{c:"canceled",d:"closed",cd:"canceled",a:"open"}},defaultNetwork:"ERC20",defaultNetworks:{USDT:"TRC20"},networks:{ERC20:"Ethereum",BTC:"BTC",BEP20:"Binance Smart Chain",BSC:"Binance Smart Chain",TRC20:"Tron"},networksById:{Ethereum:"ERC20",BTC:"BTC","Binance Smart Chain":"BEP20",Tron:"TRC20"}}})}async fetchCurrenciesFromCache(e={}){const t=this.safeValue(this.options,"fetchCurrencies",{}),s=this.safeInteger(t,"timestamp"),i=this.safeInteger(t,"expires",1e3),n=this.milliseconds();if(s===void 0||n-s>i){const r=await this.publicGetCurrencyProfile(e);this.options.fetchCurrencies=this.extend(t,{response:r,timestamp:n})}return this.safeValue(this.options.fetchCurrencies,"response")}async fetchCurrencies(e={}){const t=await this.fetchCurrenciesFromCache(e);this.options.currencies={timestamp:this.milliseconds(),response:t};const s=this.safeValue(t,"data",[]),i=this.safeValue(s,"symbols",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"code"),d=this.safeCurrencyCode(o),c=!0;n[d]={id:o,code:d,name:o,active:c,deposit:void 0,withdraw:void 0,precision:this.parseNumber(this.safeString(a,"precision")),fee:void 0,limits:{amount:{min:this.safeNumber(a,"minimumCurrencyAmount"),max:void 0},withdraw:{min:this.safeNumber(a,"minimalWithdrawalAmount"),max:void 0}},info:a}}return n}async fetchMarkets(e={}){const t=await this.fetchCurrenciesFromCache(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"symbols",[]),n=this.indexBy(i,"code"),r=this.safeValue(s,"pairs",[]),a=await this.publicGetCurrencyLimits(e),o=[],d=this.safeValue(a.data,"pairs");for(let c=0;c<d.length;c++){const u=d[c],h=this.safeString(u,"symbol1"),l=this.safeString(u,"symbol2"),p=this.safeCurrencyCode(h),m=this.safeCurrencyCode(l),g=this.safeValue(n,h,{}),y=this.safeValue(n,l,{});let b=this.safeString(y,"precision","8");for(let O=0;O<r.length;O++){const x=r[O];x.symbol1===h&&x.symbol2===l&&(b=this.safeString(x,"pricePrecision",b))}const w=this.safeString(g,"precision","8"),k=this.safeString(g,"scale","0"),T=c0.stringSub(w,k);o.push({id:h+"/"+l,symbol:p+"/"+m,base:p,quote:m,settle:void 0,baseId:h,quoteId:l,settleId:void 0,type:"spot",spot:!0,margin:void 0,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(T)),price:this.parseNumber(this.parsePrecision(b))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(u,"minLotSize"),max:this.safeNumber(u,"maxLotSize")},price:{min:this.safeNumber(u,"minPrice"),max:this.safeNumber(u,"maxPrice")},cost:{min:this.safeNumber(u,"minLotSizeS2"),max:void 0}},info:u})}return o}parseBalance(e){const t={info:e},s=["username","timestamp"],i=this.omit(e,s),n=Object.keys(i);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeValue(i,a,{}),d=this.account();d.free=this.safeString(o,"available"),d.used=this.safeString(o,"orders","0");const c=this.safeCurrencyCode(a);t[c]=d}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id};t!==void 0&&(n.depth=t);const r=await this.publicGetOrderBookPair(this.extend(n,s)),a=this.safeTimestamp(r,"timestamp");return this.parseOrderBook(r,i.symbol,a)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);if(s===void 0)s=this.milliseconds()-864e5;else if(this.options.fetchOHLCVWarning)throw new _S(this.id+" fetchOHLCV warning: CEX can return historical candles for a certain date only, this might produce an empty or null reply. Set exchange.options['fetchOHLCVWarning'] = false or add ({ 'options': { 'fetchOHLCVWarning': false }}) to constructor params to suppress this warning message.");const a={pair:r.id,yyyymmdd:this.yyyymmdd(s,"")};try{const o=await this.publicGetOhlcvHdYyyymmddPair(this.extend(a,n)),d="data"+this.timeframes[t],c=this.safeString(o,d),u=JSON.parse(c);return this.parseOHLCVs(u,r,t,s,i)}catch(o){if(o instanceof CS)return[]}}parseTicker(e,t=void 0){const s=this.safeTimestamp(e,"timestamp"),i=this.safeString(e,"volume"),n=this.safeString(e,"high"),r=this.safeString(e,"low"),a=this.safeString(e,"bid"),o=this.safeString(e,"ask"),d=this.safeString(e,"last"),c=this.safeSymbol(void 0,t);return this.safeTicker({symbol:c,timestamp:s,datetime:this.iso8601(s),high:n,low:r,bid:a,bidVolume:void 0,ask:o,askVolume:void 0,vwap:void 0,open:void 0,close:d,last:d,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:i,quoteVolume:void 0,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const i={currencies:Object.keys(this.currencies).join("/")},n=await this.publicGetTickersCurrencies(this.extend(i,t)),r=this.safeValue(n,"data",[]),a={};for(let o=0;o<r.length;o++){const d=r[o],c=this.safeString(d,"pair"),u=this.safeMarket(c,void 0,":"),h=u.symbol;a[h]=this.parseTicker(d,u)}return this.filterByArray(a,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetTickerPair(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"date"),i=this.safeString(e,"tid"),n=void 0,r=this.safeString(e,"type"),a=this.safeString(e,"price"),o=this.safeString(e,"amount");return t=this.safeMarket(void 0,t),this.safeTrade({info:e,id:i,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:n,side:r,order:void 0,takerOrMaker:void 0,price:a,amount:o,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id},a=await this.publicGetTradeHistoryPair(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostGetMyfee(e),s=this.safeValue(t,"data",{}),i={};for(let n=0;n<this.symbols.length;n++){const r=this.symbols[n],a=this.market(r),o=this.safeValue(s,a.id,{}),d=this.safeString(o,"buyMaker"),c=this.safeString(o,"buy"),u=this.parseNumber(c0.stringDiv(d,"100")),h=this.parseNumber(c0.stringDiv(c,"100"));i[r]={info:o,symbol:r,maker:u,taker:h,percentage:!0}}return i}async createOrder(e,t,s,i,n=void 0,r={}){if(t==="market"&&s==="buy"&&this.options.createMarketBuyOrderRequiresPrice){if(n===void 0)throw new d0(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)");i=i*n}await this.loadMarkets();const a=this.market(e),o={pair:a.id,type:s,amount:i};t==="limit"?o.price=n:o.order_type=t;const d=await this.privatePostPlaceOrderPair(this.extend(o,r)),c=this.safeNumber(d,"amount"),u=this.safeNumber(d,"pending"),h=this.safeValue(d,"time"),p=this.safeValue(d,"complete")?"closed":"open";let m;return c!==void 0&&u!==void 0&&(m=Math.max(c-u,0)),{id:this.safeString(d,"id"),info:d,clientOrderId:void 0,timestamp:h,datetime:this.iso8601(h),lastTradeTimestamp:void 0,type:t,side:this.safeString(d,"type"),symbol:a.symbol,status:p,price:this.safeNumber(d,"price"),amount:c,cost:void 0,average:void 0,remaining:u,filled:m,fee:void 0,trades:void 0}}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e};return await this.privatePostCancelOrder(this.extend(i,s))}parseOrder(e,t=void 0){let s=this.safeValue(e,"time");typeof s=="string"&&s.indexOf("T")>=0?s=this.parse8601(s):s=parseInt(s);let i;if(t===void 0){const m=this.safeString(e,"symbol1"),g=this.safeString(e,"symbol2"),y=this.safeCurrencyCode(m),b=this.safeCurrencyCode(g);i=y+"/"+b,i in this.markets&&(t=this.market(i))}const n=this.parseOrderStatus(this.safeString(e,"status")),r=this.safeNumber(e,"price");let a=this.safeNumber(e,"amount");a!==void 0&&(a=Math.abs(a));const o=this.safeNumber2(e,"pending","remains"),d=a-o;let c,u;if(t!==void 0){i=t.symbol;const m=this.safeNumber(e,"ta:"+t.quote),g=this.safeNumber(e,"tta:"+t.quote);u=this.sum(m,g);const y="fa:"+t.base,b="tfa:"+t.base,w="fa:"+t.quote,k="tfa:"+t.quote;let T=this.safeNumber(e,"tradingFeeMaker");if(T||(T=this.safeNumber(e,"tradingFeeTaker",T)),T&&(T/=100),y in e||b in e){const O=this.safeNumber2(e,y,b);c={currency:t.base,rate:T,cost:O}}else if(w in e||k in e){const O=this.safeNumber2(e,w,k);c={currency:t.quote,rate:T,cost:O}}}u||(u=r*d);const h=e.type;let l;const p=e.id;if("vtx"in e){l=[];for(let m=0;m<e.vtx.length;m++){const g=e.vtx[m],y=this.safeString(g,"type");if(y==="cancel")continue;const b=this.safeNumber(g,"price");if(b===void 0||y==="costsNothing")continue;const w=this.parse8601(this.safeString(g,"time")),k=this.safeNumber(g,"amount"),T=this.safeNumber(g,"fee_amount");let O=k<0?-k:k,x;y==="sell"?(x=O,O=this.sum(T,x)/b):x=O*b,l.push({id:this.safeString(g,"id"),timestamp:w,datetime:this.iso8601(w),order:p,symbol:i,price:b,amount:O,cost:x,side:y,fee:{cost:T,currency:t.quote},info:g,type:void 0,takerOrMaker:void 0})}}return{id:p,clientOrderId:void 0,datetime:this.iso8601(s),timestamp:s,lastTradeTimestamp:void 0,status:n,symbol:i,type:r===void 0?"market":"limit",timeInForce:void 0,postOnly:void 0,side:h,price:r,stopPrice:void 0,cost:u,amount:a,filled:d,remaining:o,trades:l,fee:c,info:e,average:void 0}}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r="privatePostOpenOrders",a;e!==void 0&&(a=this.market(e),n.pair=a.id,r+="Pair");const o=await this[r](this.extend(n,i));for(let d=0;d<o.length;d++)o[d]=this.extend(o[d],{status:"open"});return this.parseOrders(o,a,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n="privatePostArchivedOrdersPair";if(e===void 0)throw new o0(this.id+" fetchClosedOrders() requires a symbol argument");const r=this.market(e),a={pair:r.id},o=await this[n](this.extend(a,i));return this.parseOrders(o,r,t,s)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e.toString()},n=await this.privatePostGetOrderTx(this.extend(i,s)),r=this.safeValue(n,"data",{});return this.parseOrder(r)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={limit:s,pair:n.id,dateFrom:t},a=await this.privatePostArchivedOrdersPair(this.extend(r,i)),o=[];for(let d=0;d<a.length;d++){const c=a[d],u=this.parseOrderStatus(this.safeString(c,"status")),h=this.safeString(c,"symbol1"),l=this.safeString(c,"symbol2"),p=this.safeCurrencyCode(h),m=this.safeCurrencyCode(l),g=p+"/"+m,y=this.safeString(c,"type"),b=this.safeNumber(c,"a:"+h+":cds"),w=this.safeNumber(c,"a:"+l+":cds"),k=this.safeNumber(c,"f:"+l+":cds"),T=this.safeNumber(c,"amount"),O=this.safeNumber(c,"price"),x=this.safeNumber(c,"remains"),C=T-x;let E,P,_,S;if(!O)S="market",E=b,P=w,_=E/P;else{const q=this.safeNumber(c,"ta:"+l,0),R=this.safeNumber(c,"tta:"+l,0),G=this.safeNumber(c,"fa:"+l,0),F=this.safeNumber(c,"tfa:"+l,0);y==="sell"?P=this.sum(this.sum(q,R),this.sum(G,F)):P=this.sum(q,R)-this.sum(G,F),S="limit",E=T,_=P/C}const I=this.safeString(c,"time"),v=this.safeString(c,"lastTxTime"),N=this.parse8601(I);o.push({id:this.safeString(c,"id"),timestamp:N,datetime:this.iso8601(N),lastUpdated:this.parse8601(v),status:u,symbol:g,side:y,price:O,amount:E,average:_,type:S,filled:C,cost:P,remaining:x,fee:{cost:k,currency:m},info:c})}return o}parseOrderStatus(e){return this.safeString(this.options.order.status,e,e)}async editOrder(e,t,s,i,n=void 0,r=void 0,a={}){if(n===void 0)throw new o0(this.id+" editOrder() requires a amount argument");if(r===void 0)throw new o0(this.id+" editOrder() requires a price argument");await this.loadMarkets();const o=this.market(t),d={pair:o.id,type:i,amount:n,price:r,order_id:e},c=await this.privatePostCancelReplaceOrderPair(this.extend(d,a));return this.parseOrder(c,o)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},[n,r]=this.handleNetworkCodeAndParams(t),a=await this.privatePostGetCryptoAddress(this.extend(i,r)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"addresses",[]),c=this.indexBy(d,"blockchain"),u=this.selectNetworkIdFromAvailableNetworks(e,n,c),h=this.safeValue(c,u,{}),l=this.safeString2(h,"address","destination");return this.checkAddress(l),{currency:e,address:l,tag:this.safeString2(h,"destinationTag","memo"),network:this.networkIdToCode(u),info:o}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials();const d=this.nonce().toString(),c=d+this.uid+this.apiKey,u=this.hmac(this.encode(c),this.encode(this.secret));r=this.json(this.extend({key:this.apiKey,signature:u.toUpperCase(),nonce:d},o)),n={"Content-Type":"application/json"}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(Array.isArray(a))return a;if(r!=="true"){if(a===void 0)throw new CS(this.id+" returned "+this.json(a));if(!("e"in a&&"ok"in a&&a.ok==="ok")&&"error"in a){const c=this.safeString(a,"error"),u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u),new _S(u)}}}};const N8=ge,{ExchangeError:Un,ArgumentsRequired:PS,AuthenticationError:Ji,RateLimitExceeded:V8,InvalidNonce:q8}=de,{TICK_SIZE:L8}=me,wc=Se;var R8=class extends N8{describe(){return this.deepExtend(super.describe(),{id:"coinbase",name:"Coinbase",countries:["US"],rateLimit:400,version:"v2",userAgent:this.userAgents.chrome,headers:{"CB-VERSION":"2018-05-30"},has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:void 0,createDepositAddress:!0,createOrder:void 0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:void 0,fetchCurrencies:!0,fetchDepositAddress:void 0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchL2OrderBook:!1,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyBuys:!0,fetchMySells:!0,fetchMyTrades:void 0,fetchOHLCV:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:void 0,fetchOrder:void 0,fetchOrderBook:!1,fetchOrders:void 0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:void 0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactions:void 0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:void 0},urls:{logo:"https://user-images.githubusercontent.com/1294454/40811661-b6eceae2-653a-11e8-829e-10bfadb078cf.jpg",api:{rest:"https://api.coinbase.com"},www:"https://www.coinbase.com",doc:"https://developers.coinbase.com/api/v2",fees:"https://support.coinbase.com/customer/portal/articles/2109597-buy-sell-bank-transfer-fees",referral:"https://www.coinbase.com/join/58cbe25a355148797479dbd2"},requiredCredentials:{apiKey:!0,secret:!0},api:{public:{get:["currencies","time","exchange-rates","users/{user_id}","prices/{symbol}/buy","prices/{symbol}/sell","prices/{symbol}/spot"]},private:{get:["accounts","accounts/{account_id}","accounts/{account_id}/addresses","accounts/{account_id}/addresses/{address_id}","accounts/{account_id}/addresses/{address_id}/transactions","accounts/{account_id}/transactions","accounts/{account_id}/transactions/{transaction_id}","accounts/{account_id}/buys","accounts/{account_id}/buys/{buy_id}","accounts/{account_id}/sells","accounts/{account_id}/sells/{sell_id}","accounts/{account_id}/deposits","accounts/{account_id}/deposits/{deposit_id}","accounts/{account_id}/withdrawals","accounts/{account_id}/withdrawals/{withdrawal_id}","payment-methods","payment-methods/{payment_method_id}","user","user/auth"],post:["accounts","accounts/{account_id}/primary","accounts/{account_id}/addresses","accounts/{account_id}/transactions","accounts/{account_id}/transactions/{transaction_id}/complete","accounts/{account_id}/transactions/{transaction_id}/resend","accounts/{account_id}/buys","accounts/{account_id}/buys/{buy_id}/commit","accounts/{account_id}/sells","accounts/{account_id}/sells/{sell_id}/commit","accounts/{account_id}/deposits","accounts/{account_id}/deposits/{deposit_id}/commit","accounts/{account_id}/withdrawals","accounts/{account_id}/withdrawals/{withdrawal_id}/commit"],put:["accounts/{account_id}","user"],delete:["accounts/{id}","accounts/{account_id}/transactions/{transaction_id}"]}},precisionMode:L8,exceptions:{exact:{two_factor_required:Ji,param_required:Un,validation_error:Un,invalid_request:Un,personal_details_required:Ji,identity_verification_required:Ji,jumio_verification_required:Ji,jumio_face_match_verification_required:Ji,unverified_email:Ji,authentication_error:Ji,invalid_authentication_method:Ji,invalid_token:Ji,revoked_token:Ji,expired_token:Ji,invalid_scope:Ji,not_found:Un,rate_limit_exceeded:V8,internal_server_error:Un},broad:{"request timestamp expired":q8}},commonCurrencies:{CGLD:"CELO"},options:{fetchCurrencies:{expires:5e3},accounts:["wallet","fiat"]}})}async fetchTime(e={}){const t=await this.publicGetTime(e),s=this.safeValue(t,"data",{});return this.safeTimestamp(s,"epoch")}async fetchAccounts(e={}){await this.loadMarkets();const t={limit:100},s=await this.privateGetAccounts(this.extend(t,e)),i=this.safeValue(s,"data",[]);return this.parseAccounts(i,e)}parseAccount(e){const t=this.safeValue(e,"currency",{}),s=this.safeString(t,"code"),i=this.safeCurrencyCode(s);return{id:this.safeString(e,"id"),type:this.safeString(e,"type"),code:i,info:e}}async createDepositAddress(e,t={}){let s=this.safeString(t,"account_id");if(t=this.omit(t,"account_id"),s===void 0){await this.loadAccounts();for(let d=0;d<this.accounts.length;d++){const c=this.accounts[d];if(c.code===e&&c.type==="wallet"){s=c.id;break}}}if(s===void 0)throw new Un(this.id+" createDepositAddress() could not find the account with matching currency code, specify an `account_id` extra param");const i={account_id:s},n=await this.privatePostAccountsAccountIdAddresses(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeString(r,"destination_tag"),o=this.safeString(r,"address");return{currency:e,tag:a,address:o,info:n}}async fetchMySells(e=void 0,t=void 0,s=void 0,i={}){const n=this.prepareAccountRequest(s,i);await this.loadMarkets();const r=this.omit(i,["account_id","accountId"]),a=await this.privateGetAccountsAccountIdSells(this.extend(n,r));return this.parseTrades(a.data,void 0,t,s)}async fetchMyBuys(e=void 0,t=void 0,s=void 0,i={}){const n=this.prepareAccountRequest(s,i);await this.loadMarkets();const r=this.omit(i,["account_id","accountId"]),a=await this.privateGetAccountsAccountIdBuys(this.extend(n,r));return this.parseTrades(a.data,void 0,t,s)}async fetchTransactionsWithMethod(e,t=void 0,s=void 0,i=void 0,n={}){const r=await this.prepareAccountRequestWithCurrencyCode(t,i,n);await this.loadMarkets();const a=this.omit(n,["account_id","accountId"]),o=await this[e](this.extend(r,a));return this.parseTransactions(o.data,void 0,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsWithMethod("privateGetAccountsAccountIdWithdrawals",e,t,s,i)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsWithMethod("privateGetAccountsAccountIdDeposits",e,t,s,i)}parseTransactionStatus(e){const t={created:"pending",completed:"ok",canceled:"canceled"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeValue(e,"subtotal",{}),i=this.safeValue(e,"fee",{}),n=this.safeString(e,"id"),r=this.parse8601(this.safeValue(e,"created_at")),a=this.parse8601(this.safeValue(e,"updated_at")),o=this.safeString(e,"resource"),d=this.safeNumber(s,"amount"),c=this.safeString(s,"currency"),u=this.safeCurrencyCode(c),h=this.safeNumber(i,"amount"),l=this.safeString(i,"currency"),p=this.safeCurrencyCode(l),m={cost:h,currency:p};let g=this.parseTransactionStatus(this.safeString(e,"status"));return g===void 0&&(g=this.safeValue(e,"committed")?"ok":"pending"),{info:e,id:n,txid:n,timestamp:r,datetime:this.iso8601(r),network:void 0,address:void 0,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:o,amount:d,currency:u,status:g,updated:a,fee:m}}parseTrade(e,t=void 0){let s;const i=this.safeValue(e,"total",{}),n=this.safeValue(e,"amount",{}),r=this.safeValue(e,"subtotal",{}),a=this.safeValue(e,"fee",{}),o=this.safeString(e,"id"),d=this.parse8601(this.safeValue(e,"created_at"));if(t===void 0){const O=this.safeString(n,"currency"),x=this.safeString(i,"currency");if(O!==void 0&&x!==void 0){const C=this.safeCurrencyCode(O),E=this.safeCurrencyCode(x);s=C+"/"+E}}const c=void 0,u=this.safeString(e,"resource"),h=void 0,l=this.safeString(r,"amount"),p=this.safeString(n,"amount"),m=this.parseNumber(l),g=this.parseNumber(p),y=this.parseNumber(wc.stringDiv(l,p)),b=this.safeNumber(a,"amount"),w=this.safeString(a,"currency"),k=this.safeCurrencyCode(w),T={cost:b,currency:k};return{info:e,id:o,order:c,timestamp:d,datetime:this.iso8601(d),symbol:s,type:h,side:u,takerOrMaker:void 0,price:y,amount:g,cost:m,fee:T}}async fetchMarkets(e={}){const t=await this.fetchCurrenciesFromCache(e),s=this.safeValue(t,"currencies",{}),i=this.safeValue(t,"exchangeRates",{}),n=this.safeValue(s,"data",[]),r=this.indexBy(n,"id"),a=this.safeValue(this.safeValue(i,"data",{}),"rates",{}),o=Object.keys(a),d=[];for(let c=0;c<o.length;c++){const u=o[c],h=this.safeCurrencyCode(u);if((u in r?"fiat":"crypto")==="crypto")for(let p=0;p<n.length;p++){const m=n[p],g=this.safeString(m,"id"),y=this.safeCurrencyCode(g);d.push({id:u+"-"+g,symbol:h+"/"+y,base:h,quote:y,settle:void 0,baseId:u,quoteId:g,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:void 0,price:void 0},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(m,"min_size"),max:void 0}},info:m})}}return d}async fetchCurrenciesFromCache(e={}){const t=this.safeValue(this.options,"fetchCurrencies",{}),s=this.safeInteger(t,"timestamp"),i=this.safeInteger(t,"expires",1e3),n=this.milliseconds();if(s===void 0||n-s>i){const r=await this.publicGetCurrencies(e),a=await this.publicGetExchangeRates(e);this.options.fetchCurrencies=this.extend(t,{currencies:r,exchangeRates:a,timestamp:n})}return this.safeValue(this.options,"fetchCurrencies",{})}async fetchCurrencies(e={}){const t=await this.fetchCurrenciesFromCache(e),s=this.safeValue(t,"currencies",{}),i=this.safeValue(t,"exchangeRates",{}),n=this.safeValue(s,"data",[]),r=this.indexBy(n,"id"),a=this.safeValue(this.safeValue(i,"data",{}),"rates",{}),o=Object.keys(a),d={};for(let c=0;c<o.length;c++){const u=o[c],h=u in r?"fiat":"crypto",l=this.safeValue(r,u,{}),p=this.safeString(l,"id",u),m=this.safeString(l,"name"),g=this.safeCurrencyCode(p);d[g]={id:p,code:g,info:l,type:h,name:m,active:!0,deposit:void 0,withdraw:void 0,fee:void 0,precision:void 0,limits:{amount:{min:this.safeNumber(l,"min_size"),max:void 0},withdraw:{min:void 0,max:void 0}}}}return d}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={},i=await this.publicGetExchangeRates(this.extend(s,t)),n=this.safeValue(i,"data",{}),r=this.safeValue(n,"rates",{}),a=this.safeString(n,"currency"),o={},d=Object.keys(r),c="-";for(let u=0;u<d.length;u++){const h=d[u],l=h+c+a,p=this.safeMarket(l,void 0,c),m=p.symbol;o[m]=this.parseTicker(r[h],p)}return this.filterByArray(o,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=this.extend({symbol:s.id},t),n=await this.publicGetPricesSymbolSpot(i),r=await this.publicGetPricesSymbolBuy(i),a=await this.publicGetPricesSymbolSell(i);return this.parseTicker([n,r,a],s)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t);let i,n,r;const a=this.milliseconds();if(typeof e!="string"){const[o,d,c]=e,u=this.safeValue(o,"data",{}),h=this.safeValue(c,"data",{}),l=this.safeValue(d,"data",{});r=this.safeString(u,"amount"),n=this.safeString(h,"amount"),i=this.safeString(l,"amount")}return this.safeTicker({symbol:s,timestamp:a,datetime:this.iso8601(a),bid:n,ask:i,last:r,high:void 0,low:void 0,bidVolume:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:void 0,info:e},t)}parseBalance(e,t={}){const s=this.safeValue(e,"data",[]),i=this.safeValue(t,"type",this.options.accounts),n={info:e};for(let r=0;r<s.length;r++){const a=s[r],o=this.safeString(a,"type");if(this.inArray(o,i)){const d=this.safeValue(a,"balance");if(d!==void 0){const c=this.safeString(d,"currency"),u=this.safeCurrencyCode(c),h=this.safeString(d,"amount"),l=h;let p=this.safeValue(n,u);p===void 0?(p=this.account(),p.free=l,p.total=h):(p.free=wc.stringAdd(p.free,h),p.total=wc.stringAdd(p.total,h)),n[u]=p}}}return this.safeBalance(n)}async fetchBalance(e={}){await this.loadMarkets();const t={limit:100},s=await this.privateGetAccounts(this.extend(t,e));return this.parseBalance(s,e)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r=await this.prepareAccountRequestWithCurrencyCode(e,s,i),a=this.omit(i,["account_id","accountId"]),o=await this.privateGetAccountsAccountIdTransactions(this.extend(r,a));return this.parseLedger(o.data,n,t,s)}parseLedgerEntryStatus(e){const t={completed:"ok"};return this.safeString(t,e,e)}parseLedgerEntryType(e){const t={buy:"trade",sell:"trade",fiat_deposit:"transaction",fiat_withdrawal:"transaction",exchange_deposit:"transaction",exchange_withdrawal:"transaction",send:"transaction",pro_deposit:"transaction",pro_withdrawal:"transaction"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeValue(e,"amount",{});let i=this.safeString(s,"amount"),n;wc.stringLt(i,"0")?(n="out",i=wc.stringNeg(i)):n="in";const r=this.safeString(s,"currency"),a=this.safeCurrencyCode(r,t);let o;const d=this.safeValue(e,"network",{}),c=this.safeValue(d,"transaction_fee");if(c!==void 0){const y=this.safeString(c,"currency"),b=this.safeCurrencyCode(y,t);o={cost:this.safeNumber(c,"amount"),currency:b}}const u=this.parse8601(this.safeValue(e,"created_at")),h=this.safeString(e,"id"),l=this.parseLedgerEntryType(this.safeString(e,"type")),p=this.parseLedgerEntryStatus(this.safeString(e,"status")),m=this.safeString(e,"resource_path");let g;if(m!==void 0){const y=m.split("/");y.length>3&&(g=y[3])}return{info:e,id:h,timestamp:u,datetime:this.iso8601(u),direction:n,account:g,referenceId:void 0,referenceAccount:void 0,type:l,currency:a,amount:this.parseNumber(i),before:void 0,after:void 0,status:p,fee:o}}async findAccountId(e){await this.loadMarkets(),await this.loadAccounts();for(let t=0;t<this.accounts.length;t++){const s=this.accounts[t];if(s.code===e)return s.id}}prepareAccountRequest(e=void 0,t={}){const s=this.safeString2(t,"account_id","accountId");if(s===void 0)throw new PS(this.id+" prepareAccountRequest() method requires an account_id (or accountId) parameter");const i={account_id:s};return e!==void 0&&(i.limit=e),i}async prepareAccountRequestWithCurrencyCode(e=void 0,t=void 0,s={}){let i=this.safeString2(s,"account_id","accountId");if(i===void 0){if(e===void 0)throw new PS(this.id+" prepareAccountRequestWithCurrencyCode() method requires an account_id (or accountId) parameter OR a currency code argument");if(i=await this.findAccountId(e),i===void 0)throw new Un(this.id+" prepareAccountRequestWithCurrencyCode() could not find account id for "+e)}const n={account_id:i};return t!==void 0&&(n.limit=t),n}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));s==="GET"&&Object.keys(o).length&&(a+="?"+this.urlencode(o));const d=this.urls.api.rest+a;if(t==="private"){const c=this.safeString(this.headers,"Authorization");if(c!==void 0)n={Authorization:c,"Content-Type":"application/json"};else if(this.token)n={Authorization:"Bearer "+this.token,"Content-Type":"application/json"};else{this.checkRequiredCredentials();const u=this.nonce().toString();let h="";s!=="GET"&&Object.keys(o).length&&(r=this.json(o),h=r);const l=u+s+a+h,p=this.hmac(this.encode(l),this.encode(this.secret));n={"CB-ACCESS-KEY":this.apiKey,"CB-ACCESS-SIGN":p,"CB-ACCESS-TIMESTAMP":u,"Content-Type":"application/json"}}}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.id+" "+r;let u=this.safeString(a,"error");if(u!==void 0){const p=this.safeString(a,"error_description");throw this.throwExactlyMatchedException(this.exceptions.exact,u,c),this.throwBroadlyMatchedException(this.exceptions.broad,p,c),new Un(c)}const h=this.safeValue(a,"errors");if(h!==void 0&&Array.isArray(h)&&h.length>0){u=this.safeString(h[0],"id");const m=this.safeString(h[0],"message");if(u!==void 0)throw this.throwExactlyMatchedException(this.exceptions.exact,u,c),this.throwBroadlyMatchedException(this.exceptions.broad,m,c),new Un(c)}if(this.safeValue(a,"data")===void 0)throw new Un(this.id+" failed due to a malformed response "+this.json(a))}};const F8=ge,{InsufficientFunds:D8,ArgumentsRequired:AS,ExchangeError:Da,InvalidOrder:kc,InvalidAddress:H8,AuthenticationError:Mf,NotSupported:G8,OrderNotFound:u0,OnMaintenance:BS,PermissionDenied:U8,RateLimitExceeded:$8}=de,{TICK_SIZE:j8}=me,f0=Se;var Mb=class extends F8{describe(){return this.deepExtend(super.describe(),{id:"coinbasepro",name:"Coinbase Pro",countries:["US"],rateLimit:100,userAgent:this.userAgents.chrome,pro:!0,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:void 0,fetchDeposits:!0,fetchLedger:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPositionMode:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:!0,fetchWithdrawals:!0,withdraw:!0},timeframes:{"1m":60,"5m":300,"15m":900,"1h":3600,"6h":21600,"1d":86400},hostname:"pro.coinbase.com",urls:{test:{public:"https://api-public.sandbox.pro.coinbase.com",private:"https://api-public.sandbox.pro.coinbase.com"},logo:"https://user-images.githubusercontent.com/1294454/41764625-63b7ffde-760a-11e8-996d-a6328fa9347a.jpg",api:{public:"https://api.{hostname}",private:"https://api.{hostname}"},www:"https://pro.coinbase.com/",doc:"https://docs.pro.coinbase.com",fees:["https://docs.pro.coinbase.com/#fees","https://support.pro.coinbase.com/customer/en/portal/articles/2945310-fees"]},requiredCredentials:{apiKey:!0,secret:!0,password:!0},api:{public:{get:["currencies","products","products/{id}","products/{id}/book","products/{id}/candles","products/{id}/stats","products/{id}/ticker","products/{id}/trades","time","products/spark-lines"]},private:{get:["accounts","accounts/{id}","accounts/{id}/holds","accounts/{id}/ledger","accounts/{id}/transfers","coinbase-accounts","fills","funding","fees","margin/profile_information","margin/buying_power","margin/withdrawal_power","margin/withdrawal_power_all","margin/exit_plan","margin/liquidation_history","margin/position_refresh_amounts","margin/status","oracle","orders","orders/{id}","orders/client:{client_oid}","otc/orders","payment-methods","position","profiles","profiles/{id}","reports/{report_id}","transfers","transfers/{transfer_id}","users/self/exchange-limits","users/self/hold-balances","users/self/trailing-volume","withdrawals/fee-estimate","conversions/{conversion_id}"],post:["conversions","deposits/coinbase-account","deposits/payment-method","coinbase-accounts/{id}/addresses","funding/repay","orders","position/close","profiles/margin-transfer","profiles/transfer","reports","withdrawals/coinbase","withdrawals/coinbase-account","withdrawals/crypto","withdrawals/payment-method"],delete:["orders","orders/client:{client_oid}","orders/{id}"]}},commonCurrencies:{CGLD:"CELO"},precisionMode:j8,fees:{trading:{tierBased:!0,percentage:!0,maker:.4/100,taker:.6/100},funding:{tierBased:!1,percentage:!1,withdraw:{BCH:0,BTC:0,LTC:0,ETH:0,EUR:.15,USD:25},deposit:{BCH:0,BTC:0,LTC:0,ETH:0,EUR:.15,USD:10}}},exceptions:{exact:{"Insufficient funds":D8,NotFound:u0,"Invalid API Key":Mf,"invalid signature":Mf,"Invalid Passphrase":Mf,"Invalid order id":kc,"Private rate limit exceeded":$8,"Trading pair not available":U8,"Product not found":kc},broad:{"Order already done":u0,"order not found":u0,"price too small":kc,"price too precise":kc,"under maintenance":BS,"size is too small":kc,"Cancel only mode":BS}}})}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"id"),a=this.safeString(n,"name"),o=this.safeCurrencyCode(r),d=this.safeValue(n,"details",{}),u=this.safeString(n,"status")==="online";s[o]={id:r,code:o,info:n,type:this.safeString(d,"type"),name:a,active:u,deposit:void 0,withdraw:void 0,fee:void 0,precision:this.safeNumber(n,"max_precision"),limits:{amount:{min:this.safeNumber(d,"min_size"),max:void 0},withdraw:{min:this.safeNumber(d,"min_withdrawal_amount"),max:void 0}}}}return s}async fetchMarkets(e={}){const t=await this.publicGetProducts(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"id"),[a,o]=r.split("-"),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o),u=this.safeString(n,"status");s.push(this.extend(this.fees.trading,{id:r,symbol:d+"/"+c,base:d,quote:c,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:this.safeValue(n,"margin_enabled"),swap:!1,future:!1,option:!1,active:u==="online",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(n,"base_increment"),price:this.safeNumber(n,"quote_increment")},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(n,"min_market_funds"),max:void 0}},info:n}))}return s}async fetchAccounts(e={}){await this.loadMarkets();const t=await this.privateGetAccounts(e);return this.parseAccounts(t,e)}parseAccount(e){const t=this.safeString(e,"currency");return{id:this.safeString(e,"id"),type:void 0,code:this.safeCurrencyCode(t),info:e}}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"available"),a.used=this.safeString(i,"hold"),a.total=this.safeString(i,"balance"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccounts(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={id:this.marketId(e),level:2},n=await this.publicGetProductsIdBook(this.extend(i,s)),r=this.parseOrderBook(n,e);return r.nonce=this.safeInteger(n,"sequence"),r}parseTicker(e,t=void 0){let s,i,n,r,a,o,d,c;const u=t===void 0?void 0:t.symbol;return Array.isArray(e)?(r=this.safeString(e,4),s=this.milliseconds()):(s=this.parse8601(this.safeValue(e,"time")),i=this.safeString(e,"bid"),n=this.safeString(e,"ask"),a=this.safeString(e,"high"),o=this.safeString(e,"low"),d=this.safeString(e,"open"),r=this.safeString2(e,"price","last"),c=this.safeString(e,"volume")),this.safeTicker({symbol:u,timestamp:s,datetime:this.iso8601(s),high:a,low:o,bid:i,bidVolume:void 0,ask:n,askVolume:void 0,vwap:void 0,open:d,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:c,quoteVolume:void 0,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={},i=await this.publicGetProductsSparkLines(this.extend(s,t)),n={},r=Object.keys(i),a="-";for(let o=0;o<r.length;o++){const d=r[o],c=this.safeValue(i,d,[]),u=this.safeValue(c,0,[]),h=this.safeMarket(d,void 0,a),l=h.symbol;n[l]=this.parseTicker(u,h)}return this.filterByArray(n,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={id:s.id},n=this.safeString(this.options,"fetchTickerMethod","publicGetProductsIdTicker"),r=await this[n](this.extend(i,t));return this.parseTicker(r,s)}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString2(e,"time","created_at")),i=this.safeString(e,"product_id");t=this.safeMarket(i,t,"-");let n,r,a;const o=this.safeStringLower(t,"quoteId");if(o!==void 0){const b=o+"_value";a=this.safeString(e,b);const w=this.safeString(e,"liquidity");w!==void 0&&(r=w==="T"?"taker":"maker",n=this.safeString(t,r))}const c={cost:this.safeString2(e,"fill_fees","fee"),currency:t.quote,rate:n},u=this.safeString(e,"trade_id");let h=e.side==="buy"?"sell":"buy";const l=this.safeString(e,"order_id"),p=this.safeString(e,"maker_order_id"),m=this.safeString(e,"taker_order_id");(l!==void 0||p!==void 0&&m!==void 0)&&(h=e.side==="buy"?"buy":"sell");const g=this.safeString(e,"price"),y=this.safeString(e,"size");return this.safeTrade({id:u,order:l,info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:void 0,takerOrMaker:r,side:h,price:g,amount:y,fee:c,cost:a},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new AS(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={product_id:n.id};s!==void 0&&(r.limit=s);const a=await this.privateGetFills(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={id:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetProductsIdTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetFees(e),s=this.safeNumber(t,"maker_fee_rate"),i=this.safeNumber(t,"taker_fee_rate"),n={};for(let r=0;r<this.symbols.length;r++){const a=this.symbols[r];n[a]={info:t,symbol:a,maker:s,taker:i,percentage:!0,tierBased:!0}}return n}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,3),this.safeNumber(e,2),this.safeNumber(e,1),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.timeframes[t],o={id:r.id,granularity:a};s!==void 0&&(o.start=this.iso8601(s),i===void 0?i=300:i=Math.min(300,i),o.end=this.iso8601(this.sum((i-1)*a*1e3,s)));const d=await this.publicGetProductsIdCandles(this.extend(o,n));return this.parseOHLCVs(d,r,t,s,i)}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeTimestamp(t,"epoch")}parseOrderStatus(e){const t={pending:"open",active:"open",open:"open",done:"closed",canceled:"canceled",canceling:"open"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parse8601(this.safeString(e,"created_at")),i=this.safeString(e,"product_id");t=this.safeMarket(i,t,"-");let n=this.parseOrderStatus(this.safeString(e,"status"));const r=this.safeString(e,"done_reason");n==="closed"&&r==="canceled"&&(n="canceled");const a=this.safeString(e,"price"),o=this.safeString(e,"filled_size"),d=this.safeString(e,"size",o),c=this.safeString(e,"executed_value"),u=this.safeNumber(e,"fill_fees");let h;u!==void 0&&(h={cost:u,currency:t.quote,rate:void 0});const l=this.safeString(e,"id"),p=this.safeString(e,"type"),m=this.safeString(e,"side"),g=this.safeString(e,"time_in_force"),y=this.safeValue(e,"post_only"),b=this.safeNumber(e,"stop_price"),w=this.safeString(e,"client_oid");return this.safeOrder({id:l,clientOrderId:w,info:e,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,status:n,symbol:t.symbol,type:p,timeInForce:g,postOnly:y,side:m,price:a,stopPrice:b,cost:c,amount:d,filled:o,remaining:void 0,fee:h,average:void 0,trades:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={},n=this.safeString2(s,"clientOrderId","client_oid");let r;n===void 0?(r="privateGetOrdersId",i.id=e):(r="privateGetOrdersClientClientOid",i.client_oid=n,s=this.omit(s,["clientOrderId","client_oid"]));const a=await this[r](this.extend(i,s));return this.parseOrder(a)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;t!==void 0&&(r=this.market(t));const a={order_id:e},o=await this.privateGetFills(this.extend(a,n));return this.parseTrades(o,r,s,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"all"};return await this.fetchOpenOrders(e,t,s,this.extend(n,i))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.product_id=r.id),s!==void 0&&(n.limit=s);const a=await this.privateGetOrders(this.extend(n,i));return this.parseOrders(a,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"done"};return await this.fetchOpenOrders(e,t,s,this.extend(n,i))}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={type:t,side:s,product_id:a.id},d=this.safeString2(r,"clientOrderId","client_oid");d!==void 0&&(o.client_oid=d);const c=this.safeNumber2(r,"stopPrice","stop_price");c!==void 0&&(o.stop_price=this.priceToPrecision(e,c));const u=this.safeString2(r,"timeInForce","time_in_force");if(u!==void 0&&(o.time_in_force=u),this.safeValue2(r,"postOnly","post_only",!1)&&(o.post_only=!0),r=this.omit(r,["timeInForce","time_in_force","stopPrice","stop_price","clientOrderId","client_oid","postOnly","post_only"]),t==="limit")o.price=this.priceToPrecision(e,n),o.size=this.amountToPrecision(e,i);else if(t==="market"){let p=this.safeNumber2(r,"cost","funds");p===void 0?n!==void 0&&(p=i*n):r=this.omit(r,["cost","funds"]),p!==void 0?o.funds=this.costToPrecision(e,p):o.size=this.amountToPrecision(e,i)}const l=await this.privatePostOrders(this.extend(o,r));return this.parseOrder(l,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={},n=this.safeString2(s,"clientOrderId","client_oid");let r;n===void 0?(r="privateDeleteOrdersId",i.id=e):(r="privateDeleteOrdersClientClientOid",i.client_oid=n,s=this.omit(s,["clientOrderId","client_oid"]));let a;return t!==void 0&&(a=this.market(t),i.product_id=a.symbol),await this[r](this.extend(i,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;return e!==void 0&&(i=this.market(e),s.product_id=i.symbol),await this.privateDeleteOrders(this.extend(s,t))}async fetchPaymentMethods(e={}){return await this.privateGetPaymentMethods(e)}async deposit(e,t,s,i={}){await this.loadMarkets();const r={currency:this.currency(e).id,amount:t};let a="privatePostDeposits";if("payment_method_id"in i)a+="PaymentMethod";else if("coinbase_account_id"in i)a+="CoinbaseAccount";else throw new G8(this.id+" deposit() requires one of `coinbase_account_id` or `payment_method_id` extra params");const o=await this[a](this.extend(r,i));if(!o)throw new Da(this.id+" deposit() error: "+this.json(o));return{info:o,id:o.id}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,amount:t};let o="privatePostWithdrawals";"payment_method_id"in n?o+="PaymentMethod":"coinbase_account_id"in n?o+="CoinbaseAccount":(o+="Crypto",a.crypto_address=s,i!==void 0&&(a.destination_tag=i));const d=await this[o](this.extend(a,n));if(!d)throw new Da(this.id+" withdraw() error: "+this.json(d));return this.parseTransaction(d,r)}parseLedgerEntryType(e){const t={transfer:"transfer",match:"trade",fee:"fee",rebate:"rebate",conversion:"trade"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"id");let i=this.safeString(e,"amount"),n;const r=this.safeString(e,"balance"),a=f0.stringSub(r,i);f0.stringLt(i,"0")?(n="out",i=f0.stringAbs(i)):n="in";const o=this.parseNumber(i),d=this.parseNumber(r),c=this.parseNumber(a),u=this.parse8601(this.safeValue(e,"created_at")),h=this.parseLedgerEntryType(this.safeString(e,"type")),l=this.safeCurrencyCode(void 0,t),p=this.safeValue(e,"details",{});let m,g,y;return h==="transfer"?(m=this.safeString(p,"from"),g=this.safeString(p,"to"),y=this.safeString(p,"profile_transfer_id")):y=this.safeString(p,"order_id"),{id:s,currency:l,account:m,referenceAccount:g,referenceId:y,status:"ok",amount:o,before:c,after:d,fee:void 0,direction:n,timestamp:u,datetime:this.iso8601(u),type:h,info:e}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new AS(this.id+" fetchLedger() requires a code param");await this.loadMarkets(),await this.loadAccounts();const n=this.currency(e),r=this.indexBy(this.accounts,"code"),a=this.safeValue(r,e);if(a===void 0)throw new Da(this.id+" fetchLedger() could not find account id for "+e);const o={id:a.id};t!==void 0&&(o.start_date=this.iso8601(t)),s!==void 0&&(o.limit=s);const d=await this.privateGetAccountsIdLedger(this.extend(o,i));for(let c=0;c<d.length;c++)d[c].currency=e;return this.parseLedger(d,n,t,s)}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.loadAccounts();let n,r=this.safeString(i,"id");if(r===void 0&&e!==void 0){n=this.currency(e);const d=this.indexBy(this.accounts,"code"),c=this.safeValue(d,e);if(c===void 0)throw new Da(this.id+" fetchTransactions() could not find account id for "+e);r=c.id}const a={};r!==void 0&&(a.id=r),s!==void 0&&(a.limit=s);let o;if(r===void 0){o=await this.privateGetTransfers(this.extend(a,i));for(let d=0;d<o.length;d++){const c=this.safeString(o[d],"account_id"),u=this.safeValue(this.accountsById,c),h=this.safeString(u,"code");o[d].currency=h}}else{o=await this.privateGetAccountsIdTransfers(this.extend(a,i));for(let d=0;d<o.length;d++)o[d].currency=e}return this.parseTransactions(o,n,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactions(e,t,s,this.extend({type:"deposit"},i))}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactions(e,t,s,this.extend({type:"withdraw"},i))}parseTransactionStatus(e){if(this.safeValue(e,"canceled_at"))return"canceled";const s=this.safeValue(e,"processed_at"),i=this.safeValue(e,"completed_at");return i?"ok":s&&!i?"failed":"pending"}parseTransaction(e,t=void 0){const s=this.safeValue(e,"details",{}),i=this.safeString(e,"id"),n=this.safeString(s,"crypto_transaction_hash"),r=this.parse8601(this.safeString(e,"created_at")),a=this.parse8601(this.safeString(e,"processed_at")),o=this.safeString(e,"currency"),d=this.safeCurrencyCode(o,t),c=this.parseTransactionStatus(e);let u=this.safeNumber(e,"amount"),h=this.safeString(e,"type"),l=this.safeString(s,"crypto_address");const p=this.safeString(s,"destination_tag");l=this.safeString(e,"crypto_address",l);let m;if(h==="withdraw"){h="withdrawal",l=this.safeString(s,"sent_to_address",l);const g=this.safeNumber(s,"fee");g!==void 0&&(u!==void 0&&(u-=g),m={cost:g,currency:d})}return{info:e,id:i,txid:n,timestamp:r,datetime:this.iso8601(r),network:void 0,address:l,addressTo:void 0,addressFrom:void 0,tag:p,tagTo:void 0,tagFrom:void 0,type:h,amount:u,currency:d,status:c,updated:a,fee:m}}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e);let i=this.safeValue(this.options,"coinbaseAccounts");i===void 0&&(i=await this.privateGetCoinbaseAccounts(),this.options.coinbaseAccounts=i,this.options.coinbaseAccountsByCurrencyId=this.indexBy(i,"currency"));const n=s.id,r=this.safeValue(this.options.coinbaseAccountsByCurrencyId,n);if(r===void 0)throw new H8(this.id+" createDepositAddress() could not find currency code "+e+" with id = "+n+" in this.options['coinbaseAccountsByCurrencyId']");const a={id:r.id},o=await this.privatePostCoinbaseAccountsIdAddresses(this.extend(a,t)),d=this.safeString(o,"address"),c=this.safeString(o,"destination_tag");return{currency:e,address:this.checkAddress(d),tag:c,info:o}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));s==="GET"&&Object.keys(o).length&&(a+="?"+this.urlencode(o));const d=this.implodeHostname(this.urls.api[t])+a;if(t==="private"){this.checkRequiredCredentials();const c=this.nonce().toString();let u="";s!=="GET"&&Object.keys(o).length&&(r=this.json(o),u=r);const h=c+s+a+u;let l;try{l=this.base64ToBinary(this.secret)}catch{throw new Mf(this.id+" sign() invalid base64 secret")}const p=this.hmac(this.encode(h),l,"sha256","base64");n={"CB-ACCESS-KEY":this.apiKey,"CB-ACCESS-SIGN":p,"CB-ACCESS-TIMESTAMP":c,"CB-ACCESS-PASSPHRASE":this.password,"Content-Type":"application/json"}}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(e===400||e===404){if(r[0]==="{"){const c=this.safeString(a,"message"),u=this.id+" "+c;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u),new Da(u)}throw new Da(this.id+" "+r)}}async request(e,t="public",s="GET",i={},n=void 0,r=void 0,a={},o={}){const d=await this.fetch2(e,t,s,i,n,r,a,o);if(typeof d!="string"&&"message"in d)throw new Da(this.id+" "+this.json(d));return d}};const W8=Mb;var z8=class extends W8{describe(){return this.deepExtend(super.describe(),{id:"coinbaseprime",name:"Coinbase Prime",pro:!0,hostname:"exchange.coinbase.com",urls:{test:{public:"https://public.sandbox.exchange.coinbase.com",private:"https://public.sandbox.exchange.coinbase.com"},logo:"https://user-images.githubusercontent.com/1294454/44539184-29f26e00-a70c-11e8-868f-e907fc236a7c.jpg",api:{public:"https://api.{hostname}",private:"https://api.{hostname}"},www:"https://exchange.coinbase.com",doc:"https://docs.exchange.coinbase.com"}})}};const K8=ge,{BadSymbol:X8,ExchangeError:Y8,AuthenticationError:ES}=de,{TICK_SIZE:Q8}=me;var Z8=class extends K8{describe(){return this.deepExtend(super.describe(),{id:"coincheck",name:"coincheck",countries:["JP","ID"],rateLimit:1500,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},urls:{logo:"https://user-images.githubusercontent.com/51840849/87182088-1d6d6380-c2ec-11ea-9c64-8ab9f9b289f5.jpg",api:{rest:"https://coincheck.com/api"},www:"https://coincheck.com",doc:"https://coincheck.com/documents/exchange/api",fees:["https://coincheck.com/exchange/fee","https://coincheck.com/info/fee"]},api:{public:{get:["exchange/orders/rate","order_books","rate/{pair}","ticker","trades"]},private:{get:["accounts","accounts/balance","accounts/leverage_balance","bank_accounts","deposit_money","exchange/orders/opens","exchange/orders/transactions","exchange/orders/transactions_pagination","exchange/leverage/positions","lending/borrows/matches","send_money","withdraws"],post:["bank_accounts","deposit_money/{id}/fast","exchange/orders","exchange/transfers/to_leverage","exchange/transfers/from_leverage","lending/borrows","lending/borrows/{id}/repay","send_money","withdraws"],delete:["bank_accounts/{id}","exchange/orders/{id}","withdraws/{id}"]}},markets:{"BTC/JPY":{id:"btc_jpy",symbol:"BTC/JPY",base:"BTC",quote:"JPY",baseId:"btc",quoteId:"jpy",type:"spot",spot:!0},"ETC/JPY":{id:"etc_jpy",symbol:"ETC/JPY",base:"ETC",quote:"JPY",baseId:"etc",quoteId:"jpy",type:"spot",spot:!0},"FCT/JPY":{id:"fct_jpy",symbol:"FCT/JPY",base:"FCT",quote:"JPY",baseId:"fct",quoteId:"jpy",type:"spot",spot:!0},"MONA/JPY":{id:"mona_jpy",symbol:"MONA/JPY",base:"MONA",quote:"JPY",baseId:"mona",quoteId:"jpy",type:"spot",spot:!0},"ETC/BTC":{id:"etc_btc",symbol:"ETC/BTC",base:"ETC",quote:"BTC",baseId:"etc",quoteId:"btc",type:"spot",spot:!0}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0"),taker:this.parseNumber("0")}},precisionMode:Q8,exceptions:{exact:{"disabled API Key":ES,"invalid authentication":ES},broad:{}}})}parseBalance(e){const t={info:e},s=Object.keys(this.currencies);for(let i=0;i<s.length;i++){const n=s[i],a=this.currency(n).id;if(a in e){const o=this.account(),d=a+"_reserved";o.free=this.safeString(e,a),o.used=this.safeString(e,d),t[n]=o}}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountsBalance(e);return this.parseBalance(t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));const r=await this.privateGetExchangeOrdersOpens(i),a=this.safeValue(r,"orders",[]),o=this.parseOrders(a,n,t,s),d=[];for(let c=0;c<o.length;c++)d.push(this.extend(o[c],{status:"open"}));return d}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"order_type"),n=this.parse8601(this.safeString(e,"created_at")),r=this.safeString(e,"pending_amount"),a=this.safeString(e,"pending_amount"),o=this.safeString(e,"rate"),d=void 0,c=this.safeString(e,"pair"),u=this.safeSymbol(c,t,"_");return this.safeOrder({id:s,clientOrderId:void 0,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,amount:r,remaining:a,filled:void 0,side:i,type:void 0,timeInForce:void 0,postOnly:void 0,status:d,symbol:u,price:o,stopPrice:void 0,cost:void 0,fee:void 0,info:e,average:void 0,trades:void 0},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id},r=await this.publicGetOrderBooks(this.extend(n,s));return this.parseOrderBook(r,i.symbol)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeTimestamp(e,"timestamp"),n=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){if(e!=="BTC/JPY")throw new X8(this.id+" fetchTicker() supports BTC/JPY only");await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetTicker(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"created_at")),i=this.safeString(e,"id"),n=this.safeString(e,"rate"),r=this.safeString(e,"pair");t=this.safeMarket(r,t,"_");const a=t.baseId,o=t.quoteId,d=t.symbol;let c,u,h,l,p,m;if("liquidity"in e){this.safeString(e,"liquidity")==="T"?c="taker":this.safeString(e,"liquidity")==="M"&&(c="maker");const g=this.safeValue(e,"funds",{});u=this.safeString(g,a),h=this.safeString(g,o),p={currency:this.safeString(e,"fee_currency"),cost:this.safeString(e,"fee")},l=this.safeString(e,"side"),m=this.safeString(e,"order_id")}else u=this.safeString(e,"amount"),l=this.safeString(e,"order_type");return this.safeTrade({id:i,info:e,datetime:this.iso8601(s),timestamp:s,symbol:d,type:void 0,side:l,order:m,takerOrMaker:c,price:n,amount:u,cost:h,fee:p},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={};s!==void 0&&(r.limit=s);const a=await this.privateGetExchangeOrdersTransactionsPagination(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetTrades(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetAccounts(e),s=this.safeValue(t,"exchange_fees",{}),i={};for(let n=0;n<this.symbols.length;n++){const r=this.symbols[n],a=this.market(r),o=this.safeValue(s,a.id,{});i[r]={info:o,symbol:r,maker:this.safeNumber(o,"maker_fee"),taker:this.safeNumber(o,"taker_fee"),percentage:!0,tierBased:!1}}return i}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const o={pair:this.market(e).id};if(t==="market"){const u=t+"_"+s;o.order_type=u;const h=s==="buy"?u+"_":"";o[h+"amount"]=i}else o.order_type=s,o.rate=n,o.amount=i;const d=await this.privatePostExchangeOrders(this.extend(o,r)),c=this.safeString(d,"id");return{info:d,id:c}}async cancelOrder(e,t=void 0,s={}){const i={id:e};return await this.privateDeleteExchangeOrdersId(this.extend(i,s))}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.currency=n.id),s!==void 0&&(r.limit=s);const a=await this.privateGetDepositMoney(this.extend(r,i)),o=this.safeValue(a,"deposits",[]);return this.parseTransactions(o,n,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r={};s!==void 0&&(r.limit=s);const a=await this.privateGetWithdraws(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s,{type:"withdrawal"})}parseTransactionStatus(e){const t={pending:"pending",processing:"pending",finished:"ok",canceled:"canceled",confirmed:"pending",received:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.parse8601(this.safeString(e,"created_at")),n=this.safeString(e,"address"),r=this.safeNumber(e,"amount"),a=this.safeString(e,"currency"),o=this.safeCurrencyCode(a,t),d=this.parseTransactionStatus(this.safeString(e,"status")),c=this.parse8601(this.safeString(e,"confirmed_at"));let u;const h=this.safeNumber(e,"fee");return h!==void 0&&(u={cost:h,currency:o}),{info:e,id:s,txid:void 0,timestamp:i,datetime:this.iso8601(i),network:void 0,address:n,addressTo:n,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:void 0,amount:r,currency:o,status:d,updated:c,internal:void 0,fee:u}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials();const d=this.nonce().toString();let c="";s==="GET"?Object.keys(o).length&&(a+="?"+this.urlencode(this.keysort(o))):Object.keys(o).length&&(r=this.urlencode(this.keysort(o)),c=r);const u=d+a+c;n={"Content-Type":"application/x-www-form-urlencoded","ACCESS-KEY":this.apiKey,"ACCESS-NONCE":d,"ACCESS-SIGNATURE":this.hmac(this.encode(u),this.encode(this.secret))}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;if(!this.safeValue(a,"success",!0)){const u=this.safeString(a,"error"),h=this.id+" "+this.json(a);throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwBroadlyMatchedException(this.exceptions.broad,r,h),new Y8(this.id+" "+this.json(a))}}};const J8=ge,{ExchangeError:h0,ArgumentsRequired:Ts,BadRequest:Jr,BadSymbol:l0,RateLimitExceeded:eR,InsufficientFunds:tR,OrderNotFound:sR,InvalidOrder:Ro,AuthenticationError:p0,PermissionDenied:iR,ExchangeNotAvailable:nR,RequestTimeout:rR}=de,{TICK_SIZE:aR}=me,NS=Se;var j_=class extends J8{describe(){return this.deepExtend(super.describe(),{id:"coinex",name:"CoinEx",version:"v1",countries:["CN"],rateLimit:2.5,pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!1,option:!1,addMargin:!0,borrowMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,createReduceOnlyOrder:!0,fetchBalance:!0,fetchBorrowInterest:!0,fetchBorrowRate:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddressByNetwork:!1,fetchDepositAddresses:!1,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!0,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!0,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,"fetchTransactionFee:":!1,fetchTransactoinFees:!1,fetchTransfer:!1,fetchTransfers:!0,fetchWithdrawal:!1,fetchWithdrawals:!0,reduceMargin:!0,repayMargin:!0,setLeverage:!0,setMarginMode:!0,setPositionMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","2h":"2hour","4h":"4hour","6h":"6hour","12h":"12hour","1d":"1day","3d":"3day","1w":"1week"},urls:{logo:"https://user-images.githubusercontent.com/51840849/87182089-1e05fa00-c2ec-11ea-8da9-cc73b45abbbc.jpg",api:{public:"https://api.coinex.com",private:"https://api.coinex.com",perpetualPublic:"https://api.coinex.com/perpetual",perpetualPrivate:"https://api.coinex.com/perpetual"},www:"https://www.coinex.com",doc:"https://github.com/coinexcom/coinex_exchange_api/wiki",fees:"https://www.coinex.com/fees",referral:"https://www.coinex.com/register?refer_code=yw5fz"},api:{public:{get:{"amm/market":1,"common/currency/rate":1,"common/asset/config":1,"common/maintain/info":1,"common/temp-maintain/info":1,"margin/market":1,"market/info":1,"market/list":1,"market/ticker":1,"market/ticker/all":1,"market/depth":1,"market/deals":1,"market/kline":1,"market/detail":1}},private:{get:{"account/amm/balance":40,"account/investment/balance":40,"account/balance/history":40,"account/market/fee":40,"balance/coin/deposit":40,"balance/coin/withdraw":40,"balance/info":40,"balance/deposit/address/{coin_type}":40,"contract/transfer/history":40,"credit/info":40,"credit/balance":40,"investment/transfer/history":40,"margin/account":1,"margin/config":1,"margin/loan/history":40,"margin/transfer/history":40,"order/deals":40,"order/finished":40,"order/pending":4,"order/status":4,"order/status/batch":4,"order/user/deals":40,"order/stop/finished":40,"order/stop/pending":4,"order/user/trade/fee":1,"order/market/trade/info":1,"sub_account/balance":1,"sub_account/transfer/history":40,"sub_account/auth/api/{user_auth_id}":40},post:{"balance/coin/withdraw":40,"contract/balance/transfer":40,"margin/flat":40,"margin/loan":40,"margin/transfer":40,"order/limit/batch":13.334,"order/ioc":6.667,"order/limit":6.667,"order/market":6.667,"order/modify":6.667,"order/stop/limit":6.667,"order/stop/market":6.667,"order/stop/modify":6.667,"sub_account/transfer":40,"sub_account/register":1,"sub_account/unfrozen":40,"sub_account/frozen":40,"sub_account/auth/api":40},put:{"balance/deposit/address/{coin_type}":40,"sub_account/auth/api/{user_auth_id}":40,"v1/account/settings":40},delete:{"balance/coin/withdraw":40,"order/pending/batch":13.334,"order/pending":6.667,"order/stop/pending":13.334,"order/stop/pending/{id}":13.334,"sub_account/auth/api/{user_auth_id}":40}},perpetualPublic:{get:{ping:1,time:1,"market/list":1,"market/limit_config":1,"market/ticker":1,"market/ticker/all":1,"market/depth":1,"market/deals":1,"market/funding_history":1,"market/user_deals":1,"market/kline":1}},perpetualPrivate:{get:{"asset/query":40,"order/pending":4,"order/finished":40,"order/stop_finished":40,"order/stop_pending":4,"order/status":4,"order/stop_status":4,"position/pending":40,"position/funding":40},post:{"market/adjust_leverage":1,"market/position_expect":1,"order/put_limit":10,"order/put_market":10,"order/put_stop_limit":10,"order/put_stop_market":10,"order/modify":10,"order/modify_stop":10,"order/cancel":10,"order/cancel_all":20,"order/cancel_batch":20,"order/cancel_stop":10,"order/cancel_stop_all":20,"order/close_limit":10,"order/close_market":10,"position/adjust_margin":10,"position/stop_loss":10,"position/take_profit":10,"position/market_close":10}}},fees:{trading:{maker:.001,taker:.001},funding:{withdraw:{BCH:0,BTC:.001,LTC:.001,ETH:.001,ZEC:1e-4,DASH:1e-4}}},limits:{amount:{min:.001,max:void 0}},precision:{amount:this.parseNumber("0.00000001"),price:this.parseNumber("0.00000001")},options:{createMarketBuyOrderRequiresPrice:!0,defaultType:"spot",defaultSubType:"linear",defaultMarginMode:"isolated",fetchDepositAddress:{fillResponseFromRequest:!0},accountsById:{spot:"0"}},commonCurrencies:{ACM:"Actinium"},precisionMode:aR})}async fetchCurrencies(e={}){const t=await this.publicGetCommonAssetConfig(e),s=this.safeValue(t,"data",[]),i=Object.keys(s),n={};for(let r=0;r<i.length;r++){const a=i[r],o=s[a],d=this.safeString(o,"asset"),c=this.safeString(o,"chain"),u=this.safeCurrencyCode(d);this.safeValue(n,u)===void 0&&(n[u]={id:d,numericId:void 0,code:u,info:o,name:void 0,active:!0,deposit:this.safeValue(o,"can_deposit"),withdraw:this.safeValue(o,"can_withdraw"),fee:this.safeNumber(o,"withdraw_tx_fee"),precision:this.parseNumber(this.parsePrecision(this.safeString(o,"withdrawal_precision"))),limits:{amount:{min:void 0,max:void 0},deposit:{min:this.safeNumber(o,"deposit_least_amount"),max:void 0},withdraw:{min:this.safeNumber(o,"withdraw_least_amount"),max:void 0}}});const h=this.safeValue(n[u],"networks",{}),l={info:o,id:c,network:c,name:void 0,limits:{amount:{min:void 0,max:void 0},deposit:{min:this.safeNumber(o,"deposit_least_amount"),max:void 0},withdraw:{min:this.safeNumber(o,"withdraw_least_amount"),max:void 0}},active:!0,deposit:this.safeValue(o,"can_deposit"),withdraw:this.safeValue(o,"can_withdraw"),fee:this.safeNumber(o,"withdraw_tx_fee"),precision:this.parseNumber(this.parsePrecision(this.safeString(o,"withdrawal_precision")))};h[c]=l,n[u].networks=h}return n}async fetchMarkets(e={}){let t=[];const[s,i]=this.handleMarketTypeAndParams("fetchMarkets",void 0,e);if(s==="spot"||s==="margin")t=await this.fetchSpotMarkets(i);else if(s==="swap")t=await this.fetchContractMarkets(i);else throw new h0(this.id+" does not support the '"+s+"' market type, set exchange.options['defaultType'] to 'spot', 'margin' or 'swap'");return t}async fetchSpotMarkets(e){const t=await this.publicGetMarketInfo(e),s=this.safeValue(t,"data",{}),i=[],n=Object.keys(s);for(let r=0;r<n.length;r++){const a=n[r],o=s[a],d=this.safeString(o,"name"),c=this.safeString(o,"trading_name"),u=c,h=this.safeString(o,"pricing_name"),l=this.safeCurrencyCode(u),p=this.safeCurrencyCode(h);let m=l+"/"+p;c===d&&(m=d),i.push({id:d,symbol:m,base:l,quote:p,settle:void 0,baseId:u,quoteId:h,settleId:void 0,type:"spot",spot:!0,margin:void 0,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(o,"taker_fee_rate"),maker:this.safeNumber(o,"maker_fee_rate"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(o,"trading_decimal"))),price:this.parseNumber(this.parsePrecision(this.safeString(o,"pricing_decimal")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(o,"min_amount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:o})}return i}async fetchContractMarkets(e){const t=await this.perpetualPublicGetMarketList(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.fees,o=this.safeValue(r,"leverages",[]),d=this.safeInteger(r,"type"),c=d===1,u=d===2,h=this.safeString(r,"name"),l=this.safeString(r,"stock"),p=this.safeString(r,"money"),m=this.safeCurrencyCode(l),g=this.safeCurrencyCode(p),y=d===1?"USDT":l,b=this.safeCurrencyCode(y),w=m+"/"+g+":"+b;i.push({id:h,symbol:w,base:m,quote:g,settle:b,baseId:l,quoteId:p,settleId:y,type:"swap",spot:!1,margin:!1,swap:!0,future:!1,option:!1,active:this.safeValue(r,"available"),contract:!0,linear:c,inverse:u,taker:a.trading.taker,maker:a.trading.maker,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"stock_prec"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"money_prec")))},limits:{leverage:{min:this.safeString(o,0),max:this.safeString(o,o.length-1)},amount:{min:this.safeString(r,"amount_min"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}parseTicker(e,t=void 0){const s=this.safeInteger(e,"date"),i=this.safeSymbol(void 0,t);e=this.safeValue(e,"ticker",{});const n=this.safeString(e,"last");return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString2(e,"vol","volume"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id},n=s.swap?"perpetualPublicGetMarketTicker":"publicGetMarketTicker",r=await this[n](this.extend(i,t));return this.parseTicker(r.data,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s;if(e!==void 0){const l=this.safeValue(e,0);s=this.market(l)}const[i,n]=this.handleMarketTypeAndParams("fetchTickers",s,t),a=await this[i==="swap"?"perpetualPublicGetMarketTickerAll":"publicGetMarketTickerAll"](n),o=this.safeValue(a,"data"),d=this.safeInteger(o,"date"),c=this.safeValue(o,"ticker",{}),u=Object.keys(c),h={};for(let l=0;l<u.length;l++){const p=u[l],m=this.safeMarket(p),g=m.symbol,y=this.parseTicker({date:d,ticker:c[p]},m);y.symbol=g,h[g]=y}return this.filterByArray(h,"symbol",e)}async fetchTime(e={}){const t=await this.perpetualPublicGetTime(e);return this.safeNumber(t,"data")}async fetchOrderBook(e,t=20,s={}){if(e===void 0)throw new Ts(this.id+" fetchOrderBook() requires a symbol argument");await this.loadMarkets();const i=this.market(e);t===void 0&&(t=20);const n={market:this.marketId(e),merge:"0",limit:t.toString()},r=i.swap?"perpetualPublicGetMarketDepth":"publicGetMarketDepth",a=await this[r](this.extend(n,s)),o=this.safeValue(a,"data",{}),d=this.safeInteger(o,"time");return this.parseOrderBook(o,e,d)}parseTrade(e,t=void 0){let s=this.safeTimestamp2(e,"create_time","time");s===void 0&&(s=this.safeInteger(e,"date_ms"));const i=this.safeString(e,"id"),n=this.safeString(e,"order_id"),r=this.safeString(e,"price"),a=this.safeString(e,"amount"),o=this.safeString(e,"market");t=this.safeMarket(o,t);const d=this.safeSymbol(o,t),c=this.safeString(e,"deal_money");let u;const h=this.safeString2(e,"fee","deal_fee");if(h!==void 0){const m=this.safeString(e,"fee_asset"),g=this.safeCurrencyCode(m);u={cost:h,currency:g}}let l=this.safeString(e,"role");l==="1"?l="maker":l==="2"&&(l="taker");let p;return t.type==="swap"?(p=this.safeInteger(e,"side"),p===1?p="sell":p===2&&(p="buy"),p===void 0&&(p=this.safeString(e,"type"))):p=this.safeString(e,"type"),this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:d,id:i,order:n,type:void 0,side:p,takerOrMaker:l,price:r,amount:a,cost:c,fee:u},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market:n.id};s!==void 0&&(r.limit=s);const a=n.swap?"perpetualPublicGetMarketDeals":"publicGetMarketDeals",o=await this[a](this.extend(r,i));return this.parseTrades(o.data,n,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const i={market:this.market(e).id},n=await this.publicGetMarketDetail(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTradingFee(r)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetMarketInfo(e),s=this.safeValue(t,"data",{}),i={};for(let n=0;n<this.symbols.length;n++){const r=this.symbols[n],a=this.market(r),o=this.safeValue(s,a.id,{});i[r]=this.parseTradingFee(o,a)}return i}parseTradingFee(e,t=void 0){const s=this.safeValue(e,"name"),i=this.safeSymbol(s,t);return{info:e,symbol:i,maker:this.safeNumber(e,"maker_fee_rate"),taker:this.safeNumber(e,"taker_fee_rate"),percentage:!0,tierBased:!0}}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={market:r.id,type:this.timeframes[t]};i!==void 0&&(a.limit=i);const o=r.swap?"perpetualPublicGetMarketKline":"publicGetMarketKline",d=await this[o](this.extend(a,n)),c=this.safeValue(d,"data",[]);return this.parseOHLCVs(c,r,t,s,i)}async fetchMarginBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"symbol");let s=this.safeString(e,"market"),i;if(t!==void 0)i=this.market(t),s=i.id;else if(s===void 0)throw new Ts(this.id+" fetchMarginBalance() fetching a margin account requires a market parameter or a symbol parameter");e=this.omit(e,["symbol","market"]);const n={market:s},r=await this.privateGetMarginAccount(this.extend(n,e)),a={info:r},o=this.safeValue(r,"data",{}),d=this.safeValue(o,"can_transfer",{}),c=this.safeValue(o,"balance",{}),u=this.account(),h=this.safeString(o,"sell_asset_type"),l=this.safeCurrencyCode(h);u.free=this.safeString(d,"sell_type"),u.total=this.safeString(c,"sell_type"),a[l]=u;const p=this.account(),m=this.safeString(o,"buy_asset_type"),g=this.safeCurrencyCode(m);return p.free=this.safeString(d,"buy_type"),p.total=this.safeString(c,"buy_type"),a[g]=p,this.safeBalance(a)}async fetchSpotBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalanceInfo(e),s={info:t},i=this.safeValue(t,"data",{}),n=Object.keys(i);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeCurrencyCode(a),d=this.safeValue(i,a,{}),c=this.account();c.free=this.safeString(d,"available"),c.used=this.safeString(d,"frozen"),s[o]=c}return this.safeBalance(s)}async fetchSwapBalance(e={}){await this.loadMarkets();const t=await this.perpetualPrivateGetAssetQuery(e),s={info:t},i=this.safeValue(t,"data",{}),n=Object.keys(i);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeCurrencyCode(a),d=this.safeValue(i,a,{}),c=this.account();c.free=this.safeString(d,"available"),c.used=this.safeString(d,"frozen"),c.total=this.safeString(d,"balance_total"),s[o]=c}return this.safeBalance(s)}async fetchBalance(e={}){const t=this.safeString(e,"type","main");return e=this.omit(e,"type"),t==="margin"?await this.fetchMarginBalance(e):t==="swap"?await this.fetchSwapBalance(e):await this.fetchSpotBalance(e)}parseOrderStatus(e){const t={not_deal:"open",part_deal:"open",done:"closed",cancel:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeTimestamp(e,"create_time"),i=this.safeString(e,"price"),n=this.safeString(e,"deal_money"),r=this.safeString(e,"amount"),a=this.safeString(e,"deal_amount"),o=this.safeString(e,"avg_price"),d=this.safeString(e,"left"),c=this.safeString(e,"market");t=this.safeMarket(c,t);const u=this.safeString(e,"fee_asset");let h=this.safeCurrencyCode(u);h===void 0&&(h=t.quote);const l=this.parseOrderStatus(this.safeString(e,"status"));let p=this.safeInteger(e,"side");p===1?p="sell":p===2?p="buy":p=this.safeString(e,"type");let m=this.safeString(e,"order_type");return m===void 0&&(m=this.safeInteger(e,"type"),m===1?m="limit":m===2&&(m="market")),this.safeOrder({id:this.safeString2(e,"id","order_id"),clientOrderId:void 0,datetime:this.iso8601(s),timestamp:s,lastTradeTimestamp:this.safeTimestamp(e,"update_time"),status:l,symbol:t.symbol,type:m,timeInForce:void 0,postOnly:void 0,reduceOnly:void 0,side:p,price:i,stopPrice:this.safeString(e,"stop_price"),cost:n,average:o,amount:r,filled:a,remaining:d,trades:void 0,fee:{currency:h,cost:this.safeString(e,"deal_fee")},info:e},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=a.swap,d=this.safeValue2(r,"stopPrice","triggerPrice"),c=this.safeValue(r,"stopLossPrice"),u=this.safeValue(r,"takeProfitPrice"),h=this.safeString(r,"option"),l=t==="market",p=this.isPostOnly(l,h==="MAKER_ONLY",r),m=this.safeInteger2(r,"position_id","positionId");let g=this.safeString(r,"timeInForce");const y=this.safeValue(r,"reduceOnly");if(y!==void 0&&a.type!=="swap")throw new Ro(this.id+" createOrder() does not support reduceOnly for "+a.type+" orders, reduceOnly orders are supported for swap markets only");let b;const w={market:a.id};if(o)if(c||u){if(w.stop_type=this.safeInteger(r,"stop_type",1),m===void 0)throw new Ts(this.id+" createOrder() requires a position_id parameter for stop loss and take profit orders");w.position_id=m,c?(b="perpetualPrivatePostPositionStopLoss",w.stop_loss_price=this.priceToPrecision(e,c)):u&&(b="perpetualPrivatePostPositionTakeProfit",w.take_profit_price=this.priceToPrecision(e,u))}else b="perpetualPrivatePostOrderPut"+this.capitalize(t),s=s==="buy"?2:1,d!==void 0&&(w.stop_price=this.priceToPrecision(e,d),w.stop_type=this.safeInteger(r,"stop_type",1),w.amount=this.amountToPrecision(e,i),w.side=s,t==="limit"?(b="perpetualPrivatePostOrderPutStopLimit",w.price=this.priceToPrecision(e,n)):t==="market"&&(b="perpetualPrivatePostOrderPutStopMarket"),w.amount=this.amountToPrecision(e,i)),(t!=="market"||d!==void 0)&&(p?w.option=1:g!==void 0&&(g==="IOC"?g=2:g==="FOK"?g=3:g=1,w.effect_type=g)),t==="limit"&&d===void 0?(y?(b="perpetualPrivatePostOrderCloseLimit",w.position_id=m):w.side=s,w.price=this.priceToPrecision(e,n),w.amount=this.amountToPrecision(e,i)):t==="market"&&d===void 0&&(y?(b="perpetualPrivatePostOrderCloseMarket",w.position_id=m):(w.side=s,w.amount=this.amountToPrecision(e,i)));else{if(b="privatePostOrder"+this.capitalize(t),w.type=s,t==="market"&&s==="buy")if(this.options.createMarketBuyOrderRequiresPrice){if(n===void 0)throw new Ro(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)");{const C=this.amountToPrecision(e,i),E=this.priceToPrecision(e,n),P=NS.stringMul(C,E),_=this.parseNumber(P);w.amount=this.costToPrecision(e,_)}}else w.amount=this.costToPrecision(e,i);else w.amount=this.amountToPrecision(e,i);if((t==="limit"||t==="ioc")&&(w.price=this.priceToPrecision(e,n)),d!==void 0&&(w.stop_price=this.priceToPrecision(e,d),t==="limit"?b="privatePostOrderStopLimit":t==="market"&&(b="privatePostOrderStopMarket")),(t!=="market"||d!==void 0)&&(g!==void 0||p)){if((p||g!=="IOC")&&t==="limit"&&d!==void 0)throw new Ro(this.id+" createOrder() only supports the IOC option for stop-limit orders");p?w.option="MAKER_ONLY":g!==void 0&&(w.option=g)}}const k=this.safeInteger(r,"account_id");if(this.safeString(this.options,"defaultType")==="margin"){if(k===void 0)throw new Jr(this.id+" createOrder() requires an account_id parameter for margin orders");w.account_id=k}r=this.omit(r,["reduceOnly","positionId","timeInForce","postOnly","stopPrice","triggerPrice","stopLossPrice","takeProfitPrice"]);const O=await this[b](this.extend(w,r)),x=this.safeValue(O,"data");return this.parseOrder(x,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(t),n=this.safeValue(s,"stop"),r=i.swap,a={market:i.id},o=r?"order_id":"id";a[o]=e;let d=r?"perpetualPrivatePostOrderCancel":"privateDeleteOrderPending";n&&(r?d="perpetualPrivatePostOrderCancelStop":d="privateDeleteOrderStopPendingId");const c=this.safeInteger(s,"account_id");if(this.safeString(this.options,"defaultType")==="margin"){if(c===void 0)throw new Jr(this.id+" cancelOrder() requires an account_id parameter for margin orders");a.account_id=c}const h=this.omit(s,["stop","account_id"]),l=await this[d](this.extend(a,h)),p=this.safeValue(l,"data");return this.parseOrder(p,i)}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new Ts(this.id+" cancellAllOrders() requires a symbol argument");await this.loadMarkets();const s=this.market(e),i=s.id,n=this.safeInteger(t,"account_id",0),r={market:i},a=s.swap,o=this.safeValue(t,"stop");let d;return a?(d="perpetualPrivatePostOrderCancelAll",o&&(d="perpetualPrivatePostOrderCancelStopAll")):(d="privateDeleteOrderPending",o&&(d="privateDeleteOrderStopPending"),r.account_id=n),t=this.omit(t,["stop","account_id"]),await this[d](this.extend(r,t))}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Ts(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=i.swap,r=this.safeValue(s,"stop"),a={market:i.id},o=n?"order_id":"id";a[o]=e;let d;n?d=r?"perpetualPrivateGetOrderStopStatus":"perpetualPrivateGetOrderStatus":d="privateGetOrderStatus",s=this.omit(s,"stop");const c=await this[d](this.extend(a,s)),u=this.safeValue(c,"data");return this.parseOrder(u,i)}async fetchOrdersByStatus(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets(),i=i===void 0?100:i;const r={limit:i},a=this.safeValue(n,"stop"),o=this.safeInteger(n,"side");n=this.omit(n,"stop");let d;t!==void 0&&(d=this.market(t),r.market=d.id);const[c,u]=this.handleMarketTypeAndParams("fetchOrdersByStatus",d,n);let h;if(c==="swap"){if(t===void 0)throw new Ts(this.id+" fetchOrdersByStatus() requires a symbol argument for swap markets");h="perpetualPrivateGetOrder"+this.capitalize(e),a&&(h="perpetualPrivateGetOrderStopPending"),o!==void 0?r.side=o:r.side=0,r.offset=0}else h="privateGetOrder"+this.capitalize(e),a&&(h="privateGetOrderStop"+this.capitalize(e)),r.page=1;const l=this.safeInteger(n,"account_id");if(this.safeString(this.options,"defaultType")==="margin"){if(l===void 0)throw new Jr(this.id+" fetchOpenOrders() and fetchClosedOrders() require an account_id parameter for margin orders");r.account_id=l}n=this.omit(u,"account_id");const m=await this[h](this.extend(r,n)),g=c==="swap"?"records":"data",y=this.safeValue(m,"data"),b=this.safeValue(y,g,[]);return this.parseOrders(b,d,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("pending",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("finished",e,t,s,i)}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={coin_type:s.id};if("network"in t){const a=this.safeString(t,"network");t=this.omit(t,"network"),i.smart_contract_name=a}const n=await this.privatePutBalanceDepositAddressCoinType(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseDepositAddress(r,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={coin_type:s.id},n=this.safeValue(s,"networks",{}),r=this.safeString(t,"network");t=this.omit(t,"network");const o=Object.keys(n).length;if(n!==void 0&&o>1){if(r===void 0)throw new Ts(this.id+" fetchDepositAddress() "+e+" requires a network parameter");if(!(r in n))throw new h0(this.id+" fetchDepositAddress() "+r+" network not supported for "+e)}r!==void 0&&(i.smart_contract_name=r);const d=await this.privateGetBalanceDepositAddressCoinType(this.extend(i,t)),c=this.safeValue(d,"data",{}),u=this.parseDepositAddress(c,s),h=this.safeValue(this.options,"fetchDepositAddress",{});return this.safeValue(h,"fillResponseFromRequest",!0)&&(u.network=this.safeNetworkCode(r,s)),u}safeNetwork(e,t=void 0){const s=this.safeValue(t,"networks",{}),i=Object.keys(s);return e===void 0&&i.length===1?s[i[0]]:{id:e,network:e===void 0?void 0:e.toUpperCase()}}safeNetworkCode(e,t=void 0){return this.safeNetwork(e,t).network}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"coin_address");return{info:e,currency:this.safeCurrencyCode(void 0,t),address:s,tag:void 0,network:void 0}}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;s===void 0&&(s=100);const r={limit:s,offset:0};e!==void 0&&(n=this.market(e),r.market=n.id);let a;if([a,i]=this.handleMarketTypeAndParams("fetchMyTrades",n,i),a!=="spot"&&e===void 0)throw new Ts(this.id+" fetchMyTrades() requires a symbol argument for non-spot markets");const o=a==="swap";let d;if(o){d="perpetualPublicGetMarketUserDeals";const g=this.safeInteger(i,"side");if(g===void 0)throw new Ts(this.id+" fetchMyTrades() requires a side parameter for swap markets");t!==void 0&&(r.start_time=t),r.side=g,i=this.omit(i,"side")}else d="privateGetOrderUserDeals",r.page=1;const c=this.safeInteger(i,"account_id");if(this.safeString(this.options,"defaultType")==="margin"){if(c===void 0)throw new Jr(this.id+" fetchMyTrades() requires an account_id parameter for margin trades");r.account_id=c,i=this.omit(i,"account_id")}const h=await this[d](this.extend(r,i)),l=o?"records":"data",p=this.safeValue(h,"data"),m=this.safeValue(p,l,[]);return this.parseTrades(m,n,t,s)}async fetchPositions(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={};let i;if(e!==void 0){let o;if(Array.isArray(e)){if(e.length>1)throw new Jr(this.id+" fetchPositions() symbols argument cannot contain more than 1 symbol");o=e[0]}else o=e;i=this.market(o),s.market=i.id}const n=await this.perpetualPrivateGetPositionPending(this.extend(s,t)),r=this.safeValue(n,"data",[]),a=[];for(let o=0;o<r.length;o++)a.push(this.parsePosition(r[o],i));return this.filterByArray(a,"symbol",e,!1)}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id},n=await this.perpetualPrivateGetPositionPending(this.extend(i,t)),r=this.safeValue(n,"data",[]);return this.parsePosition(r[0],s)}parsePosition(e,t=void 0){const s=this.safeString(e,"market");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeInteger(e,"position_id"),a=this.safeInteger(e,"type")===1?"isolated":"cross",o=this.safeString(e,"liq_price"),d=this.safeString(e,"open_price"),c=this.safeString(e,"profit_unreal"),u=this.safeString(e,"amount"),l=this.safeInteger(e,"side")===1?"short":"long",p=this.safeTimestamp(e,"update_time"),m=this.safeString(e,"mainten_margin_amount"),g=this.safeString(e,"mainten_margin"),y=this.safeString(e,"margin_amount"),b=this.safeNumber(e,"leverage");return{info:e,id:n,symbol:i,notional:void 0,marginMode:a,liquidationPrice:o,entryPrice:d,unrealizedPnl:c,percentage:void 0,contracts:void 0,contractSize:u,markPrice:void 0,side:l,hedged:void 0,timestamp:p,datetime:this.iso8601(p),maintenanceMargin:m,maintenanceMarginPercentage:g,collateral:y,initialMargin:void 0,initialMarginPercentage:void 0,leverage:b,marginRatio:void 0}}async setMarginMode(e,t=void 0,s={}){if(t===void 0)throw new Ts(this.id+" setMarginMode() requires a symbol argument");if(e=e.toLowerCase(),e!=="isolated"&&e!=="cross")throw new Jr(this.id+" setMarginMode() marginMode argument should be isolated or cross");await this.loadMarkets();const i=this.market(t);if(i.type!=="swap")throw new l0(this.id+" setMarginMode() supports swap contracts only");let n;e==="isolated"?n=1:e==="cross"&&(n=2);const r=this.safeInteger(s,"leverage"),a=this.safeInteger(i.limits.leverage,"max",100),o=this.safeInteger(s,"position_type",n);if(r===void 0)throw new Ts(this.id+" setMarginMode() requires a leverage parameter");if(o===void 0)throw new Ts(this.id+" setMarginMode() requires a position_type parameter that will transfer margin to the specified trading pair");if(r<3||r>a)throw new Jr(this.id+" setMarginMode() leverage should be between 3 and "+a.toString()+" for "+t);const d={market:i.id,leverage:r.toString(),position_type:o};return await this.perpetualPrivatePostMarketAdjustLeverage(this.extend(d,s))}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new Ts(this.id+" setLeverage() requires a symbol argument");await this.loadMarkets();const i=this.safeString2(this.options,"defaultMarginMode","marginMode");let n;i==="isolated"?n=1:i==="cross"&&(n=2);const r=this.safeInteger(s,"position_type",n);if(r===void 0)throw new Ts(this.id+" setLeverage() requires a position_type parameter that will transfer margin to the specified trading pair");const a=this.market(t),o=this.safeInteger(a.limits.leverage,"max",100);if(a.type!=="swap")throw new l0(this.id+" setLeverage() supports swap contracts only");if(e<3||e>o)throw new Jr(this.id+" setLeverage() leverage should be between 3 and "+o.toString()+" for "+t);const d={market:a.id,leverage:e.toString(),position_type:r};return await this.perpetualPrivatePostMarketAdjustLeverage(this.extend(d,s))}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const s=await this.perpetualPublicGetMarketLimitConfig(t),i=this.safeValue(s,"data",{});return this.parseLeverageTiers(i,e,void 0)}parseLeverageTiers(e,t=void 0,s=void 0){const i={},n=Object.keys(e);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeMarket(a),d=this.safeString(o,"symbol");let c=0;t!==void 0&&(c=t.length),d!==void 0&&(c===0||this.inArray(t,d))&&(i[d]=this.parseMarketLeverageTiers(e[a],o))}return i}parseMarketLeverageTiers(e,t=void 0){const s=[];let i=0;for(let n=0;n<e.length;n++){const r=e[n],a=this.safeNumber(r,0);s.push({tier:n+1,currency:t.linear?t.base:t.quote,minNotional:i,maxNotional:a,maintenanceMarginRate:this.safeNumber(r,2),maxLeverage:this.safeInteger(r,1),info:r}),i=a}return s}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets();const n=this.market(e),r={market:n.id,amount:this.amountToPrecision(e,t),type:s},a=await this.perpetualPrivatePostPositionAdjustMargin(this.extend(r,i)),o=this.safeString(a,"message"),d=s===1?"add":"reduce";return this.extend(this.parseMarginModification(a,n),{amount:this.parseNumber(t),type:d,status:o})}parseMarginModification(e,t=void 0){return{info:e,type:void 0,amount:void 0,code:t.quote,symbol:this.safeSymbol(void 0,t),status:void 0}}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,1,s)}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,2,s)}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Ts(this.id+" fetchFundingHistory() requires a symbol argument");s=s===void 0?100:s,await this.loadMarkets();const r={market:this.market(e).id,limit:s};t!==void 0&&(r.start_time=t);const a=await this.perpetualPrivateGetPositionFunding(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"records",[]),c=[];for(let u=0;u<d.length;u++){const h=d[u],l=this.safeTimestamp(h,"time"),p=this.safeString(h,"asset"),m=this.safeCurrencyCode(p);c.push({info:h,symbol:e,code:m,timestamp:l,datetime:this.iso8601(l),id:this.safeNumber(h,"position_id"),amount:this.safeNumber(h,"funding")})}return c}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new l0(this.id+" fetchFundingRate() supports swap contracts only");const i={market:s.id},n=await this.perpetualPublicGetMarketTicker(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"ticker",{});return this.parseFundingRate(a,s)}parseFundingRate(e,t=void 0){return{info:e,symbol:this.safeSymbol(void 0,t),markPrice:this.safeString(e,"sign_price"),indexPrice:this.safeString(e,"index_price"),interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeString(e,"funding_rate_next"),fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:this.safeString(e,"funding_rate_predict"),nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:this.safeString(e,"funding_rate_last"),previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e);i&&(s=s+":"+i);const a={coin_type:r.id,coin_address:s,actual_amount:parseFloat(t),transfer_method:"onchain"},o=await this.privatePostBalanceCoinWithdraw(this.extend(a,n)),d=this.safeValue(o,"data",{});return this.parseTransaction(d,r)}parseTransactionStatus(e){const t={audit:"pending",pass:"pending",processing:"pending",confirming:"pending",not_pass:"failed",cancel:"canceled",finish:"ok",fail:"failed"};return this.safeString(t,e,e)}async fetchFundingRateHistory(e=void 0,t=void 0,s=100,i={}){if(e===void 0)throw new Ts(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={market:n.id,limit:s,offset:0};t!==void 0&&(r.start_time=t);const a=await this.perpetualPublicGetMarketFundingHistory(this.extend(r,i)),o=this.safeValue(a,"data"),d=this.safeValue(o,"records",[]),c=[];for(let h=0;h<d.length;h++){const l=d[h],p=this.safeString(l,"market"),m=this.safeSymbol(p),g=this.safeTimestamp(l,"time");c.push({info:l,symbol:m,fundingRate:this.safeString(l,"funding_rate"),timestamp:g,datetime:this.iso8601(g)})}const u=this.sortBy(c,"timestamp");return this.filterBySymbolSinceLimit(u,n.symbol,t,s)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"coin_withdraw_id","coin_deposit_id"),i=this.safeString(e,"coin_address");let n=this.safeString(e,"remark");n!==void 0&&n.length<1&&(n=void 0);let r=this.safeValue(e,"tx_id");r!==void 0&&r.length<1&&(r=void 0);const a=this.safeString(e,"coin_type"),o=this.safeCurrencyCode(a,t),d=this.safeTimestamp(e,"create_time"),c="coin_withdraw_id"in e?"withdraw":"deposit",u=this.parseTransactionStatus(this.safeString(e,"status"));let h=this.safeNumber(e,"amount"),l=this.safeNumber(e,"tx_fee");c==="deposit"&&(l=0);const p={cost:l,currency:o};return h!==void 0&&(h=h-l),{info:e,id:s,txid:r,timestamp:d,datetime:this.iso8601(d),network:void 0,address:i,addressTo:void 0,addressFrom:void 0,tag:n,tagTo:void 0,tagFrom:void 0,type:c,amount:h,currency:o,status:u,updated:void 0,fee:p}}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.currencyToPrecision(e,t),o={amount:a,coin_type:r.id};let d="privatePostContractBalanceTransfer";if(s==="spot"&&i==="swap")o.transfer_side="in";else if(s==="swap"&&i==="spot")o.transfer_side="out";else{const u=this.safeValue(this.options,"accountsById",{}),h=this.safeString(u,s,s),l=this.safeString(u,i,i);o.from_account=parseInt(h),o.to_account=parseInt(l),d="privatePostMarginTransfer"}const c=await this[d](this.extend(o,n));return this.extend(this.parseTransfer(c,r),{amount:this.parseNumber(a),fromAccount:s,toAccount:i})}parseTransferStatus(e){const t={0:"ok",SUCCESS:"ok"};return this.safeString(t,e,e)}parseTransfer(e,t=void 0){const s=this.safeTimestamp(e,"created_at"),i=this.safeString(e,"transfer_type");let n,r;i==="transfer_out"?(n="swap",r="spot"):i==="transfer_in"?(n="spot",r="swap"):i==="IN"?(n="spot",r="margin"):i==="OUT"&&(n="margin",r="spot");const a=this.safeString(e,"asset"),o=this.safeCurrencyCode(a,t);return{id:this.safeInteger(e,"id"),timestamp:s,datetime:this.iso8601(s),currency:o,amount:this.safeNumber(e,"amount"),fromAccount:n,toAccount:r,status:this.parseTransferStatus(this.safeString2(e,"code","status"))}}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={page:1,limit:s},a=this.safeInteger(i,"page");a!==void 0&&(r.page=a),e!==void 0&&(n=this.safeCurrencyCode(e),r.asset=n.id),t!==void 0&&(r.start_time=t),i=this.omit(i,"page");const d=this.safeString(this.options,"defaultType")==="margin"?"privateGetMarginTransferHistory":"privateGetContractTransferHistory",c=await this[d](this.extend(r,i)),u=this.safeValue(c,"data",{}),h=this.safeValue(u,"records",[]);return this.parseTransfers(h,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Ts(this.id+" fetchWithdrawals() requires a currency code argument");await this.loadMarkets();const n=this.currency(e),r={coin_type:n.id};s!==void 0&&(r.Limit=s);const a=await this.privateGetBalanceCoinWithdraw(this.extend(r,i));let o=this.safeValue(a,"data");return Array.isArray(o)||(o=this.safeValue(o,"data",[])),this.parseTransactions(o,n,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Ts(this.id+" fetchDeposits() requires a currency code argument");await this.loadMarkets();const n=this.currency(e),r={coin_type:n.id};s!==void 0&&(r.Limit=s);const a=await this.privateGetBalanceCoinDeposit(this.extend(r,i));let o=this.safeValue(a,"data");return Array.isArray(o)||(o=this.safeValue(o,"data",[])),this.parseTransactions(o,n,t,s)}parseBorrowRate(e,t=void 0){const s=this.milliseconds(),i=this.safeValue(e,t,{});return{currency:this.safeCurrencyCode(t),rate:this.safeNumber(i,"day_rate"),period:864e5,timestamp:s,datetime:this.iso8601(s),info:e}}async fetchBorrowRate(e,t={}){await this.loadMarkets();let s;if(e in this.markets)s=this.market(e);else{const a=this.safeString(this.options,"defaultSettle","USDT");s=this.market(e+"/"+a)}const i={market:s.id},n=await this.privateGetMarginConfig(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseBorrowRate(r,s.base)}async fetchBorrowRates(e={}){await this.loadMarkets();const t=await this.privateGetMarginConfig(e),s=this.milliseconds(),i=this.safeValue(t,"data",{}),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"market"),d=this.safeMarket(o),c=this.safeValue(a,d.base);n.push({currency:d.base,rate:this.safeNumber(c,"day_rate"),period:864e5,timestamp:s,datetime:this.iso8601(s),info:a})}return n}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a;t!==void 0&&(a=this.market(t),r.market=a.id),i!==void 0&&(r.limit=i);const o=await this.privateGetMarginLoanHistory(this.extend(r,n)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"data",[]),u=this.parseBorrowInterests(c,a);return this.filterByCurrencySinceLimit(u,e,s,i)}parseBorrowInterest(e,t=void 0){const s=this.safeString(e,"market_type");t=this.safeMarket(s,t);const i=this.safeString(t,"symbol"),n=this.safeTimestamp(e,"expire_time"),r=this.safeString(e,"unflat_amount"),a=this.safeString(e,"loan_amount");let o=NS.stringSub(r,a);return r==="0"&&(o=void 0),{account:void 0,symbol:i,marginMode:"isolated",marginType:void 0,currency:this.safeCurrencyCode(this.safeString(e,"coin_type")),interest:this.parseNumber(o),interestRate:this.safeNumber(e,"day_rate"),amountBorrowed:this.parseNumber(a),timestamp:n,datetime:this.iso8601(n),info:e}}async borrowMargin(e,t,s=void 0,i={}){if(s===void 0)throw new Ts(this.id+" borrowMargin() requires a symbol argument");await this.loadMarkets();const n=this.market(s),r=this.currency(e),a={market:n.id,coin_type:r.id,amount:this.currencyToPrecision(e,t)},o=await this.privatePostMarginLoan(this.extend(a,i)),d=this.safeValue(o,"data",{}),c=this.parseMarginLoan(d,r);return this.extend(c,{amount:t,symbol:s})}async repayMargin(e,t,s=void 0,i={}){if(s===void 0)throw new Ts(this.id+" repayMargin() requires a symbol argument");await this.loadMarkets();const n=this.market(s),r=this.currency(e),a={market:n.id,coin_type:r.id,amount:this.currencyToPrecision(e,t)},o=this.safeInteger(i,"loan_id");o!==void 0&&(a.loan_id=o);const d=await this.privatePostMarginFlat(this.extend(a,i)),c=this.parseMarginLoan(d,r);return this.extend(c,{amount:t,symbol:s})}parseMarginLoan(e,t=void 0){return{id:this.safeInteger(e,"loan_id"),currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){e=this.implodeParams(e,i);let a=this.urls.api[t]+"/"+this.version+"/"+e,o=this.omit(i,this.extractParams(e));const d=this.nonce().toString();if(t==="perpetualPrivate"||a==="https://api.coinex.com/perpetual/v1/market/user_deals"){this.checkRequiredCredentials(),o=this.extend({access_id:this.apiKey,timestamp:d},o),o=this.keysort(o);const c=this.rawencode(o);n={Authorization:this.hash(this.encode(c+"&secret_key="+this.secret),"sha256").toLowerCase(),AccessId:this.apiKey},s==="GET"||s==="PUT"?a+="?"+c:(n["Content-Type"]="application/x-www-form-urlencoded",r=c)}else if(t==="public"||t==="perpetualPublic")Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials(),o=this.extend({access_id:this.apiKey,tonce:d},o),o=this.keysort(o);const c=this.rawencode(o);n={Authorization:this.hash(this.encode(c+"&secret_key="+this.secret)).toUpperCase(),"Content-Type":"application/json"},s==="GET"||s==="DELETE"||s==="PUT"?a+="?"+c:r=this.json(o)}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"code"),u=this.safeValue(a,"data"),h=this.safeString(a,"message");if(c!=="0"||h!=="Success"&&h!=="Succeeded"&&h!=="Ok"&&!u){const l={23:iR,24:p0,25:p0,34:p0,35:nR,36:rR,213:eR,107:tR,600:sR,601:Ro,602:Ro,606:Ro},p=this.safeValue(l,c,h0);throw new p(a.message)}}};const oR=ge,{ExchangeError:dR,AuthenticationError:cR,RateLimitExceeded:uR,ArgumentsRequired:fR}=de,{TICK_SIZE:hR}=me,VS=Se;var lR=class extends oR{describe(){return this.deepExtend(super.describe(),{id:"coinfalcon",name:"CoinFalcon",countries:["GB"],rateLimit:1e3,version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradinFee:!1,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/41822275-ed982188-77f5-11e8-92bb-496bcd14ca52.jpg",api:{rest:"https://coinfalcon.com"},www:"https://coinfalcon.com",doc:"https://docs.coinfalcon.com",fees:"https://coinfalcon.com/fees",referral:"https://coinfalcon.com/?ref=CFJSVGTUPASB"},api:{public:{get:["markets","markets/{market}","markets/{market}/orders","markets/{market}/trades"]},private:{get:["user/accounts","user/orders","user/orders/{id}","user/orders/{id}/trades","user/trades","user/fees","account/withdrawals/{id}","account/withdrawals","account/deposit/{id}","account/deposits","account/deposit_address"],post:["user/orders","account/withdraw"],delete:["user/orders/{id}","account/withdrawals/{id}"]}},fees:{trading:{tierBased:!0,maker:0,taker:.002}},precision:{amount:this.parseNumber("0.00000001"),price:this.parseNumber("0.00000001")},precisionMode:hR})}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],[a,o]=r.name.split("-"),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o);i.push({id:r.name,symbol:d+"/"+c,base:d,quote:c,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"size_precision"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"price_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"minPrice"),max:void 0},price:{min:this.safeNumber(r,"minVolume"),max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}parseTicker(e,t=void 0){const s=this.safeString(e,"name");t=this.safeMarket(s,t,"-");const i=this.milliseconds(),n=this.safeString(e,"last_price");return this.safeTicker({symbol:t.symbol,timestamp:i,datetime:this.iso8601(i),high:void 0,low:void 0,bid:this.safeString(e,"highest_bid"),bidVolume:void 0,ask:this.safeString(e,"lowest_ask"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:this.safeString(e,"change_in_24h"),percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:this.safeString(e,"volume"),info:e},t)}async fetchTicker(e,t={}){return await this.loadMarkets(),(await this.fetchTickers([e],t))[e]}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetMarkets(t),i=this.safeValue(s,"data",[]),n={};for(let r=0;r<i.length;r++){const a=this.parseTicker(i[r]),o=a.symbol;n[o]=a}return this.filterByArray(n,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={market:i.id,level:"3"},r=await this.publicGetMarketsMarketOrders(this.extend(n,s)),a=this.safeValue(r,"data",{});return this.parseOrderBook(a,i.symbol,void 0,"bids","asks","price","size")}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"created_at")),i=this.safeString(e,"price"),n=this.safeString(e,"size"),r=t.symbol,a=this.safeString(e,"id"),o=this.safeString(e,"side"),d=this.safeString(e,"order_id");let c;const u=this.safeString(e,"fee");if(u!==void 0){const h=this.safeString(e,"fee_currency_code");c={cost:u,currency:this.safeCurrencyCode(h)}}return this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:r,id:a,order:d,type:void 0,side:o,takerOrMaker:void 0,price:i,amount:n,cost:void 0,fee:c},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new fR(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={market:n.id};t!==void 0&&(r.start_time=this.iso8601(t)),s!==void 0&&(r.limit=s);const a=await this.privateGetUserTrades(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market:n.id};t!==void 0&&(r.since=this.iso8601(t));const a=await this.publicGetMarketsMarketTrades(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetUserFees(e),s=this.safeValue(t,"data",{}),i=this.safeString(s,"maker_fee"),n=this.safeString(s,"taker_fee"),r=this.parseNumber(VS.stringDiv(i,"100")),a=this.parseNumber(VS.stringDiv(n,"100")),o={};for(let d=0;d<this.symbols.length;d++){const c=this.symbols[d];o[c]={info:t,symbol:c,maker:r,taker:a,percentage:!0,tierBased:!0}}return o}parseBalance(e){const t={info:e},s=this.safeValue(e,"data",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeString(n,"currency_code"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(n,"available_balance"),o.used=this.safeString(n,"hold_balance"),o.total=this.safeString(n,"balance"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetUserAccounts(e);return this.parseBalance(t)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"tag");return this.checkAddress(s),{currency:this.safeCurrencyCode(void 0,t),address:s,tag:i,network:void 0,info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.safeCurrency(e),i={currency:this.safeStringLower(s,"id")},n=await this.privateGetAccountDepositAddress(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseDepositAddress(r,s)}parseOrderStatus(e){const t={fulfilled:"closed",canceled:"canceled",pending:"open",open:"open",partially_filled:"open"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeSymbol(s,t,"-"),n=this.parse8601(this.safeString(e,"created_at")),r=this.safeString(e,"price"),a=this.safeString(e,"size"),o=this.safeString(e,"size_filled"),d=this.parseOrderStatus(this.safeString(e,"status"));let c=this.safeString(e,"operation_type");c!==void 0&&(c=c.split("_"),c=c[0]);const u=this.safeString(e,"order_type"),h=this.safeValue(e,"post_only");return this.safeOrder({id:this.safeString(e,"id"),clientOrderId:void 0,datetime:this.iso8601(n),timestamp:n,status:d,symbol:i,type:c,timeInForce:void 0,postOnly:h,side:u,price:r,stopPrice:void 0,cost:void 0,amount:a,filled:o,remaining:void 0,trades:void 0,fee:void 0,info:e,lastTradeTimestamp:void 0,average:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={market:a.id,size:this.amountToPrecision(e,i),order_type:s};t==="limit"&&(n=this.priceToPrecision(e,n),o.price=n.toString()),o.operation_type=t+"_order";const d=await this.privatePostUserOrders(this.extend(o,r)),c=this.safeValue(d,"data",{});return this.parseOrder(c,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateDeleteUserOrdersId(this.extend(i,s)),r=this.market(t),a=this.safeValue(n,"data",{});return this.parseOrder(a,r)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetUserOrdersId(this.extend(i,s)),r=this.safeValue(n,"data",{});return this.parseOrder(r)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.market=r.id),t!==void 0&&(n.since_time=this.iso8601(t));const a=await this.privateGetUserOrders(this.extend(n,i)),o=this.safeValue(a,"data",[]),d=this.filterByArray(o,"status",["pending","open","partially_filled"],!1);return this.parseOrders(d,r,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=this.safeStringLower(r,"id")),t!==void 0&&(n.since_time=this.iso8601(t));const a=await this.privateGetAccountDeposits(this.extend(n,i)),o=this.safeValue(a,"data",[]);return o.reverse(),this.parseTransactions(o,r,void 0,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=this.safeStringLower(r,"id")),t!==void 0&&(n.since_time=this.iso8601(t));const a=await this.privateGetAccountWithdrawals(this.extend(n,i)),o=this.safeValue(a,"data",[]);return o.reverse(),this.parseTransactions(o,r,void 0,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency:this.safeStringLower(r,"id"),address:s,amount:t};i!==void 0&&(a.tag=i);const o=await this.privatePostAccountWithdraw(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseTransaction(d,r)}parseTransactionStatus(e){const t={completed:"ok",denied:"failed",approval_pending:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"address"),n=this.safeString(e,"tag"),r=this.safeString(e,"txid"),a=this.safeString(e,"currency_code"),o=this.safeCurrencyCode(a,t);let d=this.safeString(e,"type");d==="withdraw"&&(d="withdrawal");const c=this.parseTransactionStatus(this.safeString(e,"status")),u=this.safeString(e,"amount"),h=this.parseNumber(u),l=this.safeString(e,"fee");let p=0;return l!==void 0&&(p=this.parseNumber(l)),{info:e,id:s,txid:r,timestamp:void 0,datetime:void 0,network:void 0,address:i,addressTo:void 0,addressFrom:void 0,tag:n,tagTo:void 0,tagFrom:void 0,type:d,amount:h,currency:o,status:c,updated:void 0,fee:{currency:o,cost:p}}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/api/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials(),s==="GET"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):r=this.json(o);const c=this.seconds().toString();let u=[c,s,a].join("|");r&&(u+="|"+r);const h=this.hmac(this.encode(u),this.encode(this.secret));n={"CF-API-KEY":this.apiKey,"CF-API-TIMESTAMP":c,"CF-API-SIGNATURE":h,"Content-Type":"application/json"}}return{url:this.urls.api.rest+a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(e<400)return;const c=this.safeValue({401:cR,429:uR},e,dR);throw new c(r)}};const pR=ge,{ExchangeError:Pf,ArgumentsRequired:mR,InvalidOrder:m0,OrderNotFound:gR,RateLimitExceeded:yR,InsufficientFunds:bR,AuthenticationError:wR}=de,{TICK_SIZE:kR}=me,qS=Se;var SR=class extends pR{describe(){return this.deepExtend(super.describe(),{id:"coinmate",name:"CoinMate",countries:["GB","CZ","EU"],rateLimit:1e3,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactions:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/51840849/87460806-1c9f3f00-c616-11ea-8c46-a77018a8f3f4.jpg",api:{rest:"https://coinmate.io/api"},www:"https://coinmate.io",fees:"https://coinmate.io/fees",doc:["https://coinmate.docs.apiary.io","https://coinmate.io/developers"],referral:"https://coinmate.io?referral=YTFkM1RsOWFObVpmY1ZjMGREQmpTRnBsWjJJNVp3PT0"},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},api:{public:{get:["orderBook","ticker","transactions","tradingPairs"]},private:{post:["balances","bitcoinCashWithdrawal","bitcoinCashDepositAddresses","bitcoinDepositAddresses","bitcoinWithdrawal","bitcoinWithdrawalFees","buyInstant","buyLimit","cancelOrder","cancelOrderWithInfo","createVoucher","dashDepositAddresses","dashWithdrawal","ethereumWithdrawal","ethereumDepositAddresses","litecoinWithdrawal","litecoinDepositAddresses","openOrders","order","orderHistory","orderById","pusherAuth","redeemVoucher","replaceByBuyLimit","replaceByBuyInstant","replaceBySellLimit","replaceBySellInstant","rippleDepositAddresses","rippleWithdrawal","sellInstant","sellLimit","transactionHistory","traderFees","tradeHistory","transfer","transferHistory","unconfirmedBitcoinDeposits","unconfirmedBitcoinCashDeposits","unconfirmedDashDeposits","unconfirmedEthereumDeposits","unconfirmedLitecoinDeposits","unconfirmedRippleDeposits"]}},fees:{trading:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.0012"),taker:this.parseNumber("0.0025"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.0035")],[this.parseNumber("10000"),this.parseNumber("0.0023")],[this.parseNumber("100000"),this.parseNumber("0.0021")],[this.parseNumber("250000"),this.parseNumber("0.0020")],[this.parseNumber("500000"),this.parseNumber("0.0015")],[this.parseNumber("1000000"),this.parseNumber("0.0013")],[this.parseNumber("3000000"),this.parseNumber("0.0010")],[this.parseNumber("15000000"),this.parseNumber("0.0005")]],maker:[[this.parseNumber("0"),this.parseNumber("0.003")],[this.parseNumber("10000"),this.parseNumber("0.0011")],[this.parseNumber("100000"),this.parseNumber("0.0010")],[this.parseNumber("250000"),this.parseNumber("0.0008")],[this.parseNumber("500000"),this.parseNumber("0.0005")],[this.parseNumber("1000000"),this.parseNumber("0.0003")],[this.parseNumber("3000000"),this.parseNumber("0.0002")],[this.parseNumber("15000000"),this.parseNumber("0")]]}}},options:{withdraw:{fillResponsefromRequest:!0,methods:{BTC:"privatePostBitcoinWithdrawal",LTC:"privatePostLitecoinWithdrawal",BCH:"privatePostBitcoinCashWithdrawal",ETH:"privatePostEthereumWithdrawal",XRP:"privatePostRippleWithdrawal",DASH:"privatePostDashWithdrawal",DAI:"privatePostDaiWithdrawal"}}},exceptions:{exact:{"No order with given ID":gR},broad:{"Not enough account balance available":bR,"Incorrect order ID":m0,"Minimum Order Size ":m0,"max allowed precision":m0,"TOO MANY REQUESTS":yR,"Access denied.":wR}},precisionMode:kR})}async fetchMarkets(e={}){const t=await this.publicGetTradingPairs(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"name"),o=this.safeString(r,"firstCurrency"),d=this.safeString(r,"secondCurrency"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d),h=c+"/"+u;i.push({id:a,symbol:h,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"lotDecimals"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"priceDecimals")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"minAmount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}parseBalance(e){const t=this.safeValue(e,"data",{}),s={info:e},i=Object.keys(t);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeCurrencyCode(r),o=this.safeValue(t,r),d=this.account();d.free=this.safeString(o,"available"),d.used=this.safeString(o,"reserved"),d.total=this.safeString(o,"balance"),s[a]=d}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalances(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={currencyPair:i.id,groupByPriceLimit:"False"},a=(await this.publicGetOrderBook(this.extend(n,s))).data,o=this.safeTimestamp(a,"timestamp");return this.parseOrderBook(a,i.symbol,o,"bids","asks","price","amount")}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={currencyPair:s.id},n=await this.publicGetTicker(this.extend(i,t)),r=this.safeValue(n,"data"),a=this.safeTimestamp(r,"timestamp"),o=this.safeNumber(r,"last");return{symbol:s.symbol,timestamp:a,datetime:this.iso8601(a),high:this.safeNumber(r,"high"),low:this.safeNumber(r,"low"),bid:this.safeNumber(r,"bid"),bidVolume:void 0,ask:this.safeNumber(r,"ask"),vwap:void 0,askVolume:void 0,open:void 0,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeNumber(r,"amount"),quoteVolume:void 0,info:r}}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={limit:1e3};if(s!==void 0&&(n.limit=s),t!==void 0&&(n.timestampFrom=t),e!==void 0){const o=this.currency(e);n.currency=o.id}const a=(await this.privatePostTransferHistory(this.extend(n,i))).data;return this.parseTransactions(a,void 0,t,s)}parseTransactionStatus(e){const t={COMPLETED:"ok",WAITING:"pending",SENT:"pending",CREATED:"pending",OK:"ok",NEW:"pending",CANCELED:"canceled"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeNumber(e,"amount"),n=this.safeNumber(e,"fee"),r=this.safeString(e,"txid"),a=this.safeString(e,"destination"),o=this.safeString(e,"destinationTag"),d=this.safeString(e,"amountCurrency"),c=this.safeCurrencyCode(d,t),u=this.safeStringLower(e,"transferType"),h=this.parseTransactionStatus(this.safeString(e,"transferStatus")),l=this.safeString2(e,"transactionId","id"),p=this.safeString(e,"walletType");return{id:l,timestamp:s,datetime:this.iso8601(s),currency:c,amount:i,type:u,txid:r,network:p,address:a,addressTo:void 0,addressFrom:void 0,tag:o,tagTo:void 0,tagFrom:void 0,status:h,fee:{cost:n,currency:c},info:e}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"withdraw",{}),o=this.safeValue(a,"methods",{}),d=this.safeString(o,e);if(d===void 0){const m=Object.keys(o);throw new Pf(this.id+" withdraw() only allows withdrawing the following currencies: "+m.join(", "))}const c={amount:this.currencyToPrecision(e,t),address:s};i!==void 0&&(c.destinationTag=i);const u=await this[d](this.extend(c,n)),h=this.safeValue(u,"data"),l=this.parseTransaction(h,r);return this.safeValue(a,"fillResponseFromRequest",!0)&&(l.amount=t,l.currency=e,l.address=s,l.tag=i,l.type="withdrawal",l.status="pending"),l}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),s===void 0&&(s=1e3);const n={limit:s};if(e!==void 0){const o=this.market(e);n.currencyPair=o.id}t!==void 0&&(n.timestampFrom=t);const r=await this.privatePostTradeHistory(this.extend(n,i)),a=this.safeValue(r,"data",[]);return this.parseTrades(a,void 0,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"currencyPair");t=this.safeMarket(s,t,"_");const i=this.safeString(e,"price"),n=this.safeString(e,"amount"),r=this.safeStringLower2(e,"type","tradeType"),a=this.safeStringLower(e,"orderType"),o=this.safeString(e,"orderId"),d=this.safeString(e,"transactionId"),c=this.safeInteger2(e,"timestamp","createdTimestamp");let u;const h=this.safeString(e,"fee");h!==void 0&&(u={cost:h,currency:t.quote});let l=this.safeString(e,"feeType");return l=l==="MAKER"?"maker":"taker",this.safeTrade({id:d,info:e,timestamp:c,datetime:this.iso8601(c),symbol:t.symbol,type:a,side:r,order:o,takerOrMaker:l,price:i,amount:n,cost:void 0,fee:u},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={currencyPair:n.id,minutesIntoHistory:10},a=await this.publicGetTransactions(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={currencyPair:s.id},n=await this.privatePostTraderFees(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeString(r,"maker"),o=this.safeString(r,"taker"),d=this.parseNumber(qS.stringDiv(a,"100")),c=this.parseNumber(qS.stringDiv(o,"100"));return{info:r,symbol:s.symbol,maker:d,taker:c,percentage:!0,tierBased:!0}}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n=await this.privatePostOpenOrders(this.extend({},i)),r={status:"open"};return this.parseOrders(n.data,void 0,t,s,r)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new mR(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={currencyPair:n.id};s!==void 0&&(r.limit=s);const a=await this.privatePostOrderHistory(this.extend(r,i));return this.parseOrders(a.data,n,t,s)}parseOrderStatus(e){const t={FILLED:"closed",CANCELLED:"canceled",PARTIALLY_FILLED:"open",OPEN:"open"};return this.safeString(t,e,e)}parseOrderType(e){const t={LIMIT:"limit",MARKET:"market"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeInteger(e,"timestamp"),n=this.safeStringLower(e,"type"),r=this.safeString(e,"price"),a=this.safeString(e,"originalAmount"),o=this.safeString2(e,"remainingAmount","amount"),d=this.parseOrderStatus(this.safeString(e,"status")),c=this.parseOrderType(this.safeString(e,"orderTradeType")),u=this.safeString(e,"avgPrice"),h=this.safeString(e,"currencyPair"),l=this.safeSymbol(h,t,"_"),p=this.safeString(e,"clientOrderId"),m=this.safeNumber(e,"stopPrice");return this.safeOrder({id:s,clientOrderId:p,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,symbol:l,type:c,timeInForce:void 0,postOnly:void 0,side:n,price:r,stopPrice:m,amount:a,cost:void 0,average:u,filled:void 0,remaining:o,status:d,trades:void 0,info:e,fee:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();let a="privatePost"+this.capitalize(s);const d={currencyPair:this.market(e).id};t==="market"?(s==="buy"?d.total=this.amountToPrecision(e,i):d.amount=this.amountToPrecision(e,i),a+="Instant"):(d.amount=this.amountToPrecision(e,i),d.price=this.priceToPrecision(e,n),a+=this.capitalize(t));const c=await this[a](this.extend(d,r)),u=this.safeString(c,"data");return{info:c,id:u}}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e};let n;t&&(n=this.market(t));const r=await this.privatePostOrderById(this.extend(i,s)),a=this.safeValue(r,"data");return this.parseOrder(a,n)}async cancelOrder(e,t=void 0,s={}){const i={orderId:e};return{info:await this.privatePostCancelOrderWithInfo(this.extend(i,s))}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+e;if(t==="public")Object.keys(i).length&&(a+="?"+this.urlencode(i));else{this.checkRequiredCredentials();const o=this.nonce().toString(),d=o+this.uid+this.apiKey,c=this.hmac(this.encode(d),this.encode(this.secret));r=this.urlencode(this.extend({clientId:this.uid,nonce:o,publicKey:this.apiKey,signature:c.toUpperCase()},i)),n={"Content-Type":"application/x-www-form-urlencoded"}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&"error"in a&&a.error){const c=this.safeString(a,"errorMessage"),u=this.id+" "+c;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u),new Pf(this.id+" "+this.json(a))}if(e>400){if(r){const c=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,r,c),this.throwBroadlyMatchedException(this.exceptions.broad,r,c),new Pf(c)}throw new Pf(this.id+" "+r)}}};const vR=ge,{BadSymbol:TR,BadRequest:OR,ExchangeError:Af,ArgumentsRequired:Bf,OrderNotFound:IR,OnMaintenance:xR}=de,{TICK_SIZE:_R}=me,g0=Se;var CR=class extends vR{describe(){return this.deepExtend(super.describe(),{id:"coinone",name:"CoinOne",countries:["KR"],rateLimit:667,version:"v2",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:void 0,fetchDepositAddresses:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/38003300-adc12fba-323f-11e8-8525-725f53c4a659.jpg",api:{rest:"https://api.coinone.co.kr"},www:"https://coinone.co.kr",doc:"https://doc.coinone.co.kr"},requiredCredentials:{apiKey:!0,secret:!0},api:{public:{get:["orderbook/","trades/","ticker/"]},private:{post:["account/deposit_address/","account/btc_deposit_address/","account/balance/","account/daily_balance/","account/user_info/","account/virtual_account/","order/cancel_all/","order/cancel/","order/limit_buy/","order/limit_sell/","order/complete_orders/","order/limit_orders/","order/order_info/","transaction/auth_number/","transaction/history/","transaction/krw/history/","transaction/btc/","transaction/coin/"]}},fees:{trading:{tierBased:!1,percentage:!0,taker:.002,maker:.002}},precision:{price:this.parseNumber("0.0001"),amount:this.parseNumber("0.0001"),cost:this.parseNumber("0.00000001")},precisionMode:_R,exceptions:{405:xR,104:IR,108:TR,107:OR},commonCurrencies:{SOC:"Soda Coin"}})}async fetchMarkets(e={}){const t={currency:"all"},s=await this.publicGetTicker(t),i=[],n="krw",r=this.safeCurrencyCode(n),a=Object.keys(s);for(let o=0;o<a.length;o++){const d=a[o],c=this.safeValue(s,d,{});if(this.safeValue(c,"currency")===void 0)continue;const h=this.safeCurrencyCode(d);i.push({id:d,symbol:h+"/"+r,base:h,quote:r,settle:void 0,baseId:d,quoteId:n,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:void 0,price:void 0},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:c})}return i}parseBalance(e){const t={info:e},s=this.omit(e,["errorCode","result","normalWallets"]),i=Object.keys(s);for(let n=0;n<i.length;n++){const r=i[n],a=s[r],o=this.safeCurrencyCode(r),d=this.account();d.free=this.safeString(a,"avail"),d.total=this.safeString(a,"balance"),t[o]=d}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostAccountBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={currency:i.id,format:"json"},r=await this.publicGetOrderbook(this.extend(n,s)),a=this.safeTimestamp(r,"timestamp");return this.parseOrderBook(r,i.symbol,a,"bid","ask","price","qty")}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={currency:"all",format:"json"},i=await this.publicGetTicker(this.extend(s,t)),n={},r=Object.keys(i),a=this.safeTimestamp(i,"timestamp");for(let o=0;o<r.length;o++){const d=r[o],c=this.safeMarket(d),u=c.symbol,h=i[d];n[u]=this.parseTicker(h,c),n[u].timestamp=a}return this.filterByArray(n,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={currency:s.id,format:"json"},n=await this.publicGetTicker(this.extend(i,t));return this.parseTicker(n,s)}parseTicker(e,t=void 0){const s=this.safeTimestamp(e,"timestamp"),i=this.safeString(e,"first"),n=this.safeString(e,"last"),r=this.safeString(e,"yesterday_last"),a=this.safeSymbol(void 0,t);return this.safeTicker({symbol:a,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:i,close:n,last:n,previousClose:r,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:void 0,info:e},t)}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"timestamp");t=this.safeMarket(void 0,t);const i=this.safeString(e,"is_ask");let n=this.safeString(e,"type");i!==void 0?i==="1"?n="sell":i==="0"&&(n="buy"):n==="ask"?n="sell":n==="bid"&&(n="buy");const r=this.safeString(e,"price"),a=this.safeString(e,"qty"),o=this.safeString(e,"orderId");let d=this.safeString(e,"fee"),c;if(d!==void 0){d=g0.stringAbs(d);let u=this.safeString(e,"feeRate");u=g0.stringAbs(u);const h=n==="sell"?t.quote:t.base;c={cost:d,currency:h,rate:u}}return this.safeTrade({id:this.safeString(e,"id"),info:e,timestamp:s,datetime:this.iso8601(s),order:o,symbol:t.symbol,type:void 0,side:n,takerOrMaker:void 0,price:r,amount:a,cost:void 0,fee:c},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={currency:n.id,format:"json"},a=await this.publicGetTrades(this.extend(r,i)),o=this.safeValue(a,"completeOrders",[]);return this.parseTrades(o,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){if(t!=="limit")throw new Af(this.id+" createOrder() allows limit orders only");await this.loadMarkets();const a=this.market(e),o={price:n,currency:a.id,qty:i},d="privatePostOrder"+this.capitalize(t)+this.capitalize(s),c=await this[d](this.extend(o,r));return this.parseOrder(c,a)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Bf(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={order_id:e,currency:i.id},r=await this.privatePostOrderOrderInfo(this.extend(n,s)),a=this.safeValue(r,"info",{});return a.status=this.safeString(a,"status"),this.parseOrder(a,i)}parseOrderStatus(e){const t={live:"open",partially_filled:"open",filled:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"orderId"),i=this.safeString(e,"price"),n=this.safeTimestamp(e,"timestamp");let r=this.safeString(e,"type");r==="ask"?r="sell":r==="bid"&&(r="buy");const a=this.safeString(e,"remainQty"),o=this.safeString(e,"qty");let d=this.safeString(e,"status");d==="live"&&a!==void 0&&o!==void 0&&g0.stringLt(a,o)&&(d="canceled"),d=this.parseOrderStatus(d);const c=t.symbol,u=t.base,h=t.quote;let l;const p=this.safeString(e,"fee");if(p!==void 0){const m=r==="sell"?h:u;l={cost:p,rate:this.safeString(e,"feeRate"),currency:m}}return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,symbol:c,type:"limit",timeInForce:void 0,postOnly:void 0,side:r,price:i,stopPrice:void 0,cost:void 0,average:void 0,amount:o,filled:void 0,remaining:a,status:d,fee:l,trades:void 0},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Af(this.id+" fetchOpenOrders() allows fetching closed orders with a specific symbol");await this.loadMarkets();const n=this.market(e),r={currency:n.id},a=await this.privatePostOrderLimitOrders(this.extend(r,i)),o=this.safeValue(a,"limitOrders",[]);return this.parseOrders(o,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Bf(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={currency:n.id},a=await this.privatePostOrderCompleteOrders(this.extend(r,i)),o=this.safeValue(a,"completeOrders",[]);return this.parseTrades(o,n,t,s)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Bf(this.id+" cancelOrder() requires a symbol argument. To cancel the order, pass a symbol argument and {'price': 12345, 'qty': 1.2345, 'is_ask': 0} in the params argument of cancelOrder.");const i=this.safeNumber(s,"price"),n=this.safeNumber(s,"qty"),r=this.safeInteger(s,"is_ask");if(i===void 0||n===void 0||r===void 0)throw new Bf(this.id+" cancelOrder() requires {'price': 12345, 'qty': 1.2345, 'is_ask': 0} in the params argument.");await this.loadMarkets();const a={order_id:e,price:i,qty:n,is_ask:r,currency:this.marketId(t)};return await this.privatePostOrderCancel(this.extend(a,s))}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s=await this.privatePostAccountDepositAddress(t),i=this.safeValue(s,"walletAddress",{}),n=Object.keys(i),r={};for(let a=0;a<n.length;a++){const o=n[a],d=i[o];if(!d||d==="-1")continue;const c=o.split("_"),u=this.safeValue(c,0),h=this.safeValue(c,1),l=this.safeCurrencyCode(u);let p=this.safeValue(r,l);p===void 0&&(p={currency:l,address:void 0,tag:void 0,info:d});const m=this.safeString(p,"address",d);this.checkAddress(m),p.address=m,p.info=m,(h==="tag"||h==="memo")&&(p.tag=d,p.info=[m,d]),r[l]=p}return r}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.implodeParams(e,i),o=this.omit(i,this.extractParams(e));let d=this.urls.api.rest+"/";if(t==="public")d+=a,Object.keys(o).length&&(d+="?"+this.urlencode(o));else{this.checkRequiredCredentials(),d+=this.version+"/"+a;const c=this.nonce().toString(),u=this.json(this.extend({access_token:this.apiKey,nonce:c},i)),h=this.stringToBase64(u);r=this.decode(h);const l=this.secret.toUpperCase(),p=this.hmac(h,this.encode(l),"sha512");n={"Content-Type":"application/json","X-COINONE-PAYLOAD":h,"X-COINONE-SIGNATURE":p}}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0)if("result"in a){if(a.result!=="success"){const u=this.safeString(a,"errorCode"),h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions,u,h),new Af(h)}}else throw new Af(this.id+" "+r)}};const MR=ge,{ExchangeError:PR,ArgumentsRequired:AR}=de,{TICK_SIZE:BR}=me;var ER=class extends MR{describe(){return this.deepExtend(super.describe(),{id:"coinspot",name:"CoinSpot",countries:["AU"],rateLimit:1e3,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchOpenInterestHistory:!1,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/28208429-3cacdf9a-6896-11e7-854e-4c79a772a30f.jpg",api:{public:"https://www.coinspot.com.au/pubapi",private:"https://www.coinspot.com.au/api"},www:"https://www.coinspot.com.au",doc:"https://www.coinspot.com.au/api",referral:"https://www.coinspot.com.au/register?code=PJURCU"},api:{public:{get:["latest"]},private:{post:["orders","orders/history","my/coin/deposit","my/coin/send","quote/buy","quote/sell","my/balances","my/orders","my/buy","my/sell","my/buy/cancel","my/sell/cancel","ro/my/balances","ro/my/balances/{cointype}","ro/my/deposits","ro/my/withdrawals","ro/my/transactions","ro/my/transactions/{cointype}","ro/my/transactions/open","ro/my/transactions/{cointype}/open","ro/my/sendreceive","ro/my/affiliatepayments","ro/my/referralpayments"]}},markets:{"ADA/AUD":{id:"ada",symbol:"ADA/AUD",base:"ADA",quote:"AUD",baseId:"ada",quoteId:"aud",type:"spot",spot:!0},"BTC/AUD":{id:"btc",symbol:"BTC/AUD",base:"BTC",quote:"AUD",baseId:"btc",quoteId:"aud",type:"spot",spot:!0},"BTC/USDT":{id:"btc",symbol:"BTC/USDT",base:"BTC",quote:"USDT",baseId:"btc",quoteId:"usdt",type:"spot",spot:!0},"ETH/AUD":{id:"eth",symbol:"ETH/AUD",base:"ETH",quote:"AUD",baseId:"eth",quoteId:"aud",type:"spot",spot:!0},"XRP/AUD":{id:"xrp",symbol:"XRP/AUD",base:"XRP",quote:"AUD",baseId:"xrp",quoteId:"aud",type:"spot",spot:!0},"LTC/AUD":{id:"ltc",symbol:"LTC/AUD",base:"LTC",quote:"AUD",baseId:"ltc",quoteId:"aud",type:"spot",spot:!0},"DOGE/AUD":{id:"doge",symbol:"DOGE/AUD",base:"DOGE",quote:"AUD",baseId:"doge",quoteId:"aud",type:"spot",spot:!0},"RFOX/AUD":{id:"rfox",symbol:"RFOX/AUD",base:"RFOX",quote:"AUD",baseId:"rfox",quoteId:"aud",type:"spot",spot:!0},"POWR/AUD":{id:"powr",symbol:"POWR/AUD",base:"POWR",quote:"AUD",baseId:"powr",quoteId:"aud",type:"spot",spot:!0},"NEO/AUD":{id:"neo",symbol:"NEO/AUD",base:"NEO",quote:"AUD",baseId:"neo",quoteId:"aud",type:"spot",spot:!0},"TRX/AUD":{id:"trx",symbol:"TRX/AUD",base:"TRX",quote:"AUD",baseId:"trx",quoteId:"aud",type:"spot",spot:!0},"EOS/AUD":{id:"eos",symbol:"EOS/AUD",base:"EOS",quote:"AUD",baseId:"eos",quoteId:"aud",type:"spot",spot:!0},"XLM/AUD":{id:"xlm",symbol:"XLM/AUD",base:"XLM",quote:"AUD",baseId:"xlm",quoteId:"aud",type:"spot",spot:!0},"RHOC/AUD":{id:"rhoc",symbol:"RHOC/AUD",base:"RHOC",quote:"AUD",baseId:"rhoc",quoteId:"aud",type:"spot",spot:!0},"GAS/AUD":{id:"gas",symbol:"GAS/AUD",base:"GAS",quote:"AUD",baseId:"gas",quoteId:"aud",type:"spot",spot:!0}},commonCurrencies:{DRK:"DASH"},options:{fetchBalance:"private_post_my_balances"},precisionMode:BR})}parseBalance(e){const t={info:e},s=this.safeValue2(e,"balance","balances");if(Array.isArray(s))for(let i=0;i<s.length;i++){const n=s[i],r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=n[o],c=this.safeCurrencyCode(o),u=this.account();u.total=this.safeString(d,"balance"),t[c]=u}}else{const i=Object.keys(s);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(s,r),t[a]=o}}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(this.options,"fetchBalance","private_post_my_balances"),s=await this[t](e);return this.parseBalance(s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={cointype:i.id},r=await this.privatePostOrders(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"buyorders","sellorders","rate","amount")}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:void 0,datetime:void 0,high:void 0,low:void 0,bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:i,last:i,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=await this.publicGetLatest(t);let n=s.id;n=n.toLowerCase();const r=this.safeValue(i,"prices"),a=this.safeValue(r,n);return this.parseTicker(a,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetLatest(t),i={},n=this.safeValue(s,"prices"),r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeMarket(o);if(d.spot){const c=d.symbol,u=n[o];i[c]=this.parseTicker(u,d)}}return this.filterByArray(i,"symbol",e)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={cointype:n.id},a=await this.privatePostOrdersHistory(this.extend(r,i)),o=this.safeValue(a,"orders",[]);return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"rate"),i=this.safeString(e,"amount"),n=this.safeNumber(e,"total"),r=this.safeInteger(e,"solddate"),a=this.safeString(e,"market"),o=this.safeSymbol(a,t,"/");return this.safeTrade({info:e,id:void 0,symbol:o,timestamp:r,datetime:this.iso8601(r),order:void 0,type:void 0,side:void 0,takerOrMaker:void 0,price:s,amount:i,cost:n,fee:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a="privatePostMy"+this.capitalize(s);if(t==="market")throw new PR(this.id+" createOrder() allows limit orders only");const d={cointype:this.market(e).id,amount:i,rate:n};return await this[a](this.extend(d,r))}async cancelOrder(e,t=void 0,s={}){const i=this.safeString(s,"side");if(i!=="buy"&&i!=="sell")throw new AR(this.id+' cancelOrder() requires a side parameter, "buy" or "sell"');s=this.omit(s,"side");const n="privatePostMy"+this.capitalize(i)+"Cancel",r={id:e};return await this[n](this.extend(r,s))}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.urls.api[t]+"/"+e;if(t==="private"){this.checkRequiredCredentials();const o=this.nonce();r=this.json(this.extend({nonce:o},i)),n={"Content-Type":"application/json",key:this.apiKey,sign:this.hmac(this.encode(r),this.encode(this.secret),"sha512")}}return{url:a,method:s,body:r,headers:n}}};const NR=ge,{ExchangeError:y0,BadRequest:Sc,InvalidNonce:VR,RequestTimeout:qR,ExchangeNotAvailable:LS,InsufficientFunds:LR,OrderNotFound:RR,InvalidOrder:b0,DDoSProtection:FR,AuthenticationError:Ef,BadSymbol:w0,AccountSuspended:RS,ArgumentsRequired:DR}=de,{TICK_SIZE:HR}=me;var GR=class extends NR{describe(){return this.deepExtend(super.describe(),{id:"crex24",name:"CREX24",countries:["EE"],rateLimit:500,version:"v2",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!0,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFees:!0,fetchTransactions:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","1d":"1d","1w":"1w","1M":"1mo"},urls:{logo:"https://user-images.githubusercontent.com/1294454/47813922-6f12cc00-dd5d-11e8-97c6-70f957712d47.jpg",api:{rest:"https://api.crex24.com"},www:"https://crex24.com",referral:"https://crex24.com/?refid=slxsjsjtil8xexl9hksr",doc:"https://docs.crex24.com/trade-api/v2",fees:"https://crex24.com/fees"},api:{public:{get:["currencies","instruments","tickers","recentTrades","orderBook","ohlcv","tradingFeeSchedules","withdrawalFees","currencyTransport","currenciesWithdrawalFees"]},trading:{get:["orderStatus","orderTrades","activeOrders","orderHistory","tradeHistory","tradingFee","tradeFee"],post:["placeOrder","modifyOrder","cancelOrdersById","cancelOrdersByInstrument","cancelAllOrders"]},account:{get:["balance","depositAddress","moneyTransfers","moneyTransferStatus","previewWithdrawal"],post:["withdraw"]}},precisionMode:HR,fees:{trading:{tierBased:!0,percentage:!0,taker:.001,maker:-1e-4},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}},commonCurrencies:{ACM:"Actinium",BCC:"BCH",BIT:"BitMoney",BULL:"BuySell",CLC:"CaluraCoin",CREDIT:"TerraCredit",DMS:"Documentchain",EGG:"NestEGG Coin",EPS:"Epanus",FUND:"FUNDChains",GHOST:"GHOSTPRISM",GM:"GM Holding",GMT:"GMT Token",GTC:"GastroCoin",IQ:"IQ.Cash",ONE:"One Hundred Coin",PUT:"PutinCoin",SBTC:"SBTCT",SPH:"SapphireCoin",SUPER:"SuperCoin",UNI:"Universe",YOYO:"YOYOW"},options:{networks:{ETH:"ERC20",TRX:"TRC20",BSC:"BEP20"},fetchOrdersMethod:"tradingGetOrderHistory",fetchClosedOrdersMethod:"tradingGetOrderHistory",fetchTickersMethod:"publicGetTicker24hr",defaultTimeInForce:"GTC",hasAlreadyAuthenticatedSuccessfully:!1,warnOnFetchOpenOrdersWithoutSymbol:!0,parseOrderToPrecision:!1,newOrderRespType:"RESULT",fetchTradingFees:{method:"fetchPrivateTradingFees"}},exceptions:{exact:{"Parameter 'filter' contains invalid value.":Sc,"Mandatory parameter 'instrument' is missing.":Sc,"The value of parameter 'till' must be greater than or equal to the value of parameter 'from'.":Sc,"Failed to verify request signature.":Ef,"Nonce error. Make sure that the value passed in the 'X-CREX24-API-NONCE' header is greater in each consecutive request than in the previous one for the corresponding API-Key provided in 'X-CREX24-API-KEY' header.":VR,"Market orders are not supported by the instrument currently.":b0,"Parameter 'instrument' contains invalid value.":w0,"Trading has been disabled for the account until the verification is passed. To initiate the verification process, please log into your account at crex24.com and proceed to 'My account' -> 'Verification'.":RS},broad:{"try again later":LS,"API Key":Ef,"Insufficient funds":LR,"has been delisted.":w0,"is currently suspended.":w0,"Mandatory parameter":Sc,"can not trade":RS}}})}nonce(){return this.milliseconds()}async fetchMarkets(e={}){const t=await this.publicGetInstruments(e),s=await this.publicGetTradingFeeSchedules(e),i=[];for(let n=0;n<t.length;n++){const r=t[n],a=this.safeString(r,"symbol"),o=this.safeString(r,"baseCurrency"),d=this.safeString(r,"quoteCurrency"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d);let h,l;const p=this.safeString(r,"feeSchedule");for(let g=0;g<s.length;g++)if(this.safeString(s[g],"name")===p){const b=this.safeValue(s[g],"feeRates",[]);for(let w=0;w<b.length;w++)if(this.safeNumber(b[w],"volumeThreshold")===0){h=this.safeNumber(b[w],"maker"),l=this.safeNumber(b[w],"taker");break}break}const m=this.safeString(r,"state");i.push({id:a,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:m==="active",contract:!1,linear:void 0,inverse:void 0,taker:l,maker:h,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(r,"volumeIncrement"),price:this.safeNumber(r,"tickSize")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"minVolume"),max:this.safeNumber(r,"maxVolume")},price:{min:this.safeNumber(r,"minPrice"),max:this.safeNumber(r,"maxPrice")},cost:{min:this.safeNumber(r,"minQuoteVolume"),max:this.safeNumber(r,"maxQuoteVolume")}},info:r})}return i}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"symbol"),a=this.safeCurrencyCode(r),o=this.parseNumber(this.parsePrecision(this.safeString(n,"withdrawalPrecision"))),d=this.safeValue(n,"BaseAddress"),c=this.safeValue(n,"depositsAllowed"),u=this.safeValue(n,"withdrawalsAllowed"),h=this.safeValue(n,"isDelisted"),l=c&&u&&!h,m=this.safeValue(n,"isFiat")?"fiat":"crypto";s[a]={id:r,code:a,address:d,info:n,type:m,name:this.safeString(n,"name"),active:l,deposit:c,withdraw:u,fee:this.safeNumber(n,"flatWithdrawalFee"),precision:o,limits:{amount:{min:o,max:void 0},deposit:{min:this.safeNumber(n,"minDeposit"),max:void 0},withdraw:{min:this.safeNumber(n,"minWithdrawal"),max:this.safeNumber(n,"maxWithdrawal")}}}}return s}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s={};e!==void 0&&(s.filter=e.join(","));const i=await this.publicGetCurrenciesWithdrawalFees(this.extend(s,t));return this.parseTransactionFees(i,e)}parseTransactionFees(e,t=void 0){const s={};for(let i=0;i<e.length;i++){const n=e[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r);t!==void 0&&!this.inArray(a,t)||(s[a]=this.parseTransactionFee(n))}return s}parseTransactionFee(e){const t={withdraw:{},deposit:{},info:e},s=this.safeValue(e,"fees");for(let i=0;i<s.length;i++){const n=s[i],r=this.safeString(n,"feeCurrency"),a=this.safeNumber(n,"amount");t.withdraw[r]=a}return t}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"available"),a.used=this.safeString(i,"reserved"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t={},s=await this.accountGetBalance(this.extend(t,e));return this.parseBalance(s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={instrument:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetOrderBook(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"buyLevels","sellLevels","price","volume")}parseTicker(e,t=void 0){const s=this.parse8601(this.safeString(e,"timestamp")),i=this.safeString(e,"instrument"),n=this.safeSymbol(i,t,"-"),r=this.safeString(e,"last");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:this.safeString(e,"percentChange"),average:void 0,baseVolume:this.safeString(e,"baseVolume"),quoteVolume:this.safeString(e,"quoteVolume"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={instrument:s.id},n=await this.publicGetTickers(this.extend(i,t));if(n.length<1)throw new y0(this.id+" fetchTicker() could not load quotes for symbol "+e);return this.parseTicker(n[0],s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};if(e!==void 0){const n=this.marketIds(e);s.instrument=n.join(",")}const i=await this.publicGetTickers(this.extend(s,t));return this.parseTickers(i,e)}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"timestamp")),i=this.safeString(e,"price"),n=this.safeString(e,"volume"),r=this.safeString(e,"id"),a=this.safeString(e,"side"),o=this.safeString(e,"orderId"),d=this.safeString(e,"instrument"),c=this.safeSymbol(d,t,"-");let u;const h=this.safeString(e,"feeCurrency"),l=this.safeCurrencyCode(h),p=this.safeString(e,"fee");p!==void 0&&(u={cost:p,currency:l});const m=void 0;return this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:c,id:r,order:o,type:void 0,takerOrMaker:m,side:a,price:i,cost:void 0,amount:n,fee:u},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={instrument:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetRecentTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTradingFees(e={}){let t=this.safeString(e,"method");if(e=this.omit(e,"method"),t===void 0){const s=this.safeValue(this.options,"fetchTradingFees",{});t=this.safeString(s,"method","fetchPrivateTradingFees")}return await this[t](e)}async fetchPublicTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetTradingFeeSchedules(e),s=this.indexBy(t,"name"),i=this.safeValue(s,"OriginalSchedule",{}),n=this.safeValue(i,"feeRates",[]),r=this.safeValue(n,0,{}),a=this.safeNumber(r,"maker"),o=this.safeNumber(r,"taker"),d={};for(let c=0;c<this.symbols.length;c++){const u=this.symbols[c];d[u]={info:t,symbol:u,maker:a,taker:o,percentage:!0,tierBased:!0}}return d}async fetchPrivateTradingFees(e={}){await this.loadMarkets();const t=await this.tradingGetTradingFee(e),s=this.safeValue(t,"feeRates",[]),i=this.indexBy(s,"schedule"),n=this.safeValue(i,"OriginalSchedule",{}),r=this.safeNumber(n,"maker"),a=this.safeNumber(n,"taker"),o={};for(let d=0;d<this.symbols.length;d++){const c=this.symbols[d];o[c]={info:t,symbol:c,maker:r,taker:a,percentage:!0,tierBased:!0}}return o}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"timestamp")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={granularity:this.timeframes[t],instrument:r.id};i!==void 0&&(a.limit=i);const o=await this.publicGetOhlcv(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}parseOrderStatus(e){const t={submitting:"open",unfilledActive:"open",partiallyFilledActive:"open",filled:"closed",partiallyFilledCancelled:"canceled",unfilledCancelled:"canceled"};return e in t?t[e]:e}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString(e,"status")),i=this.safeString(e,"instrument"),n=this.safeSymbol(i,t,"-"),r=this.parse8601(this.safeString(e,"timestamp")),a=this.safeString(e,"price"),o=this.safeString(e,"volume"),d=this.safeString(e,"remainingVolume"),c=this.parse8601(this.safeString(e,"lastUpdate")),u=this.safeString(e,"id",e),h=this.safeString(e,"type"),l=this.safeString(e,"side"),p=this.safeString(e,"timeInForce"),m=this.safeNumber(e,"stopPrice");return this.safeOrder({info:e,id:u,clientOrderId:void 0,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:c,symbol:n,type:h,timeInForce:p,side:l,price:a,stopPrice:m,amount:o,cost:void 0,average:void 0,filled:void 0,remaining:d,status:s,fee:void 0,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={instrument:a.id,volume:this.amountToPrecision(e,i),type:t,side:s};let d=!1,c=!1;if(t==="limit"?d=!0:t==="stopLimit"&&(d=!0,c=!0),d){if(n===void 0)throw new b0(this.id+" createOrder() requires a price argument for a "+t+" order");o.price=this.priceToPrecision(e,n)}if(c){const h=this.safeValue2(r,"triggerPrice","stopPrice");if(h===void 0)throw new b0(this.id+" createOrder() requires a stopPrice extra param for a "+t+" order");o.stopPrice=this.priceToPrecision(e,h),r=this.omit(r,["triggerPrice","stopPrice"])}const u=await this.tradingPostPlaceOrder(this.extend(o,r));return this.parseOrder(u,a)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.tradingGetOrderStatus(this.extend(i,s));if(n.length<1)throw new RR(this.id+" fetchOrder() could not fetch order id "+e);return this.parseOrder(n[0])}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};if(t!==void 0&&(n.from=this.ymdhms(t,"T")),s!==void 0&&(n.limit=s),e!==void 0){const o=this.market(e);n.instrument=o.id}const r=this.safeString(this.options,"fetchOrdersMethod","tradingGetOrderHistory"),a=await this[r](this.extend(n,i));return this.parseOrders(a)}async fetchOrdersByIds(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={id:e.join(",")},r=await this.tradingGetOrderStatus(this.extend(n,i));return this.parseOrders(r,void 0,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.instrument=n.id);const a=await this.tradingGetActiveOrders(this.extend(r,i));return this.parseOrders(a,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.instrument=n.id),t!==void 0&&(r.from=this.ymdhms(t,"T")),s!==void 0&&(r.limit=s);const a=this.safeString(this.options,"fetchClosedOrdersMethod","tradingGetOrderHistory"),o=await this[a](this.extend(r,i));return this.parseOrders(o,n,t,s)}async cancelOrder(e,t=void 0,s={}){const i=await this.cancelOrders([e],t,s);return this.safeValue(i,0)}async cancelOrders(e,t=void 0,s={}){if(!Array.isArray(e))throw new DR(this.id+" cancelOrders() ids argument should be an array");await this.loadMarkets();const i={ids:[]};for(let r=0;r<e.length;r++){const a=parseInt(e[r]);i.ids.push(a)}const n=await this.tradingPostCancelOrdersById(this.extend(i,s));return this.parseOrders(n)}async cancelAllOrders(e=void 0,t={}){let s,i;if(e===void 0)s=await this.tradingPostCancelAllOrders(t);else{await this.loadMarkets(),i=this.market(e);const n={instruments:[i.id]};s=await this.tradingPostCancelOrdersByInstrument(this.extend(n,t))}return this.parseOrders(s,i,void 0,void 0,t)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={id:e},a=await this.tradingGetOrderTrades(this.extend(r,n));return this.parseTrades(a,void 0,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.instrument=n.id),t!==void 0&&(r.from=this.ymdhms(t,"T")),s!==void 0&&(r.limit=s);const a=await this.tradingGetTradeHistory(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.currency=n.id),t!==void 0&&(r.from=this.ymdhms(t,"T"));const a=await this.accountGetMoneyTransfers(this.extend(r,i));return this.parseTransactions(a,n,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){const n={type:"deposit"};return this.fetchTransactions(e,t,s,this.extend(n,i))}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const n={type:"withdrawal"};return this.fetchTransactions(e,t,s,this.extend(n,i))}parseTransactionStatus(e){const t={pending:"pending",success:"ok",failed:"failed"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"address"),n=this.safeString(e,"paymentId"),r=this.safeValue(e,"txId"),a=this.safeString(e,"currency"),o=this.safeCurrencyCode(a,t),d=this.safeString(e,"type"),c=this.parse8601(this.safeString(e,"createdAt")),u=this.parse8601(this.safeString(e,"processedAt")),h=this.parseTransactionStatus(this.safeString(e,"status")),l=this.safeNumber(e,"amount"),m={cost:this.safeNumber(e,"fee"),currency:o};return{info:e,id:s,txid:r,timestamp:c,datetime:this.iso8601(c),network:void 0,address:i,addressTo:void 0,addressFrom:void 0,tag:n,tagTo:void 0,tagFrom:void 0,type:d,amount:l,currency:o,status:h,updated:u,fee:m}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.accountGetDepositAddress(this.extend(i,t)),r=this.safeString(n,"address"),a=this.safeString(n,"paymentId");return{currency:e,address:this.checkAddress(r),tag:a,network:void 0,info:n}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,address:s,amount:parseFloat(this.currencyToPrecision(e,t)),feeCurrency:r.id};i!==void 0&&(a.paymentId=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeString(o,d,d),d!==void 0&&(a.transport=d,n=this.omit(n,"network"));const c=await this.accountPostWithdraw(this.extend(a,n));return this.parseTransaction(c)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.version+"/"+t+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));s==="GET"&&Object.keys(o).length&&(a+="?"+this.urlencode(o));const d=this.urls.api.rest+a;if(t==="trading"||t==="account"){this.checkRequiredCredentials();const c=this.nonce().toString(),u=this.base64ToBinary(this.secret);let h=a+c;n={"X-CREX24-API-KEY":this.apiKey,"X-CREX24-API-NONCE":c},s==="POST"&&(n["Content-Type"]="application/json",r=this.json(i),h+=r),n["X-CREX24-API-SIGN"]=this.hmac(this.encode(h),u,"sha512","base64")}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(!this.isJsonEncodedObject(r)||e>=200&&e<300)return;const c=this.safeString(a,"errorDescription"),u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u),e===400?new Sc(u):e===401?new Ef(u):e===403?new Ef(u):e===429?new FR(u):e===500?new y0(u):e===503?new LS(u):e===504?new qR(u):new y0(u)}};const UR=ge,{AuthenticationError:$R,ArgumentsRequired:Nf,ExchangeError:k0,InsufficientFunds:jR,DDoSProtection:WR,InvalidNonce:zR,PermissionDenied:S0,BadRequest:Pt,BadSymbol:KR,NotSupported:FS,AccountNotEnabled:XR,OnMaintenance:YR}=de,{TICK_SIZE:QR}=me,DS=Se;var W_=class extends UR{describe(){return this.deepExtend(super.describe(),{id:"cryptocom",name:"Crypto.com",countries:["MT"],version:"v2",rateLimit:10,pro:!0,has:{CORS:!1,spot:!0,margin:!0,swap:void 0,future:void 0,option:void 0,borrowMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,fetchBalance:!0,fetchBidsAsks:!1,fetchBorrowInterest:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!0,fetchClosedOrders:"emulated",fetchCurrencies:!1,fetchDepositAddress:!0,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRates:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPositionMode:!1,fetchPositions:!1,fetchStatus:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfers:!0,fetchWithdrawals:!0,repayMargin:!0,setLeverage:!1,setMarginMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","6h":"6h","12h":"12h","1d":"1D","1w":"7D","2w":"14D","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/147792121-38ed5e36-c229-48d6-b49a-48d05fc19ed4.jpeg",test:{spot:"https://uat-api.3ona.co/v2",derivatives:"https://uat-api.3ona.co/v2"},api:{spot:"https://api.crypto.com/v2",derivatives:"https://deriv-api.crypto.com/v1"},www:"https://crypto.com/",referral:"https://crypto.com/exch/5835vstech",doc:["https://exchange-docs.crypto.com/spot/index.html","https://exchange-docs.crypto.com/derivatives/index.html"],fees:"https://crypto.com/exchange/document/fees-limits"},api:{spot:{public:{get:{"public/auth":1,"public/get-instruments":1,"public/get-book":1,"public/get-candlestick":1,"public/get-ticker":1,"public/get-trades":1,"public/margin/get-transfer-currencies":1,"public/margin/get-load-currenices":1,"public/respond-heartbeat":1}},private:{post:{"private/set-cancel-on-disconnect":10/3,"private/get-cancel-on-disconnect":10/3,"private/create-withdrawal":10/3,"private/get-withdrawal-history":10/3,"private/get-currency-networks":10/3,"private/get-deposit-history":10/3,"private/get-deposit-address":10/3,"private/get-account-summary":10/3,"private/create-order":2/3,"private/cancel-order":2/3,"private/cancel-all-orders":2/3,"private/create-order-list":10/3,"private/get-order-history":10/3,"private/get-open-orders":10/3,"private/get-order-detail":1/3,"private/get-trades":100,"private/margin/get-user-config":10/3,"private/margin/get-account-summary":10/3,"private/margin/transfer":10/3,"private/margin/borrow":10/3,"private/margin/repay":10/3,"private/margin/get-transfer-history":10/3,"private/margin/get-borrow-history":10/3,"private/margin/get-interest-history":10/3,"private/margin/get-repay-history":10/3,"private/margin/get-liquidation-history":10/3,"private/margin/get-liquidation-orders":10/3,"private/margin/create-order":2/3,"private/margin/cancel-order":2/3,"private/margin/cancel-all-orders":2/3,"private/margin/get-order-history":10/3,"private/margin/get-open-orders":10/3,"private/margin/get-order-detail":1/3,"private/margin/get-trades":100,"private/deriv/transfer":10/3,"private/deriv/get-transfer-history":10/3,"private/get-accounts":10/3,"private/get-subaccount-balances":10/3,"private/create-subaccount-transfer":10/3,"private/otc/get-otc-user":10/3,"private/otc/get-instruments":10/3,"private/otc/request-quote":100,"private/otc/accept-quote":100,"private/otc/get-quote-history":10/3,"private/otc/get-trade-history":10/3}}},derivatives:{public:{get:{"public/auth":10/3,"public/get-instruments":10/3,"public/get-book":1,"public/get-candlestick":1,"public/get-trades":1,"public/get-tickers":1,"public/get-valuations":1,"public/get-expired-settlement-price":10/3,"public/get-insurance":1}},private:{post:{"private/set-cancel-on-disconnect":10/3,"private/get-cancel-on-disconnect":10/3,"private/user-balance":10/3,"private/user-balance-history":10/3,"private/get-positions":10/3,"private/create-order":2/3,"private/cancel-order":2/3,"private/cancel-all-orders":2/3,"private/close-position":10/3,"private/convert-collateral":10/3,"private/get-order-history":100,"private/get-open-orders":10/3,"private/get-order-detail":1/3,"private/get-trades":100,"private/change-account-leverage":10/3,"private/get-transactions":10/3}}}},fees:{trading:{maker:this.parseNumber("0.004"),taker:this.parseNumber("0.004"),tiers:{maker:[[this.parseNumber("0"),this.parseNumber("0.004")],[this.parseNumber("25000"),this.parseNumber("0.0035")],[this.parseNumber("50000"),this.parseNumber("0.0015")],[this.parseNumber("100000"),this.parseNumber("0.001")],[this.parseNumber("250000"),this.parseNumber("0.0009")],[this.parseNumber("1000000"),this.parseNumber("0.0008")],[this.parseNumber("20000000"),this.parseNumber("0.0007")],[this.parseNumber("100000000"),this.parseNumber("0.0006")],[this.parseNumber("200000000"),this.parseNumber("0.0004")]],taker:[[this.parseNumber("0"),this.parseNumber("0.004")],[this.parseNumber("25000"),this.parseNumber("0.0035")],[this.parseNumber("50000"),this.parseNumber("0.0025")],[this.parseNumber("100000"),this.parseNumber("0.0016")],[this.parseNumber("250000"),this.parseNumber("0.00015")],[this.parseNumber("1000000"),this.parseNumber("0.00014")],[this.parseNumber("20000000"),this.parseNumber("0.00013")],[this.parseNumber("100000000"),this.parseNumber("0.00012")],[this.parseNumber("200000000"),this.parseNumber("0.0001")]]}}},options:{defaultType:"spot",accountsById:{funding:"SPOT",spot:"SPOT",margin:"MARGIN",derivatives:"DERIVATIVES",swap:"DERIVATIVES",future:"DERIVATIVES"}},commonCurrencies:{USD_STABLE_COIN:"USDC"},precisionMode:QR,exceptions:{exact:{10001:k0,10002:S0,10003:S0,10004:Pt,10005:S0,10006:WR,10007:zR,10008:Pt,10009:Pt,20001:Pt,20002:jR,20005:XR,30003:KR,30004:Pt,30005:Pt,30006:Pt,30007:Pt,30008:Pt,30009:Pt,30010:Pt,30013:Pt,30014:Pt,30016:Pt,30017:Pt,30023:Pt,30024:Pt,30025:Pt,40001:Pt,40002:Pt,40003:Pt,40004:Pt,40005:Pt,40006:Pt,40007:Pt,40101:$R,50001:Pt,9010001:YR}}})}async fetchMarkets(e={}){let t=[this.fetchSpotMarkets(e),this.fetchDerivativesMarkets(e)];t=await Promise.all(t);const s=t[0],i=t[1];return this.arrayConcat(s,i)}async fetchSpotMarkets(e={}){const t=await this.spotPublicGetPublicGetInstruments(e),s=this.safeValue(t,"result",{}),i=this.safeValue(s,"instruments",[]),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"instrument_name"),d=this.safeString(a,"base_currency"),c=this.safeString(a,"quote_currency"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),l=this.safeString(a,"min_price"),p=this.safeString(a,"min_quantity");let m=this.parseNumber("1");this.safeValue(a,"margin_trading_enabled_5x")&&(m=this.parseNumber("5")),this.safeValue(a,"margin_trading_enabled_10x")&&(m=this.parseNumber("10")),n.push({id:o,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:this.safeValue(a,"margin_trading_enabled"),swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(a,"quantity_tick_size"),price:this.safeNumber(a,"price_tick_size")},limits:{leverage:{min:this.parseNumber("1"),max:m},amount:{min:this.parseNumber(p),max:this.safeNumber(a,"max_quantity")},price:{min:this.parseNumber(l),max:this.safeNumber(a,"max_price")},cost:{min:this.parseNumber(DS.stringMul(p,l)),max:void 0}},info:a})}return n}async fetchDerivativesMarkets(e={}){const t=[],s=await this.derivativesPublicGetPublicGetInstruments(),i=this.safeValue(s,"result",{}),n=this.safeValue(i,"data",[]);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeString(a,"inst_type"),d=o==="PERPETUAL_SWAP",c=o==="FUTURE";if(o==="CCY_PAIR")continue;const u=this.safeString(a,"base_ccy"),h=this.safeString(a,"quote_ccy"),l=this.safeCurrencyCode(u),p=this.safeCurrencyCode(h);let m=l+"/"+p+":"+p,g=this.safeInteger(a,"expiry_timestamp_ms");g===0&&(g=void 0);let y="swap";c&&(y="future",m=m+"-"+this.yymmdd(g));const b=this.safeNumber(a,"contract_size");t.push({id:this.safeString(a,"symbol"),symbol:m,base:l,quote:p,settle:p,baseId:u,quoteId:h,settleId:h,type:y,spot:!1,margin:!1,swap:d,future:c,option:!1,active:this.safeValue(a,"tradable"),contract:!0,linear:!0,inverse:!1,contractSize:b,expiry:g,expiryDatetime:this.iso8601(g),strike:void 0,optionType:void 0,precision:{price:this.parseNumber(this.parsePrecision(this.safeString(a,"quote_decimals"))),amount:this.parseNumber(this.parsePrecision(this.safeString(a,"quantity_decimals")))},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(a,"max_leverage")},amount:{min:this.parseNumber(b),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:a})}return t}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s;if(e!==void 0){const c=this.safeValue(e,0);s=this.market(c)}const[i,n]=this.handleMarketTypeAndParams("fetchTickers",s,t),r=this.getSupportedMapping(i,{spot:"spotPublicGetPublicGetTicker",future:"derivativesPublicGetPublicGetTickers",swap:"derivativesPublicGetPublicGetTickers"}),a=await this[r](n),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"data",[]);return this.parseTickers(d,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={instrument_name:s.id},[n,r]=this.handleMarketTypeAndParams("fetchTicker",s,t);if(n!=="spot")throw new FS(this.id+" fetchTicker() only supports spot markets");const a=await this.spotPublicGetPublicGetTicker(this.extend(i,r)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"data",{}),c=this.safeValue(d,0,{});return this.parseTicker(c,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Nf(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={instrument_name:n.id};t!==void 0&&(r.start_ts=t),s!==void 0&&(r.page_size=s);const[a,o]=this.handleMarketTypeAndParams("fetchOrders",n,i);let d=this.getSupportedMapping(a,{spot:"spotPrivatePostPrivateGetOrderHistory",margin:"spotPrivatePostPrivateMarginGetOrderHistory",future:"derivativesPrivatePostPrivateGetOrderHistory",swap:"derivativesPrivatePostPrivateGetOrderHistory"});const[c,u]=this.customHandleMarginModeAndParams("fetchOrders",o);c!==void 0&&(d="spotPrivatePostPrivateMarginGetOrderHistory");const h=await this[d](this.extend(r,u)),l=this.safeValue(h,"result",{}),p=this.safeValue2(l,"order_list","data",[]);return this.parseOrders(p,n,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={instrument_name:n.id};t!==void 0&&(r.start_ts=t),s!==void 0&&(r.page_size=s);const[a,o]=this.handleMarketTypeAndParams("fetchTrades",n,i),d=this.getSupportedMapping(a,{spot:"spotPublicGetPublicGetTrades",future:"derivativesPublicGetPublicGetTrades",swap:"derivativesPublicGetPublicGetTrades"}),c=await this[d](this.extend(r,o)),u=this.safeValue(c,"result",{}),h=this.safeValue(u,"data",[]);return this.parseTrades(h,n,t,s)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={instrument_name:r.id,timeframe:this.timeframes[t]},[o,d]=this.handleMarketTypeAndParams("fetchOHLCV",r,n),c=this.getSupportedMapping(o,{spot:"spotPublicGetPublicGetCandlestick",future:"derivativesPublicGetPublicGetCandlestick",swap:"derivativesPublicGetPublicGetCandlestick"}),u=await this[c](this.extend(a,d)),h=this.safeValue(u,"result",{}),l=this.safeValue(h,"data",[]);return this.parseOHLCVs(l,r,t,s,i)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={instrument_name:i.id};t&&(n.depth=t);const[r,a]=this.handleMarketTypeAndParams("fetchOrderBook",i,s),o=this.getSupportedMapping(r,{spot:"spotPublicGetPublicGetBook",future:"derivativesPublicGetPublicGetBook",swap:"derivativesPublicGetPublicGetBook"}),d=await this[o](this.extend(n,a)),c=this.safeValue(d,"result"),u=this.safeValue(c,"data"),h=this.safeValue(u,0),l=this.safeInteger(h,"t");return this.parseOrderBook(h,e,l)}parseSwapBalance(e){const t=this.safeValue(e,"result",{}),s=this.safeValue(t,"data",[]),i={info:e};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"instrument_name"),o=this.safeCurrencyCode(a),d=this.account();d.total=this.safeString(r,"total_cash_balance"),d.free=this.safeString(r,"total_available_balance"),i[o]=d}return this.safeBalance(i)}parseSpotBalance(e){const t=this.safeValue(e,"result",{}),s=this.safeValue(t,"accounts",[]),i={info:e};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.account();d.total=this.safeString(r,"balance"),d.free=this.safeString(r,"available"),d.used=this.safeString(r,"order"),i[o]=d}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("fetchBalance",void 0,e);let i=this.getSupportedMapping(t,{spot:"spotPrivatePostPrivateGetAccountSummary",margin:"spotPrivatePostPrivateMarginGetAccountSummary",future:"derivativesPrivatePostPrivateUserBalance",swap:"derivativesPrivatePostPrivateUserBalance"});const[n,r]=this.customHandleMarginModeAndParams("fetchBalance",s);n!==void 0&&(i="spotPrivatePostPrivateMarginGetAccountSummary");const a=await this[i](r),o=this.getSupportedMapping(t,{spot:"parseSpotBalance",margin:"parseSpotBalance",future:"parseSwapBalance",swap:"parseSwapBalance"});return this[o](a)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));const n={},[r,a]=this.handleMarketTypeAndParams("fetchOrder",i,s),[o,d]=this.customHandleMarginModeAndParams("fetchOrder",a);r==="spot"||r==="margin"||o!==void 0?n.order_id=e.toString():n.order_id=parseInt(e);let c=this.getSupportedMapping(r,{spot:"spotPrivatePostPrivateGetOrderDetail",margin:"spotPrivatePostPrivateMarginGetOrderDetail",future:"derivativesPrivatePostPrivateGetOrderDetail",swap:"derivativesPrivatePostPrivateGetOrderDetail"});o!==void 0&&(c="spotPrivatePostPrivateMarginGetOrderDetail");const u=await this[c](this.extend(n,d)),h=this.safeValue(u,"result",{}),l=this.safeValue(h,"order_info",h);return this.parseOrder(l,i)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=t.toUpperCase(),d={instrument_name:a.id,side:s.toUpperCase(),type:o,quantity:this.amountToPrecision(e,i)};(o==="LIMIT"||o==="STOP_LIMIT")&&(d.price=this.priceToPrecision(e,n)),this.safeValue(r,"postOnly",!1)&&(d.exec_inst="POST_ONLY",r=this.omit(r,["postOnly"]));const[u,h]=this.handleMarketTypeAndParams("createOrder",a,r);let l=this.getSupportedMapping(u,{spot:"spotPrivatePostPrivateCreateOrder",margin:"spotPrivatePostPrivateMarginCreateOrder",future:"derivativesPrivatePostPrivateCreateOrder",swap:"derivativesPrivatePostPrivateCreateOrder"});const[p,m]=this.customHandleMarginModeAndParams("createOrder",h);p!==void 0&&(l="spotPrivatePostPrivateMarginCreateOrder");const g=await this[l](this.extend(d,m)),y=this.safeValue(g,"result",{});return this.parseOrder(y,a)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();let s;e!==void 0&&(s=this.market(e));const i={},[n,r]=this.handleMarketTypeAndParams("cancelAllOrders",s,t),[a,o]=this.customHandleMarginModeAndParams("cancelAllOrders",r);if(n==="spot"||n==="margin"||a!==void 0){if(e===void 0)throw new Nf(this.id+" cancelAllOrders() requires a symbol argument for "+n+" orders");i.instrument_name=s.id}let d=this.getSupportedMapping(n,{spot:"spotPrivatePostPrivateCancelAllOrders",margin:"spotPrivatePostPrivateMarginCancelAllOrders",future:"derivativesPrivatePostPrivateCancelAllOrders",swap:"derivativesPrivatePostPrivateCancelAllOrders"});return a!==void 0&&(d="spotPrivatePostPrivateMarginCancelAllOrders"),await this[d](this.extend(i,o))}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));const n={},[r,a]=this.handleMarketTypeAndParams("cancelOrder",i,s),[o,d]=this.customHandleMarginModeAndParams("cancelOrder",a);if(r==="spot"||r==="margin"||o!==void 0){if(t===void 0)throw new Nf(this.id+" cancelOrder() requires a symbol argument for "+r+" orders");n.instrument_name=i.id,n.order_id=e.toString()}else n.order_id=parseInt(e);let c=this.getSupportedMapping(r,{spot:"spotPrivatePostPrivateCancelOrder",margin:"spotPrivatePostPrivateMarginCancelOrder",future:"derivativesPrivatePostPrivateCancelOrder",swap:"derivativesPrivatePostPrivateCancelOrder"});o!==void 0&&(c="spotPrivatePostPrivateMarginCancelOrder");const u=await this[c](this.extend(n,d)),h=this.safeValue(u,"result",u);return this.parseOrder(h)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.instrument_name=n.id),s!==void 0&&(r.page_size=s);const[a,o]=this.handleMarketTypeAndParams("fetchOpenOrders",n,i);let d=this.getSupportedMapping(a,{spot:"spotPrivatePostPrivateGetOpenOrders",margin:"spotPrivatePostPrivateMarginGetOpenOrders",future:"derivativesPrivatePostPrivateGetOpenOrders",swap:"derivativesPrivatePostPrivateGetOpenOrders"});const[c,u]=this.customHandleMarginModeAndParams("fetchOpenOrders",o);c!==void 0&&(d="spotPrivatePostPrivateMarginGetOpenOrders");const h=await this[d](this.extend(r,u)),l=this.safeValue(h,"result",{}),p=this.safeValue2(l,"order_list","data",[]);return this.parseOrders(p,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.market(e),n.instrument_name=r.id),t!==void 0){n.start_ts=t;const m=this.sum(t,24*60*60*1e3);n.end_ts=m}s!==void 0&&(n.page_size=s);const[a,o]=this.handleMarketTypeAndParams("fetchMyTrades",r,i);let d=this.getSupportedMapping(a,{spot:"spotPrivatePostPrivateGetTrades",margin:"spotPrivatePostPrivateMarginGetTrades",future:"derivativesPrivatePostPrivateGetTrades",swap:"derivativesPrivatePostPrivateGetTrades"});const[c,u]=this.customHandleMarginModeAndParams("fetchMyTrades",o);c!==void 0&&(d="spotPrivatePostPrivateMarginGetTrades");const h=await this[d](this.extend(n,u)),l=this.safeValue(h,"result",{}),p=this.safeValue2(l,"trade_list","data",[]);return this.parseTrades(p,r,t,s)}parseAddress(e){let t,s,i;return e.indexOf("?")>0?([t,i]=e.split("?"),s=i.split("=")[1]):t=e,[t,s]}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,amount:t,address:s};i!==void 0&&(a.address_tag=i);const o=await this.spotPrivatePostPrivateCreateWithdrawal(this.extend(a,n)),d=this.safeValue(o,"result");return this.parseTransaction(d,r)}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.spotPrivatePostPrivateGetDepositAddress(this.extend(i,t)),r=this.safeValue(n,"result",{}),a=this.safeValue(r,"deposit_address_list",[]);if(a.length===0)throw new k0(this.id+" fetchDepositAddressesByNetwork() generating address...");const o={};for(let d=0;d<a.length;d++){const c=this.safeValue(a,d),u=this.safeString(c,"address"),h=this.safeString(c,"currency"),l=this.safeCurrencyCode(h),[p,m]=this.parseAddress(u);this.checkAddress(p);const g=this.safeString(c,"network"),y=this.safeNetwork(g);o[y]={info:c,currency:l,address:p,tag:m,network:y}}return o}async fetchDepositAddress(e,t={}){const s=this.safeStringUpper(t,"network");t=this.omit(t,["network"]);const i=await this.fetchDepositAddressesByNetwork(e,t);if(s in i)return i[s];{const n=Object.keys(i);return i[n[0]]}}safeNetwork(e){const t={BTC:"BTC",ETH:"ETH",SOL:"SOL",BNB:"BNB",CRONOS:"CRONOS",MATIC:"MATIC",OP:"OP"};return this.safeString(t,e,e)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.currency=n.id),t!==void 0&&(r.start_ts=t),s!==void 0&&(r.page_size=s);const a=await this.spotPrivatePostPrivateGetDepositHistory(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"deposit_list",[]);return this.parseTransactions(d,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.currency=n.id),t!==void 0&&(r.start_ts=t),s!==void 0&&(r.page_size=s);const a=await this.spotPrivatePostPrivateGetWithdrawalHistory(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"withdrawal_list",[]);return this.parseTransactions(d,n,t,s)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e);s=s.toLowerCase(),i=i.toLowerCase();const a=this.safeValue(this.options,"accountsById",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c={currency:r.id,amount:parseFloat(t),from:o,to:d};let u="spotPrivatePostPrivateDerivTransfer";(s==="margin"||i==="margin")&&(u="spotPrivatePostPrivateMarginTransfer");const h=await this[u](this.extend(c,n));return this.parseTransfer(h,r)}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){if(!("direction"in i))throw new Nf(this.id+' fetchTransfers() requires a direction param to be either "IN" or "OUT"');await this.loadMarkets();let n;const r={direction:"OUT"};e!==void 0&&(n=this.currency(e),r.currency=n.id),t!==void 0&&(r.start_ts=t),s!==void 0&&(r.page_size=s);let a="spotPrivatePostPrivateDerivGetTransferHistory";const[o,d]=this.customHandleMarginModeAndParams("fetchTransfers",i);o!==void 0&&(a="spotPrivatePostPrivateMarginGetTransferHistory");const c=await this[a](this.extend(r,d)),u=[];return u.push({response:c}),this.parseTransfers(u,n,t,s,i)}parseTransferStatus(e){const t={COMPLETED:"ok",PROCESSING:"pending"};return this.safeString(t,e,e)}parseTransfer(e,t=void 0){const s=this.safeValue(e,"response",{}),i=this.safeValue(s,"result",{}),n=this.safeValue(i,"transfer_list",[]);let r,a,o,d,c;for(let l=0;l<n.length;l++){const p=n[l];r=this.safeInteger(p,"time"),a=this.safeNumber(p,"amount");const m=this.safeString(p,"currency");o=this.safeCurrencyCode(m),d=this.safeString(p,"information");const g=this.safeString(p,"status");c=this.parseTransferStatus(g)}let u,h;if(d!==void 0){const l=d.split(" "),p=this.safeStringLower(l,0),m=this.safeString(s,"method");p==="from"?(u=this.safeStringLower(l,1),m==="private/margin/get-transfer-history"?h="margin":h="derivative"):p==="to"&&(h=this.safeStringLower(l,1),m==="private/margin/get-transfer-history"?u="margin":u="derivative")}return{info:n,id:this.safeString(s,"id"),timestamp:r,datetime:this.iso8601(r),currency:o,amount:a,fromAccount:u,toAccount:h,status:c}}parseTicker(e,t=void 0){const s=this.safeInteger(e,"t"),i=this.safeString(e,"i");t=this.safeMarket(i,t,"_");const n=t.symbol,r=this.safeString(e,"a"),a=this.safeString(e,"c");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"h"),low:this.safeString(e,"l"),bid:this.safeString(e,"b"),bidVolume:void 0,ask:this.safeString(e,"k"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:a,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"v"),quoteVolume:void 0,info:e},t)}parseTrade(e,t=void 0){const s=this.safeInteger2(e,"t","create_time"),i=this.safeString2(e,"i","instrument_name");t=this.safeMarket(i,t,"_");const n=t.symbol,r=this.safeString2(e,"p","traded_price"),a=this.safeString2(e,"q","traded_quantity");let o=this.safeString2(e,"s","side");o!==void 0&&(o=o.toLowerCase());const d=this.safeString2(e,"d","trade_id"),c=this.safeStringLower2(e,"liquidity_indicator","taker_side"),u=this.safeString(e,"order_id");let h,l=this.safeString2(e,"fee","fees");if(l!==void 0){this.safeValue(t,"contract",!1)&&(l=DS.stringNeg(l));let m;t.spot?m=this.safeString(e,"fee_currency"):t.linear&&(m=t.quote),h={currency:m,cost:l}}return this.safeTrade({info:e,id:d,timestamp:s,datetime:this.iso8601(s),symbol:n,side:o,price:r,amount:a,cost:void 0,order:u,takerOrMaker:c,type:void 0,fee:h},t)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"t"),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}parseOrderStatus(e){const t={ACTIVE:"open",CANCELED:"canceled",FILLED:"closed",REJECTED:"rejected",EXPIRED:"expired"};return this.safeString(t,e,e)}parseTimeInForce(e){const t={GOOD_TILL_CANCEL:"GTC",IMMEDIATE_OR_CANCEL:"IOC",FILL_OR_KILL:"FOK"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"create_time"),i=this.safeInteger(e,"update_time"),n=this.safeString(e,"instrument_name"),r=this.safeSymbol(n,t),a=this.safeString(e,"quantity"),o=this.safeString(e,"cumulative_quantity"),d=this.parseOrderStatus(this.safeString(e,"status")),c=this.safeString(e,"order_id"),u=this.safeString(e,"client_oid"),h=this.safeString2(e,"price","limit_price"),l=this.safeString(e,"avg_price"),p=this.safeStringLower2(e,"type","order_type"),m=this.safeStringLower(e,"side"),g=this.parseTimeInForce(this.safeString(e,"time_in_force")),y=this.safeString(e,"exec_inst");let b;y!==void 0&&(b=y==="POST_ONLY");const w=this.safeString(e,"cumulative_value"),k=this.safeString(e,"cumulative_fee");let T;if(k!==void 0){const O=this.safeString(e,"fee_instrument_name");T={cost:k,currency:this.safeCurrencyCode(O)}}return this.safeOrder({info:e,id:c,clientOrderId:u,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:i,status:d,symbol:r,type:p,timeInForce:g,postOnly:b,side:m,price:h,amount:a,filled:o,remaining:void 0,cost:w,fee:T,average:l,trades:[]},t)}parseDepositStatus(e){const t={0:"pending",1:"ok",2:"failed",3:"pending"};return this.safeString(t,e,e)}parseWithdrawalStatus(e){const t={0:"pending",1:"pending",2:"failed",3:"pending",4:"failed",5:"ok",6:"canceled"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){let s;const i=this.safeString(e,"status");let n;"client_wid"in e?(s="withdrawal",n=this.parseWithdrawalStatus(i)):(s="deposit",n=this.parseDepositStatus(i));const r=this.safeString(e,"id"),a=this.safeString(e,"address"),[o,d]=this.parseAddress(a),c=this.safeString(e,"currency"),u=this.safeCurrencyCode(c,t),h=this.safeInteger(e,"create_time"),l=this.safeNumber(e,"amount"),p=this.safeString(e,"txid"),m=this.safeNumber(e,"fee");let g;m!==void 0&&(g={currency:u,cost:m});const y=this.safeInteger(e,"update_time");return{info:e,id:r,txid:p,timestamp:h,datetime:this.iso8601(h),network:void 0,address:o,addressTo:o,addressFrom:void 0,tag:d,tagTo:d,tagFrom:void 0,type:s,amount:l,currency:u,status:n,updated:y,internal:void 0,fee:g}}async repayMargin(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.currency(e),r={currency:n.id,amount:this.currencyToPrecision(e,t)},a=await this.spotPrivatePostPrivateMarginRepay(this.extend(r,i)),o=this.parseMarginLoan(a,n);return this.extend(o,{amount:t})}async borrowMargin(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.currency(e),r={currency:n.id,amount:this.currencyToPrecision(e,t)},a=await this.spotPrivatePostPrivateMarginBorrow(this.extend(r,i)),o=this.parseMarginLoan(a,n);return this.extend(o,{amount:t})}parseMarginLoan(e,t=void 0){return{id:this.safeInteger(e,"id"),currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a,o;t!==void 0&&(a=this.market(t)),e!==void 0&&(o=this.currency(e),r.currency=o.id),s!==void 0&&(r.start_ts=s),i!==void 0&&(r.page_size=i);const d=await this.spotPrivatePostPrivateMarginGetInterestHistory(this.extend(r,n)),c=this.safeValue(d,"result",{}),u=this.safeValue(c,"list",[]);let h;for(let l=0;l<u.length;l++)h=this.parseBorrowInterests(u,a);return this.filterByCurrencySinceLimit(h,e,s,i)}parseBorrowInterest(e,t=void 0){const s=this.safeInteger(e,"time");let i;return t!==void 0&&(i=t.symbol),{symbol:i,marginMode:void 0,currency:this.safeCurrencyCode(this.safeString(e,"currency")),interest:this.safeNumber(e,"interest"),interestRate:this.safeNumber(e,"interest_rate"),amountBorrowed:void 0,timestamp:s,datetime:this.iso8601(s),info:e}}async fetchBorrowRates(e={}){await this.loadMarkets();const t=await this.spotPrivatePostPrivateMarginGetUserConfig(e),s=this.safeValue(t,"result",{}),i=this.safeValue(s,"currency_configs",[]);return this.parseBorrowRates(i,"currency")}parseBorrowRates(e,t){const s=this.milliseconds(),i=[];for(let n=0;n<e.length;n++){const r=e[n];i.push({currency:this.safeCurrencyCode(this.safeString(r,"currency")),rate:this.safeNumber(r,"hourly_rate"),period:36e5,timestamp:s,datetime:this.iso8601(s),info:r})}return i}customHandleMarginModeAndParams(e,t={}){const s=this.safeString(this.options,"defaultType"),i=this.safeValue(t,"margin",!1);t=this.omit(t,"margin");let n;if([n,t]=this.handleMarginModeAndParams(e,t),n!==void 0){if(n!=="cross")throw new FS(this.id+" only cross margin is supported")}else(s==="margin"||i===!0)&&(n="cross");return[n,t]}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const[a,o]=t;let d=this.urls.api[a]+"/"+e;const c=this.omit(i,this.extractParams(e));if(o==="public")Object.keys(c).length&&(d+="?"+this.urlencode(c));else{this.checkRequiredCredentials();const u=this.nonce().toString(),h=this.extend({},i),l=this.keysort(h),p=Object.keys(l);let m="";for(let w=0;w<p.length;w++)m=m+p[w].toString()+h[p[w]].toString();const g=e+u+this.apiKey+m+u,y=this.hmac(this.encode(g),this.encode(this.secret)),b=p.length;if(r=this.json({id:u,method:e,params:i,api_key:this.apiKey,sig:y,nonce:u}),b===0){const w="{}",k="[]";r=r.replace(k,w)}n={"Content-Type":"application/json"}}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){const c=this.safeString(a,"code");if(c!=="0"){const u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),new k0(this.id+" "+r)}}};const ZR=ge,{BadSymbol:JR,ExchangeError:Vf,ArgumentsRequired:v0,ExchangeNotAvailable:T0,InsufficientFunds:eF,OrderNotFound:HS,InvalidOrder:ea,DDoSProtection:tF,InvalidNonce:sF,AuthenticationError:vc,BadRequest:O0}=de,{TICK_SIZE:iF}=me,mr=Se;var z_=class extends ZR{describe(){return this.deepExtend(super.describe(),{id:"currencycom",name:"Currency.com",countries:["BY"],rateLimit:100,certified:!1,pro:!0,version:"v2",has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!1,option:!1,addMargin:void 0,cancelAllOrders:void 0,cancelOrder:!0,cancelOrders:void 0,createDepositAddress:void 0,createLimitOrder:!0,createMarketOrder:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:"emulated",fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowRate:void 0,fetchBorrowRateHistory:void 0,fetchBorrowRates:void 0,fetchBorrowRatesPerSymbol:void 0,fetchCanceledOrders:void 0,fetchClosedOrder:void 0,fetchClosedOrders:void 0,fetchCurrencies:!0,fetchDeposit:void 0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchL2OrderBook:!0,fetchLedger:!0,fetchLedgerEntry:!1,fetchLeverage:!0,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrder:void 0,fetchOpenOrders:!0,fetchOrder:void 0,fetchOrderBook:!0,fetchOrderBooks:void 0,fetchOrders:void 0,fetchOrderTrades:void 0,fetchPosition:void 0,fetchPositionMode:!1,fetchPositions:!0,fetchPositionsRisk:void 0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTradingLimits:void 0,fetchTransactionFee:void 0,fetchTransactionFees:void 0,fetchTransactions:!0,fetchTransfers:void 0,fetchWithdrawal:void 0,fetchWithdrawals:!0,reduceMargin:void 0,setLeverage:void 0,setMarginMode:void 0,setPositionMode:void 0,signIn:void 0,transfer:void 0,withdraw:void 0},timeframes:{"1m":"1m","5m":"5m","10m":"10m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","1d":"1d","1w":"1w"},hostname:"backend.currency.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/83718672-36745c00-a63e-11ea-81a9-677b1f789a4d.jpg",api:{public:"https://api-adapter.{hostname}/api",private:"https://api-adapter.{hostname}/api",marketcap:"https://marketcap.{hostname}/api"},test:{public:"https://demo-api-adapter.{hostname}/api",private:"https://demo-api-adapter.{hostname}/api"},www:"https://www.currency.com",referral:"https://currency.com/trading/signup?c=362jaimv&pid=referral",doc:["https://currency.com/api"],fees:"https://currency.com/fees-charges"},api:{public:{get:{"v1/time":1,"v1/exchangeInfo":1,"v1/depth":1,"v1/aggTrades":1,"v1/klines":1,"v1/ticker/24hr":1,"v2/time":1,"v2/exchangeInfo":1,"v2/depth":1,"v2/aggTrades":1,"v2/klines":1,"v2/ticker/24hr":1}},marketcap:{get:{"v1/assets":1,"v1/candles":1,"v1/orderbook":1,"v1/summary":1,"v1/ticker":1,"v1/token/assets":1,"v1/token/orderbook":1,"v1/token/summary":1,"v1/token/ticker":1,"v1/token/trades":1,"v1/token_crypto/OHLC":1,"v1/token_crypto/assets":1,"v1/token_crypto/orderbook":1,"v1/token_crypto/summary":1,"v1/token_crypto/ticker":1,"v1/token_crypto/trades":1,"v1/trades":1}},private:{get:{"v1/account":1,"v1/currencies":1,"v1/deposits":1,"v1/depositAddress":1,"v1/ledger":1,"v1/leverageSettings":1,"v1/myTrades":1,"v1/openOrders":1,"v1/tradingPositions":1,"v1/tradingPositionsHistory":1,"v1/transactions":1,"v1/withdrawals":1,"v2/account":1,"v2/currencies":1,"v2/deposits":1,"v2/depositAddress":1,"v2/ledger":1,"v2/leverageSettings":1,"v2/myTrades":1,"v2/openOrders":1,"v2/tradingPositions":1,"v2/tradingPositionsHistory":1,"v2/transactions":1,"v2/withdrawals":1},post:{"v1/order":1,"v1/updateTradingPosition":1,"v1/updateTradingOrder":1,"v1/closeTradingPosition":1,"v2/order":1,"v2/updateTradingPosition":1,"v2/updateTradingOrder":1,"v2/closeTradingPosition":1},delete:{"v1/order":1,"v2/order":1}}},fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,taker:this.parseNumber("0.002"),maker:this.parseNumber("0.002")}},precisionMode:iF,options:{defaultTimeInForce:"GTC",warnOnFetchOpenOrdersWithoutSymbol:!0,recvWindow:5*1e3,timeDifference:0,adjustForTimeDifference:!1,parseOrderToPrecision:!1,newOrderRespType:{market:"FULL",limit:"RESULT",stop:"RESULT"},leverage_markets_suffix:"_LEVERAGE",collateralCurrencies:["USD","EUR","USDT"]},exceptions:{broad:{"FIELD_VALIDATION_ERROR Cancel is available only for LIMIT order":ea,"API key does not exist":vc,"Order would trigger immediately.":ea,"Account has insufficient balance for requested action.":eF,"Rest API trading is not enabled.":T0,"Combination of parameters invalid":O0,"Invalid limit price":O0,"Only leverage symbol allowed here:":JR,"market data service is not available":T0,"your time is ahead of server":sF},exact:{"-1000":T0,"-1013":ea,"-1022":vc,"-1030":ea,"-1100":ea,"-1104":Vf,"-1025":vc,"-1128":O0,"-2010":Vf,"-2011":HS,"-2013":HS,"-2014":vc,"-2015":vc}},commonCurrencies:{ACN:"Accenture",AMC:"AMC Entertainment Holdings",BNS:"Bank of Nova Scotia",CAR:"Avis Budget Group Inc",CLR:"Continental Resources",EDU:"New Oriental Education & Technology Group Inc",ETN:"Eaton",FOX:"Fox Corporation",GM:"General Motors Co",IQ:"iQIYI",OSK:"Oshkosh",PLAY:"Dave & Buster's Entertainment"}})}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchTime(e={}){const t=await this.publicGetV2Time(e);return this.safeInteger(t,"serverTime")}async fetchCurrencies(e={}){if(!this.checkRequiredCredentials(!1))return;const t=await this.privateGetV2Currencies(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"displaySymbol"),a=this.safeCurrencyCode(r),o=this.safeNumber(n,"commissionFixed");s[a]={id:r,code:a,address:this.safeString(n,"baseAddress"),type:this.safeStringLower(n,"type"),name:this.safeString(n,"name"),active:void 0,deposit:void 0,withdraw:void 0,fee:o,precision:this.parseNumber(this.parsePrecision(this.safeString(n,"precision"))),limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.safeNumber(n,"minWithdrawal"),max:this.safeNumber(n,"maxWithdrawal")},deposit:{min:this.safeNumber(n,"minDeposit"),max:void 0}},info:n}}return s}async fetchMarkets(e={}){const t=await this.publicGetV2ExchangeInfo(e);this.options.adjustForTimeDifference&&await this.loadTimeDifference();const s=this.safeValue(t,"symbols",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeString(r,"baseAsset"),d=this.safeString(r,"quoteAsset"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d);let h=c+"/"+u;const l=this.safeString(r,"marketType"),p=l==="SPOT",m=!1,g=l==="LEVERAGE",y=g;g&&(h=h.replace(this.options.leverage_markets_suffix,""),h+=":"+u);const b=this.safeString(r,"status")==="TRADING",w=this.safeString2(r,"exchangeFee","tradingFee");let k=this.safeString(r,"makerFee",w),T=this.safeString(r,"takerFee",w);k=mr.stringDiv(k,"100"),T=mr.stringDiv(T,"100");const O=this.safeValue(r,"filters",[]),x=this.indexBy(O,"filterType");let C,E,P=this.safeNumber(r,"tickSize");if("PRICE_FILTER"in x){const q=this.safeValue(x,"PRICE_FILTER",{});P=this.safeNumber(q,"tickSize"),C=this.safeNumber(q,"minPrice");const R=this.safeString(q,"maxPrice");R!==void 0&&mr.stringGt(R,"0")&&(E=R)}let _=this.parseNumber(this.parsePrecision(this.safeString(r,"baseAssetPrecision"))),S={min:void 0,max:void 0};if("LOT_SIZE"in x){const q=this.safeValue(x,"LOT_SIZE",{});_=this.safeNumber(q,"stepSize"),S={min:this.safeNumber(q,"minQty"),max:this.safeNumber(q,"maxQty")}}let I={min:void 0,max:void 0};if("MARKET_LOT_SIZE"in x){const q=this.safeValue(x,"MARKET_LOT_SIZE",{});I={min:this.safeNumber(q,"minQty"),max:this.safeNumber(q,"maxQty")}}let v;if("MIN_NOTIONAL"in x){const q=this.safeValue(x,"MIN_NOTIONAL",{});v=this.safeNumber(q,"minNotional")}const N=g||m;i.push({id:a,symbol:h,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:l,spot:p,margin:y,swap:g,future:m,option:!1,active:b,contract:N,linear:N?!0:void 0,inverse:void 0,taker:this.parseNumber(T),maker:this.parseNumber(k),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:_,price:P},limits:{leverage:{min:void 0,max:void 0},amount:S,market:I,price:{min:C,max:this.parseNumber(E)},cost:{min:v,max:void 0}},info:r})}return i}async fetchAccounts(e={}){const t=await this.privateGetV2Account(e),s=this.safeValue(t,"balances",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeInteger(r,"accountId"),o=this.safeString(r,"asset"),d=this.safeCurrencyCode(o);i.push({id:a,type:void 0,currency:d,info:r})}return i}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetV2Account(e),s=this.safeNumber(t,"makerCommission"),i=this.safeNumber(t,"takerCommission"),n={};for(let r=0;r<this.symbols.length;r++){const a=this.symbols[r];n[a]={info:t,symbol:a,maker:s,taker:i,percentage:!0,tierBased:!1}}return n}parseBalance(e,t=void 0){const s={info:e},i=this.safeValue(e,"balances",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"asset"),o=this.safeCurrencyCode(a),d=this.account();d.free=this.safeString(r,"free"),d.used=this.safeString(r,"locked"),s[o]=d}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetV2Account(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={symbol:this.market(e).id};t!==void 0&&(n.limit=t);const r=await this.publicGetV2Depth(this.extend(n,s)),a=this.parseOrderBook(r,e);return a.nonce=this.safeInteger(r,"lastUpdateId"),a}parseTicker(e,t=void 0){const s=this.safeInteger2(e,"closeTime","timestamp"),i=this.safeString2(e,"symbol","symbolName");t=this.safeMarket(i,t,"/");const n=this.safeString(e,"lastPrice");return this.safeTicker({symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"highPrice"),low:this.safeString(e,"lowPrice"),bid:this.safeString2(e,"bidPrice","bid"),bidVolume:this.safeString(e,"bidQty"),ask:this.safeString2(e,"askPrice","ofr"),askVolume:this.safeString(e,"ofrQty"),vwap:this.safeString(e,"weightedAvgPrice"),open:this.safeString(e,"openPrice"),close:n,last:n,previousClose:this.safeString(e,"prevClosePrice"),change:this.safeString(e,"priceChange"),percentage:this.safeString(e,"priceChangePercent"),average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:this.safeString(e,"quoteVolume"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetV2Ticker24hr(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetV2Ticker24hr(t);return this.parseTickers(s,e)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,interval:this.timeframes[t]};s!==void 0&&(a.startTime=s),i!==void 0&&(a.limit=i);const o=await this.publicGetV2Klines(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}parseTrade(e,t=void 0){const s=this.safeInteger2(e,"T","time"),i=this.safeString2(e,"p","price"),n=this.safeString2(e,"q","qty"),r=this.safeString2(e,"a","id");let a;const o=this.safeString(e,"orderId");let d;"m"in e?(a=e.m?"sell":"buy",d="taker"):"isBuyer"in e&&(a=e.isBuyer?"buy":"sell",d=e.isMaker?"maker":"taker");let c;"commission"in e&&(c={cost:this.safeString(e,"commission"),currency:this.safeCurrencyCode(this.safeString(e,"commissionAsset"))});const u=this.safeString(e,"symbol"),h=this.safeSymbol(u,t);return this.safeTrade({id:r,order:o,timestamp:s,datetime:this.iso8601(s),symbol:h,type:void 0,takerOrMaker:d,side:a,price:i,amount:n,cost:void 0,fee:c,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s),t!==void 0&&(r.startTime=t);const a=await this.publicGetV2AggTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t,"/"),n=this.safeString(e,"orderId"),r=this.safeString(e,"price"),a=this.safeString(e,"origQty"),o=this.safeString(e,"executedQty"),d=mr.stringAbs(o),c=this.parseOrderStatus(this.safeString(e,"status")),u=this.parseOrderTimeInForce(this.safeString(e,"timeInForce")),h=this.parseOrderType(this.safeString(e,"type")),l=this.parseOrderSide(this.safeString(e,"side")),p=this.safeInteger2(e,"time","transactTime"),m=this.safeValue(e,"fills");return this.safeOrder({info:e,id:n,timestamp:p,datetime:this.iso8601(p),lastTradeTimestamp:void 0,symbol:i,type:h,timeInForce:u,side:l,price:r,stopPrice:void 0,amount:a,cost:void 0,average:void 0,filled:d,remaining:void 0,status:c,fee:void 0,trades:m},t)}parseOrderStatus(e){const t={NEW:"open",PARTIALLY_FILLED:"open",FILLED:"closed",CANCELED:"canceled",PENDING_CANCEL:"canceling",REJECTED:"rejected",EXPIRED:"expired"};return this.safeString(t,e,e)}parseOrderType(e){const t={MARKET:"market",LIMIT:"limit",STOP:"stop"};return this.safeString(t,e,e)}parseOrderTimeInForce(e){const t={GTC:"GTC",FOK:"FOK",IOC:"IOC"};return this.safeString(t,e,e)}parseOrderSide(e){const t={BUY:"buy",SELL:"sell"};return this.safeString(t,e,e)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o;if(a.margin&&(o=this.safeString(this.options,"accountId"),o=this.safeString(r,"accountId",o),o===void 0))throw new v0(this.id+" createOrder() requires an accountId parameter or an exchange.options['accountId'] option for "+a.type+" markets");const d=this.safeValue(this.options.newOrderRespType,t,"RESULT"),c={symbol:a.id,quantity:this.amountToPrecision(e,i),type:t.toUpperCase(),side:s.toUpperCase(),newOrderRespType:d};if(t==="limit")c.price=this.priceToPrecision(e,n),c.timeInForce=this.options.defaultTimeInForce;else if(t==="stop")c.type="STOP",c.price=this.priceToPrecision(e,n);else if(t==="market"){const h=this.safeValue2(r,"triggerPrice","stopPrice");r=this.omit(r,["triggerPrice","stopPrice"]),h!==void 0&&(c.type="STOP",c.price=this.priceToPrecision(e,h))}const u=await this.privatePostV2Order(this.extend(c,r));return this.parseOrder(u,a)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};if(e!==void 0)n=this.market(e),r.symbol=n.id;else if(this.options.warnOnFetchOpenOrdersWithoutSymbol){const d=this.symbols.length,c=parseInt(d/2);throw new Vf(this.id+" fetchOpenOrders() WARNING: fetching open orders without specifying a symbol is rate-limited to one call per "+c.toString()+" seconds. Do not call this method frequently to avoid ban. Set "+this.id+'.options["warnOnFetchOpenOrdersWithoutSymbol"] = false to suppress this warning message.')}const a=await this.privateGetV2OpenOrders(this.extend(r,i));return this.parseOrders(a,n,t,s,i)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new v0(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=this.safeValue(s,"origClientOrderId"),r={symbol:i.id};n===void 0?r.orderId=e:r.origClientOrderId=n;const a=await this.privateDeleteV2Order(this.extend(r,s));return this.parseOrder(a,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new v0(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s);const a=await this.privateGetV2MyTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByMethod("privateGetV2Deposits",e,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByMethod("privateGetV2Withdrawals",e,t,s,i)}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByMethod("privateGetV2Transactions",e,t,s,i)}async fetchTransactionsByMethod(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a;t!==void 0&&(a=this.currency(t)),s!==void 0&&(r.startTime=s),i!==void 0&&(r.limit=i);const o=await this[e](this.extend(r,n));return this.parseTransactions(o,a,s,i,n)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"blockchainTransactionHash"),n=this.safeNumber(e,"amount"),r=this.safeInteger(e,"timestamp"),a=this.safeString(e,"currency"),o=this.safeCurrencyCode(a,t),d=this.parseTransactionStatus(this.safeString(e,"state")),c=this.parseTransactionType(this.safeString(e,"type")),u=this.safeString(e,"commission");let h;return u!==void 0&&(h={currency:o,cost:u}),{id:s,txid:i,timestamp:r,datetime:this.iso8601(r),network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,type:c,amount:n,currency:o,status:d,updated:void 0,comment:void 0,fee:h,info:e}}parseTransactionStatus(e){const t={APPROVAL:"pending",PROCESSED:"ok"};return this.safeString(t,e,e)}parseTransactionType(e){const t={deposit:"deposit",withdrawal:"withdrawal"};return this.safeString(t,e,e)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e)),t!==void 0&&(n.startTime=t),s!==void 0&&(n.limit=s);const a=await this.privateGetV2Ledger(this.extend(n,i));return this.parseLedger(a,r,t,s)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"amount"),n=mr.stringAbs(i),r=this.safeInteger(e,"timestamp"),a=this.safeString(e,"currency"),o=this.safeCurrencyCode(a,t),d=this.safeString(e,"commission");let c;d!==void 0&&(c={currency:o,cost:d});const u=mr.stringLt(i,"0")?"out":"in";return{id:s,timestamp:r,datetime:this.iso8601(r),direction:u,account:void 0,referenceId:this.safeString(e,"blockchainTransactionHash"),referenceAccount:void 0,type:this.parseLedgerEntryType(this.safeString(e,"type")),currency:o,amount:n,before:void 0,after:this.safeString(e,"balance"),status:this.parseLedgerEntryStatus(this.safeString(e,"status")),fee:c,info:e}}parseLedgerEntryStatus(e){const t={APPROVAL:"pending",PROCESSED:"ok",CANCELLED:"canceled"};return this.safeString(t,e,e)}parseLedgerEntryType(e){const t={deposit:"transaction",withdrawal:"transaction",exchange_commission:"fee"};return this.safeString(t,e,e)}async fetchLeverage(e,t={}){await this.loadMarkets();const i={symbol:this.market(e).id},n=await this.privateGetV2LeverageSettings(this.extend(i,t));return this.safeNumber(n,"value")}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={coin:s.id},n=await this.privateGetV2DepositAddress(this.extend(i,t));return this.parseDepositAddress(n,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address");return this.checkAddress(s),t=this.safeCurrency(void 0,t),{currency:t.code,address:s,tag:void 0,network:void 0,info:e}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/"+e;if(e==="historicalTrades"&&(n={"X-MBX-APIKEY":this.apiKey}),t==="private"){this.checkRequiredCredentials();let o=this.urlencode(this.extend({timestamp:this.nonce(),recvWindow:this.options.recvWindow},i));const d=this.hmac(this.encode(o),this.encode(this.secret));o+="&signature="+d,n={"X-MBX-APIKEY":this.apiKey},s==="GET"||s==="DELETE"?a+="?"+o:(r=o,n["Content-Type"]="application/x-www-form-urlencoded")}else Object.keys(i).length&&(a+="?"+this.urlencode(i));return a=this.implodeHostname(a),{url:a,method:s,body:r,headers:n}}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetV2TradingPositions(t),i=this.safeValue(s,"positions",[]);return this.parsePositions(i,e)}parsePosition(e,t=void 0){t=this.safeMarket(this.safeString(e,"symbol"),t);const s=t.symbol,i=this.safeNumber(e,"createdTimestamp"),n=this.safeString(e,"openQuantity"),r=mr.stringGt(n,"0")?"long":"short",a=mr.stringAbs(n),o=this.safeNumber(e,"openPrice"),d=this.safeNumber(e,"upl"),c=this.safeString(e,"margin"),u=mr.stringDiv("1",c);return{symbol:s,timestamp:i,datetime:this.iso8601(i),contracts:this.parseNumber(a),contractSize:void 0,entryPrice:o,collateral:void 0,side:r,unrealizedProfit:d,leverage:u,percentage:void 0,marginMode:void 0,notional:void 0,markPrice:void 0,liquidationPrice:void 0,initialMargin:void 0,initialMarginPercentage:void 0,maintenanceMargin:this.parseNumber(c),maintenanceMarginPercentage:void 0,marginRatio:void 0,info:e,id:void 0}}handleErrors(e,t,s,i,n,r,a,o,d){if(e===418||e===429)throw new tF(this.id+" "+e.toString()+" "+t+" "+r);if(e>=400){if(r.indexOf("Price * QTY is zero or less")>=0)throw new ea(this.id+" order cost = amount * price is zero or less "+r);if(r.indexOf("LOT_SIZE")>=0)throw new ea(this.id+" order amount should be evenly divisible by lot size "+r);if(r.indexOf("PRICE_FILTER")>=0)throw new ea(this.id+" order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid float value in general, use this.priceToPrecision (symbol, amount) "+r)}if(a===void 0)return;const c=this.safeString(a,"code");if(c!==void 0&&c!=="0"){const u=this.id+" "+this.json(a);this.throwExactlyMatchedException(this.exceptions.exact,c,u);const h=this.safeString(a,"msg");throw this.throwBroadlyMatchedException(this.exceptions.broad,h,u),new Vf(u)}}};const nF=ge,{ExchangeError:rF,InsufficientFunds:aF,BadRequest:GS,BadSymbol:oF,InvalidOrder:Tc,AuthenticationError:US,ArgumentsRequired:$S,OrderNotFound:dF,ExchangeNotAvailable:cF}=de,{TICK_SIZE:uF}=me;var fF=class extends nF{describe(){return this.deepExtend(super.describe(),{id:"delta",name:"Delta Exchange",countries:["VC"],rateLimit:300,version:"v2",has:{CORS:void 0,spot:!0,margin:void 0,swap:void 0,future:void 0,option:void 0,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,editOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:void 0,fetchDepositAddress:!0,fetchDeposits:void 0,fetchLedger:!0,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrderBook:!0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTransfer:void 0,fetchTransfers:void 0,fetchWithdrawal:void 0,fetchWithdrawals:void 0,transfer:!1,withdraw:!1},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","1d":"1d","7d":"7d","1w":"1w","2w":"2w","1M":"30d"},urls:{logo:"https://user-images.githubusercontent.com/1294454/99450025-3be60a00-2931-11eb-9302-f4fd8d8589aa.jpg",test:{public:"https://testnet-api.delta.exchange",private:"https://testnet-api.delta.exchange"},api:{public:"https://api.delta.exchange",private:"https://api.delta.exchange"},www:"https://www.delta.exchange",doc:["https://docs.delta.exchange"],fees:"https://www.delta.exchange/fees",referral:"https://www.delta.exchange/app/signup/?code=IULYNB"},api:{public:{get:["assets","settings","indices","products","tickers","tickers/{symbol}","l2orderbook/{symbol}","trades/{symbol}","history/candles","history/sparklines"]},private:{get:["orders","orders/leverage","positions","positions/margined","orders/history","fills","fills/history/download/csv","wallet/balances","wallet/transactions","wallet/transactions/download","deposits/address"],post:["orders","orders/batch","orders/leverage","positions/change_margin"],put:["orders","orders/batch"],delete:["orders","orders/all","orders/batch"]}},fees:{trading:{tierBased:!0,percentage:!0,taker:.15/100,maker:.1/100,tiers:{taker:[[0,.15/100],[100,.13/100],[250,.13/100],[1e3,.1/100],[5e3,.09/100],[1e4,.075/100],[2e4,.065/100]],maker:[[0,.1/100],[100,.1/100],[250,.09/100],[1e3,.075/100],[5e3,.06/100],[1e4,.05/100],[2e4,.05/100]]}}},precisionMode:uF,requiredCredentials:{apiKey:!0,secret:!1},exceptions:{exact:{insufficient_margin:aF,order_size_exceed_available:Tc,risk_limits_breached:GS,invalid_contract:oF,immediate_liquidation:Tc,out_of_bankruptcy:Tc,self_matching_disrupted_post_only:Tc,immediate_execution_post_only:Tc,bad_schema:GS,invalid_api_key:US,invalid_signature:US,open_order_not_found:dF,unavailable:cF},broad:{}}})}async fetchTime(e={}){const t=await this.publicGetSettings(e),s=this.safeValue(t,"result",{});return this.safeIntegerProduct(s,"server_time",.001)}async fetchStatus(e={}){const t=await this.publicGetSettings(e),s=this.safeValue(t,"result",{}),n=this.safeString(s,"under_maintenance")==="true"?"maintenance":"ok",r=this.safeIntegerProduct(s,"server_time",.001,this.milliseconds());return{status:n,updated:r,eta:void 0,url:void 0,info:t}}async fetchCurrencies(e={}){const t=await this.publicGetAssets(e),s=this.safeValue(t,"result",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeInteger(r,"id"),d=this.safeCurrencyCode(a),c=this.safeString(r,"deposit_status"),u=this.safeString(r,"withdrawal_status"),h=c==="enabled",l=u==="enabled",p=h&&l;i[d]={id:a,numericId:o,code:d,name:this.safeString(r,"name"),info:r,active:p,deposit:h,withdraw:l,fee:this.safeNumber(r,"base_withdrawal_fee"),precision:this.parseNumber(this.parsePrecision(this.safeString(r,"precision"))),limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.safeNumber(r,"min_withdrawal_amount"),max:void 0}}}}return i}async loadMarkets(e=!1,t={}){const s=await super.loadMarkets(e,t);return(this.safeValue(this.options,"currenciesByNumericId")===void 0||e)&&(this.options.currenciesByNumericId=this.indexBy(this.currencies,"numericId")),(this.safeValue(this.options,"marketsByNumericId")===void 0||e)&&(this.options.marketsByNumericId=this.indexBy(this.markets,"numericId")),s}async fetchMarkets(e={}){const t=await this.publicGetProducts(e),s=this.safeValue(t,"result",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n];let a=this.safeString(r,"contract_type");const o=this.safeValue(r,"quoting_asset",{}),d=this.safeValue(r,"underlying_asset",{}),c=this.safeValue(r,"settling_asset"),u=this.safeValue(r,"product_specs",{}),h=this.safeString(d,"symbol"),l=this.safeString(o,"symbol"),p=this.safeString(c,"symbol"),m=this.safeString(r,"symbol"),g=this.safeInteger(r,"id"),y=this.safeCurrencyCode(h),b=this.safeCurrencyCode(l),w=this.safeCurrencyCode(p),k=a==="call_options",T=a==="put_options",O=a==="move_options",x=a==="spot",C=a==="perpetual_futures",E=a==="futures",P=k||T||O,_=this.safeString(r,"strike_price"),S=this.safeString(r,"settlement_time"),I=this.parse8601(S),v=this.safeNumber(r,"contract_value");let N;x?N=this.parseNumber(this.parsePrecision(this.safeString(u,"underlying_precision"))):N=this.parseNumber("1");const q=w===y;let R,G=y+"/"+b;if(C||E||P)if(G=G+":"+w,E||P)if(G=G+"-"+this.yymmdd(I),P){a="option";let A="C";R="call",T?(A="P",R="put"):O&&(A="M",R="move"),G=G+":"+_+":"+A}else a="future";else a="swap";else G=m;const F=this.safeString(r,"state");i.push({id:m,numericId:g,symbol:G,base:y,quote:b,settle:w,baseId:h,quoteId:l,settleId:p,type:a,spot:x,margin:x?void 0:!1,swap:C,future:E,option:P,active:F==="live",contract:!x,linear:x?void 0:q,inverse:x?void 0:!q,taker:this.safeNumber(r,"taker_commission_rate"),maker:this.safeNumber(r,"maker_commission_rate"),contractSize:v,expiry:I,expiryDatetime:S,strike:this.parseNumber(_),optionType:R,precision:{amount:N,price:this.safeNumber(r,"tick_size")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.parseNumber("1"),max:this.safeNumber(r,"position_size_limit")},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(r,"min_size"),max:void 0}},info:r})}return i}parseTicker(e,t=void 0){const s=this.safeIntegerProduct(e,"timestamp",.001),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.safeString(e,"close"),a=this.safeString(e,"open"),o=this.safeString(e,"volume"),d=this.safeString(e,"turnover");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:a,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:o,quoteVolume:d,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetTickersSymbol(this.extend(i,t)),r=this.safeValue(n,"result",{});return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTickers(t),i=this.safeValue(s,"result",[]),n={};for(let r=0;r<i.length;r++){const a=this.parseTicker(i[r]),o=a.symbol;n[o]=a}return this.filterByArray(n,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.depth=t);const r=await this.publicGetL2orderbookSymbol(this.extend(n,s)),a=this.safeValue(r,"result",{});return this.parseOrderBook(a,i.symbol,void 0,"buy","sell","price","size")}parseTrade(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"order_id");let n=this.parse8601(this.safeString(e,"created_at"));n=this.safeIntegerProduct(e,"timestamp",.001,n);const r=this.safeString(e,"price"),a=this.safeString(e,"size"),o=this.safeValue(e,"product",{}),d=this.safeString(o,"symbol"),c=this.safeSymbol(d,t),u=this.safeString(e,"seller_role");let h=this.safeString(e,"side");h===void 0&&(u==="taker"?h="sell":u==="maker"&&(h="buy"));const l=this.safeString(e,"role"),p=this.safeValue(e,"meta_data",{});let m=this.safeString(p,"order_type");m!==void 0&&(m=m.replace("_order",""));const g=this.safeString(e,"commission");let y;if(g!==void 0){const b=this.safeValue(o,"settling_asset",{}),w=this.safeString(b,"symbol"),k=this.safeCurrencyCode(w);y={cost:g,currency:k}}return this.safeTrade({id:s,order:i,timestamp:n,datetime:this.iso8601(n),symbol:c,type:m,side:h,price:r,amount:a,cost:void 0,takerOrMaker:l,fee:y,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.publicGetTradesSymbol(this.extend(r,i)),o=this.safeValue(a,"result",[]);return this.parseTrades(o,n,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"time"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,resolution:this.timeframes[t]},o=this.parseTimeframe(t);if(i=i||2e3,s===void 0){const u=this.seconds();a.end=u,a.start=u-i*o}else{const u=parseInt(s/1e3);a.start=u,a.end=this.sum(u,i*o)}const d=await this.publicGetHistoryCandles(this.extend(a,n)),c=this.safeValue(d,"result",[]);return this.parseOHLCVs(c,r,t,s,i)}parseBalance(e){const t=this.safeValue(e,"result",[]),s={info:e},i=this.safeValue(this.options,"currenciesByNumericId",{});for(let n=0;n<t.length;n++){const r=t[n],a=this.safeString(r,"asset_id"),o=this.safeValue(i,a),d=o===void 0?a:o.code,c=this.account();c.total=this.safeString(r,"balance"),c.free=this.safeString(r,"available_balance"),s[d]=c}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetWalletBalances(e);return this.parseBalance(t)}async fetchPosition(e,t={}){await this.loadMarkets();const i={product_id:this.market(e).numericId},n=await this.privateGetPositions(this.extend(i,t));return this.safeValue(n,"result",{})}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetPositionsMargined(t);return this.safeValue(s,"result",[])}parseOrderStatus(e){const t={open:"open",pending:"open",closed:"closed",cancelled:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"client_order_id"),n=this.parse8601(this.safeString(e,"created_at")),r=this.safeString(e,"product_id"),a=this.safeValue(this.options,"marketsByNumericId",{});t=this.safeValue(a,r,t);const o=t===void 0?r:t.symbol,d=this.parseOrderStatus(this.safeString(e,"state")),c=this.safeString(e,"side");let u=this.safeString(e,"order_type");u=u.replace("_order","");const h=this.safeString(e,"limit_price"),l=this.safeString(e,"size"),p=this.safeString(e,"unfilled_size"),m=this.safeString(e,"average_fill_price");let g;const y=this.safeString(e,"paid_commission");if(y!==void 0){let b;if(t!==void 0){const w=this.safeValue(t.info,"settling_asset",{}),k=this.safeString(w,"symbol");b=this.safeCurrencyCode(k)}g={cost:y,currency:b}}return this.safeOrder({info:e,id:s,clientOrderId:i,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,symbol:o,type:u,side:c,price:h,amount:l,cost:void 0,average:m,filled:void 0,remaining:p,status:d,fee:g,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=t+"_order",o=this.market(e),d={product_id:o.numericId,size:this.amountToPrecision(o.symbol,i),side:s,order_type:a};t==="limit"&&(d.limit_price=this.priceToPrecision(o.symbol,n));const c=this.safeString2(r,"clientOrderId","client_order_id");r=this.omit(r,["clientOrderId","client_order_id"]),c!==void 0&&(d.client_order_id=c);const u=await this.privatePostOrders(this.extend(d,r)),h=this.safeValue(u,"result",{});return this.parseOrder(h,o)}async editOrder(e,t,s,i,n,r=void 0,a={}){await this.loadMarkets();const o=this.market(t),d={id:parseInt(e),product_id:o.numericId};n!==void 0&&(d.size=parseInt(this.amountToPrecision(t,n))),r!==void 0&&(d.limit_price=this.priceToPrecision(t,r));const c=await this.privatePutOrders(this.extend(d,a)),u=this.safeValue(c,"result");return this.parseOrder(u,o)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new $S(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={id:parseInt(e),product_id:i.numericId},r=await this.privateDeleteOrders(this.extend(n,s)),a=this.safeValue(r,"result");return this.parseOrder(a,i)}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new $S(this.id+" cancelAllOrders() requires a symbol argument");await this.loadMarkets();const i={product_id:this.market(e).numericId};return this.privateDeleteOrdersAll(this.extend(i,t))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersWithMethod("privateGetOrders",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersWithMethod("privateGetOrdersHistory",e,t,s,i)}async fetchOrdersWithMethod(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a;t!==void 0&&(a=this.market(t),r.product_ids=a.numericId),s!==void 0&&(r.start_time=s.toString()+"000"),i!==void 0&&(r.page_size=i);const o=await this[e](this.extend(r,n)),d=this.safeValue(o,"result",[]);return this.parseOrders(d,a,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.product_ids=r.numericId),t!==void 0&&(n.start_time=t.toString()+"000"),s!==void 0&&(n.page_size=s);const a=await this.privateGetFills(this.extend(n,i)),o=this.safeValue(a,"result",[]);return this.parseTrades(o,r,t,s)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.asset_id=r.numericId),s!==void 0&&(n.page_size=s);const a=await this.privateGetWalletTransactions(this.extend(n,i)),o=this.safeValue(a,"result",[]);return this.parseLedger(o,r,t,s)}parseLedgerEntryType(e){const t={pnl:"pnl",deposit:"transaction",withdrawal:"transaction",commission:"fee",conversion:"trade",referral_bonus:"referral",commission_rebate:"rebate"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"uuid");let i;const n=void 0,r=this.safeValue(e,"meta_data",{}),a=this.safeString(r,"transaction_id"),o=void 0;let d=this.safeString(e,"transaction_type");d==="deposit"||d==="commission_rebate"||d==="referral_bonus"||d==="pnl"||d==="withdrawal_cancellation"||d==="promo_credit"?i="in":(d==="withdrawal"||d==="commission"||d==="conversion"||d==="perpetual_futures_funding")&&(i="out"),d=this.parseLedgerEntryType(d);const c=this.safeInteger(e,"asset_id"),u=this.safeValue(this.options,"currenciesByNumericId");t=this.safeValue(u,c,t);const h=t===void 0?void 0:t.code,l=this.safeNumber(e,"amount"),p=this.parse8601(this.safeString(e,"created_at")),m=this.safeNumber(e,"balance"),g=Math.max(0,m-l);return{info:e,id:s,direction:i,account:n,referenceId:a,referenceAccount:o,type:d,currency:h,amount:l,before:g,after:m,status:"ok",timestamp:p,datetime:this.iso8601(p),fee:void 0}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={asset_symbol:this.currency(e).id},n=await this.privateGetDepositsAddress(this.extend(i,t)),r=this.safeValue(n,"result",{}),a=this.safeString(r,"address");return this.checkAddress(a),{currency:e,address:a,tag:void 0,network:void 0,info:n}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a="/"+this.version+"/"+this.implodeParams(e,i);let o=this.urls.api[t]+a;const d=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(d).length&&(o+="?"+this.urlencode(d));else if(t==="private"){this.checkRequiredCredentials();const c=this.seconds().toString();n={"api-key":this.apiKey,timestamp:c};let u=s+c+a;if(s==="GET"||s==="DELETE"){if(Object.keys(d).length){const l="?"+this.urlencode(d);u+=l,o+=l}}else r=this.json(d),u+=r,n["Content-Type"]="application/json";const h=this.hmac(this.encode(u),this.encode(this.secret));n.signature=h}return{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeValue(a,"error",{}),u=this.safeString(c,"code");if(u!==void 0){const h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwBroadlyMatchedException(this.exceptions.broad,u,h),new rF(h)}}};const hF=ge,{TICK_SIZE:lF}=me,{AuthenticationError:oi,ExchangeError:ns,ArgumentsRequired:Oc,PermissionDenied:en,InvalidOrder:wt,OrderNotFound:I0,DDoSProtection:Ic,NotSupported:pF,ExchangeNotAvailable:mF,InsufficientFunds:gF,BadRequest:Ms,InvalidAddress:x0,OnMaintenance:jS}=de,tn=Se;var K_=class extends hF{describe(){return this.deepExtend(super.describe(),{id:"deribit",name:"Deribit",countries:["NL"],version:"v2",userAgent:void 0,rateLimit:50,pro:!0,has:{CORS:!0,spot:!1,margin:!1,swap:!0,future:!0,option:!0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!1,createDepositAddress:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchDeposit:!1,fetchDepositAddress:!0,fetchDeposits:!0,fetchHistoricalVolatility:!0,fetchIndexOHLCV:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:void 0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:void 0,fetchTransfer:!1,fetchTransfers:!0,fetchWithdrawal:!1,fetchWithdrawals:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"1","3m":"3","5m":"5","10m":"10","15m":"15","30m":"30","1h":"60","2h":"120","3h":"180","6h":"360","12h":"720","1d":"1D"},urls:{test:{rest:"https://test.deribit.com"},logo:"https://user-images.githubusercontent.com/1294454/41933112-9e2dd65a-798b-11e8-8440-5bab2959fcb8.jpg",api:{rest:"https://www.deribit.com"},www:"https://www.deribit.com",doc:["https://docs.deribit.com/v2","https://github.com/deribit"],fees:"https://www.deribit.com/pages/information/fees",referral:{url:"https://www.deribit.com/reg-1189.4038",discount:.1}},api:{public:{get:{auth:1,exchange_token:1,fork_token:1,set_heartbeat:1,disable_heartbeat:1,get_time:1,hello:1,status:1,test:1,subscribe:1,unsubscribe:1,unsubscribe_all:1,get_announcements:1,get_book_summary_by_currency:1,get_book_summary_by_instrument:1,get_contract_size:1,get_currencies:1,get_delivery_prices:1,get_funding_chart_data:1,get_funding_rate_history:1,get_funding_rate_value:1,get_historical_volatility:1,get_index:1,get_index_price:1,get_index_price_names:1,get_instrument:1,get_instruments:1,get_last_settlements_by_currency:1,get_last_settlements_by_instrument:1,get_last_trades_by_currency:1,get_last_trades_by_currency_and_time:1,get_last_trades_by_instrument:1,get_last_trades_by_instrument_and_time:1,get_mark_price_history:1,get_order_book:1,get_trade_volumes:1,get_tradingview_chart_data:1,get_volatility_index_data:1,ticker:1}},private:{get:{logout:1,enable_cancel_on_disconnect:1,disable_cancel_on_disconnect:1,get_cancel_on_disconnect:1,subscribe:1,unsubscribe:1,unsubscribe_all:1,change_api_key_name:1,change_scope_in_api_key:1,change_subaccount_name:1,create_api_key:1,create_subaccount:1,disable_api_key:1,disable_tfa_for_subaccount:1,enable_affiliate_program:1,enable_api_key:1,get_access_log:1,get_account_summary:1,get_affiliate_program_info:1,get_email_language:1,get_new_announcements:1,get_portfolio_margins:1,get_position:1,get_positions:1,get_subaccounts:1,get_subaccounts_details:1,get_transaction_log:1,list_api_keys:1,remove_api_key:1,remove_subaccount:1,reset_api_key:1,set_announcement_as_read:1,set_api_key_as_default:1,set_email_for_subaccount:1,set_email_language:1,set_password_for_subaccount:1,toggle_notifications_from_subaccount:1,toggle_subaccount_login:1,execute_block_trade:4,get_block_trade:1,get_last_block_trades_by_currency:1,invalidate_block_trade_signature:1,verify_block_trade:4,buy:4,sell:4,edit:4,edit_by_label:4,cancel:4,cancel_all:4,cancel_all_by_currency:4,cancel_all_by_instrument:4,cancel_by_label:4,close_position:4,get_margins:1,get_mmp_config:1,get_open_orders_by_currency:1,get_open_orders_by_instrument:1,get_order_history_by_currency:1,get_order_history_by_instrument:1,get_order_margin_by_ids:1,get_order_state:1,get_stop_order_history:1,get_trigger_order_history:1,get_user_trades_by_currency:1,get_user_trades_by_currency_and_time:1,get_user_trades_by_instrument:1,get_user_trades_by_instrument_and_time:1,get_user_trades_by_order:1,reset_mmp:1,set_mmp_config:1,get_settlement_history_by_instrument:1,get_settlement_history_by_currency:1,cancel_transfer_by_id:1,cancel_withdrawal:1,create_deposit_address:1,get_current_deposit_address:1,get_deposits:1,get_transfers:1,get_withdrawals:1,submit_transfer_to_subaccount:1,submit_transfer_to_user:1,withdraw:1}}},exceptions:{9999:en,1e4:oi,10001:ns,10002:wt,10003:wt,10004:I0,10005:wt,10006:wt,10007:wt,10008:wt,10009:gF,10010:I0,10011:wt,10012:wt,10013:en,10014:en,10015:en,10016:en,10017:en,10018:en,10019:en,10020:ns,10021:wt,10022:wt,10023:wt,10024:wt,10025:wt,10026:wt,10027:wt,10028:Ic,10029:I0,10030:ns,10031:ns,10032:wt,10033:pF,10034:wt,10035:wt,10036:wt,10040:mF,10041:jS,10043:wt,10044:wt,10045:wt,10046:wt,10047:Ic,10048:ns,11008:wt,11029:Ms,11030:ns,11031:ns,11035:Ic,11036:wt,11037:Ms,11038:wt,11039:wt,11041:wt,11042:en,11043:Ms,11044:wt,11045:Ms,11046:Ms,11047:Ms,11048:ns,11049:Ms,11050:Ms,11051:jS,11052:ns,11053:ns,11090:x0,11091:x0,11092:x0,11093:Ic,11094:ns,11095:ns,11096:ns,12e3:oi,12001:Ic,12002:ns,12998:oi,12003:oi,12004:oi,12005:oi,12100:ns,12999:oi,13e3:oi,13001:oi,13002:en,13003:oi,13004:oi,13005:oi,13006:oi,13007:oi,13008:ns,13009:oi,13010:Ms,13011:Ms,13012:en,13013:Ms,13014:Ms,13015:Ms,13016:Ms,13017:ns,13018:ns,13019:ns,13020:ns,13021:en,13025:ns,"-32602":Ms,"-32601":Ms,"-32700":Ms,"-32000":Ms,11054:wt},precisionMode:lF,options:{code:"BTC",fetchBalance:{code:"BTC"},fetchPositions:{code:"BTC"},transfer:{method:"privateGetSubmitTransferToSubaccount"}}})}async fetchTime(e={}){const t=await this.publicGetGetTime(e);return this.safeInteger(t,"result")}codeFromOptions(e,t={}){const s=this.safeValue(this.options,"code","BTC"),i=this.safeValue(this.options,e,{}),n=this.safeValue(i,"code",s);return this.safeValue(t,"code",n)}async fetchStatus(e={}){const t=await this.publicGetStatus(e),s=this.safeValue(t,"result"),i=this.safeString(s,"locked"),n=this.safeIntegerProduct(t,"usIn",.001,this.milliseconds());return{status:i==="false"?"ok":"maintenance",updated:n,eta:void 0,url:void 0,info:t}}async fetchAccounts(e={}){await this.loadMarkets();const t=await this.privateGetGetSubaccounts(e),s=this.safeValue(t,"result",[]);return this.parseAccounts(s)}parseAccount(e,t=void 0){return{info:e,id:this.safeString(e,"id"),type:this.safeString(e,"type"),code:this.safeCurrencyCode(void 0,t)}}async fetchMarkets(e={}){const t=await this.publicGetGetCurrencies(e),s=this.safeValue(t,"result",[]),i=[];for(let n=0;n<s.length;n++){const a={currency:this.safeString(s[n],"currency")},o=await this.publicGetGetInstruments(this.extend(a,e)),d=this.safeValue(o,"result",[]);for(let c=0;c<d.length;c++){const u=d[c],h=this.safeString(u,"instrument_name"),l=this.safeString(u,"base_currency"),p=this.safeString(u,"counter_currency"),m=this.safeString(u,"settlement_currency"),g=this.safeCurrencyCode(l),y=this.safeCurrencyCode(p),b=this.safeCurrencyCode(m),w=this.safeString(u,"kind"),T=this.safeValue(u,"settlement_period")==="perpetual",O=!T&&w.indexOf("future")>=0,x=w.indexOf("option")>=0,C=w.indexOf("combo")>=0,E=this.safeInteger(u,"expiration_timestamp");let P,_,S=h,I="swap";if(O?I="future":x&&(I="option"),!C&&(S=g+"/"+y+":"+b,(x||O)&&(S=S+"-"+this.yymmdd(E,""),x))){P=this.safeNumber(u,"strike"),_=this.safeString(u,"option_type");const q=_==="call"?"C":"P";S=S+"-"+this.numberToString(P)+"-"+q}const v=this.safeNumber(u,"min_trade_amount"),N=this.safeNumber(u,"tick_size");i.push({id:h,symbol:S,base:g,quote:y,settle:b,baseId:l,quoteId:p,settleId:m,type:I,spot:!1,margin:!1,swap:T,future:O,option:x,active:this.safeValue(u,"is_active"),contract:!0,linear:b===y,inverse:b!==y,taker:this.safeNumber(u,"taker_commission"),maker:this.safeNumber(u,"maker_commission"),contractSize:this.safeNumber(u,"contract_size"),expiry:E,expiryDatetime:this.iso8601(E),strike:P,optionType:_,precision:{amount:v,price:N},limits:{leverage:{min:void 0,max:void 0},amount:{min:v,max:void 0},price:{min:N,max:void 0},cost:{min:void 0,max:void 0}},info:u})}}return i}parseBalance(e){const t={info:e},s=this.safeString(e,"currency"),i=this.safeCurrencyCode(s),n=this.account();return n.free=this.safeString(e,"available_funds"),n.used=this.safeString(e,"maintenance_margin"),n.total=this.safeString(e,"equity"),t[i]=n,this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=this.codeFromOptions("fetchBalance",e),i={currency:this.currency(t).id},n=await this.privateGetGetAccountSummary(this.extend(i,e)),r=this.safeValue(n,"result",{});return this.parseBalance(r)}async createDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.privateGetCreateDepositAddress(this.extend(i,t)),r=this.safeValue(n,"result",{}),a=this.safeString(r,"address");return this.checkAddress(a),{currency:e,address:a,tag:void 0,info:n}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.privateGetGetCurrentDepositAddress(this.extend(i,t)),r=this.safeValue(n,"result",{}),a=this.safeString(r,"address");return this.checkAddress(a),{currency:e,address:a,tag:void 0,network:void 0,info:n}}parseTicker(e,t=void 0){const s=this.safeInteger2(e,"timestamp","creation_timestamp"),i=this.safeString(e,"instrument_name"),n=this.safeSymbol(i,t),r=this.safeString2(e,"last_price","last"),a=this.safeValue(e,"stats",e);return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString2(a,"high","max_price"),low:this.safeString2(a,"low","min_price"),bid:this.safeString2(e,"best_bid_price","bid_price"),bidVolume:this.safeString(e,"best_bid_amount"),ask:this.safeString2(e,"best_ask_price","ask_price"),askVolume:this.safeString(e,"best_ask_amount"),vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:this.safeString(a,"volume"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={instrument_name:s.id},n=await this.publicGetTicker(this.extend(i,t)),r=this.safeValue(n,"result");return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.codeFromOptions("fetchTickers",t),n={currency:this.currency(s).id},r=await this.publicGetGetBookSummaryByCurrency(this.extend(n,t)),a=this.safeValue(r,"result",[]),o={};for(let d=0;d<a.length;d++){const c=this.parseTicker(a[d]),u=c.symbol;o[u]=c}return this.filterByArray(o,"symbol",e)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={instrument_name:r.id,resolution:this.timeframes[t]},o=this.parseTimeframe(t),d=this.milliseconds();s===void 0?(i===void 0&&(i=1e3),a.start_timestamp=d-(i-1)*o*1e3,a.end_timestamp=d):(a.start_timestamp=s,i===void 0?a.end_timestamp=d:a.end_timestamp=this.sum(s,i*o*1e3));const c=await this.publicGetGetTradingviewChartData(this.extend(a,n)),u=this.safeValue(c,"result",{}),h=this.convertTradingViewToOHLCV(u,"ticks","open","high","low","close","volume",!0);return this.parseOHLCVs(h,r,t,s,i)}parseTrade(e,t=void 0){const s=this.safeString(e,"trade_id"),i=this.safeString(e,"instrument_name"),n=this.safeSymbol(i,t),r=this.safeInteger(e,"timestamp"),a=this.safeString(e,"direction"),o=this.safeString(e,"price"),d=this.safeString(e,"amount");let c=tn.stringMul(d,o);t.inverse&&(c=tn.stringDiv(d,o));const u=this.safeString(e,"liquidity");let h;u!==void 0&&(h=u==="M"?"maker":"taker");const l=this.safeString(e,"fee");let p;if(l!==void 0){const m=this.safeString(e,"fee_currency"),g=this.safeCurrencyCode(m);p={cost:l,currency:g}}return this.safeTrade({id:s,info:e,timestamp:r,datetime:this.iso8601(r),symbol:n,order:this.safeString(e,"order_id"),type:this.safeString(e,"order_type"),side:a,takerOrMaker:h,price:o,amount:d,cost:c,fee:p},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={instrument_name:n.id,include_old:!0},a=t===void 0?"publicGetGetLastTradesByInstrument":"publicGetGetLastTradesByInstrumentAndTime";t!==void 0&&(r.start_timestamp=t),s!==void 0&&(r.count=s);const o=await this[a](this.extend(r,i)),d=this.safeValue(o,"result",{}),c=this.safeValue(d,"trades",[]);return this.parseTrades(c,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=this.codeFromOptions("fetchTradingFees",e),i={currency:this.currency(t).id,extended:!0},n=await this.privateGetGetAccountSummary(this.extend(i,e)),r=this.safeValue(n,"result",{}),a=this.safeValue(r,"fees",[]);let o={},d={},c={};for(let h=0;h<a.length;h++){const l=a[h],p=this.safeString(l,"instrument_type");p==="future"?d={info:l,maker:this.safeNumber(l,"maker_fee"),taker:this.safeNumber(l,"taker_fee")}:p==="perpetual"?o={info:l,maker:this.safeNumber(l,"maker_fee"),taker:this.safeNumber(l,"taker_fee")}:p==="option"&&(c={info:l,maker:this.safeNumber(l,"maker_fee"),taker:this.safeNumber(l,"taker_fee")})}const u={};for(let h=0;h<this.symbols.length;h++){const l=this.symbols[h],p=this.market(l);let m={info:p,symbol:l,percentage:!0,tierBased:!0,maker:p.maker,taker:p.taker};p.swap?m=this.extend(m,o):p.future?m=this.extend(m,d):p.option&&(m=this.extend(m,c)),u[l]=m}return u}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={instrument_name:i.id};t!==void 0&&(n.depth=t);const r=await this.publicGetGetOrderBook(this.extend(n,s)),a=this.safeValue(r,"result",{}),o=this.safeInteger(a,"timestamp"),d=this.safeInteger(a,"change_id"),c=this.parseOrderBook(a,i.symbol,o);return c.nonce=d,c}parseOrderStatus(e){const t={open:"open",cancelled:"canceled",filled:"closed",rejected:"rejected",untriggered:"open"};return this.safeString(t,e,e)}parseTimeInForce(e){const t={good_til_cancelled:"GTC",fill_or_kill:"FOK",immediate_or_cancel:"IOC"};return this.safeString(t,e,e)}parseOrderType(e){const t={stop_limit:"limit",take_limit:"limit",stop_market:"market",take_market:"market"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"instrument_name");t=this.safeMarket(s,t);const i=this.safeInteger(e,"creation_timestamp"),n=this.safeInteger(e,"last_update_timestamp"),r=this.safeString(e,"order_id"),a=this.safeString(e,"price"),o=this.safeString(e,"average_price"),d=this.safeString(e,"filled_amount"),c=this.safeString(e,"amount");let u=tn.stringMul(d,o);t.inverse&&this.parseNumber(o)!==0&&(u=tn.stringDiv(c,o));let h;d!==void 0&&tn.stringGt(d,"0")&&(h=n);const l=this.parseOrderStatus(this.safeString(e,"order_state")),p=this.safeStringLower(e,"direction");let m=this.safeString(e,"commission"),g;m!==void 0&&(m=tn.stringAbs(m),g={cost:m,currency:t.base});const y=this.safeString(e,"order_type"),b=this.parseOrderType(y),w=this.safeValue(e,"trades"),k=this.parseTimeInForce(this.safeString(e,"time_in_force")),T=this.safeValue(e,"stop_price"),O=this.safeValue(e,"post_only");return this.safeOrder({info:e,id:r,clientOrderId:void 0,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:h,symbol:t.symbol,type:b,timeInForce:k,postOnly:O,side:p,price:a,stopPrice:T,amount:c,cost:u,average:o,filled:d,remaining:void 0,status:l,fee:g,trades:w},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privateGetGetOrderState(this.extend(i,s)),r=this.safeValue(n,"result");return this.parseOrder(r)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);a.inverse?i=this.amountToPrecision(e,i):i=this.currencyToPrecision(e,i);const o={instrument_name:a.id,amount:i,type:t},d=this.safeStringUpper(r,"timeInForce"),c=this.safeValue2(r,"reduceOnly","reduce_only"),u=this.safeValue(r,"stopLossPrice"),h=this.safeValue(r,"takeProfitPrice"),l=t==="stop_limit",p=t==="stop_market",m=t==="take_limit",g=t==="take_market",y=l||p||u!==void 0,b=m||g||h!==void 0;if(y&&b)throw new wt(this.id+" createOrder () only allows one of stopLossPrice or takeProfitPrice to be specified");const w=y||b,k=t==="limit"||l||m,T=t==="market"||p||g,O=this.safeValue(r,"post_only"),x=this.isPostOnly(T,O,r);if(k?(o.type="limit",o.price=this.priceToPrecision(e,n)):o.type="market",w){const I=u!==void 0?u:h;o.trigger_price=this.priceToPrecision(e,I),o.trigger="last_price",y?T?o.type="stop_market":o.type="stop_limit":T?o.type="take_market":o.type="take_limit"}c&&(o.reduce_only=!0),x&&(o.post_only=!0,o.reject_post_only=!0),d!==void 0&&(d==="GTC"&&(o.time_in_force="good_til_cancelled"),d==="IOC"&&(o.time_in_force="immediate_or_cancel"),d==="FOK"&&(o.time_in_force="fill_or_kill"));const C="privateGet"+this.capitalize(s);r=this.omit(r,["timeInForce","stopLossPrice","takeProfitPrice","postOnly","reduceOnly"]);const E=await this[C](this.extend(o,r)),P=this.safeValue(E,"result",{}),_=this.safeValue(P,"order"),S=this.safeValue(P,"trades",[]);return _.trades=S,this.parseOrder(_,a)}async editOrder(e,t,s,i,n=void 0,r=void 0,a={}){if(n===void 0)throw new Oc(this.id+" editOrder() requires an amount argument");if(r===void 0)throw new Oc(this.id+" editOrder() requires a price argument");await this.loadMarkets();const o={order_id:e,amount:this.amountToPrecision(t,n),price:this.priceToPrecision(t,r)},d=await this.privateGetEdit(this.extend(o,a)),c=this.safeValue(d,"result",{}),u=this.safeValue(c,"order"),h=this.safeValue(c,"trades",[]);return u.trades=h,this.parseOrder(u)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privateGetCancel(this.extend(i,s)),r=this.safeValue(n,"result",{});return this.parseOrder(r)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;if(e===void 0)i="privateGetCancelAll";else{i="privateGetCancelAllByInstrument";const r=this.market(e);s.instrument_name=r.id}return await this[i](this.extend(s,t))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r,a;if(e===void 0){const c=this.codeFromOptions("fetchOpenOrders",i),u=this.currency(c);n.currency=u.id,a="privateGetGetOpenOrdersByCurrency"}else r=this.market(e),n.instrument_name=r.id,a="privateGetGetOpenOrdersByInstrument";const o=await this[a](this.extend(n,i)),d=this.safeValue(o,"result",[]);return this.parseOrders(d,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r,a;if(e===void 0){const c=this.codeFromOptions("fetchClosedOrders",i),u=this.currency(c);n.currency=u.id,a="privateGetGetOrderHistoryByCurrency"}else r=this.market(e),n.instrument_name=r.id,a="privateGetGetOrderHistoryByInstrument";const o=await this[a](this.extend(n,i)),d=this.safeValue(o,"result",[]);return this.parseOrders(d,r,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={order_id:e},a=await this.privateGetGetUserTradesByOrder(this.extend(r,n)),o=this.safeValue(a,"result",{});return this.parseTrades(o,void 0,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={include_old:!0};let r,a;if(e===void 0){const u=this.codeFromOptions("fetchMyTrades",i),h=this.currency(u);n.currency=h.id,t===void 0?a="privateGetGetUserTradesByCurrency":(a="privateGetGetUserTradesByCurrencyAndTime",n.start_timestamp=t)}else r=this.market(e),n.instrument_name=r.id,t===void 0?a="privateGetGetUserTradesByInstrument":(a="privateGetGetUserTradesByInstrumentAndTime",n.start_timestamp=t);s!==void 0&&(n.count=s);const o=await this[a](this.extend(n,i)),d=this.safeValue(o,"result",{}),c=this.safeValue(d,"trades",[]);return this.parseTrades(c,r,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Oc(this.id+" fetchDeposits() requires a currency code argument");await this.loadMarkets();const n=this.currency(e),r={currency:n.id};s!==void 0&&(r.count=s);const a=await this.privateGetGetDeposits(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"data",[]);return this.parseTransactions(d,n,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Oc(this.id+" fetchWithdrawals() requires a currency code argument");await this.loadMarkets();const n=this.currency(e),r={currency:n.id};s!==void 0&&(r.count=s);const a=await this.privateGetGetWithdrawals(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"data",[]);return this.parseTransactions(d,n,t,s,i)}parseTransactionStatus(e){const t={completed:"ok",unconfirmed:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"currency"),i=this.safeCurrencyCode(s,t),n=this.safeInteger2(e,"created_timestamp","received_timestamp"),r=this.safeInteger(e,"updated_timestamp"),a=this.parseTransactionStatus(this.safeString(e,"state")),o=this.safeString(e,"address"),d=this.safeNumber(e,"fee");let c="deposit",u;return d!==void 0&&(c="withdrawal",u={cost:d,currency:i}),{info:e,id:this.safeString(e,"id"),txid:this.safeString(e,"transaction_id"),timestamp:n,datetime:this.iso8601(n),address:o,addressTo:o,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:c,amount:this.safeNumber(e,"amount"),currency:i,status:a,updated:r,fee:u}}parsePosition(e,t=void 0){const s=this.safeString(e,"instrument_name");t=this.safeMarket(s,t);let i=this.safeString(e,"direction");i=i==="buy"?"long":"short";const n=this.safeString(e,"floating_profit_loss"),r=this.safeString(e,"initial_margin"),a=this.safeString(e,"size_currency"),o=this.safeString(e,"maintenance_margin"),d=tn.stringMul(tn.stringDiv(n,r),"100"),c=this.milliseconds();return{info:e,id:void 0,symbol:this.safeString(t,"symbol"),timestamp:c,datetime:this.iso8601(c),initialMargin:this.parseNumber(r),initialMarginPercentage:this.parseNumber(tn.stringMul(tn.stringDiv(r,a),"100")),maintenanceMargin:this.parseNumber(o),maintenanceMarginPercentage:this.parseNumber(tn.stringMul(tn.stringDiv(o,a),"100")),entryPrice:this.safeNumber(e,"average_price"),notional:this.parseNumber(a),leverage:this.safeInteger(e,"leverage"),unrealizedPnl:this.parseNumber(n),contracts:void 0,contractSize:this.safeNumber(t,"contractSize"),marginRatio:void 0,liquidationPrice:this.safeNumber(e,"estimated_liquidation_price"),markPrice:this.safeNumber(e,"mark_price"),collateral:void 0,marginMode:void 0,side:i,percentage:this.parseNumber(d)}}async fetchPosition(e,t={}){await this.loadMarkets();const i={instrument_name:this.market(e).id},n=await this.privateGetGetPosition(this.extend(i,t)),r=this.safeValue(n,"result");return this.parsePosition(r)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();let s;if(e===void 0)s=this.codeFromOptions("fetchPositions",t);else if(typeof e=="string")s=e,e=void 0;else if(Array.isArray(e)){if(e.length!==1)throw new Ms(this.id+" fetchPositions() symbols argument cannot contain more than 1 symbol");s=this.market(e[0]).base}const n={currency:this.currency(s).id},r=await this.privateGetGetPositions(this.extend(n,t)),a=this.safeValue(r,"result");return this.parsePositions(a,e)}async fetchHistoricalVolatility(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.publicGetGetHistoricalVolatility(this.extend(i,t)),r=this.safeValue(n,"result",{}),a=[];for(let o=0;o<r.length;o++){const d=this.safeInteger(r[o],0),c=this.safeNumber(r[o],1);a.push({info:n,timestamp:d,datetime:this.iso8601(d),volatility:c})}return a}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Oc(this.id+" fetchTransfers() requires a currency code argument");await this.loadMarkets();const n=this.currency(e),r={currency:n.id};s!==void 0&&(r.count=s);const a=await this.privateGetGetTransfers(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"data",[]);return this.parseTransfers(d,n,t,s,i)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a={amount:t,currency:r.id,destination:i};let o=this.safeString(n,"method");if(n=this.omit(n,"method"),o===void 0){const u=this.safeValue(this.options,"transfer",{});o=this.safeString(u,"method","privateGetSubmitTransferToSubaccount")}const d=await this[o](this.extend(a,n)),c=this.safeValue(d,"result",{});return this.parseTransfer(c,r)}parseTransfer(e,t=void 0){const s=this.safeTimestamp(e,"created_timestamp"),i=this.safeString(e,"state"),n=this.safeString(e,"other_side"),r=this.safeString(e,"direction"),a=this.safeString(e,"currency");return{info:e,id:this.safeString(e,"id"),status:this.parseTransferStatus(i),amount:this.safeNumber(e,"amount"),code:this.safeCurrencyCode(a,t),fromAccount:r!=="payment"?n:void 0,toAccount:r==="payment"?n:void 0,timestamp:s,datetime:this.iso8601(s)}}parseTransferStatus(e){const t={prepared:"pending",confirmed:"ok",cancelled:"cancelled",waiting_for_admin:"pending"};return this.safeString(t,e,e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,address:s,amount:t};this.twofa!==void 0&&(a.tfa=this.oath());const o=await this.privateGetWithdraw(this.extend(a,n));return this.parseTransaction(o,r)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/api/"+this.version+"/"+t+"/"+e;if(t==="public"&&Object.keys(i).length&&(a+="?"+this.urlencode(i)),t==="private"){this.checkRequiredCredentials();const d=this.nonce().toString(),c=this.milliseconds().toString(),u="";Object.keys(i).length&&(a+="?"+this.urlencode(i));const h=s+`
`+a+`
`+u+`
`,l=c+`
`+d+`
`+h,p=this.hmac(this.encode(l),this.encode(this.secret),"sha256");n={Authorization:"deri-hmac-sha256 id="+this.apiKey+",ts="+c+",sig="+p+",nonce="+d}}return{url:this.urls.api.rest+a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(!a)return;const c=this.safeValue(a,"error");if(c!==void 0){const u=this.safeString(c,"code"),h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions,u,h),new ns(h)}}};const yF=ge,{AccountSuspended:bF,BadRequest:Xs,BadResponse:wF,NetworkError:kF,NotSupported:SF,DDoSProtection:WS,AuthenticationError:zS,PermissionDenied:sn,ExchangeError:qf,InsufficientFunds:KS,InvalidOrder:Fo,InvalidNonce:vF,OrderNotFound:_0,InvalidAddress:C0,RateLimitExceeded:TF,BadSymbol:xc}=de,{TICK_SIZE:OF}=me,XS=Se;var IF=class extends yF{describe(){return this.deepExtend(super.describe(),{id:"digifinex",name:"DigiFinex",countries:["SG"],version:"v3",rateLimit:900,has:{CORS:void 0,spot:!0,margin:!0,swap:void 0,future:!1,option:!1,cancelOrder:!0,cancelOrders:!0,createOrder:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowInterest:!0,fetchBorrowRate:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchLedger:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransfers:!0,fetchWithdrawals:!0,setLeverage:!0,setMarginMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"1","5m":"5","15m":"15","30m":"30","1h":"60","4h":"240","12h":"720","1d":"1D","1w":"1W"},urls:{logo:"https://user-images.githubusercontent.com/51840849/87443315-01283a00-c5fe-11ea-8628-c2a0feaf07ac.jpg",api:{rest:"https://openapi.digifinex.com"},www:"https://www.digifinex.com",doc:["https://docs.digifinex.com"],fees:"https://digifinex.zendesk.com/hc/en-us/articles/360000328422-Fee-Structure-on-DigiFinex",referral:"https://www.digifinex.com/en-ww/from/DhOzBg?channelCode=ljaUPp"},api:{public:{spot:{get:["{market}/symbols","kline","margin/currencies","margin/symbols","markets","order_book","ping","spot/symbols","time","trades","trades/symbols","ticker","currencies"]},swap:{get:["public/api_weight","public/candles","public/candles_history","public/depth","public/funding_rate","public/funding_rate_history","public/instrument","public/instruments","public/ticker","public/tickers","public/time","public/trades"]}},private:{spot:{get:["{market}/financelog","{market}/mytrades","{market}/order","{market}/order/detail","{market}/order/current","{market}/order/history","margin/assets","margin/financelog","margin/mytrades","margin/order","margin/order/current","margin/order/history","margin/positions","otc/financelog","spot/assets","spot/financelog","spot/mytrades","spot/order","spot/order/current","spot/order/history","deposit/address","deposit/history","withdraw/history"],post:["{market}/order/cancel","{market}/order/new","{market}/order/batch_new","margin/order/cancel","margin/order/new","margin/position/close","spot/order/cancel","spot/order/new","transfer","withdraw/new","withdraw/cancel"]},swap:{get:["account/balance","account/positions","account/finance_record","account/trading_fee_rate","account/transfer_record","trade/history_orders","trade/history_trades","trade/open_orders","trade/order_info"],post:["account/leverage","trade/batch_cancel_order","trade/batch_order","trade/cancel_order","trade/order_place"]}}},fees:{trading:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},precisionMode:OF,exceptions:{exact:{10001:[Xs,"Wrong request method, please check it's a GET ot POST request"],10002:[zS,"Invalid ApiKey"],10003:[zS,"Sign doesn't match"],10004:[Xs,"Illegal request parameters"],10005:[WS,"Request frequency exceeds the limit"],10006:[sn,"Unauthorized to execute this request"],10007:[sn,"IP address Unauthorized"],10008:[vF,"Timestamp for this request is invalid, timestamp must within 1 minute"],10009:[kF,"Unexist endpoint, please check endpoint URL"],10011:[bF,"ApiKey expired. Please go to client side to re-create an ApiKey"],20001:[sn,"Trade is not open for this trading pair"],20002:[sn,"Trade of this trading pair is suspended"],20003:[Fo,"Invalid price or amount"],20007:[Fo,"Price precision error"],20008:[Fo,"Amount precision error"],20009:[Fo,"Amount is less than the minimum requirement"],20010:[Fo,"Cash Amount is less than the minimum requirement"],20011:[KS,"Insufficient balance"],20012:[Xs,"Invalid trade type, valid value: buy/sell)"],20013:[Fo,"No order info found"],20014:[Xs,"Invalid date, Valid format: 2018-07-25)"],20015:[Xs,"Date exceeds the limit"],20018:[sn,"Your trading rights have been banned by the system"],20019:[xc,'Wrong trading pair symbol. Correct format:"usdt_btc". Quote asset is in the front'],20020:[WS,"You have violated the API operation trading rules and temporarily forbid trading. At present, we have certain restrictions on the user's transaction rate and withdrawal rate."],5e4:[qf,"Exception error"],20021:[Xs,"Invalid currency"],20022:[Xs,"The ending timestamp must be larger than the starting timestamp"],20023:[Xs,"Invalid transfer type"],20024:[Xs,"Invalid amount"],20025:[Xs,"This currency is not transferable at the moment"],20026:[KS,"Transfer amount exceed your balance"],20027:[sn,"Abnormal account status"],20028:[sn,"Blacklist for transfer"],20029:[sn,"Transfer amount exceed your daily limit"],20030:[Xs,"You have no position on this trading pair"],20032:[sn,"Withdrawal limited"],20033:[Xs,"Wrong Withdrawal ID"],20034:[sn,"Withdrawal service of this crypto has been closed"],20035:[sn,"Withdrawal limit"],20036:[qf,"Withdrawal cancellation failed"],20037:[C0,"The withdrawal address, Tag or chain type is not included in the withdrawal management list"],20038:[C0,"The withdrawal address is not on the white list"],20039:[qf,"Can't be canceled in current status"],20040:[TF,"Withdraw too frequently; limitation: 3 times a minute, 100 times a day"],20041:[sn,"Beyond the daily withdrawal limit"],20042:[xc,"Current trading pair does not support API trading"],400002:[Xs,"Invalid Parameter"]},broad:{}},options:{defaultType:"spot",types:["spot","margin","otc"],accountsByType:{spot:"1",margin:"2",OTC:"3"}},commonCurrencies:{BHT:"Black House Test",EPS:"Epanus",FREE:"FreeRossDAO",MBN:"Mobilian Coin",TEL:"TEL666"}})}safeNetwork(e){if(e!==void 0)return e.toUpperCase()}async fetchCurrencies(e={}){const t=await this.publicSpotGetCurrencies(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.safeInteger(r,"deposit_status",1),c=this.safeInteger(r,"withdraw_status",1),u=d>0,h=c>0,l=u&&h,p=this.safeNumber(r,"min_withdraw_fee"),m=this.safeNumber(r,"min_withdraw_amount"),g=this.safeNumber(r,"min_deposit_amount"),y=this.safeString(r,"chain"),b={id:y,network:this.safeNetwork(y),name:void 0,active:l,fee:p,precision:this.parseNumber("0.00000001"),deposit:u,withdraw:h,limits:{amount:{min:void 0,max:void 0},withdraw:{min:m,max:void 0},deposit:{min:g,max:void 0}},info:r};o in i?(Array.isArray(i[o].info)?i[o].info.push(r):i[o].info=[i[o].info,r],h&&(i[o].withdraw=!0,i[o].limits.withdraw.min=Math.min(i[o].limits.withdraw.min,m)),u&&(i[o].deposit=!0,i[o].limits.deposit.min=Math.min(i[o].limits.deposit.min,g)),l&&(i[o].active=!0)):i[o]={id:a,code:o,info:r,type:void 0,name:void 0,active:l,deposit:u,withdraw:h,fee:p,precision:this.parseNumber("0.00000001"),limits:{amount:{min:void 0,max:void 0},withdraw:{min:m,max:void 0},deposit:{min:g,max:void 0}},networks:{}},i[o].networks[y]=b}return i}async fetchMarkets(e={}){const t=this.safeValue(this.options,"fetchMarkets",{}),s=this.safeString(t,"method","fetch_markets_v2");return await this[s](e)}async fetchMarketsV2(e={}){const t=this.safeString(this.options,"defaultType"),[s,i]=this.handleMarginModeAndParams("fetchMarketsV2",e);let r=[this[s!==void 0?"publicSpotGetMarginSymbols":"publicSpotGetTradesSymbols"](i),this.publicSwapGetPublicInstruments(e)];r=await Promise.all(r);const a=r[0],o=r[1],d=this.safeValue(a,"symbol_list",[]),c=this.safeValue(o,"data",[]),u=this.arrayConcat(d,c),h=[];for(let l=0;l<u.length;l++){const p=u[l],m=this.safeString2(p,"symbol","instrument_id"),g=this.safeString2(p,"base_asset","base_currency"),y=this.safeString2(p,"quote_asset","quote_currency"),b=this.safeString(p,"clear_currency"),w=this.safeCurrencyCode(g),k=this.safeCurrencyCode(y),T=this.safeCurrencyCode(b);let O=this.safeInteger(p,"is_allow",1),x=t==="margin"?"margin":"spot";const C=T===void 0,E=!C,P=s!==void 0?!0:void 0;let _=w+"/"+k,S,I;E&&(x="swap",_=w+"/"+k+":"+T,S=this.safeValue(p,"is_inverse"),I=!S,this.safeValue(p,"isTrading")&&(O=!0)),h.push({id:m,symbol:_,base:w,quote:k,settle:T,baseId:g,quoteId:y,settleId:b,type:x,spot:C,margin:P,swap:E,future:!1,option:!1,active:!!O,contract:E,linear:I,inverse:S,contractSize:this.safeNumber(p,"contract_value"),expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(p,"amount_precision"))),price:this.parseNumber(this.parsePrecision(this.safeString(p,"price_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber2(p,"minimum_amount","min_order_amount"),max:void 0},price:{min:this.safeNumber(p,"tick_size"),max:void 0},cost:{min:this.safeNumber(p,"minimum_value"),max:void 0}},info:p})}return h}async fetchMarketsV1(e={}){const t=await this.publicSpotGetMarkets(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"market"),[o,d]=a.split("_"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d);i.push({id:a,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:void 0,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{price:this.parseNumber(this.parsePrecision(this.safeString(r,"price_precision"))),amount:this.parseNumber(this.parsePrecision(this.safeString(r,"volume_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"min_volume"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(r,"min_amount"),max:void 0}},info:r})}return i}parseBalance(e){const t=this.safeValue(e,"list",[]),s={info:e};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.used=this.safeString(n,"frozen"),o.free=this.safeString(n,"free"),o.total=this.safeString(n,"total"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){const t=this.safeString(this.options,"defaultType","spot"),s=this.safeString(e,"type",t);e=this.omit(e,"type");const i="privateSpotGet"+this.capitalize(s)+"Assets",n=await this[i](e);return this.parseBalance(n)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit=t);const r=await this.publicSpotGetOrderBook(this.extend(n,s)),a=this.safeTimestamp(r,"date");return this.parseOrderBook(r,i.symbol,a)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeString(e,0);let i;s!==void 0&&(i=this.market(s));let n;[n,t]=this.handleMarketTypeAndParams("fetchTickers",i,t);let r="publicSpotGetTicker";const a={};n==="swap"&&(r="publicSwapGetPublicTickers");const o=await this[r](this.extend(a,t)),d={},c=this.safeValue2(o,"ticker","data",[]),u=this.safeInteger(o,"date");for(let h=0;h<c.length;h++){const l=this.extend({date:u},c[h]),p=this.parseTicker(l),m=p.symbol;d[m]=p}return this.filterByArray(d,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);let i="publicSpotGetTicker";const n={};s.swap?(i="publicSwapGetPublicTicker",n.instrument_id=s.id):n.symbol=s.id;const r=await this[i](this.extend(n,t)),a=this.safeInteger(r,"date"),o=this.safeValue(r,"ticker",[]),d=this.safeValue(r,"data",{}),c=this.safeValue(o,0,{});let u;return s.swap?u=d:u=this.extend({date:a},c),this.parseTicker(u,s)}parseTicker(e,t=void 0){const s=this.safeStringUpper2(e,"symbol","instrument_id"),i=this.safeSymbol(s,t);t=this.safeMarket(s);let n=this.safeTimestamp(e,"date");t.swap&&(n=this.safeInteger(e,"timestamp"));const r=this.safeString(e,"last");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString2(e,"high","high_24h"),low:this.safeString2(e,"low","low_24h"),bid:this.safeString2(e,"buy","best_bid"),bidVolume:this.safeString(e,"best_bid_size"),ask:this.safeString2(e,"sell","best_ask"),askVolume:this.safeString(e,"best_ask_size"),vwap:void 0,open:this.safeString(e,"open_24h"),close:r,last:r,previousClose:void 0,change:void 0,percentage:this.safeString2(e,"change","price_change_percent"),average:void 0,baseVolume:this.safeString(e,"base_vol"),quoteVolume:this.safeString2(e,"vol","volume_24h"),info:e},t)}parseTrade(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"order_id"),n=this.safeTimestamp2(e,"date","timestamp");let r=this.safeString2(e,"type","side");const a=r.split("_");r=this.safeString(a,0);const o=this.safeString(a,1),d=this.safeString(e,"price"),c=this.safeString(e,"amount"),u=this.safeString(e,"symbol"),h=this.safeSymbol(u,t,"_"),l=this.safeValue(e,"is_maker"),p=this.safeString(e,"fee");let m;if(p!==void 0){const g=this.safeString(e,"fee_currency"),y=this.safeCurrencyCode(g);m={cost:p,currency:y}}return this.safeTrade({id:s,info:e,timestamp:n,datetime:this.iso8601(n),symbol:h,type:o,order:i,side:r,price:d,amount:c,cost:void 0,takerOrMaker:l,fee:m},t)}async fetchTime(e={}){const t=await this.publicSpotGetTime(e);return this.safeTimestamp(t,"server_time")}async fetchStatus(e={}){const t=await this.publicSpotGetPing(e);return{status:this.safeInteger(t,"code")===0?"ok":"maintenance",updated:void 0,eta:void 0,url:void 0,info:t}}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s);const a=await this.publicSpotGetTrades(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,5),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,1)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,period:this.timeframes[t]};if(s!==void 0){const c=parseInt(s/1e3);if(a.start_time=c,i!==void 0){const u=this.parseTimeframe(t);a.end_time=this.sum(c,i*u)}}else if(i!==void 0){const c=this.seconds(),u=this.parseTimeframe(t);a.startTime=this.sum(c,-i*u)}const o=await this.publicSpotGetKline(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseOHLCVs(d,r,t,s,i)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);e=a.symbol;let o,d;[o,r]=this.handleMarketTypeAndParams("createOrder",a,r);let c=this.getSupportedMapping(o,{spot:"privateSpotPostSpotOrderNew",margin:"privateSpotPostMarginOrderNew",swap:"privateSwapPostTradeOrderPlace"});[d,r]=this.handleMarginModeAndParams("createOrder",r),d!==void 0&&(c="privateSpotPostMarginOrderNew",o="margin");const u={},h=o==="swap",l=t==="market",p=t==="limit",m=h?"instrument_id":"symbol";u[m]=a.id;let g=this.isPostOnly(l,!1,r);if(h){const k=this.safeValue(r,"reduceOnly",!1),T=this.safeString(r,"timeInForce");let O;if(s==="buy"){const x=k?4:1;u.type=x}else{const x=k?3:2;u.type=x}p&&(O=0),T==="FOK"?O=l?15:9:T==="IOC"?O=l?13:4:T==="GTC"||l?O=14:T==="PO"&&(g=!0),n!==void 0&&(u.price=this.priceToPrecision(e,n)),u.order_type=O,u.size=i,r=this.omit(r,["reduceOnly","timeInForce"])}else{g=g===!0?1:2,u.market=o;let k="";t==="market"?k="_market":u.price=this.priceToPrecision(e,n),u.type=s+k,u.amount=this.amountToPrecision(e,i)}g&&(u.postOnly=g);const y=this.omit(r,["postOnly","post_only"]),b=await this[c](this.extend(u,y)),w=this.parseOrder(b,a);return this.extend(w,{symbol:e,type:t,side:s,amount:i,price:n})}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));let n;[n,s]=this.handleMarketTypeAndParams("cancelOrder",i,s);let r=this.getSupportedMapping(n,{spot:"privateSpotPostSpotOrderCancel",margin:"privateSpotPostMarginOrderCancel",swap:"privateSwapPostTradeCancelOrder"});const[a,o]=this.handleMarginModeAndParams("cancelOrder",s);a!==void 0&&(r="privateSpotPostMarginOrderCancel",n="margin"),e=e.toString();const d={order_id:e};n==="swap"?(this.checkRequiredSymbol("cancelOrder",t),d.instrument_id=i.id):d.market=n;const c=await this[r](this.extend(d,o));if((n==="spot"||n==="margin")&&this.safeValue(c,"success",[]).length!==1)throw new _0(this.id+" cancelOrder() "+e+" not found");return c}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeString(this.options,"defaultType","spot"),n=this.safeString(s,"type",i);s=this.omit(s,"type");const r={market:n,order_id:e.join(",")},a=await this.privateSpotPostCancelOrder(this.extend(r,s));if(this.safeValue(a,"success",[]).length<1)throw new _0(this.id+" cancelOrders() error");return a}parseOrderStatus(e){const t={0:"open",1:"open",2:"closed",3:"canceled",4:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){let s,i,n,r,a=this.safeString(e,"type");const o=this.safeString2(e,"symbol","instrument_id"),d=this.safeSymbol(o,t,"_");if(t=this.market(d),t.type==="swap"){const c=this.safeInteger(e,"order_type");c===9||c===10||c===11||c===12||c===15?n="FOK":c===1||c===2||c===3||c===4||c===13?n="IOC":(c===6||c===7||c===8||c===14)&&(n="GTC"),c===0||c===1||c===4||c===5||c===9||c===10?r="limit":r="market",a==="1"?a="open long":a==="2"?a="open short":a==="3"?a="close long":a==="4"&&(a="close short"),s=this.safeInteger(e,"insert_time"),i=this.safeInteger(e,"time_stamp")}else if(s=this.safeTimestamp(e,"created_date"),i=this.safeTimestamp(e,"finished_date"),a!==void 0){const c=a.split("_");c.length>1?(a=c[0],r=c[1]):r="limit"}return this.safeOrder({info:e,id:this.safeString2(e,"order_id","data"),clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:i,symbol:d,type:r,timeInForce:n,postOnly:void 0,side:a,price:this.safeNumber(e,"price"),stopPrice:void 0,amount:this.safeNumber2(e,"amount","size"),filled:this.safeNumber2(e,"executed_amount","filled_qty"),remaining:void 0,cost:void 0,average:this.safeNumber2(e,"avg_price","price_avg"),status:this.parseOrderStatus(this.safeString2(e,"status","state")),fee:{cost:this.safeNumber(e,"fee")},trades:void 0},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));let r;[r,i]=this.handleMarketTypeAndParams("fetchOpenOrders",n,i);let a=this.getSupportedMapping(r,{spot:"privateSpotGetSpotOrderCurrent",margin:"privateSpotGetMarginOrderCurrent",swap:"privateSwapGetTradeOpenOrders"});const[o,d]=this.handleMarginModeAndParams("fetchOpenOrders",i);o!==void 0&&(a="privateSpotGetMarginOrderCurrent",r="margin");const c={},u=r==="swap";if(u?(t!==void 0&&(c.start_timestamp=t),s!==void 0&&(c.limit=s)):c.market=r,n!==void 0){const p=u?"instrument_id":"symbol";c[p]=n.id}const h=await this[a](this.extend(c,d)),l=this.safeValue(h,"data",[]);return this.parseOrders(l,n,t,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));let r;[r,i]=this.handleMarketTypeAndParams("fetchOrders",n,i);let a=this.getSupportedMapping(r,{spot:"privateSpotGetSpotOrderHistory",margin:"privateSpotGetMarginOrderHistory",swap:"privateSwapGetTradeHistoryOrders"});const[o,d]=this.handleMarginModeAndParams("fetchOrders",i);o!==void 0&&(a="privateSpotGetMarginOrderHistory",r="margin");const c={};if(r==="swap"?t!==void 0&&(c.start_timestamp=t):(c.market=r,t!==void 0&&(c.start_time=parseInt(t/1e3))),n!==void 0){const l=r==="swap"?"instrument_id":"symbol";c[l]=n.id}s!==void 0&&(c.limit=s);const u=await this[a](this.extend(c,d)),h=this.safeValue(u,"data",[]);return this.parseOrders(h,n,t,s)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));let n;[n,s]=this.handleMarketTypeAndParams("fetchOrder",i,s);let r=this.getSupportedMapping(n,{spot:"privateSpotGetSpotOrder",margin:"privateSpotGetMarginOrder",swap:"privateSwapGetTradeOrderInfo"});const[a,o]=this.handleMarginModeAndParams("fetchOrder",s);a!==void 0&&(r="privateSpotGetMarginOrder",n="margin");const d={order_id:e};n==="swap"?i!==void 0&&(d.instrument_id=i.id):d.market=n;const c=await this[r](this.extend(d,o)),u=this.safeValue(c,"data"),h=n==="swap"?u:this.safeValue(u,0);if(h===void 0)throw new _0(this.id+" fetchOrder() order "+e.toString()+" not found");return this.parseOrder(h,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeString(this.options,"defaultType","spot"),r=this.safeString(i,"type",n);i=this.omit(i,"type"),await this.loadMarkets();let a;const o={market:r};e!==void 0&&(a=this.market(e),o.symbol=a.id),t!==void 0&&(o.start_time=parseInt(t/1e3)),s!==void 0&&(o.limit=s);const d=await this.privateSpotGetMarketMytrades(this.extend(o,i)),c=this.safeValue(d,"list",[]);return this.parseTrades(c,a,t,s)}parseLedgerEntryType(e){const t={};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"num"),i=void 0,n=this.parseLedgerEntryType(this.safeString(e,"type")),r=this.safeCurrencyCode(this.safeString(e,"currency_mark"),t),a=this.safeTimestamp(e,"time"),o=void 0,d=this.safeNumber(e,"balance");return{info:e,id:s,direction:void 0,account:i,referenceId:void 0,referenceAccount:void 0,type:n,currency:r,amount:void 0,before:o,after:d,status:"ok",timestamp:a,datetime:this.iso8601(a),fee:void 0}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeString(this.options,"defaultType","spot"),r=this.safeString(i,"type",n);i=this.omit(i,"type"),await this.loadMarkets();const a={market:r};let o;e!==void 0&&(o=this.currency(e),a.currency_mark=o.id),t!==void 0&&(a.start_time=parseInt(t/1e3)),s!==void 0&&(a.limit=s);const d=await this.privateSpotGetMarketFinancelog(this.extend(a,i)),c=this.safeValue(d,"data",{}),u=this.safeValue(c,"finance",[]);return this.parseLedger(u,o,t,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"addressTag"),n=this.safeStringUpper(e,"currency"),r=this.safeCurrencyCode(n);return{info:e,currency:r,address:s,tag:i,network:void 0}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.privateSpotGetDepositAddress(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.parseDepositAddresses(r),o=this.safeValue(a,e);if(o===void 0)throw new C0(this.id+" fetchDepositAddress() did not return an address for "+e+" - create the deposit address in the user settings on the exchange website first.");return o}async fetchTransactionsByType(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;const a={};t!==void 0&&(r=this.currency(t),a.currency=r.id),i!==void 0&&(a.size=Math.min(500,i));const d=await this[e==="deposit"?"privateSpotGetDepositHistory":"privateSpotGetWithdrawHistory"](this.extend(a,n)),c=this.safeValue(d,"data",[]);return this.parseTransactions(c,r,s,i,{type:e})}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByType("deposit",e,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByType("withdrawal",e,t,s,i)}parseTransactionStatus(e){const t={1:"pending",2:"pending",3:"ok",4:"failed"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"id","withdraw_id"),i=this.safeString(e,"address"),n=this.safeString(e,"memo"),r=this.safeString(e,"hash"),a=this.safeStringUpper(e,"currency"),o=this.safeCurrencyCode(a,t),d=this.parse8601(this.safeString(e,"created_date")),c=this.parse8601(this.safeString(e,"finished_date")),u=this.parseTransactionStatus(this.safeString(e,"state")),h=this.safeNumber(e,"amount"),l=this.safeNumber(e,"fee");let p;l!==void 0&&(p={currency:o,cost:l});const m=this.safeString(e,"chain");return{info:e,id:s,txid:r,timestamp:d,datetime:this.iso8601(d),network:m,address:i,addressTo:i,addressFrom:void 0,tag:n,tagTo:n,tagFrom:void 0,type:void 0,amount:h,currency:o,status:u,updated:c,fee:p}}parseTransferStatus(e){const t={0:"ok"};return this.safeString(t,e,e)}parseTransfer(e,t=void 0){let s,i;const n=this.safeInteger(e,"type");n===1?(s="spot",i="swap"):n===2&&(s="swap",i="spot");const r=this.safeInteger(e,"timestamp");return{info:e,id:this.safeString(e,"transfer_id"),timestamp:r,datetime:this.iso8601(r),currency:this.safeCurrencyCode(this.safeString(e,"currency"),t),amount:this.safeNumber(e,"amount"),fromAccount:s,toAccount:i,status:this.parseTransferStatus(this.safeString(e,"code"))}}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c={currency_mark:r.id,num:parseFloat(this.currencyToPrecision(e,t)),from:o,to:d},u=await this.privateSpotPostTransfer(this.extend(c,n)),h=this.parseTransfer(u,r);return this.extend(h,{amount:t,currency:e,fromAccount:s,toAccount:i})}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={address:s,amount:parseFloat(t),currency:r.id};i!==void 0&&(a.memo=i);const o=await this.privateSpotPostWithdrawNew(this.extend(a,n));return this.parseTransaction(o,r)}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a;t!==void 0&&(a=this.market(t),r.symbol=a.id);const o=await this.privateSpotGetMarginPositions(this.extend(r,n)),d=this.safeValue(o,"positions"),c=this.parseBorrowInterests(d,a);return this.filterByCurrencySinceLimit(c,e,s,i)}parseBorrowInterest(e,t){const s=this.safeString(e,"symbol"),i=this.safeString(e,"amount"),n=this.safeString(e,"leverage_ratio"),r=XS.stringDiv(i,n),a=XS.stringSub(i,r),o=t===void 0?void 0:t.base;return{account:this.safeSymbol(s,t),currency:o,interest:void 0,interestRate:.001,amountBorrowed:this.parseNumber(a),timestamp:void 0,datetime:void 0,info:e}}async fetchBorrowRate(e,t={}){await this.loadMarkets();const s={},i=await this.privateSpotGetMarginAssets(this.extend(s,t)),n=this.safeValue(i,"list",[]);let r=[];for(let o=0;o<n.length;o++){const d=n[o];this.safeString(d,"currency")===e&&(r=d)}const a=this.safeString(r,"currency");return this.parseBorrowRate(r,a)}async fetchBorrowRates(e={}){await this.loadMarkets();const t=await this.privateSpotGetMarginAssets(e),s=this.safeValue(t,"list");return this.parseBorrowRates(s,"currency")}parseBorrowRate(e,t=void 0){const s=this.milliseconds(),i=this.safeString(e,"currency");return{currency:this.safeCurrencyCode(i,t),rate:.001,period:864e5,timestamp:s,datetime:this.iso8601(s),info:e}}parseBorrowRates(e,t){const s={};for(let i=0;i<e.length;i++){const n=e[i],r=this.safeString(n,t),a=this.safeCurrencyCode(r),o=this.parseBorrowRate(n,r);s[a]=o}return s}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new xc(this.id+" fetchFundingRate() supports swap contracts only");const i={instrument_id:s.id},n=await this.publicSwapGetPublicFundingRate(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseFundingRate(r,s)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"instrument_id"),i=this.safeInteger(e,"funding_time"),n=this.safeInteger(e,"next_funding_time");return{info:e,symbol:this.safeSymbol(s,t),markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeString(e,"funding_rate"),fundingTimestamp:i,fundingDatetime:this.iso8601(i),nextFundingRate:this.safeString(e,"next_funding_rate"),nextFundingTimestamp:n,nextFundingDatetime:this.iso8601(n),previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){this.checkRequiredSymbol("fetchFundingRateHistory",e),await this.loadMarkets();const n=this.market(e);if(!n.swap)throw new xc(this.id+" fetchFundingRateHistory() supports swap contracts only");const r={instrument_id:n.id};t!==void 0&&(r.start_timestamp=t),s!==void 0&&(r.limit=s);const a=await this.publicSwapGetPublicFundingRateHistory(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"funding_rates",[]),c=[];for(let h=0;h<d.length;h++){const l=d[h],p=this.safeString(o,"instrument_id"),m=this.safeSymbol(p),g=this.safeInteger(l,"time");c.push({info:l,symbol:m,fundingRate:this.safeString(l,"rate"),timestamp:g,datetime:this.iso8601(g)})}const u=this.sortBy(c,"timestamp");return this.filterBySymbolSinceLimit(u,e,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new Xs(this.id+" fetchTradingFee() supports swap markets only");const i={instrument_id:s.id},n=await this.privateSwapGetAccountTradingFeeRate(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTradingFee(r,s)}parseTradingFee(e,t=void 0){const s=this.safeString(e,"instrument_id"),i=this.safeSymbol(s,t);return{info:e,symbol:i,maker:this.safeNumber(e,"maker_fee_rate"),taker:this.safeNumber(e,"taker_fee_rate")}}async fetchPositions(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={};let i,n;if(e!==void 0){let l;if(Array.isArray(e)){if(e.length>1)throw new Xs(this.id+" fetchPositions() symbols argument cannot contain more than 1 symbol");l=e[0]}else l=e;i=this.market(l)}[n,t]=this.handleMarketTypeAndParams("fetchPositions",i,t);const[r,a]=this.handleMarginModeAndParams("fetchPositions",t);if(r!==void 0&&(n="margin"),i!==void 0){const l=n==="swap"?"instrument_id":"symbol";s[l]=i.id}const o=this.getSupportedMapping(n,{spot:"privateSpotGetMarginPositions",margin:"privateSpotGetMarginPositions",swap:"privateSwapGetAccountPositions"}),d=await this[o](this.extend(s,a)),c=n==="swap"?"data":"positions",u=this.safeValue(d,c,[]),h=[];for(let l=0;l<u.length;l++)h.push(this.parsePosition(u[l],i));return this.filterByArray(h,"symbol",e,!1)}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e),i={};let n;[n,t]=this.handleMarketTypeAndParams("fetchPosition",s,t);const[r,a]=this.handleMarginModeAndParams("fetchPosition",t);r!==void 0&&(n="margin");const o=this.getSupportedMapping(n,{spot:"privateSpotGetMarginPositions",margin:"privateSpotGetMarginPositions",swap:"privateSwapGetAccountPositions"}),d=n==="swap"?"instrument_id":"symbol";i[d]=s.id;const c=await this[o](this.extend(i,a)),u=n==="swap"?"data":"positions",h=this.safeValue(c,u,[]),l=this.parsePosition(h[0],s);return n==="swap"?l:this.extend(l,{collateral:this.safeNumber(c,"margin"),marginRatio:this.safeNumber(c,"margin_rate")})}parsePosition(e,t=void 0){const s=this.safeString2(e,"instrument_id","symbol");t=this.safeMarket(s,t);const i=t.symbol;let n=this.safeString(e,"margin_mode");n!==void 0?n=n==="crossed"?"cross":"isolated":n="crossed";const r=this.safeInteger(e,"timestamp");let a=this.safeString(e,"side");return a==="go_long"?a="long":a==="go_short"&&(a="short"),{info:e,id:void 0,symbol:i,notional:this.safeNumber(e,"amount"),marginMode:n,liquidationPrice:this.safeNumber(e,"liquidation_price"),entryPrice:this.safeNumber2(e,"avg_cost","entry_price"),unrealizedPnl:this.safeNumber(e,"unrealized_pnl"),contracts:this.safeNumber(e,"avail_position"),contractSize:this.safeNumber(t,"contractSize"),markPrice:this.safeNumber(e,"last"),side:a,hedged:void 0,timestamp:r,datetime:this.iso8601(r),maintenanceMargin:this.safeNumber(e,"margin"),maintenanceMarginPercentage:this.safeNumber(e,"maint_margin_ratio"),collateral:void 0,initialMargin:void 0,initialMarginPercentage:void 0,leverage:this.safeNumber2(e,"leverage","leverage_ratio"),marginRatio:this.safeNumber(e,"margin_ratio"),percentage:void 0}}async setLeverage(e,t=void 0,s={}){await this.loadMarkets(),this.checkRequiredSymbol("setLeverage",t);const i=this.market(t);if(i.type!=="swap")throw new xc(this.id+" setLeverage() supports swap contracts only");if(e<1||e>100)throw new Xs(this.id+" leverage should be between 1 and 100");const n={instrument_id:i.id,leverage:e},r=this.safeString2(this.options,"marginMode","defaultMarginMode");let a=this.safeStringLower2(s,"marginMode","defaultMarginMode",r);if(a!==void 0&&(a=a==="cross"?"crossed":"isolated",n.margin_mode=a,s=this.omit(s,["marginMode","defaultMarginMode"])),a==="isolated"){const o=this.safeString(s,"side");o!==void 0?(n.side=o,s=this.omit(s,"side")):this.checkRequiredArgument("setLeverage",o,"side",["long","short"])}return await this.privateSwapPostAccountLeverage(this.extend(n,s))}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.safeCurrencyCode(e),r.currency=n.id),t!==void 0&&(r.start_timestamp=t),s!==void 0&&(r.limit=s);const a=await this.privateSwapGetAccountTransferRecord(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransfers(o,n,t,s)}handleMarginModeAndParams(e,t={},s=void 0){const i=this.safeString(this.options,"defaultType"),n=this.safeValue(t,"margin",!1);let r;if([r,t]=super.handleMarginModeAndParams(e,t,s),r!==void 0){if(r!=="cross")throw new SF(this.id+" only cross margin is supported")}else(i==="margin"||n===!0)&&(r="cross");return[r,t]}sign(e,t=[],s="GET",i={},n=void 0,r=void 0){const a=t[0]==="private",d=t[1]==="spot"?"/v3":"/swap/v2",c="/"+this.implodeParams(e,i),u=d+c;let h=this.urls.api.rest+u;const l=this.omit(i,this.extractParams(e));let p=this.urlencode(this.keysort(l));if(a){let m,g;if(d==="/swap/v2"){if(g=this.milliseconds().toString(),m=g+s+u,s==="GET")p&&(m+="?"+p);else if(s==="POST"){const b=JSON.stringify(i);p=b,m+=b}}else g=this.nonce().toString(),m=p;const y=this.hmac(this.encode(m),this.encode(this.secret));s==="GET"?p&&(h+="?"+p):s==="POST"&&(n={"Content-Type":"application/x-www-form-urlencoded"},p&&(r=p)),n={"ACCESS-KEY":this.apiKey,"ACCESS-SIGN":y,"ACCESS-TIMESTAMP":g}}else p&&(h+="?"+p);return{url:h,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(!a)return;const c=this.safeString(a,"code");if(c==="0"||c==="200")return;const u=this.id+" "+r;if(c===void 0)throw new wF(u);const h=[qf,u],[l,p]=this.safeValue(this.exceptions.exact,c,h);throw new l(p)}};const xF=ge,{ArgumentsRequired:YS,ExchangeError:Lf,OrderNotFound:QS,AuthenticationError:ZS,InsufficientFunds:JS,InvalidOrder:_c,InvalidNonce:_F,OnMaintenance:CF,RateLimitExceeded:ev,BadRequest:Rf,PermissionDenied:tv}=de,{TICK_SIZE:MF}=me,gr=Se;var X_=class extends xF{describe(){return this.deepExtend(super.describe(),{id:"exmo",name:"EXMO",countries:["LT"],rateLimit:350,version:"v1.1",has:{CORS:void 0,spot:!0,margin:!0,swap:!1,future:!1,option:!1,addMargin:!0,cancelOrder:!0,cancelOrders:!1,createDepositAddress:!1,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!1,fetchBalance:!0,fetchCanceledOrders:!0,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:"emulated",fetchOrderBook:!0,fetchOrderBooks:!0,fetchOrderTrades:!0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFees:!0,fetchTransactions:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,reduceMargin:!0,setMargin:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1","5m":"5","15m":"15","30m":"30","45m":"45","1h":"60","2h":"120","3h":"180","4h":"240","1d":"D","1w":"W","1M":"M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766491-1b0ea956-5eda-11e7-9225-40d67b481b8d.jpg",api:{public:"https://api.exmo.com",private:"https://api.exmo.com",web:"https://exmo.me"},www:"https://exmo.me",referral:"https://exmo.me/?ref=131685",doc:["https://exmo.me/en/api_doc?ref=131685"],fees:"https://exmo.com/en/docs/fees"},api:{web:{get:["ctrl/feesAndLimits","en/docs/fees"]},public:{get:["currency","currency/list/extended","order_book","pair_settings","ticker","trades","candles_history","required_amount","payments/providers/crypto/list"]},private:{post:["user_info","order_create","order_cancel","stop_market_order_create","stop_market_order_cancel","user_open_orders","user_trades","user_cancelled_orders","order_trades","deposit_address","withdraw_crypt","withdraw_get_txid","excode_create","excode_load","code_check","wallet_history","wallet_operations","margin/user/order/create","margin/user/order/update","margin/user/order/cancel","margin/user/position/close","margin/user/position/margin_add","margin/user/position/margin_remove","margin/currency/list","margin/pair/list","margin/settings","margin/funding/list","margin/user/info","margin/user/order/list","margin/user/order/history","margin/user/order/trades","margin/user/order/max_quantity","margin/user/position/list","margin/user/position/margin_remove_info","margin/user/position/margin_add_info","margin/user/wallet/list","margin/user/wallet/history","margin/user/trade/list","margin/trades","margin/liquidation/feed"]}},fees:{trading:{feeSide:"get",tierBased:!0,percentage:!0,maker:this.parseNumber("0.004"),taker:this.parseNumber("0.004")},transaction:{tierBased:!1,percentage:!1}},options:{networks:{ETH:"ERC20",TRX:"TRC20"},fetchTradingFees:{method:"fetchPrivateTradingFees"},margin:{fillResponseFromRequest:!0}},commonCurrencies:{GMT:"GMT Token"},precisionMode:MF,exceptions:{exact:{40005:ZS,40009:_F,40015:Lf,40016:CF,40017:ZS,40032:tv,40033:tv,40034:ev,50052:JS,50054:JS,50304:QS,50173:QS,50277:_c,50319:_c,50321:_c,50381:_c},broad:{"range period is too long":Rf,"invalid syntax":Rf,"API rate limit exceeded":ev}}})}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets();const n=this.market(e),r={position_id:n.id,quantity:t};let a;s==="add"?a="privatePostMarginUserPositionMarginAdd":s==="reduce"&&(a="privatePostMarginUserPositionMarginReduce");const o=await this[a](this.extend(r,i)),d=this.parseMarginModification(o,n),c=this.safeValue(this.options,"margin",{});return this.safeValue(c,"fillResponseFromRequest",!0)&&(d.type=s,d.amount=t),d}parseMarginModification(e,t=void 0){return{info:e,type:void 0,amount:void 0,code:this.safeValue(t,"quote"),symbol:this.safeSymbol(void 0,t),total:void 0,status:"ok"}}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"reduce",s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"add",s)}async fetchTradingFees(e={}){let t=this.safeString(e,"method");if(e=this.omit(e,"method"),t===void 0){const s=this.safeValue(this.options,"fetchTradingFees",{});t=this.safeString(s,"method","fetchPrivateTradingFees")}return await this[t](e)}async fetchPrivateTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostMarginPairList(e),s=this.safeValue(t,"pairs",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"name"),o=this.safeSymbol(a,void 0,"_"),d=this.safeString(r,"trade_maker_fee"),c=this.safeString(r,"trade_taker_fee"),u=this.parseNumber(gr.stringDiv(d,"100")),h=this.parseNumber(gr.stringDiv(c,"100"));i[o]={info:r,symbol:o,maker:u,taker:h,percentage:!0,tierBased:!0}}return i}async fetchPublicTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetPairSettings(e),s={};for(let i=0;i<this.symbols.length;i++){const n=this.symbols[i],r=this.market(n),a=this.safeValue(t,r.id,{}),o=this.safeString(a,"commission_maker_percent"),d=this.safeString(a,"commission_taker_percent"),c=this.parseNumber(gr.stringDiv(o,"100")),u=this.parseNumber(gr.stringDiv(d,"100"));s[n]={info:a,symbol:n,maker:c,taker:u,percentage:!0,tierBased:!0}}return s}parseFixedFloatValue(e){if(e===void 0||e==="-")return;if(e==="")return 0;const t=e.indexOf("%")>=0,i=e.split(" ")[0].replace("%",""),n=parseFloat(i);if(n>0&&t)throw new Lf(this.id+" parseFixedFloatValue() detected an unsupported non-zero percentage-based fee "+e);return n}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetPaymentsProvidersCryptoList(t),i={},n=Object.keys(s);for(let r=0;r<n.length;r++){const a=n[r];if(e!==void 0&&!this.inArray(a,e))continue;i[a]={deposit:void 0,withdraw:void 0};const o=this.currency(a),d=this.safeString(o,"id"),c=this.safeValue(s,d,[]);for(let u=0;u<c.length;u++){const h=c[u],l=this.safeString(h,"type"),p=this.safeString(h,"commission_desc"),m=this.parseFixedFloatValue(p);i[a][l]=m}i[a].info=c}return this.options.transactionFees=i,i}async fetchCurrencies(e={}){const t=await this.publicGetCurrencyListExtended(e),s=await this.publicGetPaymentsProvidersCryptoList(e),i={};for(let n=0;n<t.length;n++){const r=t[n],a=this.safeString(r,"name"),o=this.safeString(r,"description"),d=this.safeValue(s,a);let c=!1,u="crypto";const h={deposit:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}};let l,p,m;if(d===void 0)c=!0,u="fiat";else for(let y=0;y<d.length;y++){const b=d[y],w=this.safeString(b,"type"),k=this.safeNumber(b,"min");let T=this.safeNumber(b,"max");T===0&&(T=void 0);const O=this.safeValue(b,"enabled");if(w==="deposit"?O&&!p?p=!0:O||(p=!1):w==="withdraw"&&(O&&!m?m=!0:O||(m=!1)),O&&(c=!0,(h[w].min===void 0||k<h[w].min)&&(h[w].min=k,h[w].max=T,w==="withdraw"))){const x=this.safeString(b,"commission_desc");l=this.parseFixedFloatValue(x)}}const g=this.safeCurrencyCode(a);i[g]={id:a,code:g,name:o,type:u,active:c,deposit:p,withdraw:m,fee:l,precision:this.parseNumber("0.00000001"),limits:h,info:d}}return i}async fetchMarkets(e={}){const t=await this.publicGetPairSettings(e),s=Object.keys(t),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=t[r],o=r.replace("_","/"),[d,c]=o.split("/"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),l=this.safeString(a,"commission_taker_percent"),p=this.safeString(a,"commission_maker_percent");i.push({id:r,symbol:o,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!0,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,taker:this.parseNumber(gr.stringDiv(l,"100")),maker:this.parseNumber(gr.stringDiv(p,"100")),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber("0.00000001"),price:this.parseNumber(this.parsePrecision(this.safeString(a,"price_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(a,"min_quantity"),max:this.safeNumber(a,"max_quantity")},price:{min:this.safeNumber(a,"min_price"),max:this.safeNumber(a,"max_price")},cost:{min:this.safeNumber(a,"min_amount"),max:this.safeNumber(a,"max_amount")}},info:a})}return i}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,resolution:this.timeframes[t]},o=this.safeValue(this.options,"fetchOHLCV"),d=this.safeInteger(o,"maxLimit",3e3),c=this.parseTimeframe(t),u=this.milliseconds();if(s===void 0)i===void 0&&(i=1e3),i>d&&(i=d),a.from=parseInt(u/1e3)-i*c-1,a.to=parseInt(u/1e3);else if(a.from=parseInt(s/1e3)-1,i===void 0)a.to=parseInt(u/1e3);else{if(i>d)throw new Rf(this.id+" fetchOHLCV() will serve "+d.toString()+" candles at most");const p=this.sum(s,i*c*1e3);a.to=parseInt(p/1e3)}const h=await this.publicGetCandlesHistory(this.extend(a,n)),l=this.safeValue(h,"candles",[]);return this.parseOHLCVs(l,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"t"),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}parseBalance(e){const t={info:e},s=this.safeValue(e,"balances",{}),i=this.safeValue(e,"reserved",{}),n=Object.keys(s);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeCurrencyCode(a),d=this.account();a in s&&(d.free=this.safeString(s,a)),a in i&&(d.used=this.safeString(i,a)),t[o]=d}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostUserInfo(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetOrderBook(this.extend(n,s)),a=this.safeValue(r,i.id);return this.parseOrderBook(a,i.symbol,void 0,"bid","ask")}async fetchOrderBooks(e=void 0,t=void 0,s={}){await this.loadMarkets();let i;if(e===void 0){if(i=this.ids.join(","),i.length>2048){const d=this.ids.length;throw new Lf(this.id+" fetchOrderBooks() has "+d.toString()+" symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchOrderBooks")}}else i=this.marketIds(e),i=i.join(",");const n={pair:i};t!==void 0&&(n.limit=t);const r=await this.publicGetOrderBook(this.extend(n,s)),a={},o=Object.keys(r);for(let d=0;d<o.length;d++){const c=o[d],u=this.safeSymbol(c);a[u]=this.parseOrderBook(r[c],u,void 0,"bid","ask")}return a}parseTicker(e,t=void 0){const s=this.safeTimestamp(e,"updated");t=this.safeMarket(void 0,t);const i=this.safeString(e,"last_trade");return this.safeTicker({symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy_price"),bidVolume:void 0,ask:this.safeString(e,"sell_price"),askVolume:void 0,vwap:void 0,open:void 0,close:i,last:i,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeString(e,"avg"),baseVolume:this.safeString(e,"vol"),quoteVolume:this.safeString(e,"vol_curr"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTicker(t),i={},n=Object.keys(s);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeMarket(a,void 0,"_"),d=o.symbol,c=this.safeValue(s,a);i[d]=this.parseTicker(c,o)}return this.filterByArray(i,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=await this.publicGetTicker(t),i=this.market(e);return this.parseTicker(s[i.id],i)}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"date"),i=this.safeString(e,"trade_id"),n=this.safeString(e,"order_id"),r=this.safeString(e,"price"),a=this.safeString(e,"quantity"),o=this.safeString(e,"amount"),d=this.safeString(e,"type"),c=void 0,u=this.safeString(e,"pair");t=this.safeMarket(u,t,"_");const h=t.symbol,l=this.safeString(e,"exec_type");let p;const m=this.safeString(e,"commission_amount");if(m!==void 0){const g=this.safeString(e,"commission_currency"),y=this.safeCurrencyCode(g);let b=this.safeString(e,"commission_percent");b!==void 0&&(b=gr.stringDiv(b,"1000",18)),p={cost:m,currency:y,rate:b}}return this.safeTrade({id:i,info:e,timestamp:s,datetime:this.iso8601(s),symbol:h,order:n,type:c,side:d,takerOrMaker:l,price:r,amount:a,cost:o,fee:p},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id},a=await this.publicGetTrades(this.extend(r,i)),o=this.safeValue(a,n.id,[]);return this.parseTrades(o,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new YS(this.id+" fetchMyTrades() requires a symbol argument (a single symbol or an array)");await this.loadMarkets();let n,r;if(Array.isArray(e)){if(e.length<1)throw new YS(this.id+" fetchMyTrades() requires a non-empty symbol array");n=this.marketIds(e).join(",")}else r=this.market(e),n=r.id;const a={pair:n};s!==void 0&&(a.limit=s);const o=await this.privatePostUserTrades(this.extend(a,i));let d=[];const c=Object.keys(o);for(let u=0;u<c.length;u++){const h=c[u],l=this.safeMarket(h,void 0,"_"),p=o[h],m=this.parseTrades(p,l,t,s);d=this.arrayConcat(d,m)}return this.filterBySinceLimit(d,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),d=(t==="market"?t+"_":"")+s;let c=n;t==="market"&&n===void 0&&(c=0);const u={pair:a.id,quantity:this.amountToPrecision(a.symbol,i),type:d,price:this.priceToPrecision(a.symbol,c)};let h="privatePostOrderCreate",l=this.safeValue2(r,"client_id","clientOrderId");if(l!==void 0){if(l=this.safeInteger2(r,"client_id","clientOrderId"),l===void 0)throw new Rf(this.id+" createOrder() client order id must be an integer / numeric literal");u.client_id=l,r=this.omit(r,["client_id","clientOrderId"])}if(t==="stop"||t==="stop_limit"||t==="trailing_stop"){const b=this.safeNumber2(r,"stop_price","stopPrice");if(b===void 0)throw new _c(this.id+" createOrder() requires a stopPrice extra param for a "+t+" order");r=this.omit(r,["stopPrice","stop_price"]),u.stop_price=this.priceToPrecision(e,b),h="privatePostMarginUserOrderCreate"}const p=await this[h](this.extend(u,r)),m=this.safeString(p,"order_id"),g=this.milliseconds(),y="open";return{id:m,info:p,timestamp:g,datetime:this.iso8601(g),lastTradeTimestamp:void 0,status:y,symbol:a.symbol,type:t,side:s,price:n,cost:void 0,amount:i,remaining:i,filled:0,fee:void 0,trades:void 0,clientOrderId:l,average:void 0}}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e};return await this.privatePostOrderCancel(this.extend(i,s))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e.toString()},n=await this.privatePostOrderTrades(this.extend(i,s)),r=this.parseOrder(n);return this.extend(r,{id:e.toString()})}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){let r;t!==void 0&&(r=this.market(t));const a={order_id:e.toString()},o=await this.privatePostOrderTrades(this.extend(a,n)),d=this.safeValue(o,"trades");return this.parseTrades(d,r,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),e!==void 0&&(e=this.market(e).symbol);const n=await this.privatePostUserOpenOrders(i),r=Object.keys(n);let a=[];for(let o=0;o<r.length;o++){const d=r[o],c=this.safeMarket(d),u=this.parseOrders(n[d],c);a=this.arrayConcat(a,u)}return this.filterBySymbolSinceLimit(a,e,t,s)}parseOrder(e,t=void 0){let s=this.safeString(e,"order_id"),i=this.safeTimestamp(e,"created"),n;const r=this.safeString(e,"type");let a;"pair"in e?a=e.pair:"in_currency"in e&&"out_currency"in e&&(r==="buy"?a=e.in_currency+"_"+e.out_currency:a=e.out_currency+"_"+e.in_currency),t=this.safeMarket(a,t);let o=this.safeNumber(e,"quantity");if(o===void 0){const x=r==="buy"?"in_amount":"out_amount";o=this.safeNumber(e,x)}let d=this.safeNumber(e,"price"),c=this.safeNumber(e,"amount"),u=0;const h=[],l=this.safeValue(e,"trades",[]);let p,m,g;const y=l.length;if(y>0){p=0;for(let x=0;x<y;x++){const C=this.parseTrade(l[x],t);s===void 0&&(s=C.order),i===void 0&&(i=C.timestamp),i>C.timestamp&&(i=C.timestamp),u=this.sum(u,C.amount),p=this.sum(p,C.fee.cost),h.push(C)}m=h[y-1].timestamp}let b=this.safeString(e,"status"),w;o!==void 0&&(w=o-u,u>=o?b="closed":b="open"),t===void 0&&(t=this.getMarketFromTrades(h));let k;t!==void 0&&(n=t.symbol,k=t.quote),c===void 0?d!==void 0&&(c=d*u):u>0&&(g===void 0&&(g=c/u),d===void 0&&(d=c/u));const T={cost:p,currency:k},O=this.safeInteger(e,"client_id");return{id:s,clientOrderId:O,datetime:this.iso8601(i),timestamp:i,lastTradeTimestamp:m,status:b,symbol:n,type:"limit",timeInForce:void 0,postOnly:void 0,side:r,price:d,stopPrice:void 0,cost:c,amount:o,filled:u,remaining:w,average:g,trades:h,fee:T,info:e}}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.offset=s),s!==void 0&&(n.limit=s);let r;e!==void 0&&(r=this.market(e));const a=await this.privatePostUserCancelledOrders(this.extend(n,i));return this.parseOrders(a,r,t,s,i)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=await this.privatePostDepositAddress(t),i=this.safeString(s,e);let n,r;if(i){const a=i.split(",");n=a[0],a.length>1&&(r=a[1])}return this.checkAddress(n),{currency:e,address:n,tag:r,network:void 0,info:s}}getMarketFromTrades(e){const t=this.indexBy(e,"pair"),s=Object.keys(t);if(s.length===1)return this.markets[s[0]]}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets();const r=this.currency(e),a={amount:t,currency:r.id,address:s};i!==void 0&&(a.invoice=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeString(o,d,d),d!==void 0&&(a.transport=d,n=this.omit(n,"network"));const c=await this.privatePostWithdrawCrypt(this.extend(a,n));return this.parseTransaction(c,r)}parseTransactionStatus(e){const t={transferred:"ok",paid:"ok",pending:"pending",processing:"pending",verifying:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"order_id","task_id"),i=this.safeTimestamp2(e,"dt","created"),n=this.safeTimestamp(e,"updated");let r=this.safeString(e,"amount");r!==void 0&&(r=gr.stringAbs(r));const a=this.parseTransactionStatus(this.safeStringLower(e,"status"));let o=this.safeString(e,"txid");if(o===void 0){const b=this.safeValue(e,"extra",{}),w=this.safeString(b,"txid");w!==""&&(o=w)}const d=this.safeString(e,"type"),c=this.safeString2(e,"curr","currency"),u=this.safeCurrencyCode(c,t);let h;const l=void 0;let p;const m=this.safeString(e,"account");if(d==="deposit")p=m;else if(d==="withdrawal"&&(h=m,h!==void 0)){const b=h.split(":");b.length===2&&(h=this.safeString(b,1),h=h.replace(" ",""))}let g;if(!this.fees.transaction.percentage){const b=d==="withdrawal"?"withdraw":"deposit";let w=this.safeString(e,"commission");w===void 0&&(w=this.safeString(this.options.transactionFees[u],b)),this.safeString(e,"provider")==="cashback"&&(w="0"),w!==void 0&&(d==="withdrawal"&&(r=gr.stringSub(r,w)),g={cost:this.parseNumber(w),currency:u,rate:void 0})}const y=this.safeString(e,"provider");return{info:e,id:s,timestamp:i,datetime:this.iso8601(i),currency:u,amount:r,network:y,address:h,addressTo:h,addressFrom:void 0,tag:l,tagTo:l,tagFrom:void 0,status:a,type:d,updated:n,comment:p,txid:o,fee:g}}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.date=parseInt(t/1e3));let r;e!==void 0&&(r=this.currency(e));const a=await this.privatePostWalletHistory(this.extend(n,i));return this.parseTransactions(a.history,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={type:"withdraw"};s!==void 0&&(r.limit=s),e!==void 0&&(n=this.currency(e),r.currency=n.id);const a=await this.privatePostWalletOperations(this.extend(r,i)),o=this.safeValue(a,"items",[]);return this.parseTransactions(o,n,t,s)}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();let i;const n={order_id:e,type:"withdraw"};t!==void 0&&(i=this.currency(t),n.currency=i.id);const r=await this.privatePostWalletOperations(this.extend(n,s)),a=this.safeValue(r,"items",[]),o=this.safeValue(a,0,{});return this.parseTransaction(o,i)}async fetchDeposit(e=void 0,t=void 0,s={}){await this.loadMarkets();let i;const n={order_id:e,type:"deposit"};t!==void 0&&(i=this.currency(t),n.currency=i.id);const r=await this.privatePostWalletOperations(this.extend(n,s)),a=this.safeValue(r,"items",[]),o=this.safeValue(a,0,{});return this.parseTransaction(o,i)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={type:"deposit"};s!==void 0&&(r.limit=s),e!==void 0&&(n=this.currency(e),r.currency=n.id);const a=await this.privatePostWalletOperations(this.extend(r,i)),o=this.safeValue(a,"items",[]);return this.parseTransactions(o,n,t,s)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/";if(t!=="web"&&(a+=this.version+"/"),a+=e,t==="public"||t==="web")Object.keys(i).length&&(a+="?"+this.urlencode(i));else if(t==="private"){this.checkRequiredCredentials();const o=this.nonce();r=this.urlencode(this.extend({nonce:o},i)),n={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:this.hmac(this.encode(r),this.encode(this.secret),"sha512")}}return{url:a,method:s,body:r,headers:n}}nonce(){return this.milliseconds()}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&("result"in a||"errmsg"in a)){let c=this.safeValue(a,"result",!1);if(typeof c=="string"&&(c==="true"||c==="1"?c=!0:c=!1),!c){let u;const h=this.safeString2(a,"error","errmsg"),l=h.split(":");if(l.length>1){const g=l[0].split(" ");u=g.length>1?g[1]:g[0]}const m=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,m),this.throwBroadlyMatchedException(this.exceptions.broad,h,m),new Lf(m)}}}};const PF=ge,{ExchangeError:Ff,AuthenticationError:Ha,InsufficientFunds:AF,BadSymbol:BF,OrderNotFound:EF}=de,{TICK_SIZE:NF}=me;var jl=class extends PF{describe(){return this.deepExtend(super.describe(),{id:"ndax",name:"NDAX",countries:["CA"],rateLimit:1e3,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,createReduceOnlyOrder:!1,editOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!1,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,signIn:!0,transfer:!1,withdraw:!0},timeframes:{"1m":"60","5m":"300","15m":"900","30m":"1800","1h":"3600","2h":"7200","4h":"14400","6h":"21600","12h":"43200","1d":"86400","1w":"604800","1M":"2419200","4M":"9676800"},urls:{logo:"https://user-images.githubusercontent.com/1294454/108623144-67a3ef00-744e-11eb-8140-75c6b851e945.jpg",test:{public:"https://ndaxmarginstaging.cdnhop.net:8443/AP",private:"https://ndaxmarginstaging.cdnhop.net:8443/AP"},api:{public:"https://api.ndax.io:8443/AP",private:"https://api.ndax.io:8443/AP"},www:"https://ndax.io",doc:["https://apidoc.ndax.io/"],fees:"https://ndax.io/fees",referral:"https://one.ndax.io/bfQiSL"},api:{public:{get:{Activate2FA:1,Authenticate2FA:1,AuthenticateUser:1,GetL2Snapshot:1,GetLevel1:1,GetValidate2FARequiredEndpoints:1,LogOut:1,GetTickerHistory:1,GetProduct:1,GetProducts:1,GetInstrument:1,GetInstruments:1,Ping:1,trades:1,GetLastTrades:1,SubscribeLevel1:1,SubscribeLevel2:1,SubscribeTicker:1,SubscribeTrades:1,SubscribeBlockTrades:1,UnsubscribeBlockTrades:1,UnsubscribeLevel1:1,UnsubscribeLevel2:1,UnsubscribeTicker:1,UnsubscribeTrades:1,Authenticate:1}},private:{get:{GetUserAccountInfos:1,GetUserAccounts:1,GetUserAffiliateCount:1,GetUserAffiliateTag:1,GetUserConfig:1,GetAllUnredactedUserConfigsForUser:1,GetUnredactedUserConfigByKey:1,GetUserDevices:1,GetUserReportTickets:1,GetUserReportWriterResultRecords:1,GetAccountInfo:1,GetAccountPositions:1,GetAllAccountConfigs:1,GetTreasuryProductsForAccount:1,GetAccountTrades:1,GetAccountTransactions:1,GetOpenTradeReports:1,GetAllOpenTradeReports:1,GetTradesHistory:1,GetOpenOrders:1,GetOpenQuotes:1,GetOrderFee:1,GetOrderHistory:1,GetOrdersHistory:1,GetOrderStatus:1,GetOmsFeeTiers:1,GetAccountDepositTransactions:1,GetAccountWithdrawTransactions:1,GetAllDepositRequestInfoTemplates:1,GetDepositInfo:1,GetDepositRequestInfoTemplate:1,GetDeposits:1,GetDepositTicket:1,GetDepositTickets:1,GetOMSWithdrawFees:1,GetWithdrawFee:1,GetWithdraws:1,GetWithdrawTemplate:1,GetWithdrawTemplateTypes:1,GetWithdrawTicket:1,GetWithdrawTickets:1},post:{AddUserAffiliateTag:1,CancelUserReport:1,RegisterNewDevice:1,SubscribeAccountEvents:1,UpdateUserAffiliateTag:1,GenerateTradeActivityReport:1,GenerateTransactionActivityReport:1,GenerateTreasuryActivityReport:1,ScheduleTradeActivityReport:1,ScheduleTransactionActivityReport:1,ScheduleTreasuryActivityReport:1,CancelAllOrders:1,CancelOrder:1,CancelQuote:1,CancelReplaceOrder:1,CreateQuote:1,ModifyOrder:1,SendOrder:1,SubmitBlockTrade:1,UpdateQuote:1,CancelWithdraw:1,CreateDepositTicket:1,CreateWithdrawTicket:1,SubmitDepositTicketComment:1,SubmitWithdrawTicketComment:1,GetOrderHistoryByOrderId:1}}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.0025")}},requiredCredentials:{apiKey:!0,secret:!0,uid:!0,login:!0,password:!0},precisionMode:NF,exceptions:{exact:{Not_Enough_Funds:AF,"Server Error":Ff,"Resource Not Found":EF},broad:{"Invalid InstrumentId":BF,"This endpoint requires 2FACode along with the payload":Ha}},options:{omsId:1,orderTypes:{Market:1,Limit:2,StopMarket:3,StopLimit:4,TrailingStopMarket:5,TrailingStopLimit:6,BlockTrade:7}}})}async signIn(e={}){if(this.checkRequiredCredentials(),this.login===void 0||this.password===void 0)throw new Ha(this.id+" signIn() requires exchange.login, exchange.password");let t={grant_type:"client_credentials"};const s=await this.publicGetAuthenticate(this.extend(t,e));let i=this.safeString(s,"SessionToken");if(i!==void 0)return this.options.sessionToken=i,s;const n=this.safeString(s,"Pending2FaToken");if(n!==void 0){if(this.twofa===void 0)throw new Ha(this.id+" signIn() requires exchange.twofa credentials");this.options.pending2faToken=n,t={Code:this.oath()};const r=await this.publicGetAuthenticate2FA(this.extend(t,e));return i=this.safeString(r,"SessionToken"),this.options.sessionToken=i,r}return s}async fetchCurrencies(e={}){const s={omsId:this.safeInteger(this.options,"omsId",1)},i=await this.publicGetGetProducts(this.extend(s,e)),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"ProductId"),d=this.safeString(a,"ProductFullName"),c=this.safeString(a,"ProductType"),u=this.safeCurrencyCode(this.safeString(a,"Product")),l=!this.safeValue(a,"IsDisabled");n[u]={id:o,name:d,code:u,type:c,precision:this.safeNumber(a,"TickSize"),info:a,active:l,deposit:void 0,withdraw:void 0,fee:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}}}return n}async fetchMarkets(e={}){const s={omsId:this.safeInteger(this.options,"omsId",1)},i=await this.publicGetGetInstruments(this.extend(s,e)),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"InstrumentId"),d=this.safeString(a,"Product1"),c=this.safeString(a,"Product2"),u=this.safeCurrencyCode(this.safeString(a,"Product1Symbol")),h=this.safeCurrencyCode(this.safeString(a,"Product2Symbol")),l=this.safeString(a,"SessionStatus"),p=this.safeValue(a,"IsDisable"),m=l==="Running";n.push({id:o,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:m&&!p,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(a,"QuantityIncrement"),price:this.safeNumber(a,"PriceIncrement")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(a,"MinimumQuantity"),max:void 0},price:{min:this.safeNumber(a,"MinimumPrice"),max:void 0},cost:{min:void 0,max:void 0}},info:a})}return n}parseOrderBook(e,t,s=void 0,i="bids",n="asks",r=6,a=8){let o;const d={symbol:t,bids:[],asks:[],timestamp:void 0,datetime:void 0,nonce:void 0};for(let c=0;c<e.length;c++){const u=e[c];if(s===void 0)s=this.safeInteger(u,2);else{const m=this.safeInteger(u,2);s=Math.max(s,m)}if(o===void 0)o=this.safeInteger(u,0);else{const m=this.safeInteger(u,0);o=Math.max(o,m)}const h=this.parseBidAsk(u,r,a),p=this.safeInteger(u,9)?n:i;d[p].push(h)}return d.bids=this.sortBy(d.bids,0,!0),d.asks=this.sortBy(d.asks,0),d.timestamp=s,d.datetime=this.iso8601(s),d.nonce=o,d}async fetchOrderBook(e,t=void 0,s={}){const i=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const n=this.market(e);t=t===void 0?100:t;const r={omsId:i,InstrumentId:n.id,Depth:t},a=await this.publicGetGetL2Snapshot(this.extend(r,s));return this.parseOrderBook(a,e)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"TimeStamp"),i=this.safeString(e,"InstrumentId");t=this.safeMarket(i,t);const n=this.safeSymbol(i,t),r=this.safeString(e,"LastTradedPx"),a=this.safeString(e,"Rolling24HrPxChangePercent"),o=this.safeString(e,"Rolling24HrPxChange"),d=this.safeString(e,"SessionOpen"),c=this.safeString(e,"Rolling24HrVolume"),u=this.safeString(e,"Rolling24HrNotional");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"SessionHigh"),low:this.safeString(e,"SessionLow"),bid:this.safeString(e,"BestBid"),bidVolume:void 0,ask:this.safeString(e,"BestOffer"),askVolume:void 0,vwap:void 0,open:d,close:r,last:r,previousClose:void 0,change:o,percentage:a,average:void 0,baseVolume:c,quoteVolume:u,info:e},t)}async fetchTicker(e,t={}){const s=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const i=this.market(e),n={omsId:s,InstrumentId:i.id},r=await this.publicGetGetLevel1(this.extend(n,t));return this.parseTicker(r,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,3),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){const r=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const a=this.market(e),o={omsId:r,InstrumentId:a.id,Interval:this.timeframes[t]},d=this.parseTimeframe(t),c=this.milliseconds();s===void 0?i!==void 0&&(o.FromDate=this.ymdhms(c-d*i*1e3),o.ToDate=this.ymdhms(c)):(o.FromDate=this.ymdhms(s),i===void 0?o.ToDate=this.ymdhms(c):o.ToDate=this.ymdhms(this.sum(s,d*i*1e3)));const u=await this.publicGetGetTickerHistory(this.extend(o,n));return this.parseOHLCVs(u,a,t,s,i)}parseTrade(e,t=void 0){let s,i,n,r,a,o,d,c,u,h,l;if(Array.isArray(e))s=this.safeString(e,3),i=this.safeString(e,2),r=this.safeInteger(e,6),a=this.safeString(e,0),o=this.safeString(e,1),d=this.safeValue(e,8)?"sell":"buy",c=this.safeString(e,4);else{r=this.safeInteger2(e,"TradeTimeMS","ReceiveTime"),a=this.safeString(e,"TradeId"),c=this.safeString2(e,"OrderId","OrigOrderId"),o=this.safeString2(e,"InstrumentId","Instrument"),s=this.safeString(e,"Price"),i=this.safeString(e,"Quantity"),n=this.safeString2(e,"Value","GrossValueExecuted"),u=this.safeStringLower(e,"MakerTaker"),d=this.safeStringLower(e,"Side"),l=this.safeStringLower(e,"OrderType");const m=this.safeString(e,"Fee");if(m!==void 0){const g=this.safeString(e,"FeeProductId"),y=this.safeCurrencyCode(g);h={cost:m,currency:y}}}const p=this.safeSymbol(o,t);return this.safeTrade({info:e,id:a,symbol:p,timestamp:r,datetime:this.iso8601(r),order:c,type:l,side:d,takerOrMaker:u,price:s,amount:i,cost:n,fee:h},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){const n=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const r=this.market(e),a={omsId:n,InstrumentId:r.id};s!==void 0&&(a.Count=s);const o=await this.publicGetGetLastTrades(this.extend(a,i));return this.parseTrades(o,r,t,s)}async fetchAccounts(e={}){if(!this.login)throw new Ha(this.id+" fetchAccounts() requires exchange.login email credential");const t=this.safeInteger(this.options,"omsId",1);this.checkRequiredCredentials();const s={omsId:t,UserId:this.uid,UserName:this.login},i=await this.privateGetGetUserAccounts(this.extend(s,e)),n=[];for(let r=0;r<i.length;r++){const a=this.safeString(i,r);n.push({id:a,type:void 0,currency:void 0,info:a})}return n}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"ProductId");if(n in this.currencies_by_id){const r=this.safeCurrencyCode(n),a=this.account();a.total=this.safeString(i,"Amount"),a.used=this.safeString(i,"Hold"),t[r]=a}}return this.safeBalance(t)}async fetchBalance(e={}){const t=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const s=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),i=this.safeInteger2(e,"accountId","AccountId",s);e=this.omit(e,["accountId","AccountId"]);const n={omsId:t,AccountId:i},r=await this.privateGetGetAccountPositions(this.extend(n,e));return this.parseBalance(r)}parseLedgerEntryType(e){const t={Trade:"trade",Deposit:"transaction",Withdraw:"transaction",Transfer:"transfer",OrderHold:"trade",WithdrawHold:"transaction",DepositHold:"transaction",MarginHold:"trade",ManualHold:"trade",ManualEntry:"trade",MarginAcquisition:"trade",MarginRelinquish:"trade",MarginQuoteHold:"trade"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"TransactionId"),i=this.safeString(e,"AccountId"),n=this.safeString(e,"ReferenceId"),r=this.safeString(e,"Counterparty"),a=this.parseLedgerEntryType(this.safeString(e,"ReferenceType")),o=this.safeString(e,"ProductId"),d=this.safeCurrencyCode(o,t),c=this.safeNumber(e,"CR"),u=this.safeNumber(e,"DR");let h,l;c>0?(h=c,l="in"):u>0&&(h=u,l="out");const p=this.safeInteger(e,"TimeStamp");let m;const g=this.safeNumber(e,"Balance");return l==="out"?m=this.sum(g,h):l==="in"&&(m=Math.max(0,g-h)),{info:e,id:s,direction:l,account:i,referenceId:n,referenceAccount:r,type:a,currency:d,amount:h,before:m,after:g,status:"ok",timestamp:p,datetime:this.iso8601(p),fee:void 0}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const r=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),a=this.safeInteger2(i,"accountId","AccountId",r);i=this.omit(i,["accountId","AccountId"]);const o={omsId:n,AccountId:a};s!==void 0&&(o.Depth=s);const d=await this.privateGetGetAccountTransactions(this.extend(o,i));let c;return e!==void 0&&(c=this.currency(e)),this.parseLedger(d,c,t,s)}parseOrderStatus(e){const t={Accepted:"open",Rejected:"rejected",Working:"open",Canceled:"canceled",Expired:"expired",FullyExecuted:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"ReceiveTime"),i=this.safeString(e,"Instrument");return this.safeOrder({id:this.safeString2(e,"ReplacementOrderId","OrderId"),clientOrderId:this.safeString2(e,"ReplacementClOrdId","ClientOrderId"),info:e,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:this.safeInteger(e,"LastUpdatedTime"),status:this.parseOrderStatus(this.safeString(e,"OrderState")),symbol:this.safeSymbol(i,t),type:this.safeStringLower(e,"OrderType"),timeInForce:void 0,postOnly:void 0,side:this.safeStringLower(e,"Side"),price:this.safeString(e,"Price"),stopPrice:this.parseNumber(this.omitZero(this.safeString(e,"StopPrice"))),cost:this.safeString(e,"GrossValueExecuted"),amount:this.safeString(e,"OrigQuantity"),filled:this.safeString(e,"QuantityExecuted"),average:this.safeString(e,"AvgPrice"),remaining:void 0,fee:void 0,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){const a=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const o=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),d=this.safeInteger2(r,"accountId","AccountId",o),c=this.safeInteger2(r,"ClientOrderId","clientOrderId");r=this.omit(r,["accountId","AccountId","clientOrderId","ClientOrderId"]);const u=this.market(e),h=s==="buy"?0:1,l={InstrumentId:parseInt(u.id),omsId:a,AccountId:d,TimeInForce:1,Side:h,Quantity:parseFloat(this.amountToPrecision(e,i)),OrderType:this.safeInteger(this.options.orderTypes,this.capitalize(t))};n!==void 0&&(l.LimitPrice=parseFloat(this.priceToPrecision(e,n))),c!==void 0&&(l.ClientOrderId=c);const p=await this.privatePostSendOrder(this.extend(l,r));return this.parseOrder(p,u)}async editOrder(e,t,s,i,n,r=void 0,a={}){const o=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const d=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),c=this.safeInteger2(a,"accountId","AccountId",d),u=this.safeInteger2(a,"ClientOrderId","clientOrderId");a=this.omit(a,["accountId","AccountId","clientOrderId","ClientOrderId"]);const h=this.market(t),l=i==="buy"?0:1,p={OrderIdToReplace:parseInt(e),InstrumentId:parseInt(h.id),omsId:o,AccountId:c,TimeInForce:1,Side:l,Quantity:parseFloat(this.amountToPrecision(t,n)),OrderType:this.safeInteger(this.options.orderTypes,this.capitalize(s))};r!==void 0&&(p.LimitPrice=parseFloat(this.priceToPrecision(t,r))),u!==void 0&&(p.ClientOrderId=u);const m=await this.privatePostCancelReplaceOrder(this.extend(p,a));return this.parseOrder(m,h)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const r=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),a=this.safeInteger2(i,"accountId","AccountId",r);i=this.omit(i,["accountId","AccountId"]);const o={omsId:n,AccountId:a};let d;e!==void 0&&(d=this.market(e),o.InstrumentId=d.id),t!==void 0&&(o.StartTimeStamp=parseInt(t/1e3)),s!==void 0&&(o.Depth=s);const c=await this.privateGetGetTradesHistory(this.extend(o,i));return this.parseTrades(c,d,t,s)}async cancelAllOrders(e=void 0,t={}){const s=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const i=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),n=this.safeInteger2(t,"accountId","AccountId",i);t=this.omit(t,["accountId","AccountId"]);const r={omsId:s,AccountId:n};if(e!==void 0){const o=this.market(e);r.IntrumentId=o.id}return await this.privatePostCancelAllOrders(this.extend(r,t))}async cancelOrder(e,t=void 0,s={}){const i=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();let n;t!==void 0&&(n=this.market(t));const r={omsId:i},a=this.safeInteger2(s,"clientOrderId","ClOrderId");a!==void 0?r.ClOrderId=a:r.OrderId=parseInt(e),s=this.omit(s,["clientOrderId","ClOrderId"]);const o=await this.privatePostCancelOrder(this.extend(r,s)),d=this.parseOrder(o,n);return this.extend(d,{id:e,clientOrderId:a})}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const r=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),a=this.safeInteger2(i,"accountId","AccountId",r);i=this.omit(i,["accountId","AccountId"]);let o;e!==void 0&&(o=this.market(e));const d={omsId:n,AccountId:a},c=await this.privateGetGetOpenOrders(this.extend(d,i));return this.parseOrders(c,o,t,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const r=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),a=this.safeInteger2(i,"accountId","AccountId",r);i=this.omit(i,["accountId","AccountId"]);const o={omsId:n,AccountId:a};let d;e!==void 0&&(d=this.market(e),o.InstrumentId=d.id),t!==void 0&&(o.StartTimeStamp=parseInt(t/1e3)),s!==void 0&&(o.Depth=s);const c=await this.privateGetGetOrdersHistory(this.extend(o,i));return this.parseOrders(c,d,t,s)}async fetchOrder(e,t=void 0,s={}){const i=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const n=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),r=this.safeInteger2(s,"accountId","AccountId",n);s=this.omit(s,["accountId","AccountId"]);let a;t!==void 0&&(a=this.market(t));const o={omsId:i,AccountId:r,OrderId:parseInt(e)},d=await this.privateGetGetOrderStatus(this.extend(o,s));return this.parseOrder(d,a)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){const r=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();let a;t!==void 0&&(a=this.market(t));const o={OMSId:parseInt(r),OrderId:parseInt(e)},d=await this.privatePostGetOrderHistoryByOrderId(this.extend(o,n)),c=this.groupBy(d,"ChangeReason"),u=this.safeValue(c,"Trade",[]);return this.parseTrades(u,a,s,i)}async fetchDepositAddress(e,t={}){const s=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const i=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),n=this.safeInteger2(t,"accountId","AccountId",i);t=this.omit(t,["accountId","AccountId"]);const r=this.currency(e),a={omsId:s,AccountId:n,ProductId:r.id,GenerateNewKey:!1},o=await this.privateGetGetDepositInfo(this.extend(a,t));return this.parseDepositAddress(o,r)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"DepositInfo"),i=JSON.parse(s),n=i.length,a=this.safeString(i,n-1).split("?memo="),o=this.safeString(a,0),d=this.safeString(a,1);let c;return t!==void 0&&(c=t.code),this.checkAddress(o),{currency:c,address:o,tag:d,network:void 0,info:e}}async createDepositAddress(e,t={}){const s={GenerateNewKey:!0};return await this.fetchDepositAddress(e,this.extend(s,t))}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const r=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),a=this.safeInteger2(i,"accountId","AccountId",r);i=this.omit(i,["accountId","AccountId"]);let o;e!==void 0&&(o=this.currency(e));const d={omsId:n,AccountId:a},c=await this.privateGetGetDeposits(this.extend(d,i));return this.parseTransactions(c,o,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const r=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),a=this.safeInteger2(i,"accountId","AccountId",r);i=this.omit(i,["accountId","AccountId"]);let o;e!==void 0&&(o=this.currency(e));const d={omsId:n,AccountId:a},c=await this.privateGetGetWithdraws(this.extend(d,i));return this.parseTransactions(c,o,t,s)}parseTransactionStatusByType(e,t=void 0){const s={deposit:{New:"pending",AdminProcessing:"pending",Accepted:"pending",Rejected:"rejected",SystemProcessing:"pending",FullyProcessed:"ok",Failed:"failed",Pending:"pending",Confirmed:"pending",AmlProcessing:"pending",AmlAccepted:"pending",AmlRejected:"rejected",AmlFailed:"failed",LimitsAccepted:"pending",LimitsRejected:"rejected"},withdrawal:{New:"pending",AdminProcessing:"pending",Accepted:"pending",Rejected:"rejected",SystemProcessing:"pending",FullyProcessed:"ok",Failed:"failed",Pending:"pending",Pending2Fa:"pending",AutoAccepted:"pending",Delayed:"pending",UserCanceled:"canceled",AdminCanceled:"canceled",AmlProcessing:"pending",AmlAccepted:"pending",AmlRejected:"rejected",AmlFailed:"failed",LimitsAccepted:"pending",LimitsRejected:"rejected",Submitted:"pending",Confirmed:"pending",ManuallyConfirmed:"pending",Confirmed2Fa:"pending"}},i=this.safeValue(s,t,{});return this.safeString(i,e,e)}parseTransaction(e,t=void 0){let s,i;const n=this.safeString(e,"ProductId"),r=this.safeCurrencyCode(n,t);let a,o;"DepositId"in e?(s=this.safeString(e,"DepositId"),o="deposit"):"WithdrawId"in e&&(s=this.safeString(e,"WithdrawId"),o="withdrawal");const d=this.safeString(e,"TemplateForm");let c,u=this.safeInteger(e,"LastUpdateTimeStamp");if(d!==void 0){const y=JSON.parse(d);c=this.safeString(y,"ExternalAddress"),i=this.safeString(y,"TxId"),a=this.safeInteger(y,"TimeSubmitted"),u=this.safeInteger(y,"LastUpdated",u)}const h=c,l=this.parseTransactionStatusByType(this.safeString(e,"TicketStatus"),o),p=this.safeNumber(e,"Amount"),m=this.safeNumber(e,"FeeAmount");let g;return m!==void 0&&(g={currency:r,cost:m}),{info:e,id:s,txid:i,timestamp:a,datetime:this.iso8601(a),address:c,addressTo:h,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:o,amount:p,currency:r,status:l,updated:u,fee:g}}async withdraw(e,t,s,i=void 0,n={}){if([i,n]=this.handleWithdrawTagAndParams(i,n),this.safeString(this.options,"sessionToken")===void 0)throw new Ha(this.id+" call signIn() method to obtain a session token");if(this.twofa===void 0)throw new Ha(this.id+" withdraw() requires exchange.twofa credentials");this.checkAddress(s);const a=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const o=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),d=this.safeInteger2(n,"accountId","AccountId",o);n=this.omit(n,["accountId","AccountId"]);const c=this.currency(e),u={omsId:a,AccountId:d,ProductId:c.id},h=await this.privateGetGetWithdrawTemplateTypes(u),l=this.safeValue(h,"TemplateTypes",[]),p=this.safeValue(l,0);if(p===void 0)throw new Ff(this.id+" withdraw() could not find a withdraw template type for "+c.code);const m=this.safeString(p,"TemplateName"),g={omsId:a,AccountId:d,ProductId:c.id,TemplateType:m,AccountProviderId:p.AccountProviderId},y=await this.privateGetGetWithdrawTemplate(g),b=this.safeString(y,"Template");if(b===void 0)throw new Ff(this.id+" withdraw() could not find a withdraw template for "+c.code);const w=JSON.parse(b);w.ExternalAddress=s,i!==void 0&&"Memo"in w&&(w.Memo=i);const k={omsId:a,AccountId:d,ProductId:c.id,TemplateForm:this.json(w),TemplateType:m},T={TfaType:"Google",TFaCode:this.oath(),Payload:this.json(k)},O=await this.privatePostCreateWithdrawTicket(this.deepExtend(T,n));return this.parseTransaction(O,c)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/"+this.implodeParams(e,i),o=this.omit(i,this.extractParams(e));if(t==="public"){if(e==="Authenticate"){const d=this.login+":"+this.password,c=this.stringToBase64(d);n={Authorization:"Basic "+this.decode(c)}}else if(e==="Authenticate2FA"){const d=this.safeString(this.options,"pending2faToken");d!==void 0&&(n={Pending2FaToken:d},o=this.omit(o,"pending2faToken"))}Object.keys(o).length&&(a+="?"+this.urlencode(o))}else if(t==="private"){this.checkRequiredCredentials();const d=this.safeString(this.options,"sessionToken");if(d===void 0){const c=this.nonce().toString(),u=c+this.uid+this.apiKey,h=this.hmac(this.encode(u),this.encode(this.secret));n={Nonce:c,APIKey:this.apiKey,Signature:h,UserId:this.uid}}else n={APToken:d};s==="POST"?(n["Content-Type"]="application/json",r=this.json(o)):Object.keys(o).length&&(a+="?"+this.urlencode(o))}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(e===404)throw new Ha(this.id+" "+r);if(a===void 0)return;const c=this.safeString(a,"errormsg");if(c!==void 0&&c!==""){const u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,r,u),new Ff(u)}}};const VF=jl;var qF=class extends VF{describe(){return this.deepExtend(super.describe(),{id:"flowbtc",name:"flowBTC",countries:["BR"],rateLimit:1e3,urls:{logo:"https://user-images.githubusercontent.com/51840849/87443317-01c0d080-c5fe-11ea-95c2-9ebe1a8fafd9.jpg",api:{public:"https://api.flowbtc.com.br:8443/ap/",private:"https://api.flowbtc.com.br:8443/ap/"},www:"https://www.flowbtc.com.br",doc:"https://www.flowbtc.com.br/api.html"},fees:{trading:{tierBased:!1,percentage:!0,maker:.0025,taker:.005}}})}};const LF=ge,Ke=Se,{TICK_SIZE:RF}=me,{ExchangeError:ht,BadRequest:Oi,ArgumentsRequired:yr,AuthenticationError:Do,PermissionDenied:sv,AccountSuspended:iv,InsufficientFunds:Cc,RateLimitExceeded:FF,ExchangeNotAvailable:Df,BadSymbol:Mc,InvalidOrder:rs,OrderNotFound:Hf,NotSupported:DF,AccountNotEnabled:HF,OrderImmediatelyFillable:nv}=de;var Pb=class extends LF{describe(){return this.deepExtend(super.describe(),{id:"gate",name:"Gate.io",countries:["KR"],rateLimit:10/3,version:"v4",certified:!0,pro:!0,urls:{logo:"https://user-images.githubusercontent.com/1294454/31784029-0313c702-b509-11e7-9ccc-bc0da6a0e435.jpg",doc:"https://www.gate.io/docs/apiv4/en/index.html",www:"https://gate.io/",api:{public:{wallet:"https://api.gateio.ws/api/v4",futures:"https://api.gateio.ws/api/v4",margin:"https://api.gateio.ws/api/v4",delivery:"https://api.gateio.ws/api/v4",spot:"https://api.gateio.ws/api/v4",options:"https://api.gateio.ws/api/v4",sub_accounts:"https://api.gateio.ws/api/v4"},private:{withdrawals:"https://api.gateio.ws/api/v4",wallet:"https://api.gateio.ws/api/v4",futures:"https://api.gateio.ws/api/v4",margin:"https://api.gateio.ws/api/v4",delivery:"https://api.gateio.ws/api/v4",spot:"https://api.gateio.ws/api/v4",options:"https://api.gateio.ws/api/v4",subAccounts:"https://api.gateio.ws/api/v4"}},test:{public:{futures:"https://fx-api-testnet.gateio.ws/api/v4",delivery:"https://fx-api-testnet.gateio.ws/api/v4"},private:{futures:"https://fx-api-testnet.gateio.ws/api/v4",delivery:"https://fx-api-testnet.gateio.ws/api/v4"}},referral:{url:"https://www.gate.io/ref/2436035",discount:.2}},has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!0,option:void 0,borrowMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createMarketOrder:!1,createOrder:!0,createPostOnlyOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!1,createStopOrder:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!0,fetchLeverage:!1,fetchLeverageTiers:!0,fetchMarginMode:!1,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchNetworkDepositAddress:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransactionFees:!0,fetchWithdrawals:!0,repayMargin:!0,setLeverage:!0,setMarginMode:!1,transfer:!0,withdraw:!0},api:{public:{wallet:{get:{currency_chains:1.5}},spot:{get:{currencies:1,"currencies/{currency}":1,currency_pairs:1,"currency_pairs/{currency_pair}":1,tickers:1,order_book:1,trades:1,candlesticks:1}},margin:{get:{currency_pairs:1,"currency_pairs/{currency_pair}":1,"cross/currencies":1,"cross/currencies/{currency}":1,funding_book:1}},futures:{get:{"{settle}/contracts":1.5,"{settle}/contracts/{contract}":1.5,"{settle}/order_book":1.5,"{settle}/trades":1.5,"{settle}/candlesticks":1.5,"{settle}/tickers":1.5,"{settle}/funding_rate":1.5,"{settle}/insurance":1.5,"{settle}/contract_stats":1.5,"{settle}/liq_orders":1.5}},delivery:{get:{"{settle}/contracts":1.5,"{settle}/contracts/{contract}":1.5,"{settle}/order_book":1.5,"{settle}/trades":1.5,"{settle}/candlesticks":1.5,"{settle}/tickers":1.5,"{settle}/insurance":1.5}},options:{get:{underlyings:1.5,expirations:1.5,contracts:1.5,"contracts/{contract}":1.5,settlements:1.5,"settlements/{contract}":1.5,order_book:1.5,tickers:1.5,"underlying/tickers/{underlying}":1.5,candlesticks:1.5,"underlying/candlesticks":1.5,trades:1.5}}},private:{withdrawals:{post:{withdrawals:3e3},delete:{"withdrawals/{withdrawal_id}":300}},wallet:{get:{deposit_address:300,withdrawals:300,deposits:300,sub_account_transfers:300,withdraw_status:300,sub_account_balances:300,fee:300,total_balance:300},post:{transfers:300,sub_account_transfers:300}},subAccounts:{get:{sub_accounts:1,"sub_accounts/{user_id}":1,"sub_accounts/{user_id}/keys":1,"sub_accounts/{user_id}/keys/{key}":1},post:{sub_accounts:1,"sub_accounts/{user_id}/keys":1,"sub_accounts/{user_id}/lock":1,"sub_accounts/{user_id}/unlock":1},put:{"sub_accounts/{user_id}/keys/{key}":1},delete:{"sub_accounts/{user_id}/keys/{key}":1}},spot:{get:{accounts:1,open_orders:1,orders:1,"orders/{order_id}":1,my_trades:1,price_orders:1,"price_orders/{order_id}":1},post:{batch_orders:1,orders:1,cancel_batch_orders:1,price_orders:1},delete:{orders:1,"orders/{order_id}":1,price_orders:1,"price_orders/{order_id}":1}},margin:{get:{accounts:1.5,account_book:1.5,funding_accounts:1.5,loans:1.5,"loans/{loan_id}":1.5,"loans/{loan_id}/repayment":1.5,loan_records:1.5,"loan_records/{load_record_id}":1.5,auto_repay:1.5,transferable:1.5,"cross/accounts":1.5,"cross/account_book":1.5,"cross/loans":1.5,"cross/loans/{loan_id}":1.5,"cross/loans/repayments":1.5,"cross/transferable":1.5,"loan_records/{loan_record_id}":1.5,borrowable:1.5,"cross/repayments":1.5,"cross/borrowable":1.5},post:{loans:1.5,merged_loans:1.5,"loans/{loan_id}/repayment":1.5,auto_repay:1.5,"cross/loans":1.5,"cross/loans/repayments":1.5,"cross/repayments":1.5},patch:{"loans/{loan_id}":1.5,"loan_records/{loan_record_id}":1.5},delete:{"loans/{loan_id}":1.5}},futures:{get:{"{settle}/accounts":1.5,"{settle}/account_book":1.5,"{settle}/positions":1.5,"{settle}/positions/{contract}":1.5,"{settle}/orders":1.5,"{settle}/orders/{order_id}":1.5,"{settle}/my_trades":1.5,"{settle}/position_close":1.5,"{settle}/liquidates":1.5,"{settle}/price_orders":1.5,"{settle}/price_orders/{order_id}":1.5,"{settle}/dual_comp/positions/{contract}":1.5},post:{"{settle}/positions/{contract}/margin":1.5,"{settle}/positions/{contract}/leverage":1.5,"{settle}/positions/{contract}/risk_limit":1.5,"{settle}/dual_mode":1.5,"{settle}/dual_comp/positions/{contract}":1.5,"{settle}/dual_comp/positions/{contract}/margin":1.5,"{settle}/dual_comp/positions/{contract}/leverage":1.5,"{settle}/dual_comp/positions/{contract}/risk_limit":1.5,"{settle}/orders":1.5,"{settle}/price_orders":1.5},delete:{"{settle}/orders":1.5,"{settle}/orders/{order_id}":1.5,"{settle}/price_orders":1.5,"{settle}/price_orders/{order_id}":1.5}},delivery:{get:{"{settle}/accounts":1.5,"{settle}/account_book":1.5,"{settle}/positions":1.5,"{settle}/positions/{contract}":1.5,"{settle}/orders":1.5,"{settle}/orders/{order_id}":1.5,"{settle}/my_trades":1.5,"{settle}/position_close":1.5,"{settle}/liquidates":1.5,"{settle}/price_orders":1.5,"{settle}/price_orders/{order_id}":1.5,"{settle}/settlements":1.5},post:{"{settle}/positions/{contract}/margin":1.5,"{settle}/positions/{contract}/leverage":1.5,"{settle}/positions/{contract}/risk_limit":1.5,"{settle}/orders":1.5,"{settle}/price_orders":1.5},delete:{"{settle}/orders":1.5,"{settle}/orders/{order_id}":1.5,"{settle}/price_orders":1.5,"{settle}/price_orders/{order_id}":1.5}},options:{get:{accounts:1.5,account_book:1.5,positions:1.5,"positions/{contract}":1.5,position_close:1.5,orders:1.5,"orders/{order_id}":1.5,my_trades:1.5},post:{orders:1.5},delete:{orders:1.5,"orders/{order_id}":1.5}}}},timeframes:{"10s":"10s","1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","8h":"8h","1d":"1d","7d":"7d","1w":"7d"},commonCurrencies:{"88MPH":"MPH",AXIS:"Axis DeFi",BIFI:"Bitcoin File",BOX:"DefiBox",BTCBEAR:"BEAR",BTCBULL:"BULL",BYN:"BeyondFi",EGG:"Goose Finance",GTC:"Game.com",GTC_HT:"Game.com HT",GTC_BSC:"Game.com BSC",HIT:"HitChain",MM:"Million",MPH:"Morpher",POINT:"GatePoint",RAI:"Rai Reflex Index",SBTC:"Super Bitcoin",TNC:"Trinity Network Credit",TON:"TONToken",VAI:"VAIOT"},requiredCredentials:{apiKey:!0,secret:!0},headers:{"X-Gate-Channel-Id":"ccxt"},options:{createOrder:{expiration:86400},networks:{TRC20:"TRX",ERC20:"ETH",BEP20:"BSC"},timeInForce:{GTC:"gtc",IOC:"ioc",PO:"poc",POC:"poc"},accountsByType:{funding:"spot",spot:"spot",margin:"margin",cross_margin:"cross_margin",cross:"cross_margin",isolated:"margin",swap:"futures",future:"delivery",futures:"futures",delivery:"delivery"},defaultType:"spot",swap:{fetchMarkets:{settlementCurrencies:["usdt","btc"]}},future:{fetchMarkets:{settlementCurrencies:["usdt","btc"]}}},precisionMode:RF,fees:{trading:{tierBased:!0,feeSide:"get",percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002"),tiers:{maker:[[this.parseNumber("0"),this.parseNumber("0.002")],[this.parseNumber("1.5"),this.parseNumber("0.00185")],[this.parseNumber("3"),this.parseNumber("0.00175")],[this.parseNumber("6"),this.parseNumber("0.00165")],[this.parseNumber("12.5"),this.parseNumber("0.00155")],[this.parseNumber("25"),this.parseNumber("0.00145")],[this.parseNumber("75"),this.parseNumber("0.00135")],[this.parseNumber("200"),this.parseNumber("0.00125")],[this.parseNumber("500"),this.parseNumber("0.00115")],[this.parseNumber("1250"),this.parseNumber("0.00105")],[this.parseNumber("2500"),this.parseNumber("0.00095")],[this.parseNumber("3000"),this.parseNumber("0.00085")],[this.parseNumber("6000"),this.parseNumber("0.00075")],[this.parseNumber("11000"),this.parseNumber("0.00065")],[this.parseNumber("20000"),this.parseNumber("0.00055")],[this.parseNumber("40000"),this.parseNumber("0.00055")],[this.parseNumber("75000"),this.parseNumber("0.00055")]],taker:[[this.parseNumber("0"),this.parseNumber("0.002")],[this.parseNumber("1.5"),this.parseNumber("0.00195")],[this.parseNumber("3"),this.parseNumber("0.00185")],[this.parseNumber("6"),this.parseNumber("0.00175")],[this.parseNumber("12.5"),this.parseNumber("0.00165")],[this.parseNumber("25"),this.parseNumber("0.00155")],[this.parseNumber("75"),this.parseNumber("0.00145")],[this.parseNumber("200"),this.parseNumber("0.00135")],[this.parseNumber("500"),this.parseNumber("0.00125")],[this.parseNumber("1250"),this.parseNumber("0.00115")],[this.parseNumber("2500"),this.parseNumber("0.00105")],[this.parseNumber("3000"),this.parseNumber("0.00095")],[this.parseNumber("6000"),this.parseNumber("0.00085")],[this.parseNumber("11000"),this.parseNumber("0.00075")],[this.parseNumber("20000"),this.parseNumber("0.00065")],[this.parseNumber("40000"),this.parseNumber("0.00065")],[this.parseNumber("75000"),this.parseNumber("0.00065")]]}},swap:{tierBased:!0,feeSide:"base",percentage:!0,maker:this.parseNumber("0.0"),taker:this.parseNumber("0.0005"),tiers:{maker:[[this.parseNumber("0"),this.parseNumber("0.0000")],[this.parseNumber("1.5"),this.parseNumber("-0.00005")],[this.parseNumber("3"),this.parseNumber("-0.00005")],[this.parseNumber("6"),this.parseNumber("-0.00005")],[this.parseNumber("12.5"),this.parseNumber("-0.00005")],[this.parseNumber("25"),this.parseNumber("-0.00005")],[this.parseNumber("75"),this.parseNumber("-0.00005")],[this.parseNumber("200"),this.parseNumber("-0.00005")],[this.parseNumber("500"),this.parseNumber("-0.00005")],[this.parseNumber("1250"),this.parseNumber("-0.00005")],[this.parseNumber("2500"),this.parseNumber("-0.00005")],[this.parseNumber("3000"),this.parseNumber("-0.00008")],[this.parseNumber("6000"),this.parseNumber("-0.01000")],[this.parseNumber("11000"),this.parseNumber("-0.01002")],[this.parseNumber("20000"),this.parseNumber("-0.01005")],[this.parseNumber("40000"),this.parseNumber("-0.02000")],[this.parseNumber("75000"),this.parseNumber("-0.02005")]],taker:[[this.parseNumber("0"),this.parseNumber("0.00050")],[this.parseNumber("1.5"),this.parseNumber("0.00048")],[this.parseNumber("3"),this.parseNumber("0.00046")],[this.parseNumber("6"),this.parseNumber("0.00044")],[this.parseNumber("12.5"),this.parseNumber("0.00042")],[this.parseNumber("25"),this.parseNumber("0.00040")],[this.parseNumber("75"),this.parseNumber("0.00038")],[this.parseNumber("200"),this.parseNumber("0.00036")],[this.parseNumber("500"),this.parseNumber("0.00034")],[this.parseNumber("1250"),this.parseNumber("0.00032")],[this.parseNumber("2500"),this.parseNumber("0.00030")],[this.parseNumber("3000"),this.parseNumber("0.00030")],[this.parseNumber("6000"),this.parseNumber("0.00030")],[this.parseNumber("11000"),this.parseNumber("0.00030")],[this.parseNumber("20000"),this.parseNumber("0.00030")],[this.parseNumber("40000"),this.parseNumber("0.00030")],[this.parseNumber("75000"),this.parseNumber("0.00030")]]}}},exceptions:{exact:{INVALID_PARAM_VALUE:Oi,INVALID_PROTOCOL:Oi,INVALID_ARGUMENT:Oi,INVALID_REQUEST_BODY:Oi,MISSING_REQUIRED_PARAM:yr,BAD_REQUEST:Oi,INVALID_CONTENT_TYPE:Oi,NOT_ACCEPTABLE:Oi,METHOD_NOT_ALLOWED:Oi,NOT_FOUND:ht,INVALID_CREDENTIALS:Do,INVALID_KEY:Do,IP_FORBIDDEN:Do,READ_ONLY:sv,INVALID_SIGNATURE:Do,MISSING_REQUIRED_HEADER:Do,REQUEST_EXPIRED:Do,ACCOUNT_LOCKED:iv,FORBIDDEN:sv,SUB_ACCOUNT_NOT_FOUND:ht,SUB_ACCOUNT_LOCKED:iv,MARGIN_BALANCE_EXCEPTION:ht,MARGIN_TRANSFER_FAILED:ht,TOO_MUCH_FUTURES_AVAILABLE:ht,FUTURES_BALANCE_NOT_ENOUGH:Cc,ACCOUNT_EXCEPTION:ht,SUB_ACCOUNT_TRANSFER_FAILED:ht,ADDRESS_NOT_USED:ht,TOO_FAST:FF,WITHDRAWAL_OVER_LIMIT:ht,API_WITHDRAW_DISABLED:Df,INVALID_WITHDRAW_ID:ht,INVALID_WITHDRAW_CANCEL_STATUS:ht,INVALID_PRECISION:rs,INVALID_CURRENCY:Mc,INVALID_CURRENCY_PAIR:Mc,POC_FILL_IMMEDIATELY:nv,ORDER_NOT_FOUND:Hf,CLIENT_ID_NOT_FOUND:Hf,ORDER_CLOSED:rs,ORDER_CANCELLED:rs,QUANTITY_NOT_ENOUGH:rs,BALANCE_NOT_ENOUGH:Cc,MARGIN_NOT_SUPPORTED:rs,MARGIN_BALANCE_NOT_ENOUGH:Cc,AMOUNT_TOO_LITTLE:rs,AMOUNT_TOO_MUCH:rs,REPEATED_CREATION:rs,LOAN_NOT_FOUND:Hf,LOAN_RECORD_NOT_FOUND:Hf,NO_MATCHED_LOAN:ht,NOT_MERGEABLE:ht,NO_CHANGE:ht,REPAY_TOO_MUCH:ht,TOO_MANY_CURRENCY_PAIRS:rs,TOO_MANY_ORDERS:rs,MIXED_ACCOUNT_TYPE:rs,AUTO_BORROW_TOO_MUCH:ht,TRADE_RESTRICTED:Cc,USER_NOT_FOUND:HF,CONTRACT_NO_COUNTER:ht,CONTRACT_NOT_FOUND:Mc,RISK_LIMIT_EXCEEDED:ht,INSUFFICIENT_AVAILABLE:Cc,LIQUIDATE_IMMEDIATELY:rs,LEVERAGE_TOO_HIGH:rs,LEVERAGE_TOO_LOW:rs,ORDER_NOT_OWNED:ht,ORDER_FINISHED:ht,POSITION_CROSS_MARGIN:ht,POSITION_IN_LIQUIDATION:ht,POSITION_IN_CLOSE:ht,POSITION_EMPTY:rs,REMOVE_TOO_MUCH:ht,RISK_LIMIT_NOT_MULTIPLE:ht,RISK_LIMIT_TOO_HIGH:ht,RISK_LIMIT_TOO_lOW:ht,PRICE_TOO_DEVIATED:rs,SIZE_TOO_LARGE:rs,SIZE_TOO_SMALL:rs,PRICE_OVER_LIQUIDATION:rs,PRICE_OVER_BANKRUPT:rs,ORDER_POC_IMMEDIATE:nv,INCREASE_POSITION:rs,CONTRACT_IN_DELISTING:ht,INTERNAL:Df,SERVER_ERROR:Df,TOO_BUSY:Df,CROSS_ACCOUNT_NOT_FOUND:ht,RISK_LIMIT_TOO_LOW:Oi}},broad:{}})}async fetchMarkets(e={}){let t=[];const[s,i]=this.handleMarketTypeAndParams("fetchMarkets",void 0,e);if((s==="spot"||s==="margin")&&(t=await this.fetchSpotMarkets(i)),(s==="swap"||s==="future")&&(t=await this.fetchContractMarkets(i)),s==="option"&&(t=await this.fetchOptionMarkets(i)),t.length===0)throw new ht(this.id+" does not support '"+s+"' type, set exchange.options['defaultType'] to 'spot', 'margin', 'swap', 'future' or 'option'");return t}async fetchSpotMarkets(e){const t=await this.publicMarginGetCurrencyPairs(e),s=await this.publicSpotGetCurrencyPairs(e),i=this.indexBy(t,"id"),n=[];for(let r=0;r<s.length;r++){const a=s[r],o=this.safeString(a,"id"),d=this.safeValue(i,o),c=this.deepExtend(d,a),[u,h]=o.split("_"),l=this.safeCurrencyCode(u),p=this.safeCurrencyCode(h),m=this.safeString(c,"fee"),g=this.safeString(c,"maker_fee_rate",m),y=this.parseNumber(this.parsePrecision(this.safeString(c,"amount_precision"))),b=this.safeString(c,"trade_status"),k=this.safeNumber(c,"leverage")!==void 0;n.push({id:o,symbol:l+"/"+p,base:l,quote:p,settle:void 0,baseId:u,quoteId:h,settleId:void 0,type:"spot",spot:!0,margin:k,swap:!1,future:!1,option:!1,active:b==="tradable",contract:!1,linear:void 0,inverse:void 0,taker:this.parseNumber(Ke.stringDiv(m,"100")),maker:this.parseNumber(Ke.stringDiv(g,"100")),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:y,price:this.parseNumber(this.parsePrecision(this.safeString(c,"precision")))},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(c,"leverage",1)},amount:{min:this.safeNumber(a,"min_base_amount",y),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(c,"min_quote_amount"),max:k?this.safeNumber(c,"max_quote_amount"):void 0}},info:c})}return n}async fetchContractMarkets(e){const t=[],s=this.getSettlementCurrencies("swap","fetchMarkets"),i=this.getSettlementCurrencies("future","fetchMarkets");for(let n=0;n<s.length;n++){const r=s[n],a=e;a.settle=r;const o=await this.publicFuturesGetSettleContracts(a);for(let d=0;d<o.length;d++){const c=this.parseContractMarket(o[d],r);t.push(c)}}for(let n=0;n<i.length;n++){const r=i[n],a=e;a.settle=r;const o=await this.publicDeliveryGetSettleContracts(a);for(let d=0;d<o.length;d++){const c=this.parseContractMarket(o[d],r);t.push(c)}}return t}parseContractMarket(e,t){const s=this.safeString(e,"name"),i=s.split("_"),n=this.safeString(i,0),r=this.safeString(i,1),a=this.safeString(i,2),o=this.safeCurrencyCode(n),d=this.safeCurrencyCode(r),c=this.safeCurrencyCode(t),u=this.safeTimestamp(e,"expire_time");let h="",l="swap";a!==void 0?(h=o+"/"+d+":"+c+"-"+this.yymmdd(u,""),l="future"):h=o+"/"+d+":"+c;const p=this.safeString(e,"order_price_deviate"),m=this.safeString(e,"mark_price"),g=Ke.stringSub("1",p),y=Ke.stringAdd("1",p),b=Ke.stringMul(g,m),w=Ke.stringMul(y,m),k=this.safeString(e,"taker_fee_rate"),T=this.safeString(e,"maker_fee_rate",k),O=d===c;return{id:s,symbol:h,base:o,quote:d,settle:c,baseId:n,quoteId:r,settleId:t,type:l,spot:!1,margin:!1,swap:l==="swap",future:l==="future",option:l==="option",active:!0,contract:!0,linear:O,inverse:!O,taker:this.parseNumber(Ke.stringDiv(k,"100")),maker:this.parseNumber(Ke.stringDiv(T,"100")),contractSize:this.safeNumber(e,"quanto_multiplier"),expiry:u,expiryDatetime:this.iso8601(u),strike:void 0,optionType:void 0,precision:{amount:this.parseNumber("1"),price:this.safeNumber(e,"order_price_round")},limits:{leverage:{min:this.safeNumber(e,"leverage_min"),max:this.safeNumber(e,"leverage_max")},amount:{min:this.safeNumber(e,"order_size_min"),max:this.safeNumber(e,"order_size_max")},price:{min:this.parseNumber(b),max:this.parseNumber(w)},cost:{min:void 0,max:void 0}},info:e}}async fetchOptionMarkets(e={}){const t=[],s=await this.fetchOptionUnderlyings();for(let i=0;i<s.length;i++){const n=s[i],r=e;r.underlying=n;const a=await this.publicOptionsGetContracts(r);for(let o=0;o<a.length;o++){const d=a[o],c=this.safeString(d,"name"),u=n.split("_"),h=this.safeString(u,0),l=this.safeString(u,1),p=this.safeCurrencyCode(h),m=this.safeCurrencyCode(l);let g=p+"/"+m;const y=this.safeTimestamp(d,"expiration_time"),b=this.safeString(d,"strike_price"),w=this.safeValue(d,"is_call"),k=w?"C":"P",T=w?"call":"put";g=g+":"+m+"-"+this.yymmdd(y)+"-"+b+"-"+k;const O=this.safeString(d,"order_price_deviate"),x=this.safeString(d,"mark_price"),C=Ke.stringSub("1",O),E=Ke.stringAdd("1",O),P=Ke.stringMul(C,x),_=Ke.stringMul(E,x),S=this.safeString(d,"taker_fee_rate"),I=this.safeString(d,"maker_fee_rate",S);t.push({id:c,symbol:g,base:p,quote:m,settle:m,baseId:h,quoteId:l,settleId:l,type:"option",spot:!1,margin:!1,swap:!1,future:!1,option:!0,active:!0,contract:!0,linear:!0,inverse:!1,taker:this.parseNumber(Ke.stringDiv(S,"100")),maker:this.parseNumber(Ke.stringDiv(I,"100")),contractSize:this.parseNumber("1"),expiry:y,expiryDatetime:this.iso8601(y),strike:b,optionType:T,precision:{amount:this.parseNumber("1"),price:this.safeNumber(d,"order_price_round")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(d,"order_size_min"),max:this.safeNumber(d,"order_size_max")},price:{min:this.parseNumber(P),max:this.parseNumber(_)},cost:{min:void 0,max:void 0}},info:d})}}return t}async fetchOptionUnderlyings(){const e=await this.publicOptionsGetUnderlyings(),t=[];for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"name");n!==void 0&&t.push(n)}return t}prepareRequest(e=void 0,t=void 0,s={}){const i={};if(e!==void 0)e.contract?(i.contract=e.id,i.settle=e.settleId):i.currency_pair=e.id;else{const n=t==="swap";if(n||t==="future"){const a=n?"usdt":"btc",o=this.safeStringLower(s,"settle",a);s=this.omit(s,"settle"),i.settle=o}}return[i,s]}spotOrderPrepareRequest(e=void 0,t=!1,s={}){const[i,n]=this.getMarginMode(t,s),r={};if(!t){if(e===void 0)throw new yr(this.id+" spotOrderPrepareRequest() requires a market argument for non-stop orders");r.account=i,r.currency_pair=e.id}return[r,n]}multiOrderSpotPrepareRequest(e=void 0,t=!1,s={}){const[i,n]=this.getMarginMode(t,s),r={account:i};return e!==void 0&&(t?r.market=e.id:r.currency_pair=e.id),[r,n]}getMarginMode(e,t){const s=this.safeStringLower2(this.options,"defaultMarginMode","marginMode","spot");let i=this.safeStringLower2(t,"marginMode","account",s);if(t=this.omit(t,["marginMode","account"]),i==="cross"?i="cross_margin":i==="isolated"?i="margin":i===""&&(i="spot"),e&&(i==="spot"&&(i="normal"),i==="cross_margin"))throw new Oi(this.id+" getMarginMode() does not support stop orders for cross margin");return[i,t]}getSettlementCurrencies(e,t){const s=this.safeValue(this.options,e,{}),i=this.safeValue(s,t,{}),n=e==="swap"?["usdt"]:["btc"];return this.safeValue(i,"settlementCurrencies",n)}async fetchCurrencies(e={}){if(this.safeValue(this.urls,"apiBackup")!==void 0)return;const s=await this.publicSpotGetCurrencies(e),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeStringLower(r,"currency"),d=this.safeCurrencyCode(a),c=this.safeValue(r,"delisted"),u=this.safeValue(r,"withdraw_disabled",!1),h=this.safeValue(r,"deposit_disabled",!1),l=this.safeValue(r,"trade_disabled",!1),p=!u,m=!h,b=!c&&!l&&p&&m;i[d]={id:a,lowerCaseId:o,name:void 0,code:d,precision:this.parseNumber("1e-6"),info:r,active:b,deposit:m,withdraw:p,fee:void 0,fees:[],limits:this.limits}}return i}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new Mc(this.id+" fetchFundingRate() supports swap contracts only");const[i,n]=this.prepareRequest(s,void 0,t),r=await this.publicFuturesGetSettleContractsContract(this.extend(i,n));return this.parseFundingRate(r)}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const[s,i]=this.prepareRequest(void 0,"swap",t),n=await this.publicFuturesGetSettleContracts(this.extend(s,i)),r=this.parseFundingRates(n);return this.filterByArray(r,"symbol",e)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"name"),i=this.safeSymbol(s,t),n=this.safeNumber(e,"mark_price"),r=this.safeNumber(e,"index_price"),a=this.safeNumber(e,"interest_rate"),o=this.safeNumber(e,"funding_rate"),d=this.safeTimestamp(e,"funding_next_apply"),c=this.safeNumber(e,"funding_rate_indicative");return{info:e,symbol:i,markPrice:n,indexPrice:r,interestRate:a,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:o,fundingTimestamp:d,fundingDatetime:this.iso8601(d),nextFundingRate:c,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchNetworkDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.privateWalletGetDepositAddress(this.extend(i,t)),r=this.safeValue(n,"multichain_addresses"),a=this.safeString(n,"currency");e=this.safeCurrencyCode(a);const o={};for(let d=0;d<r.length;d++){const c=r[d];if(this.safeInteger(c,"obtain_failed"))continue;const h=this.safeString(c,"chain"),l=this.safeString(c,"address"),p=this.safeString(c,"payment_id");o[h]={info:c,code:e,currency:e,address:l,tag:p}}return o}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.privateWalletGetDepositAddress(this.extend(i,t)),r=this.safeString(n,"currency");e=this.safeCurrencyCode(r);const a=this.safeString(n,"address");let o,d;if(a!==void 0)if(a.indexOf(" ")>=0){const c=a.split(" ");d=c[0],o=c[1]}else d=a;return this.checkAddress(d),{info:n,code:e,currency:e,address:d,tag:o,network:void 0}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={currency_pair:s.id},n=await this.privateWalletGetFee(this.extend(i,t));return this.parseTradingFee(n,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateWalletGetFee(e);return this.parseTradingFees(t)}parseTradingFees(e){const t={};for(let s=0;s<this.symbols.length;s++){const i=this.symbols[s],n=this.market(i);t[i]=this.parseTradingFee(e,n)}return t}parseTradingFee(e,t=void 0){const s=this.safeValue(t,"contract"),i=s?"futures_taker_fee":"taker_fee",n=s?"futures_maker_fee":"maker_fee";return{info:e,symbol:this.safeString(t,"symbol"),maker:this.safeNumber(e,n),taker:this.safeNumber(e,i)}}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.privateWalletGetWithdrawStatus(t),i={};let n={};for(let r=0;r<s.length;r++){n={};const a=s[r],o=this.safeString(a,"currency"),d=this.safeCurrencyCode(o);if(e!==void 0&&!this.inArray(d,e))continue;const c=this.safeValue(a,"withdraw_fix_on_chains");if(c===void 0)n=this.safeNumber(a,"withdraw_fix");else{const u=Object.keys(c);for(let h=0;h<u.length;h++){const l=u[h];n[l]=this.parseNumber(c[l])}}i[d]={withdraw:n,deposit:void 0,info:a}}return i}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e),e=n.symbol);const[r,a]=this.handleMarketTypeAndParams("fetchFundingHistory",n,i),[o,d]=this.prepareRequest(n,r,a);o.type="fund",t!==void 0&&(o.from=t/1e3),s!==void 0&&(o.limit=s);const c=this.getSupportedMapping(r,{swap:"privateFuturesGetSettleAccountBook",future:"privateDeliveryGetSettleAccountBook"}),u=await this[c](this.extend(o,d));return this.parseFundingHistories(u,e,t,s)}parseFundingHistories(e,t,s,i){const n=[];for(let a=0;a<e.length;a++){const o=e[a],d=this.parseFundingHistory(o);n.push(d)}const r=this.sortBy(n,"timestamp");return this.filterBySymbolSinceLimit(r,t,s,i)}parseFundingHistory(e,t=void 0){const s=this.safeTimestamp(e,"time"),i=this.safeString(e,"text");return t=this.safeMarket(i,t),{info:e,symbol:this.safeString(t,"symbol"),code:this.safeString(t,"settle"),timestamp:s,datetime:this.iso8601(s),id:void 0,amount:this.safeNumber(e,"change")}}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),[n,r]=this.prepareRequest(i,void 0,s),a=this.getSupportedMapping(i.type,{spot:"publicSpotGetOrderBook",margin:"publicSpotGetOrderBook",swap:"publicFuturesGetSettleOrderBook",future:"publicDeliveryGetSettleOrderBook"});t!==void 0&&(n.limit=t),n.with_id=!0;const o=await this[a](this.extend(n,r));let d=this.safeInteger(o,"current");i.spot||(d=d*1e3);const c=i.spot?0:"p",u=i.spot?1:"s",h=this.safeInteger(o,"id"),l=this.parseOrderBook(o,e,d,"bids","asks",c,u);return l.nonce=h,l}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),[i,n]=this.prepareRequest(s,void 0,t),r=this.getSupportedMapping(s.type,{spot:"publicSpotGetTickers",margin:"publicSpotGetTickers",swap:"publicFuturesGetSettleTickers",future:"publicDeliveryGetSettleTickers"}),a=await this[r](this.extend(i,n)),o=this.safeValue(a,0);return this.parseTicker(o,s)}parseTicker(e,t=void 0){const s=this.safeString2(e,"currency_pair","contract"),i=this.safeSymbol(s,t),n=this.safeString(e,"last"),r=this.safeString(e,"lowest_ask"),a=this.safeString(e,"highest_bid"),o=this.safeString(e,"high_24h"),d=this.safeString(e,"low_24h");let c=this.safeString2(e,"base_volume","volume_24h_base");c==="nan"&&(c="0");let u=this.safeString2(e,"quote_volume","volume_24h_quote");u==="nan"&&(u="0");const h=this.safeString(e,"change_percentage");return this.safeTicker({symbol:i,timestamp:void 0,datetime:void 0,high:o,low:d,bid:a,bidVolume:void 0,ask:r,askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:h,average:void 0,baseVolume:c,quoteVolume:u,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeString(e,0);let i;s!==void 0&&(i=this.market(s));const[n,r]=this.handleMarketTypeAndParams("fetchTickers",i,t),[a,o]=this.prepareRequest(void 0,n,r),d=this.getSupportedMapping(n,{spot:"publicSpotGetTickers",margin:"publicSpotGetTickers",swap:"publicFuturesGetSettleTickers",future:"publicDeliveryGetSettleTickers"}),c=await this[d](this.extend(a,o));return this.parseTickers(c,e)}parseBalanceHelper(e){const t=this.account();return t.used=this.safeString2(e,"freeze","locked"),t.free=this.safeString(e,"available"),t.total=this.safeString(e,"total"),"borrowed"in e&&(t.debt=this.safeString(e,"borrowed")),t}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"symbol");e=this.omit(e,"symbol");const[s,i]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),[n,r]=this.prepareRequest(void 0,s,i),[a,o]=this.getMarginMode(!1,r);if(t!==void 0){const m=this.market(t);n.currency_pair=m.id}const d=this.getSupportedMapping(s,{spot:this.getSupportedMapping(a,{spot:"privateSpotGetAccounts",margin:"privateMarginGetAccounts",cross_margin:"privateMarginGetCrossAccounts"}),funding:"privateMarginGetFundingAccounts",swap:"privateFuturesGetSettleAccounts",future:"privateDeliveryGetSettleAccounts"});let c=await this[d](this.extend(n,o));(s==="swap"||s==="future")&&(c=[c]);const h={info:c},l=a==="margin";let p=c;if("balances"in p){const m=[],g=this.safeValue(p,"balances",[]),y=Object.keys(g);for(let b=0;b<y.length;b++){const w=y[b],k=g[w];k.currency=w,m.push(k)}p=m}for(let m=0;m<p.length;m++){const g=p[m];if(l){const y=this.safeString(g,"currency_pair"),b=this.safeSymbol(y,void 0,"_"),w=this.safeValue(g,"base",{}),k=this.safeValue(g,"quote",{}),T=this.safeCurrencyCode(this.safeString(w,"currency")),O=this.safeCurrencyCode(this.safeString(k,"currency")),x={};x[T]=this.parseBalanceHelper(w),x[O]=this.parseBalanceHelper(k),h[b]=this.safeBalance(x)}else{const y=this.safeCurrencyCode(this.safeString(g,"currency"));h[y]=this.parseBalanceHelper(g)}}return l?h:this.safeBalance(h)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.safeString(n,"price");let o={};[o,n]=this.prepareRequest(r,void 0,n),o.interval=this.timeframes[t];let d="publicSpotGetCandlesticks",c=1e3;r.contract&&(c=1999,i=i===void 0?c:Math.min(i,c),r.future?d="publicDeliveryGetSettleCandlesticks":r.swap&&(d="publicFuturesGetSettleCandlesticks"),(a==="mark"||a==="index")&&(o.contract=a+"_"+r.id,n=this.omit(n,"price"))),i=i===void 0?c:Math.min(i,c);let u=this.safeInteger(n,"until");if(u!==void 0&&(u=parseInt(u/1e3),n=this.omit(n,"until")),s!==void 0){const l=this.parseTimeframe(t);o.from=parseInt(s/1e3);const p=this.sum(o.from,i*l-1),m=this.seconds(),g=Math.min(p,m);u!==void 0?o.to=Math.min(g,u):o.to=g}else u!==void 0&&(o.to=u),o.limit=i;const h=await this[d](this.extend(o,n));return this.parseOHLCVs(h,r,t,s,i)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new yr(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const n=this.market(e);if(!n.swap)throw new Mc(this.id+" fetchFundingRateHistory() supports swap contracts only");const[r,a]=this.prepareRequest(n,void 0,i);s!==void 0&&(r.limit=s);const d=await this["publicFuturesGetSettleFundingRate"](this.extend(r,a)),c=[];for(let h=0;h<d.length;h++){const l=d[h],p=this.safeTimestamp(l,"t");c.push({info:l,symbol:e,fundingRate:this.safeNumber(l,"r"),timestamp:p,datetime:this.iso8601(p)})}const u=this.sortBy(c,"timestamp");return this.filterBySymbolSinceLimit(u,n.symbol,t,s)}parseOHLCV(e,t=void 0){return Array.isArray(e)?[this.safeTimestamp(e,0),this.safeNumber(e,5),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,6)]:[this.safeTimestamp(e,"t"),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),[r,a]=this.prepareRequest(n,void 0,i),o=this.getSupportedMapping(n.type,{spot:"publicSpotGetTrades",margin:"publicSpotGetTrades",swap:"publicFuturesGetSettleTrades",future:"publicDeliveryGetSettleTrades"});s!==void 0&&(r.limit=s),t!==void 0&&n.contract&&(r.from=parseInt(t/1e3));const d=await this[o](this.extend(r,a));return this.parseTrades(d,n,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){if(await this.loadMarkets(),t===void 0)throw new yr(this.id+" fetchOrderTrades requires a symbol argument");return await this.fetchMyTrades(t,s,i,{order_id:e})}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r,a={};const o=e!==void 0?this.market(e):void 0,d=this.safeInteger2(i,"until","till");i=this.omit(i,["until","till"]),[n,i]=this.handleMarketTypeAndParams("fetchMyTrades",o,i),n==="swap"||n==="future"?[a,i]=this.prepareRequest(o,n,i):(o!==void 0&&(a.currency_pair=o.id),[r,i]=this.getMarginMode(!1,i),a.account=r),s!==void 0&&(a.limit=s),t!==void 0&&(a.from=parseInt(t/1e3)),d!==void 0&&(a.to=parseInt(d/1e3));const u=this.getSupportedMapping(n,{spot:"privateSpotGetMyTrades",margin:"privateSpotGetMyTrades",swap:"privateFuturesGetSettleMyTrades",future:"privateDeliveryGetSettleMyTrades"}),h=await this[u](this.extend(a,i));return this.parseTrades(h,o,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"id");let i=this.safeTimestamp2(e,"time","create_time");i=this.safeInteger(e,"create_time_ms",i);const n=this.safeString2(e,"currency_pair","contract");t=this.safeMarket(n,t);let r=this.safeString2(e,"amount","size");const a=this.safeString(e,"price"),o=Ke.stringLt(r,"0")?"sell":"buy";r=Ke.stringAbs(r);const d=this.safeString2(e,"side","type",o),c=this.safeString(e,"order_id"),u=this.safeString(e,"fee"),h=this.safeString(e,"gt_fee"),l=this.safeString(e,"point_fee"),p=[];if(u!==void 0){const g=this.safeString(e,"fee_currency");let y=this.safeCurrencyCode(g);y===void 0&&(y=this.safeString(t,"settle")),p.push({cost:u,currency:y})}h!==void 0&&p.push({cost:h,currency:"GT"}),l!==void 0&&p.push({cost:l,currency:"GatePoint"});const m=this.safeString(e,"role");return this.safeTrade({info:e,id:s,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,order:c,type:void 0,side:d,takerOrMaker:m,price:a,amount:r,cost:void 0,fee:void 0,fees:p},t)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.limit=s),t!==void 0){const o=parseInt(t/1e3);n.from=o,n.to=this.sum(o,30*24*60*60)}const a=await this.privateWalletGetDeposits(this.extend(n,i));return this.parseTransactions(a,r)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.limit=s),t!==void 0){const o=parseInt(t/1e3);n.from=o,n.to=this.sum(o,30*24*60*60)}const a=await this.privateWalletGetWithdrawals(this.extend(n,i));return this.parseTransactions(a,r)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,address:s,amount:this.currencyToPrecision(e,t)};i!==void 0&&(a.memo=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeStringLower(o,d,d),d!==void 0&&(a.chain=d,n=this.omit(n,"network"));const c=await this.privateWithdrawalsPostWithdrawals(this.extend(a,n));return this.parseTransaction(c,r)}parseTransactionStatus(e){const t={PEND:"pending",REQUEST:"pending",DMOVE:"pending",CANCEL:"failed",DONE:"ok",BCODE:"ok"};return this.safeString(t,e,e)}parseTransactionType(e){const t={d:"deposit",w:"withdrawal"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id");let i,n=this.safeString(e,"amount");s[0]==="b"?(i=Ke.stringGt(n,"0")?"deposit":"withdrawal",n=Ke.stringAbs(n)):s!==void 0&&(i=this.parseTransactionType(s[0]));const r=this.safeString(e,"currency"),a=this.safeCurrencyCode(r),o=this.safeString(e,"txid"),d=this.safeString(e,"status"),c=this.parseTransactionStatus(d),u=this.safeString(e,"address"),h=this.safeNumber(e,"fee"),l=this.safeString(e,"memo"),p=this.safeTimestamp(e,"timestamp");return{info:e,id:s,txid:o,currency:a,amount:this.parseNumber(n),network:void 0,address:u,addressTo:void 0,addressFrom:void 0,tag:l,tagTo:void 0,tagFrom:void 0,status:c,type:i,timestamp:p,datetime:this.iso8601(p),updated:void 0,fee:h}}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=a.contract,d=this.safeValue(r,"trigger"),c=this.safeValue2(r,"triggerPrice","stopPrice"),u=this.safeValue(r,"stopLossPrice",c),h=this.safeValue(r,"takeProfitPrice"),l=u!==void 0,p=h!==void 0,m=l||p;if(l&&p)throw new ht(this.id+" createOrder() stopLossPrice and takeProfitPrice cannot both be defined");let g="Orders";const y=this.safeValue(r,"reduceOnly"),b=this.safeStringLower2(r,"time_in_force","tif"),w=this.isPostOnly(t==="market",b==="poc",r);let k=this.handleTimeInForce(r);r=this.omit(r,["stopPrice","triggerPrice","stopLossPrice","takeProfitPrice","reduceOnly","timeInForce","postOnly"]),w&&(k="poc");const T=t==="limit",O=t==="market";if(T&&n===void 0)throw new yr(this.id+" createOrder () requires a price argument for "+t+" orders");if(o){const P=this.amountToPrecision(e,i),_=s==="sell"?Ke.stringNeg(P):P;if(i=parseInt(_),O){if(k==="poc"||k==="gtc")throw new ht(this.id+' createOrder () timeInForce for market orders must be "IOC"');k="ioc",n=0}}else if(!T)throw new rs(this.id+" createOrder () does not support "+t+" orders for "+a.type+" markets");let x;if(!m&&d===void 0){if(o)x={contract:a.id,size:i,price:this.priceToPrecision(e,n),settle:a.settleId},y!==void 0&&(x.reduce_only=y),k!==void 0&&(x.tif=k);else{let _;[_,r]=this.getMarginMode(!1,r),x={currency_pair:a.id,type:t,account:_,side:s,amount:this.amountToPrecision(e,i),price:this.priceToPrecision(e,n)},k!==void 0&&(x.time_in_force=k)}let P=this.safeString2(r,"text","clientOrderId");if(P!==void 0){if(P.length>28)throw new Oi(this.id+" createOrder () clientOrderId or text param must be up to 28 characters");r=this.omit(r,["text","clientOrderId"]),P[0]!=="t"&&(P="t-"+P),x.text=P}}else{if(o){if(x={initial:{contract:a.id,size:i,price:this.priceToPrecision(e,n)},settle:a.settleId},d===void 0){let P,_;l?(P=s==="buy"?1:2,_=this.priceToPrecision(e,u)):p&&(P=s==="buy"?2:1,_=this.priceToPrecision(e,h)),x.trigger={price_type:0,price:this.priceToPrecision(e,_),rule:P}}y!==void 0&&(x.initial.reduce_only=y),k!==void 0&&(x.initial.tif=k)}else{const P=this.safeValue(this.options,"createOrder",{});let _;if([_,r]=this.getMarginMode(!0,r),x={put:{type:t,side:s,price:this.priceToPrecision(e,n),amount:this.amountToPrecision(e,i),account:_,time_in_force:"gtc"},market:a.id},d===void 0){const S=this.safeInteger(P,"expiration"),I=this.safeInteger(r,"expiration",S);let v,N;l?(v=s==="buy"?">=":"<=",N=this.priceToPrecision(e,u)):p&&(v=s==="buy"?"<=":">=",N=this.priceToPrecision(e,h)),x.trigger={price:this.priceToPrecision(e,N),rule:v,expiration:I}}k!==void 0&&(x.put.time_in_force=k)}g="PriceOrders"}const C=this.getSupportedMapping(a.type,{spot:"privateSpotPost"+g,margin:"privateSpotPost"+g,swap:"privateFuturesPostSettle"+g,future:"privateDeliveryPostSettle"+g}),E=await this[C](this.deepExtend(x,r));return this.parseOrder(E,a)}parseOrderStatus(e){const t={_new:"open",filled:"closed",cancelled:"canceled",liquidated:"closed",ioc:"canceled",failed:"canceled",expired:"canceled",finished:"closed",succeeded:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeValue2(e,"put","initial"),i=this.safeValue(e,"trigger");let n=this.safeString(s,"contract"),r=this.safeString(s,"type"),a=this.safeStringUpper2(s,"time_in_force","tif"),o=this.safeString2(s,"amount","size"),d=this.safeString(s,"side"),c=this.safeString(s,"price");n=this.safeString(e,"contract",n),r=this.safeString(e,"type",r),a=this.safeStringUpper2(e,"time_in_force","tif",a),a==="POC"&&(a="PO");const u=a==="PO";o=this.safeString2(e,"amount","size",o),d=this.safeString(e,"side",d),c=this.safeString(e,"price",c);let h=this.safeString(e,"left"),l=Ke.stringSub(o,h),p=this.safeString(e,"filled_total"),m,g;s&&(h=o,l="0",p="0"),n?(r=Ke.stringEquals(c,"0")&&a==="IOC"?"market":"limit",d=Ke.stringGt(o,"0")?"buy":"sell",m=this.safeString(e,"finish_as","open"),g=this.safeNumber(e,"fill_price")):m=this.safeString(e,"status");let y=this.safeInteger(e,"create_time_ms");y===void 0&&(y=this.safeTimestamp2(e,"create_time","ctime"));let b=this.safeInteger(e,"update_time_ms");b===void 0&&(b=this.safeTimestamp2(e,"update_time","finish_time"));const w=this.safeString2(e,"currency_pair","market",n),k=[],T=this.safeString(e,"gt_fee");T&&k.push({currency:"GT",cost:T});const O=this.safeString(e,"fee");O&&k.push({currency:this.safeCurrencyCode(this.safeString(e,"fee_currency")),cost:O});const x=this.safeString(e,"rebated_fee");x&&k.push({currency:this.safeCurrencyCode(this.safeString(e,"rebated_fee_currency")),cost:Ke.stringNeg(x)});const E=k.length>1,P=this.parseOrderStatus(m);return this.safeOrder({id:this.safeString(e,"id"),clientOrderId:this.safeString(e,"text"),timestamp:y,datetime:this.iso8601(y),lastTradeTimestamp:b,status:P,symbol:this.safeSymbol(w),type:r,timeInForce:a,postOnly:u,reduceOnly:this.safeValue(e,"is_reduce_only"),side:d,price:this.parseNumber(c),stopPrice:this.safeNumber(i,"price"),average:g,amount:this.parseNumber(Ke.stringAbs(o)),cost:Ke.stringAbs(p),filled:this.parseNumber(Ke.stringAbs(l)),remaining:this.parseNumber(Ke.stringAbs(h)),fee:E?void 0:this.safeValue(k,0),fees:E?k:[],trades:void 0,info:e},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue2(s,"is_stop_order","stop",!1);s=this.omit(s,["is_stop_order","stop"]);let n=this.safeString2(s,"text","clientOrderId"),r=e;n!==void 0&&(s=this.omit(s,["text","clientOrderId"]),n[0]!=="t"&&(n="t-"+n),r=n);const a=t===void 0?void 0:this.market(t),[o,d]=this.handleMarketTypeAndParams("fetchOrder",a,s),c=o==="swap"||o==="future",[u,h]=c?this.prepareRequest(a,o,d):this.spotOrderPrepareRequest(a,i,d);u.order_id=r;const l=i?"PriceOrders":"Orders",p=this.getSupportedMapping(o,{spot:"privateSpotGet"+l+"OrderId",margin:"privateSpotGet"+l+"OrderId",swap:"privateFuturesGetSettle"+l+"OrderId",future:"privateDeliveryGetSettle"+l+"OrderId"}),m=await this[p](this.extend(u,h));return this.parseOrder(m,a)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("open",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("finished",e,t,s,i)}async fetchOrdersByStatus(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;t!==void 0&&(r=this.market(t),t=r.symbol);const a=this.safeValue(n,"stop");n=this.omit(n,"stop");const[o,d]=this.handleMarketTypeAndParams("fetchOrdersByStatus",r,n),c=o==="spot"||o==="margin",[u,h]=c?this.multiOrderSpotPrepareRequest(r,a,d):this.prepareRequest(r,o,d);e==="closed"&&(e="finished"),u.status=e,i!==void 0&&(u.limit=i),s!==void 0&&c&&(u.from=parseInt(s/1e3));let l=a?"PriceOrders":"Orders";const p=c&&e==="open"&&!a;p&&(l="OpenOrders");const m=this.getSupportedMapping(o,{spot:"privateSpotGet"+l,margin:"privateSpotGet"+l,swap:"privateFuturesGetSettle"+l,future:"privateDeliveryGetSettle"+l}),g=await this[m](this.extend(u,h));let y=g;if(p){y=[];for(let w=0;w<g.length;w++){const k=this.safeValue(g[w],"orders");y=this.arrayConcat(y,k)}}const b=this.parseOrders(y,r,s,i);return this.filterBySymbolSinceLimit(b,t,s,i)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=t===void 0?void 0:this.market(t),n=this.safeValue2(s,"is_stop_order","stop",!1);s=this.omit(s,["is_stop_order","stop"]);const[r,a]=this.handleMarketTypeAndParams("cancelOrder",i,s),[o,d]=r==="spot"||r==="margin"?this.spotOrderPrepareRequest(i,n,a):this.prepareRequest(i,r,a);o.order_id=e;const c=n?"Price":"",u=this.getSupportedMapping(r,{spot:"privateSpotDelete"+c+"OrdersOrderId",margin:"privateSpotDelete"+c+"OrdersOrderId",swap:"privateFuturesDeleteSettle"+c+"OrdersOrderId",future:"privateDeliveryDeleteSettle"+c+"OrdersOrderId"}),h=await this[u](this.extend(o,d));return this.parseOrder(h,i)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s=e===void 0?void 0:this.market(e),i=this.safeValue(t,"stop");t=this.omit(t,"stop");const[n,r]=this.handleMarketTypeAndParams("cancelAllOrders",s,t),[a,o]=n==="spot"?this.multiOrderSpotPrepareRequest(s,i,r):this.prepareRequest(s,n,r),d=i?"PriceOrders":"Orders",c=this.getSupportedMapping(n,{spot:"privateSpotDelete"+d,margin:"privateSpotDelete"+d,swap:"privateFuturesDeleteSettle"+d,future:"privateDeliveryDeleteSettle"+d}),u=await this[c](this.extend(a,o));return this.parseOrders(u,s)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.convertTypeToAccount(s),o=this.convertTypeToAccount(i),d=this.currencyToPrecision(e,t),c={currency:r.id,amount:d};if(a in this.options.accountsByType?c.from=a:(c.from="margin",c.currency_pair=a),o in this.options.accountsByType?c.to=o:(c.to="margin",c.currency_pair=o),a==="margin"||o==="margin"){const l=this.safeString2(n,"symbol","currency_pair");if(l===void 0)throw new yr(this.id+' transfer requires params["symbol"] for isolated margin transfers');const p=this.market(l);c.currency_pair=p.id,n=this.omit(n,"symbol")}(o==="futures"||o==="delivery"||a==="futures"||a==="delivery")&&(c.settle=r.lowerCaseId);const u=await this.privateWalletPostTransfers(this.extend(c,n)),h=this.parseTransfer(u,r);return this.extend(h,{fromAccount:s,toAccount:i,amount:this.parseNumber(d)})}parseTransfer(e,t=void 0){const s=this.milliseconds();return{id:void 0,timestamp:s,datetime:this.iso8601(s),currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0,info:e}}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new yr(this.id+" setLeverage() requires a symbol argument");if(e<0||e>100)throw new Oi(this.id+" setLeverage() leverage should be between 1 and 100");await this.loadMarkets();const i=this.market(t),n=this.getSupportedMapping(i.type,{swap:"privateFuturesPostSettlePositionsContractLeverage",future:"privateDeliveryPostSettlePositionsContractLeverage"}),[r,a]=this.prepareRequest(i,void 0,s),o=this.safeString2(this.options,"marginMode","defaultMarginMode"),d=this.safeString(a,"cross_leverage_limit");let c=this.safeString(a,"marginMode",o);return d!==void 0&&(c="cross",e=d),c==="cross"||c==="cross_margin"?(r.cross_leverage_limit=e.toString(),r.leverage="0"):r.leverage=e.toString(),await this[n](this.extend(r,a))}parsePosition(e,t=void 0){const s=this.safeString(e,"contract");t=this.safeMarket(s,t);const i=this.safeString(e,"size");let n;Ke.stringGt(i,"0")?n="long":Ke.stringLt(i,"0")&&(n="short");const r=this.safeString(e,"maintenance_rate"),a=this.safeString(e,"value"),o=this.safeString(e,"leverage");let d;o==="0"?d="cross":d="isolated";const c=this.safeString(e,"unrealised_pnl"),u="0.00075",h=Ke.stringMul(u,a),l=Ke.stringAdd(Ke.stringDiv(a,o),h),p=Ke.stringMul(Ke.stringDiv(c,l),"100");return{info:e,id:void 0,symbol:this.safeString(t,"symbol"),timestamp:void 0,datetime:void 0,initialMargin:this.parseNumber(l),initialMarginPercentage:this.parseNumber(Ke.stringDiv(l,a)),maintenanceMargin:this.parseNumber(Ke.stringMul(r,a)),maintenanceMarginPercentage:this.parseNumber(r),entryPrice:this.safeNumber(e,"entry_price"),notional:this.parseNumber(a),leverage:this.safeNumber(e,"leverage"),unrealizedPnl:this.parseNumber(c),contracts:this.parseNumber(Ke.stringAbs(i)),contractSize:this.safeValue(t,"contractSize"),marginRatio:void 0,liquidationPrice:this.safeNumber(e,"liq_price"),markPrice:this.safeNumber(e,"mark_price"),collateral:this.safeNumber(e,"margin"),marginMode:d,side:n,percentage:this.parseNumber(p)}}async fetchPositions(e=void 0,t={}){await this.loadMarkets();let s;if(e!==void 0&&(e=this.marketSymbols(e),e.length>0)){s=this.market(e[0]);for(let u=1;u<e.length;u++)if(this.market(e[u]).type!==s.type)throw new Oi(this.id+" fetchPositions() does not support multiple types of positions at the same time")}const[i,n]=this.handleMarketTypeAndParams("fetchPositions",s,t);if(i!=="swap"&&i!=="future")throw new yr(this.id+' fetchPositions requires a type parameter, "swap" or "future"');const[r,a]=this.prepareRequest(void 0,i,n),o=this.getSupportedMapping(i,{swap:"privateFuturesGetSettlePositions",future:"privateDeliveryGetSettlePositions"}),d=await this[o](this.extend(r,a));return this.parsePositions(d,e)}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const[s,i]=this.handleMarketTypeAndParams("fetchLeverageTiers",void 0,t),[n,r]=this.prepareRequest(void 0,s,i);if(s!=="future"&&s!=="swap")throw new Oi(this.id+" fetchLeverageTiers only supports swap and future");const a=this.getSupportedMapping(s,{swap:"publicFuturesGetSettleContracts",future:"publicDeliveryGetSettleContracts"}),o=await this[a](this.extend(n,r));return this.parseLeverageTiers(o,e,"name")}parseMarketLeverageTiers(e,t=void 0){const s=this.safeString(e,"maintenance_rate"),i=this.safeString(e,"leverage_max"),n=this.safeString(e,"risk_limit_step"),r=this.safeString(e,"risk_limit_max"),a=Ke.stringDiv("1",i);let o=s,d=a,c="0";const u=[];for(;Ke.stringLt(c,r);){const h=Ke.stringAdd(c,n);u.push({tier:this.parseNumber(Ke.stringDiv(h,n)),currency:this.safeString(t,"settle"),minNotional:this.parseNumber(c),maxNotional:this.parseNumber(h),maintenanceMarginRate:this.parseNumber(o),maxLeverage:this.parseNumber(Ke.stringDiv("1",d)),info:e}),o=Ke.stringAdd(o,s),d=Ke.stringAdd(d,a),c=h}return u}async repayMargin(e,t,s=void 0,i={}){const n=this.safeString(i,"marginMode");i=this.omit(i,"marginMode"),this.checkRequiredMarginArgument("repayMargin",s,n),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,amount:this.currencyToPrecision(e,t)};let o;if(s===void 0)o="privateMarginPostCrossRepayments";else{o="privateMarginPostLoansLoanIdRepayment";const c=this.market(s);a.currency_pair=c.id,a.mode="partial";const u=this.safeString2(i,"loan_id","id");if(u===void 0)throw new yr(this.id+" repayMargin() requires loan_id param for isolated margin");a.loan_id=u}i=this.omit(i,["marginMode","loan_id","id"]);let d=await this[o](this.extend(a,i));return n==="cross"&&(d=d[0]),this.parseMarginLoan(d,r)}async borrowMargin(e,t,s=void 0,i={}){const n=this.safeString(i,"marginMode");i=this.omit(i,"marginMode"),this.checkRequiredMarginArgument("borrowMargin",s,n),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,amount:this.currencyToPrecision(e,t)};let o;if(s===void 0)o="privateMarginPostCrossLoans";else{const c=this.market(s);a.currency_pair=c.id,a.side="borrow",a.rate=this.safeString(i,"rate","0.0001"),a.auto_renew=!0,o="privateMarginPostLoans"}i=this.omit(i,["marginMode","rate"]);const d=await this[o](this.extend(a,i));return this.parseMarginLoan(d,r)}parseMarginLoan(e,t=void 0){const s=this.safeString2(this.options,"defaultMarginMode","marginMode","cross");let i=this.safeInteger(e,"create_time");s==="isolated"&&(i=this.safeTimestamp(e,"create_time"));const n=this.safeString(e,"currency"),r=this.safeString(e,"currency_pair");return{id:this.safeInteger(e,"id"),currency:this.safeCurrencyCode(n,t),amount:this.safeNumber(e,"amount"),symbol:this.safeSymbol(r,void 0),timestamp:i,datetime:this.iso8601(i),info:e}}sign(e,t=[],s="GET",i={},n=void 0,r=void 0){const a=t[0],o=t[1];let d=this.omit(i,this.extractParams(e));e=this.implodeParams(e,i);const c=e===""?"":"/"+e;let u="/"+o+c;(o==="subAccounts"||o==="withdrawals")&&(u=c);let h=this.urls.api[a][o];if(h===void 0)throw new DF(this.id+" does not have a testnet for the "+o+" market type.");if(h+=u,a==="public")Object.keys(d).length&&(h+="?"+this.urlencode(d));else{this.checkRequiredCredentials();let l="",p=!1;if(o==="futures"&&s==="POST"){const x=e.split("/"),C=this.safeString(x,1,"");p=C.indexOf("dual")>=0||C.indexOf("positions")>=0}if(s==="GET"||s==="DELETE"||p)Object.keys(d).length&&(l=this.urlencode(d),h+="?"+l);else{const x=this.safeValue(d,"query",{});Object.keys(x).length&&(l=this.urlencode(x),h+="?"+l),d=this.omit(d,"query"),r=this.json(d)}const m=r===void 0?"":r,g=this.hash(this.encode(m),"sha512"),b=this.seconds().toString(),w="/api/"+this.version+u,T=[s.toUpperCase(),w,l,g,b].join(`
`),O=this.hmac(this.encode(T),this.encode(this.secret),"sha512");n={KEY:this.apiKey,Timestamp:b,SIGN:O,"Content-Type":"application/json"}}return{url:h,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"label");if(c!==void 0){const u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),new ht(u)}}};const GF=Pb;var UF=class extends GF{describe(){return this.deepExtend(super.describe(),{id:"gateio",alias:!0})}};const $F=ge,{ExchangeError:Pc,ArgumentsRequired:M0,BadRequest:Vi,OrderNotFound:rv,InvalidOrder:Ho,InvalidNonce:jF,InsufficientFunds:av,AuthenticationError:Ga,PermissionDenied:WF,NotSupported:Gf,OnMaintenance:P0,RateLimitExceeded:ov,ExchangeNotAvailable:dv}=de,{TICK_SIZE:zF}=me,cv=Se;var KF=class extends $F{describe(){return this.deepExtend(super.describe(),{id:"gemini",name:"Gemini",countries:["US"],rateLimit:100,version:"v1",pro:!1,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createDepositAddress:!0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:void 0,fetchDepositAddress:void 0,fetchDepositAddressesByNetwork:!0,fetchDeposits:void 0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:void 0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:!0,fetchWithdrawals:void 0,postOnly:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27816857-ce7be644-6096-11e7-82d6-3c257263229c.jpg",api:{public:"https://api.gemini.com",private:"https://api.gemini.com",web:"https://docs.gemini.com"},www:"https://gemini.com/",doc:["https://docs.gemini.com/rest-api","https://docs.sandbox.gemini.com"],test:{public:"https://api.sandbox.gemini.com",private:"https://api.sandbox.gemini.com",web:"https://docs.gemini.com"},fees:["https://gemini.com/api-fee-schedule","https://gemini.com/trading-fees","https://gemini.com/transfer-fees"]},api:{web:{get:["rest-api"]},public:{get:{"v1/symbols":5,"v1/symbols/details/{symbol}":5,"v1/pubticker/{symbol}":5,"v2/ticker/{symbol}":5,"v2/candles/{symbol}/{timeframe}":5,"v1/trades/{symbol}":5,"v1/auction/{symbol}":5,"v1/auction/{symbol}/history":5,"v1/pricefeed":5,"v1/book/{symbol}":5,"v1/earn/rates":5}},private:{post:{"v1/order/new":1,"v1/order/cancel":1,"v1/wrap/{symbol}":1,"v1/order/cancel/session":1,"v1/order/cancel/all":1,"v1/order/status":1,"v1/orders":1,"v1/mytrades":1,"v1/notionalvolume":1,"v1/tradevolume":1,"v1/clearing/new":1,"v1/clearing/status":1,"v1/clearing/cancel":1,"v1/clearing/confirm":1,"v1/balances":1,"v1/notionalbalances/{currency}":1,"v1/transfers":1,"v1/addresses/{network}":1,"v1/deposit/{network}/newAddress":1,"v1/deposit/{currency}/newAddress":1,"v1/withdraw/{currency}":1,"v1/account/transfer/{currency}":1,"v1/payments/addbank":1,"v1/payments/methods":1,"v1/payments/sen/withdraw":1,"v1/balances/earn":1,"v1/earn/interest":1,"v1/approvedAddresses/{network}/request":1,"v1/approvedAddresses/account/{network}":1,"v1/approvedAddresses/{network}/remove":1,"v1/account":1,"v1/account/create":1,"v1/account/list":1,"v1/heartbeat":1}}},precisionMode:zF,fees:{trading:{taker:.004,maker:.002}},httpExceptions:{400:Vi,403:WF,404:rv,406:av,429:ov,500:Pc,502:dv,503:P0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1hr","6h":"6hr","1d":"1day"},exceptions:{exact:{AuctionNotOpen:Vi,ClientOrderIdTooLong:Vi,ClientOrderIdMustBeString:Vi,ConflictingOptions:Vi,EndpointMismatch:Vi,EndpointNotFound:Vi,IneligibleTiming:Vi,InsufficientFunds:av,InvalidJson:Vi,InvalidNonce:jF,InvalidOrderType:Ho,InvalidPrice:Ho,InvalidQuantity:Ho,InvalidSide:Ho,InvalidSignature:Ga,InvalidSymbol:Vi,InvalidTimestampInPayload:Vi,Maintenance:P0,MarketNotOpen:Ho,MissingApikeyHeader:Ga,MissingOrderField:Ho,MissingRole:Ga,MissingPayloadHeader:Ga,MissingSignatureHeader:Ga,NoSSL:Ga,OptionsMustBeArray:Vi,OrderNotFound:rv,RateLimit:ov,System:Pc,UnsupportedOption:Vi},broad:{"The Gemini Exchange is currently undergoing maintenance.":P0,"We are investigating technical issues with the Gemini Exchange.":dv}},options:{fetchMarketsMethod:"fetch_markets_from_web",fetchTickerMethod:"fetchTickerV1",networkIds:{bitcoin:"BTC",ethereum:"ERC20",bitcoincash:"BCH",litecoin:"LTC",zcash:"ZEC",filecoin:"FIL",dogecoin:"DOGE",tezos:"XTZ"},networks:{BTC:"bitcoin",ERC20:"ethereum",BCH:"bitcoincash",LTC:"litecoin",ZEC:"zcash",FIL:"filecoin",DOGE:"dogecoin",XTZ:"tezos"}}})}async fetchMarkets(e={}){const t=this.safeValue(this.options,"fetchMarketsMethod","fetch_markets_from_api");return await this[t](e)}async fetchMarketsFromWeb(e={}){const s=(await this.webGetRestApi(e)).split('<h1 id="symbols-and-minimums">Symbols and minimums</h1>'),i=s.length,n=this.id+" fetchMarketsFromWeb() the "+this.name+" API doc HTML markup has changed, breaking the parser of order limits and precision info for "+this.name+" markets.";if(i!==2)throw new Gf(n);const r=s[1].split("tbody>");if(r.length<2)throw new Gf(n);const o=r[1].split(`
<tr>
`),d=o.length;if(d<2)throw new Gf(n);const c=[];for(let u=1;u<d;u++){const h=o[u],l=h.split(`</td>
`);if(l.length<5)throw new Gf(n);const m=l[0].replace("<td>",""),y=l[1].replace("<td>","").split(" "),b=this.safeNumber(y,0),k=l[2].replace("<td>","").split(" "),T=m.length-0,O=T-3,C=l[3].replace("<td>","").split(" "),E=this.safeStringLower(C,1,m.slice(O,T)),P=this.safeStringLower(k,1,m.replace(E,"")),_=this.safeCurrencyCode(P),S=this.safeCurrencyCode(E);c.push({id:m,symbol:_+"/"+S,base:_,quote:S,settle:void 0,baseId:P,quoteId:E,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(k,0),price:this.safeNumber(C,0)},limits:{leverage:{min:void 0,max:void 0},amount:{min:b,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:h})}return c}async fetchMarketsFromAPI(e={}){const t=await this.publicGetV1Symbols(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=n,a=n.length-0,o=n.slice(0,a-3),d=n.slice(a-3,a),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d);s.push({id:n,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{price:void 0,amount:void 0},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit_bids=t,n.limit_asks=t);const r=await this.publicGetV1BookSymbol(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"bids","asks","price","amount")}async fetchTickerV1(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetV1PubtickerSymbol(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickerV2(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetV2TickerSymbol(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickerV1AndV2(e,t={}){const s=await this.fetchTickerV1(e,t),i=await this.fetchTickerV2(e,t);return this.deepExtend(s,{open:i.open,high:i.high,low:i.low,change:i.change,percentage:i.percentage,average:i.average,info:i.info})}async fetchTicker(e,t={}){const s=this.safeValue(this.options,"fetchTickerMethod","fetchTickerV1");return await this[s](e,t)}parseTicker(e,t=void 0){const s=this.safeValue(e,"volume",{}),i=this.safeInteger(s,"timestamp");let n;const r=this.safeStringLower(e,"pair");t=this.safeMarket(r,t);let a,o,d,c;r!==void 0&&t===void 0&&(r.length-0===7?(a=r.slice(0,4),o=r.slice(4,7)):(a=r.slice(0,3),o=r.slice(3,6)),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o),n=d+"/"+c),n===void 0&&t!==void 0&&(n=t.symbol,a=this.safeStringUpper(t,"baseId"),o=this.safeStringUpper(t,"quoteId"));const u=this.safeString(e,"price"),h=this.safeString2(e,"last","close",u),l=this.safeString(e,"percentChange24h"),p=this.safeString(e,"open"),m=this.safeString(s,a),g=this.safeString(s,o);return this.safeTicker({symbol:n,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:p,close:h,last:h,previousClose:void 0,change:void 0,percentage:l,average:void 0,baseVolume:m,quoteVolume:g,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetV1Pricefeed(t);return this.parseTickers(s,e)}parseTrade(e,t=void 0){const s=this.safeInteger(e,"timestampms"),i=this.safeString(e,"tid"),n=this.safeString(e,"order_id"),r=this.safeString(e,"fee_currency"),a=this.safeCurrencyCode(r),o={cost:this.safeString(e,"fee_amount"),currency:a},d=this.safeString(e,"price"),c=this.safeString(e,"amount"),u=this.safeStringLower(e,"type"),h=this.safeSymbol(void 0,t);return this.safeTrade({id:i,order:n,info:e,timestamp:s,datetime:this.iso8601(s),symbol:h,type:void 0,side:u,takerOrMaker:void 0,price:d,cost:void 0,amount:c,fee:o},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit_trades=s),t!==void 0&&(r.timestamp=t);const a=await this.publicGetV1TradesSymbol(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"available"),a.total=this.safeString(i,"amount"),t[r]=a}return this.safeBalance(t)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostV1Notionalvolume(e),s=this.safeString(t,"api_maker_fee_bps"),i=this.safeString(t,"api_taker_fee_bps"),n=cv.stringDiv(s,"10000"),r=cv.stringDiv(i,"10000"),a=this.parseNumber(n),o=this.parseNumber(r),d={};for(let c=0;c<this.symbols.length;c++){const u=this.symbols[c];d[u]={info:t,symbol:u,maker:a,taker:o,percentage:!0,tierBased:!0}}return d}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostV1Balances(e);return this.parseBalance(t)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"timestampms"),i=this.safeString(e,"original_amount"),n=this.safeString(e,"remaining_amount"),r=this.safeString(e,"executed_amount");let a="closed";e.is_live&&(a="open"),e.is_cancelled&&(a="canceled");const o=this.safeString(e,"price"),d=this.safeString(e,"avg_execution_price");let c=this.safeString(e,"type");c==="exchange limit"?c="limit":c==="market buy"||c==="market sell"?c="market":c=e.type;const u=void 0,h=this.safeString(e,"symbol"),l=this.safeSymbol(h,t),p=this.safeString(e,"order_id"),m=this.safeStringLower(e,"side"),g=this.safeString(e,"client_order_id"),y=this.safeValue(e,"options",[]),b=this.safeString(y,0);let w="GTC",k=!1;return b!==void 0&&(b==="immediate-or-cancel"?w="IOC":b==="fill-or-kill"?w="FOK":b==="maker-or-cancel"&&(w="PO",k=!0)),this.safeOrder({id:p,clientOrderId:g,info:e,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,status:a,symbol:l,type:c,timeInForce:w,postOnly:k,side:m,price:o,stopPrice:void 0,average:d,cost:void 0,amount:i,filled:r,remaining:n,fee:u,trades:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privatePostV1OrderStatus(this.extend(i,s));return this.parseOrder(n)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=await this.privatePostV1Orders(i);let r;return e!==void 0&&(r=this.market(e)),this.parseOrders(n,r,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){if(await this.loadMarkets(),t!=="limit")throw new Pc(this.id+" createOrder() allows limit orders only");let a=this.safeString2(r,"clientOrderId","client_order_id");r=this.omit(r,["clientOrderId","client_order_id"]),a===void 0&&(a=this.milliseconds().toString());const o=this.market(e),d=this.amountToPrecision(e,i),c=this.priceToPrecision(e,n),u={client_order_id:a.toString(),symbol:o.id,amount:d,price:c,side:s,type:"exchange limit"};t=this.safeString(r,"type",t),r=this.omit(r,"type");const h=this.safeString2(r,"stop_price","stopPrice");if(r=this.omit(r,["stop_price","stopPrice","type"]),t==="stopLimit")throw new M0(this.id+" createOrder() requires a stopPrice parameter or a stop_price parameter for "+t+" orders");if(h!==void 0)u.stop_price=this.priceToPrecision(e,h),u.type="exchange stop limit";else{const p=this.safeString(r,"timeInForce");r=this.omit(r,"timeInForce"),p!==void 0&&(p==="IOC"||p==="immediate-or-cancel"?u.options=["immediate-or-cancel"]:p==="FOK"||p==="fill-or-kill"?u.options=["fill-or-kill"]:p==="PO"&&(u.options=["maker-or-cancel"]));const m=this.safeValue(r,"postOnly",!1);r=this.omit(r,"postOnly"),m&&(u.options=["maker-or-cancel"]);const g=this.safeString(r,"options");g!==void 0&&(u.options=[g])}const l=await this.privatePostV1OrderNew(this.extend(u,r));return this.parseOrder(l)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privatePostV1OrderCancel(this.extend(i,s));return this.parseOrder(n)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new M0(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit_trades=s),t!==void 0&&(r.timestamp=parseInt(t/1e3));const a=await this.privatePostV1Mytrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,amount:t,address:s},o=await this.privatePostV1WithdrawCurrency(this.extend(a,n));if(this.safeString(o,"result")==="error")throw new Pc(this.id+" withdraw() failed: "+this.json(o));return this.parseTransaction(o,r)}nonce(){return this.milliseconds()}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};s!==void 0&&(n.limit_transfers=s),t!==void 0&&(n.timestamp=t);const r=await this.privatePostV1Transfers(this.extend(n,i));return this.parseTransactions(r)}parseTransaction(e,t=void 0){const s=this.safeInteger(e,"timestampms"),i=this.safeString(e,"currency"),n=this.safeCurrencyCode(i,t),r=this.safeString(e,"destination"),a=this.safeStringLower(e,"type"),o=this.safeString(e,"status");let d;const c=this.safeNumber(e,"feeAmount");return c!==void 0&&(d={cost:c,currency:n}),{info:e,id:this.safeString2(e,"eid","withdrawalId"),txid:this.safeString(e,"txHash"),timestamp:s,datetime:this.iso8601(s),network:void 0,address:r,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:a,amount:this.safeNumber(e,"amount"),currency:n,status:this.parseTransactionStatus(o),updated:void 0,fee:d}}parseTransactionStatus(e){const t={Advanced:"ok",Complete:"ok"};return this.safeString(t,e,e)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address");return{currency:this.safeCurrencyCode(void 0,t),network:void 0,address:s,tag:void 0,info:e}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const s=this.safeString(t,"network");if(s===void 0)throw new M0(this.id+" fetchDepositAddressesByNetwork() requires a network parameter");t=this.omit(t,"network");const i=this.safeValue(this.options,"networks",{}),n=this.safeString(i,s,s),r=this.safeValue(this.options,"networkIds",{}),a=this.safeString(r,n,s),o={network:n},d=await this.privatePostV1AddressesNetwork(this.extend(o,t)),c=this.parseDepositAddresses(d,[e],!1,{network:a,currency:e});return this.groupBy(c,"network")}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="private"){if(this.checkRequiredCredentials(),this.apiKey.indexOf("account")<0)throw new Ga(this.id+" sign() requires an account-key, master-keys are not-supported");const c=this.nonce(),u=this.extend({request:a,nonce:c},o);let h=this.json(u);h=this.stringToBase64(h);const l=this.hmac(h,this.encode(this.secret),"sha384");n={"Content-Type":"text/plain","X-GEMINI-APIKEY":this.apiKey,"X-GEMINI-PAYLOAD":this.decode(h),"X-GEMINI-SIGNATURE":l}}else Object.keys(o).length&&(a+="?"+this.urlencode(o));return a=this.urls.api[t]+a,(s==="POST"||s==="DELETE")&&(r=this.json(o)),{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0){if(typeof r=="string"){const u=this.id+" "+r;this.throwBroadlyMatchedException(this.exceptions.broad,r,u)}return}if(this.safeString(a,"result")==="error"){const u=this.safeString(a,"reason"),h=this.safeString(a,"message"),l=this.id+" "+h;throw this.throwExactlyMatchedException(this.exceptions.exact,u,l),this.throwExactlyMatchedException(this.exceptions.exact,h,l),this.throwBroadlyMatchedException(this.exceptions.broad,h,l),new Pc(l)}}async createDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.privatePostV1DepositCurrencyNewAddress(this.extend(i,t)),r=this.safeString(n,"address");return this.checkAddress(r),{currency:e,address:r,tag:void 0,info:n}}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={timeframe:this.timeframes[t],symbol:r.id},o=await this.publicGetV2CandlesSymbolTimeframe(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}};const XF=ge,{TICK_SIZE:YF}=me,QF=Se,{BadSymbol:A0,BadRequest:Ii,OnMaintenance:ZF,AccountSuspended:B0,PermissionDenied:E0,ExchangeError:_t,RateLimitExceeded:JF,ExchangeNotAvailable:uv,OrderNotFound:eD,InsufficientFunds:tD,InvalidOrder:Uf,AuthenticationError:N0,ArgumentsRequired:$f,NotSupported:sD}=de;var iD=class extends XF{describe(){return this.deepExtend(super.describe(),{id:"hitbtc3",name:"HitBTC",countries:["HK"],rateLimit:3.333,version:"3",pro:!0,has:{CORS:!1,spot:!0,margin:!0,swap:!0,future:!1,option:void 0,addMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!0,fetchBalance:!0,fetchBorrowRate:void 0,fetchBorrowRateHistories:void 0,fetchBorrowRateHistory:void 0,fetchBorrowRates:void 0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:void 0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchIndexOHLCV:!0,fetchLeverage:!0,fetchLeverageTiers:void 0,fetchMarketLeverageTiers:void 0,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrder:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!0,fetchOrders:!1,fetchOrderTrades:!0,fetchPosition:!0,fetchPositions:!0,fetchPremiumIndexOHLCV:!0,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransactions:!0,fetchWithdrawals:!0,reduceMargin:!0,setLeverage:!0,setMarginMode:!1,setPositionMode:!1,transfer:!0,withdraw:!0},precisionMode:YF,urls:{logo:"https://user-images.githubusercontent.com/1294454/27766555-8eaec20e-5edc-11e7-9c5b-6dc69fc42f5e.jpg",test:{public:"https://api.demo.hitbtc.com",private:"https://api.demo.hitbtc.com"},api:{public:"https://api.hitbtc.com/api/3",private:"https://api.hitbtc.com/api/3"},www:"https://hitbtc.com",referral:"https://hitbtc.com/?ref_id=5a5d39a65d466",doc:["https://api.hitbtc.com","https://github.com/hitbtc-com/hitbtc-api/blob/master/APIv2.md"],fees:["https://hitbtc.com/fees-and-limits","https://support.hitbtc.com/hc/en-us/articles/115005148605-Fees-and-limits"]},api:{public:{get:{"public/currency":10,"public/symbol":10,"public/ticker":10,"public/price/rate":10,"public/trades":10,"public/orderbook":10,"public/candles":10,"public/futures/info":10,"public/futures/history/funding":10,"public/futures/candles/index_price":10,"public/futures/candles/mark_price":10,"public/futures/candles/premium_index":10,"public/futures/candles/open_interest":10}},private:{get:{"spot/balance":15,"spot/order":15,"spot/order/{client_order_id}":15,"spot/fee":15,"spot/fee/{symbol}":15,"spot/history/order":15,"spot/history/trade":15,"margin/account":15,"margin/account/isolated/{symbol}":15,"margin/order":15,"margin/order/{client_order_id}":15,"margin/history/clearing":15,"margin/history/order":15,"margin/history/positions":15,"margin/history/trade":15,"futures/balance":15,"futures/account":15,"futures/account/isolated/{symbol}":15,"futures/order":15,"futures/order/{client_order_id}":15,"futures/fee":15,"futures/fee/{symbol}":15,"futures/history/clearing":15,"futures/history/order":15,"futures/history/positions":15,"futures/history/trade":15,"wallet/balance":15,"wallet/crypto/address":15,"wallet/crypto/address/recent-deposit":15,"wallet/crypto/address/recent-withdraw":15,"wallet/crypto/address/check-mine":15,"wallet/transactions":15,"wallet/crypto/check-offchain-available":15,"wallet/crypto/fee/estimate":15,"sub-account":15,"sub-account/acl":15,"sub-account/balance/{subAccID}":15,"sub-account/crypto/address/{subAccID}/{currency}":15},post:{"spot/order":1,"margin/order":1,"futures/order":1,"wallet/convert":15,"wallet/crypto/address":15,"wallet/crypto/withdraw":15,"wallet/transfer":15,"sub-account/freeze":15,"sub-account/activate":15,"sub-account/transfer":15,"sub-account/acl":15},patch:{"spot/order/{client_order_id}":1,"margin/order/{client_order_id}":1,"futures/order/{client_order_id}":1},delete:{"spot/order":1,"spot/order/{client_order_id}":1,"margin/position":1,"margin/position/isolated/{symbol}":1,"margin/order":1,"margin/order/{client_order_id}":1,"futures/position":1,"futures/position/isolated/{symbol}":1,"futures/order":1,"futures/order/{client_order_id}":1,"wallet/crypto/withdraw/{id}":1},put:{"margin/account/isolated/{symbol}":1,"futures/account/isolated/{symbol}":1,"wallet/crypto/withdraw/{id}":1}}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0009"),maker:this.parseNumber("0.0009"),tiers:{maker:[[this.parseNumber("0"),this.parseNumber("0.0009")],[this.parseNumber("10"),this.parseNumber("0.0007")],[this.parseNumber("100"),this.parseNumber("0.0006")],[this.parseNumber("500"),this.parseNumber("0.0005")],[this.parseNumber("1000"),this.parseNumber("0.0003")],[this.parseNumber("5000"),this.parseNumber("0.0002")],[this.parseNumber("10000"),this.parseNumber("0.0001")],[this.parseNumber("20000"),this.parseNumber("0")],[this.parseNumber("50000"),this.parseNumber("-0.0001")],[this.parseNumber("100000"),this.parseNumber("-0.0001")]],taker:[[this.parseNumber("0"),this.parseNumber("0.0009")],[this.parseNumber("10"),this.parseNumber("0.0008")],[this.parseNumber("100"),this.parseNumber("0.0007")],[this.parseNumber("500"),this.parseNumber("0.0007")],[this.parseNumber("1000"),this.parseNumber("0.0006")],[this.parseNumber("5000"),this.parseNumber("0.0006")],[this.parseNumber("10000"),this.parseNumber("0.0005")],[this.parseNumber("20000"),this.parseNumber("0.0004")],[this.parseNumber("50000"),this.parseNumber("0.0003")],[this.parseNumber("100000"),this.parseNumber("0.0002")]]}}},timeframes:{"1m":"M1","3m":"M3","5m":"M5","15m":"M15","30m":"M30","1h":"H1","4h":"H4","1d":"D1","1w":"D7","1M":"1M"},exceptions:{exact:{429:JF,500:_t,503:uv,504:uv,600:E0,800:_t,1002:N0,1003:E0,1004:N0,1005:N0,2001:A0,2002:Ii,2003:Ii,2010:Ii,2011:Ii,2012:Ii,2020:Ii,2022:Ii,10001:Ii,10021:B0,10022:Ii,20001:tD,20002:eD,20003:_t,20004:_t,20005:_t,20006:_t,20007:_t,20008:Uf,20009:Uf,20010:ZF,20011:_t,20012:_t,20014:_t,20016:_t,20031:_t,20032:_t,20033:_t,20034:_t,20040:_t,20041:_t,20042:_t,20043:_t,20044:E0,20045:Uf,20080:_t,21001:_t,21003:B0,21004:B0},broad:{}},options:{networks:{ETH:"USDT20",ERC20:"USDT20",TRX:"USDTRX",TRC20:"USDTRX",OMNI:"USDT"},accountsByType:{spot:"spot",funding:"wallet",future:"derivatives"}},commonCurrencies:{AUTO:"Cube",BCC:"BCC",BDP:"BidiPass",BET:"DAO.Casino",BIT:"BitRewards",BOX:"BOX Token",CPT:"Cryptaur",GET:"Themis",GMT:"GMT Token",HSR:"HC",IQ:"IQ.Cash",LNC:"LinkerCoin",PLA:"PlayChip",PNT:"Penta",SBTC:"Super Bitcoin",STEPN:"GMT",STX:"STOX",TV:"Tokenville",USD:"USDT",XMT:"MTL",XPNT:"PNT"}})}nonce(){return this.milliseconds()}async fetchMarkets(e={}){const t=await this.publicGetPublicSymbol(e),s=[],i=Object.keys(t);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeValue(t,r),o=this.safeString(a,"type"),d=this.safeInteger(a,"expiry"),c=o==="futures",u=o==="spot",h=this.safeValue(a,"margin_trading",!1),l=u&&h,p=d!==void 0,m=c&&!p,g=!1,y=this.safeString2(a,"base_currency","underlying"),b=this.safeString(a,"quote_currency"),w=this.safeString(a,"fee_currency"),k=this.safeCurrencyCode(y),T=this.safeCurrencyCode(b),O=this.safeCurrencyCode(w);let x,C,E=k+"/"+T,P="spot",_,S,I;c&&(_=this.parseNumber("1"),x=w,C=this.safeCurrencyCode(x),S=T!==void 0&&T===C,I=!S,E=E+":"+C,p?(E=E+"-"+d,P="future"):P="swap");const v=this.safeString(a,"quantity_increment"),N=this.safeString(a,"tick_size"),q=this.parseNumber(v),R=this.parseNumber(N);s.push({id:r,symbol:E,base:k,quote:T,settle:C,baseId:y,quoteId:b,settleId:x,type:P,spot:u,margin:l,swap:m,future:p,option:g,active:!0,contract:c,linear:S,inverse:I,taker:this.safeNumber(a,"take_rate"),maker:this.safeNumber(a,"make_rate"),contractSize:_,expiry:d,expiryDatetime:void 0,strike:void 0,optionType:void 0,feeCurrency:O,precision:{amount:q,price:R},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(a,"max_initial_leverage",1)},amount:{min:q,max:void 0},price:{min:R,max:void 0},cost:{min:this.parseNumber(QF.stringMul(v,N)),max:void 0}},info:a})}return s}async fetchCurrencies(e={}){const t=await this.publicGetPublicCurrency(e),s={},i=Object.keys(t);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeCurrencyCode(r),o=t[r],d=this.safeString(o,"full_name"),c=this.safeNumber(o,"precision_transfer"),u=this.safeValue(o,"payin_enabled",!1),h=this.safeValue(o,"payout_enabled",!1),l=this.safeValue(o,"transfer_enabled",!1),p=u&&h&&l,m=this.safeValue(o,"networks",[]),g={};let y,b,w;for(let O=0;O<m.length;O++){const x=m[O],C=this.safeString2(x,"protocol","network"),E=this.safeNetwork(C);y=this.safeNumber(x,"payout_fee");const P=this.safeNumber(x,"precision_payout"),_=this.safeValue(o,"payin_enabled",!1),S=this.safeValue(o,"payout_enabled",!1),I=_&&S;_&&!b?b=!0:_||(b=!1),S&&!w?w=!0:S||(w=!1),g[E]={info:x,id:C,network:E,fee:y,active:I,deposit:_,withdraw:S,precision:P,limits:{withdraw:{min:void 0,max:void 0}}}}const T=Object.keys(g).length;s[a]={info:o,code:a,id:r,precision:c,name:d,active:p,deposit:b,withdraw:w,networks:g,fee:T<=1?y:void 0,limits:{amount:{min:void 0,max:void 0}}}}return s}safeNetwork(e){if(e!==void 0)return e.toUpperCase()}async createDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=this.safeStringUpper(t,"network");if(n!==void 0&&e==="USDT"){const o=this.safeValue(this.options,"networks"),d=this.safeString(o,n);d!==void 0&&(i.currency=d),t=this.omit(t,"network")}const r=await this.privatePostWalletCryptoAddress(this.extend(i,t)),a=this.safeString(r,"currency");return{currency:this.safeCurrencyCode(a),address:this.safeString(r,"address"),tag:this.safeString(r,"payment_id"),network:void 0,info:r}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=this.safeStringUpper(t,"network");if(n!==void 0&&e==="USDT"){const h=this.safeValue(this.options,"networks"),l=this.safeString(h,n);l!==void 0&&(i.currency=l),t=this.omit(t,"network")}const r=await this.privateGetWalletCryptoAddress(this.extend(i,t)),a=this.safeValue(r,0),o=this.safeString(a,"address"),d=this.safeString(a,"currency"),c=this.safeString(a,"payment_id"),u=this.safeCurrencyCode(d);return{info:r,address:o,tag:c,code:u,currency:u,network:void 0}}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"available"),a.used=this.safeString(i,"reserved"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){const t=this.safeStringLower(e,"type","spot");e=this.omit(e,["type"]);const s=this.safeValue(this.options,"accountsByType",{}),i=this.safeString(s,t,t);let n;if(i==="wallet")n=await this.privateGetWalletBalance(e);else if(i==="spot")n=await this.privateGetSpotBalance(e);else if(i==="derivatives")n=await this.privateGetFuturesBalance(e);else{const r=Object.keys(s);throw new Ii(this.id+" fetchBalance() type parameter must be one of "+r.join(", "))}return this.parseBalance(n)}async fetchTicker(e,t={}){const s=await this.fetchTickers([e],t);return this.safeValue(s,e)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={};if(e!==void 0){const o=this.marketIds(e).join(",");s.symbols=o}const i=await this.publicGetPublicTicker(this.extend(s,t)),n={},r=Object.keys(i);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeMarket(o),c=d.symbol,u=i[o];n[c]=this.parseTicker(u,d)}return this.filterByArray(n,"symbol",e)}parseTicker(e,t=void 0){const s=this.parse8601(e.timestamp),i=this.safeSymbol(void 0,t),n=this.safeString(e,"volume"),r=this.safeString(e,"volume_quote"),a=this.safeString(e,"open"),o=this.safeString(e,"last");return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:a,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:n,quoteVolume:r,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbols=n.id),s!==void 0&&(r.limit=s),t!==void 0&&(r.from=t);const a=await this.publicGetPublicTrades(this.extend(r,i)),o=Object.keys(a);let d=[];for(let c=0;c<o.length;c++){const u=o[c],h=this.market(u),l=a[u],p=this.parseTrades(l,h);d=this.arrayConcat(d,p)}return d}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),s!==void 0&&(r.limit=s),t!==void 0&&(r.from=t);let a;[a,i]=this.handleMarketTypeAndParams("fetchMyTrades",n,i);let o=this.getSupportedMapping(a,{spot:"privateGetSpotHistoryTrade",swap:"privateGetFuturesHistoryTrade",margin:"privateGetMarginHistoryTrade"});const[d,c]=this.handleMarginModeAndParams("fetchMyTrades",i);d!==void 0&&(o="privateGetMarginHistoryTrade");const u=await this[o](this.extend(r,c));return this.parseTrades(u,n,t,s)}parseTrade(e,t=void 0){const s=this.parse8601(e.timestamp),i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const n=t.symbol;let r;const a=this.safeString(e,"fee"),o=this.safeValue(e,"taker");let d;if(o!==void 0&&(d=o?"taker":"maker"),a!==void 0){const m=this.safeValue(t,"info",{}),g=this.safeString(m,"fee_currency"),y=this.safeCurrencyCode(g);r={cost:a,currency:y}}const c=this.safeString(e,"clientOrderId"),u=this.safeString(e,"price"),h=this.safeString2(e,"quantity","qty"),l=this.safeString(e,"side"),p=this.safeString(e,"id");return this.safeTrade({info:e,id:p,order:c,timestamp:s,datetime:this.iso8601(s),symbol:n,type:void 0,side:l,takerOrMaker:d,price:u,amount:h,cost:void 0,fee:r},t)}async fetchTransactionsHelper(e,t,s,i,n){await this.loadMarkets();const r={types:e};let a;t!==void 0&&(a=this.currency(t),r.currencies=a.id),s!==void 0&&(r.from=this.iso8601(s)),i!==void 0&&(r.limit=i);const o=await this.privateGetWalletTransactions(this.extend(r,n));return this.parseTransactions(o,a,s,i,n)}parseTransactionStatus(e){const t={PENDING:"pending",FAILED:"failed",SUCCESS:"ok"};return this.safeString(t,e,e)}parseTransactionType(e){const t={DEPOSIT:"deposit",WITHDRAW:"withdrawal"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.parse8601(this.safeString(e,"created_at")),n=this.parse8601(this.safeString(e,"updated_at")),r=this.parseTransactionType(this.safeString(e,"type")),a=this.parseTransactionStatus(this.safeString(e,"status")),o=this.safeValue(e,"native",{}),d=this.safeString(o,"currency"),c=this.safeCurrencyCode(d),u=this.safeString(o,"hash"),h=this.safeString(o,"address"),l=h,p=this.safeString(o,"payment_id"),m=p,g=this.safeValue(o,"senders"),y=this.safeString(g,0),b=this.safeNumber(o,"amount");let w;const k=this.safeNumber(o,"fee");return k!==void 0&&(w={currency:c,cost:k}),{info:e,id:s,txid:u,code:c,currency:c,amount:b,network:void 0,address:h,addressFrom:y,addressTo:l,tag:p,tagFrom:void 0,tagTo:m,timestamp:i,datetime:this.iso8601(i),updated:n,status:a,type:r,fee:w}}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsHelper("DEPOSIT,WITHDRAW",e,t,s,i)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsHelper("DEPOSIT",e,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsHelper("WITHDRAW",e,t,s,i)}async fetchOrderBooks(e=void 0,t=void 0,s={}){await this.loadMarkets();const i={};if(e!==void 0){const o=this.marketIds(e);i.symbols=o.join(",")}t!==void 0&&(i.depth=t);const n=await this.publicGetPublicOrderbook(this.extend(i,s)),r={},a=Object.keys(n);for(let o=0;o<a.length;o++){const d=a[o],c=n[d],u=this.safeSymbol(d),h=this.parse8601(this.safeString(c,"timestamp"));r[u]=this.parseOrderBook(n[d],u,h,"bid","ask")}return r}async fetchOrderBook(e,t=void 0,s={}){return(await this.fetchOrderBooks([e],t,s))[e]}parseTradingFee(e,t=void 0){const s=this.safeNumber(e,"take_rate"),i=this.safeNumber(e,"make_rate"),n=this.safeString(e,"symbol"),r=this.safeSymbol(n,t);return{info:e,symbol:r,taker:s,maker:i}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=this.getSupportedMapping(s.type,{spot:"privateGetSpotFeeSymbol",swap:"privateGetFuturesFeeSymbol"}),r=await this[n](this.extend(i,t));return this.parseTradingFee(r,s)}async fetchTradingFees(e=void 0,t={}){await this.loadMarkets();const[s,i]=this.handleMarketTypeAndParams("fetchTradingFees",void 0,t),n=this.getSupportedMapping(s,{spot:"privateGetSpotFee",swap:"privateGetFuturesFee"}),r=await this[n](i),a={};for(let o=0;o<r.length;o++){const d=this.parseTradingFee(r[o]),c=d.symbol;a[c]=d}return a}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbols:r.id,period:this.timeframes[t]};s!==void 0&&(a.from=this.iso8601(s)),i!==void 0&&(a.limit=i);const o=this.safeString(n,"price");n=this.omit(n,"price");let d="publicGetPublicCandles";o==="mark"?d="publicGetPublicFuturesCandlesMarkPrice":o==="index"?d="publicGetPublicFuturesCandlesIndexPrice":o==="premiumIndex"&&(d="publicGetPublicFuturesCandlesPremiumIndex");const c=await this[d](this.extend(a,n)),u=this.safeValue(c,r.id);return this.parseOHLCVs(u,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"timestamp")),this.safeNumber(e,"open"),this.safeNumber(e,"max"),this.safeNumber(e,"min"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),t!==void 0&&(r.from=this.iso8601(t)),s!==void 0&&(r.limit=s);let a;[a,i]=this.handleMarketTypeAndParams("fetchClosedOrders",n,i);let o=this.getSupportedMapping(a,{spot:"privateGetSpotHistoryOrder",swap:"privateGetFuturesHistoryOrder",margin:"privateGetMarginHistoryOrder"});const[d,c]=this.handleMarginModeAndParams("fetchClosedOrders",i);d!==void 0&&(o="privateGetMarginHistoryOrder");const u=await this[o](this.extend(r,c)),h=this.parseOrders(u,n,t,s);return this.filterByArray(h,"status",["closed","canceled"],!1)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));let n;[n,s]=this.handleMarketTypeAndParams("fetchOrder",i,s);let r=this.getSupportedMapping(n,{spot:"privateGetSpotHistoryOrder",swap:"privateGetFuturesHistoryOrder",margin:"privateGetMarginHistoryOrder"});const[a,o]=this.handleMarginModeAndParams("fetchOrder",s);a!==void 0&&(r="privateGetMarginHistoryOrder");const d={client_order_id:e},c=await this[r](this.extend(d,o)),u=this.safeValue(c,0);return this.parseOrder(u,i)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;t!==void 0&&(r=this.market(t));const a={order_id:e};let o;[o,n]=this.handleMarketTypeAndParams("fetchOrderTrades",r,n);let d=this.getSupportedMapping(o,{spot:"privateGetSpotHistoryTrade",swap:"privateGetFuturesHistoryTrade",margin:"privateGetMarginHistoryTrade"});const[c,u]=this.handleMarginModeAndParams("fetchOrderTrades",n);c!==void 0&&(d="privateGetMarginHistoryTrade");const h=await this[d](this.extend(a,u));return this.parseTrades(h,r,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id);let a;[a,i]=this.handleMarketTypeAndParams("fetchOpenOrders",n,i);let o=this.getSupportedMapping(a,{spot:"privateGetSpotOrder",swap:"privateGetFuturesOrder",margin:"privateGetMarginOrder"});const[d,c]=this.handleMarginModeAndParams("fetchOpenOrders",i);d!==void 0&&(o="privateGetMarginOrder");const u=await this[o](this.extend(r,c));return this.parseOrders(u,n,t,s)}async fetchOpenOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));let n;[n,s]=this.handleMarketTypeAndParams("fetchOpenOrder",i,s);let r=this.getSupportedMapping(n,{spot:"privateGetSpotOrderClientOrderId",swap:"privateGetFuturesOrderClientOrderId",margin:"privateGetMarginOrderClientOrderId"});const[a,o]=this.handleMarginModeAndParams("fetchOpenOrder",s);a!==void 0&&(r="privateGetMarginOrderClientOrderId");const d={client_order_id:e},c=await this[r](this.extend(d,o));return this.parseOrder(c,i)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();let s;const i={};e!==void 0&&(s=this.market(e),i.symbol=s.id);let n;[n,t]=this.handleMarketTypeAndParams("cancelAllOrders",s,t);let r=this.getSupportedMapping(n,{spot:"privateDeleteSpotOrder",swap:"privateDeleteFuturesOrder",margin:"privateDeleteMarginOrder"});const[a,o]=this.handleMarginModeAndParams("cancelAllOrders",t);a!==void 0&&(r="privateDeleteMarginOrder");const d=await this[r](this.extend(i,o));return this.parseOrders(d,s)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();let i;const n={client_order_id:e};t!==void 0&&(i=this.market(t));let r;[r,s]=this.handleMarketTypeAndParams("cancelOrder",i,s);let a=this.getSupportedMapping(r,{spot:"privateDeleteSpotOrderClientOrderId",swap:"privateDeleteFuturesOrderClientOrderId",margin:"privateDeleteMarginOrderClientOrderId"});const[o,d]=this.handleMarginModeAndParams("cancelOrder",s);o!==void 0&&(a="privateDeleteMarginOrderClientOrderId");const c=await this[a](this.extend(n,d));return this.parseOrder(c,i)}async editOrder(e,t,s,i,n,r=void 0,a={}){await this.loadMarkets();let o;const d={client_order_id:e,quantity:this.amountToPrecision(t,n)};if(s==="limit"||s==="stopLimit"){if(r===void 0)throw new _t(this.id+" editOrder() limit order requires price");d.price=this.priceToPrecision(t,r)}t!==void 0&&(o=this.market(t));let c;[c,a]=this.handleMarketTypeAndParams("editOrder",o,a);let u=this.getSupportedMapping(c,{spot:"privatePatchSpotOrderClientOrderId",swap:"privatePatchFuturesOrderClientOrderId",margin:"privatePatchMarginOrderClientOrderId"});const[h,l]=this.handleMarginModeAndParams("editOrder",a);h!==void 0&&(u="privatePatchMarginOrderClientOrderId");const p=await this[u](this.extend(d,l));return this.parseOrder(p,o)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={type:t,side:s,quantity:this.amountToPrecision(e,i),symbol:a.id},d=this.safeValue(r,"reduceOnly");if(d!==void 0&&a.type!=="swap"&&a.type!=="margin")throw new Uf(this.id+" createOrder() does not support reduce_only for "+a.type+" orders, reduce_only orders are supported for swap and margin markets only");d===!0&&(o.reduce_only=d);const c=this.safeString2(r,"timeInForce","time_in_force"),u=this.safeString(r,"expire_time"),h=this.safeNumber2(r,"stopPrice","stop_price");if(t==="limit"||t==="stopLimit"||t==="takeProfitLimit"){if(n===void 0)throw new _t(this.id+" createOrder() requires a price argument for limit orders");o.price=this.priceToPrecision(e,n)}if(c==="GTD"){if(u===void 0)throw new _t(this.id+" createOrder() requires an expire_time parameter for a GTD order");o.expire_time=u}if(t==="stopLimit"||t==="stopMarket"||t==="takeProfitLimit"||t==="takeProfitMarket"){if(h===void 0)throw new _t(this.id+" createOrder() requires a stopPrice parameter for stop-loss and take-profit orders");o.stop_price=this.priceToPrecision(e,h)}let l;[l,r]=this.handleMarketTypeAndParams("createOrder",a,r);let p=this.getSupportedMapping(l,{spot:"privatePostSpotOrder",swap:"privatePostFuturesOrder",margin:"privatePostMarginOrder"});const[m,g]=this.handleMarginModeAndParams("createOrder",r);m!==void 0&&(p="privatePostMarginOrder");const y=await this[p](this.extend(o,g));return this.parseOrder(y,a)}parseOrderStatus(e){const t={new:"open",suspended:"open",partiallyFilled:"open",filled:"closed",canceled:"canceled",expired:"failed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"client_order_id"),i=this.safeString(e,"side"),n=this.safeString(e,"type"),r=this.safeString(e,"quantity"),a=this.safeString(e,"price"),o=this.safeString(e,"price_average"),d=this.safeString(e,"created_at"),c=this.parse8601(d),u=this.safeString(e,"updated_at");let h;u!==d&&(h=this.parse8601(u));const l=this.safeString(e,"quantity_cumulative"),p=this.parseOrderStatus(this.safeString(e,"status")),m=this.safeString(e,"symbol");t=this.safeMarket(m,t);const g=t.symbol,y=this.safeValue(e,"post_only"),b=this.safeString(e,"time_in_force"),w=this.safeValue(e,"trades");return this.safeOrder({info:e,id:s,clientOrderId:s,timestamp:c,datetime:this.iso8601(c),lastTradeTimestamp:h,symbol:g,price:a,amount:r,type:n,side:i,timeInForce:b,postOnly:y,reduceOnly:this.safeValue(e,"reduce_only"),filled:l,remaining:void 0,cost:void 0,status:p,average:o,trades:w,fee:void 0},t)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.currencyToPrecision(e,t),o=this.safeValue(this.options,"accountsByType",{});s=s.toLowerCase(),i=i.toLowerCase();const d=this.safeString(o,s,s),c=this.safeString(o,i,i);if(d===c)throw new Ii(this.id+" transfer() fromAccount and toAccount arguments cannot be the same account");const u={currency:r.id,amount:a,source:d,destination:c},h=await this.privatePostWalletTransfer(this.extend(u,n)),l=this.parseTransfer(h,r);return this.extend(l,{fromAccount:s,toAccount:i,amount:this.parseNumber(a)})}parseTransfer(e,t=void 0){const s=this.milliseconds();return{id:this.safeString(e,0),timestamp:s,datetime:this.iso8601(s),currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0,info:e}}async convertCurrencyNetwork(e,t,s,i,n){if(await this.loadMarkets(),e!=="USDT")throw new _t(this.id+" convertCurrencyNetwork() only supports USDT currently");const r=this.safeValue(this.options,"networks",{});if(s=s.toUpperCase(),i=i.toUpperCase(),s=this.safeString(r,s),i=this.safeString(r,i),s===i)throw new Ii(this.id+" convertCurrencyNetwork() fromNetwork cannot be the same as toNetwork");if(s===void 0||i===void 0){const d=Object.keys(r);throw new $f(this.id+" convertCurrencyNetwork() requires a fromNetwork parameter and a toNetwork parameter, supported networks are "+d.join(", "))}const a={from_currency:s,to_currency:i,amount:this.currencyToPrecision(e,t)};return{info:await this.privatePostWalletConvert(this.extend(a,n))}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets(),this.checkAddress(s);const r=this.currency(e),a={currency:r.id,amount:t,address:s};i!==void 0&&(a.payment_id=i);const o=this.safeValue(this.options,"networks",{}),d=this.safeStringUpper(n,"network");if(d!==void 0&&e==="USDT"){const u=this.safeString(o,d);u!==void 0&&(a.currency=u),n=this.omit(n,"network")}const c=await this.privatePostWalletCryptoWithdraw(this.extend(a,n));return this.parseTransaction(c,r)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),e=n.symbol,r.symbols=n.id),t!==void 0&&(r.from=t),s!==void 0&&(r.limit=s);const a=await this.publicGetPublicFuturesHistoryFunding(this.extend(r,i)),o=Object.keys(a),d=[];for(let u=0;u<o.length;u++){const h=o[u],l=this.safeMarket(h),p=a[h];for(let m=0;m<p.length;m++){const g=p[m],y=this.safeSymbol(l.symbol),b=this.safeNumber(g,"funding_rate"),w=this.safeString(g,"timestamp");d.push({info:g,symbol:y,fundingRate:b,timestamp:this.parse8601(w),datetime:w})}}const c=this.sortBy(d,"timestamp");return this.filterBySymbolSinceLimit(c,e,t,s)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s={};let i;[i,t]=this.handleMarketTypeAndParams("fetchPositions",void 0,t);let n=this.getSupportedMapping(i,{swap:"privateGetFuturesAccount",margin:"privateGetMarginAccount"});const[r,a]=this.handleMarginModeAndParams("fetchPositions",t);r!==void 0&&(n="privateGetMarginAccount");const o=await this[n](this.extend(s,a)),d=[];for(let c=0;c<o.length;c++)d.push(this.parsePosition(o[c]));return d}async fetchPosition(e,t={}){await this.loadMarkets();let s;[s,t]=this.handleMarketTypeAndParams("fetchPosition",void 0,t);let i=this.getSupportedMapping(s,{swap:"privateGetFuturesAccountIsolatedSymbol",margin:"privateGetMarginAccountIsolatedSymbol"});const[n,r]=this.handleMarginModeAndParams("fetchPosition",t);n!==void 0&&(i="privateGetMarginAccountIsolatedSymbol");const a=this.market(e),o={symbol:a.id},d=await this[i](this.extend(o,r));return this.parsePosition(d,a)}parsePosition(e,t=void 0){const s=this.safeString(e,"type"),i=this.safeNumber(e,"leverage"),n=this.safeString(e,"updated_at"),r=this.safeValue(e,"positions",[]);let a,o,d;for(let p=0;p<r.length;p++){const m=r[p];a=this.safeNumber(m,"price_liquidation"),o=this.safeNumber(m,"price_entry"),d=this.safeNumber(m,"quantity")}const c=this.safeValue(e,"currencies",[]);let u;for(let p=0;p<c.length;p++){const m=c[p];u=this.safeNumber(m,"margin_balance")}const h=this.safeString(e,"symbol");t=this.safeMarket(h,t);const l=t.symbol;return{info:e,id:void 0,symbol:l,notional:void 0,marginMode:s,marginType:s,liquidationPrice:a,entryPrice:o,unrealizedPnl:void 0,percentage:void 0,contracts:d,contractSize:void 0,markPrice:void 0,side:void 0,hedged:void 0,timestamp:this.parse8601(n),datetime:n,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,collateral:u,initialMargin:void 0,initialMarginPercentage:void 0,leverage:i,marginRatio:void 0}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new A0(this.id+" fetchFundingRate() supports swap contracts only");const i={};e!==void 0&&(e=s.symbol,i.symbols=s.id);const n=await this.publicGetPublicFuturesInfo(this.extend(i,t)),r=this.safeValue(n,s.id,{});return this.parseFundingRate(r,s)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"next_funding_time"),i=this.safeString(e,"timestamp");return{info:e,symbol:this.safeSymbol(void 0,t),markPrice:this.safeNumber(e,"mark_price"),indexPrice:this.safeNumber(e,"index_price"),interestRate:this.safeNumber(e,"interest_rate"),estimatedSettlePrice:void 0,timestamp:this.parse8601(i),datetime:i,fundingRate:this.safeNumber(e,"funding_rate"),fundingTimestamp:this.parse8601(s),fundingDatetime:s,nextFundingRate:this.safeNumber(e,"indicative_funding_rate"),nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets();const n=this.market(e),r=this.safeString(i,"leverage");if(n.type==="swap"&&r===void 0)throw new $f(this.id+" modifyMarginHelper() requires a leverage parameter for swap markets");t=this.amountToPrecision(e,t);const a={symbol:n.id,margin_balance:t};r!==void 0&&(a.leverage=r);let o;[o,i]=this.handleMarketTypeAndParams("modifyMarginHelper",void 0,i);let d=this.getSupportedMapping(o,{swap:"privatePutFuturesAccountIsolatedSymbol",margin:"privatePutMarginAccountIsolatedSymbol"});const[c,u]=this.handleMarginModeAndParams("modifyMarginHelper",i);c!==void 0&&(d="privatePutMarginAccountIsolatedSymbol");const h=await this[d](this.extend(a,u));return this.extend(this.parseMarginModification(h,n),{amount:this.parseNumber(t),type:s})}parseMarginModification(e,t=void 0){const s=this.safeValue(e,"currencies",[]),i=this.safeValue(s,0);return{info:e,type:void 0,amount:void 0,code:this.safeString(i,"code"),symbol:t.symbol,status:void 0}}async reduceMargin(e,t,s={}){if(t!==0)throw new Ii(this.id+" reduceMargin() on hitbtc3 requires the amount to be 0 and that will remove the entire margin amount");return await this.modifyMarginHelper(e,t,"reduce",s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"add",s)}async fetchLeverage(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let n=this.getSupportedMapping(s.type,{spot:"privateGetMarginAccountIsolatedSymbol",margin:"privateGetMarginAccountIsolatedSymbol",swap:"privateGetFuturesAccountIsolatedSymbol"});const[r,a]=this.handleMarginModeAndParams("modifyMarginHelper",t);r!==void 0&&(n="privateGetMarginAccountIsolatedSymbol");const o=await this[n](this.extend(i,a));return this.safeNumber(o,"leverage")}async setLeverage(e,t=void 0,s={}){if(await this.loadMarkets(),t===void 0)throw new $f(this.id+" setLeverage() requires a symbol argument");if(s.margin_balance===void 0)throw new $f(this.id+" setLeverage() requires a margin_balance parameter that will transfer margin to the specified trading pair");const i=this.market(t),n=this.safeNumber(s,"margin_balance"),r=this.safeInteger(i.limits.leverage,"max",50);if(i.type!=="swap")throw new A0(this.id+" setLeverage() supports swap contracts only");if(e<1||e>r)throw new Ii(this.id+" setLeverage() leverage should be between 1 and "+r.toString()+" for "+t);const a={symbol:i.id,leverage:e.toString(),margin_balance:this.amountToPrecision(t,n)};return await this.privatePutFuturesAccountIsolatedSymbol(this.extend(a,s))}handleMarginModeAndParams(e,t={},s=void 0){const i=this.safeString(this.options,"defaultType"),n=this.safeValue(t,"margin",!1);let r;if([r,t]=super.handleMarginModeAndParams(e,t,s),r!==void 0){if(r!=="isolated")throw new sD(this.id+" only isolated margin is supported")}else(i==="margin"||n===!0)&&(r="isolated");return[r,t]}handleErrors(e,t,s,i,n,r,a,o,d){const c=this.safeValue(a,"error"),u=this.safeString(c,"code");if(u!==void 0){const h=this.id+" "+r,l=this.safeString2(c,"message","description");throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwBroadlyMatchedException(this.exceptions.broad,l,h),new _t(h)}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.omit(i,this.extractParams(e)),o=this.implodeParams(e,i);let d=this.urls.api[t]+"/"+o,c;const h=Object.keys(a).length;if(n={"Content-Type":"application/json"},s==="GET"?h&&(c="?"+this.urlencode(a),d=d+c):r=this.json(i),t==="private"){this.checkRequiredCredentials();const l=this.nonce().toString(),p=[s,"/api/3/"+o];s==="GET"?c!==void 0&&p.push(c):p.push(r),p.push(l);const m=p.join(""),g=this.hmac(this.encode(m),this.encode(this.secret),"sha256","hex"),y=this.apiKey+":"+g+":"+l,b=this.decode(this.stringToBase64(y));n.Authorization="HS256 "+b}return{url:d,method:s,body:r,headers:n}}};const nD=ge,{BadRequest:Ac,AuthenticationError:fv,NetworkError:hv,ArgumentsRequired:lv,OrderImmediatelyFillable:rD,OrderNotFound:pv,InsufficientFunds:aD}=de,{TICK_SIZE:oD}=me,mv=Se;var Y_=class extends nD{describe(){return this.deepExtend(super.describe(),{id:"hollaex",name:"HollaEx",countries:["KR"],rateLimit:250,version:"v2",pro:!0,has:{CORS:void 0,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,createLimitBuyOrder:!0,createLimitSellOrder:!0,createMarketBuyOrder:!0,createMarketSellOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:"emulated",fetchDepositAddresses:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:void 0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","1h":"1h","4h":"4h","1d":"1d","1w":"1w"},urls:{logo:"https://user-images.githubusercontent.com/1294454/75841031-ca375180-5ddd-11ea-8417-b975674c23cb.jpg",test:{rest:"https://api.sandbox.hollaex.com"},api:{rest:"https://api.hollaex.com"},www:"https://hollaex.com",doc:"https://apidocs.hollaex.com",referral:"https://pro.hollaex.com/signup?affiliation_code=QSWA6G"},precisionMode:oD,requiredCredentials:{apiKey:!0,secret:!0},api:{public:{get:{health:1,constants:1,kit:1,tiers:1,ticker:1,tickers:1,orderbook:1,orderbooks:1,trades:1,chart:1,charts:1,"udf/config":1,"udf/history":1,"udf/symbols":1}},private:{get:{user:1,"user/balance":1,"user/deposits":1,"user/withdrawals":1,"user/withdrawal/fee":1,"user/trades":1,orders:1,order:1},post:{"user/withdrawal":1,order:1},delete:{"order/all":1,order:1}}},fees:{trading:{tierBased:!0,percentage:!0,taker:.001,maker:.001}},exceptions:{broad:{"Invalid token":fv,"Order not found":pv,"Insufficient balance":aD,"Error 1001 - Order rejected. Order could not be submitted as this order was set to a post only order.":rD},exact:{400:Ac,403:fv,404:Ac,405:Ac,410:Ac,429:Ac,500:hv,503:hv}},options:{"api-expires":parseInt(this.timeout/1e3),networks:{BTC:"btc",ETH:"eth",ERC20:"eth",TRX:"trx",TRC20:"trx",XRP:"xrp",XLM:"xlm"}}})}async fetchMarkets(e={}){const t=await this.publicGetConstants(e),s=this.safeValue(t,"pairs",{}),i=Object.keys(s),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=s[a],d=this.safeString(o,"pair_base"),c=this.safeString(o,"pair_2"),u=this.commonCurrencyCode(d.toUpperCase()),h=this.commonCurrencyCode(c.toUpperCase());n.push({id:this.safeString(o,"name"),symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:this.safeValue(o,"active"),contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(o,"increment_size"),price:this.safeNumber(o,"increment_price")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(o,"min_size"),max:this.safeNumber(o,"max_size")},price:{min:this.safeNumber(o,"min_price"),max:this.safeNumber(o,"max_price")},cost:{min:void 0,max:void 0}},info:o})}return n}async fetchCurrencies(e={}){const t=await this.publicGetConstants(e),s=this.safeValue(t,"coins",{}),i=Object.keys(s),n={};for(let r=0;r<i.length;r++){const a=i[r],o=s[a],d=this.safeString(o,"symbol"),c=this.safeInteger(o,"id"),u=this.safeCurrencyCode(d),h=this.safeString(o,"fullname"),l=this.safeValue(o,"allow_deposit"),p=this.safeValue(o,"allow_withdrawal"),g=this.safeValue(o,"active")&&l&&p,y=this.safeNumber(o,"withdrawal_fee"),b=this.safeValue(o,"withdrawal_limits",[]);n[u]={id:d,numericId:c,code:u,info:o,name:h,active:g,deposit:l,withdraw:p,fee:y,precision:this.safeNumber(o,"increment_unit"),limits:{amount:{min:this.safeNumber(o,"min"),max:this.safeNumber(o,"max")},withdraw:{min:void 0,max:this.safeValue(b,0)}}}}return n}async fetchOrderBooks(e=void 0,t=void 0,s={}){await this.loadMarkets();const i=await this.publicGetOrderbooks(s),n={},r=Object.keys(i);for(let a=0;a<r.length;a++){const o=r[a],d=i[o],c=this.safeSymbol(o,void 0,"-"),u=this.parse8601(this.safeString(d,"timestamp"));n[c]=this.parseOrderBook(i[o],c,u)}return n}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id},r=await this.publicGetOrderbooks(this.extend(n,s)),a=this.safeValue(r,i.id),o=this.parse8601(this.safeString(a,"timestamp"));return this.parseOrderBook(a,i.symbol,o)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetTicker(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTickers(this.extend(t));return this.parseTickers(s,e)}parseTickers(e,t=void 0,s={}){const i={},n=Object.keys(e);for(let r=0;r<n.length;r++){const a=n[r],o=e[a],d=this.safeString(o,"symbol",a),c=this.safeMarket(d,void 0,"-"),u=c.symbol;i[u]=this.extend(this.parseTicker(o,c),s)}return this.filterByArray(i,"symbol",t)}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,"-");const i=t.symbol,n=this.parse8601(this.safeString2(e,"time","timestamp")),r=this.safeString(e,"close");return this.safeTicker({symbol:i,info:e,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:r,last:this.safeString(e,"last",r),previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.publicGetTrades(this.extend(r,i)),o=this.safeValue(a,n.id,[]);return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,"-");const i=t.symbol,n=this.safeString(e,"timestamp"),r=this.parse8601(n),a=this.safeString(e,"side"),o=this.safeString(e,"order_id"),d=this.safeString(e,"price"),c=this.safeString(e,"size"),u=this.safeString(e,"fee");let h;return u!==void 0&&(h={cost:u,currency:t.quote}),this.safeTrade({info:e,id:void 0,timestamp:r,datetime:n,symbol:i,order:o,type:void 0,side:a,takerOrMaker:void 0,price:d,amount:c,cost:void 0,fee:h},t)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetTiers(e),s=this.safeValue(t,"1",{}),i=this.safeValue(s,"fees",{}),n=this.safeValue(i,"maker",{}),r=this.safeValue(i,"taker",{}),a={};for(let o=0;o<this.symbols.length;o++){const d=this.symbols[o],c=this.market(d),u=this.safeString(n,c.id),h=this.safeString(r,c.id);a[d]={info:i,symbol:d,maker:this.parseNumber(mv.stringDiv(u,"100")),taker:this.parseNumber(mv.stringDiv(h,"100")),percentage:!0,tierBased:!0}}return a}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,resolution:this.timeframes[t]},o=this.parseTimeframe(t);if(s===void 0){i===void 0&&(i=1e3);const c=this.seconds(),u=c-o*i;a.to=c,a.from=u}else if(i===void 0)a.from=parseInt(s/1e3),a.to=this.seconds();else{const c=parseInt(s/1e3);a.from=c,a.to=this.sum(c,o*i)}const d=await this.publicGetChart(this.extend(a,n));return this.parseOHLCVs(d,r,t,s,i)}parseOHLCV(e,t=void 0,s="1h",i=void 0,n=void 0){return[this.parse8601(this.safeString(e,"time")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}parseBalance(e){const t=this.parse8601(this.safeString(e,"updated_at")),s={info:e,timestamp:t,datetime:this.iso8601(t)},i=Object.keys(this.currencies_by_id);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(e,r+"_available"),o.total=this.safeString(e,r+"_balance"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetUserBalance(e);return this.parseBalance(t)}async fetchOpenOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privateGetOrder(this.extend(i,s));return this.parseOrder(n)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={open:!0};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={open:!1};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},r=await this.privateGetOrder(this.extend(i,s));if(r===void 0)throw new pv(this.id+" fetchOrder() could not find order id "+e);return this.parseOrder(r)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),t!==void 0&&(r.start_date=this.iso8601(t)),s!==void 0&&(r.limit=s);const a=await this.privateGetOrders(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseOrders(o,n,t,s)}parseOrderStatus(e){const t={new:"open",pfilled:"open",filled:"closed",canceled:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t,"-"),n=this.safeString(e,"id"),r=this.parse8601(this.safeString(e,"created_at")),a=this.safeString(e,"type"),o=this.safeString(e,"side"),d=this.safeString(e,"price"),c=this.safeString(e,"stop"),u=this.safeString(e,"size"),h=this.safeString(e,"filled"),l=this.parseOrderStatus(this.safeString(e,"status")),p=this.safeValue(e,"meta",{}),m=this.safeValue(p,"post_only",!1);return this.safeOrder({id:n,clientOrderId:void 0,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,status:l,symbol:i,type:a,timeInForce:void 0,postOnly:m,side:o,price:d,stopPrice:c,amount:u,filled:h,remaining:void 0,cost:void 0,trades:void 0,fee:void 0,info:e,average:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=parseFloat(this.amountToPrecision(e,i)),d={symbol:a.id,side:s,size:this.normalizeNumberIfNeeded(o),type:t},c=this.safeNumberN(r,["triggerPrice","stopPrice","stop"]),u=this.safeValue(r,"meta",{}),h=this.safeValue(u,"post_only",!1),l=t==="market",p=this.isPostOnly(l,h,r);if(!l){const g=parseFloat(this.priceToPrecision(e,n));d.price=this.normalizeNumberIfNeeded(g)}c!==void 0&&(d.stop=this.normalizeNumberIfNeeded(parseFloat(this.priceToPrecision(e,c)))),p&&(d.meta={post_only:!0}),r=this.omit(r,["postOnly","timeInForce","stopPrice","triggerPrice","stop"]);const m=await this.privatePostOrder(this.extend(d,r));return this.parseOrder(m,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privateDeleteOrder(this.extend(i,s));return this.parseOrder(n)}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new lv(this.id+" cancelAllOrders() requires a 'symbol' argument");await this.loadMarkets();const s={};let i;i=this.market(e),s.symbol=i.id;const n=await this.privateDeleteOrderAll(this.extend(s,t));return this.parseOrders(n,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),s!==void 0&&(n.limit=s),t!==void 0&&(n.start_date=this.iso8601(t));const a=await this.privateGetUserTrades(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,r,t,s)}parseDepositAddress(e,t=void 0){let s=this.safeString(e,"address"),i;if(s!==void 0){const a=s.split(":");s=this.safeString(a,0),i=this.safeString(a,1)}this.checkAddress(s);const n=this.safeString(e,"currency");t=this.safeCurrency(n,t);const r=this.safeString(e,"network");return{currency:t.code,address:s,tag:i,network:r,info:e}}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s=this.safeString(t,"network");t=this.omit(t,"network");const i=await this.privateGetUser(t),n=this.safeValue(i,"wallet",[]),r=s===void 0?n:this.filterBy(n,"network",s);return this.parseDepositAddresses(r,e)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.limit=s),t!==void 0&&(n.start_date=this.iso8601(t));const a=await this.privateGetUserDeposits(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,r,t,s)}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const i={transaction_id:e};let n;t!==void 0&&(n=this.currency(t),i.currency=n.id);const r=await this.privateGetUserWithdrawals(this.extend(i,s)),a=this.safeValue(r,"data",[]),o=this.safeValue(a,0,{});return this.parseTransaction(o,n)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.limit=s),t!==void 0&&(n.start_date=this.iso8601(t));const a=await this.privateGetUserWithdrawals(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,r,t,s)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"transaction_id"),n=this.parse8601(this.safeString(e,"created_at")),r=this.parse8601(this.safeString(e,"updated_at")),a=this.safeString(e,"type"),o=this.safeNumber(e,"amount");let d=this.safeString(e,"address"),c;const u=void 0;let h,l;const p=void 0;if(d!==void 0){const x=d.split(":");d=this.safeString(x,0),h=this.safeString(x,1),c=d,l=h}const m=this.safeString(e,"currency");t=this.safeCurrency(m,t);let g=this.safeValue(e,"status");const y=this.safeValue(e,"dismissed"),b=this.safeValue(e,"rejected");g?g="ok":y?g="canceled":b?g="failed":g="pending";const w=this.safeString(e,"fee_coin"),k=this.safeCurrencyCode(w,t),T=this.safeNumber(e,"fee");let O;return T!==void 0&&(O={currency:k,cost:T}),{info:e,id:s,txid:i,timestamp:n,datetime:this.iso8601(n),network:void 0,addressFrom:u,address:d,addressTo:c,tagFrom:p,tag:h,tagTo:l,type:a,amount:o,currency:t.code,status:g,updated:r,fee:O}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e);i!==void 0&&(s+=":"+i);const a=this.safeString(n,"network");if(a===void 0)throw new lv(this.id+" withdraw() requires a network parameter");n=this.omit(n,"network");const o=this.safeValue(this.options,"networks",{}),d=this.safeStringLower2(o,a,e,a),c={currency:r.id,amount:t,address:s,network:d},u=await this.privatePostUserWithdrawal(this.extend(c,n));return this.parseTransaction(u,r)}normalizeNumberIfNeeded(e){return e%1===0&&(e=parseInt(e)),e}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.omit(i,this.extractParams(e));e="/"+this.version+"/"+this.implodeParams(e,i),(s==="GET"||s==="DELETE")&&Object.keys(a).length&&(e+="?"+this.urlencode(a));const o=this.urls.api.rest+e;if(t==="private"){this.checkRequiredCredentials();const d=this.safeInteger2(this.options,"api-expires","expires",parseInt(this.timeout/1e3)),u=this.sum(this.seconds(),d).toString();let h=s+e+u;n={"api-key":this.apiKey,"api-expires":u},s==="POST"&&(n["Content-type"]="application/json",Object.keys(a).length&&(r=this.json(a),h+=r));const l=this.hmac(this.encode(h),this.encode(this.secret));n["api-signature"]=l}return{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&e>=400&&e<=503){const c=this.id+" "+r,u=this.safeString(a,"message");this.throwBroadlyMatchedException(this.exceptions.broad,u,c);const h=e.toString();this.throwExactlyMatchedException(this.exceptions.exact,h,c)}}};const dD=ge,{AccountNotEnabled:gv,ArgumentsRequired:Us,AuthenticationError:V0,ExchangeError:yv,PermissionDenied:cD,ExchangeNotAvailable:bv,OnMaintenance:q0,InvalidOrder:Os,OrderNotFound:jf,InsufficientFunds:Wf,BadSymbol:ta,BadRequest:xi,RateLimitExceeded:uD,RequestTimeout:fD,NetworkError:hD,InvalidAddress:zf,NotSupported:_i}=de,{TICK_SIZE:lD,TRUNCATE:pD}=me,di=Se;var Ab=class extends dD{describe(){return this.deepExtend(super.describe(),{id:"huobi",name:"Huobi",countries:["CN"],rateLimit:100,userAgent:this.userAgents.chrome100,certified:!0,version:"v1",accounts:void 0,accountsById:void 0,hostname:"api.huobi.pro",pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!0,option:void 0,addMargin:void 0,borrowMargin:!0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createDepositAddress:void 0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowInterest:!0,fetchBorrowRate:void 0,fetchBorrowRateHistories:void 0,fetchBorrowRateHistory:void 0,fetchBorrowRates:!0,fetchBorrowRatesPerSymbol:!0,fetchCanceledOrders:void 0,fetchClosedOrder:void 0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:void 0,fetchDepositAddress:!0,fetchDepositAddresses:void 0,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!0,fetchL3OrderBook:void 0,fetchLedger:!0,fetchLedgerEntry:void 0,fetchLeverage:!1,fetchLeverageTiers:!0,fetchMarketLeverageTiers:!0,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenInterestHistory:!0,fetchOpenOrder:void 0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:void 0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!0,fetchSettlementHistory:!0,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTradingLimits:!0,fetchTransactionFee:void 0,fetchTransactionFees:void 0,fetchTransactions:void 0,fetchTransfers:void 0,fetchWithdrawAddressesByNetwork:!0,fetchWithdrawal:void 0,fetchWithdrawals:!0,fetchWithdrawalWhitelist:void 0,reduceMargin:void 0,repayMargin:!0,setLeverage:!0,setMarginMode:!1,setPositionMode:!1,signIn:void 0,transfer:!0,withdraw:!0},timeframes:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"60min","4h":"4hour","1d":"1day","1w":"1week","1M":"1mon","1y":"1year"},urls:{logo:"https://user-images.githubusercontent.com/1294454/76137448-22748a80-604e-11ea-8069-6e389271911d.jpg",hostnames:{contract:"api.hbdm.com",spot:"api.huobi.pro",status:{spot:"status.huobigroup.com",future:{inverse:"status-dm.huobigroup.com",linear:"status-linear-swap.huobigroup.com"},swap:{inverse:"status-swap.huobigroup.com",linear:"status-linear-swap.huobigroup.com"}}},api:{status:"https://{hostname}",contract:"https://{hostname}",spot:"https://{hostname}",public:"https://{hostname}",private:"https://{hostname}",v2Public:"https://{hostname}",v2Private:"https://{hostname}"},www:"https://www.huobi.com",referral:{url:"https://www.huobi.com/en-us/v/register/double-invite/?inviter_id=11343840&invite_code=6rmm2223",discount:.15},doc:["https://huobiapi.github.io/docs/spot/v1/cn/","https://huobiapi.github.io/docs/dm/v1/cn/","https://huobiapi.github.io/docs/coin_margined_swap/v1/cn/","https://huobiapi.github.io/docs/usdt_swap/v1/cn/","https://huobiapi.github.io/docs/option/v1/cn/"],fees:"https://www.huobi.com/about/fee/"},api:{v2Public:{get:{"reference/currencies":1,"market-status":1}},v2Private:{get:{"account/ledger":1,"account/withdraw/quota":1,"account/withdraw/address":1,"account/deposit/address":1,"account/repayment":5,"reference/transact-fee-rate":1,"account/asset-valuation":.2,"point/account":5,"sub-user/user-list":1,"sub-user/user-state":1,"sub-user/account-list":1,"sub-user/deposit-address":1,"sub-user/query-deposit":1,"user/api-key":1,"user/uid":1,"algo-orders/opening":1,"algo-orders/history":1,"algo-orders/specific":1,"c2c/offers":1,"c2c/offer":1,"c2c/transactions":1,"c2c/repayment":1,"c2c/account":1,"etp/reference":1,"etp/transactions":5,"etp/transaction":5,"etp/rebalance":1,"etp/limit":1},post:{"account/transfer":1,"account/repayment":5,"point/transfer":5,"sub-user/management":1,"sub-user/creation":1,"sub-user/tradable-market":1,"sub-user/transferability":1,"sub-user/api-key-generation":1,"sub-user/api-key-modification":1,"sub-user/api-key-deletion":1,"sub-user/deduct-mode":1,"algo-orders":1,"algo-orders/cancel-all-after":1,"algo-orders/cancellation":1,"c2c/offer":1,"c2c/cancellation":1,"c2c/cancel-all":1,"c2c/repayment":1,"c2c/transfer":1,"etp/creation":5,"etp/redemption":5,"etp/{transactId}/cancel":10,"etp/batch-cancel":50}},public:{get:{"common/symbols":1,"common/currencys":1,"common/timestamp":1,"common/exchange":1,"settings/currencys":1}},private:{get:{"account/accounts":.2,"account/accounts/{id}/balance":.2,"account/accounts/{sub-uid}":1,"account/history":4,"cross-margin/loan-info":1,"margin/loan-info":1,"fee/fee-rate/get":1,"order/openOrders":.4,"order/orders":.4,"order/orders/{id}":.4,"order/orders/{id}/matchresults":.4,"order/orders/getClientOrder":.4,"order/history":1,"order/matchresults":1,"query/deposit-withdraw":1,"margin/loan-orders":.2,"margin/accounts/balance":.2,"cross-margin/loan-orders":1,"cross-margin/accounts/balance":1,"points/actions":1,"points/orders":1,"subuser/aggregate-balance":10,"stable-coin/exchange_rate":1,"stable-coin/quote":1},post:{"account/transfer":1,"futures/transfer":1,"order/batch-orders":.4,"order/orders/place":.2,"order/orders/submitCancelClientOrder":.2,"order/orders/batchCancelOpenOrders":.4,"order/orders/{id}/submitcancel":.2,"order/orders/batchcancel":.4,"dw/withdraw/api/create":1,"dw/withdraw-virtual/{id}/cancel":1,"dw/transfer-in/margin":10,"dw/transfer-out/margin":10,"margin/orders":10,"margin/orders/{id}/repay":10,"cross-margin/transfer-in":1,"cross-margin/transfer-out":1,"cross-margin/orders":1,"cross-margin/orders/{id}/repay":1,"stable-coin/exchange":1,"subuser/transfer":10}},status:{public:{spot:{get:{"api/v2/summary.json":1}},future:{inverse:{get:{"api/v2/summary.json":1}},linear:{get:{"api/v2/summary.json":1}}},swap:{inverse:{get:{"api/v2/summary.json":1}},linear:{get:{"api/v2/summary.json":1}}}}},spot:{public:{get:{"v2/market-status":1,"v1/common/symbols":1,"v1/common/currencys":1,"v2/settings/common/currencies":1,"v2/reference/currencies":1,"v1/common/timestamp":1,"v1/common/exchange":1,"v1/settings/common/chains":1,"v1/settings/common/currencys":1,"v1/settings/common/symbols":1,"v2/settings/common/symbols":1,"v1/settings/common/market-symbols":1,"market/history/candles":1,"market/history/kline":1,"market/detail/merged":1,"market/tickers":1,"market/detail":1,"market/depth":1,"market/trade":1,"market/history/trade":1,"market/detail/":1,"market/etp":1,"v2/etp/reference":1,"v2/etp/rebalance":1}},private:{get:{"v1/account/accounts":.2,"v1/account/accounts/{account-id}/balance":.2,"v2/account/valuation":1,"v2/account/asset-valuation":.2,"v1/account/history":4,"v2/account/ledger":1,"v2/point/account":5,"v2/account/deposit/address":1,"v2/account/withdraw/quota":1,"v2/account/withdraw/address":1,"v2/reference/currencies":1,"v1/query/deposit-withdraw":1,"v1/query/withdraw/client-order-id":1,"v2/user/api-key":1,"v2/user/uid":1,"v2/sub-user/user-list":1,"v2/sub-user/user-state":1,"v2/sub-user/account-list":1,"v2/sub-user/deposit-address":1,"v2/sub-user/query-deposit":1,"v1/subuser/aggregate-balance":10,"v1/account/accounts/{sub-uid}":1,"v1/order/openOrders":.4,"v1/order/orders/{order-id}":.4,"v1/order/orders/getClientOrder":.4,"v1/order/orders/{order-id}/matchresult":.4,"v1/order/orders/{order-id}/matchresults":.4,"v1/order/orders":.4,"v1/order/history":1,"v1/order/matchresults":1,"v2/reference/transact-fee-rate":1,"v2/algo-orders/opening":1,"v2/algo-orders/history":1,"v2/algo-orders/specific":1,"v1/margin/loan-info":1,"v1/margin/loan-orders":.2,"v1/margin/accounts/balance":.2,"v1/cross-margin/loan-info":1,"v1/cross-margin/loan-orders":1,"v1/cross-margin/accounts/balance":1,"v2/account/repayment":5,"v1/stable-coin/quote":1,"v1/stable_coin/exchange_rate":1,"v2/etp/transactions":5,"v2/etp/transaction":5,"v2/etp/limit":1},post:{"v1/account/transfer":1,"v1/futures/transfer":1,"v2/point/transfer":5,"v2/account/transfer":1,"v1/dw/withdraw/api/create":1,"v1/dw/withdraw-virtual/{withdraw-id}/cancel":1,"v2/sub-user/deduct-mode":1,"v2/sub-user/creation":1,"v2/sub-user/management":1,"v2/sub-user/tradable-market":1,"v2/sub-user/transferability":1,"v2/sub-user/api-key-generation":1,"v2/sub-user/api-key-modification":1,"v2/sub-user/api-key-deletion":1,"v1/subuser/transfer":10,"v1/order/orders/place":.2,"v1/order/batch-orders":.4,"v1/order/orders/{order-id}/submitcancel":.2,"v1/order/orders/submitCancelClientOrder":.2,"v1/order/orders/batchCancelOpenOrders":.4,"v1/order/orders/batchcancel":.4,"v2/algo-orders/cancel-all-after":1,"v2/algo-orders":1,"v2/algo-orders/cancellation":1,"v2/account/repayment":5,"v1/dw/transfer-in/margin":10,"v1/dw/transfer-out/margin":10,"v1/margin/orders":10,"v1/margin/orders/{order-id}/repay":10,"v1/cross-margin/transfer-in":1,"v1/cross-margin/transfer-out":1,"v1/cross-margin/orders":1,"v1/cross-margin/orders/{order-id}/repay":1,"v1/stable-coin/exchange":1,"v2/etp/creation":5,"v2/etp/redemption":5,"v2/etp/{transactId}/cancel":10,"v2/etp/batch-cancel":50}}},contract:{public:{get:{"api/v1/timestamp":1,"heartbeat/":1,"api/v1/contract_contract_info":1,"api/v1/contract_index":1,"api/v1/contract_price_limit":1,"api/v1/contract_open_interest":1,"api/v1/contract_delivery_price":1,"market/depth":1,"market/bbo":1,"market/history/kline":1,"index/market/history/mark_price_kline":1,"market/detail/merged":1,"market/detail/batch_merged":1,"v2/market/detail/batch_merged":1,"market/trade":1,"market/history/trade":1,"api/v1/contract_risk_info":1,"api/v1/contract_insurance_fund":1,"api/v1/contract_adjustfactor":1,"api/v1/contract_his_open_interest":1,"api/v1/contract_ladder_margin":1,"api/v1/contract_api_state":1,"api/v1/contract_elite_account_ratio":1,"api/v1/contract_elite_position_ratio":1,"api/v1/contract_liquidation_orders":1,"api/v1/contract_settlement_records":1,"index/market/history/index":1,"index/market/history/basis":1,"api/v1/contract_estimated_settlement_price":1,"api/v3/contract_liquidation_orders":1,"swap-api/v1/swap_contract_info":1,"swap-api/v1/swap_index":1,"swap-api/v1/swap_price_limit":1,"swap-api/v1/swap_open_interest":1,"swap-ex/market/depth":1,"swap-ex/market/bbo":1,"swap-ex/market/history/kline":1,"index/market/history/swap_mark_price_kline":1,"swap-ex/market/detail/merged":1,"v2/swap-ex/market/detail/batch_merged":1,"index/market/history/swap_premium_index_kline":1,"swap-ex/market/detail/batch_merged":1,"swap-ex/market/trade":1,"swap-ex/market/history/trade":1,"swap-api/v1/swap_risk_info":1,"swap-api/v1/swap_insurance_fund":1,"swap-api/v1/swap_adjustfactor":1,"swap-api/v1/swap_his_open_interest":1,"swap-api/v1/swap_ladder_margin":1,"swap-api/v1/swap_api_state":1,"swap-api/v1/swap_elite_account_ratio":1,"swap-api/v1/swap_elite_position_ratio":1,"swap-api/v1/swap_estimated_settlement_price":1,"swap-api/v1/swap_liquidation_orders":1,"swap-api/v1/swap_settlement_records":1,"swap-api/v1/swap_funding_rate":1,"swap-api/v1/swap_batch_funding_rate":1,"swap-api/v1/swap_historical_funding_rate":1,"swap-api/v3/swap_liquidation_orders":1,"index/market/history/swap_estimated_rate_kline":1,"index/market/history/swap_basis":1,"linear-swap-api/v1/swap_contract_info":1,"linear-swap-api/v1/swap_index":1,"linear-swap-api/v1/swap_price_limit":1,"linear-swap-api/v1/swap_open_interest":1,"linear-swap-ex/market/depth":1,"linear-swap-ex/market/bbo":1,"linear-swap-ex/market/history/kline":1,"index/market/history/linear_swap_mark_price_kline":1,"linear-swap-ex/market/detail/merged":1,"linear-swap-ex/market/detail/batch_merged":1,"v2/linear-swap-ex/market/detail/batch_merged":1,"linear-swap-ex/market/trade":1,"linear-swap-ex/market/history/trade":1,"linear-swap-api/v1/swap_risk_info":1,"swap-api/v1/linear-swap-api/v1/swap_insurance_fund":1,"linear-swap-api/v1/swap_adjustfactor":1,"linear-swap-api/v1/swap_cross_adjustfactor":1,"linear-swap-api/v1/swap_his_open_interest":1,"linear-swap-api/v1/swap_ladder_margin":1,"linear-swap-api/v1/swap_cross_ladder_margin":1,"linear-swap-api/v1/swap_api_state":1,"linear-swap-api/v1/swap_cross_transfer_state":1,"linear-swap-api/v1/swap_cross_trade_state":1,"linear-swap-api/v1/swap_elite_account_ratio":1,"linear-swap-api/v1/swap_elite_position_ratio":1,"linear-swap-api/v1/swap_liquidation_orders":1,"linear-swap-api/v1/swap_settlement_records":1,"linear-swap-api/v1/swap_funding_rate":1,"linear-swap-api/v1/swap_batch_funding_rate":1,"linear-swap-api/v1/swap_historical_funding_rate":1,"linear-swap-api/v3/swap_liquidation_orders":1,"index/market/history/linear_swap_premium_index_kline":1,"index/market/history/linear_swap_estimated_rate_kline":1,"index/market/history/linear_swap_basis":1,"linear-swap-api/v1/swap_estimated_settlement_price":1}},private:{get:{"api/v1/contract_api_trading_status":1,"swap-api/v1/swap_api_trading_status":1,"linear-swap-api/v1/swap_api_trading_status":1},post:{"api/v1/contract_balance_valuation":1,"api/v1/contract_account_info":1,"api/v1/contract_position_info":1,"api/v1/contract_sub_auth":1,"api/v1/contract_sub_account_list":1,"api/v1/contract_sub_account_info_list":1,"api/v1/contract_sub_account_info":1,"api/v1/contract_sub_position_info":1,"api/v1/contract_financial_record":1,"api/v1/contract_financial_record_exact":1,"api/v1/contract_user_settlement_records":1,"api/v1/contract_order_limit":1,"api/v1/contract_fee":1,"api/v1/contract_transfer_limit":1,"api/v1/contract_position_limit":1,"api/v1/contract_account_position_info":1,"api/v1/contract_master_sub_transfer":1,"api/v1/contract_master_sub_transfer_record":1,"api/v1/contract_available_level_rate":1,"api/v3/contract_financial_record":1,"api/v3/contract_financial_record_exact":1,"api/v1/contract_order":1,"v1/contract_batchorder":1,"api/v1/contract_cancel":1,"api/v1/contract_cancelall":1,"api/v1/contract_switch_lever_rate":1,"api/v1/lightning_close_position":1,"api/v1/contract_order_info":1,"api/v1/contract_order_detail":1,"api/v1/contract_openorders":1,"api/v1/contract_hisorders":1,"api/v1/contract_hisorders_exact":1,"api/v1/contract_matchresults":1,"api/v1/contract_matchresults_exact":1,"api/v3/contract_hisorders":1,"api/v3/contract_hisorders_exact":1,"api/v3/contract_matchresults":1,"api/v3/contract_matchresults_exact":1,"api/v1/contract_trigger_order":1,"api/v1/contract_trigger_cancel":1,"api/v1/contract_trigger_cancelall":1,"api/v1/contract_trigger_openorders":1,"api/v1/contract_trigger_hisorders":1,"api/v1/contract_tpsl_order":1,"api/v1/contract_tpsl_cancel":1,"api/v1/contract_tpsl_cancelall":1,"api/v1/contract_tpsl_openorders":1,"api/v1/contract_tpsl_hisorders":1,"api/v1/contract_relation_tpsl_order":1,"api/v1/contract_track_order":1,"api/v1/contract_track_cancel":1,"api/v1/contract_track_cancelall":1,"api/v1/contract_track_openorders":1,"api/v1/contract_track_hisorders":1,"swap-api/v1/swap_balance_valuation":1,"swap-api/v1/swap_account_info":1,"swap-api/v1/swap_position_info":1,"swap-api/v1/swap_account_position_info":1,"swap-api/v1/swap_sub_auth":1,"swap-api/v1/swap_sub_account_list":1,"swap-api/v1/swap_sub_account_info_list":1,"swap-api/v1/swap_sub_account_info":1,"swap-api/v1/swap_sub_position_info":1,"swap-api/v1/swap_financial_record":1,"swap-api/v1/swap_financial_record_exact":1,"swap-api/v1/swap_user_settlement_records":1,"swap-api/v1/swap_available_level_rate":1,"swap-api/v1/swap_order_limit":1,"swap-api/v1/swap_fee":1,"swap-api/v1/swap_transfer_limit":1,"swap-api/v1/swap_position_limit":1,"swap-api/v1/swap_master_sub_transfer":1,"swap-api/v1/swap_master_sub_transfer_record":1,"swap-api/v3/swap_financial_record":1,"swap-api/v3/swap_financial_record_exact":1,"swap-api/v1/swap_order":1,"swap-api/v1/swap_batchorder":1,"swap-api/v1/swap_cancel":1,"swap-api/v1/swap_cancelall":1,"swap-api/v1/swap_lightning_close_position":1,"swap-api/v1/swap_switch_lever_rate":1,"swap-api/v1/swap_order_info":1,"swap-api/v1/swap_order_detail":1,"swap-api/v1/swap_openorders":1,"swap-api/v1/swap_hisorders":1,"swap-api/v1/swap_hisorders_exact":1,"swap-api/v1/swap_matchresults":1,"swap-api/v1/swap_matchresults_exact":1,"swap-api/v3/swap_matchresults":1,"swap-api/v3/swap_matchresults_exact":1,"swap-api/v3/swap_hisorders":1,"swap-api/v3/swap_hisorders_exact":1,"swap-api/v1/swap_trigger_order":1,"swap-api/v1/swap_trigger_cancel":1,"swap-api/v1/swap_trigger_cancelall":1,"swap-api/v1/swap_trigger_openorders":1,"swap-api/v1/swap_trigger_hisorders":1,"swap-api/v1/swap_tpsl_order":1,"swap-api/v1/swap_tpsl_cancel":1,"swap-api/v1/swap_tpsl_cancelall":1,"swap-api/v1/swap_tpsl_openorders":1,"swap-api/v1/swap_tpsl_hisorders":1,"swap-api/v1/swap_relation_tpsl_order":1,"swap-api/v1/swap_track_order":1,"swap-api/v1/swap_track_cancel":1,"swap-api/v1/swap_track_cancelall":1,"swap-api/v1/swap_track_openorders":1,"swap-api/v1/swap_track_hisorders":1,"linear-swap-api/v1/swap_lever_position_limit":1,"linear-swap-api/v1/swap_cross_lever_position_limit":1,"linear-swap-api/v1/swap_balance_valuation":1,"linear-swap-api/v1/swap_account_info":1,"linear-swap-api/v1/swap_cross_account_info":1,"linear-swap-api/v1/swap_position_info":1,"linear-swap-api/v1/swap_cross_position_info":1,"linear-swap-api/v1/swap_account_position_info":1,"linear-swap-api/v1/swap_cross_account_position_info":1,"linear-swap-api/v1/swap_sub_auth":1,"linear-swap-api/v1/swap_sub_account_list":1,"linear-swap-api/v1/swap_cross_sub_account_list":1,"linear-swap-api/v1/swap_sub_account_info_list":1,"linear-swap-api/v1/swap_cross_sub_account_info_list":1,"linear-swap-api/v1/swap_sub_account_info":1,"linear-swap-api/v1/swap_cross_sub_account_info":1,"linear-swap-api/v1/swap_sub_position_info":1,"linear-swap-api/v1/swap_cross_sub_position_info":1,"linear-swap-api/v1/swap_financial_record":1,"linear-swap-api/v1/swap_financial_record_exact":1,"linear-swap-api/v1/swap_user_settlement_records":1,"linear-swap-api/v1/swap_cross_user_settlement_records":1,"linear-swap-api/v1/swap_available_level_rate":1,"linear-swap-api/v1/swap_cross_available_level_rate":1,"linear-swap-api/v1/swap_order_limit":1,"linear-swap-api/v1/swap_fee":1,"linear-swap-api/v1/swap_transfer_limit":1,"linear-swap-api/v1/swap_cross_transfer_limit":1,"linear-swap-api/v1/swap_position_limit":1,"linear-swap-api/v1/swap_cross_position_limit":1,"linear-swap-api/v1/swap_master_sub_transfer":1,"linear-swap-api/v1/swap_master_sub_transfer_record":1,"linear-swap-api/v1/swap_transfer_inner":1,"linear-swap-api/v3/swap_financial_record":1,"linear-swap-api/v3/swap_financial_record_exact":1,"linear-swap-api/v1/swap_order":1,"linear-swap-api/v1/swap_cross_order":1,"linear-swap-api/v1/swap_batchorder":1,"linear-swap-api/v1/swap_cross_batchorder":1,"linear-swap-api/v1/swap_cancel":1,"linear-swap-api/v1/swap_cross_cancel":1,"linear-swap-api/v1/swap_cancelall":1,"linear-swap-api/v1/swap_cross_cancelall":1,"linear-swap-api/v1/swap_switch_lever_rate":1,"linear-swap-api/v1/swap_cross_switch_lever_rate":1,"linear-swap-api/v1/swap_lightning_close_position":1,"linear-swap-api/v1/swap_cross_lightning_close_position":1,"linear-swap-api/v1/swap_order_info":1,"linear-swap-api/v1/swap_cross_order_info":1,"linear-swap-api/v1/swap_order_detail":1,"linear-swap-api/v1/swap_cross_order_detail":1,"linear-swap-api/v1/swap_openorders":1,"linear-swap-api/v1/swap_cross_openorders":1,"linear-swap-api/v1/swap_hisorders":1,"linear-swap-api/v1/swap_cross_hisorders":1,"linear-swap-api/v1/swap_hisorders_exact":1,"linear-swap-api/v1/swap_cross_hisorders_exact":1,"linear-swap-api/v1/swap_matchresults":1,"linear-swap-api/v1/swap_cross_matchresults":1,"linear-swap-api/v1/swap_matchresults_exact":1,"linear-swap-api/v1/swap_cross_matchresults_exact":1,"linear-swap-api/v1/swap_switch_position_mode":1,"linear-swap-api/v1/swap_cross_switch_position_mode":1,"linear-swap-api/v3/swap_matchresults":1,"linear-swap-api/v3/swap_cross_matchresults":1,"linear-swap-api/v3/swap_matchresults_exact":1,"linear-swap-api/v3/swap_cross_matchresults_exact":1,"linear-swap-api/v3/swap_hisorders":1,"linear-swap-api/v3/swap_cross_hisorders":1,"linear-swap-api/v3/swap_hisorders_exact":1,"linear-swap-api/v3/swap_cross_hisorders_exact":1,"linear-swap-api/v1/swap_trigger_order":1,"linear-swap-api/v1/swap_cross_trigger_order":1,"linear-swap-api/v1/swap_trigger_cancel":1,"linear-swap-api/v1/swap_cross_trigger_cancel":1,"linear-swap-api/v1/swap_trigger_cancelall":1,"linear-swap-api/v1/swap_cross_trigger_cancelall":1,"linear-swap-api/v1/swap_trigger_openorders":1,"linear-swap-api/v1/swap_cross_trigger_openorders":1,"linear-swap-api/v1/swap_trigger_hisorders":1,"linear-swap-api/v1/swap_cross_trigger_hisorders":1,"linear-swap-api/v1/swap_tpsl_order":1,"linear-swap-api/v1/swap_cross_tpsl_order":1,"linear-swap-api/v1/swap_tpsl_cancel":1,"linear-swap-api/v1/swap_cross_tpsl_cancel":1,"linear-swap-api/v1/swap_tpsl_cancelall":1,"linear-swap-api/v1/swap_cross_tpsl_cancelall":1,"linear-swap-api/v1/swap_tpsl_openorders":1,"linear-swap-api/v1/swap_cross_tpsl_openorders":1,"linear-swap-api/v1/swap_tpsl_hisorders":1,"linear-swap-api/v1/swap_cross_tpsl_hisorders":1,"linear-swap-api/v1/swap_relation_tpsl_order":1,"linear-swap-api/v1/swap_cross_relation_tpsl_order":1,"linear-swap-api/v1/swap_track_order":1,"linear-swap-api/v1/swap_cross_track_order":1,"linear-swap-api/v1/swap_track_cancel":1,"linear-swap-api/v1/swap_cross_track_cancel":1,"linear-swap-api/v1/swap_track_cancelall":1,"linear-swap-api/v1/swap_cross_track_cancelall":1,"linear-swap-api/v1/swap_track_openorders":1,"linear-swap-api/v1/swap_cross_track_openorders":1,"linear-swap-api/v1/swap_track_hisorders":1,"linear-swap-api/v1/swap_cross_track_hisorders":1}}}},fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},exceptions:{broad:{"contract is restricted of closing positions on API.  Please contact customer service":q0,maintain:q0},exact:{403:V0,1010:gv,1013:ta,1017:jf,1034:Os,1036:Os,1039:Os,1041:Os,1047:Wf,1048:Wf,1051:Os,1066:ta,1067:Os,1094:Os,1220:gv,1461:Os,"bad-request":xi,"validation-format-error":xi,"validation-constraints-required":xi,"base-date-limit-error":xi,"api-not-support-temp-addr":cD,timeout:fD,"gateway-internal-error":bv,"account-frozen-balance-insufficient-error":Wf,"invalid-amount":Os,"order-limitorder-amount-min-error":Os,"order-limitorder-amount-max-error":Os,"order-marketorder-amount-min-error":Os,"order-limitorder-price-min-error":Os,"order-limitorder-price-max-error":Os,"order-value-min-error":Os,"order-invalid-price":Os,"order-holding-limit-failed":Os,"order-orderprice-precision-error":Os,"order-etp-nav-price-max-error":Os,"order-orderstate-error":jf,"order-queryorder-invalid":jf,"order-update-error":bv,"api-signature-check-failed":V0,"api-signature-not-valid":V0,"base-record-invalid":jf,"base-symbol-trade-disabled":ta,"base-symbol-error":ta,"system-maintenance":q0,"base-request-exceed-frequency-limit":uD,"invalid symbol":ta,"symbol trade not open now":ta,"require-symbol":ta,"invalid-address":xi,"base-currency-chain-error":xi,"dw-insufficient-balance":Wf}},precisionMode:lD,options:{fetchMarkets:{types:{spot:!0,future:{linear:!0,inverse:!0},swap:{linear:!0,inverse:!0}}},defaultType:"spot",defaultSubType:"linear",defaultNetwork:"ERC20",networks:{ETH:"erc20",TRX:"trc20",HRC20:"hrc20",HECO:"hrc20",HT:"hrc20",ALGO:"algo",OMNI:""},fetchOrdersByStatesMethod:"spot_private_get_v1_order_orders",createMarketBuyOrderRequiresPrice:!0,language:"en-US",broker:{id:"AA03022abc"},accountsByType:{spot:"pro",funding:"pro",future:"futures"},accountsById:{spot:"spot",margin:"margin",otc:"otc",point:"point","super-margin":"super-margin",investment:"investment",borrow:"borrow","grid-trading":"grid-trading","deposit-earning":"deposit-earning","otc-options":"otc-options"},marginAccounts:{cross:"super-margin",isolated:"margin"},typesByAccount:{pro:"spot",futures:"future"},spot:{stopOrderTypes:{"stop-limit":!0,"buy-stop-limit":!0,"sell-stop-limit":!0,"stop-limit-fok":!0,"buy-stop-limit-fok":!0,"sell-stop-limit-fok":!0},limitOrderTypes:{limit:!0,"buy-limit":!0,"sell-limit":!0,ioc:!0,"buy-ioc":!0,"sell-ioc":!0,"limit-maker":!0,"buy-limit-maker":!0,"sell-limit-maker":!0,"stop-limit":!0,"buy-stop-limit":!0,"sell-stop-limit":!0,"limit-fok":!0,"buy-limit-fok":!0,"sell-limit-fok":!0,"stop-limit-fok":!0,"buy-stop-limit-fok":!0,"sell-stop-limit-fok":!0}}},commonCurrencies:{GET:"Themis",GTC:"Game.com",HIT:"HitChain",HOT:"Hydro Protocol",PNT:"Penta",SBTC:"Super Bitcoin",SOUL:"Soulsaver",BIFI:"Bitcoin File"}})}async fetchStatus(e={}){await this.loadMarkets();let t;[t,e]=this.handleMarketTypeAndParams("fetchMyTrades",void 0,e);let s="statusPublicSpotGetApiV2SummaryJson";if(t!=="spot"){const o=this.safeString(e,"subType",this.options.defaultSubType);t==="swap"?o==="linear"?s="statusPublicSwapLinearGetApiV2SummaryJson":o==="inverse"&&(s="statusPublicSwapInverseGetApiV2SummaryJson"):t==="future"?o==="linear"?s="statusPublicFutureLinearGetApiV2SummaryJson":o==="inverse"&&(s="statusPublicFutureInverseGetApiV2SummaryJson"):t==="contract"&&(s="contractPublicGetHeartbeat")}const i=await this[s]();let n,r,a;if(s==="contractPublicGetHeartbeat")n=this.safeString(i,"status")==="ok"?"ok":"maintenance",r=this.safeString(i,"ts");else{const o=this.safeValue(i,"status",{});n=this.safeString(o,"indicator")==="none"?"ok":"maintenance";const c=this.safeValue(i,"page",{}),u=this.safeString(c,"updated_at");r=this.parse8601(u),a=this.safeString(c,"url")}return{status:n,updated:r,eta:void 0,url:a,info:i}}async fetchTime(e={}){const t=this.safeValue(this.options,"fetchTime",{}),s=this.safeString(this.options,"defaultType","spot");let i=this.safeString(t,"type",s);i=this.safeString(e,"type",i);let n="spotPublicGetV1CommonTimestamp";(i==="future"||i==="swap")&&(n="contractPublicGetApiV1Timestamp");const r=await this[n](e);return this.safeInteger2(r,"data","ts")}parseTradingFee(e,t=void 0){const s=this.safeString(e,"symbol");return{info:e,symbol:this.safeSymbol(s,t),maker:this.safeNumber(e,"actualMakerRate"),taker:this.safeNumber(e,"actualTakerRate")}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbols:s.id},n=await this.spotPrivateGetV2ReferenceTransactFeeRate(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0,{});return this.parseTradingFee(a,s)}async fetchTradingLimits(e=void 0,t={}){await this.loadMarkets(),e===void 0&&(e=this.symbols);const s={};for(let i=0;i<e.length;i++){const n=e[i];s[n]=await this.fetchTradingLimitsById(this.marketId(n),t)}return s}async fetchTradingLimitsById(e,t={}){const s={symbol:e},i=await this.spotPublicGetV1CommonExchange(this.extend(s,t));return this.parseTradingLimits(this.safeValue(i,"data",{}))}parseTradingLimits(e,t=void 0,s={}){return{info:e,limits:{amount:{min:this.safeNumber(e,"limit-order-must-greater-than"),max:this.safeNumber(e,"limit-order-must-less-than")}}}}costToPrecision(e,t){return this.decimalToPrecision(t,pD,this.markets[e].precision.cost,this.precisionMode)}async fetchMarkets(e={}){const t=this.safeValue(this.options,"fetchMarkets",{}),s=this.safeValue(t,"types",{});let i=[],n=[];const r=Object.keys(s);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeValue(s,o);if(d===!0)n.push(this.fetchMarketsByTypeAndSubType(o,void 0,e));else{const c=Object.keys(d);for(let u=0;u<c.length;u++){const h=c[u];this.safeValue(d,h)&&n.push(this.fetchMarketsByTypeAndSubType(o,h,e))}}}n=await Promise.all(n);for(let a=0;a<n.length;a++)i=this.arrayConcat(i,n[a]);return i}async fetchMarketsByTypeAndSubType(e,t,s={}){let i="spotPublicGetV1CommonSymbols";const n=this.omit(s,["type","subType"]),r=e==="spot",a=e!=="spot",o=e==="future",d=e==="swap";let c,u;const h={};a&&(c=t==="linear",u=t==="inverse",c?(i="contractPublicGetLinearSwapApiV1SwapContractInfo",o&&(h.business_type="futures")):u&&(o?i="contractPublicGetApiV1ContractContractInfo":d&&(i="contractPublicGetSwapApiV1SwapContractInfo")));const l=await this[i](this.extend(h,n)),p=this.safeValue(l,"data",[]);if(p.length<1)throw new hD(this.id+" fetchMarkets() returned an empty response: "+this.json(p));const g=[];for(let y=0;y<p.length;y++){const b=p[y];let w,k,T,O,x,C;if(a){if(O=this.safeString(b,"contract_code"),x=O.toLowerCase(),d){const Oe=O.split("-");w=this.safeString(b,"symbol"),C=w.toLowerCase(),k=this.safeStringLower(Oe,1),T=u?w:k}else if(o)if(w=this.safeString(b,"symbol"),C=w.toLowerCase(),u)k="USD",T=w;else{const Ce=this.safeString(b,"pair").split("-");k=this.safeString(Ce,1),T=k}}else w=this.safeString(b,"base-currency"),C=w.toLowerCase(),k=this.safeString(b,"quote-currency"),O=w+k,x=O.toLowerCase();const E=this.safeCurrencyCode(w),P=this.safeCurrencyCode(k),_=this.safeCurrencyCode(T);let S=E+"/"+P,I;a&&(u?S+=":"+E:c&&(S+=":"+P),o&&(I=this.safeInteger(b,"delivery_time"),S+="-"+this.yymmdd(I)));const v=this.safeNumber(b,"contract_size");let N=this.safeNumber(b,"min-order-value");const q=this.safeNumber(b,"max-order-amt");let R=this.safeNumber(b,"min-order-amt");a&&(c?R=v:u&&(N=v));let G,F,A;r?(G=this.parseNumber(this.parsePrecision(this.safeString(b,"price-precision"))),F=this.parseNumber(this.parsePrecision(this.safeString(b,"amount-precision"))),A=this.parseNumber(this.parsePrecision(this.safeString(b,"value-precision")))):(G=this.safeNumber(b,"price_tick"),F=this.parseNumber("1"));let V,Q;r&&(V=E==="OMG"?this.parseNumber("0"):this.parseNumber("0.002"),Q=E==="OMG"?this.parseNumber("0"):this.parseNumber("0.002"));let J;r?J=this.safeString(b,"state")==="online":a&&(J=this.safeInteger(b,"contract_status")===1);const se=this.safeString(b,"leverage-ratio","1"),we=this.safeString(b,"super-margin-leverage-ratio","1"),le=di.stringGt(se,"1")||di.stringGt(we,"1");g.push({id:O,lowercaseId:x,symbol:S,base:E,quote:P,settle:_,baseId:w,lowercaseBaseId:C,quoteId:k,settleId:T,type:e,spot:r,margin:r&&le,swap:d,future:o,option:!1,active:J,contract:a,linear:c,inverse:u,taker:Q,maker:V,contractSize:v,expiry:I,expiryDatetime:this.iso8601(I),strike:void 0,optionType:void 0,precision:{amount:F,price:G,cost:A},limits:{leverage:{min:this.parseNumber("1"),max:this.parseNumber(se),superMax:this.parseNumber(we)},amount:{min:R,max:q},price:{min:void 0,max:void 0},cost:{min:N,max:void 0}},info:b})}return g}parseTicker(e,t=void 0){const s=this.safeString2(e,"symbol","contract_code"),i=this.safeSymbol(s,t),n=this.safeInteger(e,"ts");let r,a,o,d;"bid"in e&&(Array.isArray(e.bid)?(r=this.safeString(e.bid,0),a=this.safeString(e.bid,1)):(r=this.safeString(e,"bid"),a=this.safeString(e,"bidSize"))),"ask"in e&&(Array.isArray(e.ask)?(o=this.safeString(e.ask,0),d=this.safeString(e.ask,1)):(o=this.safeString(e,"ask"),d=this.safeString(e,"askSize")));const c=this.safeString(e,"open"),u=this.safeString(e,"close"),h=this.safeString(e,"amount"),l=this.safeString(e,"vol");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:r,bidVolume:a,ask:o,askVolume:d,vwap:void 0,open:c,close:u,last:u,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:h,quoteVolume:l,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={};let n="symbol",r="spotPublicGetMarketDetailMerged";s.linear?(r="contractPublicGetLinearSwapExMarketDetailMerged",n="contract_code"):s.inverse&&(s.future?r="contractPublicGetMarketDetailMerged":s.swap&&(r="contractPublicGetSwapExMarketDetailMerged",n="contract_code")),i[n]=s.id;const a=await this[r](this.extend(i,t)),o=this.safeValue(a,"tick",{}),d=this.parseTicker(o,s),c=this.safeInteger(a,"ts");return d.timestamp=c,d.datetime=this.iso8601(c),d}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeString(e,0);let i;s!==void 0&&(i=this.market(s));let n,r,a="spotPublicGetMarketTickers";[n,t]=this.handleMarketTypeAndParams("fetchTickers",i,t),[r,t]=this.handleSubTypeAndParams("fetchTickers",i,t);const o={},d=n==="future",c=n==="swap",u=r==="linear";(d||c)&&(u?(a="contractPublicGetLinearSwapExMarketDetailBatchMerged",d&&(o.business_type="futures")):r==="inverse"&&(d?a="contractPublicGetMarketDetailBatchMerged":c&&(a="contractPublicGetSwapExMarketDetailBatchMerged"))),t=this.omit(t,["type","subType"]);const l=await this[a](this.extend(o,t)),p=this.safeValue2(l,"data","ticks",[]),m=this.safeInteger(l,"ts"),g={};for(let y=0;y<p.length;y++){const b=this.parseTicker(p[y]);if(d&&u)for(let k=0;k<this.symbols.length;k++){const T=this.symbols[k],O=this.market(T),x=this.safeString(O.info,"contract_type");if(x==="this_week"&&b.symbol===O.baseId+"-"+O.quoteId+"-CW"){b.symbol=O.symbol;break}else if(x==="next_week"&&b.symbol===O.baseId+"-"+O.quoteId+"-NW"){b.symbol=O.symbol;break}else if(x==="this_quarter"&&b.symbol===O.baseId+"-"+O.quoteId+"-CQ"){b.symbol=O.symbol;break}else if(x==="next_quarter"&&b.symbol===O.baseId+"-"+O.quoteId+"-NQ"){b.symbol=O.symbol;break}}const w=b.symbol;b.timestamp=m,b.datetime=this.iso8601(m),g[w]=b}return this.filterByArray(g,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={type:"step0"};let r="symbol",a="spotPublicGetMarketDepth";if(i.linear)a="contractPublicGetLinearSwapExMarketDepth",r="contract_code";else if(i.inverse)i.future?a="contractPublicGetMarketDepth":i.swap&&(a="contractPublicGetSwapExMarketDepth",r="contract_code");else if(t!==void 0){if(t!==5&&t!==10&&t!==20&&t!==150)throw new xi(this.id+" fetchOrderBook() limit argument must be undefined, 5, 10, 20, or 150, default is 150");t!==150&&(n.depth=t)}n[r]=i.id;const o=await this[a](this.extend(n,s));if("tick"in o){if(!o.tick)throw new ta(this.id+" fetchOrderBook() returned empty response: "+this.json(o));const d=this.safeValue(o,"tick"),c=this.safeInteger(d,"ts",this.safeInteger(o,"ts")),u=this.parseOrderBook(d,e,c);return u.nonce=this.safeInteger(d,"version"),u}throw new yv(this.id+" fetchOrderBook() returned unrecognized response: "+this.json(o))}parseTrade(e,t=void 0){const s=this.safeString2(e,"contract_code","symbol");t=this.safeMarket(s,t);const i=t.symbol;let n=this.safeInteger2(e,"ts","created-at");n=this.safeInteger2(e,"created_at","create_date",n);const r=this.safeString2(e,"order-id","order_id");let a=this.safeString(e,"direction"),o=this.safeString(e,"type");if(o!==void 0){const k=o.split("-");a=k[0],o=k[1]}const d=this.safeStringLower(e,"role"),c=this.safeString2(e,"price","trade_price");let u=this.safeString2(e,"filled-amount","amount");u=this.safeString(e,"trade_volume",u);const h=this.safeString(e,"trade_turnover");let l,p=this.safeString2(e,"filled-fees","trade_fee");const m=this.safeString2(e,"fee-currency","fee_asset");let g=this.safeCurrencyCode(m);const y=this.safeString(e,"filled-points");if(y!==void 0&&(p===void 0||di.stringEquals(p,"0"))){const k=this.safeString(e,"fee-deduct-currency");k!==void 0&&(p=y,g=this.safeCurrencyCode(k))}p!==void 0&&(l={cost:p,currency:g});const b=this.safeString2(e,"trade-id","tradeId"),w=this.safeString2(e,"trade_id","id",b);return this.safeTrade({id:w,info:e,order:r,timestamp:n,datetime:this.iso8601(n),symbol:i,type:o,side:a,takerOrMaker:d,price:c,amount:u,cost:h,fee:l},t)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){let r;t!==void 0&&(r=this.market(t));let a;[a,n]=this.handleMarketTypeAndParams("fetchOrderTrades",r,n);const o=this.getSupportedMapping(a,{spot:"fetchSpotOrderTrades"});return await this[o](e,t,s,i,n)}async fetchSpotOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={"order-id":e},a=await this.spotPrivateGetV1OrderOrdersOrderIdMatchresults(this.extend(r,n));return this.parseTrades(a.data,void 0,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));let r;[r,i]=this.handleMarketTypeAndParams("fetchMyTrades",n,i);const a={};let o;if(r==="spot")e!==void 0&&(n=this.market(e),a.symbol=n.id),s!==void 0&&(a.size=s),t!==void 0&&(a["start-time"]=t),o="spotPrivateGetV1OrderMatchresults";else{if(e===void 0)throw new Us(this.id+" fetchMyTrades() requires a symbol for "+r+" orders");if(a.contract=n.id,a.trade_type=0,t!==void 0&&(a.start_time=t),s!==void 0&&(a.page_size=s),n.linear){let u;[u,i]=this.handleMarginModeAndParams("fetchMyTrades",i),u=u===void 0?"cross":u,u==="isolated"?o="contractPrivatePostLinearSwapApiV3SwapMatchresultsExact":u==="cross"&&(o="contractPrivatePostLinearSwapApiV3SwapCrossMatchresultsExact")}else if(n.inverse)if(r==="future")o="contractPrivatePostApiV3ContractMatchresultsExact",a.symbol=n.settleId;else if(r==="swap")o="contractPrivatePostSwapApiV3SwapMatchresultsExact";else throw new _i(this.id+" fetchMyTrades() does not support "+r+" markets")}const d=await this[o](this.extend(a,i));let c=this.safeValue(d,"data");return Array.isArray(c)||(c=this.safeValue(c,"trades")),this.parseTrades(c,n,t,s)}async fetchTrades(e,t=void 0,s=1e3,i={}){await this.loadMarkets();const n=this.market(e),r={};let a="symbol",o="spotPublicGetMarketHistoryTrade";n.future?n.inverse?o="contractPublicGetMarketHistoryTrade":n.linear&&(o="contractPublicGetLinearSwapExMarketHistoryTrade",a="contract_code"):n.swap&&(n.inverse?o="contractPublicGetSwapExMarketHistoryTrade":n.linear&&(o="contractPublicGetLinearSwapExMarketHistoryTrade"),a="contract_code"),r[a]=n.id,s!==void 0&&(r.size=s);const d=await this[o](this.extend(r,i)),c=this.safeValue(d,"data",[]);let u=[];for(let h=0;h<c.length;h++){const l=this.safeValue(c[h],"data",[]);for(let p=0;p<l.length;p++){const m=this.parseTrade(l[p],n);u.push(m)}}return u=this.sortBy(u,"timestamp"),this.filterBySymbolSinceLimit(u,n.symbol,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"id"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"amount")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={period:this.timeframes[t]};let o="symbol";const d=this.safeString(n,"price");n=this.omit(n,"price");let c="spotPublicGetMarketHistoryCandles";if(r.spot)s!==void 0&&(a.from=parseInt(s/1e3)),i!==void 0&&(a.size=i);else if(r.future){if(r.inverse)if(d==="mark")c="contractPublicGetIndexMarketHistoryMarkPriceKline";else if(d==="index")c="contractPublicGetIndexMarketHistoryIndex";else{if(d==="premiumIndex")throw new xi(this.id+" "+r.type+" has no api endpoint for "+d+" kline data");c="contractPublicGetMarketHistoryKline"}else if(r.linear){if(d==="mark")c="contractPublicGetIndexMarketHistoryLinearSwapMarkPriceKline";else{if(d==="index")throw new xi(this.id+" "+r.type+" has no api endpoint for "+d+" kline data");d==="premiumIndex"?c="contractPublicGetIndexMarketHistoryLinearSwapPremiumIndexKline":c="contractPublicGetLinearSwapExMarketHistoryKline"}o="contract_code"}}else if(r.swap){if(r.inverse)if(d==="mark")c="contractPublicGetIndexMarketHistorySwapMarkPriceKline";else{if(d==="index")throw new xi(this.id+" "+r.type+" has no api endpoint for "+d+" kline data");d==="premiumIndex"?c="contractPublicGetIndexMarketHistorySwapPremiumIndexKline":c="contractPublicGetSwapExMarketHistoryKline"}else if(r.linear)if(d==="mark")c="contractPublicGetIndexMarketHistoryLinearSwapMarkPriceKline";else{if(d==="index")throw new xi(this.id+" "+r.type+" has no api endpoint for "+d+" kline data");d==="premiumIndex"?c="contractPublicGetIndexMarketHistoryLinearSwapPremiumIndexKline":c="contractPublicGetLinearSwapExMarketHistoryKline"}o="contract_code"}if(r.contract&&(i===void 0&&(i=2e3),a.size=i,d===void 0)){const l=this.parseTimeframe(t);if(s===void 0){const p=this.seconds();a.from=p-l*(i-1),a.to=p}else{const p=parseInt(s/1e3);a.from=p,a.to=this.sum(p,l*(i-1))}}a[o]=r.id;const u=await this[c](this.extend(a,n)),h=this.safeValue(u,"data",[]);return this.parseOHLCVs(h,r,t,s,i)}async fetchAccounts(e={}){await this.loadMarkets();const t=await this.spotPrivateGetV1AccountAccounts(e),s=this.safeValue(t,"data");return this.parseAccounts(s)}parseAccount(e){const t=this.safeString(e,"type"),s=this.safeValue(this.options,"accountsById",{}),i=this.safeValue(s,t,t);return{info:e,id:this.safeString(e,"id"),type:i,code:void 0}}async fetchAccountIdByType(e,t={}){const s=await this.loadAccounts(),i=this.safeValue(t,"account-id");if(i!==void 0)return i;const n=this.indexBy(s,"type"),r=this.safeValue(s,0,{}),a=this.safeValue(n,e,r);return this.safeString(a,"id")}async fetchCurrencies(e={}){const t=await this.spotPublicGetV2ReferenceCurrencies(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.safeValue(r,"chains",[]),c={},h=this.safeString(r,"instStatus")==="normal";let l,p,m,g,y,b;for(let T=0;T<d.length;T++){const O=d[T],x=this.safeString(O,"chain");let C=this.safeString(O,"baseChainProtocol");const E="h"+a;C===void 0&&(E===x?C="ERC20":C=this.safeString(O,"displayName"));const P=this.safeNetwork(C);m=this.safeNumber(O,"minWithdrawAmt"),g=this.safeNumber(O,"maxWithdrawAmt");const _=this.safeString(O,"withdrawStatus"),S=this.safeString(O,"depositStatus"),I=_==="allowed",v=S==="allowed",N=I&&v,q=this.parsePrecision(this.safeString(O,"withdrawPrecision"));q!==void 0&&(p=p===void 0?q:di.stringMin(q,p)),I&&!b?b=!0:I||(b=!1),v&&!y?y=!0:v||(y=!1),l=this.safeNumber(O,"transactFeeWithdraw"),c[P]={info:O,id:x,network:P,limits:{withdraw:{min:m,max:g}},active:N,deposit:v,withdraw:I,fee:l,precision:this.parseNumber(q)}}const k=Object.keys(c).length;i[o]={info:r,code:o,id:a,active:h,deposit:y,withdraw:b,fee:k<=1?l:void 0,name:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:k<=1?m:void 0,max:k<=1?g:void 0}},precision:this.parseNumber(p),networks:c}}return i}async fetchBalance(e={}){await this.loadMarkets();let t;[t,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e);const s=this.safeValue(this.options,"fetchBalance",{}),i={};let n;const r=t==="margin",a=t==="spot",o=t==="future",d=t==="swap",c=this.safeString2(this.options,"defaultSubType","subType","linear");let u=this.safeString2(s,"defaultSubType","subType",c);u=this.safeString2(e,"defaultSubType","subType",u);const h=u==="inverse",l=u==="linear";let p;[p,e]=this.handleMarginModeAndParams("fetchBalance",e),e=this.omit(e,["defaultSubType","subType"]);const m=p==="isolated",g=p==="cross";if(a)if(m)n="spotPrivateGetV1MarginAccountsBalance";else if(g)n="spotPrivateGetV1CrossMarginAccountsBalance";else{await this.loadAccounts();const T=await this.fetchAccountIdByType(t,e);i["account-id"]=T,n="spotPrivateGetV1AccountAccountsAccountIdBalance"}else r?m?n="spotPrivateGetV1MarginAccountsBalance":n="spotPrivateGetV1CrossMarginAccountsBalance":l?m?n="contractPrivatePostLinearSwapApiV1SwapAccountInfo":n="contractPrivatePostLinearSwapApiV1SwapCrossAccountInfo":h&&(o?n="contractPrivatePostApiV1ContractAccountInfo":d&&(n="contractPrivatePostSwapApiV1SwapAccountInfo"));const y=await this[n](this.extend(i,e)),b={info:y},w=this.safeValue(y,"data");if(a||r)if(m)for(let T=0;T<w.length;T++){const O=w[T],x=this.safeSymbol(this.safeString(O,"symbol")),C=this.safeValue(O,"list"),E={};for(let P=0;P<C.length;P++){const _=C[P],S=this.safeString(_,"currency"),I=this.safeCurrencyCode(S);E[I]=this.parseMarginBalanceHelper(_,I,E)}b[x]=this.safeBalance(E)}else{const T=this.safeValue(w,"list",[]);for(let O=0;O<T.length;O++){const x=T[O],C=this.safeString(x,"currency"),E=this.safeCurrencyCode(C);b[E]=this.parseMarginBalanceHelper(x,E,b)}}else if(l){const T=this.safeValue(w,0,{});if(g){const O=this.account();O.free=this.safeString(T,"margin_balance","margin_available"),O.used=this.safeString(T,"margin_frozen");const x=this.safeString2(T,"margin_asset","symbol"),C=this.safeCurrencyCode(x);b[C]=O}else if(m){for(let O=0;O<w.length;O++){const x=w[O],C=this.safeString2(x,"contract_code","margin_account"),E=this.safeMarket(C),P=this.safeString(x,"margin_asset"),_=this.safeCurrency(P),S=this.safeString(E,"settle",_.code);if(S!==void 0){const I=this.account();I.free=this.safeString(x,"margin_balance"),I.used=this.safeString(x,"margin_frozen");const v={};v[S]=I;const N=E.symbol;b[N]=this.safeBalance(v)}}return b}}else if(h)for(let T=0;T<w.length;T++){const O=w[T],x=this.safeString(O,"symbol"),C=this.safeCurrencyCode(x),E=this.account();E.free=this.safeString(O,"margin_available"),E.used=this.safeString(O,"margin_frozen"),b[C]=E}return m&&(a||r)?b:this.safeBalance(b)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));let n;[n,s]=this.handleMarketTypeAndParams("fetchOrder",i,s);const r={};let a;if(n==="spot"){const c=this.safeString(s,"clientOrderId");a="spotPrivateGetV1OrderOrdersOrderId",c!==void 0?a="spotPrivateGetV1OrderOrdersGetClientOrder":r["order-id"]=e}else{if(t===void 0)throw new Us(this.id+" fetchOrder() requires a symbol for "+n+" orders");if(r.contract_code=i.id,i.linear){let u;[u,s]=this.handleMarginModeAndParams("fetchOrder",s),u=u===void 0?"cross":u,u==="isolated"?a="contractPrivatePostLinearSwapApiV1SwapOrderInfo":u==="cross"&&(a="contractPrivatePostLinearSwapApiV1SwapCrossOrderInfo")}else if(i.inverse)if(n==="future")a="contractPrivatePostApiV1ContractOrderInfo",r.symbol=i.settleId;else if(n==="swap")a="contractPrivatePostSwapApiV1SwapOrderInfo";else throw new _i(this.id+" fetchOrder() does not support "+n+" markets");const c=this.safeString2(s,"client_order_id","clientOrderId");c===void 0?r.order_id=e:(r.client_order_id=c,s=this.omit(s,["client_order_id","clientOrderId"]))}const o=await this[a](this.extend(r,s));let d=this.safeValue(o,"data");return Array.isArray(d)&&(d=this.safeValue(d,0)),this.parseOrder(d)}parseMarginBalanceHelper(e,t,s){let i;return t in s?i=s[t]:i=this.account(),e.type==="trade"&&(i.free=this.safeString(e,"balance")),e.type==="frozen"&&(i.used=this.safeString(e,"balance")),i}async fetchSpotOrdersByStates(e,t=void 0,s=void 0,i=void 0,n={}){const r=this.safeString(this.options,"fetchOrdersByStatesMethod","spot_private_get_v1_order_orders");if(r==="spot_private_get_v1_order_orders"&&t===void 0)throw new Us(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();let a;const o={states:e};t!==void 0&&(a=this.market(t),o.symbol=a.id),s!==void 0&&(o["start-time"]=s,o["end-time"]=this.sum(s,48*60*60*1e3)),i!==void 0&&(o.size=i);const d=await this[r](this.extend(o,n)),c=this.safeValue(d,"data",[]);return this.parseOrders(c,a,s,i)}async fetchSpotOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchSpotOrdersByStates("pre-submitted,submitted,partial-filled,filled,partial-canceled,canceled",e,t,s,i)}async fetchClosedSpotOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchSpotOrdersByStates("filled,partial-canceled,canceled",e,t,s,i)}async fetchContractOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Us(this.id+" fetchContractOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e);let r;[r,i]=this.handleMarketTypeAndParams("fetchOrders",n,i);const a={contract:n.id,trade_type:0,type:1,status:"0"};t!==void 0&&(a.start_time=t);let o;if(n.linear){let u;[u,i]=this.handleMarginModeAndParams("fetchContractOrders",i),u=u===void 0?"cross":u,o=this.getSupportedMapping(u,{isolated:"contractPrivatePostLinearSwapApiV3SwapHisorders",cross:"contractPrivatePostLinearSwapApiV3SwapCrossHisorders"})}else n.inverse&&(o=this.getSupportedMapping(r,{future:"contractPrivatePostApiV3ContractHisorders",swap:"contractPrivatePostSwapApiV3SwapHisorders"}),r==="future"&&(a.symbol=n.settleId));s!==void 0&&(a.page_size=s);const d=await this[o](this.extend(a,i)),c=this.safeValue(d,"data",[]);return this.parseOrders(c,n,t,s)}async fetchClosedContractOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"5,6,7"};return await this.fetchContractOrders(e,t,s,this.extend(n,i))}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));let r;[r,i]=this.handleMarketTypeAndParams("fetchOrders",n,i);const a=this.getSupportedMapping(r,{spot:"fetchSpotOrders",swap:"fetchContractOrders",future:"fetchContractOrders"});if(a===void 0)throw new _i(this.id+" fetchOrders() does not support "+r+" markets yet");if((r==="swap"||r==="future")&&e===void 0)throw new Us(this.id+" fetchOrders() requires a symbol argument for "+r+" orders");return await this[a](e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));let r;[r,i]=this.handleMarketTypeAndParams("fetchClosedOrders",n,i);const a=this.getSupportedMapping(r,{spot:"fetchClosedSpotOrders",swap:"fetchClosedContractOrders",future:"fetchClosedContractOrders"});if(a===void 0)throw new _i(this.id+" fetchClosedOrders() does not support "+r+" markets yet");return await this[a](e,t,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));let r;[r,i]=this.handleMarketTypeAndParams("fetchOpenOrders",n,i);const a={};let o;if(r==="spot"){o="spotPrivateGetV1OrderOpenOrders",e!==void 0&&(n=this.market(e),a.symbol=n.id);let u=this.safeString(i,"account-id");if(u===void 0){await this.loadAccounts();for(let h=0;h<this.accounts.length;h++){const l=this.accounts[h];if(l.type==="spot"&&(u=this.safeString(l,"id"),u!==void 0))break}}a["account-id"]=u,s!==void 0&&(a.size=s),i=this.omit(i,"account-id")}else{if(e===void 0)throw new Us(this.id+" fetchOpenOrders() requires a symbol for "+r+" orders");const u=this.market(e);if(a.contract_code=u.id,u.linear){let h;[h,i]=this.handleMarginModeAndParams("fetchOpenOrders",i),h=h===void 0?"cross":h,h==="isolated"?o="contractPrivatePostLinearSwapApiV1SwapOpenorders":h==="cross"&&(o="contractPrivatePostLinearSwapApiV1SwapCrossOpenorders")}else u.inverse&&(u.future?(o="contractPrivatePostApiV1ContractOpenorders",a.symbol=u.settleId):u.swap&&(o="contractPrivatePostSwapApiV1SwapOpenorders"));s!==void 0&&(a.page_size=s)}const d=await this[o](this.extend(a,i));let c=this.safeValue(d,"data");return Array.isArray(c)||(c=this.safeValue(c,"orders",[])),this.parseOrders(c,n,t,s)}parseOrderStatus(e){const t={"partial-filled":"open","partial-canceled":"canceled",filled:"closed",canceled:"canceled",submitted:"open",created:"open",1:"open",2:"open",3:"open",4:"open",5:"canceled",6:"closed",7:"canceled",11:"canceling"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString2(e,"id","order_id_str");let i=this.safeString(e,"direction"),n=this.safeString(e,"order_price_type");if("type"in e){const w=e.type.split("-");i=w[0],n=w[1]}const r=this.parseOrderStatus(this.safeString2(e,"state","status")),a=this.safeString2(e,"contract_code","symbol");t=this.safeMarket(a,t);const o=this.safeIntegerN(e,["created_at","created-at","create_date"]),d=this.safeString2(e,"client_order_id","client-order-id");let c,u;n!==void 0&&n.indexOf("market")>=0?i==="sell"?c=this.safeString(e,"field-cash-amount"):c=this.safeString(e,"amount"):(u=this.safeString2(e,"volume","amount"),c=this.safeStringN(e,["filled-cash-amount","field-cash-amount","trade_turnover"]));const h=this.safeStringN(e,["filled-amount","field-amount","trade_volume"]),l=this.safeString(e,"price");let p=this.safeString2(e,"filled-fees","field-fees");p=this.safeString(e,"fee",p);let m;if(p!==void 0){let w;const k=this.safeString(e,"fee_asset");k!==void 0?w=this.safeCurrencyCode(k):w=i==="sell"?t.quote:t.base,m={cost:p,currency:w}}const g=this.safeString(e,"stop-price"),y=this.safeString(e,"trade_avg_price"),b=this.safeValue(e,"trades");return this.safeOrder({info:e,id:s,clientOrderId:d,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:void 0,symbol:t.symbol,type:n,timeInForce:void 0,postOnly:void 0,side:i,price:l,stopPrice:g,average:y,cost:c,amount:u,filled:h,remaining:void 0,status:r,fee:m,trades:b},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),[o,d]=this.handleMarketTypeAndParams("createOrder",a,r),c=this.getSupportedMapping(o,{spot:"createSpotOrder",swap:"createContractOrder",future:"createContractOrder"});if(c===void 0)throw new _i(this.id+" createOrder() does not support "+o+" markets yet");return await this[c](e,t,s,i,n,d)}async createSpotOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets(),await this.loadAccounts();const a=this.market(e),d={"account-id":await this.fetchAccountIdByType(a.type),symbol:a.id};let c=t.replace("buy-","");c=c.replace("sell-","");const u=this.safeValue(this.options,a.type,{}),h=this.safeString2(r,"stopPrice","stop-price");if(h===void 0){const b=this.safeValue(u,"stopOrderTypes",{});if(c in b)throw new Us(this.id+" createOrder() requires a stopPrice or a stop-price parameter for a stop order")}else{const b=this.safeString(r,"operator");if(b===void 0)throw new Us(this.id+' createOrder() requires an operator parameter "gte" or "lte" for a stop order');if(r=this.omit(r,["stopPrice","stop-price"]),d["stop-price"]=this.priceToPrecision(e,h),d.operator=b,c==="limit"||c==="limit-fok")c="stop-"+c;else if(c!=="stop-limit"&&c!=="stop-limit-fok")throw new _i(this.id+" createOrder() does not support "+t+" orders")}this.safeValue(r,"postOnly",!1)&&(c="limit-maker"),d.type=s+"-"+c;const p=this.safeString2(r,"clientOrderId","client-order-id");if(p===void 0){const b=this.safeValue(this.options,"broker",{}),w=this.safeString(b,"id");d["client-order-id"]=w+this.uuid()}else d["client-order-id"]=p;if(r=this.omit(r,["clientOrderId","client-order-id","postOnly"]),c==="market"&&s==="buy")if(this.options.createMarketBuyOrderRequiresPrice){if(n===void 0)throw new Os(this.id+" market buy order requires price argument to calculate cost (total amount of quote currency to spend for buying, amount * price). To switch off this warning exception and specify cost in the amount argument, set .options['createMarketBuyOrderRequiresPrice'] = false. Make sure you know what you're doing.");{const b=this.numberToString(i),w=this.numberToString(n);d.amount=this.costToPrecision(e,di.stringMul(b,w))}}else d.amount=this.costToPrecision(e,i);else d.amount=this.amountToPrecision(e,i);const m=this.safeValue(u,"limitOrderTypes",{});c in m&&(d.price=this.priceToPrecision(e,n));const g=await this.spotPrivatePostV1OrderOrdersPlace(this.extend(d,r)),y=this.safeString(g,"data");return{info:g,id:y,timestamp:void 0,datetime:void 0,lastTradeTimestamp:void 0,status:void 0,symbol:void 0,type:void 0,side:void 0,price:void 0,amount:void 0,filled:void 0,remaining:void 0,cost:void 0,trades:void 0,fee:void 0,clientOrderId:void 0,average:void 0}}async createContractOrder(e,t,s,i,n=void 0,r={}){const a=this.safeString(r,"offset");if(this.safeString(r,"stopPrice")!==void 0)throw new _i(this.id+" createOrder() supports tp_trigger_price + tp_order_price for take profit orders and/or sl_trigger_price + sl_order price for stop loss orders, stop orders are supported only with open long orders and open short orders");const d=this.market(e),c={contract_code:d.id,volume:this.amountToPrecision(e,i),direction:s,lever_rate:1},u=this.safeString(r,"sl_order_price"),h=this.safeString(r,"sl_trigger_price"),l=this.safeString(r,"tp_order_price"),p=this.safeString(r,"tp_trigger_price"),m=a==="open";let g=!1;if(h!==void 0&&(c.sl_trigger_price=this.priceToPrecision(e,h),g=!0,n!==void 0&&(c.sl_order_price=this.priceToPrecision(e,n))),u!==void 0&&(c.sl_order_price=this.priceToPrecision(e,u),g=!0),p!==void 0&&(c.tp_trigger_price=this.priceToPrecision(e,p),g=!0,n!==void 0&&(c.tp_order_price=this.priceToPrecision(e,n))),l!==void 0&&(c.tp_order_price=this.priceToPrecision(e,l),g=!0),g&&!m)throw new _i(this.id+" createOrder() supports tp_trigger_price + tp_order_price for take profit orders and/or sl_trigger_price + sl_order price for stop loss orders, stop orders are supported only with open long orders and open short orders");r=this.omit(r,["sl_order_price","sl_trigger_price","tp_order_price","tp_trigger_price"]),this.safeValue(r,"postOnly",!1)&&(t="post_only"),(t==="limit"||t==="ioc"||t==="fok"||t==="post_only")&&(c.price=this.priceToPrecision(e,n)),c.order_price_type=t;const b=this.safeValue(this.options,"broker",{}),w=this.safeString(b,"id");c.channel_code=w;const k=this.safeString2(r,"client_order_id","clientOrderId");k!==void 0&&(c.client_order_id=k,r=this.omit(r,["client_order_id","clientOrderId"]));let T;if(d.linear){let C;[C,r]=this.handleMarginModeAndParams("createOrder",r),C=C===void 0?"cross":C,C==="isolated"?T="contractPrivatePostLinearSwapApiV1SwapOrder":C==="cross"&&(T="contractPrivatePostLinearSwapApiV1SwapCrossOrder")}else d.inverse&&(d.swap?T="contractPrivatePostSwapApiV1SwapOrder":d.future&&(T="contractPrivatePostApiV1ContractOrder"));const O=await this[T](this.extend(c,r)),x=this.safeValue(O,"data",{});return this.parseOrder(x,d)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));let n;[n,s]=this.handleMarketTypeAndParams("cancelOrder",i,s);const r={};let a;if(n==="spot"){const d=this.safeString2(s,"client-order-id","clientOrderId");a="spotPrivatePostV1OrderOrdersOrderIdSubmitcancel",d===void 0?r["order-id"]=e:(r["client-order-id"]=d,a="spotPrivatePostV1OrderOrdersSubmitCancelClientOrder",s=this.omit(s,["client-order-id","clientOrderId"]))}else{if(t===void 0)throw new Us(this.id+" cancelOrder() requires a symbol for "+n+" orders");if(r.contract_code=i.id,i.linear){let c;[c,s]=this.handleMarginModeAndParams("cancelOrder",s),c=c===void 0?"cross":c,c==="isolated"?a="contractPrivatePostLinearSwapApiV1SwapCancel":c==="cross"&&(a="contractPrivatePostLinearSwapApiV1SwapCrossCancel")}else if(i.inverse)i.future?(a="contractPrivatePostApiV1ContractCancel",r.symbol=i.settleId):i.swap&&(a="contractPrivatePostSwapApiV1SwapCancel");else throw new _i(this.id+" cancelOrder() does not support "+n+" markets");const d=this.safeString2(s,"client_order_id","clientOrderId");d===void 0?r.order_id=e:(r.client_order_id=d,s=this.omit(s,["client_order_id","clientOrderId"]))}const o=await this[a](this.extend(r,s));return this.extend(this.parseOrder(o,i),{id:e,status:"canceled"})}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));let n;[n,s]=this.handleMarketTypeAndParams("cancelOrders",i,s);const r={};let a;if(n==="spot"){let d=this.safeValue2(s,"client-order-id","clientOrderId");d=this.safeValue2(s,"client-order-ids","clientOrderIds",d),d===void 0?typeof d=="string"?r["order-ids"]=e:r["order-ids"]=e.join(","):(typeof d=="string"?r["client-order-ids"]=d:r["client-order-ids"]=d.join(","),s=this.omit(s,["client-order-id","client-order-ids","clientOrderId","clientOrderIds"])),a="spotPrivatePostV1OrderOrdersBatchcancel"}else{if(t===void 0)throw new Us(this.id+" cancelOrders() requires a symbol for "+n+" orders");const d=this.market(t);if(r.contract_code=d.id,d.linear){let u;[u,s]=this.handleMarginModeAndParams("cancelOrders",s),u=u===void 0?"cross":u,u==="isolated"?a="contractPrivatePostLinearSwapApiV1SwapCancel":u==="cross"&&(a="contractPrivatePostLinearSwapApiV1SwapCrossCancel")}else if(d.inverse)if(d.future)a="contractPrivatePostApiV1ContractCancel",r.symbol=d.settleId;else if(d.swap)a="contractPrivatePostSwapApiV1SwapCancel";else throw new _i(this.id+" cancelOrders() does not support "+n+" markets");let c=this.safeString2(s,"client_order_id","clientOrderId");c=this.safeString2(s,"client_order_ids","clientOrderIds",c),c===void 0?r.order_id=e.join(","):(r.client_order_id=c,s=this.omit(s,["client_order_id","client_order_ids","clientOrderId","clientOrderIds"]))}return await this[a](this.extend(r,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();let s;e!==void 0&&(s=this.market(e));let i;[i,t]=this.handleMarketTypeAndParams("cancelAllOrders",s,t);const n={};let r;if(i==="spot")e!==void 0&&(s=this.market(e),n.symbol=s.id),r="spotPrivatePostV1OrderOrdersBatchCancelOpenOrders";else{if(e===void 0)throw new Us(this.id+" cancelAllOrders() requires a symbol for "+i+" orders");const o=this.market(e);if(n.contract_code=o.id,o.linear){let d;[d,t]=this.handleMarginModeAndParams("cancelAllOrders",t),d=d===void 0?"cross":d,d==="isolated"?r="contractPrivatePostLinearSwapApiV1SwapCancelallall":d==="cross"&&(r="contractPrivatePostLinearSwapApiV1SwapCrossCancelall")}else if(o.inverse)if(i==="future")r="contractPrivatePostApiV1ContractCancelall",n.symbol=o.settleId;else if(i==="swap")r="contractPrivatePostSwapApiV1SwapCancelall";else throw new _i(this.id+" cancelAllOrders() does not support "+i+" markets")}return await this[r](this.extend(n,t))}safeNetwork(e){const t=e.length-1;e[t]==="1"&&(e=e.slice(0,t));const i={};return this.safeString(i,e,e)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"addressTag"),n=this.safeString(e,"currency");t=this.safeCurrency(n,t);const r=this.safeCurrencyCode(n,t),a=this.safeString(e,"chain"),o=this.safeValue(t,"networks",{}),d=this.indexBy(o,"id"),c=this.safeValue(d,a,a),u=this.safeStringUpper(c,"network"),h=this.safeString(e,"note");return this.checkAddress(s),{currency:r,address:s,tag:i,network:u,note:h,info:e}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.spotPrivateGetV2AccountDepositAddress(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.parseDepositAddresses(r,[e],!1);return this.indexBy(a,"network")}async fetchDepositAddress(e,t={}){const s=this.safeStringUpper(t,"network"),i=this.safeValue(this.options,"networks",{}),n=this.safeStringUpper(i,s,s);t=this.omit(t,"network");const r=await this.fetchDepositAddressesByNetwork(e,t);let a;if(n===void 0){if(a=this.safeValue(r,e),a===void 0){const o=this.safeString(i,e,e);if(a=this.safeValue(r,o),a===void 0){const d=this.safeString(this.options,"defaultNetwork","ERC20");if(a=this.safeValue(r,d),a===void 0){const c=Object.values(r);if(a=this.safeValue(c,0),a===void 0)throw new zf(this.id+" fetchDepositAddress() cannot find deposit address for "+e)}}}return a}if(a=this.safeValue(r,n),a===void 0)throw new zf(this.id+" fetchDepositAddress() cannot find "+n+" deposit address for "+e);return a}async fetchWithdrawAddressesByNetwork(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.spotPrivateGetV2AccountWithdrawAddress(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.parseDepositAddresses(r,[e],!1);return this.indexBy(a,"network")}async fetchWithdrawAddress(e,t={}){const s=this.safeStringUpper(t,"network"),i=this.safeValue(this.options,"networks",{}),n=this.safeStringUpper(i,s,s);t=this.omit(t,"network");const r=await this.fetchWithdrawAddressesByNetwork(e,t);let a;if(n===void 0){if(a=this.safeValue(r,e),a===void 0){const o=this.safeString(i,e,e);if(a=this.safeValue(r,o),a===void 0){const d=this.safeString(this.options,"defaultNetwork","ERC20");if(a=this.safeValue(r,d),a===void 0){const c=Object.values(r);if(a=this.safeValue(c,0),a===void 0)throw new zf(this.id+" fetchWithdrawAddress() cannot find withdraw address for "+e)}}}return a}if(a=this.safeValue(r,n),a===void 0)throw new zf(this.id+" fetchWithdrawAddress() cannot find "+n+" withdraw address for "+e);return a}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){(s===void 0||s>100)&&(s=100),await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r={type:"deposit",from:0};n!==void 0&&(r.currency=n.id),s!==void 0&&(r.size=s);const a=await this.spotPrivateGetV1QueryDepositWithdraw(this.extend(r,i));return this.parseTransactions(a.data,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){(s===void 0||s>100)&&(s=100),await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r={type:"withdraw",from:0};n!==void 0&&(r.currency=n.id),s!==void 0&&(r.size=s);const a=await this.spotPrivateGetV1QueryDepositWithdraw(this.extend(r,i));return this.parseTransactions(a.data,n,t,s)}parseTransaction(e,t=void 0){const s=this.safeInteger(e,"created-at"),i=this.safeCurrencyCode(this.safeString(e,"currency"));let n=this.safeString(e,"type");n==="withdraw"&&(n="withdrawal");let r=this.safeString(e,"fee");return r!==void 0&&(r=di.stringAbs(r)),{info:e,id:this.safeString2(e,"id","data"),txid:this.safeString(e,"tx-hash"),timestamp:s,datetime:this.iso8601(s),network:this.safeStringUpper(e,"chain"),address:this.safeString(e,"address"),addressTo:void 0,addressFrom:void 0,tag:this.safeString(e,"address-tag"),tagTo:void 0,tagFrom:void 0,type:n,amount:this.safeNumber(e,"amount"),currency:i,status:this.parseTransactionStatus(this.safeString(e,"state")),updated:this.safeInteger(e,"updated-at"),fee:{currency:i,cost:this.parseNumber(r),rate:void 0}}}parseTransactionStatus(e){const t={unknown:"failed",confirming:"pending",confirmed:"ok",safe:"ok",orphan:"failed",submitted:"pending",canceled:"canceled",reexamine:"pending",reject:"failed",pass:"pending","wallet-reject":"failed","confirm-error":"failed",repealed:"failed","wallet-transfer":"pending","pre-transfer":"pending"};return this.safeString(t,e,e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets(),this.checkAddress(s);const r=this.currency(e),a={address:s,amount:t,currency:r.id.toLowerCase()};i!==void 0&&(a["addr-tag"]=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeStringLower(o,d,d),d!==void 0&&(d==="erc20"?a.chain=r.id+d:a.chain=d+r.id,n=this.omit(n,"network"));const c=await this.spotPrivatePostV1DwWithdrawApiCreate(this.extend(a,n));return this.parseTransaction(c,r)}parseTransfer(e,t=void 0){const s=this.safeString(e,"data"),i=this.safeCurrencyCode(void 0,t);return{info:e,id:s,timestamp:void 0,datetime:void 0,currency:i,amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0}}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e);let a=this.safeString(n,"type");if(a===void 0){const u=this.safeValue(this.options,"accountsByType",{});s=s.toLowerCase(),i=i.toLowerCase();const h=this.safeString(u,s,s),l=this.safeString(u,i,i);a=h+"-to-"+l}const o={currency:r.id,amount:parseFloat(this.currencyToPrecision(e,t)),type:a},d=await this.spotPrivatePostFuturesTransfer(this.extend(o,n)),c=this.parseTransfer(d,r);return this.extend(c,{amount:t,currency:e,fromAccount:s,toAccount:i})}async fetchBorrowRatesPerSymbol(e={}){await this.loadMarkets();const t=await this.spotPrivateGetV1MarginLoanInfo(e),s=this.milliseconds(),i=this.safeValue(t,"data",[]),n={info:t};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeValue(a,"currencies",[]),d={};for(let h=0;h<o.length;h++){const l=o[h],p=this.safeString(l,"currency"),m=this.safeCurrencyCode(p,"currency");d[m]={currency:m,rate:this.safeNumber(l,"actual-rate"),span:864e5,timestamp:s,datetime:this.iso8601(s)}}const u=this.markets_by_id[this.safeString(a,"symbol")].symbol;n[u]=d}return n}async fetchBorrowRates(e={}){await this.loadMarkets();const t=await this.spotPrivateGetV1MarginLoanInfo(e),s=this.milliseconds(),i=this.safeValue(t,"data",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeValue(a,"currencies",[]);for(let d=0;d<o.length;d++){const c=o[d],u=this.safeString(c,"currency"),h=this.safeCurrencyCode(u,"currency");n[h]={currency:h,rate:this.safeNumber(c,"actual-rate"),span:864e5,timestamp:s,datetime:this.iso8601(s),info:void 0}}}return n}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Us(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={contract_code:n.id};let a;if(n.inverse)a="contractPublicGetSwapApiV1SwapHistoricalFundingRate";else if(n.linear)a="contractPublicGetLinearSwapApiV1SwapHistoricalFundingRate";else throw new _i(this.id+" fetchFundingRateHistory() supports inverse and linear swaps only");const o=await this[a](this.extend(r,i)),d=this.safeValue(o,"data"),c=this.safeValue(d,"data",[]),u=[];for(let l=0;l<c.length;l++){const p=c[l],m=this.safeString(p,"contract_code"),g=this.safeSymbol(m),y=this.safeInteger(p,"funding_time");u.push({info:p,symbol:g,fundingRate:this.safeNumber(p,"funding_rate"),timestamp:y,datetime:this.iso8601(y)})}const h=this.sortBy(u,"timestamp");return this.filterBySymbolSinceLimit(h,n.symbol,t,s)}parseFundingRate(e,t=void 0){const s=this.safeNumber(e,"estimated_rate"),i=this.safeInteger(e,"funding_time"),n=this.safeInteger(e,"next_funding_time"),r=this.safeString(e,"contract_code"),a=this.safeSymbol(r,t);return{info:e,symbol:a,markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeNumber(e,"funding_rate"),fundingTimestamp:i,fundingDatetime:this.iso8601(i),nextFundingRate:s,nextFundingTimestamp:n,nextFundingDatetime:this.iso8601(n),previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);let i;if(s.inverse)i="contractPublicGetSwapApiV1SwapFundingRate";else if(s.linear)i="contractPublicGetLinearSwapApiV1SwapFundingRate";else throw new _i(this.id+" fetchFundingRate() supports inverse and linear swaps only");const n={contract_code:s.id},r=await this[i](this.extend(n,t)),a=this.safeValue(r,"data",{});return this.parseFundingRate(a,s)}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeValue(this.options,"fetchFundingRates",{}),i=this.safeString(this.options,"defaultSubType","inverse");let n=this.safeString(s,"subType",i);n=this.safeString(t,"subType",n);const r={},a=this.getSupportedMapping(n,{linear:"contractPublicGetLinearSwapApiV1SwapBatchFundingRate",inverse:"contractPublicGetSwapApiV1SwapBatchFundingRate"});t=this.omit(t,"subType");const o=await this[a](this.extend(r,t)),d=this.safeValue(o,"data",[]),c=this.parseFundingRates(d);return this.filterByArray(c,"symbol",e)}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;[r,n]=this.handleMarginModeAndParams("fetchBorrowInterest",n),r=r===void 0?"cross":r;const a={};s!==void 0&&(a["start-date"]=this.yyyymmdd(s)),i!==void 0&&(a.size=i);let o,d;if(r==="isolated")d="privateGetMarginLoanOrders",t!==void 0&&(o=this.market(t),a.symbol=o.id);else if(d="privateGetCrossMarginLoanOrders",e!==void 0){const l=this.currency(e);a.currency=l.id}const c=await this[d](this.extend(a,n)),u=this.safeValue(c,"data"),h=this.parseBorrowInterests(u,o);return this.filterByCurrencySinceLimit(h,e,s,i)}parseBorrowInterest(e,t=void 0){const s=this.safeString(e,"symbol"),i=s===void 0?"cross":"isolated";t=this.safeMarket(s);const n=this.safeString(t,"symbol"),r=this.safeNumber(e,"accrued-at");return{account:i==="isolated"?n:"cross",symbol:n,marginMode:i,currency:this.safeCurrencyCode(this.safeString(e,"currency")),interest:this.safeNumber(e,"interest-amount"),interestRate:this.safeNumber(e,"interest-rate"),amountBorrowed:this.safeNumber(e,"loan-amount"),timestamp:r,datetime:this.iso8601(r),info:e}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/";const o=this.omit(i,this.extractParams(e));if(typeof t=="string"){if(t==="public"||t==="private"?a+=this.version:(t==="v2Public"||t==="v2Private")&&(a+="v2"),a+="/"+this.implodeParams(e,i),t==="private"||t==="v2Private"){this.checkRequiredCredentials();const d=this.ymdhms(this.milliseconds(),"T");let c={SignatureMethod:"HmacSHA256",SignatureVersion:"2",AccessKeyId:this.apiKey,Timestamp:d};s!=="POST"&&(c=this.extend(c,o)),c=this.keysort(c);let u=this.urlencode(c);const h=[s,this.hostname,a,u].join(`
`),l=this.hmac(this.encode(h),this.encode(this.secret),"sha256","base64");u+="&"+this.urlencode({Signature:l}),a+="?"+u,s==="POST"?(r=this.json(o),n={"Content-Type":"application/json"}):n={"Content-Type":"application/x-www-form-urlencoded"}}else Object.keys(o).length&&(a+="?"+this.urlencode(o));a=this.implodeParams(this.urls.api[t],{hostname:this.hostname})+a}else{const d=this.safeString(t,0),c=this.safeString(t,1),u=this.safeString(t,2),h=this.safeString(t,3);let l,p=this.safeValue(this.urls.hostnames,d);if(typeof p!="string"&&(p=this.safeValue(p,u),typeof l!="string"&&h!==void 0&&(p=this.safeValue(p,h))),l=p,a+=this.implodeParams(e,i),c==="public")Object.keys(o).length&&(a+="?"+this.urlencode(o));else if(c==="private"){this.checkRequiredCredentials();const m=this.ymdhms(this.milliseconds(),"T");let g={SignatureMethod:"HmacSHA256",SignatureVersion:"2",AccessKeyId:this.apiKey,Timestamp:m};s!=="POST"&&(g=this.extend(g,o)),g=this.keysort(g);let y=this.urlencode(g);const b=[s,l,a,y].join(`
`),w=this.hmac(this.encode(b),this.encode(this.secret),"sha256","base64");y+="&"+this.urlencode({Signature:w}),a+="?"+y,s==="POST"?(r=this.json(o),r.length===2&&(r="{}"),n={"Content-Type":"application/json"}):n={"Content-Type":"application/x-www-form-urlencoded"}}a=this.implodeParams(this.urls.api[d],{hostname:l})+a}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&"status"in a&&this.safeString(a,"status")==="error"){const u=this.safeString2(a,"err-code","err_code"),h=this.id+" "+r;this.throwBroadlyMatchedException(this.exceptions.broad,r,h),this.throwExactlyMatchedException(this.exceptions.exact,u,h);const l=this.safeString2(a,"err-msg","err_msg");throw this.throwExactlyMatchedException(this.exceptions.exact,l,h),new yv(h)}}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),[r,a]=this.handleMarketTypeAndParams("fetchFundingHistory",n,i);let o;const d={type:"30,31"};if(t!==void 0&&(d.start_date=t),n.linear){o="contractPrivatePostLinearSwapApiV3SwapFinancialRecordExact";let h;[h,i]=this.handleMarginModeAndParams("fetchFundingHistory",i),h=h===void 0?"cross":h,h==="isolated"?d.mar_acct=n.id:d.mar_acct=n.quoteId}else r==="swap"?(o="contractPrivatePostSwapApiV3SwapFinancialRecordExact",d.contract=n.id):(o="contractPrivatePostApiV3ContractFinancialRecordExact",d.symbol=n.id);const c=await this[o](this.extend(d,a)),u=this.safeValue(c,"data",[]);return this.parseIncomes(u,n,t,s)}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new Us(this.id+" setLeverage() requires a symbol argument");await this.loadMarkets();const i=this.market(t),[n,r]=this.handleMarketTypeAndParams("setLeverage",i,s);let a;if(i.linear){let c;[c,s]=this.handleMarginModeAndParams("setLeverage",s),c=c===void 0?"cross":c,a=this.getSupportedMapping(c,{isolated:"contractPrivatePostLinearSwapApiV1SwapSwitchLeverRate",cross:"contractPrivatePostLinearSwapApiV1SwapCrossSwitchLeverRate"})}else a=this.getSupportedMapping(n,{future:"contractPrivatePostApiV1ContractSwitchLeverRate",swap:"contractPrivatePostSwapApiV1SwapSwitchLeverRate"});const o={lever_rate:e};return n==="future"&&i.inverse?o.symbol=i.settleId:o.contract_code=i.id,await this[a](this.extend(o,r))}parseIncome(e,t=void 0){const s=this.safeString(e,"contract_code"),i=this.safeSymbol(s,t),n=this.safeNumber(e,"amount"),r=this.safeInteger(e,"ts"),a=this.safeString(e,"id"),o=this.safeString2(e,"symbol","asset"),d=this.safeCurrencyCode(o);return{info:e,symbol:i,code:d,timestamp:r,datetime:this.iso8601(r),id:a,amount:n}}parseIncomes(e,t=void 0,s=void 0,i=void 0){const n=[];for(let a=0;a<e.length;a++){const o=e[a],d=this.parseIncome(o,t);n.push(d)}const r=this.sortBy(n,"timestamp");return this.filterBySinceLimit(r,s,i,"timestamp")}parsePosition(e,t=void 0){t=this.safeMarket(this.safeString(e,"contract_code"));const s=t.symbol,i=this.safeString(e,"volume"),n=this.safeValue(t,"contractSize"),r=this.numberToString(n),a=this.safeNumber(e,"cost_open"),o=this.safeString(e,"position_margin"),c=this.safeString(e,"direction")==="buy"?"long":"short",u=this.safeNumber(e,"profit_unreal");let h=this.safeString(e,"margin_mode");const l=this.safeString(e,"lever_rate"),p=di.stringMul(this.safeString(e,"profit_rate"),"100"),m=this.safeString(e,"last_price"),g=di.stringMul(i,r);let y;t.linear?y=di.stringMul(g,m):(y=di.stringDiv(g,m),h="cross");const b=di.stringDiv(o,y),w=this.safeString(e,"margin_balance"),k=this.safeNumber(e,"liquidation_price"),T=this.safeString(e,"adjust_factor"),O=di.stringDiv(T,l),x=di.stringMul(O,y),C=di.stringDiv(x,w);return{info:e,id:void 0,symbol:s,contracts:this.parseNumber(i),contractSize:n,entryPrice:a,collateral:this.parseNumber(w),side:c,unrealizedProfit:u,leverage:this.parseNumber(l),percentage:this.parseNumber(p),marginMode:h,notional:this.parseNumber(y),markPrice:void 0,liquidationPrice:k,initialMargin:this.parseNumber(o),initialMarginPercentage:this.parseNumber(b),maintenanceMargin:this.parseNumber(x),maintenanceMarginPercentage:this.parseNumber(O),marginRatio:this.parseNumber(C),timestamp:void 0,datetime:void 0}}async fetchPositions(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s;[s,t]=this.handleMarginModeAndParams("fetchPositions",t),s=s===void 0?"cross":s;const i=this.safeString(this.options,"defaultSubType","inverse");let n;[n,t]=this.handleMarketTypeAndParams("fetchPositions",void 0,t),n==="spot"&&(n="future");let r;i==="linear"?r=this.getSupportedMapping(s,{isolated:"contractPrivatePostLinearSwapApiV1SwapPositionInfo",cross:"contractPrivatePostLinearSwapApiV1SwapCrossPositionInfo"}):r=this.getSupportedMapping(n,{future:"contractPrivatePostApiV1ContractPositionInfo",swap:"contractPrivatePostSwapApiV1SwapPositionInfo"});const a=await this[r](t),o=this.safeValue(a,"data",[]),d=this.safeInteger(a,"ts"),c=[];for(let u=0;u<o.length;u++){const h=o[u],l=this.parsePosition(h);c.push(this.extend(l,{timestamp:d,datetime:this.iso8601(d)}))}return this.filterByArray(c,"symbol",e,!1)}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e);let i;[i,t]=this.handleMarginModeAndParams("fetchPosition",t),i=i===void 0?"cross":i;const[n,r]=this.handleMarketTypeAndParams("fetchPosition",s,t);let a;s.linear?a=this.getSupportedMapping(i,{isolated:"contractPrivatePostLinearSwapApiV1SwapAccountPositionInfo",cross:"contractPrivatePostLinearSwapApiV1SwapCrossAccountPositionInfo"}):a=this.getSupportedMapping(n,{future:"contractPrivatePostApiV1ContractAccountPositionInfo",swap:"contractPrivatePostSwapApiV1SwapAccountPositionInfo"});const o={};s.future&&s.inverse?o.symbol=s.settleId:(i==="cross"&&(o.margin_account="USDT"),o.contract_code=s.id);const d=await this[a](this.extend(o,r)),c=this.safeValue(d,"data");let u;i==="cross"?u=c:u=this.safeValue(c,0);const h=this.omit(u,["positions"]),l=this.safeValue(u,"positions");let p;if(s.future&&s.inverse)for(let y=0;y<l.length;y++){const b=l[y];if(b.contract_code===s.id){p=b;break}}else p=this.safeValue(l,0);const m=this.safeInteger(d,"ts"),g=this.parsePosition(this.extend(p,h));return this.extend(g,{timestamp:m,datetime:this.iso8601(m)})}parseLedgerEntryType(e){const t={trade:"trade",etf:"trade","transact-fee":"fee","fee-deduction":"fee",transfer:"transfer",credit:"credit",liquidation:"trade",interest:"credit",deposit:"deposit",withdraw:"withdrawal","withdraw-fee":"fee",exchange:"exchange","other-types":"transfer",rebate:"rebate"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"transactId"),i=this.safeString(e,"currency"),n=this.safeCurrencyCode(i,t),r=this.safeNumber(e,"transactAmt"),a=this.safeString(e,"transferType"),o=this.parseLedgerEntryType(a),d=this.safeString(e,"direction"),c=this.safeInteger(e,"transactTime"),u=this.iso8601(c),h=this.safeString(e,"accountId");return{id:s,direction:d,account:h,referenceId:s,referenceAccount:h,type:o,currency:n,amount:r,timestamp:c,datetime:u,before:void 0,after:void 0,status:void 0,fee:void 0,info:e}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={accountId:await this.fetchAccountIdByType("spot",i)};let a;e!==void 0&&(a=this.currency(e),r.currency=a.id),t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=s);const o=await this.spotPrivateGetV2AccountLedger(this.extend(r,i)),d=this.safeValue(o,"data",[]);return this.parseLedger(d,a,t,s)}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const s=await this.contractPublicGetLinearSwapApiV1SwapAdjustfactor(t),i=this.safeValue(s,"data");return this.parseLeverageTiers(i,e,"contract_code")}async fetchMarketLeverageTiers(e,t={}){await this.loadMarkets();const s={};if(e!==void 0){const a=this.market(e);if(!a.contract)throw new xi(this.id+" fetchMarketLeverageTiers() symbol supports contract markets only");s.contract_code=a.id}const i=await this.contractPublicGetLinearSwapApiV1SwapAdjustfactor(this.extend(s,t)),n=this.safeValue(i,"data"),r=this.parseLeverageTiers(n,[e],"contract_code");return this.safeValue(r,e)}parseLeverageTiers(e,t=void 0,s=void 0){const i={};for(let n=0;n<e.length;n++){const r=e[n],a=this.safeValue(r,"list",[]),o=[],d=this.safeString(r,"trade_partition"),c=this.safeString(r,s),u=this.safeSymbol(c);if(this.inArray(u,t)){for(let h=0;h<a.length;h++){const l=a[h],p=this.safeString(l,"lever_rate"),m=this.safeValue(l,"ladders",[]);for(let g=0;g<m.length;g++){const y=m[g],b=this.safeString(y,"adjust_factor");o.push({tier:this.safeInteger(y,"ladder"),currency:this.safeCurrencyCode(d),minNotional:this.safeNumber(y,"min_size"),maxNotional:this.safeNumber(y,"max_size"),maintenanceMarginRate:this.parseNumber(di.stringDiv(b,p)),maxLeverage:this.parseNumber(p),info:y})}}i[u]=o}}return i}async fetchOpenInterestHistory(e,t="1h",s=void 0,i=void 0,n={}){if(t!=="1h"&&t!=="4h"&&t!=="12h"&&t!=="1d")throw new xi(this.id+" fetchOpenInterestHistory cannot only use the 1h, 4h, 12h and 1d timeframe");await this.loadMarkets();const r={"1h":"60min","4h":"4hour","12h":"12hour","1d":"1day"},a=this.market(e),o=this.safeNumber2(n,"amount_type","amountType");if(o===void 0)throw new Us(this.id+" fetchOpenInterestHistory requires parameter params.amountType to be either 1 (cont), or 2 (cryptocurrency)");const d={period:r[t],amount_type:o};let c;a.future?(d.contract_type=this.safeString(a.info,"contract_type"),d.symbol=a.baseId,c="contractPublicGetApiV1ContractHisOpenInterest"):a.linear?(d.contract_type="swap",d.contract_code=a.id,d.contract_code=a.id,c="contractPublicGetLinearSwapApiV1SwapHisOpenInterest"):(d.contract_code=a.id,c="contractPublicGetSwapApiV1SwapHisOpenInterest"),i!==void 0&&(d.size=i);const u=await this[c](this.extend(d,n)),h=this.safeValue(u,"data"),l=this.safeValue(h,"tick");return this.parseOpenInterests(l,a,s,i)}async fetchOpenInterest(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.contract)throw new xi(this.id+" fetchOpenInterest() supports contract markets only");if(s.option)throw new _i(this.id+" fetchOpenInterest() does not currently support option markets");const i={contract_code:s.id};let n;s.future?(i.contract_type=this.safeString(s.info,"contract_type"),i.symbol=s.baseId,n="contractPublicGetApiV1ContractOpenInterest"):s.linear?(i.contract_type="swap",n="contractPublicGetLinearSwapApiV1SwapOpenInterest"):n="contractPublicGetSwapApiV1SwapOpenInterest";const r=await this[n](this.extend(i,t)),a=this.safeValue(r,"data",[]),o=this.parseOpenInterest(a[0],s),d=this.safeInteger(r,"ts");return this.extend(o,{timestamp:d,datetime:this.iso8601(d)})}parseOpenInterest(e,t=void 0){const s=this.safeInteger(e,"ts"),i=this.safeNumber(e,"volume"),n=this.safeNumber(e,"value");return{symbol:this.safeString(t,"symbol"),baseVolume:i,quoteVolume:n,openInterestAmount:i,openInterestValue:n,timestamp:s,datetime:this.iso8601(s),info:e}}async borrowMargin(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.currency(e),r={currency:n.id,amount:this.currencyToPrecision(e,t)};let a;[a,i]=this.handleMarginModeAndParams("borrowMargin",i),a=a===void 0?"cross":a;let o;if(a==="isolated"){if(s===void 0)throw new Us(this.id+" borrowMargin() requires a symbol argument for isolated margin");const u=this.market(s);r.symbol=u.id,o="privatePostMarginOrders"}else a==="cross"&&(o="privatePostCrossMarginOrders");const d=await this[o](this.extend(r,i)),c=this.parseMarginLoan(d,n);return this.extend(c,{amount:t,symbol:s})}async repayMargin(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.currency(e);let r;[r,i]=this.handleMarginModeAndParams("repayMargin",i),r=r===void 0?"cross":r;const a=this.safeValue(this.options,"marginAccounts",{}),o=this.getSupportedMapping(r,a),d=await this.fetchAccountIdByType(o,i),c={currency:n.id,amount:this.currencyToPrecision(e,t),accountId:d},u=await this.v2PrivatePostAccountRepayment(this.extend(c,i)),h=this.safeValue(u,"Data",[]),l=this.safeValue(h,0),p=this.parseMarginLoan(l,n);return this.extend(p,{amount:t,symbol:s})}parseMarginLoan(e,t=void 0){const s=this.safeInteger(e,"repayTime");return{id:this.safeInteger2(e,"repayId","data"),currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:s,datetime:this.iso8601(s),info:e}}async fetchSettlementHistory(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeString(i,"code"),r=this.safeInteger2(i,"until","till");i=this.omit(i,["until","till"]);const a=e===void 0?void 0:this.market(e),[o,d]=this.handleMarketTypeAndParams("fetchSettlementHistory",a,i);if(o==="future"){if(e===void 0&&n===void 0)throw new Us(this.id+' requires a symbol argument or params["code"] for fetchSettlementHistory future')}else if(e===void 0)throw new Us(this.id+" requires a symbol argument for fetchSettlementHistory swap");const c={};a.future?c.symbol=a.baseId:c.contract_code=a.id,t!==void 0&&(c.start_at=t),s!==void 0&&(c.page_size=s),r!==void 0&&(c.end_at=r);let u="contractPublicGetApiV1ContractSettlementRecords";a.swap&&(a.linear?u="contractPublicGetLinearSwapApiV1SwapSettlementRecords":u="contractPublicGetSwapApiV1SwapSettlementRecords");const h=await this[u](this.extend(c,d)),l=this.safeValue(h,"data"),p=this.safeValue(l,"settlement_record"),m=this.parseSettlements(p,a);return this.sortBy(m,"timestamp")}parseSettlements(e,t){const s=[];for(let i=0;i<e.length;i++){const n=e[i],r=this.safeValue(n,"list");if(r!==void 0){const a=this.safeInteger(n,"settlement_time"),o={timestamp:a,datetime:this.iso8601(a)};for(let d=0;d<r.length;d++){const c=r[d],u=this.parseSettlement(c,t);s.push(this.extend(u,o))}}else s.push(this.parseSettlement(e[i],t))}return s}parseSettlement(e,t){const s=this.safeInteger(e,"settlement_time"),i=this.safeString(e,"contract_code");return{info:e,symbol:this.safeSymbol(i,t),price:this.safeNumber(e,"settlement_price"),timestamp:s,datetime:this.iso8601(s)}}};const mD=ge,{AuthenticationError:wv,ExchangeError:kv,PermissionDenied:gD,ExchangeNotAvailable:Sv,OnMaintenance:L0,InvalidOrder:$n,OrderNotFound:R0,InsufficientFunds:vv,ArgumentsRequired:yD,BadSymbol:Bc,BadRequest:Kf,RequestTimeout:bD,NetworkError:wD}=de,{TRUNCATE:kD,TICK_SIZE:SD}=me,F0=Se;var Q_=class extends mD{describe(){return this.deepExtend(super.describe(),{id:"huobijp",name:"Huobi Japan",countries:["JP"],rateLimit:100,userAgent:this.userAgents.chrome39,certified:!1,version:"v1",accounts:void 0,accountsById:void 0,hostname:"api-cloud.huobi.co.jp",pro:!0,has:{CORS:void 0,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchAccounts:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingLimits:!0,fetchWithdrawals:!0,withdraw:!0},timeframes:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"60min","4h":"4hour","1d":"1day","1w":"1week","1M":"1mon","1y":"1year"},urls:{logo:"https://user-images.githubusercontent.com/1294454/85734211-85755480-b705-11ea-8b35-0b7f1db33a2f.jpg",api:{market:"https://{hostname}",public:"https://{hostname}",private:"https://{hostname}",v2Public:"https://{hostname}",v2Private:"https://{hostname}"},www:"https://www.huobi.co.jp",referral:"https://www.huobi.co.jp/register/?invite_code=znnq3",doc:"https://api-doc.huobi.co.jp",fees:"https://www.huobi.co.jp/support/fee"},api:{v2Public:{get:{"reference/currencies":1,"market-status":1}},v2Private:{get:{"account/ledger":1,"account/withdraw/quota":1,"account/withdraw/address":1,"account/deposit/address":1,"account/repayment":5,"reference/transact-fee-rate":1,"account/asset-valuation":.2,"point/account":5,"sub-user/user-list":1,"sub-user/user-state":1,"sub-user/account-list":1,"sub-user/deposit-address":1,"sub-user/query-deposit":1,"user/api-key":1,"user/uid":1,"algo-orders/opening":1,"algo-orders/history":1,"algo-orders/specific":1,"c2c/offers":1,"c2c/offer":1,"c2c/transactions":1,"c2c/repayment":1,"c2c/account":1,"etp/reference":1,"etp/transactions":5,"etp/transaction":5,"etp/rebalance":1,"etp/limit":1},post:{"account/transfer":1,"account/repayment":5,"point/transfer":5,"sub-user/management":1,"sub-user/creation":1,"sub-user/tradable-market":1,"sub-user/transferability":1,"sub-user/api-key-generation":1,"sub-user/api-key-modification":1,"sub-user/api-key-deletion":1,"sub-user/deduct-mode":1,"algo-orders":1,"algo-orders/cancel-all-after":1,"algo-orders/cancellation":1,"c2c/offer":1,"c2c/cancellation":1,"c2c/cancel-all":1,"c2c/repayment":1,"c2c/transfer":1,"etp/creation":5,"etp/redemption":5,"etp/{transactId}/cancel":10,"etp/batch-cancel":50}},market:{get:{"history/kline":1,"detail/merged":1,depth:1,trade:1,"history/trade":1,detail:1,tickers:1,etp:1}},public:{get:{"common/symbols":1,"common/currencys":1,"common/timestamp":1,"common/exchange":1,"settings/currencys":1}},private:{get:{"account/accounts":.2,"account/accounts/{id}/balance":.2,"account/accounts/{sub-uid}":1,"account/history":4,"cross-margin/loan-info":1,"margin/loan-info":1,"fee/fee-rate/get":1,"order/openOrders":.4,"order/orders":.4,"order/orders/{id}":.4,"order/orders/{id}/matchresults":.4,"order/orders/getClientOrder":.4,"order/history":1,"order/matchresults":1,"query/deposit-withdraw":1,"margin/loan-orders":.2,"margin/accounts/balance":.2,"cross-margin/loan-orders":1,"cross-margin/accounts/balance":1,"points/actions":1,"points/orders":1,"subuser/aggregate-balance":10,"stable-coin/exchange_rate":1,"stable-coin/quote":1},post:{"account/transfer":1,"futures/transfer":1,"order/batch-orders":.4,"order/orders/place":.2,"order/orders/submitCancelClientOrder":.2,"order/orders/batchCancelOpenOrders":.4,"order/orders/{id}/submitcancel":.2,"order/orders/batchcancel":.4,"dw/withdraw/api/create":1,"dw/withdraw-virtual/{id}/cancel":1,"dw/transfer-in/margin":10,"dw/transfer-out/margin":10,"margin/orders":10,"margin/orders/{id}/repay":10,"cross-margin/transfer-in":1,"cross-margin/transfer-out":1,"cross-margin/orders":1,"cross-margin/orders/{id}/repay":1,"stable-coin/exchange":1,"subuser/transfer":10}}},fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},precisionMode:SD,exceptions:{broad:{"contract is restricted of closing positions on API.  Please contact customer service":L0,maintain:L0},exact:{"bad-request":Kf,"base-date-limit-error":Kf,"api-not-support-temp-addr":gD,timeout:bD,"gateway-internal-error":Sv,"account-frozen-balance-insufficient-error":vv,"invalid-amount":$n,"order-limitorder-amount-min-error":$n,"order-limitorder-amount-max-error":$n,"order-marketorder-amount-min-error":$n,"order-limitorder-price-min-error":$n,"order-limitorder-price-max-error":$n,"order-holding-limit-failed":$n,"order-orderprice-precision-error":$n,"order-etp-nav-price-max-error":$n,"order-orderstate-error":R0,"order-queryorder-invalid":R0,"order-update-error":Sv,"api-signature-check-failed":wv,"api-signature-not-valid":wv,"base-record-invalid":R0,"base-symbol-trade-disabled":Bc,"base-symbol-error":Bc,"system-maintenance":L0,"invalid symbol":Bc,"symbol trade not open now":Bc,"invalid-address":Kf,"base-currency-chain-error":Kf,"dw-insufficient-balance":vv}},options:{defaultNetwork:"ERC20",networks:{ETH:"erc20",TRX:"trc20",HRC20:"hrc20",HECO:"hrc20",HT:"hrc20",ALGO:"algo",OMNI:""},fetchOrdersByStatesMethod:"private_get_order_orders",fetchOpenOrdersMethod:"fetch_open_orders_v1",createMarketBuyOrderRequiresPrice:!0,fetchMarketsMethod:"publicGetCommonSymbols",fetchBalanceMethod:"privateGetAccountAccountsIdBalance",createOrderMethod:"privatePostOrderOrdersPlace",language:"en-US",broker:{id:"AA03022abc"}},commonCurrencies:{GET:"Themis",GTC:"Game.com",HIT:"HitChain",HOT:"Hydro Protocol",PNT:"Penta",SBTC:"Super Bitcoin",BIFI:"Bitcoin File"}})}async fetchTime(e={}){const t=await this.publicGetCommonTimestamp(e);return this.safeInteger(t,"data")}async fetchTradingLimits(e=void 0,t={}){await this.loadMarkets(),e===void 0&&(e=this.symbols);const s={};for(let i=0;i<e.length;i++){const n=e[i];s[n]=await this.fetchTradingLimitsById(this.marketId(n),t)}return s}async fetchTradingLimitsById(e,t={}){const s={symbol:e},i=await this.publicGetCommonExchange(this.extend(s,t));return this.parseTradingLimits(this.safeValue(i,"data",{}))}parseTradingLimits(e,t=void 0,s={}){return{info:e,limits:{amount:{min:this.safeNumber(e,"limit-order-must-greater-than"),max:this.safeNumber(e,"limit-order-must-less-than")}}}}costToPrecision(e,t){return this.decimalToPrecision(t,kD,this.markets[e].precision.cost,this.precisionMode)}async fetchMarkets(e={}){const t=this.options.fetchMarketsMethod,s=await this[t](e),i=this.safeValue(s,"data",[]);if(i.length<1)throw new wD(this.id+" fetchMarkets() returned empty response: "+this.json(i));const r=[];for(let a=0;a<i.length;a++){const o=i[a],d=this.safeString(o,"base-currency"),c=this.safeString(o,"quote-currency"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),l=this.safeString(o,"state"),p=this.safeString(o,"leverage-ratio","1"),m=this.safeString(o,"super-margin-leverage-ratio","1"),g=F0.stringGt(p,"1")||F0.stringGt(m,"1"),y=u==="OMG"?0:.2/100;r.push({id:d+c,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:g,swap:!1,future:!1,option:!1,active:l==="online",contract:!1,linear:void 0,inverse:void 0,taker:y,maker:y,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{price:this.parseNumber(this.parsePrecision(this.safeString(o,"price-precision"))),amount:this.parseNumber(this.parsePrecision(this.safeString(o,"amount-precision"))),cost:this.parseNumber(this.parsePrecision(this.safeString(o,"value-precision")))},limits:{leverage:{min:this.parseNumber("1"),max:this.parseNumber(p),superMax:this.parseNumber(m)},amount:{min:this.safeNumber(o,"min-order-amt"),max:this.safeNumber(o,"max-order-amt")},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(o,"min-order-value"),max:void 0}},info:o})}return r}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeInteger(e,"ts");let n,r,a,o;"bid"in e&&(Array.isArray(e.bid)?(n=this.safeString(e.bid,0),r=this.safeString(e.bid,1)):(n=this.safeString(e,"bid"),r=this.safeString(e,"bidSize"))),"ask"in e&&(Array.isArray(e.ask)?(a=this.safeString(e.ask,0),o=this.safeString(e.ask,1)):(a=this.safeString(e,"ask"),o=this.safeString(e,"askSize")));const d=this.safeString(e,"open"),c=this.safeString(e,"close"),u=this.safeString(e,"amount"),h=this.safeString(e,"vol");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:n,bidVolume:r,ask:a,askVolume:o,vwap:void 0,open:d,close:c,last:c,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:u,quoteVolume:h,info:e},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={symbol:this.market(e).id,type:"step0"},r=await this.marketGetDepth(this.extend(n,s));if("tick"in r){if(!r.tick)throw new Bc(this.id+" fetchOrderBook() returned empty response: "+this.json(r));const a=this.safeValue(r,"tick"),o=this.safeInteger(a,"ts",this.safeInteger(r,"ts")),d=this.parseOrderBook(a,e,o);return d.nonce=this.safeInteger(a,"version"),d}throw new kv(this.id+" fetchOrderBook() returned unrecognized response: "+this.json(r))}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.marketGetDetailMerged(this.extend(i,t)),r=this.parseTicker(n.tick,s),a=this.safeInteger(n,"ts");return r.timestamp=a,r.datetime=this.iso8601(a),r}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.marketGetTickers(t),i=this.safeValue(s,"data",[]),n=this.safeInteger(s,"ts"),r={};for(let a=0;a<i.length;a++){const o=this.safeString(i[a],"symbol"),d=this.safeMarket(o),c=d.symbol,u=this.parseTicker(i[a],d);u.timestamp=n,u.datetime=this.iso8601(n),r[c]=u}return this.filterByArray(r,"symbol",e)}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeInteger2(e,"ts","created-at"),r=this.safeString(e,"order-id");let a=this.safeString(e,"direction"),o=this.safeString(e,"type");if(o!==void 0){const T=o.split("-");a=T[0],o=T[1]}const d=this.safeString(e,"role"),c=this.safeString(e,"price"),u=this.safeString2(e,"filled-amount","amount"),h=this.parseNumber(c),l=this.parseNumber(u),p=this.parseNumber(F0.stringMul(c,u));let m,g=this.safeNumber(e,"filled-fees"),y=this.safeCurrencyCode(this.safeString(e,"fee-currency"));const b=this.safeNumber(e,"filled-points");b!==void 0&&(g===void 0||g===0)&&(g=b,y=this.safeCurrencyCode(this.safeString(e,"fee-deduct-currency"))),g!==void 0&&(m={cost:g,currency:y});const w=this.safeString2(e,"trade-id","tradeId");return{id:this.safeString(e,"id",w),info:e,order:r,timestamp:n,datetime:this.iso8601(n),symbol:i,type:o,side:a,takerOrMaker:d,price:h,amount:l,cost:p,fee:m}}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={id:e},a=await this.privateGetOrderOrdersIdMatchresults(this.extend(r,n));return this.parseTrades(a.data,void 0,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),s!==void 0&&(r.size=s),t!==void 0&&(r["start-time"]=t);const a=await this.privateGetOrderMatchresults(this.extend(r,i));return this.parseTrades(a.data,n,t,s)}async fetchTrades(e,t=void 0,s=1e3,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.size=s);const a=await this.marketGetHistoryTrade(this.extend(r,i)),o=this.safeValue(a,"data",[]);let d=[];for(let c=0;c<o.length;c++){const u=this.safeValue(o[c],"data",[]);for(let h=0;h<u.length;h++){const l=this.parseTrade(u[h],n);d.push(l)}}return d=this.sortBy(d,"timestamp"),this.filterBySymbolSinceLimit(d,n.symbol,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"id"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"amount")]}async fetchOHLCV(e,t="1m",s=void 0,i=1e3,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,period:this.timeframes[t]};i!==void 0&&(a.size=i);const o=await this.marketGetHistoryKline(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseOHLCVs(d,r,t,s,i)}async fetchAccounts(e={}){return await this.loadMarkets(),(await this.privateGetAccountAccounts(e)).data}async fetchCurrencies(e={}){const t={language:this.options.language},s=await this.publicGetSettingsCurrencys(this.extend(t,e)),i=this.safeValue(s,"data",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeValue(a,"name"),d=this.safeCurrencyCode(o),c=this.safeValue(a,"deposit-enabled"),u=this.safeValue(a,"withdraw-enabled"),h=this.safeValue(a,"country-disabled"),l=this.safeValue(a,"visible",!1),p=this.safeString(a,"state"),m=l&&c&&u&&p==="online"&&!h,g=this.safeString(a,"display-name"),y=this.parseNumber(this.parsePrecision(this.safeString(a,"withdraw-precision")));n[d]={id:o,code:d,type:"crypto",name:g,active:m,deposit:c,withdraw:u,fee:void 0,precision:y,limits:{amount:{min:y,max:void 0},deposit:{min:this.safeNumber(a,"deposit-min-amount"),max:void 0},withdraw:{min:this.safeNumber(a,"withdraw-min-amount"),max:void 0}},info:a}}return n}parseBalance(e){const t=this.safeValue(e.data,"list",[]),s={info:e};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r);let o;a in s?o=s[a]:o=this.account(),n.type==="trade"&&(o.free=this.safeString(n,"balance")),n.type==="frozen"&&(o.used=this.safeString(n,"balance")),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets(),await this.loadAccounts();const t=this.options.fetchBalanceMethod,s={id:this.accounts[0].id},i=await this[t](this.extend(s,e));return this.parseBalance(i)}async fetchOrdersByStates(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={states:e};let a;t!==void 0&&(a=this.market(t),r.symbol=a.id);const o=this.safeString(this.options,"fetchOrdersByStatesMethod","private_get_order_orders"),d=await this[o](this.extend(r,n));return this.parseOrders(d.data,a,s,i)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetOrderOrdersId(this.extend(i,s)),r=this.safeValue(n,"data");return this.parseOrder(r)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStates("pre-submitted,submitted,partial-filled,filled,partial-canceled,canceled",e,t,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeString(this.options,"fetchOpenOrdersMethod","fetch_open_orders_v1");return await this[n](e,t,s,i)}async fetchOpenOrdersV1(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new yD(this.id+" fetchOpenOrdersV1() requires a symbol argument");return await this.fetchOrdersByStates("pre-submitted,submitted,partial-filled",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStates("filled,partial-canceled,canceled",e,t,s,i)}async fetchOpenOrdersV2(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id);let a=this.safeString(i,"account-id");if(a===void 0){await this.loadAccounts();for(let u=0;u<this.accounts.length;u++){const h=this.accounts[u];if(h.type==="spot"&&(a=this.safeString(h,"id"),a!==void 0))break}}n["account-id"]=a,s!==void 0&&(n.size=s);const o=this.omit(i,"account-id"),d=await this.privateGetOrderOpenOrders(this.extend(n,o)),c=this.safeValue(d,"data",[]);return this.parseOrders(c,r,t,s)}parseOrderStatus(e){const t={"partial-filled":"open","partial-canceled":"canceled",filled:"closed",canceled:"canceled",submitted:"open"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id");let i,n,r;if("type"in e){const g=e.type.split("-");i=g[0],n=g[1],r=this.parseOrderStatus(this.safeString(e,"state"))}const a=this.safeString(e,"symbol");t=this.safeMarket(a,t);const o=this.safeInteger(e,"created-at"),d=this.safeString(e,"client-order-id"),c=this.safeString(e,"amount"),u=this.safeString2(e,"filled-amount","field-amount"),h=this.safeString(e,"price"),l=this.safeString2(e,"filled-cash-amount","field-cash-amount"),p=this.safeString2(e,"filled-fees","field-fees");let m;if(p!==void 0){const g=i==="sell"?t.quote:t.base;m={cost:p,currency:g}}return this.safeOrder({info:e,id:s,clientOrderId:d,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:void 0,symbol:t.symbol,type:n,timeInForce:void 0,postOnly:void 0,side:i,price:h,stopPrice:void 0,average:void 0,cost:l,amount:c,filled:u,remaining:void 0,status:r,fee:m,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets(),await this.loadAccounts();const a=this.market(e),o={"account-id":this.accounts[0].id,symbol:a.id,type:s+"-"+t},d=this.safeString2(r,"clientOrderId","client-order-id");if(d===void 0){const p=this.safeValue(this.options,"broker",{}),m=this.safeString(p,"id");o["client-order-id"]=m+this.uuid()}else o["client-order-id"]=d;if(r=this.omit(r,["clientOrderId","client-order-id"]),t==="market"&&s==="buy")if(this.options.createMarketBuyOrderRequiresPrice){if(n===void 0)throw new $n(this.id+" market buy order requires price argument to calculate cost (total amount of quote currency to spend for buying, amount * price). To switch off this warning exception and specify cost in the amount argument, set .options['createMarketBuyOrderRequiresPrice'] = false. Make sure you know what you're doing.");o.amount=this.costToPrecision(e,parseFloat(i)*parseFloat(n))}else o.amount=this.costToPrecision(e,i);else o.amount=this.amountToPrecision(e,i);(t==="limit"||t==="ioc"||t==="limit-maker"||t==="stop-limit"||t==="stop-limit-fok")&&(o.price=this.priceToPrecision(e,n));const c=this.options.createOrderMethod,u=await this[c](this.extend(o,r)),h=this.milliseconds(),l=this.safeString(u,"data");return{info:u,id:l,timestamp:h,datetime:this.iso8601(h),lastTradeTimestamp:void 0,status:void 0,symbol:e,type:t,side:s,price:n,amount:i,filled:void 0,remaining:void 0,cost:void 0,trades:void 0,fee:void 0,clientOrderId:void 0,average:void 0}}async cancelOrder(e,t=void 0,s={}){const i=await this.privatePostOrderOrdersIdSubmitcancel({id:e});return this.extend(this.parseOrder(i),{id:e,status:"canceled"})}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue2(s,"clientOrderIds","client-order-ids");s=this.omit(s,["clientOrderIds","client-order-ids"]);const n={};return i===void 0?n["order-ids"]=e:n["client-order-ids"]=i,await this.privatePostOrderOrdersBatchcancel(this.extend(n,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;return e!==void 0&&(i=this.market(e),s.symbol=i.id),await this.privatePostOrderOrdersBatchCancelOpenOrders(this.extend(s,t))}currencyToPrecision(e,t,s=void 0){return this.decimalToPrecision(t,0,this.currencies[e].precision,this.precisionMode)}safeNetwork(e){const t=e.length-1;e[t]==="1"&&(e=e.slice(0,t));const i={};return this.safeString(i,e,e)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"addressTag"),n=this.safeString(e,"currency");t=this.safeCurrency(n,t);const r=this.safeCurrencyCode(n,t),a=this.safeString(e,"chain"),o=this.safeValue(t,"networks",{}),d=this.indexBy(o,"id"),c=this.safeValue(d,a,a),u=this.safeString(c,"network");return this.checkAddress(s),{currency:r,address:s,tag:i,network:u,info:e}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){(s===void 0||s>100)&&(s=100),await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r={type:"deposit",from:0};n!==void 0&&(r.currency=n.id),s!==void 0&&(r.size=s);const a=await this.privateGetQueryDepositWithdraw(this.extend(r,i));return this.parseTransactions(a.data,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){(s===void 0||s>100)&&(s=100),await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r={type:"withdraw",from:0};n!==void 0&&(r.currency=n.id),s!==void 0&&(r.size=s);const a=await this.privateGetQueryDepositWithdraw(this.extend(r,i));return this.parseTransactions(a.data,n,t,s)}parseTransaction(e,t=void 0){const s=this.safeInteger(e,"created-at"),i=this.safeInteger(e,"updated-at"),n=this.safeCurrencyCode(this.safeString(e,"currency"));let r=this.safeString(e,"type");r==="withdraw"&&(r="withdrawal");const a=this.parseTransactionStatus(this.safeString(e,"state")),o=this.safeString(e,"address-tag");let d=this.safeNumber(e,"fee");d!==void 0&&(d=Math.abs(d));const c=this.safeString(e,"address"),u=this.safeStringUpper(e,"chain");return{info:e,id:this.safeString2(e,"id","data"),txid:this.safeString(e,"tx-hash"),timestamp:s,datetime:this.iso8601(s),network:u,address:c,addressTo:void 0,addressFrom:void 0,tag:o,tagTo:void 0,tagFrom:void 0,type:r,amount:this.safeNumber(e,"amount"),currency:n,status:a,updated:i,fee:{currency:n,cost:d,rate:void 0}}}parseTransactionStatus(e){const t={unknown:"failed",confirming:"pending",confirmed:"ok",safe:"ok",orphan:"failed",submitted:"pending",canceled:"canceled",reexamine:"pending",reject:"failed",pass:"pending","wallet-reject":"failed","confirm-error":"failed",repealed:"failed","wallet-transfer":"pending","pre-transfer":"pending"};return this.safeString(t,e,e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets(),this.checkAddress(s);const r=this.currency(e),a={address:s,amount:t,currency:r.id.toLowerCase()};i!==void 0&&(a["addr-tag"]=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeStringLower(o,d,d),d!==void 0&&(d==="erc20"?a.chain=r.id+d:a.chain=d+r.id,n=this.omit(n,"network"));const c=await this.privatePostDwWithdrawApiCreate(this.extend(a,n));return this.parseTransaction(c,r)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/";t==="market"?a+=t:t==="public"||t==="private"?a+=this.version:(t==="v2Public"||t==="v2Private")&&(a+="v2"),a+="/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="private"||t==="v2Private"){this.checkRequiredCredentials();const d=this.ymdhms(this.milliseconds(),"T");let c={SignatureMethod:"HmacSHA256",SignatureVersion:"2",AccessKeyId:this.apiKey,Timestamp:d};s!=="POST"&&(c=this.extend(c,o)),c=this.keysort(c);let u=this.urlencode(c);const h=[s,this.hostname,a,u].join(`
`),l=this.hmac(this.encode(h),this.encode(this.secret),"sha256","base64");u+="&"+this.urlencode({Signature:l}),a+="?"+u,s==="POST"?(r=this.json(o),n={"Content-Type":"application/json"}):n={"Content-Type":"application/x-www-form-urlencoded"}}else Object.keys(i).length&&(a+="?"+this.urlencode(i));return a=this.implodeParams(this.urls.api[t],{hostname:this.hostname})+a,{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&"status"in a&&this.safeString(a,"status")==="error"){const u=this.safeString(a,"err-code"),h=this.id+" "+r;this.throwBroadlyMatchedException(this.exceptions.broad,r,h),this.throwExactlyMatchedException(this.exceptions.exact,u,h);const l=this.safeString(a,"err-msg");throw this.throwExactlyMatchedException(this.exceptions.exact,l,h),new kv(h)}}};const vD=Ab;var TD=class extends vD{describe(){return this.deepExtend(super.describe(),{id:"huobipro",alias:!0,name:"Huobi Pro"})}};const OD=ge,{TICK_SIZE:ID,PAD_WITH_ZERO:Tv,ROUND:xD,TRUNCATE:_D,DECIMAL_PLACES:CD}=me,{InvalidOrder:MD,InsufficientFunds:PD,ExchangeError:AD,ExchangeNotAvailable:BD,DDoSProtection:ED,BadRequest:Ua,NotSupported:ND,InvalidAddress:D0,AuthenticationError:VD}=de,qD=Se;var Z_=class extends OD{describe(){return this.deepExtend(super.describe(),{id:"idex",name:"IDEX",countries:["US"],rateLimit:200,version:"v3",pro:!0,certified:!0,requiresWeb3:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!1,createDepositAddress:!1,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:void 0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:void 0,fetchWithdrawal:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","6h":"6h","1d":"1d"},urls:{test:{MATIC:"https://api-sandbox-matic.idex.io"},logo:"https://user-images.githubusercontent.com/51840849/94481303-2f222100-01e0-11eb-97dd-bc14c5943a86.jpg",api:{MATIC:"https://api-matic.idex.io"},www:"https://idex.io",doc:["https://docs.idex.io/"]},api:{public:{get:{ping:1,time:1,exchange:1,assets:1,markets:1,tickers:1,candles:1,trades:1,orderbook:1}},private:{get:{user:1,wallets:1,balances:1,orders:1,fills:1,deposits:1,withdrawals:1,wsToken:1},post:{wallets:1,orders:1,"orders/test":1,withdrawals:1},delete:{orders:1}}},options:{defaultTimeInForce:"gtc",defaultSelfTradePrevention:"cn",network:"MATIC"},exceptions:{INVALID_ORDER_QUANTITY:MD,INSUFFICIENT_FUNDS:PD,SERVICE_UNAVAILABLE:BD,EXCEEDED_RATE_LIMIT:ED,INVALID_PARAMETER:Ua,WALLET_NOT_ASSOCIATED:D0,INVALID_WALLET_SIGNATURE:VD},requiredCredentials:{walletAddress:!0,privateKey:!0,apiKey:!0,secret:!0},precisionMode:ID,paddingMode:Tv,commonCurrencies:{}})}priceToPrecision(e,t){const s=this.market(e),i=this.safeValue(s,"info",{}),n=this.safeInteger(i,"quoteAssetPrecision");return t=this.decimalToPrecision(t,xD,s.precision.price,this.precisionMode),this.decimalToPrecision(t,_D,n,CD,Tv)}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=await this.publicGetExchange(),i=this.safeNumber(s,"makerFeeRate"),n=this.safeNumber(s,"takerFeeRate"),r=this.safeString(s,"makerTradeMinimum"),a=this.safeString(s,"takerTradeMinimum"),o=this.parseNumber(qD.stringMin(r,a)),d=[];for(let c=0;c<t.length;c++){const u=t[c],h=this.safeString(u,"market"),l=this.safeString(u,"baseAsset"),p=this.safeString(u,"quoteAsset"),m=this.safeCurrencyCode(l),g=this.safeCurrencyCode(p),y=this.parseNumber(this.parsePrecision(this.safeString(u,"baseAssetPrecision"))),b=this.parseNumber(this.parsePrecision(this.safeString(u,"quoteAssetPrecision"))),w=this.safeString(u,"status");let k;g==="ETH"&&(k=o),d.push({id:h,symbol:m+"/"+g,base:m,quote:g,settle:void 0,baseId:l,quoteId:p,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:w!=="inactive",contract:!1,linear:void 0,inverse:void 0,taker:n,maker:i,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:y,price:this.safeNumber(u,"tickSize")},limits:{leverage:{min:void 0,max:void 0},amount:{min:y,max:void 0},price:{min:b,max:void 0},cost:{min:k,max:void 0}},info:u})}return d}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id},n=await this.publicGetTickers(this.extend(i,t)),r=this.safeValue(n,0);return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickers(t);return this.parseTickers(s,e)}parseTicker(e,t=void 0){const s=this.safeString(e,"market");t=this.safeMarket(s,t,"-");const i=t.symbol,n=this.safeInteger(e,"time"),r=this.safeString(e,"close");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:r,last:r,previousClose:void 0,change:void 0,percentage:this.safeString(e,"percentChange"),average:void 0,baseVolume:this.safeString(e,"baseVolume"),quoteVolume:this.safeString(e,"quoteVolume"),info:e},t)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={market:r.id,interval:t};s!==void 0&&(a.start=s),i!==void 0&&(a.limit=i);const o=await this.publicGetCandles(this.extend(a,n));return Array.isArray(o)?this.parseOHLCVs(o,r,t,s,i):[]}parseOHLCV(e,t=void 0){const s=this.safeInteger(e,"start"),i=this.safeNumber(e,"open"),n=this.safeNumber(e,"high"),r=this.safeNumber(e,"low"),a=this.safeNumber(e,"close"),o=this.safeNumber(e,"volume");return[s,i,n,r,a,o]}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market:n.id};t!==void 0&&(r.start=t),s!==void 0&&(r.limit=s);const a=await this.publicGetTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"fillId"),i=this.safeString(e,"price"),n=this.safeString(e,"quantity"),r=this.safeString(e,"quoteQuantity"),a=this.safeInteger(e,"time"),o=this.safeString(e,"market"),d=this.safeSymbol(o,t,"-"),u=this.safeString(e,"makerSide")==="buy"?"sell":"buy",h=this.safeString(e,"side",u),l=this.safeString(e,"liquidity","taker"),p=this.safeString(e,"fee");let m;if(p!==void 0){const y=this.safeString(e,"feeAsset");m={cost:p,currency:this.safeCurrencyCode(y)}}const g=this.safeString(e,"orderId");return this.safeTrade({info:e,timestamp:a,datetime:this.iso8601(a),symbol:d,id:s,order:g,type:"limit",side:h,takerOrMaker:l,price:i,amount:n,cost:r,fee:m},t)}async fetchTradingFees(e={}){this.checkRequiredCredentials(),await this.loadMarkets();const s={nonce:this.uuidv1()};let i;i=await this.privateGetUser(this.extend(s,e));const n=this.safeNumber(i,"makerFeeRate"),r=this.safeNumber(i,"takerFeeRate"),a={};for(let o=0;o<this.symbols.length;o++){const d=this.symbols[o];a[d]={info:i,symbol:d,maker:n,taker:r,percentage:!0,tierBased:!1}}return a}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={market:this.market(e).id,level:2};t!==void 0&&(n.limit=t);const r=await this.publicGetOrderbook(this.extend(n,s)),a=this.safeInteger(r,"sequence");return{symbol:e,timestamp:void 0,datetime:void 0,nonce:a,bids:this.parseSide(r,"bids"),asks:this.parseSide(r,"asks")}}parseSide(e,t){const s=this.safeValue(e,t,[]),i=[];for(let r=0;r<s.length;r++){const a=s[r],o=this.safeNumber(a,0),d=this.safeNumber(a,1),c=this.safeInteger(a,2);i.push([o,d,c])}const n=t==="bids";return this.sortBy(i,0,n)}async fetchCurrencies(e={}){const t=await this.publicGetAssets(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"name"),a=this.safeString(n,"symbol"),o=this.safeCurrencyCode(a),d=this.parseNumber(this.parsePrecision(this.safeString(n,"exchangeDecimals")));s[o]={id:a,code:o,info:n,type:void 0,name:r,active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,precision:d,limits:{amount:{min:d,max:void 0},withdraw:{min:d,max:void 0}}}}return s}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"asset"),r=this.safeCurrencyCode(n),a=this.account();a.total=this.safeString(i,"quantity"),a.free=this.safeString(i,"availableForTrade"),a.used=this.safeString(i,"locked"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){this.checkRequiredCredentials(),await this.loadMarkets();const s={nonce:this.uuidv1(),wallet:this.walletAddress},i=this.extend(s,e);if(i.wallet===void 0)throw new Ua(this.id+' fetchBalance() wallet is undefined, set this.walletAddress or "address" in params');let n;try{n=await this.privateGetBalances(i)}catch(r){if(r instanceof D0){const a=i.wallet;await this.associateWallet(a),n=await this.privateGetBalances(i)}else throw r}return this.parseBalance(n)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){this.checkRequiredCredentials(),await this.loadMarkets();let n;const r={nonce:this.uuidv1(),wallet:this.walletAddress};e!==void 0&&(n=this.market(e),r.market=n.id),t!==void 0&&(r.start=t),s!==void 0&&(r.limit=s);const a=this.extend(r,i);if(a.wallet===void 0)throw new Ua(this.id+' fetchMyTrades() walletAddress is undefined, set this.walletAddress or "address" in params');let o;try{o=await this.privateGetFills(a)}catch(d){if(d instanceof D0){const c=a.wallet;await this.associateWallet(c),o=await this.privateGetFills(a)}else throw d}return this.parseTrades(o,n,t,s)}async fetchOrder(e,t=void 0,s={}){const i={orderId:e};return await this.fetchOrdersHelper(t,void 0,void 0,this.extend(i,s))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={closed:!1};return await this.fetchOrdersHelper(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={closed:!0};return await this.fetchOrdersHelper(e,t,s,this.extend(n,i))}async fetchOrdersHelper(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={nonce:this.uuidv1(),wallet:this.walletAddress};let r;e!==void 0&&(r=this.market(e),n.market=r.id),t!==void 0&&(n.start=t),s!==void 0&&(n.limit=s);const a=await this.privateGetOrders(this.extend(n,i));return Array.isArray(a)?this.parseOrders(a,r,t,s):this.parseOrder(a,r)}parseOrderStatus(e){const t={active:"open",partiallyFilled:"open",rejected:"canceled",filled:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"time"),i=this.safeValue(e,"fills",[]),n=this.safeString(e,"orderId"),r=this.safeString(e,"clientOrderId"),a=this.safeString(e,"market"),o=this.safeString(e,"side"),d=this.safeSymbol(a,t,"-"),c=this.safeString(e,"type"),u=this.safeString(e,"originalQuantity"),h=this.safeString(e,"executedQuantity"),l=this.safeString(e,"avgExecutionPrice"),p=this.safeString(e,"price"),m=this.safeString(e,"status"),g=this.safeStringUpper(e,"timeInForce"),y=this.parseOrderStatus(m);return this.safeOrder({info:e,id:n,clientOrderId:r,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,symbol:d,type:c,timeInForce:g,postOnly:void 0,side:o,price:p,stopPrice:void 0,amount:u,cost:void 0,average:l,filled:h,remaining:void 0,status:y,fee:void 0,trades:i},t)}async associateWallet(e,t={}){const s=this.uuidv1(),i=this.remove0xPrefix(e),n=[this.base16ToBinary(s),this.base16ToBinary(i)],r=this.binaryConcatArray(n),a=this.hash(r,"keccak","hex"),o=this.signMessageString(a,this.privateKey),d={parameters:{nonce:s,wallet:e},signature:o};return await this.privatePostWallets(d)}async createOrder(e,t,s,i,n=void 0,r={}){this.checkRequiredCredentials(),await this.loadMarkets();const a=this.market(e),o=this.uuidv1();let d;const c={stopLoss:3,stopLossLimit:4,takeProfit:5,takeProfitLimit:6};let u;if(t==="stopLossLimit"||t==="takeProfitLimit"||"stopPrice"in r){if(!("stopPrice"in r))throw new Ua(this.id+" createOrder() stopPrice is a required parameter for "+t+"orders");u=this.priceToPrecision(e,r.stopPrice)}const h={limit:1,limitMaker:2};let l;const m=t.toLowerCase().indexOf("limit")>=0;if(t in h)d=h[t],l=this.priceToPrecision(e,n);else if(t in c)d=c[t],l=this.priceToPrecision(e,n);else if(t==="market")d=0;else throw new Ua(this.id+" "+t+" is not a valid order type");let g=0;if("quoteOrderQuantity"in r){if(t!=="market")throw new ND(this.id+" createOrder() quoteOrderQuantity is not supported for "+t+" orders, only supported for market orders");g=1,i=this.safeNumber(r,"quoteOrderQuantity")}const y=s==="buy"?0:1,b=this.remove0xPrefix(this.walletAddress),w=this.safeString(this.options,"network","ETH"),k=this.getSupportedMapping(w,{ETH:1,BSC:2,MATIC:4}),T=this.amountToPrecision(e,i),O={gtc:0,ioc:2,fok:3},x=this.safeString(this.options,"defaultTimeInForce","gtc"),C=this.safeString(r,"timeInForce",x);let E;if(C in O)E=O[C];else{const se=Object.keys(O).join(", ");throw new Ua(this.id+" "+C+" is not a valid timeInForce, please choose one of "+se)}const P={dc:0,co:1,cn:2,cb:3},_=this.safeString(this.options,"defaultSelfTradePrevention","cn"),S=this.safeString(r,"selfTradePrevention",_);let I;if(S in P)I=P[S];else{const se=Object.keys(P).join(", ");throw new Ua(this.id+" "+S+" is not a valid selfTradePrevention, please choose one of "+se)}const v=[this.numberToBE(k,1),this.base16ToBinary(o),this.base16ToBinary(b),this.stringToBinary(this.encode(a.id)),this.numberToBE(d,1),this.numberToBE(y,1),this.stringToBinary(this.encode(T)),this.numberToBE(g,1)];if(m){const J=this.stringToBinary(this.encode(l));v.push(J)}if(t in c){const J=this.stringToBinary(this.encode(u||l));v.push(J)}const N=this.safeString(r,"clientOrderId");N!==void 0&&v.push(this.stringToBinary(this.encode(N)));const q=[this.numberToBE(E,1),this.numberToBE(I,1),this.numberToBE(0,8)],R=this.arrayConcat(v,q),G=this.binaryConcatArray(R),F=this.hash(G,"keccak","hex"),A=this.signMessageString(F,this.privateKey),V={parameters:{nonce:o,market:a.id,side:s,type:t,wallet:this.walletAddress,selfTradePrevention:S},signature:A};t!=="market"&&(V.parameters.timeInForce=C),m&&(V.parameters.price=l),t in c&&(V.parameters.stopPrice=u||l),g===0?V.parameters.quantity=T:V.parameters.quoteOrderQuantity=T,N!==void 0&&(V.parameters.clientOrderId=N);const Q=await this.privatePostOrders(V);return this.parseOrder(Q,a)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkRequiredCredentials(),await this.loadMarkets();const r=this.uuidv1(),a=this.currencyToPrecision(e,t),o=this.currency(e),d=this.remove0xPrefix(this.walletAddress),c=[this.base16ToBinary(r),this.base16ToBinary(d),this.stringToBinary(this.encode(o.id)),this.stringToBinary(this.encode(a)),this.numberToBE(1,1)],u=this.binaryConcatArray(c),h=this.hash(u,"keccak","hex"),l=this.signMessageString(h,this.privateKey),p={parameters:{nonce:r,wallet:s,asset:o.id,quantity:a},signature:l},m=await this.privatePostWithdrawals(p);return this.parseTransaction(m,o)}async cancelAllOrders(e=void 0,t={}){this.checkRequiredCredentials(),await this.loadMarkets();let s;e!==void 0&&(s=this.market(e));const i=this.uuidv1(),n={parameters:{nonce:i,wallet:this.walletAddress}},r=this.remove0xPrefix(this.walletAddress),a=[this.base16ToBinary(i),this.base16ToBinary(r)];s!==void 0&&(a.push(this.stringToBinary(this.encode(s.id))),n.parameters.market=s.id);const o=this.binaryConcatArray(a),d=this.hash(o,"keccak","hex"),c=this.signMessageString(d,this.privateKey);n.signature=c;const u=await this.privateDeleteOrders(this.extend(n,t));return this.parseOrders(u,s)}async cancelOrder(e,t=void 0,s={}){this.checkRequiredCredentials(),await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));const n=this.uuidv1(),r=this.remove0xPrefix(this.walletAddress),a=[this.base16ToBinary(n),this.base16ToBinary(r),this.stringToBinary(this.encode(e))],o=this.binaryConcatArray(a),d=this.hash(o,"keccak","hex"),c=this.signMessageString(d,this.privateKey),u={parameters:{nonce:n,wallet:this.walletAddress,orderId:e},signature:c},h=await this.privateDeleteOrders(this.extend(u,s)),l=this.safeValue(h,0);return this.parseOrder(l,i)}handleErrors(e,t,s,i,n,r,a,o,d){const c=this.safeString(a,"code"),u=this.safeString(a,"message");if(c in this.exceptions){const h=this.exceptions[c];throw new h(this.id+" "+u)}if(c!==void 0)throw new AD(this.id+" "+u)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const n={nonce:this.uuidv1(),wallet:this.walletAddress,depositId:e},r=await this.privateGetDeposits(this.extend(n,s));return this.parseTransaction(r,t)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return i=this.extend({method:"privateGetDeposits"},i),this.fetchTransactionsHelper(e,t,s,i)}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeNumber(t,"serverTime")}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const n={nonce:this.uuidv1(),wallet:this.walletAddress,withdrawalId:e},r=await this.privateGetWithdrawals(this.extend(n,s));return this.parseTransaction(r,t)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return i=this.extend({method:"privateGetWithdrawals"},i),this.fetchTransactionsHelper(e,t,s,i)}async fetchTransactionsHelper(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={nonce:this.uuidv1(),wallet:this.walletAddress};let a;e!==void 0&&(a=this.currency(e),r.asset=a.id),t!==void 0&&(r.start=t),s!==void 0&&(r.limit=s);const o=i.method;i=this.omit(i,"method");const d=await this[o](this.extend(r,i));return this.parseTransactions(d,a,t,s)}parseTransactionStatus(e){const t={mined:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){let s;"depositId"in e?s="deposit":("withdrawId"in e||"withdrawalId"in e)&&(s="withdrawal");let i=this.safeString2(e,"depositId","withdrawId");i=this.safeString(e,"withdrawalId",i);const n=this.safeCurrencyCode(this.safeString(e,"asset"),t),r=this.safeNumber(e,"quantity"),a=this.safeString(e,"txId"),o=this.safeInteger2(e,"txTime","time");let d;"fee"in e&&(d={cost:this.safeNumber(e,"fee"),currency:"ETH"});const c=this.safeString(e,"txStatus"),u=this.parseTransactionStatus(c),h=this.safeInteger(e,"confirmationTime");return{info:e,id:i,txid:a,timestamp:o,datetime:this.iso8601(o),network:void 0,address:void 0,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:s,amount:r,currency:n,status:u,updated:h,fee:d}}calculateRateLimiterCost(e,t,s,i,n={},r={}){const a=this.apiKey!==void 0,o=this.secret!==void 0,d=this.walletAddress!==void 0,c=this.privateKey!==void 0,u=this.safeValue(n,"cost",1);return a&&o&&d&&c?u/2:u}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.safeString(this.options,"network","ETH"),o=this.safeString(this.options,"version","v1");let d=this.urls.api[a]+"/"+o+"/"+e;const u=Object.keys(i).length;let h;if(u>0&&(s==="GET"?(h=this.urlencode(i),d=d+"?"+h):r=this.json(i)),n={"Content-Type":"application/json"},this.apiKey!==void 0&&(n["IDEX-API-Key"]=this.apiKey),t==="private"){let l;s==="GET"?l=h:l=r,n["IDEX-HMAC-Signature"]=this.hmac(this.encode(l),this.encode(this.secret),"sha256","hex")}return{url:d,method:s,body:r,headers:n}}};const LD=ge,{TICK_SIZE:RD}=me,Ov=Se;var FD=class extends LD{describe(){return this.deepExtend(super.describe(),{id:"independentreserve",name:"Independent Reserve",countries:["AU","NZ"],rateLimit:1e3,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},urls:{logo:"https://user-images.githubusercontent.com/51840849/87182090-1e9e9080-c2ec-11ea-8e49-563db9a38f37.jpg",api:{public:"https://api.independentreserve.com/Public",private:"https://api.independentreserve.com/Private"},www:"https://www.independentreserve.com",doc:"https://www.independentreserve.com/API"},api:{public:{get:["GetValidPrimaryCurrencyCodes","GetValidSecondaryCurrencyCodes","GetValidLimitOrderTypes","GetValidMarketOrderTypes","GetValidOrderTypes","GetValidTransactionTypes","GetMarketSummary","GetOrderBook","GetAllOrders","GetTradeHistorySummary","GetRecentTrades","GetFxRates","GetOrderMinimumVolumes","GetCryptoWithdrawalFees"]},private:{post:["GetOpenOrders","GetClosedOrders","GetClosedFilledOrders","GetOrderDetails","GetAccounts","GetTransactions","GetFiatBankAccounts","GetDigitalCurrencyDepositAddress","GetDigitalCurrencyDepositAddresses","GetTrades","GetBrokerageFees","GetDigitalCurrencyWithdrawal","PlaceLimitOrder","PlaceMarketOrder","CancelOrder","SynchDigitalCurrencyDepositAddressWithBlockchain","RequestFiatWithdrawal","WithdrawFiatCurrency","WithdrawDigitalCurrency"]}},fees:{trading:{taker:this.parseNumber("0.005"),maker:this.parseNumber("0.005"),percentage:!0,tierBased:!1}},commonCurrencies:{PLA:"PlayChip"},precisionMode:RD})}async fetchMarkets(e={}){const t=await this.publicGetGetValidPrimaryCurrencyCodes(e),s=await this.publicGetGetValidSecondaryCurrencyCodes(e),i=await this.publicGetGetOrderMinimumVolumes(e),n=[];for(let r=0;r<t.length;r++){const a=t[r],o=this.safeCurrencyCode(a),d=this.safeNumber(i,a);for(let c=0;c<s.length;c++){const u=s[c],h=this.safeCurrencyCode(u),l=a+"/"+u;n.push({id:l,symbol:o+"/"+h,base:o,quote:h,settle:void 0,baseId:a,quoteId:u,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:void 0,price:void 0},limits:{leverage:{min:void 0,max:void 0},amount:{min:d,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:l})}}return n}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"CurrencyCode"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"AvailableBalance"),a.total=this.safeString(i,"TotalBalance"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetAccounts(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={primaryCurrencyCode:i.baseId,secondaryCurrencyCode:i.quoteId},r=await this.publicGetGetOrderBook(this.extend(n,s)),a=this.parse8601(this.safeString(r,"CreatedTimestampUtc"));return this.parseOrderBook(r,i.symbol,a,"BuyOrders","SellOrders","Price","Volume")}parseTicker(e,t=void 0){const s=this.parse8601(this.safeString(e,"CreatedTimestampUtc")),i=this.safeString(e,"PrimaryCurrencyCode"),n=this.safeString(e,"SecondaryCurrencyCode");let r;i!==void 0&&n!==void 0&&(r=i+"/"+n),t=this.safeMarket(r,t,"/");const a=t.symbol,o=this.safeString(e,"LastPrice");return this.safeTicker({symbol:a,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"DayHighestPrice"),low:this.safeString(e,"DayLowestPrice"),bid:this.safeString(e,"CurrentHighestBidPrice"),bidVolume:void 0,ask:this.safeString(e,"CurrentLowestOfferPrice"),askVolume:void 0,vwap:void 0,open:void 0,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeString(e,"DayAvgPrice"),baseVolume:this.safeString(e,"DayVolumeXbtInSecondaryCurrrency"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={primaryCurrencyCode:s.baseId,secondaryCurrencyCode:s.quoteId},n=await this.publicGetGetMarketSummary(this.extend(i,t));return this.parseTicker(n,s)}parseOrder(e,t=void 0){let s;const i=this.safeString(e,"PrimaryCurrencyCode"),n=this.safeString(e,"SecondaryCurrencyCode");let r,a;i!==void 0&&n!==void 0?(r=this.safeCurrencyCode(i),a=this.safeCurrencyCode(n),s=r+"/"+a):t!==void 0&&(s=t.symbol,r=t.base,a=t.quote);let o=this.safeString2(e,"Type","OrderType"),d;o!==void 0&&(o.indexOf("Bid")>=0?d="buy":o.indexOf("Offer")>=0&&(d="sell"),o.indexOf("Market")>=0?o="market":o.indexOf("Limit")>=0&&(o="limit"));const c=this.parse8601(this.safeString(e,"CreatedTimestampUtc")),u=this.safeString(e,"VolumeFilled"),h=this.safeString(e,"FeePercent");let l;return h!==void 0&&u!==void 0&&(l=Ov.stringMul(h,u)),this.safeOrder({info:e,id:this.safeString(e,"OrderGuid"),clientOrderId:void 0,timestamp:c,datetime:this.iso8601(c),lastTradeTimestamp:void 0,symbol:s,type:o,timeInForce:void 0,postOnly:void 0,side:d,price:this.safeString(e,"Price"),stopPrice:void 0,cost:this.safeString(e,"Value"),average:this.safeString(e,"AvgPrice"),amount:this.safeString2(e,"VolumeOrdered","Volume"),filled:u,remaining:this.safeString(e,"Outstanding"),status:this.parseOrderStatus(this.safeString(e,"Status")),fee:{rate:h,cost:l,currency:r},trades:void 0},t)}parseOrderStatus(e){const t={Open:"open",PartiallyFilled:"open",Filled:"closed",PartiallyFilledAndCancelled:"canceled",Cancelled:"canceled",PartiallyFilledAndExpired:"canceled",Expired:"canceled"};return this.safeString(t,e,e)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=await this.privatePostGetOrderDetails(this.extend({orderGuid:e},s));let n;return t!==void 0&&(n=this.market(t)),this.parseOrder(i,n)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.ordered({});let r;e!==void 0&&(r=this.market(e),n.primaryCurrencyCode=r.baseId,n.secondaryCurrencyCode=r.quoteId),s===void 0&&(s=50),n.pageIndex=1,n.pageSize=s;const a=await this.privatePostGetOpenOrders(this.extend(n,i)),o=this.safeValue(a,"Data",[]);return this.parseOrders(o,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.ordered({});let r;e!==void 0&&(r=this.market(e),n.primaryCurrencyCode=r.baseId,n.secondaryCurrencyCode=r.quoteId),s===void 0&&(s=50),n.pageIndex=1,n.pageSize=s;const a=await this.privatePostGetClosedOrders(this.extend(n,i)),o=this.safeValue(a,"Data",[]);return this.parseOrders(o,r,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=50,i={}){await this.loadMarkets();const n=this.safeInteger(i,"pageIndex",1);s===void 0&&(s=50);const r=this.ordered({pageIndex:n,pageSize:s}),a=await this.privatePostGetTrades(this.extend(r,i));let o;return e!==void 0&&(o=this.market(e)),this.parseTrades(a.Data,o,t,s)}parseTrade(e,t=void 0){const s=this.parse8601(e.TradeTimestampUtc),i=this.safeString(e,"TradeGuid"),n=this.safeString(e,"OrderGuid"),r=this.safeString2(e,"Price","SecondaryCurrencyTradePrice"),a=this.safeString2(e,"VolumeTraded","PrimaryCurrencyAmount"),o=this.parseNumber(r),d=this.parseNumber(a),c=this.parseNumber(Ov.stringMul(r,a)),u=this.safeString(e,"PrimaryCurrencyCode"),h=this.safeString(e,"SecondaryCurrencyCode");let l;u!==void 0&&h!==void 0&&(l=u+"/"+h);const p=this.safeSymbol(l,t,"/");let m=this.safeString(e,"OrderType");return m!==void 0&&(m.indexOf("Bid")>=0?m="buy":m.indexOf("Offer")>=0&&(m="sell")),{id:i,info:e,timestamp:s,datetime:this.iso8601(s),symbol:p,order:n,type:void 0,side:m,takerOrMaker:void 0,price:o,amount:d,cost:c,fee:void 0}}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={primaryCurrencyCode:n.baseId,secondaryCurrencyCode:n.quoteId,numberOfRecentTradesToRetrieve:50},a=await this.publicGetGetRecentTrades(this.extend(r,i));return this.parseTrades(a.Trades,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostGetBrokerageFees(e),s={};for(let n=0;n<t.length;n++){const r=t[n],a=this.safeString(r,"CurrencyCode"),o=this.safeCurrencyCode(a),d=this.safeNumber(r,"Fee");s[o]={info:r,fee:d}}const i={};for(let n=0;n<this.symbols.length;n++){const r=this.symbols[n],a=this.market(r),o=this.safeValue(s,a.base,{});i[r]={info:this.safeValue(o,"info"),symbol:r,maker:this.safeNumber(o,"fee"),taker:this.safeNumber(o,"fee"),percentage:!0,tierBased:!0}}return i}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.capitalize(t),d="privatePostPlace"+o+"Order";let c=o;c+=s==="sell"?"Offer":"Bid";const u=this.ordered({primaryCurrencyCode:a.baseId,secondaryCurrencyCode:a.quoteId,orderType:c});t==="limit"&&(u.price=n),u.volume=i;const h=await this[d](this.extend(u,r));return{info:h,id:h.OrderGuid}}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderGuid:e};return await this.privatePostCancelOrder(this.extend(i,s))}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/"+e;if(t==="public")Object.keys(i).length&&(a+="?"+this.urlencode(i));else{this.checkRequiredCredentials();const o=this.nonce(),d=[a,"apiKey="+this.apiKey,"nonce="+o.toString()],c=Object.keys(i);for(let p=0;p<c.length;p++){const m=c[p],g=i[m].toString();d.push(m+"="+g)}const u=d.join(","),h=this.hmac(this.encode(u),this.encode(this.secret)),l=this.ordered({});l.apiKey=this.apiKey,l.nonce=o,l.signature=h.toUpperCase();for(let p=0;p<c.length;p++){const m=c[p];l[m]=i[m]}r=this.json(l),n={"Content-Type":"application/json"}}return{url:a,method:s,body:r,headers:n}}};const DD=ge,{ExchangeError:H0,ArgumentsRequired:Xf,InsufficientFunds:HD,InvalidOrder:Iv,OrderNotFound:GD,AuthenticationError:xv,BadSymbol:UD}=de,{TICK_SIZE:$D}=me;var jD=class extends DD{describe(){return this.deepExtend(super.describe(),{id:"indodax",name:"INDODAX",countries:["ID"],rateLimit:100,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!1,cancelOrder:!0,cancelOrders:!1,createDepositAddress:!1,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchDeposit:!1,fetchDeposits:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:void 0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:void 0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:void 0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFee:!0,fetchTransactionFees:!1,fetchTransactions:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!1,reduceMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},version:"2.0",urls:{logo:"https://user-images.githubusercontent.com/51840849/87070508-9358c880-c221-11ea-8dc5-5391afbbb422.jpg",api:{public:"https://indodax.com/api",private:"https://indodax.com/tapi"},www:"https://www.indodax.com",doc:"https://github.com/btcid/indodax-official-api-docs",referral:"https://indodax.com/ref/testbitcoincoid/1"},api:{public:{get:{server_time:5,pairs:5,price_increments:5,summaries:5,ticker_all:5,"{pair}/ticker":5,"{pair}/trades":5,"{pair}/depth":5}},private:{post:{getInfo:4,transHistory:4,trade:1,tradeHistory:4,openOrders:4,orderHistory:4,getOrder:4,cancelOrder:4,withdrawFee:4,withdrawCoin:4,listDownline:4,checkDownline:4,createVoucher:4}}},fees:{trading:{tierBased:!1,percentage:!0,maker:0,taker:.003}},exceptions:{exact:{invalid_pair:UD,"Insufficient balance.":HD,"invalid order.":GD,"Invalid credentials. API not found or session has expired.":xv,"Invalid credentials. Bad sign.":xv},broad:{"Minimum price":Iv,"Minimum order":Iv}},options:{recvWindow:5*1e3,timeDifference:0,adjustForTimeDifference:!1},commonCurrencies:{STR:"XLM",BCHABC:"BCH",BCHSV:"BSV",DRK:"DASH",NEM:"XEM"},precisionMode:$D})}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchTime(e={}){const t=await this.publicGetServerTime(e);return this.safeInteger(t,"server_time")}async fetchMarkets(e={}){const t=await this.publicGetPairs(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"ticker_id"),a=this.safeString(n,"traded_currency"),o=this.safeString(n,"base_currency"),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o),u=this.safeInteger(n,"is_maintenance");s.push({id:r,symbol:d+"/"+c,base:d,quote:c,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!u,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(n,"trade_fee_percent"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,percentage:!0,precision:{amount:this.parseNumber(this.parsePrecision("8")),price:this.parseNumber(this.parsePrecision(this.safeString(n,"price_round"))),cost:this.parseNumber(this.parsePrecision(this.safeString(n,"volume_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(n,"trade_min_traded_currency"),max:void 0},price:{min:this.safeNumber(n,"trade_min_base_currency"),max:void 0},cost:{min:void 0,max:void 0}},info:n})}return s}parseBalance(e){const t=this.safeValue(e,"return",{}),s=this.safeValue(t,"balance",{}),i=this.safeValue(t,"balance_hold",{}),n=this.safeTimestamp(t,"server_time"),r={info:e,timestamp:n,datetime:this.iso8601(n)},a=Object.keys(s);for(let o=0;o<a.length;o++){const d=a[o],c=this.safeCurrencyCode(d),u=this.account();u.free=this.safeString(s,d),u.used=this.safeString(i,d),r[c]=u}return this.safeBalance(r)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetInfo(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id},r=await this.publicGetPairDepth(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"buy","sell")}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeTimestamp(e,"server_time"),n="vol_"+t.baseId.toLowerCase(),r="vol_"+t.quoteId.toLowerCase(),a=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,n),quoteVolume:this.safeString(e,r),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetPairTicker(this.extend(i,t)),r=this.safeValue(n,"ticker",{});return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickerAll(t),i=this.safeValue(s,"tickers");return this.parseTickers(i,e)}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"date");return this.safeTrade({id:this.safeString(e,"tid"),info:e,timestamp:s,datetime:this.iso8601(s),symbol:this.safeSymbol(void 0,t),type:void 0,side:this.safeString(e,"type"),order:void 0,takerOrMaker:void 0,price:this.safeString(e,"price"),amount:this.safeString(e,"amount"),cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id},a=await this.publicGetPairTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseOrderStatus(e){const t={open:"open",filled:"closed",cancelled:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){let s;"type"in e&&(s=e.type);const i=this.parseOrderStatus(this.safeString(e,"status","open"));let n,r;const a=this.safeString(e,"price");let o,d;if(t!==void 0){n=t.symbol;let l=t.quoteId,p=t.baseId;t.quoteId==="idr"&&"order_rp"in e&&(l="rp"),t.baseId==="idr"&&"remain_rp"in e&&(p="rp"),r=this.safeString(e,"order_"+l),r||(o=this.safeString(e,"order_"+p),d=this.safeString(e,"remain_"+p))}const c=this.safeInteger(e,"submit_time"),u=void 0,h=this.safeString(e,"order_id");return this.safeOrder({info:e,id:h,clientOrderId:void 0,timestamp:c,datetime:this.iso8601(c),lastTradeTimestamp:void 0,symbol:n,type:"limit",timeInForce:void 0,postOnly:void 0,side:s,price:a,stopPrice:void 0,cost:r,average:void 0,amount:o,filled:void 0,remaining:d,status:i,fee:u,trades:void 0})}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Xf(this.id+" fetchOrder() requires a symbol");await this.loadMarkets();const i=this.market(t),n={pair:i.id,order_id:e},r=await this.privatePostGetOrder(this.extend(n,s)),a=r.return,o=this.parseOrder(this.extend({id:e},a.order),i);return this.extend({info:r},o)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.pair=n.id);const o=(await this.privatePostOpenOrders(this.extend(r,i))).return.orders;if(!o)return[];if(e!==void 0)return this.parseOrders(o,n,t,s);const d=Object.keys(o);let c=[];for(let u=0;u<d.length;u++){const h=d[u],l=o[h];n=this.markets_by_id[h];const p=this.parseOrders(l,n,t,s);c=this.arrayConcat(c,p)}return c}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Xf(this.id+" fetchClosedOrders() requires a symbol argument");await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),e=r.symbol,n.pair=r.id);const a=await this.privatePostOrderHistory(this.extend(n,i));let o=this.parseOrders(a.return.orders,r);return o=this.filterBy(o,"status","closed"),this.filterBySymbolSinceLimit(o,e,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){if(t!=="limit")throw new H0(this.id+" createOrder() allows limit orders only");await this.loadMarkets();const a=this.market(e),o={pair:a.id,type:s,price:n},d=a.baseId;s==="buy"?o[a.quoteId]=i*n:o[a.baseId]=i,o[d]=i;const c=await this.privatePostTrade(this.extend(o,r)),u=this.safeValue(c,"return",{}),h=this.safeString(u,"order_id");return{info:c,id:h}}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Xf(this.id+" cancelOrder() requires a symbol argument");const i=this.safeValue(s,"side");if(i===void 0)throw new Xf(this.id+' cancelOrder() requires an extra "side" param');await this.loadMarkets();const n=this.market(t),r={order_id:e,pair:n.id,type:i};return await this.privatePostCancelOrder(this.extend(r,s))}async fetchTransactionFee(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=await this.privatePostWithdrawFee(this.extend(i,t)),r=this.safeValue(n,"return",{}),a=this.safeString(r,"currency");return{info:n,rate:this.safeNumber(r,"withdraw_fee"),currency:this.safeCurrencyCode(a,s)}}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};if(t!==void 0){const h=this.iso8601(t).slice(0,10);n.start=h,n.end=this.iso8601(this.milliseconds()).slice(0,10)}const r=await this.privatePostTransHistory(this.extend(n,i)),a=this.safeValue(r,"return",{}),o=this.safeValue(a,"withdraw",{}),d=this.safeValue(a,"deposit",{});let c=[],u;if(e===void 0){let h=Object.keys(o);for(let l=0;l<h.length;l++){const p=h[l];c=this.arrayConcat(c,o[p])}h=Object.keys(d);for(let l=0;l<h.length;l++){const p=h[l];c=this.arrayConcat(c,d[p])}}else{u=this.currency(e);const h=this.safeValue(o,u.id,[]),l=this.safeValue(d,u.id,[]);c=this.arrayConcat(h,l)}return this.parseTransactions(c,u,t,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a=this.milliseconds(),o={currency:r.id,withdraw_amount:t,withdraw_address:s,request_id:a.toString()};i&&(o.withdraw_memo=i);const d=await this.privatePostWithdrawCoin(this.extend(o,n));return this.parseTransaction(d,r)}parseTransaction(e,t=void 0){const s=this.safeString(e,"status"),i=this.safeTimestamp2(e,"success_time","submit_time"),n=this.safeString(e,"deposit_id"),r=this.safeNumber(e,"fee");let a;return r!==void 0&&(a={currency:this.safeCurrencyCode(void 0,t),cost:r}),{id:this.safeString2(e,"withdraw_id","deposit_id"),txid:this.safeString2(e,"txid","tx"),timestamp:i,datetime:this.iso8601(i),network:void 0,addressFrom:void 0,address:this.safeString(e,"withdraw_address"),addressTo:void 0,amount:this.safeNumberN(e,["amount","withdraw_amount","deposit_amount"]),type:n===void 0?"withdraw":"deposit",currency:this.safeCurrencyCode(void 0,t),status:this.parseTransactionStatus(s),updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:this.safeString(e,"withdraw_memo"),fee:a,info:e}}parseTransactionStatus(e){const t={success:"ok"};return this.safeString(t,e,e)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t];return t==="public"?a+="/"+this.implodeParams(e,i):(this.checkRequiredCredentials(),r=this.urlencode(this.extend({method:e,timestamp:this.nonce(),recvWindow:this.options.recvWindow},i)),n={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:this.hmac(this.encode(r),this.encode(this.secret),"sha512")}),{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0||Array.isArray(a))return;const c=this.safeValue(a,"error","");if(!("success"in a)&&c==="")return;if(this.safeInteger(a,"success",0)===1){if("return"in a)return;throw new H0(this.id+": malformed response: "+this.json(a))}const u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u),new H0(u)}};const WD=ge,{ExchangeError:sa,AuthenticationError:zD,ArgumentsRequired:KD}=de,{TICK_SIZE:XD}=me,_v=Se;var YD=class extends WD{describe(){return this.deepExtend(super.describe(),{id:"itbit",name:"itBit",countries:["US"],rateLimit:2e3,version:"v1",has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactions:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/27822159-66153620-60ad-11e7-89e7-005f6d7f3de0.jpg",api:{rest:"https://api.itbit.com"},www:"https://www.itbit.com",doc:["https://api.itbit.com/docs","https://www.itbit.com/api"]},api:{public:{get:["markets/{symbol}/ticker","markets/{symbol}/order_book","markets/{symbol}/trades"]},private:{get:["wallets","wallets/{walletId}","wallets/{walletId}/balances/{currencyCode}","wallets/{walletId}/funding_history","wallets/{walletId}/trades","wallets/{walletId}/orders","wallets/{walletId}/orders/{id}"],post:["wallet_transfers","wallets","wallets/{walletId}/cryptocurrency_deposits","wallets/{walletId}/cryptocurrency_withdrawals","wallets/{walletId}/orders","wire_withdrawal"],delete:["wallets/{walletId}/orders/{id}"]}},markets:{"BTC/USD":{id:"XBTUSD",symbol:"BTC/USD",base:"BTC",quote:"USD",baseId:"XBT",quoteId:"USD",type:"spot",spot:!0},"BTC/SGD":{id:"XBTSGD",symbol:"BTC/SGD",base:"BTC",quote:"SGD",baseId:"XBT",quoteId:"SGD",type:"spot",spot:!0},"BTC/EUR":{id:"XBTEUR",symbol:"BTC/EUR",base:"BTC",quote:"EUR",baseId:"XBT",quoteId:"EUR",type:"spot",spot:!0},"ETH/USD":{id:"ETHUSD",symbol:"ETH/USD",base:"ETH",quote:"USD",baseId:"ETH",quoteId:"USD",type:"spot",spot:!0},"ETH/EUR":{id:"ETHEUR",symbol:"ETH/EUR",base:"ETH",quote:"EUR",baseId:"ETH",quoteId:"EUR",type:"spot",spot:!0},"ETH/SGD":{id:"ETHSGD",symbol:"ETH/SGD",base:"ETH",quote:"SGD",baseId:"ETH",quoteId:"SGD",type:"spot",spot:!0},PAXGUSD:{id:"PAXGUSD",symbol:"PAXG/USD",base:"PAXG",quote:"USD",baseId:"PAXG",quoteId:"USD",type:"spot",spot:!0},BCHUSD:{id:"BCHUSD",symbol:"BCH/USD",base:"BCH",quote:"USD",baseId:"BCH",quoteId:"USD",type:"spot",spot:!0},LTCUSD:{id:"LTCUSD",symbol:"LTC/USD",base:"LTC",quote:"USD",baseId:"LTC",quoteId:"USD",type:"spot",spot:!0}},fees:{trading:{maker:this.parseNumber("-0.0003"),taker:this.parseNumber("0.0035")}},commonCurrencies:{XBT:"BTC"},precisionMode:XD})}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id},r=await this.publicGetMarketsSymbolOrderBook(this.extend(n,s));return this.parseOrderBook(r,i.symbol)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeString(e,"serverTimeUTC");if(!i)throw new sa(this.id+" fetchTicker() returned a bad response: "+this.json(e));const n=this.parse8601(i),r=this.safeString(e,"vwap24h"),a=this.safeString(e,"volume24h"),o=_v.stringMul(a,r),d=this.safeString(e,"lastPrice");return this.safeTicker({symbol:s,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high24h"),low:this.safeString(e,"low24h"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:r,open:this.safeString(e,"openToday"),close:d,last:d,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:a,quoteVolume:o,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetMarketsSymbolTicker(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){const s=this.safeString2(e,"executionId","matchNumber"),i=this.parse8601(this.safeString(e,"timestamp")),n=this.safeString(e,"direction"),r=this.safeString(e,"orderId");let a=this.safeNumber(e,"commissionPaid");const o=this.safeString(e,"commissionCurrency"),d=this.safeCurrencyCode(o);let c=this.safeNumber(e,"rebatesApplied");c!==void 0&&(c=-c);const u=this.safeString(e,"rebateCurrency"),h=this.safeCurrencyCode(u),l=this.safeString2(e,"price","rate"),p=this.safeString2(e,"currency1Amount","amount"),m=this.parseNumber(l),g=this.parseNumber(p),y=this.parseNumber(_v.stringMul(l,p));let b;if(this.safeString(e,"instrument")!==void 0){const T=this.safeString(e,"currency1"),O=this.safeString(e,"currency2"),x=this.safeCurrencyCode(T),C=this.safeCurrencyCode(O);b=x+"/"+C}const k={info:e,id:s,timestamp:i,datetime:this.iso8601(i),symbol:b,order:r,type:void 0,side:n,takerOrMaker:void 0,price:m,amount:g,cost:y,fee:void 0};return a!==void 0&&(c!==void 0?d===h?(a=this.sum(a,c),k.fee={cost:a,currency:d}):k.fees=[{cost:a,currency:d},{cost:c,currency:h}]:k.fee={cost:a,currency:d}),"fee"in k||"fees"in k||(k.fee=void 0),k}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeString(i,"walletId");if(n===void 0)throw new KD(this.id+" fetchTransactions() requires a walletId parameter");const r={walletId:n};s!==void 0&&(r.perPage=s);const o=(await this.privateGetWalletsWalletIdFundingHistory(this.extend(r,i))).fundingHistory,d=[];for(let c=0;c<o.length;c++){const u=o[c],h=this.safeString(u,"time"),l=this.parse8601(h),p=this.safeString(u,"currency"),m=this.safeString(u,"destinationAddress"),g=this.safeString(u,"txnHash"),y=this.safeStringLower(u,"transactionType"),b=this.safeString(u,"status"),w=this.parseTransferStatus(b);d.push({id:this.safeString(u,"withdrawalId"),timestamp:l,datetime:this.iso8601(l),currency:this.safeCurrencyCode(p),address:m,tag:void 0,txid:g,type:y,status:w,amount:this.safeNumber(u,"amount"),fee:void 0,info:u})}return d}parseTransferStatus(e){const t={cancelled:"canceled",completed:"ok"};return this.safeString(t,e,"pending")}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeString(i,"walletId");if(n===void 0)throw new sa(this.id+" fetchMyTrades() requires a walletId parameter");const r={walletId:n};t!==void 0&&(r.rangeStart=this.ymdhms(t,"T")),s!==void 0&&(r.perPage=s);const a=await this.privateGetWalletsWalletIdTrades(this.extend(r,i)),o=this.safeValue(a,"tradingHistory",[]);let d;return e!==void 0&&(d=this.market(e)),this.parseTrades(o,d,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.publicGetMarketsSymbolTrades(this.extend(r,i)),o=this.safeValue(a,"recentTrades",[]);return this.parseTrades(o,n,t,s)}parseBalance(e){const t=e[0].balances,s={info:e};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(n,"availableBalance"),o.total=this.safeString(n,"totalBalance"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.fetchWallets(e);return this.parseBalance(t)}async fetchWallets(e={}){if(await this.loadMarkets(),!this.uid)throw new zD(this.id+" fetchWallets() requires uid API credential");const t={userId:this.uid};return await this.privateGetWallets(this.extend(t,e))}async fetchWallet(e,t={}){await this.loadMarkets();const s={walletId:e};return await this.privateGetWalletsWalletId(this.extend(s,t))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"open"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"filled"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;if(e!==void 0&&(n=this.market(e)),!("walletId"in i))throw new sa(this.id+" fetchOrders() requires a walletId parameter");const o={walletId:i.walletId},d=await this.privateGetWalletsWalletIdOrders(this.extend(o,i));return this.parseOrders(d,n,t,s)}parseOrderStatus(e){const t={submitted:"open",open:"open",filled:"closed",cancelled:"canceled",rejected:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"side"),i=this.safeString(e,"type"),n=this.safeString(e,"instrument"),r=this.safeSymbol(n,t),a=this.safeString(e,"createdTime"),o=this.parse8601(a),d=this.safeString(e,"amount"),c=this.safeString(e,"amountFilled"),u=void 0,h=this.safeString(e,"price"),l=this.safeString(e,"volumeWeightedAveragePrice"),p=this.safeString(e,"clientOrderIdentifier"),m=this.safeString(e,"id"),y=this.safeString(e,"postOnly")==="True";return this.safeOrder({id:m,clientOrderId:p,info:e,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:void 0,status:this.parseOrderStatus(this.safeString(e,"status")),symbol:r,type:i,timeInForce:void 0,postOnly:y,side:s,price:h,stopPrice:void 0,cost:void 0,average:l,amount:d,filled:c,remaining:void 0,fee:u,trades:void 0},t)}nonce(){return this.milliseconds()}async createOrder(e,t,s,i,n=void 0,r={}){if(await this.loadMarkets(),t==="market")throw new sa(this.id+" createOrder() allows limit orders only");if(!("walletId"in r))throw new sa(this.id+" createOrder() requires a walletId parameter");i=i.toString(),n=n.toString();const o=this.market(e),d={side:s,type:t,currency:o.id.replace(o.quote,""),amount:i,display:i,price:n,instrument:o.id},c=await this.privatePostWalletsWalletIdOrders(this.extend(d,r));return{info:c,id:c.id}}async fetchOrder(e,t=void 0,s={}){if(await this.loadMarkets(),!("walletId"in s))throw new sa(this.id+" fetchOrder() requires a walletId parameter");const n={id:e},r=await this.privateGetWalletsWalletIdOrdersId(this.extend(n,s));return this.parseOrder(r)}async cancelOrder(e,t=void 0,s={}){if(!("walletId"in s))throw new sa(this.id+" cancelOrder() requires a walletId parameter");const n={id:e};return await this.privateDeleteWalletsWalletIdOrdersId(this.extend(n,s))}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(s==="GET"&&Object.keys(o).length&&(a+="?"+this.urlencode(o)),s==="POST"&&Object.keys(o).length&&(r=this.json(o)),t==="private"){this.checkRequiredCredentials();const d=this.nonce().toString(),c=d,h=[s,a,s==="POST"?r:"",d,c],l=d+this.json(h).replace("\\/","/"),p=this.hash(this.encode(l),"sha256","binary"),m=this.stringToBinary(this.encode(a)),g=this.binaryConcat(m,p),y=this.hmac(g,this.encode(this.secret),"sha512","base64");n={Authorization:this.apiKey+":"+y,"Content-Type":"application/json","X-Auth-Timestamp":c,"X-Auth-Nonce":d}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;if(this.safeString(a,"code")!==void 0)throw new sa(this.id+" "+this.json(a))}};const QD=ge,{BadSymbol:G0,BadRequest:Cv,ExchangeNotAvailable:Ec,ArgumentsRequired:Nc,PermissionDenied:ZD,AuthenticationError:Mv,ExchangeError:Vc,OrderNotFound:Pv,DDoSProtection:Yf,InvalidNonce:Av,InsufficientFunds:Bv,CancelPending:JD,InvalidOrder:Qf,InvalidAddress:Ev,RateLimitExceeded:eH,OnMaintenance:tH,AccountSuspended:sH}=de,{TRUNCATE:iH,TICK_SIZE:nH}=me,$a=Se;var J_=class extends QD{describe(){return this.deepExtend(super.describe(),{id:"kraken",name:"Kraken",countries:["US"],version:"0",rateLimit:1e3,certified:!1,pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createDepositAddress:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchBorrowInterest:!1,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLedgerEntry:!0,fetchLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderTrades:"emulated",fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchWithdrawals:!0,setLeverage:!1,setMarginMode:!1,withdraw:!0},marketsByAltname:{},timeframes:{"1m":1,"5m":5,"15m":15,"30m":30,"1h":60,"4h":240,"1d":1440,"1w":10080,"2w":21600},urls:{logo:"https://user-images.githubusercontent.com/51840849/76173629-fc67fb00-61b1-11ea-84fe-f2de582f58a3.jpg",api:{public:"https://api.kraken.com",private:"https://api.kraken.com",zendesk:"https://kraken.zendesk.com/api/v2/help_center/en-us/articles"},www:"https://www.kraken.com",doc:"https://www.kraken.com/features/api",fees:"https://www.kraken.com/en-us/features/fee-schedule"},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0026"),maker:this.parseNumber("0.0016"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.0026")],[this.parseNumber("50000"),this.parseNumber("0.0024")],[this.parseNumber("100000"),this.parseNumber("0.0022")],[this.parseNumber("250000"),this.parseNumber("0.0020")],[this.parseNumber("500000"),this.parseNumber("0.0018")],[this.parseNumber("1000000"),this.parseNumber("0.0016")],[this.parseNumber("2500000"),this.parseNumber("0.0014")],[this.parseNumber("5000000"),this.parseNumber("0.0012")],[this.parseNumber("10000000"),this.parseNumber("0.0001")]],maker:[[this.parseNumber("0"),this.parseNumber("0.0016")],[this.parseNumber("50000"),this.parseNumber("0.0014")],[this.parseNumber("100000"),this.parseNumber("0.0012")],[this.parseNumber("250000"),this.parseNumber("0.0010")],[this.parseNumber("500000"),this.parseNumber("0.0008")],[this.parseNumber("1000000"),this.parseNumber("0.0006")],[this.parseNumber("2500000"),this.parseNumber("0.0004")],[this.parseNumber("5000000"),this.parseNumber("0.0002")],[this.parseNumber("10000000"),this.parseNumber("0.0")]]}}},handleContentTypeApplicationZip:!0,api:{zendesk:{get:["360000292886","201893608"]},public:{get:{Assets:1,AssetPairs:1,Depth:1,OHLC:1,Spread:1,Ticker:1,Time:1,Trades:1}},private:{post:{AddOrder:0,AddExport:3,Balance:3,CancelAll:3,CancelOrder:0,CancelOrderBatch:0,ClosedOrders:6,DepositAddresses:3,DepositMethods:3,DepositStatus:3,ExportStatus:3,GetWebSocketsToken:3,Ledgers:6,OpenOrders:3,OpenPositions:3,QueryLedgers:3,QueryOrders:3,QueryTrades:3,RetrieveExport:3,RemoveExport:3,TradeBalance:3,TradesHistory:6,TradeVolume:3,Withdraw:3,WithdrawCancel:3,WithdrawInfo:3,WithdrawStatus:3,Stake:3,Unstake:3,"Staking/Assets":3,"Staking/Pending":3,"Staking/Transactions":3}}},commonCurrencies:{LUNA:"LUNC",LUNA2:"LUNA",REPV2:"REP",REP:"REPV1",UST:"USTC",XBT:"BTC","XBT.M":"BTC.M",XDG:"DOGE"},options:{delistedMarketsById:{},inactiveCurrencies:["CAD","USD","JPY","GBP"],networks:{ETH:"ERC20",TRX:"TRC20"},depositMethods:{"1INCH":"1inch (1INCH)",AAVE:"Aave",ADA:"ADA",ALGO:"Algorand",ANKR:"ANKR (ANKR)",ANT:"Aragon (ANT)",ATOM:"Cosmos",AXS:"Axie Infinity Shards (AXS)",BADGER:"Bager DAO (BADGER)",BAL:"Balancer (BAL)",BAND:"Band Protocol (BAND)",BAT:"BAT",BCH:"Bitcoin Cash",BNC:"Bifrost (BNC)",BNT:"Bancor (BNT)",BTC:"Bitcoin",CHZ:"Chiliz (CHZ)",COMP:"Compound (COMP)",CQT:"	Covalent Query Token (CQT)",CRV:"Curve DAO Token (CRV)",CTSI:"Cartesi (CTSI)",DAI:"Dai",DASH:"Dash",DOGE:"Dogecoin",DOT:"Polkadot",DYDX:"dYdX (DYDX)",ENJ:"Enjin Coin (ENJ)",EOS:"EOS",ETC:"Ether Classic (Hex)",ETH:"Ether (Hex)",EWT:"Energy Web Token",FEE:"Kraken Fee Credit",FIL:"Filecoin",FLOW:"Flow",GHST:"Aavegotchi (GHST)",GNO:"GNO",GRT:"GRT",ICX:"Icon",INJ:"Injective Protocol (INJ)",KAR:"Karura (KAR)",KAVA:"Kava",KEEP:"Keep Token (KEEP)",KNC:"Kyber Network (KNC)",KSM:"Kusama",LINK:"Link",LPT:"Livepeer Token (LPT)",LRC:"Loopring (LRC)",LSK:"Lisk",LTC:"Litecoin",MANA:"MANA",MATIC:"Polygon (MATIC)",MINA:"Mina",MIR:"Mirror Protocol (MIR)",MKR:"Maker (MKR)",MLN:"MLN",MOVR:"Moonriver (MOVR)",NANO:"NANO",OCEAN:"OCEAN",OGN:"Origin Protocol (OGN)",OMG:"OMG",OXT:"Orchid (OXT)",OXY:"Oxygen (OXY)",PAXG:"PAX (Gold)",PERP:"Perpetual Protocol (PERP)",PHA:"Phala (PHA)",QTUM:"QTUM",RARI:"Rarible (RARI)",RAY:"Raydium (RAY)",REN:"Ren Protocol (REN)",REP:"REPv2",REPV1:"REP",SAND:"The Sandbox (SAND)",SC:"Siacoin",SDN:"Shiden (SDN)",SOL:"Solana",SNX:"Synthetix  Network (SNX)",SRM:"Serum",STORJ:"Storj (STORJ)",SUSHI:"Sushiswap (SUSHI)",TBTC:"tBTC",TRX:"Tron",UNI:"UNI",USDC:"USDC",USDT:"Tether USD (ERC20)","USDT-TRC20":"Tether USD (TRC20)",WAVES:"Waves",WBTC:"Wrapped Bitcoin (WBTC)",XLM:"Stellar XLM",XMR:"Monero",XRP:"Ripple XRP",XTZ:"XTZ",YFI:"YFI",ZEC:"Zcash (Transparent)",ZRX:"0x (ZRX)"}},precisionMode:nH,exceptions:{"EQuery:Invalid asset pair":G0,"EAPI:Invalid key":Mv,"EFunding:Unknown withdraw key":Ev,"EFunding:Invalid amount":Bv,"EService:Unavailable":Ec,"EDatabase:Internal error":Ec,"EService:Busy":Ec,"EQuery:Unknown asset":G0,"EAPI:Rate limit exceeded":Yf,"EOrder:Rate limit exceeded":Yf,"EGeneral:Internal error":Ec,"EGeneral:Temporary lockout":Yf,"EGeneral:Permission denied":ZD,"EOrder:Unknown order":Qf,"EOrder:Order minimum not met":Qf,"EGeneral:Invalid arguments":Cv,"ESession:Invalid session":Mv,"EAPI:Invalid nonce":Av,"EFunding:No funding method":Cv,"EFunding:Unknown asset":G0,"EService:Market in post_only mode":tH,"EGeneral:Too many requests":Yf,"ETrade:User Locked":sH}})}feeToPrecision(e,t){return this.decimalToPrecision(t,iH,this.markets[e].precision.amount,this.precisionMode)}async fetchMarkets(e={}){const t=await this.publicGetAssetPairs(e),s=this.safeValue(t,"result",{}),i=Object.keys(s);let n=[];for(let r=0;r<i.length;r++){const a=i[r],o=s[a],d=this.safeString(o,"base"),c=this.safeString(o,"quote"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),l=a.indexOf(".d")>=0,p=this.safeString(o,"altname"),m=this.safeValue(o,"fees_maker",[]),g=this.safeValue(m,0,[]),y=this.safeString(g,1);let b;y!==void 0&&(b=this.parseNumber($a.stringDiv(y,"100")));const w=this.safeValue(o,"fees",[]),k=this.safeValue(w,0,[]),T=this.safeString(k,1);let O;T!==void 0&&(O=this.parseNumber($a.stringDiv(T,"100")));const x=this.safeValue(o,"leverage_buy",[]),C=x.length,E=this.parseNumber(this.parsePrecision(this.safeString(o,"pair_decimals")));n.push({id:a,symbol:l?p:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,darkpool:l,altname:o.altname,type:"spot",spot:!0,margin:C>0,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,taker:O,maker:b,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(o,"lot_decimals"))),price:E},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(x,C-1,1)},amount:{min:this.safeNumber(o,"ordermin"),max:void 0},price:{min:E,max:void 0},cost:{min:void 0,max:void 0}},info:o})}return n=this.appendInactiveMarkets(n),this.marketsByAltname=this.indexBy(n,"altname"),n}safeCurrency(e,t=void 0){if(e!==void 0&&e.length>3&&(e.indexOf("X")===0||e.indexOf("Z")===0)){if(e.indexOf(".")>0)return super.safeCurrency(e,t);e=e.slice(1)}return super.safeCurrency(e,t)}appendInactiveMarkets(e){const t={amount:this.parseNumber("0.00000001"),price:this.parseNumber("0.00000001")},s={min:void 0,max:void 0},i={min:t.price,max:void 0},r={amount:{min:t.amount,max:void 0},price:i,cost:s},a={darkpool:!1,info:void 0,maker:void 0,taker:void 0,active:!1,precision:t,limits:r},o=[];for(let d=0;d<o.length;d++)e.push(this.extend(a,o[d]));return e}async fetchCurrencies(e={}){const t=await this.publicGetAssets(e),s=this.safeValue(t,"result",{}),i=Object.keys(s),n={};for(let r=0;r<i.length;r++){const a=i[r],o=s[a],d=this.safeCurrencyCode(this.safeString(o,"altname")),c=this.parseNumber(this.parsePrecision(this.safeString(o,"decimals"))),u=!this.inArray(d,this.options.inactiveCurrencies);n[d]={id:a,code:d,info:o,name:d,active:u,deposit:void 0,withdraw:void 0,fee:void 0,precision:c,limits:{amount:{min:c,max:void 0},withdraw:{min:void 0,max:void 0}}}}return n}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id,"fee-info":!0},n=await this.privatePostTradeVolume(this.extend(i,t)),r=this.safeValue(n,"result",{});return this.parseTradingFee(r,s)}parseTradingFee(e,t){const s=this.safeValue(e,"fees_maker",{}),i=this.safeValue(e,"fees",{}),n=this.safeValue(s,t.id,{}),r=this.safeValue(i,t.id,{});return{info:e,symbol:t.symbol,maker:this.safeNumber(n,"fee"),taker:this.safeNumber(r,"fee"),percentage:!0,tierBased:!0}}parseBidAsk(e,t=0,s=1){const i=this.safeNumber(e,t),n=this.safeNumber(e,s),r=this.safeInteger(e,2);return[i,n,r]}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);if(i.darkpool)throw new Vc(this.id+" fetchOrderBook() does not provide an order book for darkpool symbol "+e);const n={pair:i.id};t!==void 0&&(n.count=t);const r=await this.publicGetDepth(this.extend(n,s)),a=this.safeValue(r,"result",{});let o=this.safeValue(a,i.id);const d=this.safeValue(i,"info",{}),c=this.safeValue(d,"wsname");return c!==void 0&&(o=this.safeValue(a,c,o)),this.parseOrderBook(o,e)}parseTicker(e,t=void 0){const s=this.milliseconds(),i=this.safeSymbol(void 0,t),n=this.safeValue(e,"v",[]),r=this.safeString(n,1),a=this.safeValue(e,"p",[]),o=this.safeString(a,1),d=$a.stringMul(r,o),c=this.safeValue(e,"c",[]),u=this.safeString(c,0),h=this.safeValue(e,"h",[]),l=this.safeValue(e,"l",[]),p=this.safeValue(e,"b",[]),m=this.safeValue(e,"a",[]);return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(h,1),low:this.safeString(l,1),bid:this.safeString(p,0),bidVolume:void 0,ask:this.safeString(m,0),askVolume:void 0,vwap:o,open:this.safeString(e,"o"),close:u,last:u,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:d,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};if(e!==void 0){e=this.marketSymbols(e);const o=[];for(let d=0;d<e.length;d++){const c=e[d],u=this.markets[c];u.active&&!u.darkpool&&o.push(u.id)}s.pair=o.join(",")}const n=(await this.publicGetTicker(this.extend(s,t))).result,r=Object.keys(n),a={};for(let o=0;o<r.length;o++){const d=r[o],c=this.safeMarket(d),u=c.symbol,h=n[d];a[u]=this.parseTicker(h,c)}return this.filterByArray(a,"symbol",e)}async fetchTicker(e,t={}){if(await this.loadMarkets(),e.indexOf(".d")>=0)throw new Vc(this.id+" fetchTicker() does not provide a ticker for darkpool symbol "+e);const i=this.market(e),n={pair:i.id},a=(await this.publicGetTicker(this.extend(n,t))).result[i.id];return this.parseTicker(a,i)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,6)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id,interval:this.timeframes[t]};s!==void 0&&(a.since=parseInt((s-1)/1e3));const o=await this.publicGetOHLC(this.extend(a,n)),d=this.safeValue(o,"result",{}),c=this.safeValue(d,r.id,[]);return this.parseOHLCVs(c,r,t,s,i)}parseLedgerEntryType(e){const t={trade:"trade",withdrawal:"transaction",deposit:"transaction",transfer:"transfer",margin:"margin"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"id");let i;const n=void 0,r=this.safeString(e,"refid"),a=void 0,o=this.parseLedgerEntryType(this.safeString(e,"type")),d=this.safeCurrencyCode(this.safeString(e,"asset"),t);let c=this.safeString(e,"amount");$a.stringLt(c,"0")?(i="out",c=$a.stringAbs(c)):i="in";const u=this.safeNumber(e,"time");let h;return u!==void 0&&(h=parseInt(u*1e3)),{info:e,id:s,direction:i,account:n,referenceId:r,referenceAccount:a,type:o,currency:d,amount:this.parseNumber(c),before:void 0,after:this.safeNumber(e,"balance"),status:"ok",timestamp:h,datetime:this.iso8601(h),fee:{cost:this.safeNumber(e,"fee"),currency:d}}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.asset=r.id),t!==void 0&&(n.start=parseInt(t/1e3));const a=await this.privatePostLedgers(this.extend(n,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"ledger",{}),c=Object.keys(d),u=[];for(let h=0;h<c.length;h++){const l=c[h],p=d[l];p.id=l,u.push(p)}return this.parseLedger(u,r,t,s)}async fetchLedgerEntriesByIds(e,t=void 0,s={}){await this.loadMarkets(),e=e.join(",");const i=this.extend({id:e},s),r=(await this.privatePostQueryLedgers(i)).result,a=Object.keys(r),o=[];for(let d=0;d<a.length;d++){const c=a[d],u=r[c];u.id=c,o.push(u)}return this.parseLedger(o)}async fetchLedgerEntry(e,t=void 0,s={}){return(await this.fetchLedgerEntriesByIds([e],t,s))[0]}parseTrade(e,t=void 0){let s,i,n,r,a,o,d,c,u;if(Array.isArray(e))s=this.safeTimestamp(e,2),i=e[3]==="s"?"sell":"buy",n=e[4]==="l"?"limit":"market",r=this.safeString(e,0),a=this.safeString(e,1),e.length>6&&(o=this.safeString(e,6));else if(typeof e=="string")o=e;else if("ordertxid"in e){const l=this.safeString(e,"pair"),p=this.findMarketByAltnameOrId(l);if(p!==void 0?t=p:l!==void 0&&(t=this.getDelistedMarketById(l)),d=this.safeString(e,"ordertxid"),o=this.safeString2(e,"id","postxid"),s=this.safeTimestamp(e,"time"),i=this.safeString(e,"type"),n=this.safeString(e,"ordertype"),r=this.safeString(e,"price"),a=this.safeString(e,"vol"),"fee"in e){let m;t!==void 0&&(m=t.quote),c={cost:this.safeString(e,"fee"),currency:m}}}t!==void 0&&(u=t.symbol);const h=this.safeString(e,"cost");return this.safeTrade({id:o,order:d,info:e,timestamp:s,datetime:this.iso8601(s),symbol:u,type:n,side:i,takerOrMaker:void 0,price:r,amount:a,cost:h,fee:c},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r=n.id,a={pair:r};if(t!==void 0&&(a.since=t*1e6,a.since=t.toString()+"000000"),s!==void 0&&s!==1e3&&this.safeValue(this.options,"fetchTradesWarning",!0))throw new Vc(this.id+" fetchTrades() cannot serve "+s.toString()+" trades without breaking the pagination, see https://github.com/ccxt/ccxt/issues/5698 for more details. Set exchange.options['fetchTradesWarning'] to acknowledge this warning and silence it.");const d=(await this.publicGetTrades(this.extend(a,i))).result,c=d[r],u=c.length;if(u<=0)return[];const h=c[u-1],l=this.safeString(d,"last");return h.push(l),this.parseTrades(c,n,t,s)}parseBalance(e){const t=this.safeValue(e,"result",{}),s={info:e,timestamp:void 0,datetime:void 0},i=Object.keys(t);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(t,r),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalance(e);return this.parseBalance(t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const o={pair:this.market(e).id,type:s,ordertype:t,volume:this.amountToPrecision(e,i)},d=this.safeString2(r,"userref","clientOrderId");if(r=this.omit(r,["userref","clientOrderId"]),d!==void 0&&(o.userref=d),t==="limit")o.price=this.priceToPrecision(e,n);else if(t==="stop-loss"||t==="take-profit"){const l=this.safeNumber2(r,"price","stopPrice",n);if(l===void 0)throw new Nc(this.id+" createOrder() requires a price argument or a price/stopPrice parameter for a "+t+" order");o.price=this.priceToPrecision(e,l)}else if(t==="stop-loss-limit"||t==="take-profit-limit"){const l=this.safeNumber2(r,"price","stopPrice"),p=this.safeNumber(r,"price2"),m=l!==void 0,g=p!==void 0;if(m&&g)o.price=this.priceToPrecision(e,l),o.price2=this.priceToPrecision(e,p);else{if(n===void 0||!(m||g))throw new Nc(this.id+" createOrder() requires a price argument and/or price/stopPrice/price2 parameters for a "+t+" order");m?(o.price=this.priceToPrecision(e,l),o.price2=this.priceToPrecision(e,n)):g&&(o.price=this.priceToPrecision(e,n),o.price2=this.priceToPrecision(e,p))}}let c=this.safeValue(r,"close");if(c!==void 0){c=this.extend({},c);const l=this.safeValue(c,"price");l!==void 0&&(c.price=this.priceToPrecision(e,l));const p=this.safeValue(c,"price2");p!==void 0&&(c.price2=this.priceToPrecision(e,p)),o.close=c}r=this.omit(r,["price","stopPrice","price2","close"]);const u=await this.privatePostAddOrder(this.extend(o,r)),h=this.safeValue(u,"result");return this.parseOrder(h)}findMarketByAltnameOrId(e){return e in this.marketsByAltname?this.marketsByAltname[e]:this.safeMarket(e)}getDelistedMarketById(e){if(e===void 0)return e;let t=this.safeValue(this.options.delistedMarketsById,e);if(t!==void 0)return t;const s=0;let i=3,n=3,r=6;e.length===8?(i=4,n=4,r=8):e.length===7&&(i=4,n=4,r=7);const a=e.slice(s,i),o=e.slice(n,r),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o);return t={symbol:d+"/"+c,base:d,quote:c,baseId:a,quoteId:o},this.options.delistedMarketsById[e]=t,t}parseOrderStatus(e){const t={pending:"open",open:"open",closed:"closed",canceled:"canceled",expired:"expired"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeValue(e,"descr",{}),i=this.safeString(s,"order");let n,r,a,o,d,c;if(i!==void 0){const T=i.split(" ");n=this.safeString(T,0),d=this.safeString(T,1),a=this.safeString(T,2),r=this.safeString(T,4),r==="stop"?(c=this.safeString(T,6),o=this.safeString(T,9)):r==="limit"&&(o=this.safeString(T,5))}n=this.safeString(s,"type",n),r=this.safeString(s,"ordertype",r),a=this.safeString(s,"pair",a);const u=this.findMarketByAltnameOrId(a);let h;u!==void 0?t=u:a!==void 0&&(t=this.getDelistedMarketById(a));const l=this.safeTimestamp(e,"opentm");d=this.safeString(e,"vol",d);const p=this.safeString(e,"vol_exec");let m;o=this.safeString(s,"price",o),(o===void 0||$a.stringEquals(o,"0"))&&(o=this.safeString(s,"price2")),(o===void 0||$a.stringEquals(o,"0"))&&(o=this.safeString(e,"price",o));const g=this.safeNumber(e,"price");if(t!==void 0&&(h=t.symbol,"fee"in e)){const T=e.oflags;m={cost:this.safeString(e,"fee"),rate:void 0},T.indexOf("fciq")>=0?m.currency=t.quote:T.indexOf("fcib")>=0&&(m.currency=t.base)}const y=this.parseOrderStatus(this.safeString(e,"status"));let b=this.safeString(e,"id");if(b===void 0){const T=this.safeValue(e,"txid");b=this.safeString(T,0)}const w=this.safeString(e,"userref"),k=this.safeValue(e,"trades");return c=this.safeNumber(e,"stopprice",c),this.safeOrder({id:b,clientOrderId:w,info:e,timestamp:l,datetime:this.iso8601(l),lastTradeTimestamp:void 0,status:y,symbol:h,type:r,timeInForce:void 0,postOnly:void 0,side:n,price:o,stopPrice:c,cost:void 0,amount:d,filled:p,average:g,remaining:void 0,fee:m,trades:k},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue2(s,"userref","clientOrderId"),n={trades:!0};let r=s;i!==void 0?(n.userref=i,r=this.omit(s,["userref","clientOrderId"])):n.txid=e;const a=await this.privatePostQueryOrders(this.extend(n,r)),o=this.safeValue(a,"result",[]);if(!(e in o))throw new Pv(this.id+" fetchOrder() could not find order id "+e);const d=this.parseOrder(this.extend({id:e},o[e]));return this.extend({info:a},d)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){const r=this.safeValue(n,"trades"),a=[];if(r===void 0)throw new Nc(this.id+" fetchOrderTrades() requires a unified order structure in the params argument or a 'trades' param (an array of trade id strings)");for(let l=0;l<r.length;l++){const p=r[l];typeof p=="string"?a.push(p):a.push(p.id)}await this.loadMarkets(),t!==void 0&&(t=this.symbol(t));const o=this.safeValue(this.options,"fetchOrderTrades",{}),d=this.safeInteger(o,"batchSize",20),c=a.length;let u=parseInt(c/d);u=this.sum(u,1);let h=[];for(let l=0;l<u;l++){const p=[];for(let T=0;T<d;T++){const O=this.sum(l*d,T);O<c&&p.push(a[O])}const m={txid:p.join(",")},g=await this.privatePostQueryTrades(m),y=this.safeValue(g,"result"),b=Object.keys(y);for(let T=0;T<b.length;T++)y[b[T]].id=b[T];const w=this.parseTrades(y,void 0,s,i),k=this.filterBySymbol(w,t);h=this.arrayConcat(h,k)}return h}async fetchOrdersByIds(e,t=void 0,s={}){await this.loadMarkets();const i=await this.privatePostQueryOrders(this.extend({trades:!0,txid:e.join(",")},s)),n=this.safeValue(i,"result",{}),r=[],a=Object.keys(n);for(let o=0;o<a.length;o++){const d=a[o],c=n[d],u=this.parseOrder(this.extend({id:d},c));r.push(u)}return r}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.start=parseInt(t/1e3));const a=(await this.privatePostTradesHistory(this.extend(n,i))).result.trades,o=Object.keys(a);for(let c=0;c<o.length;c++)a[o[c]].id=o[c];let d;return e!==void 0&&(d=this.market(e)),this.parseTrades(a,d,t,s)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();let i;const r={txid:this.safeValue2(s,"userref","clientOrderId",e)};s=this.omit(s,["userref","clientOrderId"]);try{i=await this.privatePostCancelOrder(this.extend(r,s))}catch(a){throw this.last_http_response&&this.last_http_response.indexOf("EOrder:Unknown order")>=0?new Pv(this.id+" cancelOrder() error "+this.last_http_response):a}return i}async cancelOrders(e,t=void 0,s={}){const i={orders:e};return await this.privatePostCancelOrderBatch(this.extend(i,s))}async cancelAllOrders(e=void 0,t={}){return await this.loadMarkets(),await this.privatePostCancelAll(t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.start=parseInt(t/1e3));let r=i;const a=this.safeValue2(i,"userref","clientOrderId");a!==void 0&&(n.userref=a,r=this.omit(i,["userref","clientOrderId"]));const o=await this.privatePostOpenOrders(this.extend(n,r));let d;e!==void 0&&(d=this.market(e));const c=this.safeValue(o,"result",{}),u=this.safeValue(c,"open",[]);return this.parseOrders(u,d,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.start=parseInt(t/1e3));let r=i;const a=this.safeValue2(i,"userref","clientOrderId");a!==void 0&&(n.userref=a,r=this.omit(i,["userref","clientOrderId"]));const o=await this.privatePostClosedOrders(this.extend(n,r));let d;e!==void 0&&(d=this.market(e));const c=this.safeValue(o,"result",{}),u=this.safeValue(c,"closed",[]);return this.parseOrders(u,d,t,s)}parseTransactionStatus(e){const t={Initial:"pending",Pending:"pending",Success:"ok",Settled:"pending",Failure:"failed",Partial:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"refid"),i=this.safeString(e,"txid"),n=this.safeTimestamp(e,"time"),r=this.safeString(e,"asset"),a=this.safeCurrencyCode(r,t),o=this.safeString(e,"info"),d=this.safeNumber(e,"amount");let c=this.parseTransactionStatus(this.safeString(e,"status"));const u=this.safeString(e,"status-prop");(u==="on-hold"||u==="cancel-pending"||u==="onhold")&&(c="pending");const m=this.safeString(e,"type");let g=this.safeNumber(e,"fee");return g===void 0&&m==="deposit"&&(g=0),{info:e,id:s,currency:a,amount:d,network:void 0,address:o,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,status:c,type:m,updated:void 0,txid:i,timestamp:n,datetime:this.iso8601(n),fee:{currency:a,cost:g}}}parseTransactionsByType(e,t,s=void 0,i=void 0,n=void 0){const r=[];for(let a=0;a<t.length;a++){const o=this.parseTransaction(this.extend({type:e},t[a]));r.push(o)}return this.filterByCurrencySinceLimit(r,s,i,n)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Nc(this.id+" fetchDeposits() requires a currency code argument");await this.loadMarkets();const r={asset:this.currency(e).id},a=await this.privatePostDepositStatus(this.extend(r,i));return this.parseTransactionsByType("deposit",a.result,e,t,s)}async fetchTime(e={}){const t=await this.publicGetTime(e),s=this.safeValue(t,"result",{});return this.safeTimestamp(s,"unixtime")}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Nc(this.id+" fetchWithdrawals() requires a currency code argument");await this.loadMarkets();const r={asset:this.currency(e).id},a=await this.privatePostWithdrawStatus(this.extend(r,i));return this.parseTransactionsByType("withdrawal",a.result,e,t,s)}async createDepositAddress(e,t={}){const s={new:"true"};return await this.fetchDepositAddress(e,this.extend(s,t))}async fetchDepositMethods(e,t={}){await this.loadMarkets();const i={asset:this.currency(e).id},n=await this.privatePostDepositMethods(this.extend(i,t));return this.safeValue(n,"result")}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e);let i=this.safeStringUpper(t,"network");const n=this.safeValue(this.options,"networks",{});i=this.safeString(n,i,i),t=this.omit(t,"network"),e==="USDT"&&i==="TRC20"&&(e=e+"-"+i);const r=this.safeValue(this.options,"depositMethods",{}),a=this.safeString(r,e);let o=this.safeString(t,"method",a);if(o===void 0){const l=await this.fetchDepositMethods(e);if(i!==void 0)for(let p=0;p<l.length;p++){const m=this.safeString(l[p],"method");if(m.indexOf(i)>=0){o=m;break}}if(o===void 0){const p=this.safeValue(l,0,{});o=this.safeString(p,"method")}}const d={asset:s.id,method:o},c=await this.privatePostDepositAddresses(this.extend(d,t)),u=this.safeValue(c,"result",[]),h=this.safeValue(u,0,{});if(h===void 0)throw new Ev(this.id+" privatePostDepositAddresses() returned no addresses for "+e);return this.parseDepositAddress(h,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"tag");t=this.safeCurrency(void 0,t);const n=t.code;return this.checkAddress(s),{currency:n,address:s,tag:i,network:void 0,info:e}}async withdraw(e,t,s,i=void 0,n={}){if([i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),"key"in n){await this.loadMarkets();const r=this.currency(e),a={asset:r.id,amount:t},o=await this.privatePostWithdraw(this.extend(a,n)),d=this.safeValue(o,"result",{});return this.parseTransaction(d,r)}throw new Vc(this.id+" withdraw() requires a 'key' parameter (withdrawal key name, as set up on your account)")}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s={},i=await this.privatePostOpenPositions(this.extend(s,t));return this.safeValue(i,"result")}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.version+"/"+t+"/"+e;if(t==="public")Object.keys(i).length&&(a+="?"+this.urlencodeNested(i));else if(t==="private"){const o=e==="CancelOrderBatch";this.checkRequiredCredentials();const d=this.nonce().toString();o?r=this.json(this.extend({nonce:d},i)):r=this.urlencodeNested(this.extend({nonce:d},i));const c=this.encode(d+r),u=this.hash(c,"sha256","binary"),h=this.stringToBinary(this.encode(a)),l=this.binaryConcat(h,u),p=this.base64ToBinary(this.secret),m=this.hmac(l,p,"sha512","base64");n={"API-Key":this.apiKey,"API-Sign":m},o?n["Content-Type"]="application/json":n["Content-Type"]="application/x-www-form-urlencoded"}else a="/"+e;return a=this.urls.api[t]+a,{url:a,method:s,body:r,headers:n}}nonce(){return this.milliseconds()}handleErrors(e,t,s,i,n,r,a,o,d){if(e===520)throw new Ec(this.id+" "+e.toString()+" "+t);if(r.indexOf("Invalid order")>=0)throw new Qf(this.id+" "+r);if(r.indexOf("Invalid nonce")>=0)throw new Av(this.id+" "+r);if(r.indexOf("Insufficient funds")>=0)throw new Bv(this.id+" "+r);if(r.indexOf("Cancel pending")>=0)throw new JD(this.id+" "+r);if(r.indexOf("Invalid arguments:volume")>=0)throw new Qf(this.id+" "+r);if(r.indexOf("Rate limit exceeded")>=0)throw new eH(this.id+" "+r);if(a!==void 0&&r[0]==="{"&&typeof a!="string"&&"error"in a&&a.error.length){const u=this.id+" "+r;for(let h=0;h<a.error.length;h++){const l=a.error[h];this.throwExactlyMatchedException(this.exceptions,l,u)}throw new Vc(u)}}};const rH=ge,{ExchangeError:Go,ExchangeNotAvailable:U0,InsufficientFunds:qc,OrderNotFound:$0,InvalidOrder:On,AccountSuspended:aH,InvalidNonce:oH,NotSupported:Zf,BadRequest:Lc,AuthenticationError:ja,BadSymbol:Nv,RateLimitExceeded:Vv,PermissionDenied:qv,InvalidAddress:dH}=de,{TICK_SIZE:cH}=me,Uo=Se;var Bb=class extends rH{describe(){return this.deepExtend(super.describe(),{id:"kucoin",name:"KuCoin",countries:["SC"],rateLimit:50,version:"v2",certified:!0,pro:!0,comment:"Platform 2.0",quoteJsonNumbers:!1,has:{CORS:void 0,spot:!0,margin:!0,swap:!1,future:!1,option:void 0,borrowMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBorrowInterest:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!0,fetchBorrowRates:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchL3OrderBook:!0,fetchLedger:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrdersByStatus:!0,fetchOrderTrades:!0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactionFee:!0,fetchWithdrawals:!0,repayMargin:!0,setMarginMode:!1,transfer:!0,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/51840849/87295558-132aaf80-c50e-11ea-9801-a2fb0c57c799.jpg",referral:"https://www.kucoin.com/ucenter/signup?rcode=E5wkqe",api:{public:"https://api.kucoin.com",private:"https://api.kucoin.com",futuresPrivate:"https://api-futures.kucoin.com",futuresPublic:"https://api-futures.kucoin.com"},test:{public:"https://openapi-sandbox.kucoin.com",private:"https://openapi-sandbox.kucoin.com",futuresPrivate:"https://api-sandbox-futures.kucoin.com",futuresPublic:"https://api-sandbox-futures.kucoin.com"},www:"https://www.kucoin.com",doc:["https://docs.kucoin.com"]},requiredCredentials:{apiKey:!0,secret:!0,password:!0},api:{public:{get:{timestamp:1,status:1,symbols:1,markets:1,"market/allTickers":1,"market/orderbook/level{level}_{limit}":1,"market/orderbook/level2_20":1,"market/orderbook/level2_100":1,"market/histories":1,"market/candles":1,"market/stats":1,currencies:1,"currencies/{currency}":1,prices:1,"mark-price/{symbol}/current":1,"margin/config":1,"margin/trade/last":1},post:{"bullet-public":1}},private:{get:{"market/orderbook/level{level}":1,"market/orderbook/level2":{v3:2},"market/orderbook/level3":1,accounts:1,"accounts/{accountId}":1,"accounts/ledgers":3.333,"accounts/{accountId}/holds":1,"accounts/transferable":1,"base-fee":1,"sub/user":1,"user-info":1,"sub/api-key":1,"sub-accounts":1,"sub-accounts/{subUserId}":1,"deposit-addresses":1,deposits:10,"hist-deposits":10,"hist-withdrawals":10,withdrawals:10,"withdrawals/quotas":1,orders:2,"order/client-order/{clientOid}":1,"orders/{orderId}":1,"limit/orders":1,fills:6.66667,"limit/fills":1,"isolated/accounts":2,"isolated/account/{symbol}":2,"isolated/borrow/outstanding":2,"isolated/borrow/repaid":2,"isolated/symbols":2,"margin/account":1,"margin/borrow":1,"margin/borrow/outstanding":1,"margin/borrow/repaid":1,"margin/lend/active":1,"margin/lend/done":1,"margin/lend/trade/unsettled":1,"margin/lend/trade/settled":1,"margin/lend/assets":1,"margin/market":1,"stop-order/{orderId}":1,"stop-order":1,"stop-order/queryOrderByClientOid":1,"trade-fees":1.3333},post:{accounts:1,"accounts/inner-transfer":{v2:1},"accounts/sub-transfer":{v2:25},"deposit-addresses":1,withdrawals:1,orders:4,"orders/multi":20,"isolated/borrow":2,"isolated/repay/all":2,"isolated/repay/single":2,"margin/borrow":1,"margin/order":1,"margin/repay/all":1,"margin/repay/single":1,"margin/lend":1,"margin/toggle-auto-lend":1,"bullet-private":1,"stop-order":1,"sub/user":1,"sub/api-key":1,"sub/api-key/update":1},delete:{"withdrawals/{withdrawalId}":1,orders:20,"order/client-order/{clientOid}":1,"orders/{orderId}":1,"margin/lend/{orderId}":1,"stop-order/cancelOrderByClientOid":1,"stop-order/{orderId}":1,"stop-order/cancel":1,"sub/api-key":1}},futuresPublic:{get:{"contracts/active":1.3953,"contracts/{symbol}":1.3953,ticker:1.3953,"level2/snapshot":2,"level2/depth20":1.3953,"level2/depth100":1.3953,"level2/message/query":1.3953,"level3/message/query":1.3953,"level3/snapshot":1.3953,"trade/history":1.3953,"interest/query":1.3953,"index/query":1.3953,"mark-price/{symbol}/current":1.3953,"premium/query":1.3953,"funding-rate/{symbol}/current":1.3953,timestamp:1.3953,status:1.3953,"kline/query":1.3953},post:{"bullet-public":1.3953}},futuresPrivate:{get:{"account-overview":2,"transaction-history":6.666,"deposit-address":1.3953,"deposit-list":1.3953,"withdrawals/quotas":1.3953,"withdrawal-list":1.3953,"transfer-list":1.3953,orders:1.3953,stopOrders:1.3953,recentDoneOrders:1.3953,"orders/{orderId}":1.3953,"orders/byClientOid":1.3953,fills:6.666,recentFills:6.666,openOrderStatistics:1.3953,position:1.3953,positions:6.666,"funding-history":6.666},post:{withdrawals:1.3953,"transfer-out":1.3953,orders:1.3953,"position/margin/auto-deposit-status":1.3953,"position/margin/deposit-margin":1.3953,"bullet-private":1.3953},delete:{"withdrawals/{withdrawalId}":1.3953,"cancel/transfer-out":1.3953,"orders/{orderId}":1.3953,orders:6.666,stopOrders:1.3953}}},timeframes:{"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","2h":"2hour","4h":"4hour","6h":"6hour","8h":"8hour","12h":"12hour","1d":"1day","1w":"1week"},precisionMode:cH,exceptions:{exact:{"order not exist":$0,"order not exist.":$0,order_not_exist:$0,order_not_exist_or_not_allow_to_cancel:On,"Order size below the minimum requirement.":On,"The withdrawal amount is below the minimum requirement.":Go,"Unsuccessful! Exceeded the max. funds out-transfer limit":qc,400:Lc,401:ja,403:Zf,404:Zf,405:Zf,429:Vv,500:U0,503:U0,101030:qv,103e3:On,200004:qc,210014:On,210021:qc,230003:qc,260100:qc,3e5:On,4e5:Nv,400001:ja,400002:oH,400003:ja,400004:ja,400005:ja,400006:ja,400007:ja,400008:Zf,400100:Lc,400200:On,400350:On,400370:On,400500:On,400600:Nv,400760:On,401e3:Lc,411100:aH,415e3:Lc,5e5:U0,260220:dH,900014:Lc},broad:{"Exceeded the access frequency":Vv,"require more permission":qv}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0.001"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("50"),this.parseNumber("0.001")],[this.parseNumber("200"),this.parseNumber("0.0009")],[this.parseNumber("500"),this.parseNumber("0.0008")],[this.parseNumber("1000"),this.parseNumber("0.0007")],[this.parseNumber("2000"),this.parseNumber("0.0007")],[this.parseNumber("4000"),this.parseNumber("0.0006")],[this.parseNumber("8000"),this.parseNumber("0.0005")],[this.parseNumber("15000"),this.parseNumber("0.00045")],[this.parseNumber("25000"),this.parseNumber("0.0004")],[this.parseNumber("40000"),this.parseNumber("0.00035")],[this.parseNumber("60000"),this.parseNumber("0.0003")],[this.parseNumber("80000"),this.parseNumber("0.00025")]],maker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("50"),this.parseNumber("0.0009")],[this.parseNumber("200"),this.parseNumber("0.0007")],[this.parseNumber("500"),this.parseNumber("0.0005")],[this.parseNumber("1000"),this.parseNumber("0.0003")],[this.parseNumber("2000"),this.parseNumber("0")],[this.parseNumber("4000"),this.parseNumber("0")],[this.parseNumber("8000"),this.parseNumber("0")],[this.parseNumber("15000"),this.parseNumber("-0.00005")],[this.parseNumber("25000"),this.parseNumber("-0.00005")],[this.parseNumber("40000"),this.parseNumber("-0.00005")],[this.parseNumber("60000"),this.parseNumber("-0.00005")],[this.parseNumber("80000"),this.parseNumber("-0.00005")]]}},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}},commonCurrencies:{HOT:"HOTNOW",EDGE:"DADI",WAX:"WAXP",TRY:"Trias",VAI:"VAIOT"},options:{version:"v1",symbolSeparator:"-",fetchMyTradesMethod:"private_get_fills",fetchBalance:"trade",fetchMarkets:{fetchTickersFees:!0},versions:{public:{GET:{"currencies/{currency}":"v2",status:"v1","market/orderbook/level2_20":"v1","market/orderbook/level2_100":"v1","market/orderbook/level{level}_{limit}":"v1"}},private:{GET:{"market/orderbook/level2":"v3","market/orderbook/level3":"v3","market/orderbook/level{level}":"v3","deposit-addresses":"v1"},POST:{"accounts/inner-transfer":"v2","accounts/sub-transfer":"v2",accounts:"v2"}},futuresPrivate:{GET:{"account-overview":"v1",positions:"v1"},POST:{"transfer-out":"v2"}},futuresPublic:{GET:{"level3/snapshot":"v2"}}},partner:{spot:{id:"ccxt",key:"9e58cc35-5b5e-4133-92ec-166e3f077cb8"},future:{id:"ccxtfutures",key:"1b327198-f30c-4f14-a0ac-918871282f15"}},accountsByType:{spot:"trade",margin:"margin",cross:"margin",isolated:"isolated",main:"main",funding:"main",future:"contract",mining:"pool"},networks:{Native:"bech32","BTC-Segwit":"btc",ERC20:"eth",BEP20:"bsc",TRC20:"trx",TERRA:"luna",BNB:"bsc",HRC20:"heco",HT:"heco"}}})}nonce(){return this.milliseconds()}async fetchTime(e={}){const t=await this.publicGetTimestamp(e);return this.safeInteger(t,"data")}async fetchStatus(e={}){const t=await this.publicGetStatus(e),s=this.safeValue(t,"data",{});return{status:this.safeString(s,"status")==="open"?"ok":"maintenance",updated:void 0,eta:void 0,url:void 0,info:t}}async fetchMarkets(e={}){const t=await this.publicGetSymbols(e),s=this.safeValue(t,"data"),i=this.safeValue(this.options,"fetchMarkets",{}),n=this.safeValue(i,"fetchTickersFees",!0);let r={};n&&(r=await this.publicGetMarketAllTickers(e));const a=this.safeValue(r,"data",{}),o=this.safeValue(a,"ticker",[]),d=this.indexBy(o,"symbol"),c=[];for(let u=0;u<s.length;u++){const h=s[u],l=this.safeString(h,"symbol"),[p,m]=l.split("-"),g=this.safeCurrencyCode(p),y=this.safeCurrencyCode(m),b=this.safeValue(d,l,{}),w=this.safeString(b,"makerFeeRate"),k=this.safeString(b,"makerFeeRate"),T=this.safeString(b,"makerCoefficient"),O=this.safeString(b,"takerCoefficient");c.push({id:l,symbol:g+"/"+y,base:g,quote:y,settle:void 0,baseId:p,quoteId:m,settleId:void 0,type:"spot",spot:!0,margin:this.safeValue(h,"isMarginEnabled"),swap:!1,future:!1,option:!1,active:this.safeValue(h,"enableTrading"),contract:!1,linear:void 0,inverse:void 0,taker:this.parseNumber(Uo.stringMul(k,O)),maker:this.parseNumber(Uo.stringMul(w,T)),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(h,"baseIncrement"),price:this.safeNumber(h,"priceIncrement")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(h,"baseMinSize"),max:this.safeNumber(h,"baseMaxSize")},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(h,"quoteMinSize"),max:this.safeNumber(h,"quoteMaxSize")}},info:h})}return c}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeString(r,"fullName"),d=this.safeCurrencyCode(a),c=this.safeValue(r,"isWithdrawEnabled",!1),u=this.safeValue(r,"isDepositEnabled",!1),h=this.safeNumber(r,"withdrawalMinFee"),l=c&&u;i[d]={id:a,name:o,code:d,precision:this.parseNumber(this.parsePrecision(this.safeString(r,"precision"))),info:r,active:l,deposit:u,withdraw:c,fee:h,limits:this.limits}}return i}async fetchAccounts(e={}){const t=await this.privateGetAccounts(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"id"),o=this.safeString(r,"currency"),d=this.safeCurrencyCode(o),c=this.safeString(r,"type");i.push({id:a,type:c,currency:d,info:r})}return i}async fetchTransactionFee(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper2(t,"network","chain");r=this.safeStringLower(n,r,r),r!==void 0&&(r=r.toLowerCase(),i.chain=r.toLowerCase(),t=this.omit(t,["network","chain"]));const a=await this.privateGetWithdrawalsQuotas(this.extend(i,t)),o=a.data,d={};return d[e]=this.safeNumber(o,"withdrawMinFee"),{info:a,withdraw:d,deposit:{}}}isFuturesMethod(e,t){const s=this.safeString2(this.options,e,"defaultType","trade"),i=this.safeString(t,"type",s),n=this.safeValue(this.options,"accountsByType"),r=this.safeString(n,i);if(r===void 0){const a=Object.keys(n);throw new Go(this.id+" isFuturesMethod() type must be one of "+a.join(", "))}return t=this.omit(t,"type"),r==="contract"||r==="future"||r==="futures"}parseTicker(e,t=void 0){let s=this.safeString(e,"changeRate");s!==void 0&&(s=Uo.stringMul(s,"100"));let i=this.safeString2(e,"last","lastTradedPrice");i=this.safeString(e,"price",i);const n=this.safeString(e,"symbol");t=this.safeMarket(n,t,"-");const r=t.symbol,a=this.safeString(e,"vol"),o=this.safeString(e,"volValue"),d=this.safeInteger2(e,"time","datetime");return this.safeTicker({symbol:r,timestamp:d,datetime:this.iso8601(d),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString2(e,"buy","bestBid"),bidVolume:this.safeString(e,"bestBidSize"),ask:this.safeString2(e,"sell","bestAsk"),askVolume:this.safeString(e,"bestAskSize"),vwap:void 0,open:this.safeString(e,"open"),close:i,last:i,previousClose:void 0,change:this.safeString(e,"changePrice"),percentage:s,average:this.safeString(e,"averagePrice"),baseVolume:a,quoteVolume:o,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetMarketAllTickers(t),i=this.safeValue(s,"data",{}),n=this.safeValue(i,"ticker",[]),r=this.safeInteger(i,"time"),a={};for(let o=0;o<n.length;o++){n[o].time=r;const d=this.parseTicker(n[o]),c=this.safeString(d,"symbol");c!==void 0&&(a[c]=d)}return this.filterByArray(a,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetMarketStats(this.extend(i,t));return this.parseTicker(n.data,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),o={symbol:r.id,type:this.timeframes[t]},d=this.parseTimeframe(t)*1e3;let c=this.milliseconds();s!==void 0?(o.startAt=parseInt(Math.floor(s/1e3)),i===void 0&&(i=this.safeInteger(this.options,"fetchOHLCVLimit",1500)),c=this.sum(s,i*d)):i!==void 0&&(s=c-i*d,o.startAt=parseInt(Math.floor(s/1e3))),o.endAt=parseInt(Math.floor(c/1e3));const u=await this.publicGetMarketCandles(this.extend(o,n)),h=this.safeValue(u,"data",[]);return this.parseOHLCVs(h,r,t,s,i)}async createDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper2(t,"chain","network");r=this.safeStringLower(n,r,r),r!==void 0&&(r=r.toLowerCase(),i.chain=r,t=this.omit(t,["chain","network"]));const a=await this.privatePostDepositAddresses(this.extend(i,t)),o=this.safeValue(a,"data",{});let d=this.safeString(o,"address");d!==void 0&&(d=d.replace("bitcoincash:",""));const c=this.safeString(o,"memo");return e!=="NIM"&&this.checkAddress(d),{info:a,currency:e,network:this.safeString(o,"chain"),address:d,tag:c}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper2(t,"chain","network");r=this.safeStringLower(n,r,r),r!==void 0&&(r=r.toLowerCase(),i.chain=r,t=this.omit(t,["chain","network"]));const a=this.options.versions.private.GET["deposit-addresses"];this.options.versions.private.GET["deposit-addresses"]="v1";const o=await this.privateGetDepositAddresses(this.extend(i,t));this.options.versions.private.GET["deposit-addresses"]=a;const d=this.safeValue(o,"data",{});return this.parseDepositAddress(d,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=t.id;return i!=="NIM"&&this.checkAddress(s),{info:e,currency:i,address:s,tag:this.safeString(e,"memo"),network:this.safeString(e,"chain")}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=this.options.versions.private.GET["deposit-addresses"];this.options.versions.private.GET["deposit-addresses"]="v2";const r=await this.privateGetDepositAddresses(this.extend(i,t));this.options.versions.private.GET["deposit-addresses"]=n;const a=this.safeValue(r,"data",[]);return this.parseDepositAddressesByNetwork(a,s)}parseDepositAddressesByNetwork(e,t=void 0){const s=[];for(let i=0;i<e.length;i++){const n=e[i];s.push({info:n,currency:this.safeCurrencyCode(t.id,t),network:this.safeString(n,"chain"),address:this.safeString(n,"address"),tag:this.safeString(n,"memo")})}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n=this.safeInteger(s,"level",2),r={symbol:i.id};let a="publicGetMarketOrderbookLevelLevelLimit";const o=this.checkRequiredCredentials(!1);let d;if(!o||t!==void 0){if(n===2){if(r.level=n,t!==void 0)if(t===20||t===100)r.limit=t;else throw new Go(this.id+" fetchOrderBook() limit argument must be 20 or 100");r.limit=t||100}}else a="privateGetMarketOrderbookLevel2";d=await this[a](this.extend(r,s));const c=this.safeValue(d,"data",{}),u=this.safeInteger(c,"time"),h=this.parseOrderBook(c,i.symbol,u,"bids","asks",n-2,n-1);return h.nonce=this.safeInteger(c,"sequence"),h}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.marketId(e),o=this.safeString2(r,"clientOid","clientOrderId",this.uuid());r=this.omit(r,["clientOid","clientOrderId"]);const d={clientOid:o,side:s,symbol:a,type:t},c=this.safeNumber2(r,"cost","funds");let u,h;t==="market"?c!==void 0?(r=this.omit(r,["cost","funds"]),h=this.amountToPrecision(e,c),d.funds=h):(u=this.amountToPrecision(e,i),d.size=this.amountToPrecision(e,i)):(u=this.amountToPrecision(e,i),d.size=u,d.price=this.priceToPrecision(e,n));const l=this.safeValue(r,"stopLossPrice"),p=this.safeValue2(r,"takeProfitPrice","stopPrice"),m=l!==void 0,g=p!==void 0;if(m&&g)throw new Go(this.id+" createOrder() stopLossPrice and takeProfitPrice cannot both be defined");const y=this.safeString(r,"tradeType");r=this.omit(r,["stopLossPrice","takeProfitPrice","stopPrice"]);let b="privatePostOrders";if(m||g){d.stop=m?"entry":"loss";const C=m?l:p;d.stopPrice=this.priceToPrecision(e,C),b="privatePostStopOrder"}else y==="MARGIN_TRADE"&&(b="privatePostMarginOrder");const w=await this[b](this.extend(d,r)),k=this.safeValue(w,"data",{}),T=this.milliseconds();return{id:this.safeString(k,"orderId"),clientOrderId:o,info:k,timestamp:T,datetime:this.iso8601(T),lastTradeTimestamp:void 0,symbol:e,type:t,side:s,price:n,amount:this.parseNumber(u),cost:this.parseNumber(h),average:void 0,filled:void 0,remaining:void 0,status:void 0,fee:void 0,trades:void 0}}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={},n=this.safeString2(s,"clientOid","clientOrderId"),r=this.safeValue(s,"stop");let a="privateDeleteOrdersOrderId";return n!==void 0?(i.clientOid=n,r?a="privateDeleteStopOrderCancelOrderByClientOid":a="privateDeleteOrderClientOrderClientOid"):(r&&(a="privateDeleteStopOrderOrderId"),i.orderId=e),s=this.omit(s,["clientOid","clientOrderId","stop"]),await this[a](this.extend(i,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;e!==void 0&&(i=this.market(e),s.symbol=i.id);let n="privateDeleteOrders";return this.safeValue(t,"stop")&&(n="privateDeleteStopOrderCancel"),await this[n](this.extend(s,t))}async fetchOrdersByStatus(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r=e.toLowerCase();r==="open"?r="active":r==="closed"&&(r="done");const a={status:r};let o;t!==void 0&&(o=this.market(t),a.symbol=o.id),s!==void 0&&(a.startAt=s),i!==void 0&&(a.pageSize=i);const d=this.safeInteger2(n,"until","till");d&&(a.endAt=d);const c=this.safeValue(n,"stop");n=this.omit(n,["stop","till","until"]);let u="privateGetOrders";c&&(u="privateGetStopOrder");const h=await this[u](this.extend(a,n)),l=this.safeValue(h,"data",{}),p=this.safeValue(l,"items",[]);return this.parseOrders(p,o,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("done",e,t,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("active",e,t,s,i)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={},n=this.safeString2(s,"clientOid","clientOrderId"),r=this.safeValue(s,"stop");let a;t!==void 0&&(a=this.market(t)),s=this.omit(s,"stop");let o="privateGetOrdersOrderId";if(n!==void 0)i.clientOid=n,r?(o="privateGetStopOrderQueryOrderByClientOid",t!==void 0&&(i.symbol=a.id)):o="privateGetOrderClientOrderClientOid";else{if(e===void 0)throw new On(this.id+" fetchOrder() requires an order id");r&&(o="privateGetStopOrderOrderId"),i.orderId=e}s=this.omit(s,["clientOid","clientOrderId"]);const d=await this[o](this.extend(i,s));let c=this.safeValue(d,"data");return o==="privateGetStopOrderQueryOrderByClientOid"&&(c=this.safeValue(c,0)),this.parseOrder(c,a)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t,"-"),n=this.safeString(e,"id"),r=this.safeString(e,"type"),a=this.safeInteger(e,"createdAt"),o=this.iso8601(a),d=this.safeString(e,"price"),c=this.safeString(e,"side"),u=this.safeString(e,"feeCurrency"),h=this.safeCurrencyCode(u),l=this.safeNumber(e,"fee"),p=this.safeString(e,"size"),m=this.safeString(e,"dealSize"),g=this.safeString(e,"dealFunds"),y=this.safeValue(e,"isActive",!1),b=this.safeValue(e,"cancelExist",!1),w=this.safeString(e,"stop"),k=this.safeValue(e,"stopTriggered",!1);let T=y?"open":"closed";T=b||!y&&w&&!k?"canceled":T;const x={currency:h,cost:l},C=this.safeString(e,"clientOid"),E=this.safeString(e,"timeInForce"),P=this.safeNumber(e,"stopPrice"),_=this.safeValue(e,"postOnly");return this.safeOrder({id:n,clientOrderId:C,symbol:i,type:r,timeInForce:E,postOnly:_,side:c,amount:p,price:d,stopPrice:P,cost:g,filled:m,remaining:void 0,timestamp:a,datetime:o,fee:x,status:T,info:e,lastTradeTimestamp:void 0,average:void 0,trades:void 0},t)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){const r={orderId:e};return await this.fetchMyTrades(t,s,i,this.extend(r,n))}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),s!==void 0&&(n.pageSize=s);const a=this.options.fetchMyTradesMethod;let o=!1;if(a==="private_get_fills")t!==void 0&&(n.startAt=t);else if(a==="private_get_limit_fills")o=!0;else if(a==="private_get_hist_orders")t!==void 0&&(n.startAt=parseInt(t/1e3));else throw new Go(this.id+" fetchMyTradesMethod() invalid method");const d=await this[a](this.extend(n,i)),c=this.safeValue(d,"data",{});let u;return o?u=c:u=this.safeValue(c,"items",[]),this.parseTrades(u,r,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.publicGetMarketHistories(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,"-");const i=this.safeString2(e,"tradeId","id"),n=this.safeString(e,"orderId"),r=this.safeString(e,"liquidity");let a=this.safeInteger(e,"time");a!==void 0?a=parseInt(a/1e6):(a=this.safeInteger(e,"createdAt"),"dealValue"in e&&a!==void 0&&(a=a*1e3));const o=this.safeString2(e,"price","dealPrice"),d=this.safeString2(e,"size","amount"),c=this.safeString(e,"side");let u;const h=this.safeString(e,"fee");if(h!==void 0){const m=this.safeString(e,"feeCurrency");let g=this.safeCurrencyCode(m);g===void 0&&(g=c==="sell"?t.quote:t.base),u={cost:h,currency:g,rate:this.safeString(e,"feeRate")}}let l=this.safeString(e,"type");l==="match"&&(l=void 0);const p=this.safeString2(e,"funds","dealValue");return this.safeTrade({info:e,id:i,order:n,timestamp:a,datetime:this.iso8601(a),symbol:t.symbol,type:l,takerOrMaker:r,side:c,price:o,amount:d,cost:p,fee:u},t)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbols:s.id},n=await this.privateGetTradeFees(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0),o=this.safeString(a,"symbol");return{info:n,symbol:this.safeSymbol(o,s),maker:this.safeNumber(a,"makerFeeRate"),taker:this.safeNumber(a,"takerFeeRate"),percentage:!0,tierBased:!0}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets(),this.checkAddress(s);const r=this.currency(e),a={currency:r.id,address:s,amount:t};i!==void 0&&(a.memo=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeStringLower(o,d,d),d!==void 0&&(d=d.toLowerCase(),a.chain=d,n=this.omit(n,"network"));const c=await this.privatePostWithdrawals(this.extend(a,n)),u=this.safeValue(c,"data",{});return this.parseTransaction(u,r)}parseTransactionStatus(e){const t={SUCCESS:"ok",PROCESSING:"ok",FAILURE:"failed"};return this.safeString(t,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"currency"),i=this.safeCurrencyCode(s,t);let n=this.safeString(e,"address");const r=this.safeString(e,"amount");let a=this.safeString(e,"walletTxId");if(a!==void 0){const y=a.split("@");y.length>1&&n===void 0&&y[1].length>1&&(n=y[1]),a=y[0]}let o=a===void 0?"withdrawal":"deposit";const d=this.safeString(e,"status");let c;const u=this.safeString(e,"fee");if(u!==void 0){let y;r!==void 0&&(y=Uo.stringDiv(u,r)),c={cost:this.parseNumber(u),rate:this.parseNumber(y),currency:i}}let h=this.safeInteger2(e,"createdAt","createAt"),l=this.safeInteger(e,"updatedAt");!("createdAt"in e)&&(o="address"in e?"withdrawal":"deposit",h!==void 0&&(h=h*1e3),l!==void 0&&(l=l*1e3));const m=this.safeString(e,"memo"),g=this.safeString(e,"chain");return{info:e,id:this.safeString2(e,"id","withdrawalId"),timestamp:h,datetime:this.iso8601(h),network:g,address:n,addressTo:n,addressFrom:void 0,tag:m,tagTo:m,tagFrom:void 0,currency:i,amount:this.parseNumber(r),txid:a,type:o,status:this.parseTransactionStatus(d),comment:this.safeString(e,"remark"),fee:c,updated:l}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.pageSize=s);let a="privateGetDeposits";t!==void 0&&(t<1550448e6?(n.startAt=parseInt(t/1e3),a="privateGetHistDeposits"):n.startAt=t);const d=(await this[a](this.extend(n,i))).data.items;return this.parseTransactions(d,r,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.pageSize=s);let a="privateGetWithdrawals";t!==void 0&&(t<1550448e6?(n.startAt=parseInt(t/1e3),a="privateGetHistWithdrawals"):n.startAt=t);const d=(await this[a](this.extend(n,i))).data.items;return this.parseTransactions(d,r,t,s,{type:"withdrawal"})}parseBalanceHelper(e){const t=this.account();t.used=this.safeString(e,"holdBalance"),t.free=this.safeString(e,"availableBalance"),t.total=this.safeString(e,"totalBalance");const s=this.safeString(e,"liability"),i=this.safeString(e,"interest");return t.debt=Uo.stringAdd(s,i),t}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"code");let s;t!==void 0&&(s=this.currency(t));const i=this.safeString2(this.options,"fetchBalance","defaultType","spot"),n=this.safeString(e,"type",i),r=this.safeValue(this.options,"accountsByType"),a=this.safeString(r,n,n);e=this.omit(e,"type");const[o,d]=this.handleMarginModeAndParams("fetchBalance",e);let c="privateGetAccounts";const u={},h=o==="isolated"||a==="isolated",l=o==="cross"||a==="cross";h?(c="privateGetIsolatedAccounts",s!==void 0&&(u.balanceCurrency=s.id)):l?c="privateGetMarginAccount":(s!==void 0&&(u.currency=s.id),u.type=a);const p=await this[c](this.extend(u,d)),m=this.safeValue(p,"data",[]),g={info:p,timestamp:void 0,datetime:void 0};if(h){const y=this.safeValue(m,"assets",[]);for(let b=0;b<y.length;b++){const w=y[b],k=this.safeString(w,"symbol"),T=this.safeSymbol(k,void 0,"_"),O=this.safeValue(w,"baseAsset",{}),x=this.safeValue(w,"quoteAsset",{}),C=this.safeCurrencyCode(this.safeString(O,"currency")),E=this.safeCurrencyCode(this.safeString(x,"currency")),P={};P[C]=this.parseBalanceHelper(O),P[E]=this.parseBalanceHelper(x),g[T]=this.safeBalance(P)}}else if(l){const y=this.safeValue(m,"accounts",[]);for(let b=0;b<y.length;b++){const w=y[b],k=this.safeString(w,"currency"),T=this.safeCurrencyCode(k);g[T]=this.parseBalanceHelper(w)}}else for(let y=0;y<m.length;y++){const b=m[y];if(this.safeString(b,"type")===a){const k=this.safeString(b,"currency"),T=this.safeCurrencyCode(k),O=this.account();O.total=this.safeString(b,"balance"),O.free=this.safeString(b,"available"),O.used=this.safeString(b,"holds"),g[T]=O}}return h?g:this.safeBalance(g)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.currencyToPrecision(e,t);let o=this.convertTypeToAccount(s),d=this.convertTypeToAccount(i);const c=this.inArray(o,this.ids),u=this.inArray(d,this.ids);if(o==="contract"){if(d!=="main")throw new Go(this.id+" transfer() only supports transferring from futures account to main account");const h={currency:r.id,amount:a};"bizNo"in n||(h.bizNo=this.uuid22());const l=await this.futuresPrivatePostTransferOut(this.extend(h,n)),p=this.safeValue(l,"data");return this.parseTransfer(p,r)}else{const h={currency:r.id,amount:a};(c||u)&&(this.inArray(o,this.ids)&&(h.fromTag=o,o="isolated"),this.inArray(d,this.ids)&&(h.toTag=d,d="isolated")),h.from=o,h.to=d,"clientOid"in n||(h.clientOid=this.uuid());const l=await this.privatePostAccountsInnerTransfer(this.extend(h,n)),p=this.safeValue(l,"data"),m=this.parseTransfer(p,r);return this.extend(m,{amount:a,fromAccount:o,toAccount:d})}}parseTransfer(e,t=void 0){const s=this.safeInteger(e,"createdAt"),i=this.safeString(e,"currency"),n=this.safeString(e,"status"),r=this.safeStringLower(e,"payAccountType"),a=this.safeStringLower(e,"recAccountType"),o=this.safeValue(this.options,"accountsByType"),d=this.safeString(o,r,r),c=this.safeString(o,a,a);return{id:this.safeString2(e,"applyId","orderId"),currency:this.safeCurrencyCode(i,t),timestamp:s,datetime:this.iso8601(s),amount:this.safeNumber(e,"amount"),fromAccount:d,toAccount:c,status:this.parseTransferStatus(n),info:e}}parseTransferStatus(e){const t={PROCESSING:"pending"};return this.safeString(t,e,e)}parseLedgerEntryType(e){const t={"Assets Transferred in After Upgrading":"transfer",Deposit:"transaction",Withdrawal:"transaction",Transfer:"transfer",Trade_Exchange:"trade","KuCoin Bonus":"bonus","Referral Bonus":"referral",Rewards:"bonus","Airdrop/Fork":"airdrop","Other rewards":"bonus","Fee Rebate":"rebate","Buy Crypto":"trade","Sell Crypto":"sell","Public Offering Purchase":"trade","Refunded Fees":"fee","KCS Pay Fees":"fee","Margin Trade":"trade",Loans:"Loans","Instant Exchange":"trade","Sub-account transfer":"transfer","Liquidation Fees":"fee"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"currency"),n=this.safeCurrencyCode(i,t),r=this.safeNumber(e,"amount"),a=void 0,o=this.safeString(e,"bizType"),d=this.parseLedgerEntryType(o),c=this.safeString(e,"direction"),u=this.safeInteger(e,"createdAt"),h=this.iso8601(u),l=this.safeString(e,"accountType"),p=this.safeString(e,"context");let m;if(p!==void 0&&p!=="")try{const w=JSON.parse(p),k=this.safeString(w,"orderId"),T=this.safeString(w,"tradeId");T!==void 0?m=T:m=k}catch{m=p}let g;const y=this.safeNumber(e,"fee");let b;return y!==0&&(b=n,g={cost:y,currency:b}),{id:s,direction:c,account:l,referenceId:m,referenceAccount:l,type:d,currency:n,amount:r,timestamp:u,datetime:h,before:void 0,after:a,status:void 0,fee:g,info:e}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.loadAccounts();const n={};t!==void 0&&(n.startAt=t);let r;e!==void 0&&(r=this.currency(e),n.currency=r.id);const a=await this.privateGetAccountsLedgers(this.extend(n,i)),o=this.safeValue(a,"data"),d=this.safeValue(o,"items");return this.parseLedger(d,r,t,s)}calculateRateLimiterCost(e,t,s,i,n={},r={}){const a=this.safeValue(this.options,"versions",{}),o=this.safeValue(a,e,{}),d=this.safeValue(o,t,{}),c=this.safeString(d,s,this.options.version),u=this.safeString(i,"version",c);return u==="v3"&&"v3"in n?n.v3:u==="v2"&&"v2"in n?n.v2:u==="v1"&&"v1"in n?n.v1:this.safeValue(n,"cost",1)}async fetchBorrowRateHistory(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={currency:this.currency(e).id},a=await this.privateGetMarginTradeLast(this.extend(r,i)),o=this.safeValue(a,"data",{});return this.parseBorrowRateHistory(o,e)}parseBorrowRateHistory(e,t,s,i){const n=[];for(let a=0;a<e.length;a++){const o=e[a],d=this.parseBorrowRate(o);n.push(d)}const r=this.sortBy(n,"timestamp");return this.filterByCurrencySinceLimit(r,t,s,i)}parseBorrowRate(e,t=void 0){const s=this.safeString(e,"timestamp"),i=Uo.stringMul(s,"0.000001"),n=this.safeString(e,"currency");return{currency:this.safeCurrencyCode(n,t),rate:this.safeNumber(e,"dailyIntRate"),period:864e5,timestamp:i,datetime:this.iso8601(i),info:e}}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;[r,n]=this.handleMarginModeAndParams("fetchBorrowInterest",n),r===void 0&&(r="cross");const a={};let o="privateGetMarginBorrowOutstanding";if(r==="isolated"){if(e!==void 0){const h=this.currency(e);a.balanceCurrency=h.id}o="privateGetIsolatedAccounts"}else if(e!==void 0){const h=this.currency(e);a.currency=h.id}const d=await this[o](this.extend(a,n)),c=this.safeValue(d,"data",{}),u=r==="isolated"?this.safeValue(c,"assets",[]):this.safeValue(c,"items",[]);return this.parseBorrowInterests(u,void 0)}parseBorrowInterest(e,t=void 0){const s=this.safeString(e,"symbol"),i=s===void 0?"cross":"isolated";t=this.safeMarket(s,t);const n=this.safeString(t,"symbol"),r=this.safeInteger(e,"createdAt"),a=this.safeValue(e,"baseAsset",{});let o,d,c;return i==="isolated"?(o=this.safeNumber(a,"liability"),d=this.safeNumber(a,"interest"),c=this.safeString(a,"currency")):(o=this.safeNumber(e,"principal"),d=this.safeNumber(e,"accruedInterest"),c=this.safeString(e,"currency")),{symbol:n,marginMode:i,currency:this.safeCurrencyCode(c),interest:d,interestRate:this.safeNumber(e,"dailyIntRate"),amountBorrowed:o,timestamp:r,datetime:this.iso8601(r),info:e}}async borrowMargin(e,t,s=void 0,i={}){const n=this.safeString(i,"marginMode");i=this.omit(i,"marginMode"),this.checkRequiredMarginArgument("borrowMargin",s,n),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,size:this.currencyToPrecision(e,t)};let o;const d=this.safeStringN(i,["timeInForce","type","borrowStrategy"],"IOC");let c;if(s===void 0)o="privatePostMarginBorrow",c="type";else{const l=this.market(s);a.symbol=l.id,c="borrowStrategy",o="privatePostIsolatedBorrow"}a[c]=d,i=this.omit(i,["timeInForce","type","borrowStrategy"]);const u=await this[o](this.extend(a,i)),h=this.safeValue(u,"data",{});return this.parseMarginLoan(h,r)}async repayMargin(e,t,s=void 0,i={}){const n=this.safeString(i,"marginMode");i=this.omit(i,"marginMode"),this.checkRequiredMarginArgument("repayMargin",s,n),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,size:this.currencyToPrecision(e,t)};let o;const d=this.safeString2(i,"sequence","seqStrategy","RECENTLY_EXPIRE_FIRST");let c;if(s===void 0)o="privatePostMarginRepayAll",c="sequence";else{const h=this.market(s);a.symbol=h.id,c="seqStrategy",o="privatePostIsolatedRepayAll"}a[c]=d,i=this.omit(i,["sequence","seqStrategy"]);const u=await this[o](this.extend(a,i));return this.parseMarginLoan(u,r)}parseMarginLoan(e,t=void 0){const s=this.milliseconds(),i=this.safeString(e,"currency");return{id:this.safeString(e,"orderId"),currency:this.safeCurrencyCode(i,t),amount:this.safeNumber(e,"actualSize"),symbol:void 0,timestamp:s,datetime:this.iso8601(s),info:e}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.safeValue(this.options,"versions",{}),o=this.safeValue(a,t,{}),d=this.safeValue(o,s,{}),c=this.safeString(d,e,this.options.version),u=this.safeString(i,"version",c);i=this.omit(i,"version");let h="/api/"+u+"/"+this.implodeParams(e,i);const l=this.omit(i,this.extractParams(e));let p="";n=n!==void 0?n:{};let m=this.urls.api[t];const g=m.indexOf("sandbox")>=0;e==="symbols"&&!g&&(h="/api/v2/"+this.implodeParams(e,i)),Object.keys(l).length&&(s==="GET"||s==="DELETE"?h+="?"+this.rawencode(l):(r=this.json(l),p=r,n["Content-Type"]="application/json")),m=m+h;const y=t==="futuresPrivate";if(t==="private"||y){this.checkRequiredCredentials();const w=this.nonce().toString();if(n=this.extend({"KC-API-KEY-VERSION":"2","KC-API-KEY":this.apiKey,"KC-API-TIMESTAMP":w},n),this.safeString(n,"KC-API-KEY-VERSION")==="2"){const P=this.hmac(this.encode(this.password),this.encode(this.secret),"sha256","base64");n["KC-API-PASSPHRASE"]=P}else n["KC-API-PASSPHRASE"]=this.password;const T=w+s+h+p,O=this.hmac(this.encode(T),this.encode(this.secret),"sha256","base64");n["KC-API-SIGN"]=O;let x=this.safeValue(this.options,"partner",{});x=y?this.safeValue(x,"future",x):this.safeValue(x,"spot",x);const C=this.safeString(x,"id"),E=this.safeString2(x,"secret","key");if(C!==void 0&&E!==void 0){const P=w+C+this.apiKey,_=this.hmac(this.encode(P),this.encode(E),"sha256","base64");n["KC-API-PARTNER-SIGN"]=_,n["KC-API-PARTNER"]=C}}return{url:m,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(!a){this.throwBroadlyMatchedException(this.exceptions.broad,r,r);return}const c=this.safeString(a,"code"),u=this.safeString(a,"msg",""),h=this.id+" "+u;this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwExactlyMatchedException(this.exceptions.exact,c,h),this.throwBroadlyMatchedException(this.exceptions.broad,r,h)}};const{ArgumentsRequired:j0,ExchangeNotAvailable:W0,InvalidOrder:Jf,InsufficientFunds:eh,AccountSuspended:uH,InvalidNonce:fH,NotSupported:th,OrderNotFound:hH,BadRequest:ci,AuthenticationError:Wa,RateLimitExceeded:lH,PermissionDenied:pH}=de,Ys=Se,mH=Bb,{TICK_SIZE:gH}=me;var yH=class extends mH{describe(){return this.deepExtend(super.describe(),{id:"kucoinfutures",name:"KuCoin Futures",countries:["SC"],rateLimit:75,version:"v1",certified:!1,pro:!1,comment:"Platform 2.0",quoteJsonNumbers:!1,has:{CORS:void 0,spot:!1,margin:!1,swap:!0,future:!0,option:!1,addMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!1,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!1,fetchIndexOHLCV:!1,fetchL3OrderBook:!0,fetchLedger:!0,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarketLeverageTiers:!0,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!1,fetchTime:!0,fetchTrades:!0,fetchTransactionFee:!0,fetchWithdrawals:!0,setMarginMode:!1,transfer:!0,withdraw:void 0},urls:{logo:"https://user-images.githubusercontent.com/1294454/147508995-9e35030a-d046-43a1-a006-6fabd981b554.jpg",doc:["https://docs.kucoin.com/futures","https://docs.kucoin.com"],www:"https://futures.kucoin.com/",referral:"https://futures.kucoin.com/?rcode=E5wkqe",api:{public:"https://openapi-v2.kucoin.com",private:"https://openapi-v2.kucoin.com",futuresPrivate:"https://api-futures.kucoin.com",futuresPublic:"https://api-futures.kucoin.com"},test:{public:"https://openapi-sandbox.kucoin.com",private:"https://openapi-sandbox.kucoin.com",futuresPrivate:"https://api-sandbox-futures.kucoin.com",futuresPublic:"https://api-sandbox-futures.kucoin.com"}},requiredCredentials:{apiKey:!0,secret:!0,password:!0},api:{futuresPublic:{get:{"contracts/active":1,"contracts/{symbol}":1,"contracts/risk-limit/{symbol}":1,ticker:1,"level2/snapshot":1.33,"level2/depth{limit}":1,"level2/message/query":1,"level3/message/query":1,"level3/snapshot":1,"trade/history":1,"interest/query":1,"index/query":1,"mark-price/{symbol}/current":1,"premium/query":1,"funding-rate/{symbol}/current":1,timestamp:1,status:1,"kline/query":1},post:{"bullet-public":1}},futuresPrivate:{get:{"account-overview":1.33,"transaction-history":4.44,"deposit-address":1,"deposit-list":1,"withdrawals/quotas":1,"withdrawal-list":1,"transfer-list":1,orders:1.33,stopOrders:1,recentDoneOrders:1,"orders/{orderId}":1,"orders/byClientOid":1,fills:4.44,recentFills:4.44,openOrderStatistics:1,position:1,positions:4.44,"funding-history":4.44},post:{withdrawals:1,"transfer-out":1,orders:1.33,"position/margin/auto-deposit-status":1,"position/margin/deposit-margin":1,"bullet-private":1},delete:{"withdrawals/{withdrawalId}":1,"cancel/transfer-out":1,"orders/{orderId}":1,orders:4.44,stopOrders:1}}},precisionMode:gH,exceptions:{exact:{400:ci,401:Wa,403:th,404:th,405:th,415:ci,429:lH,500:W0,503:W0,100001:Jf,100004:ci,101030:pH,200004:eh,230003:eh,260100:eh,300003:eh,300012:Jf,400001:Wa,400002:fH,400003:Wa,400004:Wa,400005:Wa,400006:Wa,400007:Wa,404e3:th,400100:ci,411100:uH,5e5:W0},broad:{"Position does not exist":hH}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0006"),maker:this.parseNumber("0.0002"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.0006")],[this.parseNumber("50"),this.parseNumber("0.0006")],[this.parseNumber("200"),this.parseNumber("0.0006")],[this.parseNumber("500"),this.parseNumber("0.0005")],[this.parseNumber("1000"),this.parseNumber("0.0004")],[this.parseNumber("2000"),this.parseNumber("0.0004")],[this.parseNumber("4000"),this.parseNumber("0.00038")],[this.parseNumber("8000"),this.parseNumber("0.00035")],[this.parseNumber("15000"),this.parseNumber("0.00032")],[this.parseNumber("25000"),this.parseNumber("0.0003")],[this.parseNumber("40000"),this.parseNumber("0.0003")],[this.parseNumber("60000"),this.parseNumber("0.0003")],[this.parseNumber("80000"),this.parseNumber("0.0003")]],maker:[[this.parseNumber("0"),this.parseNumber("0.02")],[this.parseNumber("50"),this.parseNumber("0.015")],[this.parseNumber("200"),this.parseNumber("0.01")],[this.parseNumber("500"),this.parseNumber("0.01")],[this.parseNumber("1000"),this.parseNumber("0.01")],[this.parseNumber("2000"),this.parseNumber("0")],[this.parseNumber("4000"),this.parseNumber("0")],[this.parseNumber("8000"),this.parseNumber("0")],[this.parseNumber("15000"),this.parseNumber("-0.003")],[this.parseNumber("25000"),this.parseNumber("-0.006")],[this.parseNumber("40000"),this.parseNumber("-0.009")],[this.parseNumber("60000"),this.parseNumber("-0.012")],[this.parseNumber("80000"),this.parseNumber("-0.015")]]}},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}},commonCurrencies:{HOT:"HOTNOW",EDGE:"DADI",WAX:"WAXP",TRY:"Trias",VAI:"VAIOT",XBT:"BTC"},timeframes:{"1m":1,"3m":void 0,"5m":5,"15m":15,"30m":30,"1h":60,"2h":120,"4h":240,"6h":void 0,"8h":480,"12h":720,"1d":1440,"1w":10080},options:{version:"v1",symbolSeparator:"-",defaultType:"swap",code:"USDT",marginModes:{},marginTypes:{},versions:{futuresPrivate:{POST:{"transfer-out":"v2"}},futuresPublic:{GET:{"level3/snapshot":"v2"}}},networks:{OMNI:"omni",ERC20:"eth",TRC20:"trx"}}})}async fetchAccounts(e={}){throw new ci(this.id+" fetchAccounts() is not supported yet")}async fetchStatus(e={}){const t=await this.futuresPublicGetStatus(e),s=this.safeValue(t,"data",{});return{status:this.safeString(s,"status")==="open"?"ok":"maintenance",updated:void 0,eta:void 0,url:void 0,info:t}}async fetchMarkets(e={}){const t=await this.futuresPublicGetContractsActive(e),s=[],i=this.safeValue(t,"data",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"symbol"),o=this.safeInteger(r,"expireDate"),d=!!o,c=!d,u=this.safeString(r,"baseCurrency"),h=this.safeString(r,"quoteCurrency"),l=this.safeString(r,"settleCurrency"),p=this.safeCurrencyCode(u),m=this.safeCurrencyCode(h),g=this.safeCurrencyCode(l);let y=p+"/"+m+":"+g,b="swap";d&&(y=y+"-"+this.yymmdd(o,""),b="future");const w=this.safeValue(r,"isInverse"),k=this.safeString(r,"status"),T=this.safeString(r,"multiplier"),O=this.safeNumber(r,"tickSize"),x=this.safeNumber(r,"lotSize");let C=x;C===void 0&&(C=this.safeNumber(r,"baseMinSize"));let E=this.safeNumber(r,"maxOrderQty");E===void 0&&(E=this.safeNumber(r,"baseMaxSize"));let P=this.safeNumber(r,"maxPrice");if(P===void 0){const _=this.safeString(r,"baseMinSize"),S=this.safeString(r,"quoteMaxSize");P=this.parseNumber(Ys.stringDiv(S,_))}s.push({id:a,symbol:y,base:p,quote:m,settle:g,baseId:u,quoteId:h,settleId:l,type:b,spot:!1,margin:!1,swap:c,future:d,option:!1,active:k==="Open",contract:!0,linear:!w,inverse:w,taker:this.safeNumber(r,"takerFeeRate"),maker:this.safeNumber(r,"makerFeeRate"),contractSize:this.parseNumber(Ys.stringAbs(T)),expiry:o,expiryDatetime:this.iso8601(o),strike:void 0,optionType:void 0,precision:{amount:x,price:O},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(r,"maxLeverage")},amount:{min:C,max:E},price:{min:O,max:P},cost:{min:this.safeNumber(r,"quoteMinSize"),max:this.safeNumber(r,"quoteMaxSize")}},info:r})}return s}async fetchTime(e={}){const t=await this.futuresPublicGetTimestamp(e);return this.safeNumber(t,"data")}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),o={symbol:r.id,granularity:this.timeframes[t]},d=this.parseTimeframe(t)*1e3;let c=this.milliseconds();s!==void 0?(o.from=s,i===void 0&&(i=this.safeInteger(this.options,"fetchOHLCVLimit",200)),c=this.sum(s,i*d)):i!==void 0&&(s=c-i*d,o.from=s),o.to=c;const u=await this.futuresPublicGetKlineQuery(this.extend(o,n)),h=this.safeValue(u,"data",[]);return this.parseOHLCVs(h,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async createDepositAddress(e,t={}){throw new ci(this.id+" createDepositAddress() is not supported yet")}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i=this.currency(e).id,n={currency:i},r=await this.futuresPrivateGetDepositAddress(this.extend(n,t)),a=this.safeValue(r,"data",{}),o=this.safeString(a,"address");return i!=="NIM"&&this.checkAddress(o),{info:r,currency:i,address:o,tag:this.safeString(a,"memo"),network:this.safeString(a,"chain")}}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeNumber(s,"level");if(i!==2&&i!==void 0)throw new ci(this.id+" fetchOrderBook() can only return level 2");const n=this.market(e),r={symbol:n.id};if(t!==void 0)if(t===20||t===100)r.limit=t;else throw new ci(this.id+" fetchOrderBook() limit argument must be 20 or 100");else r.limit=20;const a=await this.futuresPublicGetLevel2DepthLimit(this.extend(r,s)),o=this.safeValue(a,"data",{}),d=parseInt(this.safeInteger(o,"ts")/1e6),c=this.parseOrderBook(o,n.symbol,d,"bids","asks",0,1);return c.nonce=this.safeInteger(o,"sequence"),c}async fetchL3OrderBook(e,t=void 0,s={}){throw new ci(this.id+" fetchL3OrderBook() is not supported yet")}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.futuresPublicGetTicker(this.extend(i,t));return this.parseTicker(n.data,s)}parseTicker(e,t=void 0){const s=this.safeString(e,"price"),i=this.safeString(e,"symbol");t=this.safeMarket(i,t,"-");const n=this.safeIntegerProduct(e,"ts",1e-6);return this.safeTicker({symbol:t.symbol,timestamp:n,datetime:this.iso8601(n),high:void 0,low:void 0,bid:this.safeString(e,"bestBidPrice"),bidVolume:this.safeString(e,"bestBidSize"),ask:this.safeString(e,"bestAskPrice"),askVolume:this.safeString(e,"bestAskSize"),vwap:void 0,open:void 0,close:s,last:s,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:void 0,info:e},t)}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new j0(this.id+" fetchFundingHistory() requires a symbol argument");await this.loadMarkets();const r={symbol:this.market(e).id};t!==void 0&&(r.startAt=t),s!==void 0&&(r.maxCount=s);const a=await this.futuresPrivateGetFundingHistory(this.extend(r,i)),o=this.safeValue(a,"data"),d=this.safeValue(o,"dataList",[]),c=[];for(let u=0;u<d.length;u++){const h=d[u],l=this.safeInteger(h,"timePoint");c.push({info:h,symbol:e,code:this.safeCurrencyCode(this.safeString(h,"settleCurrency")),timestamp:l,datetime:this.iso8601(l),id:this.safeNumber(h,"id"),amount:this.safeNumber(h,"funding"),fundingRate:this.safeNumber(h,"fundingRate"),markPrice:this.safeNumber(h,"markPrice"),positionQty:this.safeNumber(h,"positionQty"),positionCost:this.safeNumber(h,"positionCost")})}return c}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.futuresPrivateGetPositions(t),i=this.safeValue(s,"data");return this.parsePositions(i,e)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeNumber(e,"currentTimestamp"),n=this.safeString(e,"currentQty");let r;Ys.stringGt(n,"0")?r="long":Ys.stringLt(n,"0")&&(r="short");const a=Ys.stringAbs(this.safeString(e,"posCost")),o=this.safeString(e,"posInit"),d=Ys.stringDiv(o,a),c=this.safeString(e,"unrealisedPnl"),h=this.safeValue(e,"crossMode")?"cross":"isolated";return{info:e,id:void 0,symbol:this.safeString(t,"symbol"),timestamp:i,datetime:this.iso8601(i),initialMargin:this.parseNumber(o),initialMarginPercentage:this.parseNumber(d),maintenanceMargin:this.safeNumber(e,"posMaint"),maintenanceMarginPercentage:this.safeNumber(e,"maintMarginReq"),entryPrice:this.safeNumber(e,"avgEntryPrice"),notional:this.parseNumber(a),leverage:this.safeNumber(e,"realLeverage"),unrealizedPnl:this.parseNumber(c),contracts:this.parseNumber(Ys.stringAbs(n)),contractSize:this.safeValue(t,"contractSize"),marginRatio:void 0,liquidationPrice:this.safeNumber(e,"liquidationPrice"),markPrice:this.safeNumber(e,"markPrice"),collateral:this.safeNumber(e,"maintMargin"),marginMode:h,side:r,percentage:this.parseNumber(Ys.stringDiv(c,o))}}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeString2(r,"clientOid","clientOrderId",this.uuid());if(r=this.omit(r,["clientOid","clientOrderId"]),i<1)throw new Jf(this.id+" createOrder() minimum contract order amount is 1");const d=parseInt(this.amountToPrecision(e,i)),c={clientOid:o,side:s,symbol:a.id,type:t,size:d,leverage:1},u=this.safeValue2(r,"triggerPrice","stopPrice");if(u){c.stop=s==="buy"?"up":"down";const w=this.safeString(r,"stopPriceType","TP");c.stopPriceType=w,c.stopPrice=this.priceToPrecision(e,u)}const h=t.toUpperCase(),l=this.safeStringUpper(r,"timeInForce");if(h==="LIMIT"){if(n===void 0)throw new j0(this.id+" createOrder() requires a price argument for limit orders");c.price=this.priceToPrecision(e,n),l!==void 0&&(c.timeInForce=l)}const p=this.safeValue(r,"postOnly",!1),m=this.safeValue(r,"hidden");if(p&&m!==void 0)throw new ci(this.id+" createOrder() does not support the postOnly parameter together with a hidden parameter");if(this.safeValue(r,"iceberg")&&this.safeValue(r,"visibleSize")===void 0)throw new j0(this.id+" createOrder() requires a visibleSize parameter for iceberg orders");r=this.omit(r,["timeInForce","stopPrice","triggerPrice"]);const y=await this.futuresPrivatePostOrders(this.extend(c,r)),b=this.safeValue(y,"data",{});return{id:this.safeString(b,"orderId"),clientOrderId:void 0,timestamp:void 0,datetime:void 0,lastTradeTimestamp:void 0,symbol:void 0,type:void 0,side:void 0,price:void 0,amount:void 0,cost:void 0,average:void 0,filled:void 0,remaining:void 0,status:void 0,fee:void 0,trades:void 0,timeInForce:void 0,postOnly:void 0,stopPrice:void 0,info:y}}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e},n=await this.futuresPrivateDeleteOrdersOrderId(this.extend(i,s));return this.safeValue(n,"data")}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};e!==void 0&&(s.symbol=this.marketId(e));const n=this.safeValue(t,"stop")?"futuresPrivateDeleteStopOrders":"futuresPrivateDeleteOrders",r=await this[n](this.extend(s,t));return this.safeValue(r,"data")}async addMargin(e,t,s={}){await this.loadMarkets();const i=this.market(e),n=this.uuid(),r={symbol:i.id,margin:this.amountToPrecision(e,t),bizNo:n},a=await this.futuresPrivatePostPositionMarginDepositMargin(this.extend(r,s)),o=this.safeValue(a,"data");return this.extend(this.parseMarginModification(o,i),{amount:this.amountToPrecision(e,t),direction:"in"})}parseMarginModification(e,t=void 0){const s=this.safeString(e,"id");t=this.safeMarket(s,t);const i=this.safeString(e,"settleCurrency"),r=this.safeValue(e,"crossMode")?"cross":"isolated",a=this.safeString(t,"symbol");return{info:e,direction:void 0,mode:r,amount:void 0,code:this.safeCurrencyCode(i),symbol:this.safeSymbol(a,t),status:void 0}}async fetchOrdersByStatus(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.safeValue(n,"stop"),a=this.safeInteger2(n,"until","till");n=this.omit(n,["stop","until","till"]),e==="closed"?e="done":e==="open"&&(e="active");const o={};if(!r)o.status=e;else if(e!=="active")throw new ci(this.id+" fetchOrdersByStatus() can only fetch untriggered stop orders");let d;t!==void 0&&(d=this.market(t),o.symbol=d.id),s!==void 0&&(o.startAt=s),a!==void 0&&(o.endAt=a);const u=await this[r?"futuresPrivateGetStopOrders":"futuresPrivateGetOrders"](this.extend(o,n)),h=this.safeValue(u,"data",{}),l=this.safeValue(h,"items",[]);return this.parseOrders(l,d,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("done",e,t,s,i)}async fetchOrder(e=void 0,t=void 0,s={}){await this.loadMarkets();const i={};let n="futuresPrivateGetOrdersOrderId";if(e===void 0){const d=this.safeString2(s,"clientOid","clientOrderId");if(d===void 0)throw new Jf(this.id+" fetchOrder() requires parameter id or params.clientOid");i.clientOid=d,n="futuresPrivateGetOrdersByClientOid",s=this.omit(s,["clientOid","clientOrderId"])}else i.orderId=e;const r=await this[n](this.extend(i,s)),a=t!==void 0?this.market(t):void 0,o=this.safeValue(r,"data");return this.parseOrder(o,a)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeString(e,"id"),r=this.safeString(e,"type"),a=this.safeInteger(e,"createdAt"),o=this.iso8601(a),d=this.safeString(e,"price"),c=this.safeString(e,"side"),u=this.safeString(e,"feeCurrency"),h=this.safeCurrencyCode(u),l=this.safeNumber(e,"fee"),p=this.safeString(e,"size"),m=this.safeString(e,"dealSize"),g=this.safeString2(e,"dealFunds","filledValue"),y=this.safeString(e,"leverage"),b=Ys.stringDiv(g,y);let w;if(Ys.stringGt(m,"0")){const S=this.safeString(t,"contractSize");t.linear?w=Ys.stringDiv(g,Ys.stringMul(S,m)):w=Ys.stringDiv(Ys.stringMul(S,m),g)}const k=this.safeValue(e,"isActive",!1),T=this.safeValue(e,"cancelExist",!1);let O=k?"open":"closed";O=T?"canceled":O;const x={currency:h,cost:l},C=this.safeString(e,"clientOid"),E=this.safeString(e,"timeInForce"),P=this.safeNumber(e,"stopPrice"),_=this.safeValue(e,"postOnly");return this.safeOrder({id:n,clientOrderId:C,symbol:i,type:r,timeInForce:E,postOnly:_,side:c,amount:p,price:d,stopPrice:P,cost:b,filled:m,remaining:void 0,timestamp:a,datetime:o,fee:x,status:O,info:e,lastTradeTimestamp:void 0,average:w,trades:void 0},t)}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.futuresPublicGetFundingRateSymbolCurrent(this.extend(i,t)),r=this.safeValue(n,"data"),a=this.safeNumber(r,"timePoint");return{info:r,symbol:s.symbol,markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeNumber(r,"predictedValue"),fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:this.safeNumber(r,"value"),previousFundingTimestamp:a,previousFundingDatetime:this.iso8601(a)}}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"data"),i=this.safeString(s,"currency"),n=this.safeCurrencyCode(i),r=this.account();return r.free=this.safeString(s,"availableBalance"),r.total=this.safeString(s,"accountEquity"),t[n]=r,this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();let t=this.safeString(this.options,"code");const s=this.safeValue(this.options,"fetchBalance",{});t=this.safeString(s,"code",t);const i=this.safeString(e,"code",t),r={currency:this.currency(i).id},a=await this.futuresPrivateGetAccountOverview(this.extend(r,e));return this.parseBalance(a)}async transfer(e,t,s,i,n={}){if(i!=="main"&&i!=="funding"||s!=="futures"&&s!=="future"&&s!=="contract")throw new ci(this.id+" transfer() only supports transfers from contract(future) account to main(funding) account");await this.loadMarkets();const r=this.currency(e),a=this.currencyToPrecision(e,t),o={currency:this.safeString(r,"id"),amount:a},d=await this.futuresPrivatePostTransferOut(this.extend(o,n)),c=this.safeValue(d,"data");return this.extend(this.parseTransfer(c,r),{amount:this.parseNumber(a),fromAccount:"future",toAccount:"spot"})}parseTransfer(e,t=void 0){const s=this.safeInteger(e,"updatedAt");return{id:this.safeString(e,"applyId"),timestamp:s,datetime:this.iso8601(s),currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:this.safeString(e,"status"),info:e}}parseTransferStatus(e){const t={PROCESSING:"pending"};return this.safeString(t,e,e)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),t!==void 0&&(n.startAt=t);const a=await this.futuresPrivateGetFills(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"items",{});return this.parseTrades(d,r,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.futuresPublicGetTradeHistory(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,"-");const i=this.safeString2(e,"tradeId","id"),n=this.safeString(e,"orderId"),r=this.safeString(e,"liquidity");let a=this.safeInteger(e,"ts");a!==void 0?a=parseInt(a/1e6):(a=this.safeInteger(e,"createdAt"),"dealValue"in e&&a!==void 0&&(a=a*1e3));const o=this.safeString2(e,"price","dealPrice"),d=this.safeString2(e,"size","amount"),c=this.safeString(e,"side");let u;const h=this.safeString(e,"fee");if(h!==void 0){const m=this.safeString(e,"feeCurrency");let g=this.safeCurrencyCode(m);g===void 0&&(g=c==="sell"?t.quote:t.base),u={cost:h,currency:g,rate:this.safeString(e,"feeRate")}}let l=this.safeString2(e,"type","orderType");l==="match"&&(l=void 0);let p=this.safeString2(e,"funds","value");if(p===void 0){const m=this.safeString(t,"contractSize"),g=Ys.stringMul(o,d);p=Ys.stringMul(g,m)}return this.safeTrade({info:e,id:i,order:n,timestamp:a,datetime:this.iso8601(a),symbol:t.symbol,type:l,takerOrMaker:r,side:c,price:o,amount:d,cost:p,fee:u},t)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.pageSize=s),t!==void 0&&(n.startAt=t);const o=(await this.futuresPrivateGetDepositList(this.extend(n,i))).data.items;return this.parseTransactions(o,r,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.pageSize=s),t!==void 0&&(n.startAt=t);const o=(await this.futuresPrivateGetWithdrawalList(this.extend(n,i))).data.items;return this.parseTransactions(o,r,t,s,{type:"withdrawal"})}async fetchTransactionFee(e,t={}){throw new ci(this.id+" fetchTransactionFee() is not supported yet")}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){throw new ci(this.id+" fetchLedger() is not supported yet")}async fetchMarketLeverageTiers(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.contract)throw new ci(this.id+" fetchMarketLeverageTiers() supports contract markets only");const i={symbol:s.id},n=await this.futuresPublicGetContractsRiskLimitSymbol(this.extend(i,t)),r=this.safeValue(n,"data");return this.parseMarketLeverageTiers(r,s)}parseMarketLeverageTiers(e,t){const s=[];for(let i=0;i<e.length;i++){const n=e[i];s.push({tier:this.safeNumber(n,"level"),currency:t.base,minNotional:this.safeNumber(n,"minRiskLimit"),maxNotional:this.safeNumber(n,"maxRiskLimit"),maintenanceMarginRate:this.safeNumber(n,"maintainMargin"),maxLeverage:this.safeNumber(n,"maxLeverage"),info:n})}return s}};const bH=ge,{ArgumentsRequired:Lv,InsufficientFunds:wH,OrderNotFound:Rv,NotSupported:kH}=de,{TICK_SIZE:SH}=me;var vH=class extends bH{describe(){return this.deepExtend(super.describe(),{id:"kuna",name:"Kuna",countries:["UA"],rateLimit:1e3,version:"v2",has:{CORS:void 0,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelOrder:!0,createOrder:!0,fetchBalance:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchL3OrderBook:!0,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:"emulated",fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,reduceMargin:!1,setLeverage:!1,setPositionMode:!1,withdraw:void 0},timeframes:void 0,urls:{extension:".json",referral:"https://kuna.io?r=kunaid-gvfihe8az7o4",logo:"https://user-images.githubusercontent.com/51840849/87153927-f0578b80-c2c0-11ea-84b6-74612568e9e1.jpg",api:{xreserve:"https://api.xreserve.fund",v3:"https://api.kuna.io",public:"https://kuna.io",private:"https://kuna.io"},www:"https://kuna.io",doc:"https://kuna.io/documents/api",fees:"https://kuna.io/documents/api"},api:{xreserve:{get:{nonce:1,fee:1,"delegated-transactions":1},post:{"delegate-transfer":1}},v3:{public:{get:{timestamp:1,currencies:1,markets:1,tickers:1,k:1,trades_history:1,fees:1,"exchange-rates":1,"exchange-rates/currency":1,"book/market":1,"kuna_codes/code/check":1,landing_page_statistic:1,"translations/locale":1,"trades/market/hist":1},post:{http_test:1,deposit_channels:1,withdraw_channels:1,subscription_plans:1,send_to:1,confirm_token:1,kunaid:1,"withdraw/prerequest":1,"deposit/prerequest":1,"deposit/exchange-rates":1}},sign:{get:{"reset_password/token":1},post:{"signup/google":1,"signup/resend_confirmation":1,signup:1,signin:1,"signin/two_factor":1,"signin/resend_confirm_device":1,"signin/confirm_device":1,reset_password:1,"cool-signin":1},put:{"reset_password/token":1,"signup/code/confirm":1}},private:{post:{"auth/w/order/submit":1,"auth/r/orders":1,"auth/r/orders/market":1,"auth/r/orders/markets":1,"auth/api_tokens/delete":1,"auth/api_tokens/create":1,"auth/api_tokens":1,"auth/signin_history/uniq":1,"auth/signin_history":1,"auth/disable_withdraw_confirmation":1,"auth/change_password":1,"auth/deposit_address":1,"auth/announcements/accept":1,"auth/announcements/unaccepted":1,"auth/otp/deactivate":1,"auth/otp/activate":1,"auth/otp/secret":1,"auth/r/order/market/:order_id/trades":1,"auth/r/orders/market/hist":1,"auth/r/orders/hist":1,"auth/r/orders/hist/markets":1,"auth/r/orders/details":1,"auth/assets-history":1,"auth/assets-history/withdraws":1,"auth/assets-history/deposits":1,"auth/r/wallets":1,"auth/markets/favorites":1,"auth/markets/favorites/list":1,"auth/me/update":1,"auth/me":1,"auth/fund_sources":1,"auth/fund_sources/list":1,"auth/withdraw/resend_confirmation":1,"auth/withdraw":1,"auth/withdraw/details":1,"auth/withdraw/info":1,"auth/payment_addresses":1,"auth/deposit/prerequest":1,"auth/deposit/exchange-rates":1,"auth/deposit":1,"auth/deposit/details":1,"auth/deposit/info":1,"auth/kuna_codes/count":1,"auth/kuna_codes/details":1,"auth/kuna_codes/edit":1,"auth/kuna_codes/send-pdf":1,"auth/kuna_codes":1,"auth/kuna_codes/redeemed-by-me":1,"auth/kuna_codes/issued-by-me":1,"auth/payment_requests/invoice":1,"auth/payment_requests/type":1,"auth/referral_program/weekly_earnings":1,"auth/referral_program/stats":1,"auth/merchant/payout_services":1,"auth/merchant/withdraw":1,"auth/merchant/payment_services":1,"auth/merchant/deposit":1,"auth/verification/auth_token":1,"auth/kunaid_purchase/create":1,"auth/devices/list":1,"auth/sessions/list":1,"auth/subscriptions/reactivate":1,"auth/subscriptions/cancel":1,"auth/subscriptions/prolong":1,"auth/subscriptions/create":1,"auth/subscriptions/list":1,"auth/kuna_ids/list":1,"order/cancel/multi":1,"order/cancel":1},put:{"auth/fund_sources/id":1,"auth/kuna_codes/redeem":1},delete:{"auth/markets/favorites":1,"auth/fund_sources":1,"auth/devices":1,"auth/devices/list":1,"auth/sessions/list":1,"auth/sessions":1}}},public:{get:["depth","k_with_pending_trades","k","markets","order_book","order_book/{market}","tickers","tickers/{market}","timestamp","trades","trades/{market}"]},private:{get:["members/me","deposits","deposit","deposit_address","orders","order","trades/my","withdraws","withdraw"],post:["orders","orders/multi","orders/clear","order/delete","withdraw"]}},fees:{trading:{tierBased:!1,percentage:!0,taker:this.parseNumber("0.0025"),maker:this.parseNumber("0.0025")},funding:{withdraw:{UAH:"1%",BTC:.001,BCH:.001,ETH:.01,WAVES:.01,GOL:0,GBG:0},deposit:{}}},commonCurrencies:{PLA:"Plair"},precisionMode:SH,exceptions:{2002:wH,2003:Rv}})}async fetchTime(e={}){return await this.publicGetTimestamp(e)*1e3}async fetchMarkets(e={}){const t=["btc","rub","uah","usd","usdt","usdc"],s=[],i=await this.publicGetTickers(e),n=Object.keys(i);for(let r=0;r<n.length;r++){const a=n[r];for(let o=0;o<t.length;o++){const d=t[o],c=a.slice(1),u=c.indexOf(d),h=c.slice(u);if(u>0&&h===d){const l=a[0]+c.replace(d,""),p=this.safeCurrencyCode(l),m=this.safeCurrencyCode(d);s.push({id:a,symbol:p+"/"+m,base:p,quote:m,settle:void 0,baseId:l,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:void 0,price:void 0},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:void 0})}}}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={market:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetDepth(this.extend(n,s)),a=this.safeTimestamp(r,"timestamp");return this.parseOrderBook(r,i.symbol,a)}parseTicker(e,t=void 0){const s=this.safeTimestamp(e,"at");e=e.ticker;const i=this.safeSymbol(void 0,t),n=this.safeString(e,"last");return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"vol"),quoteVolume:void 0,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTickers(t),i=Object.keys(s),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeMarket(a),d=o.symbol;n[d]=this.parseTicker(s[a],o)}return this.filterByArray(n,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id},n=await this.publicGetTickersMarket(this.extend(i,t));return this.parseTicker(n,s)}async fetchL3OrderBook(e,t=void 0,s={}){return await this.fetchOrderBook(e,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market:n.id},a=await this.publicGetTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"created_at"));let i;t&&(i=t.symbol);let n=this.safeString2(e,"side","trend");if(n!==void 0){const u={ask:"sell",bid:"buy"};n=this.safeString(u,n,n)}const r=this.safeString(e,"price"),a=this.safeString(e,"volume"),o=this.safeNumber(e,"funds"),d=this.safeString(e,"order_id"),c=this.safeString(e,"id");return this.safeTrade({id:c,info:e,timestamp:s,datetime:this.iso8601(s),symbol:i,type:void 0,side:n,order:d,takerOrMaker:void 0,price:r,amount:a,cost:o,fee:void 0},t)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=await this.fetchTrades(e,s,i,n),a=this.buildOHLCVC(r,t,s,i),o=[];for(let d=0;d<a.length;d++){const c=a[d];o.push([c[0],c[1],c[2],c[3],c[4],c[5]])}return o}parseBalance(e){const t=this.safeValue(e,"accounts",[]),s={info:t};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(n,"balance"),o.used=this.safeString(n,"locked"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetMembersMe(e);return this.parseBalance(t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={market:a.id,side:s,volume:i.toString(),ord_type:t};t==="limit"&&(o.price=n.toString());const d=await this.privatePostOrders(this.extend(o,r));return this.parseOrder(d,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privatePostOrderDelete(this.extend(i,s)),r=this.parseOrder(n),a=r.status;if(a==="closed"||a==="canceled")throw new Rv(this.id+" "+this.json(r));return r}parseOrderStatus(e){const t={done:"closed",wait:"open",cancel:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeSymbol(s,t),n=this.parse8601(this.safeString(e,"created_at")),r=this.parseOrderStatus(this.safeString(e,"state")),a=this.safeString(e,"type"),o=this.safeString(e,"side"),d=this.safeString(e,"id");return this.safeOrder({id:d,clientOrderId:void 0,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,status:r,symbol:i,type:a,timeInForce:void 0,postOnly:void 0,side:o,price:this.safeString(e,"price"),stopPrice:void 0,amount:this.safeString(e,"volume"),filled:this.safeString(e,"executed_volume"),remaining:this.safeString(e,"remaining_volume"),trades:void 0,fee:void 0,info:e,cost:void 0,average:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:parseInt(e)},n=await this.privateGetOrder(this.extend(i,s));return this.parseOrder(n)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Lv(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={market:n.id},a=await this.privateGetOrders(this.extend(r,i));return this.parseOrders(a,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Lv(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={market:n.id},a=await this.privateGetTradesMy(this.extend(r,i));return this.parseTrades(a,n,t,s)}nonce(){return this.milliseconds()}encodeParams(e){if("orders"in e){const t=e.orders;let s=this.urlencode(this.keysort(this.omit(e,"orders")));for(let i=0;i<t.length;i++){const n=t[i],r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=n[o];s+="&orders%5B%5D%5B"+o+"%5D="+d.toString()}}return s}return this.urlencode(this.keysort(e))}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a;if(Array.isArray(t)){const[o,d]=t;if(a=this.urls.api[o]+"/"+o+"/"+this.implodeParams(e,i),d==="public")s==="GET"?Object.keys(i).length&&(a+="?"+this.urlencode(i)):(s==="POST"||s==="PUT")&&(n={"Content-Type":"application/json"},r=this.json(i));else if(d==="private")throw new kH(this.id+" private v3 API is not supported yet")}else{let o="/api/"+this.version+"/"+this.implodeParams(e,i);"extension"in this.urls&&(o+=this.urls.extension);const d=this.omit(i,this.extractParams(e));if(a=this.urls.api[t]+o,t==="public")Object.keys(d).length&&(a+="?"+this.urlencode(d));else{this.checkRequiredCredentials();const c=this.nonce().toString(),u=this.encodeParams(this.extend({access_key:this.apiKey,tonce:c},i)),h=s+"|"+o+"|"+u,l=this.hmac(this.encode(h),this.encode(this.secret)),p=u+"&signature="+l;s==="GET"?a+="?"+p:(r=p,n={"Content-Type":"application/x-www-form-urlencoded"})}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&e===400){const c=this.safeValue(a,"error"),u=this.safeString(c,"code"),h=this.id+" "+this.json(a);this.throwExactlyMatchedException(this.exceptions,u,h)}}};const TH=ge,{ExchangeError:sh,AuthenticationError:za,ArgumentsRequired:OH,InvalidNonce:IH,BadRequest:$o,ExchangeNotAvailable:xH,PermissionDenied:Fv,AccountSuspended:z0,RateLimitExceeded:_H,InsufficientFunds:CH,BadSymbol:K0,InvalidOrder:Dv}=de,{TICK_SIZE:MH}=me;var PH=class extends TH{describe(){return this.deepExtend(super.describe(),{id:"latoken",name:"Latoken",countries:["KY"],version:"v2",rateLimit:1e3,has:{CORS:void 0,spot:!0,margin:!1,swap:void 0,future:void 0,option:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchCurrencies:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPositionMode:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactions:!0,fetchTransfer:!1,fetchTransfers:!0,transfer:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/61511972-24c39f00-aa01-11e9-9f7c-471f1d6e5214.jpg",api:{rest:"https://api.latoken.com"},www:"https://latoken.com",doc:["https://api.latoken.com"],fees:"https://latoken.com/fees",referral:"https://latoken.com/invite?r=mvgp2djk"},api:{public:{get:{"book/{currency}/{quote}":1,"chart/week":1,"chart/week/{currency}/{quote}":1,currency:1,"currency/available":1,"currency/quotes":1,"currency/{currency}":1,pair:1,"pair/available":1,ticker:1,"ticker/{base}/{quote}":1,time:1,"trade/history/{currency}/{quote}":1,"trade/fee/{currency}/{quote}":1,"trade/feeLevels":1,"transaction/bindings":1}},private:{get:{"auth/account":1,"auth/account/currency/{currency}/{type}":1,"auth/order":1,"auth/order/getOrder/{id}":1,"auth/order/pair/{currency}/{quote}":1,"auth/order/pair/{currency}/{quote}/active":1,"auth/stopOrder":1,"auth/stopOrder/getOrder/{id}":1,"auth/stopOrder/pair/{currency}/{quote}":1,"auth/stopOrder/pair/{currency}/{quote}/active":1,"auth/trade":1,"auth/trade/pair/{currency}/{quote}":1,"auth/trade/fee/{currency}/{quote}":1,"auth/transaction":1,"auth/transaction/bindings":1,"auth/transaction/bindings/{currency}":1,"auth/transaction/{id}":1,"auth/transfer":1},post:{"auth/order/cancel":1,"auth/order/cancelAll":1,"auth/order/cancelAll/{currency}/{quote}":1,"auth/order/place":1,"auth/spot/deposit":1,"auth/spot/withdraw":1,"auth/stopOrder/cancel":1,"auth/stopOrder/cancelAll":1,"auth/stopOrder/cancelAll/{currency}/{quote}":1,"auth/stopOrder/place":1,"auth/transaction/depositAddress":1,"auth/transaction/withdraw":1,"auth/transaction/withdraw/cancel":1,"auth/transaction/withdraw/confirm":1,"auth/transaction/withdraw/resendCode":1,"auth/transfer/email":1,"auth/transfer/id":1,"auth/transfer/phone":1}}},precisionMode:MH,fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,maker:this.parseNumber("0.0049"),taker:this.parseNumber("0.0049")}},commonCurrencies:{BUX:"Buxcoin",CBT:"Community Business Token",CTC:"CyberTronchain",DMD:"Diamond Coin",FREN:"Frenchie",GDX:"GoldenX",GEC:"Geco One",GEM:"NFTmall",GMT:"GMT Token",IMC:"IMCoin",MT:"Monarch",TPAY:"Tetra Pay",TRADE:"Smart Trade Coin",TSL:"Treasure SL",UNO:"Unobtanium",WAR:"Warrior Token"},exceptions:{exact:{INTERNAL_ERROR:sh,SERVICE_UNAVAILABLE:xH,NOT_AUTHORIZED:za,FORBIDDEN:Fv,BAD_REQUEST:$o,NOT_FOUND:sh,ACCESS_DENIED:Fv,REQUEST_REJECTED:sh,HTTP_MEDIA_TYPE_NOT_SUPPORTED:$o,MEDIA_TYPE_NOT_ACCEPTABLE:$o,METHOD_ARGUMENT_NOT_VALID:$o,VALIDATION_ERROR:$o,ACCOUNT_EXPIRED:z0,BAD_CREDENTIALS:za,COOKIE_THEFT:za,CREDENTIALS_EXPIRED:z0,INSUFFICIENT_AUTHENTICATION:za,UNKNOWN_LOCATION:za,TOO_MANY_REQUESTS:_H,INSUFFICIENT_FUNDS:CH,ORDER_VALIDATION:Dv,BAD_TICKS:Dv},broad:{"invalid API key, signature or digest":za,"The API key was revoked":za,"request expired or bad":IH,"For input string":$o,"Unable to resolve currency by tag":K0,"Can't find currency with tag":K0,"Unable to place order because pair is in inactive state":K0,"API keys are not available for FROZEN user":z0}},options:{defaultType:"spot",types:{wallet:"ACCOUNT_TYPE_WALLET",spot:"ACCOUNT_TYPE_SPOT"},accounts:{ACCOUNT_TYPE_WALLET:"wallet",ACCOUNT_TYPE_SPOT:"spot"},fetchTradingFee:{method:"fetchPrivateTradingFee"}}})}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeInteger(t,"serverTime")}async fetchMarkets(e={}){const t=await this.fetchCurrenciesFromCache(e),s=await this.publicGetPair(e);this.safeValue(this.options,"adjustForTimeDifference",!0)&&await this.loadTimeDifference();const i=this.indexBy(t,"id"),n=[];for(let r=0;r<s.length;r++){const a=s[r],o=this.safeString(a,"id"),d=this.safeString(a,"baseCurrency"),c=this.safeString(a,"quoteCurrency"),u=this.safeValue(i,d),h=this.safeValue(i,c);if(u!==void 0&&h!==void 0){const l=this.safeCurrencyCode(this.safeString(u,"tag")),p=this.safeCurrencyCode(this.safeString(h,"tag")),m=p.toLowerCase(),g=this.capitalize(m),y=this.safeString(a,"status");n.push({id:o,symbol:l+"/"+p,base:l,quote:p,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:y==="PAIR_STATUS_ACTIVE",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(a,"quantityTick"),price:this.safeNumber(a,"priceTick")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(a,"minOrderQuantity"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(a,"minOrderCost"+g),max:this.safeNumber(a,"maxOrderCost"+g)}},info:a})}}return n}async fetchCurrenciesFromCache(e={}){const t=this.safeValue(this.options,"fetchCurrencies",{}),s=this.safeInteger(t,"timestamp"),i=this.safeInteger(t,"expires",1e3),n=this.milliseconds();if(s===void 0||n-s>i){const r=await this.publicGetCurrency(e);this.options.fetchCurrencies=this.extend(t,{response:r,timestamp:n})}return this.safeValue(this.options.fetchCurrencies,"response")}async fetchCurrencies(e={}){const t=await this.fetchCurrenciesFromCache(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"id"),a=this.safeString(n,"tag"),o=this.safeCurrencyCode(a),d=this.safeNumber(n,"fee"),u=this.safeString(n,"type").split("_"),h=u.length,p=this.safeValue(u,h-1).toLowerCase(),g=this.safeString(n,"status")==="CURRENCY_STATUS_ACTIVE",y=this.safeString(n,"name");s[o]={id:r,code:o,info:n,name:y,type:p,active:g,deposit:void 0,withdraw:void 0,fee:d,precision:this.parseNumber(this.parsePrecision(this.safeString(n,"decimals"))),limits:{amount:{min:this.safeNumber(n,"minTransferAmount"),max:void 0},withdraw:{min:void 0,max:void 0}}}}return s}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAuthAccount(e),s={info:t,timestamp:void 0,datetime:void 0};let i;const n=this.safeString2(this.options,"fetchBalance","defaultType","spot"),r=this.safeString(e,"type",n),a=this.safeValue(this.options,"types",{}),o=this.safeString(a,r,r),d=this.groupBy(t,"type"),c=this.safeValue(d,o,[]);for(let u=0;u<c.length;u++){const h=c[u],l=this.safeString(h,"currency"),p=this.safeInteger(h,"timestamp");p!==void 0&&(i===void 0?i=p:i=Math.max(i,p));const m=this.safeCurrencyCode(l),g=this.account();g.free=this.safeString(h,"available"),g.used=this.safeString(h,"blocked"),s[m]=g}return s.timestamp=i,s.datetime=this.iso8601(i),this.safeBalance(s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={currency:i.baseId,quote:i.quoteId};t!==void 0&&(n.limit=t);const r=await this.publicGetBookCurrencyQuote(this.extend(n,s));return this.parseOrderBook(r,e,void 0,"bid","ask","price","quantity")}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeString(e,"lastPrice"),r=this.safeString(e,"change24h"),a=this.nonce();return this.safeTicker({symbol:i,timestamp:a,datetime:this.iso8601(a),low:this.safeString(e,"low"),high:this.safeString(e,"high"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:r,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:this.safeString(e,"volume24h"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={base:s.baseId,quote:s.quoteId},n=await this.publicGetTickerBaseQuote(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTicker(t);return this.parseTickers(s,e)}parseTrade(e,t=void 0){const i=this.safeInteger(e,"timestamp"),n=this.safeString(e,"price"),r=this.safeString(e,"quantity"),a=this.safeString(e,"cost"),o=this.safeValue(e,"makerBuyer");let d=this.safeString(e,"direction");d===void 0?d=o?"sell":"buy":d==="TRADE_DIRECTION_BUY"?d="buy":d==="TRADE_DIRECTION_SELL"&&(d="sell");const u=o&&d==="buy"?"maker":"taker",h=this.safeString(e,"baseCurrency"),l=this.safeString(e,"quoteCurrency"),p=this.safeCurrencyCode(h),m=this.safeCurrencyCode(l),g=p+"/"+m;g in this.markets&&(t=this.market(g));const y=this.safeString(e,"id"),b=this.safeString(e,"order"),w=this.safeString(e,"fee");let k;return w!==void 0&&(k={cost:w,currency:m}),this.safeTrade({info:e,timestamp:i,datetime:this.iso8601(i),symbol:g,id:y,order:b,type:void 0,takerOrMaker:u,side:d,price:n,amount:r,cost:a,fee:k},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={currency:n.baseId,quote:n.quoteId};s!==void 0&&(r.limit=s);const a=await this.publicGetTradeHistoryCurrencyQuote(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTradingFee(e,t={}){let s=this.safeString(t,"method");if(t=this.omit(t,"method"),s===void 0){const i=this.safeValue(this.options,"fetchTradingFee",{});s=this.safeString(i,"method","fetchPrivateTradingFee")}return await this[s](e,t)}async fetchPublicTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={currency:s.baseId,quote:s.quoteId},n=await this.publicGetTradeFeeCurrencyQuote(this.extend(i,t));return{info:n,symbol:s.symbol,maker:this.safeNumber(n,"makerFee"),taker:this.safeNumber(n,"takerFee")}}async fetchPrivateTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={currency:s.baseId,quote:s.quoteId},n=await this.privateGetAuthTradeFeeCurrencyQuote(this.extend(i,t));return{info:n,symbol:s.symbol,maker:this.safeNumber(n,"makerFee"),taker:this.safeNumber(n,"takerFee")}}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r="privateGetAuthTrade",a;e!==void 0&&(a=this.market(e),n.currency=a.baseId,n.quote=a.quoteId,r="privateGetAuthTradePairCurrencyQuote"),s!==void 0&&(n.limit=s);const o=await this[r](this.extend(n,i));return this.parseTrades(o,a,t,s)}parseOrderStatus(e){const t={ORDER_STATUS_PLACED:"open",ORDER_STATUS_CLOSED:"closed",ORDER_STATUS_CANCELLED:"canceled"};return this.safeString(t,e,e)}parseOrderType(e){const t={ORDER_TYPE_MARKET:"market",ORDER_TYPE_LIMIT:"limit"};return this.safeString(t,e,e)}parseTimeInForce(e){const t={ORDER_CONDITION_GOOD_TILL_CANCELLED:"GTC",ORDER_CONDITION_IMMEDIATE_OR_CANCEL:"IOC",ORDER_CONDITION_FILL_OR_KILL:"FOK"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeInteger(e,"timestamp"),n=this.safeString(e,"baseCurrency"),r=this.safeString(e,"quoteCurrency"),a=this.safeCurrencyCode(n),o=this.safeCurrencyCode(r);let d;a!==void 0&&o!==void 0&&(d=a+"/"+o,d in this.markets&&(t=this.market(d)));const c=this.safeString(e,"side");let u;if(c!==void 0){const T=c.split("_"),O=T.length;u=this.safeStringLower(T,O-1)}const h=this.parseOrderType(this.safeString(e,"type")),l=this.safeString(e,"price"),p=this.safeString(e,"quantity"),m=this.safeString(e,"filled"),g=this.safeString(e,"cost");let y=this.parseOrderStatus(this.safeString(e,"status"));const b=this.safeString(e,"message");b!==void 0&&(b.indexOf("cancel")>=0?y="canceled":b.indexOf("accept")>=0&&(y="open"));const w=this.safeString(e,"clientOrderId"),k=this.parseTimeInForce(this.safeString(e,"condition"));return this.safeOrder({id:s,clientOrderId:w,info:e,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,status:y,symbol:d,type:h,timeInForce:k,postOnly:void 0,side:u,price:l,stopPrice:void 0,cost:g,amount:p,filled:m,average:void 0,remaining:void 0,fee:void 0,trades:void 0},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new OH(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={currency:n.baseId,quote:n.quoteId},a=await this.privateGetAuthOrderPairCurrencyQuoteActive(this.extend(r,i));return this.parseOrders(a,n,t,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r="privateGetAuthOrder",a;e!==void 0&&(a=this.market(e),n.currency=a.baseId,n.quote=a.quoteId,r="privateGetAuthOrderPairCurrencyQuote"),s!==void 0&&(n.limit=s);const o=await this[r](this.extend(n,i));return this.parseOrders(o,a,t,s)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetAuthOrderGetOrderId(this.extend(i,s));return this.parseOrder(n)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=t.toUpperCase(),d={baseCurrency:a.baseId,quoteCurrency:a.quoteId,side:s.toUpperCase(),condition:"GTC",type:o,clientOrderId:this.uuid()};o==="LIMIT"&&(d.price=this.priceToPrecision(e,n)),d.quantity=this.amountToPrecision(e,i),d.timestamp=this.seconds();const c=await this.privatePostAuthOrderPlace(this.extend(d,r));return this.parseOrder(c,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privatePostAuthOrderCancel(this.extend(i,s));return this.parseOrder(n)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i="privatePostAuthOrderCancelAll",n;return e!==void 0&&(n=this.market(e),s.currency=n.baseId,s.quote=n.quoteId,i="privatePostAuthOrderCancelAllCurrencyQuote"),await this[i](this.extend(s,t))}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={},r=await this.privateGetAuthTransaction(this.extend(n,i));let a;e!==void 0&&(a=this.currency(e));const o=this.safeValue(r,"content",[]);return this.parseTransactions(o,a,t,s)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeInteger(e,"timestamp"),n=this.safeString(e,"currency"),r=this.safeCurrencyCode(n,t),a=this.parseTransactionStatus(this.safeString(e,"status")),o=this.safeNumber(e,"amount"),d=this.safeString(e,"senderAddress"),c=this.safeString(e,"recipientAddress"),u=this.safeString(e,"transactionHash"),h=this.safeString(e,"memo");let l;const p=this.safeNumber(e,"transactionFee");p!==void 0&&(l={cost:p,currency:r});const m=this.parseTransactionType(this.safeString(e,"type"));return{info:e,id:s,txid:u,timestamp:i,datetime:this.iso8601(i),network:void 0,addressFrom:d,addressTo:c,address:c,tagFrom:void 0,tagTo:h,tag:h,type:m,amount:o,currency:r,status:a,updated:void 0,fee:l}}parseTransactionStatus(e){const t={TRANSACTION_STATUS_CONFIRMED:"ok",TRANSACTION_STATUS_EXECUTED:"ok"};return this.safeString(t,e,e)}parseTransactionType(e){const t={TRANSACTION_TYPE_DEPOSIT:"deposit",TRANSACTION_TYPE_WITHDRAWAL:"withdrawal"};return this.safeString(t,e,e)}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.currency(e),r=await this.privateGetAuthTransfer(i),a=this.safeValue(r,"content",[]);return this.parseTransfers(a,n,t,s)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e);let a;i.indexOf("@")>=0?a="privatePostAuthTransferEmail":i.length===36?a="privatePostAuthTransferId":a="privatePostAuthTransferPhone";const o={currency:r.id,recipient:i,value:this.currencyToPrecision(e,t)},d=await this[a](this.extend(o,n));return this.parseTransfer(d)}parseTransfer(e,t=void 0){const s=this.safeTimestamp(e,"timestamp"),i=this.safeString(e,"currency"),n=this.safeString(e,"status");return{info:e,id:this.safeString(e,"id"),timestamp:this.safeInteger(e,"timestamp"),datetime:this.iso8601(s),currency:this.safeCurrencyCode(i,t),amount:this.safeNumber(e,"transferringFunds"),fromAccount:this.safeString(e,"fromAccount"),toAccount:this.safeString(e,"toAccount"),status:this.parseTransferStatus(n)}}parseTransferStatus(e){const t={TRANSFER_STATUS_COMPLETED:"ok",TRANSFER_STATUS_PENDING:"pending",TRANSFER_STATUS_REJECTED:"failed",TRANSFER_STATUS_UNVERIFIED:"pending",TRANSFER_STATUS_CANCELLED:"canceled"};return this.safeString(t,e,e)}sign(e,t="public",s="GET",i=void 0,n=void 0,r=void 0){const a="/"+this.version+"/"+this.implodeParams(e,i);let o=a;const d=this.omit(i,this.extractParams(e)),c=this.urlencode(d);if(s==="GET"&&Object.keys(d).length&&(o+="?"+c),t==="private"){this.checkRequiredCredentials();const h=s+a+c,l=this.hmac(this.encode(h),this.encode(this.secret),"sha512");n={"X-LA-APIKEY":this.apiKey,"X-LA-SIGNATURE":l,"X-LA-DIGEST":"HMAC-SHA512"},s==="POST"&&(n["Content-Type"]="application/json",r=this.json(d))}return{url:this.urls.api.rest+o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(!a)return;const c=this.safeString(a,"message"),u=this.id+" "+r;c!==void 0&&(this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u));const h=this.safeValue(a,"error"),l=this.safeString(h,"message");if(h!==void 0||l!==void 0)throw this.throwExactlyMatchedException(this.exceptions.exact,h,u),this.throwBroadlyMatchedException(this.exceptions.broad,r,u),new sh(u)}};const AH=ge,{ExchangeError:BH,DDoSProtection:EH,AuthenticationError:Rc,InvalidOrder:ia}=de,{TICK_SIZE:NH}=me,VH=Se;var qH=class extends AH{describe(){return this.deepExtend(super.describe(),{id:"lbank",name:"LBank",countries:["CN"],version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:void 0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},timeframes:{"1m":"minute1","5m":"minute5","15m":"minute15","30m":"minute30","1h":"hour1","2h":"hour2","4h":"hour4","6h":"hour6","8h":"hour8","12h":"hour12","1d":"day1","1w":"week1"},urls:{logo:"https://user-images.githubusercontent.com/1294454/38063602-9605e28a-3302-11e8-81be-64b1e53c4cfb.jpg",api:{rest:"https://api.lbank.info"},www:"https://www.lbank.info",doc:"https://github.com/LBank-exchange/lbank-official-api-docs",fees:"https://www.lbank.info/fees.html",referral:"https://www.lbank.info/invitevip?icode=7QCY"},api:{public:{get:["currencyPairs","ticker","depth","trades","kline","accuracy"]},private:{post:["user_info","create_order","cancel_order","orders_info","orders_info_history","withdraw","withdrawCancel","withdraws","withdrawConfigs"]}},fees:{trading:{maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")},funding:{withdraw:{}}},commonCurrencies:{GMT:"GMT Token",PNT:"Penta",SHINJA:"SHINJA(1M)",VET_ERC20:"VEN"},options:{cacheSecretAsPem:!0},precisionMode:NH})}async fetchMarkets(e={}){const t=await this.publicGetAccuracy(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=n.symbol,a=r.split("_");let o,d;a.length>2?(o=a[0]+"_"+a[1],d=a[2]):(o=a[0],d=a[1]);const u=this.safeCurrencyCode(o),h=this.safeCurrencyCode(d);s.push({id:r,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(n,"quantityAccuracy"))),price:this.parseNumber(this.parsePrecision(this.safeString(n,"priceAccuracy")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeFloat(n,"minTranQua"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return s}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,"_");const i=t.symbol,n=this.safeInteger(e,"timestamp"),r=e;e=r.ticker;const a=this.safeString(e,"latest"),o=this.safeString(e,"change");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:o,average:void 0,baseVolume:this.safeString(e,"vol"),quoteVolume:this.safeString(e,"turnover"),info:r},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetTicker(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={symbol:"all"},i=await this.publicGetTicker(this.extend(s,t)),n={};for(let r=0;r<i.length;r++){const a=this.parseTicker(i[r]),o=a.symbol;n[o]=a}return this.filterByArray(n,"symbol",e)}async fetchOrderBook(e,t=60,s={}){await this.loadMarkets();let i=60;t!==void 0&&(i=Math.min(t,i));const n=this.market(e),r={symbol:n.id,size:i},a=await this.publicGetDepth(this.extend(r,s));return this.parseOrderBook(a,n.symbol)}parseTrade(e,t=void 0){t=this.safeMarket(void 0,t);const s=this.safeInteger(e,"date_ms"),i=this.safeString(e,"price"),n=this.safeString(e,"amount"),r=this.parseNumber(i),a=this.parseNumber(n),o=this.parseNumber(VH.stringMul(i,n)),d=this.safeString(e,"tid"),c=void 0;let u=this.safeString(e,"type");return u=u.split("_")[0],{id:d,info:this.safeValue(e,"info",e),timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:void 0,type:c,side:u,takerOrMaker:void 0,price:r,amount:a,cost:o,fee:void 0}}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id,size:100};t!==void 0&&(r.time=parseInt(t)),s!==void 0&&(r.size=s);const a=await this.publicGetTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=1e3,n={}){await this.loadMarkets();const r=this.market(e);if(i===void 0&&(i=100),s===void 0){const d=this.parseTimeframe(t);s=this.milliseconds()-d*1e3*i}const a={symbol:r.id,type:this.timeframes[t],size:i,time:parseInt(s/1e3)},o=await this.publicGetKline(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"info",{}),i=this.safeValue(s,"free",{}),n=this.safeValue(s,"freeze",{}),r=this.safeValue(s,"asset",{}),a=Object.keys(i);for(let o=0;o<a.length;o++){const d=a[o],c=this.safeCurrencyCode(d),u=this.account();u.free=this.safeString(i,d),u.used=this.safeString(n,d),u.total=this.safeString(r,d),t[c]=u}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostUserInfo(e);return this.parseBalance(t)}parseOrderStatus(e){const t={"-1":"cancelled",0:"open",1:"open",2:"closed",4:"closed"};return this.safeString(t,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t,"_"),n=this.safeInteger(e,"create_time"),r=this.safeString(e,"price"),a=this.safeString(e,"amount"),o=this.safeString(e,"deal_amount"),d=this.safeString(e,"avg_price"),c=this.parseOrderStatus(this.safeString(e,"status")),u=this.safeString(e,"order_id"),h=this.safeString(e,"order_type"),l=this.safeString(e,"type");return this.safeOrder({id:u,clientOrderId:void 0,datetime:this.iso8601(n),timestamp:n,lastTradeTimestamp:void 0,status:c,symbol:i,type:h,timeInForce:void 0,postOnly:void 0,side:l,price:r,stopPrice:void 0,cost:void 0,amount:a,filled:o,remaining:void 0,trades:void 0,fee:void 0,info:this.safeValue(e,"info",e),average:d},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o={symbol:a.id,type:s,amount:i};t==="market"?o.type+="_market":o.price=n;const d=await this.privatePostCreateOrder(this.extend(o,r));return o=this.omit(o,"type"),o.order_id=d.order_id,o.type=s,o.order_type=t,o.create_time=this.milliseconds(),o.info=d,this.parseOrder(o,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const n={symbol:this.market(t).id,order_id:e};return await this.privatePostCancelOrder(this.extend(n,s))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(t),n={symbol:i.id,order_id:e},r=await this.privatePostOrdersInfo(this.extend(n,s)),a=this.safeValue(r,"orders",[]),o=this.parseOrders(a,i);return o.length===1?o[0]:o}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),s===void 0&&(s=100);const r={symbol:this.market(e).id,current_page:1,page_length:s},a=await this.privatePostOrdersInfoHistory(this.extend(r,i)),o=this.safeValue(a,"orders",[]);return this.parseOrders(o,void 0,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),e!==void 0&&(e=this.market(e).symbol);const n=await this.fetchOrders(e,t,s,i),r=this.filterBy(n,"status","closed"),a=this.filterBy(n,"status","cancelled"),o=this.arrayConcat(r,a);return this.filterBySymbolSinceLimit(o,e,t,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={assetCode:r.id,amount:t,account:s};i!==void 0&&(a.memo=i);const o=this.privatePostWithdraw(this.extend(a,n));return this.parseTransaction(o,r)}parseTransaction(e,t=void 0){return t=this.safeCurrency(void 0,t),{id:this.safeString2(e,"id","withdrawId"),txid:void 0,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0,info:e}}convertSecretToPem(e){const s=e.length-0;let i=parseInt(s/64);i=this.sum(i,1);let n=`-----BEGIN PRIVATE KEY-----
`;for(let r=0;r<i;r++){const a=r*64,o=this.sum(a,64);n+=this.secret.slice(a,o)+`
`}return n+"-----END PRIVATE KEY-----"}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.omit(i,this.extractParams(e));let o=this.urls.api.rest+"/"+this.version+"/"+this.implodeParams(e,i);if(o+=".do",t==="public")Object.keys(a).length&&(o+="?"+this.urlencode(a));else{this.checkRequiredCredentials();const d=this.keysort(this.extend({api_key:this.apiKey},i)),c=this.rawencode(d),u=this.hash(this.encode(c)).toUpperCase(),h=this.safeValue(this.options,"cacheSecretAsPem",!0);let l;h?(l=this.safeValue(this.options,"pem"),l===void 0&&(l=this.convertSecretToPem(this.secret),this.options.pem=l)):l=this.convertSecretToPem(this.secret);const p=this.binaryToBase64(this.rsa(u,this.encode(l),"RS256"));d.sign=p,r=this.urlencode(d),n={"Content-Type":"application/x-www-form-urlencoded"}}return{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;if(this.safeString(a,"result")==="false"){const u=this.safeString(a,"error_code"),h=this.safeString({1e4:"Internal error",10001:"The required parameters can not be empty",10002:"verification failed",10003:"Illegal parameters",10004:"User requests are too frequent",10005:"Key does not exist",10006:"user does not exist",10007:"Invalid signature",10008:"This currency pair is not supported",10009:"Limit orders can not be missing orders and the number of orders",10010:"Order price or order quantity must be greater than 0",10011:"Market orders can not be missing the amount of the order",10012:"market sell orders can not be missing orders",10013:"is less than the minimum trading position 0.001",10014:"Account number is not enough",10015:"The order type is wrong",10016:"Account balance is not enough",10017:"Abnormal server",10018:"order inquiry can not be more than 50 less than one",10019:"withdrawal orders can not be more than 3 less than one",10020:"less than the minimum amount of the transaction limit of 0.001",10022:"Insufficient key authority"},u,this.json(a)),l=this.safeValue({10002:Rc,10004:EH,10005:Rc,10006:Rc,10007:Rc,10009:ia,10010:ia,10011:ia,10012:ia,10013:ia,10014:ia,10015:ia,10016:ia,10022:Rc},u,BH);throw new l(h)}}};const LH=ge,{ExchangeError:br,InvalidAddress:RH,DuplicateOrderId:FH,ArgumentsRequired:na,InsufficientFunds:X0,InvalidOrder:In,InvalidNonce:DH,AuthenticationError:ih,RateLimitExceeded:HH,PermissionDenied:nh,BadRequest:ui,BadSymbol:Hv}=de,{TICK_SIZE:GH}=me,UH=Se;var $H=class extends LH{describe(){return this.deepExtend(super.describe(),{id:"lbank2",name:"LBank",countries:["CN"],version:"v2",rateLimit:20,has:{CORS:!1,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedPositions:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFees:!0,fetchTransactionFees:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!1},timeframes:{"1m":"minute1","5m":"minute5","15m":"minute15","30m":"minute30","1h":"hour1","2h":"hour2","4h":"hour4","6h":"hour6","8h":"hour8","12h":"hour12","1d":"day1","1w":"week1"},urls:{logo:"https://user-images.githubusercontent.com/1294454/38063602-9605e28a-3302-11e8-81be-64b1e53c4cfb.jpg",api:{rest:"https://api.lbank.info"},api2:"https://api.lbkex.com",www:"https://www.lbank.info",doc:"https://www.lbank.info/en-US/docs/index.html",fees:"https://lbankinfo.zendesk.com/hc/en-gb/articles/360012072873-Trading-Fees",referral:"https://www.lbank.info/invitevip?icode=7QCY"},api:{public:{get:{currencyPairs:2.5,accuracy:2.5,usdToCny:2.5,withdrawConfigs:2.5,timestamp:2.5,"ticker/24hr":2.5,ticker:2.5,depth:2.5,incrDepth:2.5,trades:2.5,kline:2.5,"supplement/system_ping":2.5,"supplement/incrDepth":2.5,"supplement/trades":2.5,"supplement/ticker/price":2.5,"supplement/ticker/bookTicker":2.5},post:{"supplement/system_status":2.5}},private:{post:{user_info:2.5,"subscribe/get_key":2.5,"subscribe/refresh_key":2.5,"subscribe/destroy_key":2.5,get_deposit_address:2.5,deposit_history:2.5,create_order:1,batch_create_order:1,cancel_order:1,cancel_clientOrders:1,orders_info:2.5,orders_info_history:2.5,order_transaction_detail:2.5,transaction_history:2.5,orders_info_no_deal:2.5,withdraw:2.5,withdrawCancel:2.5,withdraws:2.5,"supplement/user_info":2.5,"supplement/withdraw":2.5,"supplement/deposit_history":2.5,"supplement/withdraws":2.5,"supplement/get_deposit_address":2.5,"supplement/asset_detail":2.5,"supplement/customer_trade_fee":2.5,"supplement/api_Restrictions":2.5,"supplement/system_ping":2.5,"supplement/create_order_test":1,"supplement/create_order":1,"supplement/cancel_order":1,"supplement/cancel_order_by_symbol":1,"supplement/orders_info":2.5,"supplement/orders_info_no_deal":2.5,"supplement/orders_info_history":2.5,"supplement/user_info_account":2.5,"supplement/transaction_history":2.5}}},fees:{trading:{maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")},funding:{withdraw:{}}},commonCurrencies:{VET_ERC20:"VEN",PNT:"Penta"},precisionMode:GH,options:{cacheSecretAsPem:!0,createMarketBuyOrderRequiresPrice:!0,fetchTrades:{method:"publicGetTrades"},fetchTransactionFees:{method:"fetchPrivateTransactionFees"},fetchDepositAddress:{method:"fetchDepositAddressDefault"},createOrder:{method:"privatePostSupplementCreateOrder"},fetchOrder:{method:"fetchOrderSupplement"},fetchBalance:{method:"privatePostSupplementUserInfo"},networks:{ERC20:"erc20",ETH:"erc20",TRC20:"trc20",TRX:"trc20",OMNI:"omni",ASA:"asa",BEP20:"bep20(bsc)",BSC:"bep20(bsc)",HT:"heco",BNB:"bep2",BTC:"btc",DOGE:"dogecoin",MATIC:"matic",POLYGON:"matic",OEC:"oec",BTCTRON:"btctron",XRP:"xrp"},"inverse-networks":{erc20:"ERC20",trc20:"TRC20",omni:"OMNI",asa:"ASA","bep20(bsc)":"BSC",bep20:"BSC",heco:"HT",bep2:"BNB",btc:"BTC",dogecoin:"DOGE",matic:"MATIC",oec:"OEC",btctron:"BTCTRON",xrp:"XRP"},defaultNetworks:{USDT:"TRC20"}}})}async fetchMarkets(e={}){const t=await this.publicGetAccuracy(),s=this.safeValue(t,"data"),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=a.split("_"),d=o[0],c=o[1],u=d.toUpperCase(),h=c.toUpperCase();let l=u+"/"+h;const p={"3l":!0,"5l":!0,"3s":!0,"5s":!0},m=d.slice(-2),g=this.safeValue(p,m,!1);g&&(l+=":"+h);let y;g===!0&&(y=!0),i.push({id:a,symbol:l,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:g,future:!1,option:!1,active:!0,contract:g,linear:y,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"quantityAccuracy"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"priceAccuracy")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"minTranQua"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeInteger(e,"timestamp"),r=this.safeValue(e,"ticker");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(r,"high"),low:this.safeString(r,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:void 0,last:this.safeString(r,"latest"),previousClose:void 0,change:void 0,percentage:this.safeString(r,"change"),average:void 0,baseVolume:this.safeString(r,"vol"),quoteVolume:this.safeString(r,"turnover"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetTicker24hr(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0,{});return this.parseTicker(a,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={symbol:"all"},i=await this.publicGetTicker24hr(this.extend(s,t)),n=this.safeValue(i,"data",[]);return this.parseTickers(n,e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);t===void 0&&(t=60);const n={symbol:i.id,size:t},a=(await this.publicGetDepth(this.extend(n,s))).data,o=this.milliseconds();return this.parseOrderBook(a,i.symbol,o)}parseTrade(e,t=void 0){let s=this.safeInteger2(e,"date_ms","time");s===void 0&&(s=this.safeInteger(e,"dealTime"));let i=this.safeString2(e,"amount","qty");i===void 0&&(i=this.safeString(e,"dealQuantity"));let n=this.safeString(e,"price");n===void 0&&(n=this.safeString(e,"dealPrice"));let r=this.safeString(e,"quoteQty");r===void 0&&(r=this.safeString(e,"dealVolumePrice"));let a=this.safeString2(e,"tradeType","type"),o,d;if(a!==void 0){const m=a.split("_");a=this.safeString(m,0);const g=this.safeString(m,1);o="limit",d="taker",g!==void 0&&(g==="market"?o="market":g==="maker"&&(d="maker"))}let c=this.safeString2(e,"tid","id");c===void 0&&(c=this.safeString(e,"txUuid"));const u=this.safeString(e,"orderUuid"),h=this.safeSymbol(void 0,t);let l;const p=this.safeString(e,"tradeFee");return p!==void 0&&(l={cost:p,currency:void 0,rate:this.safeString(e,"tradeFeeRate")}),this.safeTrade({timestamp:s,datetime:this.iso8601(s),symbol:h,id:c,order:u,type:o,takerOrMaker:d,side:a,price:n,amount:i,cost:r,fee:l,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};t!==void 0&&(r.time=t),s!==void 0?r.size=s:r.size=600;let a=this.safeString(i,"method");if(i=this.omit(i,"method"),a===void 0){const c=this.safeValue(this.options,"fetchTrades",{});a=this.safeString(c,"method","publicGetTrades")}const o=await this[a](this.extend(r,i)),d=this.safeValue(o,"data",[]);return this.parseTrades(d,n,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);if(i===void 0&&(i=100),s===void 0){const c=this.parseTimeframe(t);s=this.milliseconds()-c*1e3*i}const a={symbol:r.id,type:this.timeframes[t],time:parseInt(s/1e3),size:i},o=await this.publicGetKline(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseOHLCVs(d,r,t,s,i)}parseBalance(e){const t=this.safeInteger(e,"ts"),s={info:e,timestamp:t,datetime:this.iso8601(t)},i=this.safeValue(e,"data");if(this.safeValue(i,"toBtc")!==void 0){const o=this.safeValue(i,"freeze",{}),d=this.safeValue(i,"free",{}),c=Object.keys(d);for(let u=0;u<c.length;u++){const h=c[u],l=this.safeCurrencyCode(h),p=this.account();p.used=this.safeString(o,h),p.free=this.safeString(d,h),s[l]=p}return this.safeBalance(s)}const r=this.safeValue(i,"balances");if(r!==void 0){for(let o=0;o<r.length;o++){const d=r[o],c=this.safeString(d,"asset"),u=this.safeCurrencyCode(c),h=this.account();h.free=this.safeString(d,"free"),h.used=this.safeString(d,"locked"),s[u]=h}return this.safeBalance(s)}if(Array.isArray(i)===!0){for(let o=0;o<i.length;o++){const d=i[o],c=this.safeString(d,"coin"),u=this.safeCurrencyCode(c),h=this.account();h.free=this.safeString(d,"usableAmt"),h.used=this.safeString(d,"freezeAmt"),s[u]=h}return this.safeBalance(s)}}async fetchBalance(e={}){await this.loadMarkets();let t=this.safeString(e,"method");if(t===void 0){const i=this.safeValue(this.options,"fetchBalance",{});t=this.safeString(i,"method","privatePostSupplementUserInfo")}const s=await this[t]();return this.parseBalance(s)}parseTradingFee(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s);return{info:e,symbol:i,maker:this.safeNumber(e,"makerCommission"),taker:this.safeNumber(e,"takerCommission")}}async fetchTradingFee(e,t={}){const s=this.market(e);return await this.fetchTradingFees(this.extend(t,{category:s.id}))}async fetchTradingFees(e={}){await this.loadMarkets();const t={},s=await this.privatePostSupplementCustomerTradeFee(this.extend(t,e)),i=this.safeValue(s,"data",[]),n={};for(let r=0;r<i.length;r++){const a=this.parseTradingFee(i[r]),o=a.symbol;n[o]=a}return n}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeString2(r,"custom_id","clientOrderId"),d=this.safeValue(r,"postOnly",!1),c=this.safeStringUpper(r,"timeInForce");r=this.omit(r,["custom_id","clientOrderId","timeInForce","postOnly"]);const u={symbol:a.id},h=c==="IOC",l=c==="FOK",p=d||c==="PO";if(t==="market"&&(h||l||p))throw new In(this.id+" createOrder () does not allow market FOK, IOC, or postOnly orders. Only limit IOC, FOK, and postOnly orders are allowed");if(t==="limit")u.type=s,u.price=this.priceToPrecision(e,n),u.amount=this.amountToPrecision(e,i),h?u.type=s+"_ioc":l?u.type=s+"_fok":p&&(u.type=s+"_maker");else if(t==="market"){if(s==="sell")u.type=s+"_market",u.amount=this.amountToPrecision(e,i);else if(s==="buy")if(u.type=s+"_market",this.options.createMarketBuyOrderRequiresPrice){if(n===void 0)throw new In(this.id+" createOrder () requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply the price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)");{const b=this.numberToString(i),w=this.numberToString(n),k=UH.stringMul(b,w),T=this.parseNumber(k);u.price=this.priceToPrecision(e,T)}}else u.price=i}o!==void 0&&(u.custom_id=o);let m;if(m=this.safeString(r,"method"),r=this.omit(r,"method"),m===void 0){const b=this.safeValue(this.options,"createOrder",{});m=this.safeString(b,"method","privatePostSupplementCreateOrder")}const g=await this[m](this.extend(u,r)),y=this.safeValue(g,"data",{});return{id:this.safeString(y,"order_id"),info:y}}parseOrderStatus(e){const t={"-1":"canceled",0:"open",1:"open",2:"closed",3:"canceled",4:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString2(e,"orderId","order_id"),i=this.safeString2(e,"clientOrderId","custom_id"),n=this.safeInteger2(e,"time","create_time"),r=this.safeString(e,"status"),a=this.safeString(e,"symbol");t=this.safeMarket(a,t);let o,d=!1,c="limit";const u=this.safeString(e,"type"),h=u.split("_"),l=this.safeString(h,0),p=this.safeString(h,1);p==="market"&&(c="market"),p==="maker"&&(d=!0,o="PO"),p==="ioc"&&(o="IOC"),p==="fok"&&(o="FOK");const m=this.safeString(e,"price"),g=this.safeString(e,"cummulativeQuoteQty");let y;u!=="buy_market"&&(y=this.safeString2(e,"origQty","amount"));const b=this.safeString2(e,"executedQty","deal_amount");return this.safeOrder({id:s,clientOrderId:i,datetime:this.iso8601(n),timestamp:n,lastTradeTimestamp:void 0,status:this.parseOrderStatus(r),symbol:t.symbol,type:c,timeInForce:o,postOnly:d,side:l,price:m,stopPrice:void 0,cost:g,amount:y,filled:b,remaining:void 0,trades:void 0,fee:void 0,info:e,average:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();let i=this.safeString(s,"method");if(i===void 0){const r=this.safeValue(this.options,"fetchOrder",{});i=this.safeString(r,"method","fetchOrderSupplement")}return await this[i](e,t,s)}async fetchOrderSupplement(e,t=void 0,s={}){if(await this.loadMarkets(),t===void 0)throw new na(this.id+" fetchOrder () requires a symbol argument");const n={symbol:this.market(t).id,orderId:e},r=await this.privatePostSupplementOrdersInfo(this.extend(n,s)),a=this.safeValue(r,"data",{});return this.parseOrder(a)}async fetchOrderDefault(e,t=void 0,s={}){if(await this.loadMarkets(),t===void 0)throw new na(this.id+" fetchOrder () requires a symbol argument");const n={symbol:this.market(t).id,order_id:e},r=await this.privatePostOrdersInfo(this.extend(n,s)),a=this.safeValue(r,"data",[]),o=a.length;if(o===1)return this.parseOrder(a[0]);{const d=[];for(let c=0;c<o;c++){const u=this.parseOrder(a[c]);d.push(u)}return d}}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new na(this.id+" fetchMyTrades () requires a symbol argument");await this.loadMarkets();const n=this.market(e);t=this.safeValue(i,"start_date",t),i=this.omit(i,"start_date");const r={symbol:n.id};s!==void 0&&(r.size=s),t!==void 0&&(r.start_date=this.ymd(t,"-"));const a=await this.privatePostTransactionHistory(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new na(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e);s===void 0&&(s=100);const r={symbol:n.id,current_page:1,page_length:s},a=await this.privatePostSupplementOrdersInfoHistory(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"orders",[]);return this.parseOrders(d,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new na(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e);s===void 0&&(s=100);const r={symbol:n.id,current_page:1,page_length:s},a=await this.privatePostSupplementOrdersInfoNoDeal(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"orders",[]);return this.parseOrders(d,n,t,s)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new na(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.safeString2(s,"origClientOrderId","clientOrderId");s=this.omit(s,["origClientOrderId","clientOrderId"]);const r={symbol:this.market(t).id};i!==void 0&&(r.origClientOrderId=i),r.orderId=e;const a=await this.privatePostSupplementCancelOrder(this.extend(r,s));return this.safeValue(a,"data",{})}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new na(this.id+" cancelAllOrders() requires a symbol argument");await this.loadMarkets();const i={symbol:this.market(e).id},n=await this.privatePostSupplementCancelOrderBySymbol(this.extend(i,t));return this.safeValue(n,"data",[])}getNetworkCodeForCurrency(e,t){const s=this.safeValue(this.options,"defaultNetworks"),i=this.safeStringUpper(s,e),n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper(t,"network",i);return r=this.safeString(n,r,r),r}async fetchDepositAddress(e,t={}){await this.loadMarkets();let s=this.safeString(t,"method");if(t=this.omit(t,"method"),s===void 0){const i=this.safeValue(this.options,"fetchDepositAddress",{});s=this.safeString(i,"method","fetchPrivateTradingFees")}return await this[s](e,t)}async fetchDepositAddressDefault(e,t={}){await this.loadMarkets();const i={assetCode:this.currency(e).id},n=this.getNetworkCodeForCurrency(e,t);n!==void 0&&(i.netWork=n,t=this.omit(t,"network"));const r=await this.privatePostGetDepositAddress(this.extend(i,t)),a=this.safeValue(r,"data"),o=this.safeString(a,"address"),d=this.safeString(a,"memo"),c=this.safeString(a,"netWork"),u=this.safeValue(this.options,"inverse-networks",{}),h=this.safeStringUpper(u,c,c);return{currency:e,address:o,tag:d,network:h,info:r}}async fetchDepositAddressSupplement(e,t={}){await this.loadMarkets();const i={coin:this.currency(e).id},n=this.safeValue(this.options,"networks");let r=this.safeStringUpper(t,"network");r=this.safeString(n,r,r),r!==void 0&&(i.networkName=r,t=this.omit(t,"network"));const a=await this.privatePostSupplementGetDepositAddress(this.extend(i,t)),o=this.safeValue(a,"data"),d=this.safeString(o,"address"),c=this.safeString(o,"memo"),u=this.safeValue(this.options,"inverse-networks",{}),h=this.safeStringUpper(u,r,r);return{currency:e,address:d,tag:c,network:h,info:a}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.safeString(n,"fee");if(n=this.omit(n,"fee"),r===void 0)throw new na(this.id+" withdraw () requires a fee argument to be supplied in params, the relevant coin network fee can be found by calling fetchTransactionFees (), note: if no network param is supplied then the default network will be used, this can also be found in fetchTransactionFees ()");const a=this.currency(e),o={address:s,coin:a.id,amount:t,fee:r};i!==void 0&&(o.memo=i);const d=this.safeStringUpper2(n,"network","networkName");n=this.omit(n,["network","networkName"]);const c=this.safeValue(this.options,"networks"),u=this.safeString(c,d,d);u!==void 0&&(o.networkName=u);const h=await this.privatePostSupplementWithdraw(this.extend(o,n)),l=this.safeValue(h,"data",{});return{info:l,id:this.safeString(l,"withdrawId")}}parseTransactionStatus(e,t){const s={deposit:{1:"pending",2:"ok",3:"failed",4:"canceled",5:"transfer"},withdrawal:{1:"pending",2:"canceled",3:"failed",4:"ok"}};return this.safeString(this.safeValue(s,t,{}),e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id");let i;s===void 0?i="deposit":i="withdrawal";const n=this.safeString(e,"txId"),r=this.safeInteger2(e,"insertTime","applyTime"),a=this.safeValue(this.options,"inverse-networks",{}),o=this.safeString(e,"networkName"),d=this.safeString(a,o,o),c=this.safeString(e,"address");let u,h;i==="deposit"?u=c:h=c;const l=this.safeNumber(e,"amount"),p=this.safeString2(e,"coin","coid"),m=this.safeCurrencyCode(p,t),g=this.parseTransactionStatus(this.safeString(e,"status"),i);let y;const b=this.safeNumber(e,"fee");return b!==void 0&&(y={cost:b,currency:m}),{info:e,id:s,txid:n,timestamp:r,datetime:this.iso8601(r),network:d,address:c,addressTo:h,addressFrom:u,tag:void 0,tagTo:void 0,tagFrom:void 0,type:i,amount:l,currency:m,status:g,updated:void 0,comment:void 0,internal:g==="transfer",fee:y}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.coin=r.id),t!==void 0&&(n.startTime=t);const a=await this.privatePostSupplementDepositHistory(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"depositOrders",[]);return this.parseTransactions(d,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.coin=r.id),t!==void 0&&(n.startTime=t);const a=await this.privatePostSupplementWithdraws(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"withdraws",[]);return this.parseTransactions(d,r,t,s)}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=this.checkRequiredCredentials(!1);let i;if(s===!0){let n=this.safeString(t,"method");if(t=this.omit(t,"method"),n===void 0){const r=this.safeValue(this.options,"fetchTransactionFees",{});n=this.safeString(r,"method","fetchPrivateTransactionFees")}i=await this[n](t)}else i=await this.fetchPublicTransactionFees(t);return i}async fetchPrivateTransactionFees(e={}){await this.loadMarkets();const t=await this.privatePostSupplementUserInfo(),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"coin"),o=this.safeCurrencyCode(a),d=this.safeValue(r,"networkList",[]);i[o]={};for(let c=0;c<d.length;c++){const u=d[c],h=this.safeString(u,"name"),l=this.safeString(this.options["inverse-networks"],h,h),p=this.safeNumber(u,"withdrawFee");p!==void 0&&(i[o][l]=p)}}return{withdraw:i,deposit:{},info:t}}async fetchPublicTransactionFees(e={}){await this.loadMarkets();const t=this.safeString2(e,"coin","assetCode");e=this.omit(e,["coin","assetCode"]);const s={};if(t!==void 0){const a=this.currency(t);s.assetCode=a.id}const i=await this.publicGetWithdrawConfigs(this.extend(s,e)),n=this.safeValue(i,"data",[]),r={};for(let a=0;a<n.length;a++){const o=n[a];if(this.safeString(o,"canWithDraw")==="true"){const c=this.safeString(o,"assetCode"),u=this.safeCurrencyCode(c),h=this.safeString(o,"chain");let l=this.safeString(this.options["inverse-networks"],h,h);l===void 0&&(l=u);const p=this.safeString(o,"fee");r[u]===void 0&&(r[u]={}),r[u][l]=this.parseNumber(p)}}return{withdraw:r,deposit:{},info:i}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.omit(i,this.extractParams(e)),o=this.urls.api.rest+"/"+this.version+"/"+this.implodeParams(e,i);if(o+=".do",t==="public")Object.keys(a).length&&(o+="?"+this.urlencode(this.keysort(a)));else{this.checkRequiredCredentials();const d=this.milliseconds().toString(),c=this.uuid22()+this.uuid16();a=this.extend({api_key:this.apiKey},a);let u;this.secret.length>32?u="RSA":u="HmacSHA256";const h=this.rawencode(this.keysort(this.extend({echostr:c,signature_method:u,timestamp:d},a))),l=this.encode(h),m=this.hash(l).toUpperCase();let g;if(u==="RSA"){const y=this.safeValue(this.options,"cacheSecretAsPem",!0);let b;y?(b=this.safeValue(this.options,"pem"),b===void 0&&(b=this.convertSecretToPem(this.encode(this.secret)),this.options.pem=b)):b=this.convertSecretToPem(this.encode(this.secret));const w=this.encode(b);g=this.binaryToBase64(this.rsa(m,w,"RS256"))}else u==="HmacSHA256"&&(g=this.hmac(this.encode(m),this.encode(this.secret)));a.sign=g,r=this.urlencode(this.keysort(a)),n={"Content-Type":"application/x-www-form-urlencoded",timestamp:d,signature_method:u,echostr:c}}return{url:o,method:s,body:r,headers:n}}convertSecretToPem(e){const s=e.length-0;let i=parseInt(s/64);i=this.sum(i,1);let n=`-----BEGIN PRIVATE KEY-----
`;for(let r=0;r<i;r++){const a=r*64,o=this.sum(a,64);n+=this.secret.slice(a,o)+`
`}return n+"-----END PRIVATE KEY-----"}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;if(this.safeString(a,"result")==="false"){const u=this.safeString(a,"error_code"),h=this.safeString({1e4:"Internal error",10001:"The required parameters can not be empty",10002:"Validation failed",10003:"Invalid parameter",10004:"Request too frequent",10005:"Secret key does not exist",10006:"User does not exist",10007:"Invalid signature",10008:"Invalid Trading Pair",10009:"Price and/or Amount are required for limit order",10010:"Price and/or Amount must be less than minimum requirement",10013:"The amount is too small",10014:"Insufficient amount of money in the account",10015:"Invalid order type",10016:"Insufficient account balance",10017:"Server Error",10018:"Page size should be between 1 and 50",10019:"Cancel NO more than 3 orders in one request",10020:"Volume < 0.001",10021:"Price < 0.01",10022:"Invalid authorization",10023:"Market Order is not supported yet",10024:"User cannot trade on this pair",10025:"Order has been filled",10026:"Order has been cancelld",10027:"Order is cancelling",10028:"Wrong query time",10029:"from is not in the query time",10030:"from do not match the transaction type of inqury",10031:"echostr length must be valid and length must be from 30 to 40",10033:"Failed to create order",10036:"customID duplicated",10100:"Has no privilege to withdraw",10101:"Invalid fee rate to withdraw",10102:"Too little to withdraw",10103:"Exceed daily limitation of withdraw",10104:"Cancel was rejected",10105:"Request has been cancelled",10106:"None trade time",10107:"Start price exception",10108:"can not create order",10109:"wallet address is not mapping",10110:"transfer fee is not mapping",10111:"mount > 0",10112:"fee is too lower",10113:"transfer fee is 0",10600:"intercepted by replay attacks filter, check timestamp",10601:"Interface closed unavailable",10701:"invalid asset code",10702:"not allowed deposit"},u,this.json(a)),l=this.safeValue({10001:ui,10002:ih,10003:ui,10004:HH,10005:ih,10006:ih,10007:ih,10008:Hv,10009:In,10010:In,10013:In,10014:X0,10015:In,10016:X0,10017:br,10018:ui,10019:ui,10020:ui,10021:In,10022:nh,10023:In,10024:nh,10025:In,10026:In,10027:In,10028:ui,10029:ui,10030:ui,10031:DH,10033:br,10036:FH,10100:nh,10101:ui,10102:X0,10103:br,10104:br,10105:br,10106:ui,10107:ui,10108:br,10109:RH,10110:br,10111:ui,10112:ui,10113:ui,10600:ui,10601:br,10701:Hv,10702:nh},u,br);throw new l(h)}}};const jH=ge,{TICK_SIZE:WH}=me,{ExchangeError:zH,ArgumentsRequired:KH,InvalidNonce:XH,OrderNotFound:Y0,InvalidOrder:Fc,InsufficientFunds:YH,AuthenticationError:Gv,DDoSProtection:Uv,NotSupported:QH,BadSymbol:ZH}=de,JH=Se;var e9=class extends jH{describe(){return this.deepExtend(super.describe(),{id:"liquid",name:"Liquid",countries:["JP","CN","TW"],version:"2",rateLimit:1e3,has:{CORS:void 0,spot:!0,margin:void 0,swap:void 0,future:!1,option:!1,cancelOrder:!0,createOrder:!0,editOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPositionMode:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchWithdrawals:!0,transfer:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/45798859-1a872600-bcb4-11e8-8746-69291ce87b04.jpg",api:{rest:"https://api.liquid.com"},www:"https://www.liquid.com",doc:["https://developers.liquid.com"],fees:"https://help.liquid.com/getting-started-with-liquid/the-platform/fee-structure",referral:"https://www.liquid.com/sign-up/?affiliate=SbzC62lt30976"},api:{public:{get:["currencies","products","products/{id}","products/{id}/price_levels","executions","ir_ladders/{currency}","fees"]},private:{get:["accounts","accounts/balance","accounts/main_asset","accounts/{id}","accounts/{currency}/reserved_balance_details","crypto_accounts","crypto_withdrawal","crypto_withdrawals","crypto_withdrawals/crypto_networks","executions/me","fiat_accounts","fund_infos","loan_bids","loans","orders","orders/{id}","orders/{id}/trades","trades","trades/{id}/loans","trading_accounts","trading_accounts/{id}","transactions","withdrawals","user/fee_tier","user/fees","trading_accounts/{id}","bank_accounts","accounts/{currency}/reserved_balance_details"],post:["crypto_withdrawals","fund_infos","fiat_accounts","loan_bids","orders","withdrawals","fees/estimate"],put:["crypto_withdrawal/{id}/cancel","loan_bids/{id}/close","loans/{id}","orders/{id}","orders/{id}/cancel","trades/{id}","trades/{id}/adjust_margin","trades/{id}/close","trades/close_all","trading_accounts/{id}","withdrawals/{id}/cancel"]}},fees:{trading:{tierBased:!0,percentage:!0,taker:.003,maker:0,tiers:{perpetual:{maker:[[0,0],[25e3,0],[5e4,-25e-5],[1e5,-25e-5],[1e6,-25e-5],[1e7,-25e-5],[25e6,-25e-5],[5e7,-25e-5],[75e6,-25e-5],[1e8,-25e-5],[2e8,-25e-5],[3e8,-25e-5]],taker:[[0,.0012],[25e3,.00115],[5e4,.0011],[1e5,.00105],[1e6,.001],[1e7,95e-5],[25e6,9e-4],[5e7,85e-5],[75e6,8e-4],[1e8,75e-5],[2e8,7e-4],[3e8,65e-5]]},spot:{taker:[[0,.003],[1e4,.0029],[2e4,.0028],[5e4,.0026],[1e5,.002],[1e6,.0016],[5e6,.0012],[1e7,.001],[25e6,9e-4],[5e7,8e-4],[1e8,7e-4],[2e8,6e-4],[5e8,4e-4],[1e9,3e-4]],maker:[[0,0],[1e4,.002],[2e4,.0019],[5e4,.0018],[1e5,.0016],[1e6,8e-4],[5e6,7e-4],[1e7,5e-4],[25e6,0],[5e7,0],[1e8,0],[2e8,0],[5e8,0],[1e9,0]]}}}},precisionMode:WH,exceptions:{exact:{"API rate limit exceeded. Please retry after 300s":Uv,"API Authentication failed":Gv,"Nonce is too small":XH,"Order not found":Y0,"Can not update partially filled order":Fc,"Can not update non-live order":Y0,not_enough_free_balance:YH,must_be_positive:Fc,less_than_order_size:Fc,price_too_high:Fc,price_too_small:Fc,product_disabled:ZH},broad:{"is not in your IP whitelist":Gv}},commonCurrencies:{BIFI:"BIFIF",HOT:"HOT Token",MIOTA:"IOTA","P-BTC":"BTC",TON:"Tokamak Network"},options:{cancelOrderException:!0,networks:{ETH:"ERC20",TRX:"TRC20",XLM:"Stellar",ALGO:"Algorand"},swap:{fetchMarkets:{settlementCurrencies:["BTC","ETH","XRP","QASH","USD","JPY","EUR","SGD","AUD"]}}}})}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.safeString(n,"name"),d=this.safeValue(n,"depositable"),c=this.safeValue(n,"withdrawable"),u=d&&c,h=this.parseNumber(this.parsePrecision(this.safeString(n,"assets_precision")));s[a]={id:r,code:a,info:n,name:o,active:u,deposit:d,withdraw:c,fee:this.safeNumber(n,"withdrawal_fee"),precision:h,limits:{amount:{min:h,max:void 0},withdraw:{min:this.safeNumber(n,"minimum_withdrawal"),max:void 0}}}}return s}async fetchMarkets(e={}){const t=await this.publicGetProducts(e),s=await this.publicGetProducts({perpetual:"1"}),i=await this.fetchCurrencies(),n=this.indexBy(i,"code"),r=[],a=this.arrayConcat(t,s);for(let o=0;o<a.length;o++){const d=a[o],c=this.safeString(d,"id"),u=this.safeString(d,"base_currency"),h=this.safeString(d,"quoted_currency"),p=this.safeString(d,"product_type")==="Perpetual",m=p?"swap":"spot",g=!p,y=this.safeCurrencyCode(u),b=this.safeCurrencyCode(h),w=this.safeValue(d,"disabled",!1),k=this.safeValue(n,y);let T;k!==void 0&&(T=this.safeNumber(k.info,"minimum_order_quantity"));const O=this.safeNumber(d,"last_traded_price");let x,C;if(O){const v=this.safeNumber(d,"multiplier_down"),N=this.safeNumber(d,"multiplier_up");v!==void 0&&(x=O*v),N!==void 0&&(C=O*N)}const E=this.safeValue(d,"margin_enabled"),P=y+"/"+b,_=this.fees.trading.maker,S=this.fees.trading.taker,I={id:c,symbol:P,base:y,quote:b,settle:void 0,baseId:u,quoteId:h,settleId:void 0,type:m,spot:g,margin:g&&E,swap:p,future:!1,option:!1,active:!w,contract:p,linear:void 0,inverse:void 0,taker:S,maker:_,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber("0.00000001"),price:this.safeNumber(d,"tick_size")},limits:{leverage:{min:void 0,max:void 0},amount:{min:T,max:void 0},price:{min:x,max:C},cost:{min:void 0,max:void 0}},info:d};if(p){const v=this.options.fetchMarkets.settlementCurrencies;for(let N=0;N<v.length;N++){const q=v[N];I.settle=q,I.symbol=P+":"+q,I.linear=b===q,I.inverse=y===q,I.taker=this.safeNumber(d,"taker_fee",S),I.maker=this.safeNumber(d,"maker_fee",_),I.contractSize=this.parseNumber("1"),r.push(I)}}else r.push(I)}return r}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"crypto_accounts",[]),i=this.safeValue(e,"fiat_accounts",[]);for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.account();d.total=this.safeString(r,"balance"),d.used=this.safeString(r,"reserved_balance"),t[o]=d}for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.account();d.total=this.safeString(r,"balance"),d.used=this.safeString(r,"reserved_balance"),t[o]=d}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccounts(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={id:i.id},r=await this.publicGetProductsIdPriceLevels(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"buy_price_levels","sell_price_levels")}parseTicker(e,t=void 0){const s=this.milliseconds();let i;"last_traded_price"in e&&e.last_traded_price&&e.last_traded_price.length>0&&(i=this.safeString(e,"last_traded_price"));const n=this.safeString(e,"id");t=this.safeMarket(n,t);let r=t.symbol;const a=this.safeString(e,"base_currency"),o=this.safeString(e,"quoted_currency");a!==void 0&&o!==void 0&&(r=this.safeCurrencyCode(a)+"/"+this.safeCurrencyCode(o));const d=this.safeString(e,"last_price_24h");return this.safeTicker({symbol:r,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high_market_ask"),low:this.safeString(e,"low_market_bid"),bid:this.safeString(e,"market_bid"),bidVolume:void 0,ask:this.safeString(e,"market_ask"),askVolume:void 0,vwap:void 0,open:d,close:i,last:i,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume_24h"),quoteVolume:void 0,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetProducts(t),i={};for(let n=0;n<s.length;n++){const r=this.parseTicker(s[n]),a=r.symbol;i[a]=r}return this.filterByArray(i,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={id:s.id},n=await this.publicGetProductsId(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"created_at"),i=this.safeString(e,"order_id"),n=this.safeString(e,"taker_side"),r=this.safeString(e,"my_side"),a=r!==void 0?r:n;let o;r!==void 0&&(o=n===r?"taker":"maker");const d=this.safeString(e,"price"),c=this.safeString(e,"quantity"),u=this.safeString(e,"id");return t=this.safeMarket(void 0,t),this.safeTrade({info:e,id:u,order:i,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:void 0,side:a,takerOrMaker:o,price:d,amount:c,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={product_id:n.id};s!==void 0&&(r.limit=s),t!==void 0&&(r.timestamp=parseInt(t/1e3));const a=await this.publicGetExecutions(this.extend(r,i)),o=t!==void 0?a:a.models;return this.parseTrades(o,n,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={id:s.id},n=await this.publicGetProductsId(this.extend(i,t));return this.parseTradingFee(n,s)}parseTradingFee(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeSymbol(s,t);return{info:e,symbol:i,maker:this.safeNumber(e,"maker_fee"),taker:this.safeNumber(e,"taker_fee"),percentage:!0,tierBased:!0}}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetProducts(e),s=await this.publicGetProducts({perpetual:"1"}),i=this.arrayConcat(t,s),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"id"),d=this.safeSymbol(o,a);n[d]=this.parseTradingFee(a)}return n}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={product_id:n.id,with_details:!0};s!==void 0&&(r.limit=s);const a=await this.privateGetExecutionsMe(this.extend(r,i));return this.parseTrades(a.models,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.safeString2(r,"clientOrderId","client_order_id");r=this.omit(r,["clientOrderId","client_order_id"]);const o=this.market(e),d={order_type:t,product_id:o.id,side:s,quantity:this.amountToPrecision(o.symbol,i)};a!==void 0&&(d.client_order_id=a),(t==="limit"||t==="limit_post_only"||t==="market_with_range"||t==="stop")&&(d.price=this.priceToPrecision(o.symbol,n));const c=await this.privatePostOrders(this.extend(d,r));return this.parseOrder(c)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privatePutOrdersIdCancel(this.extend(i,s)),r=this.parseOrder(n);if(r.status==="closed"&&this.options.cancelOrderException)throw new Y0(this.id+" order closed already: "+this.json(n));return r}async editOrder(e,t,s,i,n,r=void 0,a={}){if(await this.loadMarkets(),r===void 0)throw new KH(this.id+" editOrder() requires the price argument");const o={order:{quantity:this.amountToPrecision(t,n),price:this.priceToPrecision(t,r)},id:e},d=await this.privatePutOrdersId(this.extend(o,a));return this.parseOrder(d)}parseOrderStatus(e){const t={live:"open",filled:"closed",cancelled:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeTimestamp(e,"created_at"),n=this.safeString(e,"product_id");t=this.safeMarket(n,t);const r=this.parseOrderStatus(this.safeString(e,"status")),a=this.safeString(e,"quantity"),o=this.safeString(e,"filled_quantity"),d=this.safeString(e,"price"),c=this.safeString(e,"order_type"),u=this.safeString(e,"average_price"),h=this.safeValue(e,"executions",[]),l=this.safeString(e,"side"),p=this.safeString(e,"client_order_id");return this.safeOrder({id:s,clientOrderId:p,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,type:c,timeInForce:void 0,postOnly:void 0,status:r,symbol:t.symbol,side:l,price:d,stopPrice:void 0,amount:a,filled:o,cost:void 0,remaining:void 0,average:u,trades:h,fee:{currency:t.quote,cost:this.safeString(e,"order_fee")},info:e})}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetOrdersId(this.extend(i,s));return this.parseOrder(n)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={with_details:1};e!==void 0&&(n=this.market(e),r.product_id=n.id),s!==void 0&&(r.limit=s);const a=await this.privateGetOrders(this.extend(r,i)),o=this.safeValue(a,"models",[]);return this.parseOrders(o,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"live"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"filled"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={crypto_withdrawal:{currency:r.id,address:s,amount:t}};if(i!==void 0)if(e==="XRP")a.crypto_withdrawal.payment_id=i;else if(e==="XLM")a.crypto_withdrawal.memo_type="text",a.crypto_withdrawal.memo_value=i;else throw new QH(this.id+" withdraw() only supports a tag along the address for XRP or XLM");const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");if(d===void 0){const u=this.safeValue(n,"crypto_withdrawal",{});d=this.safeStringUpper(u,"network")}d=this.safeString(o,d,d),d!==void 0&&(a.crypto_withdrawal.network=d,n=this.omit(n,"network"),n.crypto_withdrawal=this.omit(n.crypto_withdrawal,"network"));const c=await this.privatePostCryptoWithdrawals(this.deepExtend(a,n));return this.parseTransaction(c,r)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e));const a=await this.privateGetCryptoWithdrawals(this.extend(n,i)),o=this.safeValue(a,"models",[]);return this.parseTransactions(o,r,t,s)}parseTransactionStatus(e){const t={pending:"pending",cancelled:"canceled",approved:"ok",processing:"pending",processed:"ok",reverted:"failed",to_be_reviewed:"pending",declined:"failed",broadcasted:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"address"),n=this.safeString2(e,"payment_id","memo_value"),r=this.safeString(e,"transaction_hash"),a=this.safeString2(e,"currency","asset"),o=this.safeCurrencyCode(a,t),d=this.safeTimestamp(e,"created_at"),c=this.safeTimestamp(e,"updated_at"),u="withdrawal",h=this.parseTransactionStatus(this.safeString(e,"state")),l=this.safeString(e,"amount"),p=this.safeString(e,"withdrawal_fee"),m=this.parseNumber(JH.stringSub(l,p)),g=this.safeString(e,"chain_name");return{info:e,id:s,txid:r,timestamp:d,datetime:this.iso8601(d),network:g,address:i,addressTo:void 0,addressFrom:void 0,tag:n,tagTo:void 0,tagFrom:void 0,type:u,amount:m,currency:o,status:h,updated:c,fee:{currency:o,cost:this.parseNumber(p)}}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(n={"X-Quoine-API-Version":this.version,"Content-Type":"application/json"},t==="private"){this.checkRequiredCredentials(),s==="GET"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):Object.keys(o).length&&(r=this.json(o));const d=this.nonce(),c={path:a,token_id:this.apiKey,iat:Math.floor(d/1e3)};"client_order_id"in o||(c.nonce=d),n["X-Quoine-Auth"]=this.jwt(c,this.encode(this.secret))}else Object.keys(o).length&&(a+="?"+this.urlencode(o));return a=this.urls.api.rest+a,{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(e>=200&&e<300)return;if(e===401){this.throwExactlyMatchedException(this.exceptions.exact,r,r);return}if(e===429)throw new Uv(this.id+" "+r);if(a===void 0)return;const c=this.id+" "+r,u=this.safeString(a,"message"),h=this.safeValue(a,"errors");if(u!==void 0)this.throwExactlyMatchedException(this.exceptions.exact,u,c),this.throwBroadlyMatchedException(this.exceptions.broad,u,c);else if(h!==void 0){const l=Object.keys(h);for(let p=0;p<l.length;p++){const m=l[p],g=h[m];for(let y=0;y<g.length;y++){const b=g[y];this.throwExactlyMatchedException(this.exceptions.exact,b,c)}}}else throw new zH(c)}};const t9=ge,{ExchangeError:rh,ArgumentsRequired:$v}=de,{TICK_SIZE:s9}=me,jo=Se;var eC=class extends t9{describe(){return this.deepExtend(super.describe(),{id:"luno",name:"luno",countries:["GB","SG","ZA"],rateLimit:200,version:"1",pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchAccounts:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},urls:{referral:"https://www.luno.com/invite/44893A",logo:"https://user-images.githubusercontent.com/1294454/27766607-8c1a69d8-5ede-11e7-930c-540b5eb9be24.jpg",api:{public:"https://api.luno.com/api",private:"https://api.luno.com/api",exchange:"https://api.luno.com/api/exchange"},www:"https://www.luno.com",doc:["https://www.luno.com/en/api","https://npmjs.org/package/bitx","https://github.com/bausmeier/node-bitx"]},api:{exchange:{get:{markets:1}},public:{get:{orderbook:1,orderbook_top:1,ticker:1,tickers:1,trades:1}},private:{get:{"accounts/{id}/pending":1,"accounts/{id}/transactions":1,balance:1,beneficiaries:1,fee_info:1,funding_address:1,listorders:1,listtrades:1,"orders/{id}":1,"quotes/{id}":1,withdrawals:1,"withdrawals/{id}":1,transfers:1},post:{accounts:1,"accounts/{id}/name":1,postorder:1,marketorder:1,stoporder:1,funding_address:1,withdrawals:1,send:1,quotes:1,"oauth2/grant":1},put:{"accounts/{id}/name":1,"quotes/{id}":1},delete:{"quotes/{id}":1,"withdrawals/{id}":1}}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0")}},precisionMode:s9})}async fetchMarkets(e={}){const t=await this.exchangeGetMarkets(e),s=[],i=this.safeValue(t,"markets",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"market_id"),o=this.safeString(r,"base_currency"),d=this.safeString(r,"counter_currency"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d),h=this.safeString(r,"trading_status");s.push({id:a,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:h==="ACTIVE",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"volume_scale"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"price_scale")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"min_volume"),max:this.safeNumber(r,"max_volume")},price:{min:this.safeNumber(r,"min_price"),max:this.safeNumber(r,"max_price")},cost:{min:void 0,max:void 0}},info:r})}return s}async fetchAccounts(e={}){const t=await this.privateGetBalance(e),s=this.safeValue(t,"balance",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"account_id"),o=this.safeString(r,"asset"),d=this.safeCurrencyCode(o);i.push({id:a,type:void 0,currency:d,info:r})}return i}parseBalance(e){const t=this.safeValue(e,"balance",[]),s={info:e,timestamp:void 0,datetime:void 0};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"asset"),a=this.safeCurrencyCode(r),o=this.safeString(n,"reserved"),d=this.safeString(n,"unconfirmed"),c=this.safeString(n,"balance"),u=jo.stringAdd(o,d),h=jo.stringAdd(c,d);if(a in s)s[a].used=jo.stringAdd(s[a].used,u),s[a].total=jo.stringAdd(s[a].total,h);else{const l=this.account();l.used=u,l.total=h,s[a]=l}}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();let i="publicGetOrderbook";t!==void 0&&t<=100&&(i+="Top");const n=this.market(e),r={pair:n.id},a=await this[i](this.extend(r,s)),o=this.safeInteger(a,"timestamp");return this.parseOrderBook(a,n.symbol,o,"bids","asks","price","volume")}parseOrderStatus(e){const t={PENDING:"open"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"creation_timestamp");let i=this.parseOrderStatus(this.safeString(e,"state"));i=i;let n;const r=this.safeString(e,"type");r==="ASK"||r==="SELL"?n="sell":(r==="BID"||r==="BUY")&&(n="buy");const a=this.safeString(e,"pair");t=this.safeMarket(a,t);const o=this.safeString(e,"limit_price"),d=this.safeString(e,"limit_volume"),c=this.safeNumber(e,"fee_counter"),u=this.safeNumber(e,"fee_base"),h=this.safeString(e,"base"),l=this.safeString(e,"counter");let p;c!==void 0?p={cost:c,currency:t.quote}:u!==void 0&&(p={cost:u,currency:t.base});const m=this.safeString(e,"order_id");return this.safeOrder({id:m,clientOrderId:void 0,datetime:this.iso8601(s),timestamp:s,lastTradeTimestamp:void 0,status:i,symbol:t.symbol,type:void 0,timeInForce:void 0,postOnly:void 0,side:n,price:o,stopPrice:void 0,amount:d,filled:h,cost:l,remaining:void 0,trades:void 0,fee:p,info:e,average:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetOrdersId(this.extend(i,s));return this.parseOrder(n)}async fetchOrdersByState(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a;e!==void 0&&(r.state=e),t!==void 0&&(a=this.market(t),r.pair=a.id);const o=await this.privateGetListorders(this.extend(r,n)),d=this.safeValue(o,"orders",[]);return this.parseOrders(d,a,s,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState(void 0,e,t,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState("PENDING",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState("COMPLETE",e,t,s,i)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"pair"),n=this.safeSymbol(i,t),r=this.safeString(e,"last_trade");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:void 0,low:void 0,bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"rolling_24_hour_volume"),quoteVolume:void 0,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTickers(t),i=this.indexBy(s.tickers,"pair"),n=Object.keys(i),r={};for(let a=0;a<n.length;a++){const o=n[a],d=this.safeMarket(o),c=d.symbol,u=i[o];r[c]=this.parseTicker(u,d)}return this.filterByArray(r,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetTicker(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t){const s=this.safeString(e,"order_id"),i=this.safeString(e,"sequence");let n,r;if(s!==void 0){const h=this.safeString(e,"type");h==="ASK"||h==="SELL"?r="sell":(h==="BID"||h==="BUY")&&(r="buy"),r==="sell"&&e.is_buy||r==="buy"&&!e.is_buy?n="maker":n="taker"}else r=e.is_buy?"buy":"sell";const a=this.safeString(e,"fee_base"),o=this.safeString(e,"fee_counter");let d,c;a!==void 0?jo.stringEquals(a,"0.0")||(d=t.base,c=a):o!==void 0&&(jo.stringEquals(o,"0.0")||(d=t.quote,c=o));const u=this.safeInteger(e,"timestamp");return this.safeTrade({info:e,id:i,timestamp:u,datetime:this.iso8601(u),symbol:t.symbol,order:s,type:void 0,side:r,takerOrMaker:n,price:this.safeString(e,"price"),amount:this.safeString2(e,"volume","base"),cost:this.safeString(e,"counter"),fee:{cost:c,currency:d}},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id};t!==void 0&&(r.since=t);const a=await this.publicGetTrades(this.extend(r,i)),o=this.safeValue(a,"trades",[]);return this.parseTrades(o,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new $v(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={pair:n.id};t!==void 0&&(r.since=t),s!==void 0&&(r.limit=s);const a=await this.privateGetListtrades(this.extend(r,i)),o=this.safeValue(a,"trades",[]);return this.parseTrades(o,n,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const i={symbol:this.market(e).id},n=await this.privateGetFeeInfo(this.extend(i,t));return{info:n,symbol:e,maker:this.safeNumber(n,"maker_fee"),taker:this.safeNumber(n,"taker_fee")}}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();let a="privatePost";const o=this.market(e),d={pair:o.id};t==="market"?(a+="Marketorder",d.type=s.toUpperCase(),s==="buy"?d.counter_volume=this.amountToPrecision(o.symbol,i):d.base_volume=this.amountToPrecision(o.symbol,i)):(a+="Postorder",d.volume=this.amountToPrecision(o.symbol,i),d.price=this.priceToPrecision(o.symbol,n),d.type=s==="buy"?"BID":"ASK");const c=await this[a](this.extend(d,r));return{info:c,id:c.order_id}}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e};return await this.privatePostStoporder(this.extend(i,s))}async fetchLedgerByEntries(e=void 0,t=-1,s=1,i={}){const r={min_row:t,max_row:this.sum(t,s)};return await this.fetchLedger(e,void 0,s,this.extend(r,i))}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.loadAccounts();let n,r=this.safeString(i,"id"),a=this.safeValue(i,"min_row"),o=this.safeValue(i,"max_row");if(r===void 0){if(e===void 0)throw new $v(this.id+" fetchLedger() requires a currency code argument if no account id specified in params");n=this.currency(e);const h=this.indexBy(this.accounts,"currency"),l=this.safeValue(h,e);if(l===void 0)throw new rh(this.id+" fetchLedger() could not find account id for "+e);r=l.id}if(a===void 0&&o===void 0)o=0,a=-1e3;else if(a===void 0||o===void 0)throw new rh(this.id+" fetchLedger() require both params 'max_row' and 'min_row' or neither to be defined");if(s!==void 0&&o-a>s&&(o<=0?a=o-s:a>0&&(o=a+s)),o-a>1e3)throw new rh(this.id+" fetchLedger() requires the params 'max_row' - 'min_row' <= 1000");const d={id:r,min_row:a,max_row:o},c=await this.privateGetAccountsIdTransactions(this.extend(i,d)),u=this.safeValue(c,"transactions",[]);return this.parseLedger(u,n,t,s)}parseLedgerComment(e){const t=e.split(" "),s={Withdrawal:"fee",Trading:"fee",Payment:"transaction",Sent:"transaction",Deposit:"transaction",Received:"transaction",Released:"released",Reserved:"reserved",Sold:"trade",Bought:"trade",Failure:"failed"};let i;const n=this.safeString(t,0),r=this.safeString(t,2),a=this.safeString(t,3);let o=this.safeString(s,n,void 0);return o===void 0&&r==="fee"&&(o="fee"),o==="reserved"&&a==="order"&&(i=this.safeString(t,4)),{type:o,referenceId:i}}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"row_index"),i=this.safeString(e,"account_id"),n=this.safeValue(e,"timestamp"),r=this.safeString(e,"currency"),a=this.safeCurrencyCode(r,t),o=this.safeNumber(e,"available_delta"),d=this.safeNumber(e,"balance_delta"),c=this.safeNumber(e,"balance"),u=this.safeString(e,"description");let h=c,l=0;const p=this.parseLedgerComment(u),m=p.type,g=p.referenceId;let y,b;return d!==0?(h=c-d,b="ok",l=Math.abs(d)):o<0?(b="pending",l=Math.abs(o)):o>0&&(b="canceled",l=Math.abs(o)),d>0||o>0?y="in":(d<0||o<0)&&(y="out"),{id:s,direction:y,account:i,referenceId:g,referenceAccount:void 0,type:m,currency:a,amount:l,timestamp:n,datetime:this.iso8601(n),before:h,after:c,status:b,fee:void 0,info:e}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(Object.keys(o).length&&(a+="?"+this.urlencode(o)),t==="private"){this.checkRequiredCredentials();const d=this.stringToBase64(this.apiKey+":"+this.secret);n={Authorization:"Basic "+this.decode(d)}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;if(this.safeValue(a,"error")!==void 0)throw new rh(this.id+" "+this.json(a))}};const i9=ge,{NotSupported:n9,ExchangeError:ra,BadRequest:r9,InsufficientFunds:Dc,InvalidOrder:nn,DuplicateOrderId:a9}=de,{TICK_SIZE:o9}=me,d9=Se;var c9=class extends i9{describe(){return this.deepExtend(super.describe(),{id:"lykke",name:"Lykke",countries:["UK"],version:"2",rateLimit:200,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,editOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:"emulated",fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchOrderTrades:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!1,fetchTransactions:!0,fetchWithdrawals:!1,setLeverage:!1,setMarginMode:!1,withdraw:!0},requiredCredentials:{apiKey:!0,secret:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/155840500-1ea4fdf0-47c0-4daa-9597-c6c1cd51b9ec.jpg",api:{public:"https://hft-apiv2.lykke.com/api",private:"https://hft-apiv2.lykke.com/api"},www:"https://www.lykke.com",doc:["https://hft-apiv2.lykke.com/swagger/ui/index.html","https://lykkecity.github.io/Trading-API"],fees:"https://support.lykke.com/hc/en-us/articles/115002141125-What-are-the-fees-and-charges-"},api:{public:{get:{assetpairs:2.5,"assetpairs/{id}":2.5,assets:2.5,"assets/{id}":2.5,isalive:2.5,orderbooks:2.5,tickers:2.5,prices:2.5,"trades/public/{assetPairId}":2.5}},private:{get:{balance:2.5,trades:2.5,"trades/order/{orderId}":2.5,"orders/active":1,"orders/closed":1,"orders/{orderId}":1,operations:2.5,"operations/deposits/addresses":2.5,"operations/deposits/addresses/{assetId}":2.5},post:{"orders/limit":1,"orders/market":1,"orders/bulk":1,"operations/withdrawals":2.5,"operations/deposits/addresses":2.5},delete:{orders:1,"orders/{orderId}":1}}},fees:{trading:{tierBased:!1,percentage:!0,maker:0,taker:0}},precisionMode:o9,exceptions:{exact:{1001:ra,1100:ra,1101:ra,2e3:r9,2001:Dc,2202:a9,2003:ra,2004:n9,2005:ra,2006:Dc,2007:Dc,2008:Dc,2009:ra,2010:Dc,2011:nn,2012:nn,2013:nn,2014:nn,2015:nn,2016:nn,2017:nn,2018:nn,2019:nn,2020:nn,2021:nn,2022:nn,2023:ra},broad:{}},commonCurrencies:{}})}async fetchCurrencies(e={}){const t=await this.publicGetAssets(e),s=this.safeValue(t,"payload",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"assetId"),o=this.safeString(r,"symbol"),d=this.safeString(r,"name"),c=this.safeString(r,"type"),u=this.safeValue(r,"blockchainDepositEnabled"),h=this.safeValue(r,"blockchainWithdrawal"),p=!this.safeValue(r,"isDisabled");i[o]={id:a,code:o,info:r,type:c,name:d,active:p,deposit:u,withdraw:h,fee:void 0,precision:this.parseNumber(this.parsePrecision(this.safeString(r,"accuracy"))),limits:{withdraw:{min:this.safeValue(r,"cashoutMinimalAmount"),max:void 0},amount:{min:this.safeValue(r,"lowVolumeAmount"),max:void 0}}}}return i}async fetchMarkets(e={}){const t=await this.publicGetAssetpairs(e),s=this.safeValue(t,"payload",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"assetPairId"),o=this.safeString(r,"name"),d=this.safeString(r,"baseAssetId"),c=this.safeString(r,"quoteAssetId"),[u,h]=o.split("/"),l=this.safeCurrencyCode(u),p=this.safeCurrencyCode(h),m=l+"/"+p;i.push({id:a,symbol:m,base:l,quote:p,baseId:d,quoteId:c,settle:void 0,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,contract:!1,active:!0,info:r,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"baseAssetAccuracy"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"priceAccuracy")))},limits:{amount:{min:this.safeNumber(r,"minVolume"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(r,"minOppositeVolume"),max:void 0},leverage:{min:void 0,max:void 0}}})}return i}parseTicker(e,t=void 0){const i=this.safeString(e,"assetPairId");t=this.safeMarket(i,t);const n=this.safeString(e,"lastPrice");return this.safeTicker({symbol:this.safeString(t,"symbol"),timestamp:void 0,datetime:this.iso8601(void 0),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:this.safeString(e,"priceChange"),percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volumeBase"),quoteVolume:this.safeString(e,"volumeQuote"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={assetPairIds:s.id},n=this.safeString(this.options,"fetchTickerMethod","publicGetTickers"),r=await this[n](this.extend(i,t)),a=this.safeValue(r,"payload",[]);return this.parseTicker(this.safeValue(a,0,{}),s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickers(t),i=this.safeValue(s,"payload",[]);return this.parseTickers(i,e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={assetPairId:i.id};t!==void 0&&(n.depth=t);const r=await this.publicGetOrderbooks(this.extend(n,s)),a=this.safeValue(r,"payload",[]),o=this.safeValue(a,0,{}),d=this.safeInteger(o,"timestamp");return this.parseOrderBook(o,i.symbol,d,"bids","asks","p","v")}parseTrade(e,t){const s=this.safeString(e,"assetPairId");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeString2(e,"id","id"),r=this.safeString(e,"orderId"),a=this.safeInteger(e,"timestamp"),o=this.safeString2(e,"price","price");let d=this.safeString2(e,"volume","amount");d===void 0&&(d=this.safeString2(e,"baseVolume","amount"));const c=this.safeStringLower(e,"side");return this.safeTrade({id:n,info:e,timestamp:a,datetime:this.iso8601(a),symbol:i,type:void 0,order:r,side:c,takerOrMaker:void 0,price:o,amount:d,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={assetPairId:n.id};s!==void 0&&(r.take=s);const a=await this.publicGetTradesPublicAssetPairId(this.extend(r,i)),o=this.safeValue(a,"payload",[]);return this.parseTrades(o,n,t,s)}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"assetId"),r=this.safeCurrencyCode(n),a=this.account(),o=this.safeString(i,"available"),d=this.safeString(i,"reserved");a.free=o,a.used=d,t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalance(e),s=this.safeValue(t,"payload",[]);return this.parseBalance(s)}parseOrderStatus(e){const t={Open:"open",Pending:"open",InOrderBook:"open",Processing:"open",Matched:"closed",Cancelled:"canceled",Rejected:"rejected",Replaced:"canceled",Placed:"open"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.parseOrderStatus(this.safeString(e,"status")),n=this.safeString(e,"assetPairId"),r=this.safeSymbol(n,t),a=this.safeStringLower(e,"type"),o=this.safeInteger(e,"lastTradeTimestamp"),d=this.safeInteger(e,"timestamp"),c=this.safeString(e,"price"),u=this.safeStringLower(e,"side"),h=this.safeString(e,"volume"),l=this.safeString(e,"remainingVolume"),p=this.safeString(e,"filledVolume"),m=this.safeString(e,"cost");return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:d,datetime:this.iso8601(d),lastTradeTimestamp:o,symbol:r,type:a,timeInForce:void 0,postOnly:void 0,side:u,price:c,stopPrice:void 0,amount:h,cost:m,average:void 0,filled:p,remaining:l,status:i,fee:void 0,trades:void 0},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={assetPairId:a.id,side:this.capitalize(s),volume:parseFloat(this.amountToPrecision(a.symbol,i))};t==="limit"&&(o.price=parseFloat(this.priceToPrecision(a.symbol,n)));const d="privatePostOrders"+this.capitalize(t),c=await this[d](this.extend(o,r)),u=this.safeValue(c,"payload"),h=this.safeString(u,"orderId");return t==="market"&&(n=this.safeNumber(u,"price")),{id:h,info:c,clientOrderId:void 0,timestamp:void 0,datetime:void 0,lastTradeTimestamp:void 0,symbol:a.symbol,type:t,side:s,price:n,amount:i,cost:void 0,average:void 0,filled:void 0,remaining:void 0,status:void 0,fee:void 0,trades:void 0}}async cancelOrder(e,t=void 0,s={}){const i={orderId:e};return await this.privateDeleteOrdersOrderId(this.extend(i,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;return e!==void 0&&(i=this.market(e),s.assetPairId=i.id),await this.privateDeleteOrders(this.extend(s,t))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e},n=await this.privateGetOrdersOrderId(this.extend(i,s)),r=this.safeValue(n,"payload");return this.parseOrder(r)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));const r={};s!==void 0&&(r.take=s);const a=await this.privateGetOrdersActive(this.extend(r,i)),o=this.safeValue(a,"payload");return this.parseOrders(o,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));const r={};s!==void 0&&(r.take=s);const a=await this.privateGetOrdersClosed(this.extend(r,i)),o=this.safeValue(a,"payload");return this.parseOrders(o,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;s!==void 0&&(n.take=s),e!==void 0&&(r=this.market(e),n.assetPairId=r.id),t!==void 0&&(n.from=t);const a=await this.privateGetTrades(this.extend(n,i)),o=this.safeValue(a,"payload");return this.parseTrades(o,r,t,s)}parseBidAsk(e,t=0,s=1){const i=this.safeString(e,t),n=d9.stringAbs(this.safeString(e,s));return[this.parseNumber(i),this.parseNumber(n)]}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={assetId:this.safeString(s,"id")},n=await this.privateGetOperationsDepositsAddressesAssetId(this.extend(i,t)),r=this.safeString(n,"baseAddress"),a=this.safeString(n,"addressExtension");return this.checkAddress(r),{currency:e,address:r,tag:a,network:void 0,info:n}}parseTransaction(e,t=void 0){let s,i,n,r,a,o,d;if(typeof e=="string")s=e;else{s=this.safeString(e,"operationId"),i=this.safeString(e,"assetId"),n=this.safeCurrencyCode(i,t),r=this.safeNumber(e,"totalVolume"),o=this.safeString(e,"type"),d=this.safeInteger(e,"timestamp");const c=this.safeNumber(e,"fee");a={currency:n,cost:c}}return{info:e,id:s,txid:void 0,timestamp:d,datetime:this.iso8601(d),network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,type:o,amount:r,currency:n,status:void 0,updated:void 0,fee:a}}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};s!==void 0&&(n.take=s);const r=await this.privateGetOperations(this.extend(n,i)),a=this.safeValue(r,"payload",[]);let o;return e!==void 0&&(o=this.currency(e)),this.parseTransactions(a,o,t,s)}async withdraw(e,t,s,i=void 0,n={}){await this.loadMarkets(),this.checkAddress(s);const r=this.currency(e),a={assetId:r.id,volume:parseFloat(this.currencyToPrecision(e,t)),destinationAddress:s};i!==void 0&&(a.destinationAddressExtension=i);const o=await this.privatePostOperationsWithdrawals(this.extend(a,n));return this.parseTransaction(o,r)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));return n={Accept:"application/json","Content-Type":"application/json"},t==="public"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):t==="private"&&((s==="GET"||s==="DELETE")&&Object.keys(o).length&&(a+="?"+this.urlencode(o)),this.checkRequiredCredentials(),n.Authorization="Bearer "+this.apiKey,s==="POST"&&Object.keys(i).length&&(r=this.json(i)),e==="operations/withdrawals"&&(n["X-Request-ID"]=this.uuid())),{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeValue(a,"error",{}),u=this.safeString(c,"code");if(u!==void 0&&u!=="0"){const h=this.id+" "+r,l=this.safeString(c,"message");throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwBroadlyMatchedException(this.exceptions.broad,l,h),new ra(h)}}};const u9=ge,{ExchangeError:f9,ArgumentsRequired:aa,InvalidOrder:h9}=de,{TICK_SIZE:l9}=me;var p9=class extends u9{describe(){return this.deepExtend(super.describe(),{id:"mercado",name:"Mercado Bitcoin",countries:["BR"],rateLimit:1e3,version:"v3",has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:"emulated",fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:void 0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},timeframes:{"15m":"15m","1h":"1h","3h":"3h","1d":"1d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27837060-e7c58714-60ea-11e7-9192-f05e86adb83f.jpg",api:{public:"https://www.mercadobitcoin.net/api",private:"https://www.mercadobitcoin.net/tapi",v4Public:"https://www.mercadobitcoin.com.br/v4",v4PublicNet:"https://api.mercadobitcoin.net/api/v4"},www:"https://www.mercadobitcoin.com.br",doc:["https://www.mercadobitcoin.com.br/api-doc","https://www.mercadobitcoin.com.br/trade-api","https://api.mercadobitcoin.net/api/v4/docs/"]},api:{public:{get:["coins","{coin}/orderbook/","{coin}/ticker/","{coin}/trades/","{coin}/trades/{from}/","{coin}/trades/{from}/{to}","{coin}/day-summary/{year}/{month}/{day}/"]},private:{post:["cancel_order","get_account_info","get_order","get_withdrawal","list_system_messages","list_orders","list_orderbook","place_buy_order","place_sell_order","place_market_buy_order","place_market_sell_order","withdraw_coin"]},v4Public:{get:["{coin}/candle/"]},v4PublicNet:{get:["candles"]}},fees:{trading:{maker:.003,taker:.007}},options:{limits:{BTC:.001,BCH:.001,ETH:.01,LTC:.01,XRP:.1}},precisionMode:l9})}async fetchMarkets(e={}){const t=await this.publicGetCoins(e),s=[],i=this.safeValue(this.options,"limits",{});for(let n=0;n<t.length;n++){const r=t[n],a=r,o="BRL",d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o),u=c+d,h="1e-5";s.push({id:u,symbol:d+"/"+c,base:d,quote:c,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber("0.00000001"),price:this.parseNumber("0.00001")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(i,a),max:void 0},price:{min:this.parseNumber(h),max:void 0},cost:{min:void 0,max:void 0}},info:r})}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={coin:i.base},r=await this.publicGetCoinOrderbook(this.extend(n,s));return this.parseOrderBook(r,i.symbol)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeTimestamp(e,"date"),n=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"vol"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={coin:s.base},n=await this.publicGetCoinTicker(this.extend(i,t)),r=this.safeValue(n,"ticker",{});return this.parseTicker(r,s)}parseTrade(e,t=void 0){const s=this.safeTimestamp2(e,"date","executed_timestamp");t=this.safeMarket(void 0,t);const i=this.safeString2(e,"tid","operation_id"),n=void 0,r=this.safeString(e,"type"),a=this.safeString(e,"price"),o=this.safeString2(e,"amount","quantity"),d=this.safeString(e,"fee_rate");let c;return d!==void 0&&(c={cost:d,currency:void 0}),this.safeTrade({id:i,info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:void 0,type:n,side:r,takerOrMaker:void 0,price:a,amount:o,cost:void 0,fee:c},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);let r="publicGetCoinTrades";const a={coin:n.base};t!==void 0&&(r+="From",a.from=parseInt(t/1e3)),this.safeInteger(i,"to")!==void 0&&(r+="To");const d=await this[r](this.extend(a,i));return this.parseTrades(d,n,t,s)}parseBalance(e){const t=this.safeValue(e,"response_data",{}),s=this.safeValue(t,"balance",{}),i={info:e},n=Object.keys(s);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeCurrencyCode(a);if(a in s){const d=this.safeValue(s,a,{}),c=this.account();c.free=this.safeString(d,"available"),c.total=this.safeString(d,"total"),i[o]=c}}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetAccountInfo(e);return this.parseBalance(t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={coin_pair:a.id};let d=this.capitalize(s)+"Order";if(t==="limit")d="privatePostPlace"+d,o.limit_price=this.priceToPrecision(a.symbol,n),o.quantity=this.amountToPrecision(a.symbol,i);else if(d="privatePostPlaceMarket"+d,s==="buy"){if(n===void 0)throw new h9(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount");o.cost=this.priceToPrecision(a.symbol,i*n)}else o.quantity=this.amountToPrecision(a.symbol,i);const c=await this[d](this.extend(o,r));return{info:c,id:c.response_data.order.order_id.toString()}}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new aa(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={coin_pair:i.id,order_id:e},r=await this.privatePostCancelOrder(this.extend(n,s)),a=this.safeValue(r,"response_data",{}),o=this.safeValue(a,"order",{});return this.parseOrder(o,i)}parseOrderStatus(e){const t={2:"open",3:"canceled",4:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"order_id"),i=this.safeString(e,"order_type");let n;"order_type"in e&&(n=i==="1"?"buy":"sell");const r=this.parseOrderStatus(this.safeString(e,"status")),a=this.safeString(e,"coin_pair");t=this.safeMarket(a,t);const o=this.safeTimestamp(e,"created_timestamp"),d={cost:this.safeString(e,"fee"),currency:t.quote},c=this.safeString(e,"limit_price"),u=this.safeString(e,"executed_price_avg"),h=this.safeString(e,"quantity"),l=this.safeString(e,"executed_quantity"),p=this.safeTimestamp(e,"updated_timestamp"),m=this.safeValue(e,"operations",[]);return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:p,symbol:t.symbol,type:"limit",timeInForce:void 0,postOnly:void 0,side:n,price:c,stopPrice:void 0,cost:void 0,average:u,amount:h,filled:l,remaining:void 0,status:r,fee:d,trades:m},t)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new aa(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={coin_pair:i.id,order_id:parseInt(e)},r=await this.privatePostGetOrder(this.extend(n,s)),a=this.safeValue(r,"response_data",{}),o=this.safeValue(a,"order");return this.parseOrder(o,i)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={coin:r.id,quantity:t.toFixed(10),address:s};if(e==="BRL"){if(!("account_ref"in n))throw new aa(this.id+" withdraw() requires account_ref parameter to withdraw "+e)}else if(e!=="LTC"){if(!("tx_fee"in n))throw new aa(this.id+" withdraw() requires tx_fee parameter to withdraw "+e);if(e==="XRP")if(i===void 0){if(!("destination_tag"in n))throw new aa(this.id+" withdraw() requires a tag argument or destination_tag parameter to withdraw "+e)}else a.destination_tag=i}const o=await this.privatePostWithdrawCoin(this.extend(a,n)),d=this.safeValue(o,"response_data",{}),c=this.safeValue(d,"withdrawal");return this.parseTransaction(c,r)}parseTransaction(e,t=void 0){return t=this.safeCurrency(void 0,t),{id:this.safeString(e,"id"),txid:void 0,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0,info:e}}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="15m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={resolution:this.timeframes[t],symbol:r.base+"-"+r.quote};i===void 0&&(i=100),s!==void 0?(a.from=parseInt(s/1e3),a.to=this.sum(a.from,i*this.parseTimeframe(t))):(a.to=this.seconds(),a.from=a.to-i*this.parseTimeframe(t));const o=await this.v4PublicNetGetCandles(this.extend(a,n)),d=this.convertTradingViewToOHLCV(o,"t","o","h","l","c","v");return this.parseOHLCVs(d,r,t,s,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new aa(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={coin_pair:n.id},a=await this.privatePostListOrders(this.extend(r,i)),o=this.safeValue(a,"response_data",{}),d=this.safeValue(o,"orders",[]);return this.parseOrders(d,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new aa(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={coin_pair:n.id,status_list:"[2]"},a=await this.privatePostListOrders(this.extend(r,i)),o=this.safeValue(a,"response_data",{}),d=this.safeValue(o,"orders",[]);return this.parseOrders(d,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new aa(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={coin_pair:n.id,has_fills:!0},a=await this.privatePostListOrders(this.extend(r,i)),o=this.safeValue(a,"response_data",{}),d=this.safeValue(o,"orders",[]),c=this.parseOrders(d,n,t,s),u=this.ordersToTrades(c);return this.filterBySymbolSinceLimit(u,n.symbol,t,s)}ordersToTrades(e){const t=[];for(let s=0;s<e.length;s++){const i=this.safeValue(e[s],"trades",[]);for(let n=0;n<i.length;n++)t.push(i[n])}return t}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/";const o=this.omit(i,this.extractParams(e));if(t==="public"||t==="v4Public"||t==="v4PublicNet")a+=this.implodeParams(e,i),Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials(),a+=this.version+"/";const d=this.nonce();r=this.urlencode(this.extend({tapi_method:e,tapi_nonce:d},i));const c="/tapi/"+this.version+"/?"+r;n={"Content-Type":"application/x-www-form-urlencoded","TAPI-ID":this.apiKey,"TAPI-MAC":this.hmac(this.encode(c),this.encode(this.secret),"sha512")}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;if(this.safeValue(a,"error_message")!==void 0)throw new f9(this.id+" "+this.json(a))}};const m9=ge,{AccountNotEnabled:g9,InvalidAddress:Q0,ExchangeError:Z0,BadRequest:y9,AuthenticationError:ah,RateLimitExceeded:b9,BadSymbol:Ka,InvalidOrder:qi,InsufficientFunds:jv,ArgumentsRequired:rn,OrderNotFound:w9,PermissionDenied:J0,NotSupported:k9}=de,{TICK_SIZE:S9}=me,xn=Se;var tC=class extends m9{describe(){return this.deepExtend(super.describe(),{id:"mexc",name:"MEXC Global",countries:["SC"],rateLimit:50,version:"v2",certified:!0,pro:!0,has:{CORS:void 0,spot:!0,margin:void 0,swap:!0,future:!1,option:!1,addMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createMarketOrder:!1,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!1,createStopOrder:!0,fetchBalance:!0,fetchCanceledOrders:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchIndexOHLCV:!0,fetchLeverage:void 0,fetchLeverageTiers:!0,fetchMarginMode:!1,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionMode:!0,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!0,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransfer:!0,fetchTransfers:!0,fetchWithdrawals:!0,reduceMargin:!0,setLeverage:!0,setMarginMode:!1,setPositionMode:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","1d":"1d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/137283979-8b2a818d-8633-461b-bfca-de89e8c446b2.jpg",api:{spot:{public:"https://www.mexc.com/open/api/v2",private:"https://www.mexc.com/open/api/v2"},contract:{public:"https://contract.mexc.com/api/v1/contract",private:"https://contract.mexc.com/api/v1/private"}},www:"https://www.mexc.com/",doc:["https://mxcdevelop.github.io/APIDoc/"],fees:["https://www.mexc.com/fee"],referral:"https://m.mexc.com/auth/signup?inviteCode=1FQ1G"},api:{contract:{public:{get:{ping:2,detail:2,support_currencies:2,"depth/{symbol}":2,"depth_commits/{symbol}/{limit}":2,"index_price/{symbol}":2,"fair_price/{symbol}":2,"funding_rate/{symbol}":2,"kline/{symbol}":2,"kline/index_price/{symbol}":2,"kline/fair_price/{symbol}":2,"deals/{symbol}":2,ticker:2,risk_reverse:2,"risk_reverse/history":2,"funding_rate/history":2}},private:{get:{"account/assets":2,"account/asset/{currency}":2,"account/transfer_record":2,"position/list/history_positions":2,"position/open_positions":2,"position/funding_records":2,"position/position_mode":2,"order/list/open_orders/{symbol}":2,"order/list/history_orders":2,"order/external/{symbol}/{external_oid}":2,"order/get/{order_id}":2,"order/batch_query":8,"order/deal_details/{order_id}":2,"order/list/order_deals":2,"planorder/list/orders":2,"stoporder/list/orders":2,"stoporder/order_details/{stop_order_id}":2,"account/risk_limit":2,"account/tiered_fee_rate":2},post:{"position/change_margin":2,"position/change_leverage":2,"position/change_position_mode":2,"order/submit":2,"order/submit_batch":40,"order/cancel":2,"order/cancel_with_external":2,"order/cancel_all":2,"account/change_risk_level":2,"planorder/place":2,"planorder/cancel":2,"planorder/cancel_all":2,"stoporder/cancel":2,"stoporder/cancel_all":2,"stoporder/change_price":2,"stoporder/change_plan_price":2}}},spot:{public:{get:{"market/symbols":1,"market/coin/list":2,"common/timestamp":1,"common/ping":1,"market/ticker":1,"market/depth":1,"market/deals":1,"market/kline":1,"market/api_default_symbols":2}},private:{get:{"account/info":1,"order/open_orders":1,"order/list":1,"order/query":1,"order/deals":1,"order/deal_detail":1,"asset/deposit/address/list":2,"asset/deposit/list":2,"asset/address/list":2,"asset/withdraw/list":2,"asset/internal/transfer/record":10,"account/balance":10,"asset/internal/transfer/info":10,"market/api_symbols":2},post:{"order/place":1,"order/place_batch":1,"asset/withdraw":2,"asset/internal/transfer":10},delete:{"order/cancel":1,"order/cancel_by_symbol":1,"asset/withdraw":2}}}},precisionMode:S9,fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},options:{timeframes:{spot:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","1d":"1d","1M":"1M"},contract:{"1m":"Min1","5m":"Min5","15m":"Min15","30m":"Min30","1h":"Min60","4h":"Hour4","8h":"Hour8","1d":"Day1","1w":"Week1","1M":"Month1"}},defaultType:"spot",networks:{TRX:"TRC20",ETH:"ERC20",BEP20:"BEP20(BSC)",BSC:"BEP20(BSC)"},accountsByType:{spot:"MAIN",swap:"CONTRACT"},transfer:{accountsById:{MAIN:"spot",CONTRACT:"swap"},status:{SUCCESS:"ok",FAILED:"failed",WAIT:"pending"}},fetchOrdersByState:{method:"spotPrivateGetOrderList"},cancelOrder:{method:"spotPrivateDeleteOrderCancel"}},commonCurrencies:{BEYONDPROTOCOL:"BEYOND",BIFI:"BIFIF",BYN:"BeyondFi",COFI:"COFIX",DFI:"DfiStarter",DFT:"dFuture",DRK:"DRK",EGC:"Egoras Credit",FLUX1:"FLUX",FLUX:"FLUX1",FREE:"FreeRossDAO",GMT:"GMT Token",HERO:"Step Hero",MIMO:"Mimosa",PROS:"Pros.Finance",SIN:"Sin City Token",SOUL:"Soul Swap",STEPN:"GMT"},exceptions:{exact:{400:y9,401:ah,402:ah,403:J0,429:b9,703:J0,1e3:g9,1002:qi,10072:ah,10073:ah,10075:J0,10101:jv,10216:Q0,10232:Ka,3e4:Ka,30001:qi,30002:qi,30003:qi,30004:jv,30005:qi,30010:qi,30014:Ka,30016:Ka,30019:qi,30020:Ka,30021:Ka,33333:Ka},broad:{"price and quantity must be positive":qi}}})}async fetchTime(e={}){const[t,s]=this.handleMarketTypeAndParams("fetchTime",void 0,e),i=this.getSupportedMapping(t,{spot:"spotPublicGetCommonTimestamp",swap:"contractPublicGetPing"}),n=await this[i](this.extend(s));return this.safeInteger(n,"data")}async fetchStatus(e={}){const t=await this.spotPublicGetCommonPing(e);return{status:this.safeInteger(t,"code")===200?"ok":"maintenance",updated:void 0,eta:void 0,url:void 0,info:t}}async fetchCurrencies(e={}){const t=await this.spotPublicGetMarketCoinList(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.safeString(r,"full_name");let c=!1,u,h,l,p;const m={},g=this.safeValue(r,"coins",[]);let y=!1,b=!1;for(let T=0;T<g.length;T++){const O=g[T],x=this.safeString(O,"chain"),C=this.safeNetwork(x),E=this.safeValue(O,"is_deposit_enabled",!1),P=this.safeValue(O,"is_withdraw_enabled",!1),_=E&&P;c=_||c;const S=this.safeString(O,"withdraw_limit_min"),I=this.safeString(O,"withdraw_limit_max");l=l===void 0?S:l,p=p===void 0?I:p,xn.stringGt(l,S)&&(l=S),xn.stringLt(p,I)&&(p=I),E&&(y=!0),P&&(b=!0);const v=this.parsePrecision(this.safeString(O,"precision"));v!==void 0&&(u=u===void 0?v:xn.stringMin(v,u)),m[C]={info:O,id:x,network:C,active:_,deposit:E,withdraw:P,fee:this.safeNumber(O,"fee"),precision:this.parseNumber(u),limits:{withdraw:{min:S,max:I}}}}const k=Object.keys(m).length;if(k===1||"NONE"in m){const T=this.safeValue2(m,"NONE",k-1);T!==void 0&&(h=T.fee)}i[o]={id:a,code:o,info:r,name:d,active:c,deposit:y,withdraw:b,fee:h,precision:this.parseNumber(u),limits:{amount:{min:void 0,max:void 0},withdraw:{min:l,max:p}},networks:m}}return i}async fetchMarkets(e={}){const t=this.safeString2(this.options,"fetchMarkets","defaultType","spot"),s=this.safeString(e,"type",t),i=this.omit(e,"type"),n=s==="spot",r=s==="swap";if(!n&&!r)throw new Z0(this.id+" does not support '"+s+"' type, set exchange.options['defaultType'] to 'spot' or 'swap''");if(n)return await this.fetchSpotMarkets(i);if(r)return await this.fetchContractMarkets(i)}async fetchContractMarkets(e={}){const t=await this.contractPublicGetDetail(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeString(r,"baseCoin"),d=this.safeString(r,"quoteCoin"),c=this.safeString(r,"settleCoin"),u=this.safeCurrencyCode(o),h=this.safeCurrencyCode(d),l=this.safeCurrencyCode(c),p=this.safeString(r,"state");i.push({id:a,symbol:u+"/"+h+":"+l,base:u,quote:h,settle:l,baseId:o,quoteId:d,settleId:c,type:"swap",spot:!1,margin:!1,swap:!0,future:!1,option:!1,active:p==="0",contract:!0,linear:!0,inverse:!1,taker:this.safeNumber(r,"takerFeeRate"),maker:this.safeNumber(r,"makerFeeRate"),contractSize:this.safeNumber(r,"contractSize"),expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(r,"volUnit"),price:this.safeNumber(r,"priceUnit")},limits:{leverage:{min:this.safeNumber(r,"minLeverage"),max:this.safeNumber(r,"maxLeverage")},amount:{min:this.safeNumber(r,"minVol"),max:this.safeNumber(r,"maxVol")},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}async fetchSpotMarkets(e={}){const t=await this.spotPublicGetMarketSymbols(e),s=this.safeValue(t,"data",[]),i=await this.spotPublicGetMarketApiDefaultSymbols(e),n=this.safeValue(i,"data",{}),r=this.safeValue(n,"symbol",[]),a=[];for(let o=0;o<s.length;o++){const d=s[o],c=this.safeString(d,"symbol"),[u,h]=c.split("_"),l=this.safeCurrencyCode(u),p=this.safeCurrencyCode(h),m=this.safeString(d,"state");let g=!1;for(let y=0;y<r.length;y++)if(r[y]===c){m==="ENABLED"&&(g=!0);break}a.push({id:c,symbol:l+"/"+p,base:l,quote:p,settle:void 0,baseId:u,quoteId:h,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:g,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(d,"taker_fee_rate"),maker:this.safeNumber(d,"maker_fee_rate"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(d,"quantity_scale"))),price:this.parseNumber(this.parsePrecision(this.safeString(d,"price_scale")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(d,"min_amount"),max:this.safeNumber(d,"max_amount")}},info:d})}return a}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeString(e,0);let i;s!==void 0&&(i=this.market(s));const[n,r]=this.handleMarketTypeAndParams("fetchTickers",i,t),a=this.getSupportedMapping(n,{spot:"spotPublicGetMarketTicker",swap:"contractPublicGetTicker"}),o=await this[a](this.extend(r)),d=this.safeValue(o,"data",[]);return this.parseTickers(d,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let n;s.spot?n="spotPublicGetMarketTicker":s.swap&&(n="contractPublicGetTicker");const r=await this[n](this.extend(i,t));if(s.spot){const a=this.safeValue(r,"data",[]),o=this.safeValue(a,0);return this.parseTicker(o,s)}else if(s.swap){const a=this.safeValue(r,"data",{});return this.parseTicker(a,s)}}parseTicker(e,t=void 0){const s=this.safeInteger2(e,"time","timestamp"),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t,"_"),r=this.safeString2(e,"volume","volume24"),a=this.safeString(e,"amount24"),o=this.safeString(e,"open"),d=this.safeString2(e,"last","lastPrice"),c=this.safeString(e,"riseFallValue"),u=this.safeString(e,"riseFallRate"),h=xn.stringAdd(u,"1");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString2(e,"high","high24Price"),low:this.safeString2(e,"low","lower24Price"),bid:this.safeString2(e,"bid","bid1"),bidVolume:void 0,ask:this.safeString2(e,"ask","ask1"),askVolume:void 0,vwap:void 0,open:o,close:d,last:d,previousClose:void 0,change:c,percentage:h,average:void 0,baseVolume:r,quoteVolume:a,info:e},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};let r;i.spot?(r="spotPublicGetMarketDepth",t===void 0&&(t=100),n.depth=t):i.swap&&(r="contractPublicGetDepthSymbol",t!==void 0&&(n.limit=t));const a=await this[r](this.extend(n,s)),o=this.safeValue(a,"data",{}),d=i.spot?"price":0,c=i.spot?"quantity":1,u=this.safeInteger(o,"timestamp"),h=this.parseOrderBook(o,e,u,"bids","asks",d,c);return h.nonce=this.safeInteger(o,"version"),h}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s);let a;n.spot?a="spotPublicGetMarketDeals":n.swap&&(a="contractPublicGetDealsSymbol");const o=await this[a](this.extend(r,i)),d=this.safeValue(o,"data",[]);return this.parseTrades(d,n,t,s)}parseTrade(e,t=void 0){let s=this.safeInteger2(e,"create_time","trade_time");s=this.safeInteger(e,"t",s);const i=this.safeString(e,"symbol");t=this.safeMarket(i,t,"_");const n=t.symbol;let r=this.safeString2(e,"price","trade_price");r=this.safeString(e,"p",r);let a=this.safeString2(e,"quantity","trade_quantity");a=this.safeString(e,"v",a);const o=this.safeString(e,"amount");let d=this.safeString2(e,"trade_type","T");d==="BID"||d==="1"?d="buy":(d==="ASK"||d==="2")&&(d="sell");let c=this.safeString2(e,"id","trade_time");c===void 0&&(c=this.safeString(e,"t",c),c!==void 0&&(c+="-"+t.id+"-"+a));const u=this.safeString(e,"fee");let h;if(u!==void 0){const g=this.safeString(e,"fee_currency"),y=this.safeCurrencyCode(g);h={cost:u,currency:y}}const l=this.safeString(e,"order_id"),m=this.safeValue(e,"is_taker",!0)?"taker":"maker";return this.safeTrade({info:e,id:c,order:l,timestamp:s,datetime:this.iso8601(s),symbol:n,type:void 0,side:d,takerOrMaker:m,price:r,amount:a,cost:o,fee:h},t)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.spotPublicGetMarketSymbols(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),d=this.safeMarket(a,void 0,"_").symbol;i[d]={info:r,symbol:d,maker:this.safeNumber(r,"maker_fee_rate"),taker:this.safeNumber(r,"taker_fee_rate"),percentage:!0,tierBased:!1}}return i}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.safeValue(this.options,"timeframes",{}),o=this.safeValue(a,r.type,{}),d=this.safeString(o,t);if(d===void 0)throw new k9(this.id+" fetchOHLCV() does not support "+t+" timeframe for "+r.type+" markets");const c={symbol:r.id,interval:d};let u;r.spot?(u="spotPublicGetMarketKline",s!==void 0&&(c.start_time=parseInt(s/1e3)),i!==void 0&&(c.limit=i)):r.swap&&(u="contractPublicGetKlineSymbol",s!==void 0&&(c.start=parseInt(s/1e3)));const h=await this[u](this.extend(c,n));if(r.spot){const l=this.safeValue(h,"data",[]);return this.parseOHLCVs(l,r,t,s,i)}else if(r.swap){const l=this.safeValue(h,"data",{}),p=this.convertTradingViewToOHLCV(l,"time","open","high","low","close","vol");return this.parseOHLCVs(p,r,t,s,i)}}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,t.spot?3:2),this.safeNumber(e,t.spot?4:3),this.safeNumber(e,t.spot?2:4),this.safeNumber(e,5)]}async fetchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),i=this.getSupportedMapping(t,{spot:"spotPrivateGetAccountInfo",margin:"spotPrivateGetAccountInfo",swap:"contractPrivateGetAccountAssets"}),n=t==="spot",r=await this[i](s),a=this.safeValue(r,"data",{}),o=this.milliseconds(),d={info:r,timestamp:o,datetime:this.iso8601(o)};if(n){const c=Object.keys(a);for(let u=0;u<c.length;u++){const h=c[u],l=this.safeCurrencyCode(h),p=this.safeValue(a,h,{}),m=this.account();m.free=this.safeString(p,"available"),m.used=this.safeString(p,"frozen"),d[l]=m}}else for(let c=0;c<a.length;c++){const u=a[c],h=this.safeString(u,"currency"),l=this.safeCurrencyCode(h),p=this.account();p.free=this.safeString(u,"availableBalance"),p.used=this.safeString(u,"frozenBalance"),d[l]=p}return this.safeBalance(d)}safeNetwork(e){if(e.indexOf("BSC")>=0)return"BEP20";e=e.split(" ").join(""),e=e.replace("-20","20");const s={ETH:"ETH",ERC20:"ERC20","BEP20(BSC)":"BEP20",TRX:"TRC20"};return this.safeString(s,e,e)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeCurrencyCode(void 0,t),n=this.safeString(e,"chain"),r=this.safeNetwork(n);return this.checkAddress(s),{currency:i,address:s,tag:void 0,network:r,info:e}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=await this.spotPrivateGetAssetDepositAddressList(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"chains",[]),o=[];for(let d=0;d<a.length;d++){const c=this.parseDepositAddress(a[d],s);o.push(c)}return this.indexBy(o,"network")}async fetchDepositAddress(e,t={}){const s=this.safeStringUpper(t,"network");t=this.omit(t,"network");const i=await this.fetchDepositAddressesByNetwork(e,t),n=this.safeValue(this.options,"networks",{}),r=this.safeString(n,s,s);let a;if(r===void 0){if(a=this.safeValue(i,e),a===void 0){const o=this.safeString(n,e,e);if(a=this.safeValue(i,o),a===void 0){const d=this.safeString(this.options,"defaultNetwork","ERC20");if(a=this.safeValue(i,d),a===void 0){const c=Object.values(i);if(a=this.safeValue(c,0),a===void 0)throw new Q0(this.id+" fetchDepositAddress() cannot find deposit address for "+e)}}}return a}if(a=this.safeValue(i,s),a===void 0)throw new Q0(this.id+" fetchDepositAddress() cannot find "+r+" deposit address for "+e);return a}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),t!==void 0&&(n.start_time=t),s!==void 0&&(n.limit=s);const a=await this.spotPrivateGetAssetDepositList(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"result_list",[]);return this.parseTransactions(d,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),t!==void 0&&(n.start_time=t),s!==void 0&&(n.limit=s);const a=await this.spotPrivateGetAssetWithdrawList(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"result_list",[]);return this.parseTransactions(d,r,t,s)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=s===void 0?"deposit":"withdrawal",n=this.parse8601(this.safeString(e,"create_time")),r=this.parse8601(this.safeString(e,"update_time"));let a=this.safeString(e,"currency"),o;if(a!==void 0&&a.indexOf("-")>=0){const g=a.split("-");a=this.safeString(g,0);const y=this.safeString(g,1);o=this.safeNetwork(y)}const d=this.safeCurrencyCode(a,t),c=this.parseTransactionStatus(this.safeString(e,"state"));let u=this.safeString(e,"amount");const h=this.safeString(e,"address"),l=this.safeString(e,"tx_id");let p;const m=this.safeString(e,"fee");return m!==void 0&&(p={cost:this.parseNumber(m),currency:d}),i==="withdrawal"&&(u=xn.stringSub(u,m)),{info:e,id:s,txid:l,timestamp:n,datetime:this.iso8601(n),network:o,address:h,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:i,amount:this.parseNumber(u),currency:d,status:c,updated:r,fee:p}}parseTransactionStatus(e){const t={WAIT:"pending",WAIT_PACKAGING:"pending",SUCCESS:"ok"};return this.safeString(t,e,e)}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.fetchPositions(this.extend(i,t)),r=this.safeValue(n,0);return this.parsePosition(r,s)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.contractPrivateGetPositionOpenPositions(t),i=this.safeValue(s,"data",[]);return this.parsePositions(i,e)}parsePosition(e,t=void 0){t=this.safeMarket(this.safeString(e,"symbol"),t);const s=t.symbol,i=this.safeString(e,"holdVol"),n=this.safeNumber(e,"openAvgPrice"),r=this.safeString(e,"im"),o=this.safeString(e,"positionType")==="1"?"long":"short",c=this.safeString(e,"margin_mode")==="1"?"isolated":"cross",u=this.safeString(e,"leverage"),h=this.safeNumber(e,"liquidatePrice"),l=this.safeNumber(e,"updateTime");return{info:e,symbol:s,contracts:this.parseNumber(i),contractSize:void 0,entryPrice:n,collateral:void 0,side:o,unrealizedProfit:void 0,leverage:this.parseNumber(u),percentage:void 0,marginMode:c,notional:void 0,markPrice:void 0,liquidationPrice:h,initialMargin:this.parseNumber(r),initialMarginPercentage:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,marginRatio:void 0,timestamp:l,datetime:this.iso8601(l)}}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),[o,d]=this.handleMarketTypeAndParams("createOrder",a,r);if(o==="spot")return await this.createSpotOrder(e,t,s,i,n,d);if(o==="swap")return await this.createSwapOrder(e,t,s,i,n,d)}async createSpotOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o;s==="buy"?o="BID":s==="sell"&&(o="ASK");let d=t.toUpperCase();const c=d==="MARKET";if(c)throw new qi(this.id+" createOrder () does not support market orders, only limit orders are allowed");d==="LIMIT"&&(d="LIMIT_ORDER");const u=this.isPostOnly(c,d==="POST_ONLY",r),h=this.safeStringUpper(r,"timeInForce");if(u?d="POST_ONLY":h==="IOC"&&(d="IMMEDIATE_OR_CANCEL"),h==="FOK")throw new qi(this.id+" createOrder () does not support timeInForce FOK, only IOC, PO, and GTC are allowed");if(d!=="POST_ONLY"&&d!=="IMMEDIATE_OR_CANCEL"&&d!=="LIMIT_ORDER")throw new qi(this.id+" createOrder () does not support "+t+" order type, only LIMIT, LIMIT_ORDER, POST_ONLY or IMMEDIATE_OR_CANCEL are allowed");const p={symbol:a.id,price:this.priceToPrecision(e,n),quantity:this.amountToPrecision(e,i),trade_type:o,order_type:d},m=this.safeString2(r,"clientOrderId","client_order_id");m!==void 0&&(p.client_order_id=m),r=this.omit(r,["type","clientOrderId","client_order_id","postOnly","timeInForce"]);const g=await this.spotPrivatePostOrderPlace(this.extend(p,r));return this.parseOrder(g,a)}async createSwapOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeInteger(r,"openType");if(o===void 0)throw new rn(this.id+" createSwapOrder () requires an integer openType parameter, 1 for isolated margin, 2 for cross margin");if(t!=="limit"&&t!=="market"&&t!==1&&t!==2&&t!==3&&t!==4&&t!==5&&t!==6)throw new qi(this.id+" createSwapOrder () order type must either limit, market, or 1 for limit orders, 2 for post-only orders, 3 for IOC orders, 4 for FOK orders, 5 for market orders or 6 to convert market price to current price");const d=t==="market"||t===5;this.isPostOnly(d,t===2,r)?t=2:t==="limit"?t=1:t==="market"&&(t=5);const u=this.safeStringUpper(r,"timeInForce");if(u==="IOC"?t=3:u==="FOK"&&(t=4),s!==1&&s!==2&&s!==3&&s!==4)throw new qi(this.id+" createSwapOrder () order side must be 1 open long, 2 close short, 3 open short or 4 close long");const p={symbol:a.id,vol:parseFloat(this.amountToPrecision(e,i)),side:s,type:t,openType:o};let m="contractPrivatePostOrderSubmit";const g=this.safeNumber2(r,"triggerPrice","stopPrice");if(r=this.omit(r,["stopPrice","triggerPrice","timeInForce","postOnly"]),g!==void 0&&(m="contractPrivatePostPlanorderPlace",p.triggerPrice=this.priceToPrecision(e,g),p.triggerType=this.safeInteger(r,"triggerType",1),p.executeCycle=this.safeInteger(r,"executeCycle",1),p.trend=this.safeInteger(r,"trend",1),p.orderType=this.safeInteger(r,"orderType",t)),t!==5&&t!==6&&t!=="market"&&(p.price=parseFloat(this.priceToPrecision(e,n))),o===1&&this.safeInteger(r,"leverage")===void 0)throw new rn(this.id+" createSwapOrder () requires a leverage parameter for isolated margin orders");const y=this.safeString2(r,"clientOrderId","externalOid");y!==void 0&&(p.externalOid=y),r=this.omit(r,["clientOrderId","externalOid"]);const b=await this[m](this.extend(p,r));return this.parseOrder(b,a)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new rn(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=this.safeValue(this.options,"cancelOrder",{}),r=this.safeString(n,"method","spotPrivateDeleteOrderCancel");let a=this.safeString(s,"method",r);const o=this.safeValue(s,"stop");let d={};if(i.type==="spot"){a="spotPrivateDeleteOrderCancel";const h=this.safeString2(s,"clientOrderId","client_order_ids");h!==void 0?(s=this.omit(s,["clientOrderId","client_order_ids"]),d.client_order_ids=h):d.order_ids=e}else if(o)if(a="contractPrivatePostPlanorderCancel",d=[],Array.isArray(e))for(let h=0;h<e.length;h++)d.push({symbol:i.id,orderId:e[h]});else typeof e=="string"&&d.push({symbol:i.id,orderId:e});else i.type==="swap"&&(a="contractPrivatePostOrderCancel",d=[e]);const c=await this[a](d);let u=this.safeValue(c,"data",[]);return o&&(u=c),this.parseOrder(u,i)}parseOrderStatus(e,t=void 0){let s={};return t.type==="spot"?s={NEW:"open",FILLED:"closed",PARTIALLY_FILLED:"open",CANCELED:"canceled",PARTIALLY_CANCELED:"canceled"}:t.type==="swap"?s={2:"open",3:"closed",4:"canceled"}:s={1:"open",2:"canceled",3:"closed"},this.safeString(s,e,e)}parseOrder(e,t=void 0){let s=this.safeString2(e,"data","id"),i;if(s===void 0){const O=Object.keys(e);s=this.safeString(O,0),this.safeString(e,s)==="success"&&(i="canceled")}const n=this.safeString(e,"state"),r=this.safeInteger2(e,"create_time","createTime"),a=this.safeString(e,"price"),o=this.safeString2(e,"quantity","vol"),d=this.safeString(e,"remain_quantity"),c=this.safeString2(e,"deal_quantity","dealVol"),u=this.safeString(e,"deal_amount"),h=this.safeString(e,"symbol"),l=this.safeSymbol(h,t,"_"),p=this.safeInteger(e,"side");let m;const g=this.safeString(e,"type");g==="BID"?m="buy":g==="ASK"&&(m="sell"),p===1?m="open long":m===2?m="close short":m===3?m="open short":m===4&&(m="close long"),i=this.parseOrderStatus(n,t);const y=this.safeString2(e,"client_order_id","orderId"),b=this.safeString2(e,"orderType","order_type");let w,k,T;return b!==void 0&&(T=!1,b==="1"?(w="limit",k="GTC"):b==="2"?(w="limit",k="PO",T=!0):b==="3"?(w="limit",k="IOC"):b==="4"?(w="limit",k="FOK"):b==="5"||b==="6"?(w="market",k="GTC"):b==="LIMIT_ORDER"?(w="limit",k="GTC"):b==="POST_ONLY"?(w="limit",k="PO",T=!0):b==="IMMEDIATE_OR_CANCEL"&&(w="limit",k="IOC")),this.safeOrder({id:s,clientOrderId:y,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:this.safeInteger(e,"updateTime"),status:i,symbol:l,type:w,timeInForce:k,postOnly:T,side:m,price:a,stopPrice:this.safeString(e,"triggerPrice"),average:this.safeString(e,"dealAvgPrice"),amount:o,cost:u,filled:c,remaining:d,fee:void 0,trades:void 0,info:e},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new rn(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id},[a,o]=this.handleMarketTypeAndParams("fetchOpenOrders",n,i),d=this.getSupportedMapping(a,{spot:"spotPrivateGetOrderOpenOrders",swap:"contractPrivateGetOrderListOpenOrdersSymbol"});if(this.safeValue(i,"stop"))return await this.fetchOrdersByState("1",e,t,s,i);const u=await this[d](this.extend(r,o)),h=this.safeValue(u,"data",[]);return this.parseOrders(h,n,t,s)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new rn(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),[n,r]=this.handleMarketTypeAndParams("fetchOrder",i,s),a={order_ids:e},o=this.getSupportedMapping(n,{spot:"spotPrivateGetOrderQuery",swap:"contractPrivateGetOrderBatchQuery"}),d=await this[o](this.extend(a,r)),c=this.safeValue(d,"data",[]),u=this.safeValue(c,0);if(u===void 0)throw new w9(this.id+" fetchOrder() could not find the order id "+e);return this.parseOrder(u,i)}async fetchOrdersByState(e,t=void 0,s=void 0,i=void 0,n={}){if(t===void 0)throw new rn(this.id+" fetchOrdersByState() requires a symbol argument");await this.loadMarkets();const r=this.market(t),a={symbol:r.id,states:e},o=this.safeValue(n,"stop"),d=o?"page_size":"limit";i!==void 0&&(a[d]=i),s!==void 0&&(a.start_time=s);const c=this.safeValue(this.options,"fetchOrdersByState",{}),u=this.safeString(c,"method","spotPrivateGetOrderList");let h=this.safeString(n,"method",u);h=this.getSupportedMapping(r.type,{spot:"spotPrivateGetOrderList",swap:"contractPrivateGetOrderListHistoryOrders"}),o&&(h="contractPrivateGetPlanorderListOrders");const l=this.omit(n,["method","stop"]),p=await this[h](this.extend(a,l)),m=this.safeValue(p,"data",[]);return this.parseOrders(m,r,s,i)}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new rn(this.id+" fetchCanceledOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=this.safeValue(i,"stop");let a="CANCELED";return n.type==="swap"?a="4":r&&(a="2"),await this.fetchOrdersByState(a,e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new rn(this.id+" fetchClosedOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=this.safeValue(i,"stop");let a="FILLED";return(r||n.type==="swap")&&(a="3"),await this.fetchOrdersByState(a,e,t,s,i)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let n=this.getSupportedMapping(s.type,{spot:"spotPrivateDeleteOrderCancelBySymbol",swap:"contractPrivatePostOrderCancelAll"});this.safeValue(t,"stop")&&(n="contractPrivatePostPlanorderCancelAll");const a=this.omit(t,["method","stop"]);return await this[n](this.extend(i,a))}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new rn(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};t!==void 0&&(r.start_time=t),s!==void 0&&(r.limit=s);const a=await this.spotPrivateGetOrderDeals(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;t!==void 0&&(r=this.market(t));const a={order_id:e},o=await this.spotPrivateGetOrderDealDetail(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseTrades(d,r,s,i)}async modifyMarginHelper(e,t,s,i={}){const n=this.safeInteger(i,"positionId");if(n===void 0)throw new rn(this.id+" modifyMarginHelper() requires a positionId parameter");await this.loadMarkets();const r=this.market(e);t=this.amountToPrecision(e,t);const a={positionId:n,amount:t,type:s},o=await this.contractPrivatePostPositionChangeMargin(this.extend(a,i)),d=s==="ADD"?"add":"reduce";return this.extend(this.parseMarginModification(o,r),{amount:this.parseNumber(t),type:d})}parseMarginModification(e,t=void 0){const i=this.safeValue(e,"success")===!0?"ok":"failed";return{info:e,type:void 0,amount:void 0,code:void 0,symbol:this.safeSymbol(void 0,t),status:i}}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"SUB",s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"ADD",s)}async setLeverage(e,t=void 0,s={}){await this.loadMarkets();const i={leverage:e},n=this.safeInteger(s,"positionId");if(n===void 0){const r=this.safeNumber(s,"openType"),a=this.safeNumber(s,"positionType"),o=t!==void 0?this.market(t):void 0;if(r===void 0||a===void 0||o===void 0)throw new rn(this.id+" setLeverage() requires a positionId parameter or a symbol argument with openType and positionType parameters, use openType 1 or 2 for isolated or cross margin respectively, use positionType 1 or 2 for long or short positions");i.openType=r,i.symbol=o.id,i.positionType=a}else i.positionId=n;return await this.contractPrivatePostPositionChangeLeverage(this.extend(i,s))}async fetchTransfer(e,t=void 0,s={}){const i={transact_id:e},n=await this.spotPrivateGetAssetInternalTransferInfo(this.extend(i,s)),r=this.safeValue(n,"data",{});return this.parseTransfer(r)}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;if(e!==void 0&&(r=this.currency(e),n.currency=r.id),t!==void 0&&(n.start_time=t),s!==void 0){if(s>50)throw new Z0("This exchange supports a maximum limit of 50");n["page-size"]=s}const a=await this.spotPrivateGetAssetInternalTransferRecord(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"result_list",[]);return this.parseTransfers(d,r,t,s)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c={currency:r.id,amount:t,from:o,to:d},u=await this.spotPrivatePostAssetInternalTransfer(this.extend(c,n)),h=this.safeValue(u,"data",{});return this.parseTransfer(h,r)}parseTransfer(e,t=void 0){const s=this.safeValue(this.options,"transfer",{}),i=this.safeValue(s,"status",{}),n=this.safeString(e,"currency"),r=this.safeString(e,"transact_id"),a=this.safeString(e,"from"),o=this.safeString(e,"to"),d=this.safeValue(s,"accountsById",{}),c=this.safeString(d,a),u=this.safeString(d,o),h=this.safeString(e,"transact_state");return{info:e,id:r,timestamp:void 0,datetime:void 0,currency:this.safeCurrencyCode(n,t),amount:this.safeNumber(e,"amount"),fromAccount:c,toAccount:u,status:this.safeString(i,h)}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n);const r=this.safeValue(this.options,"networks",{});let a=this.safeStringUpper2(n,"network","chain");a=this.safeString(r,a,a),this.checkAddress(s),await this.loadMarkets();const o=this.currency(e);i!==void 0&&(s+=":"+i);const d={currency:o.id,address:s,amount:t};a!==void 0&&(d.chain=a,n=this.omit(n,["network","chain"]));const c=await this.spotPrivatePostAssetWithdraw(this.extend(d,n)),u=this.safeValue(c,"data",{});return{info:u,id:this.safeString(u,"withdrawId")}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const[a,o]=t;let d=this.urls.api[a][o]+"/"+this.implodeParams(e,i);if(i=this.omit(i,this.extractParams(e)),o==="public")Object.keys(i).length&&(d+="?"+this.urlencode(i));else{this.checkRequiredCredentials();const c=this.milliseconds().toString();let u="";n={ApiKey:this.apiKey,"Request-Time":c,"Content-Type":"application/json"},s==="POST"?(u=this.json(i),r=u):(i=this.keysort(i),Object.keys(i).length&&(u+=this.urlencode(i),d+="?"+u)),u=this.apiKey+c+u;const h=this.hmac(this.encode(u),this.encode(this.secret),"sha256");n.Signature=h}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0||this.safeValue(a,"success",!1)===!0)return;const u=this.safeString(a,"code");if(u!=="200"&&u!=="0"){const h=this.id+" "+r;throw this.throwBroadlyMatchedException(this.exceptions.broad,r,h),this.throwExactlyMatchedException(this.exceptions.exact,u,h),new Z0(h)}}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),s!==void 0&&(r.page_size=s);const a=await this.contractPrivateGetPositionFundingRecords(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"resultList",[]),c=[];for(let u=0;u<d.length;u++){const h=d[u],l=this.safeInteger(h,"settleTime");c.push({info:h,symbol:e,code:void 0,timestamp:l,datetime:this.iso8601(l),id:this.safeNumber(h,"id"),amount:this.safeNumber(h,"funding")})}return c}parseFundingRate(e,t=void 0){const s=this.safeNumber(e,"fundingRate"),i=this.safeInteger(e,"nextSettleTime"),n=this.safeString(e,"symbol"),r=this.safeSymbol(n,t),a=this.safeInteger(e,"timestamp"),o=this.iso8601(a);return{info:e,symbol:r,markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:a,datetime:o,fundingRate:s,fundingTimestamp:i,fundingDatetime:this.iso8601(i),nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.contractPublicGetFundingRateSymbol(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseFundingRate(r,s)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new rn(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.page_size=s);const a=await this.contractPublicGetFundingRateHistory(this.extend(r,i)),o=this.safeValue(a,"data"),d=this.safeValue(o,"resultList",[]),c=[];for(let h=0;h<d.length;h++){const l=d[h],p=this.safeString(l,"symbol"),m=this.safeSymbol(p),g=this.safeInteger(l,"settleTime");c.push({info:l,symbol:m,fundingRate:this.safeNumber(l,"fundingRate"),timestamp:g,datetime:this.iso8601(g)})}const u=this.sortBy(c,"timestamp");return this.filterBySymbolSinceLimit(u,n.symbol,t,s)}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const s=await this.contractPublicGetDetail(t),i=this.safeValue(s,"data");return this.parseLeverageTiers(i,e,"symbol")}parseMarketLeverageTiers(e,t){let s=this.safeString(e,"maintenanceMarginRate"),i=this.safeString(e,"initialMarginRate");const n=this.safeString(e,"maxVol"),r=this.safeString(e,"riskIncrVol"),a=this.safeString(e,"riskIncrMmr"),o=this.safeString(e,"riskIncrImr");let d="0";const c=[],u=this.safeString(e,"quoteCoin");for(;xn.stringLt(d,n);){const h=xn.stringAdd(d,r);c.push({tier:this.parseNumber(xn.stringDiv(h,r)),currency:this.safeCurrencyCode(u),minNotional:this.parseNumber(d),maxNotional:this.parseNumber(h),maintenanceMarginRate:this.parseNumber(s),maxLeverage:this.parseNumber(xn.stringDiv("1",i)),info:e}),i=xn.stringAdd(i,o),s=xn.stringAdd(s,a),d=h}return c}async setPositionMode(e,t=void 0,s={}){const i={positionMode:e?1:2};return await this.contractPrivatePostPositionChangePositionMode(this.extend(i,s))}async fetchPositionMode(e=void 0,t={}){const s=await this.contractPrivateGetPositionPositionMode(t),i=this.safeInteger(s,"data");return{info:s,hedged:i===1}}};const v9=ge,{BadRequest:hs,InvalidNonce:T9,BadSymbol:Wv,InvalidOrder:_n,InvalidAddress:O9,ExchangeError:Xa,ArgumentsRequired:Ps,NotSupported:zv,InsufficientFunds:Ya,PermissionDenied:I9}=de,{TICK_SIZE:x9}=me,fi=Se;var _9=class extends v9{describe(){return this.deepExtend(super.describe(),{id:"mexc3",name:"MEXC Global",countries:["SC"],rateLimit:50,version:"v3",has:{CORS:void 0,spot:void 0,margin:!0,swap:void 0,future:void 0,option:void 0,addMargin:!0,borrowMargin:!0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:void 0,createDepositAddress:void 0,createLimitOrder:void 0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!0,deposit:void 0,editOrder:void 0,fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowRate:void 0,fetchBorrowRateHistory:void 0,fetchBorrowRates:void 0,fetchBorrowRatesPerSymbol:void 0,fetchCanceledOrders:!0,fetchClosedOrder:void 0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:void 0,fetchDepositAddress:!0,fetchDepositAddresses:void 0,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:void 0,fetchIndexOHLCV:!0,fetchL2OrderBook:!0,fetchLedger:void 0,fetchLedgerEntry:void 0,fetchLeverageTiers:!0,fetchMarginMode:!1,fetchMarketLeverageTiers:void 0,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrder:void 0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:void 0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionMode:!0,fetchPositions:!0,fetchPositionsRisk:void 0,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:void 0,fetchTradingFees:!0,fetchTradingLimits:void 0,fetchTransactionFee:"emulated",fetchTransactionFees:!0,fetchTransactions:void 0,fetchTransfer:!0,fetchTransfers:!0,fetchWithdrawal:void 0,fetchWithdrawals:!0,privateAPI:!0,publicAPI:!0,reduceMargin:!0,repayMargin:!0,setLeverage:!0,setMarginMode:void 0,setPositionMode:!0,signIn:void 0,transfer:void 0,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/137283979-8b2a818d-8633-461b-bfca-de89e8c446b2.jpg",api:{spot:{public:"https://api.mexc.com",private:"https://api.mexc.com"},spot2:{public:"https://www.mexc.com/open/api/v2",private:"https://www.mexc.com/open/api/v2"},contract:{public:"https://contract.mexc.com/api/v1/contract",private:"https://contract.mexc.com/api/v1/private"}},www:"https://www.mexc.com/",doc:["https://mxcdevelop.github.io/apidocs/spot_v3_en/","https://mxcdevelop.github.io/APIDoc/"],fees:["https://www.mexc.com/fee"],referral:"https://m.mexc.com/auth/signup?inviteCode=1FQ1G"},api:{spot:{public:{get:{ping:1,time:1,exchangeInfo:1,depth:1,trades:1,historicalTrades:1,aggTrades:1,klines:1,avgPrice:1,"ticker/24hr":1,"ticker/price":1,"ticker/bookTicker":1,"etf/info":1}},private:{get:{order:1,openOrders:1,allOrders:1,account:1,myTrades:1,"sub-account/list":1,"sub-account/apiKey":1,"capital/config/getall":1,"capital/deposit/hisrec":1,"capital/withdraw/history":1,"capital/deposit/address":1,"capital/transfer":1,"capital/sub-account/universalTransfer":1,"margin/loan":1,"margin/allOrders":1,"margin/myTrades":1,"margin/openOrders":1,"margin/maxTransferable":1,"margin/priceIndex":1,"margin/order":1,"margin/isolated/account":1,"margin/maxBorrowable":1,"margin/repay":1,"margin/isolated/pair":1,"margin/forceLiquidationRec":1,"margin/isolatedMarginData":1,"margin/isolatedMarginTier":1,"rebate/taxQuery":1,"rebate/detail":1,"rebate/detail/kickback":1},post:{order:1,"order/test":1,"sub-account/virtualSubAccount":1,"sub-account/apiKey":1,"sub-account/futures":1,"sub-account/margin":1,batchOrders:1,"capital/withdraw/apply":1,"capital/transfer":1,"capital/deposit/address":1,"capital/sub-account/universalTransfer":1,"margin/tradeMode":1,"margin/order":1,"margin/loan":1,"margin/repay":1},delete:{order:1,openOrders:1,"sub-account/apiKey":1,"margin/order":1,"margin/openOrders":1}}},contract:{public:{get:{ping:2,detail:2,support_currencies:2,"depth/{symbol}":2,"depth_commits/{symbol}/{limit}":2,"index_price/{symbol}":2,"fair_price/{symbol}":2,"funding_rate/{symbol}":2,"kline/{symbol}":2,"kline/index_price/{symbol}":2,"kline/fair_price/{symbol}":2,"deals/{symbol}":2,ticker:2,risk_reverse:2,"risk_reverse/history":2,"funding_rate/history":2}},private:{get:{"account/assets":2,"account/asset/{currency}":2,"account/transfer_record":2,"position/list/history_positions":2,"position/open_positions":2,"position/funding_records":2,"position/position_mode":2,"order/list/open_orders/{symbol}":2,"order/list/history_orders":2,"order/external/{symbol}/{external_oid}":2,"order/get/{order_id}":2,"order/batch_query":8,"order/deal_details/{order_id}":2,"order/list/order_deals":2,"planorder/list/orders":2,"stoporder/list/orders":2,"stoporder/order_details/{stop_order_id}":2,"account/risk_limit":2,"account/tiered_fee_rate":2,"position/leverage":2},post:{"position/change_margin":2,"position/change_leverage":2,"position/change_position_mode":2,"order/submit":2,"order/submit_batch":40,"order/cancel":2,"order/cancel_with_external":2,"order/cancel_all":2,"account/change_risk_level":2,"planorder/place":2,"planorder/cancel":2,"planorder/cancel_all":2,"stoporder/cancel":2,"stoporder/cancel_all":2,"stoporder/change_price":2,"stoporder/change_plan_price":2}}},spot2:{public:{get:{"market/symbols":1,"market/coin/list":2,"common/timestamp":1,"common/ping":1,"market/ticker":1,"market/depth":1,"market/deals":1,"market/kline":1,"market/api_default_symbols":2}},private:{get:{"account/info":1,"order/open_orders":1,"order/list":1,"order/query":1,"order/deals":1,"order/deal_detail":1,"asset/deposit/address/list":2,"asset/deposit/list":2,"asset/address/list":2,"asset/withdraw/list":2,"asset/internal/transfer/record":10,"account/balance":10,"asset/internal/transfer/info":10,"market/api_symbols":2},post:{"order/place":1,"order/place_batch":1,"order/advanced/place_batch":1,"asset/withdraw":2,"asset/internal/transfer":10},delete:{"order/cancel":1,"order/cancel_by_symbol":1,"asset/withdraw":2}}}},precisionMode:x9,timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},options:{createMarketBuyOrderRequiresPrice:!0,unavailableContracts:{"BTC/USDT:USDT":!0,"LTC/USDT:USDT":!0,"ETH/USDT:USDT":!0},fetchMarkets:{types:{spot:!0,future:{linear:!1,inverse:!1},swap:{linear:!0,inverse:!1}}},timeframes:{spot:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},swap:{"1m":"Min1","5m":"Min5","15m":"Min15","30m":"Min30","1h":"Min60","4h":"Hour4","8h":"Hour8","1d":"Day1","1w":"Week1","1M":"Month1"}},defaultType:"spot",networks:{TRX:"TRC20",ETH:"ERC20",BEP20:"BEP20(BSC)",BSC:"BEP20(BSC)"},networkAliases:{"BSC(BEP20)":"BSC"},recvWindow:5*1e3,maxTimeTillEnd:90*86400*1e3-1},commonCurrencies:{BEYONDPROTOCOL:"BEYOND",BIFI:"BIFIF",BYN:"BeyondFi",COFI:"COFIX",DFI:"DfiStarter",DFT:"dFuture",DRK:"DRK",EGC:"Egoras Credit",FLUX1:"FLUX",FLUX:"FLUX1",FREE:"FreeRossDAO",GMT:"GMT Token",STEPN:"GMT",HERO:"Step Hero",MIMO:"Mimosa",PROS:"Pros.Finance",SIN:"Sin City Token",SOUL:"Soul Swap"},exceptions:{exact:{"-1128":hs,"-2011":hs,"-1121":Wv,10101:Ya,2009:_n,2011:hs,30004:Ya,33333:hs,44444:hs,1002:_n,30019:hs,30005:_n,2003:_n,2005:Ya,600:hs,70011:I9,88004:Ya,88009:Xa,88013:_n,88015:Ya,700003:T9},broad:{"Order quantity error, please try to modify.":hs,"Combination of optional parameters invalid":hs,"api market order is disabled":hs,"Contract not allow place order!":_n,Oversold:_n,"Insufficient position":Ya,"Insufficient balance!":Ya,"Bid price is great than max allow price":_n,"Invalid symbol.":Wv,"Param error!":hs}}})}async fetchStatus(e={}){const[t,s]=this.handleMarketTypeAndParams("fetchStatus",void 0,e);let i,n,r;return t==="spot"?(i=await this.spotPublicGetPing(s),n=Object.keys(i).length?this.json(i):"ok"):t==="swap"&&(i=await this.contractPublicGetPing(s),n=this.safeValue(i,"success")?"ok":this.json(i),r=this.safeInteger(i,"data")),{status:n,updated:r,url:void 0,eta:void 0,info:i}}async fetchTime(e={}){const[t,s]=this.handleMarketTypeAndParams("fetchTime",void 0,e);let i;if(t==="spot")return i=await this.spotPublicGetTime(s),this.safeInteger(i,"serverTime");if(t==="swap")return i=await this.contractPublicGetPing(s),this.safeInteger(i,"data")}async fetchCurrencies(e={}){if(!this.checkRequiredCredentials(!1))return;const t=await this.spotPrivateGetCapitalConfigGetall(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"coin"),a=this.safeCurrencyCode(r),o=this.safeString(n,"name");let d=!1,c,u,h,l=!1,p=!1;const m={},g=this.safeValue(n,"networkList",[]);for(let w=0;w<g.length;w++){const k=g[w],T=this.safeString(k,"network"),O=this.safeNetwork(T),x=this.safeValue(k,"depositEnable",!1),C=this.safeValue(k,"withdrawEnable",!1),E=x&&C;d=E||d;const P=this.safeString(k,"withdrawMin"),_=this.safeString(k,"withdrawMax");u=u===void 0?P:u,h=h===void 0?_:h;const S=this.safeNumber(k,"withdrawFee");c=c===void 0?S:c,fi.stringGt(u,P)&&(u=P),fi.stringLt(h,_)&&(h=_),x&&(l=!0),C&&(p=!0),m[O]={info:k,id:T,network:O,active:E,deposit:x,withdraw:C,fee:this.safeNumber(k,"fee"),precision:void 0,limits:{withdraw:{min:P,max:_}}}}const b=Object.keys(m).length;if(b===1||"NONE"in m){const w=this.safeValue2(m,"NONE",b-1);w!==void 0&&(c=w.fee)}s[a]={info:n,id:r,code:a,name:o,active:d,deposit:l,withdraw:p,fee:c,precision:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:u,max:h}},networks:m}}return s}safeNetwork(e){if(e.indexOf("BSC")>=0)return"BEP20";e=e.split(" ").join(""),e=e.replace("-20","20");const s={ETH:"ETH",ERC20:"ERC20","BEP20(BSC)":"BEP20",TRX:"TRC20"};return this.safeString(s,e,e)}async fetchMarkets(e={}){const t=await this.fetchSpotMarkets(e),s=await this.fetchSwapMarkets(e);return this.arrayConcat(t,s)}async fetchSpotMarkets(e={}){const t=await this.spotPublicGetExchangeInfo(e),s=this.safeValue(t,"symbols",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeString(r,"baseAsset"),d=this.safeString(r,"quoteAsset"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d),h=this.safeString(r,"status"),l=this.safeValue(r,"isSpotTradingAllowed");let p=!1;h==="ENABLED"&&l&&(p=!0);const m=this.safeValue(r,"isMarginTradingAllowed"),g=this.safeNumber(r,"makerCommission"),y=this.safeNumber(r,"takerCommission"),b=this.safeNumber(r,"maxQuoteAmount");i.push({id:a,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:m,swap:!1,future:!1,option:!1,active:p,contract:!1,linear:void 0,inverse:void 0,taker:y,maker:g,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"baseAssetPrecision"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"quoteAssetPrecision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"baseSizePrecision"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(r,"quoteAmountPrecision"),max:b}},info:r})}return i}async fetchSwapMarkets(e={}){const t=await this.contractPublicGetDetail(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeString(r,"baseCoin"),d=this.safeString(r,"quoteCoin"),c=this.safeString(r,"settleCoin"),u=this.safeCurrencyCode(o),h=this.safeCurrencyCode(d),l=this.safeCurrencyCode(c),p=this.safeString(r,"state");i.push({id:a,symbol:u+"/"+h+":"+l,base:u,quote:h,settle:l,baseId:o,quoteId:d,settleId:c,type:"swap",spot:!1,margin:!1,swap:!0,future:!1,option:!1,active:p==="0",contract:!0,linear:!0,inverse:!1,taker:this.safeNumber(r,"takerFeeRate"),maker:this.safeNumber(r,"makerFeeRate"),contractSize:this.safeNumber(r,"contractSize"),expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(r,"volUnit"),price:this.safeNumber(r,"priceUnit")},limits:{leverage:{min:this.safeNumber(r,"minLeverage"),max:this.safeNumber(r,"maxLeverage")},amount:{min:this.safeNumber(r,"minVol"),max:this.safeNumber(r,"maxVol")},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit=t);let r;if(i.spot){const a=await this.spotPublicGetDepth(this.extend(n,s));r=this.parseOrderBook(a,e),r.nonce=this.safeInteger(a,"lastUpdateId")}else if(i.swap){const a=await this.contractPublicGetDepthSymbol(this.extend(n,s)),o=this.safeValue(a,"data"),d=this.safeInteger(o,"timestamp");r=this.parseOrderBook(o,e,d),r.nonce=this.safeInteger(o,"version")}return r}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s);let a;if(n.spot){let o=this.safeString(this.options,"fetchTradesMethod","spotPublicGetAggTrades");o=this.safeString(i,"method",o),a=await this[o](this.extend(r,i))}else if(n.swap){const o=await this.contractPublicGetDealsSymbol(this.extend(r,i));a=this.safeValue(o,"data")}return this.parseTrades(a,n,t,s)}parseTrade(e,t=void 0){let s,i,n,r,a,d,c,u,h,l;if("v"in e)i=this.safeInteger(e,"t"),t=this.safeMarket(void 0,t),r=t.symbol,u=this.safeString(e,"p"),h=this.safeString(e,"v"),d=this.parseOrderSide(this.safeString(e,"T")),c="taker";else{const p=this.safeString(e,"symbol");if(t=this.safeMarket(p,t),r=t.symbol,s=this.safeString2(e,"id","a"),u=this.safeString2(e,"price","p"),n=this.safeString(e,"orderId"),"positionMode"in e)i=this.safeInteger(e,"timestamp"),h=this.safeString(e,"vol"),d=this.parseOrderSide(this.safeString(e,"side")),a={cost:this.safeString(e,"fee"),currency:this.safeCurrencyCode(this.safeString(e,"feeCurrency"))},c=this.safeValue(e,"taker")?"taker":"maker";else{i=this.safeInteger2(e,"time","T"),h=this.safeString2(e,"qty","q"),l=this.safeString(e,"quoteQty");const m=this.safeValue(e,"isBuyer"),g=this.safeValue(e,"isMaker"),y=this.safeString2(e,"isBuyerMaker","m");g!==void 0&&(c=g?"maker":"taker"),m!==void 0&&(d=m?"buy":"sell"),y!==void 0&&(d=y?"sell":"buy",c="taker");const b=this.safeString(e,"commissionAsset");b!==void 0&&(a={cost:this.safeString(e,"commission"),currency:this.safeCurrencyCode(b)})}}return s===void 0&&(s=this.syntheticTradeId(t,i,d,h,u,void 0,c)),this.safeTrade({id:s,order:n,timestamp:i,datetime:this.iso8601(i),symbol:r,type:void 0,side:d,takerOrMaker:c,price:u,amount:h,cost:l,fee:a,info:e},t)}syntheticTradeId(e=void 0,t=void 0,s=void 0,i=void 0,n=void 0,r=void 0,a=void 0){let o="";return t!==void 0&&(o=this.numberToString(t)+"-"+this.safeString(e,"id","_"),s!==void 0&&(o+="-"+s),i!==void 0&&(o+="-"+this.numberToString(i)),n!==void 0&&(o+="-"+this.numberToString(n)),a!==void 0&&(o+="-"+a),r!==void 0&&(o+="-"+r)),o}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.safeValue(this.options,"timeframes",{}),o=this.safeValue(a,r.type,{}),d=this.safeString(o,t),c={symbol:r.id,interval:d};let u;if(r.spot)s!==void 0&&(c.startTime=s),i!==void 0&&(c.limit=i),u=await this.spotPublicGetKlines(this.extend(c,n));else if(r.swap){s!==void 0&&(c.start=parseInt(s/1e3));const h=this.safeString(n,"price","default");n=this.omit(n,"price");const l=this.getSupportedMapping(h,{default:"contractPublicGetKlineSymbol",index:"contractPublicGetKlineIndexPriceSymbol",mark:"contractPublicGetKlineFairPriceSymbol"}),p=await this[l](this.extend(c,n)),m=this.safeValue(p,"data");u=this.convertTradingViewToOHLCV(m,"time","open","high","low","close","vol")}return this.parseOHLCVs(u,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};let i,n=!1;if(e!==void 0){n=e.length===1;const c=this.safeString(e,0);i=this.market(c)}const[r,a]=this.handleMarketTypeAndParams("fetchTickers",i,t);let o;if(n&&(s.symbol=i.id),r==="spot")o=await this.spotPublicGetTicker24hr(this.extend(s,a));else if(r==="swap"){const d=await this.contractPublicGetTicker(this.extend(s,a));o=this.safeValue(d,"data",[])}return n&&(o=[o]),this.parseTickers(o,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),[i,n]=this.handleMarketTypeAndParams("fetchTicker",s,t);let r;const a={symbol:s.id};if(i==="spot")r=await this.spotPublicGetTicker24hr(this.extend(a,n));else if(i==="swap"){const o=await this.contractPublicGetTicker(this.extend(a,n));r=this.safeValue(o,"data",{})}return this.parseTicker(r,e)}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);let i,n,r,a,o,d,c,u,h,l,p,m,g;return this.safeValue(t,"swap")||"timestamp"in e?(i=this.safeInteger(e,"timestamp"),n=this.safeNumber(e,"bid1"),r=this.safeNumber(e,"ask1"),d=this.safeString(e,"volume24"),c=this.safeString(e,"amount24"),h=this.safeNumber(e,"high24Price"),l=this.safeNumber(e,"lower24Price"),m=this.safeString(e,"riseFallValue"),p=this.safeString(e,"riseFallRate"),p=this.parseNumber(fi.stringMul(p,"100"))):(i=this.safeInteger(e,"closeTime"),n=this.safeNumber(e,"bidPrice"),r=this.safeNumber(e,"askPrice"),a=this.safeNumber(e,"bidQty"),o=this.safeNumber(e,"askQty"),a===0&&(a=void 0),o===0&&(o=void 0),d=this.safeString(e,"volume"),c=this.safeString(e,"quoteVolume"),u=this.safeString(e,"openPrice"),h=this.safeNumber(e,"highPrice"),l=this.safeNumber(e,"lowPrice"),g=this.safeString(e,"prevClosePrice"),m=this.safeString(e,"priceChange"),p=this.safeString(e,"priceChangePercent"),p=this.parseNumber(fi.stringMul(p,"100"))),this.safeTicker({symbol:t.symbol,timestamp:i,datetime:this.iso8601(i),open:u,high:h,low:l,close:this.safeString(e,"lastPrice"),bid:n,bidVolume:a,ask:r,askVolume:o,vwap:void 0,previousClose:g,change:m,percentage:p,average:void 0,baseVolume:d,quoteVolume:c,info:e},t)}async fetchBidsAsks(e=void 0,t={}){await this.loadMarkets();let s,i=!1;e!==void 0&&(i=e.length===1,s=this.market(e[0]));const[n,r]=this.handleMarketTypeAndParams("fetchBidsAsks",s,t);let a;if(n==="spot")a=await this.spotPublicGetTickerBookTicker(r);else if(n==="swap")throw new zv(this.id+" fetchBidsAsks() is not available for "+n+" markets");return i&&(a=[a]),this.parseTickers(a,e)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),[o,d]=this.handleMarginModeAndParams("createOrder",r);if(a.spot)return await this.createSpotOrder(a,t,s,i,n,o,d);if(a.swap)return await this.createSwapOrder(a,t,s,i,n,o,d)}async createSpotOrder(e,t,s,i,n=void 0,r=void 0,a={}){const o=e.symbol,d=s==="buy"?"BUY":"SELL",c={symbol:e.id,side:d,type:t.toUpperCase()};if(d==="BUY"&&t==="market"){const p=this.safeNumber(a,"quoteOrderQty");if(p!==void 0)i=p;else if(this.options.createMarketBuyOrderRequiresPrice){if(n===void 0)throw new _n(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)");{const m=this.numberToString(i),g=this.numberToString(n),y=fi.stringMul(m,g);i=this.parseNumber(y)}}c.quoteOrderQty=i}else c.quantity=this.amountToPrecision(o,i);n!==void 0&&(c.price=this.priceToPrecision(o,n));const u=this.safeString(a,"clientOrderId");u!==void 0&&(c.newClientOrderId=u,a=this.omit(a,["type","clientOrderId"]));let h="spotPrivatePostOrder";if(r!==void 0){if(r!=="isolated")throw new hs(this.id+" createOrder() does not support marginMode "+r+" for spot-margin trading");h="spotPrivatePostMarginOrder"}const l=await this[h](this.extend(c,a));return this.extend(this.parseOrder(l,e),{side:s,type:t,price:n,amount:i})}async createSwapOrder(e,t,s,i,n=void 0,r=void 0,a={}){await this.loadMarkets();const o=e.symbol,d=this.safeValue(this.options,"unavailableContracts",{});if(this.safeValue(d,o,!1))throw new zv(this.id+" createSwapOrder() does not support yet this symbol:"+o);let u;if(r!==void 0)if(r==="cross")u=2;else if(r==="isolated")u=1;else throw new Ps(this.id+' createSwapOrder() marginMode parameter should be either "cross" or "isolated"');else u=this.safeInteger(a,"openType",2);if(t!=="limit"&&t!=="market"&&t!==1&&t!==2&&t!==3&&t!==4&&t!==5&&t!==6)throw new _n(this.id+" createSwapOrder() order type must either limit, market, or 1 for limit orders, 2 for post-only orders, 3 for IOC orders, 4 for FOK orders, 5 for market orders or 6 to convert market price to current price");this.safeValue(a,"postOnly",!1)?t=2:t==="limit"?t=1:t==="market"&&(t=6);const l={symbol:e.id,vol:parseFloat(this.amountToPrecision(o,i)),type:t,openType:u};let p="contractPrivatePostOrderSubmit";const m=this.safeNumber2(a,"triggerPrice","stopPrice");if(a=this.omit(a,["stopPrice","triggerPrice"]),m&&(p="contractPrivatePostPlanorderPlace",l.triggerPrice=this.priceToPrecision(o,m),l.triggerType=this.safeInteger(a,"triggerType",1),l.executeCycle=this.safeInteger(a,"executeCycle",1),l.trend=this.safeInteger(a,"trend",1),l.orderType=this.safeInteger(a,"orderType",1)),t!==5&&t!==6&&t!=="market"&&(l.price=parseFloat(this.priceToPrecision(o,n))),u===1&&this.safeInteger(a,"leverage")===void 0)throw new Ps(this.id+" createSwapOrder() requires a leverage parameter for isolated margin orders");this.safeValue(a,"reduceOnly",!1)?l.side=s==="buy"?2:4:l.side=s==="buy"?1:3;const y=this.safeString2(a,"clientOrderId","externalOid");y!==void 0&&(l.externalOid=y),a=this.omit(a,["clientOrderId","externalOid","postOnly"]);const b=await this[p](this.extend(l,a)),w=this.safeString(b,"data");return this.parseOrder(w,e)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Ps(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={symbol:i.id};let r;if(i.spot){const a=this.safeString(s,"clientOrderId");a!==void 0?(s=this.omit(s,"clientOrderId"),n.origClientOrderId=a):n.orderId=e;const[o,d]=this.handleMarginModeAndParams("fetchOrder",s);let c="spotPrivateGetOrder";if(o!==void 0){if(o!=="isolated")throw new hs(this.id+" fetchOrder() does not support marginMode "+o+" for spot-margin trading");c="spotPrivateGetMarginOrder"}r=await this[c](this.extend(n,d))}else if(i.swap){n.order_id=e;const a=await this.contractPrivateGetOrderGetOrderId(this.extend(n,s));r=this.safeValue(a,"data")}return this.parseOrder(r,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id);const[a,o]=this.handleMarketTypeAndParams("fetchOrders",r,i);if(a==="spot"){if(e===void 0)throw new Ps(this.id+" fetchOrders() requires a symbol argument for spot market");const[d,c]=this.handleMarginModeAndParams("fetchOrders",i);let u="spotPrivateGetAllOrders";if(d!==void 0){if(d!=="isolated")throw new hs(this.id+" fetchOrders() does not support marginMode "+d+" for spot-margin trading");u="spotPrivateGetMarginAllOrders"}t!==void 0&&(n.startTime=t),s!==void 0&&(n.limit=s);const h=await this[u](this.extend(n,c));return this.parseOrders(h,r,t,s)}else{t!==void 0&&(n.start_time=t,this.safeInteger(i,"end_time")===void 0&&(n.end_time=this.sum(t,this.options.maxTimeTillEnd))),s!==void 0&&(n.page_size=s);let d=this.safeString(this.options,"fetchOrders","contractPrivateGetOrderListHistoryOrders");d=this.safeString(o,"method",d);let c=[],u=[];if(d==="contractPrivateGetOrderListHistoryOrders"){const l=await this.contractPrivateGetOrderListHistoryOrders(this.extend(n,o));c=this.safeValue(l,"data")}else{const l=await this.contractPrivateGetPlanorderListOrders(this.extend(n,o));u=this.safeValue(l,"data")}const h=this.arrayConcat(u,c);return this.parseOrders(h,r,t,s,i)}}async fetchOrdersByIds(e,t=void 0,s={}){await this.loadMarkets();const i={};let n;t!==void 0&&(n=this.market(t),i.symbol=n.id);const[r,a]=this.handleMarketTypeAndParams("fetchOrdersByIds",n,s);if(r==="spot")throw new hs(this.id+" fetchOrdersByIds() is not supported for "+r);{i.order_ids=e.join(",");const o=await this.contractPrivateGetOrderBatchQuery(this.extend(i,a)),d=this.safeValue(o,"data");return this.parseOrders(d,n)}}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id);let a;if([a,i]=this.handleMarketTypeAndParams("fetchOpenOrders",r,i),a==="spot"){if(e===void 0)throw new Ps(this.id+" fetchOpenOrders() requires a symbol argument for spot market");let o="spotPrivateGetOpenOrders";const[d,c]=this.handleMarginModeAndParams("fetchOpenOrders",i);if(d!==void 0){if(d!=="isolated")throw new hs(this.id+" fetchOpenOrders() does not support marginMode "+d+" for spot-margin trading");o="spotPrivateGetMarginOpenOrders"}const u=await this[o](this.extend(n,c));return this.parseOrders(u,r,t,s)}else return await this.fetchOrdersByState(2,e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState(3,e,t,s,i)}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState(4,e,t,s,i)}async fetchOrdersByState(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;t!==void 0&&(r=this.market(t),r.id);const[a]=this.handleMarketTypeAndParams("fetchOrdersByState",r,n);if(a==="spot")throw new hs(this.id+" fetchOrdersByState() is not supported for "+a);return n.states=e,this.fetchOrders(t,s,i,n)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();let i;t!==void 0&&(i=this.market(t),i.id);let n;[n,s]=this.handleMarketTypeAndParams("cancelOrder",i,s);const[r,a]=this.handleMarginModeAndParams("cancelOrder",s);let o;if(n==="spot"){if(t===void 0)throw new Ps(this.id+" cancelOrder() requires a symbol argument");const d={symbol:i.id},c=this.safeString(s,"clientOrderId");c!==void 0?(s=this.omit(a,"clientOrderId"),d.origClientOrderId=c):d.orderId=e;let u="spotPrivateDeleteOrder";if(r!==void 0){if(r!=="isolated")throw new hs(this.id+" cancelOrder() does not support marginMode "+r+" for spot-margin trading");u="spotPrivateDeleteMarginOrder"}o=await this[u](this.extend(d,a))}else{let d=this.safeString(this.options,"cancelOrder","contractPrivatePostOrderCancel");d=this.safeString(a,"method",d);const c=await this[d]([e]);o=this.safeValue(c,"data");const u=this.safeValue(o,0),h=this.safeValue(u,"errorMsg","");if(h!=="success")throw new _n(this.id+" cancelOrder() the order with id "+e+" cannot be cancelled: "+h)}return this.parseOrder(o,i)}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i=t!==void 0?this.market(t):void 0,[n]=this.handleMarketTypeAndParams("cancelOrders",i,s);if(n==="spot")throw new hs(this.id+" cancelOrders() is not supported for "+n);{const r=await this.contractPrivatePostOrderCancel(e),a=this.safeValue(r,"data");return this.parseOrders(a,i)}}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s=e!==void 0?this.market(e):void 0,i={};let n;[n,t]=this.handleMarketTypeAndParams("cancelAllOrders",s,t);const[r,a]=this.handleMarginModeAndParams("cancelAllOrders",t);if(n==="spot"){if(e===void 0)throw new Ps(this.id+" cancelAllOrders() requires a symbol argument on spot");i.symbol=s.id;let o="spotPrivateDeleteOpenOrders";if(r!==void 0){if(r!=="isolated")throw new hs(this.id+" cancelAllOrders() does not support marginMode "+r+" for spot-margin trading");o="spotPrivateDeleteMarginOpenOrders"}const d=await this[o](this.extend(i,a));return this.parseOrders(d,s)}else{e!==void 0&&(i.symbol=s.id);let o=this.safeString(this.options,"cancelAllOrders","contractPrivatePostOrderCancelAll");o=this.safeString(a,"method",o);const d=await this[o](this.extend(i,a)),c=this.safeValue(d,"data",[]);return this.parseOrders(c,s)}}parseOrder(e,t=void 0){let s;typeof e=="string"?s=e:s=this.safeString2(e,"orderId","id");const i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const n=this.safeIntegerN(e,["time","createTime","transactTime"]);let r;const a=this.safeString(e,"feeCurrency");if(a!==void 0){const o=this.safeString(e,"takerFee"),d=this.safeString(e,"makerFee"),c=fi.stringAdd(o,d);r={currency:a,cost:this.parseNumber(c)}}return this.safeOrder({id:s,clientOrderId:this.safeString(e,"clientOrderId"),timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,status:this.parseOrderStatus(this.safeString2(e,"status","state")),symbol:t.symbol,type:this.parseOrderType(this.safeString(e,"type")),timeInForce:this.parseOrderTimeInForce(this.safeString(e,"timeInForce")),side:this.parseOrderSide(this.safeString(e,"side")),price:this.safeNumber(e,"price"),stopPrice:this.safeNumber2(e,"stopPrice","triggerPrice"),average:this.safeNumber(e,"dealAvgPrice"),amount:this.safeNumber2(e,"origQty","vol"),cost:this.safeNumber(e,"cummulativeQuoteQty"),filled:this.safeNumber2(e,"executedQty","dealVol"),remaining:void 0,fee:r,trades:void 0,info:e},t)}parseOrderSide(e){const t={BUY:"buy",SELL:"sell"};return this.safeString(t,e,e)}parseOrderType(e){const t={MARKET:"market",LIMIT:"limit",LIMIT_MAKER:"limit"};return this.safeString(t,e,e)}parseOrderStatus(e){const t={NEW:"open",FILLED:"closed",CANCELED:"canceled",PARTIALLY_FILLED:"open",PARTIALLY_CANCELED:"canceled",2:"open",3:"closed",4:"canceled"};return this.safeString(t,e,e)}parseOrderTimeInForce(e){const t={GTC:"GTC",FOK:"FOK",IOC:"IOC"};return this.safeString(t,e,e)}async fetchAccountHelper(e,t){if(e==="spot")return await this.spotPrivateGetAccount(t);if(e==="swap"){const s=await this.contractPrivateGetAccountAssets(t);return this.safeValue(s,"data")}}async fetchAccounts(e={}){const[t,s]=this.handleMarketTypeAndParams("fetchAccounts",void 0,e);await this.loadMarkets();const i=await this.fetchAccountHelper(t,s),n=this.safeValue(i,"balances",[]),r=[];for(let a=0;a<n.length;a++){const o=n[a],d=this.safeString2(o,"asset","currency"),c=this.safeCurrencyCode(d);r.push({id:this.safeString(o,"id"),type:this.safeString(o,"type"),code:c,info:o})}return r}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.fetchAccountHelper("spot",e);let s=this.safeString(t,"makerCommission"),i=this.safeString(t,"takerCommission");s=fi.stringDiv(s,"1000"),i=fi.stringDiv(i,"1000");const n={};for(let r=0;r<this.symbols.length;r++){const a=this.symbols[r];n[a]={symbol:a,maker:this.parseNumber(s),taker:this.parseNumber(i),percentage:!0,tierBased:!1,info:t}}return n}async fetchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),i={};let n;if(t==="spot"){n=await this.fetchAccountHelper("spot",s);const r=this.safeValue(n,"balances",[]);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeString(o,"asset"),c=this.safeCurrencyCode(d),u=this.account();u.free=this.safeString(o,"free"),u.used=this.safeString(o,"locked"),i[c]=u}}else if(t==="swap"){n=await this.contractPrivateGetAccountAssets(s);const r=this.safeValue(n,"data",[]);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeString(o,"currency"),c=this.safeCurrencyCode(d),u=this.account();u.free=this.safeString(o,"availableBalance"),u.used=this.safeString(o,"frozenBalance"),i[c]=u}}return i.info=n,this.safeBalance(i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Ps(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),[r,a]=this.handleMarketTypeAndParams("fetchMyTrades",n,i),o={symbol:n.id};let d;if(r==="spot")t!==void 0&&(o.start_time=t),s!==void 0&&(o.limit=s),d=await this.spotPrivateGetMyTrades(this.extend(o,a));else{t!==void 0&&(o.start_time=t,this.safeInteger(i,"end_time")===void 0&&(o.end_time=this.sum(t,this.options.maxTimeTillEnd))),s!==void 0&&(o.page_size=s);const c=await this.contractPrivateGetOrderListOrderDeals(this.extend(o,a));d=this.safeValue(c,"data")}return this.parseTrades(d,n,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a;t!==void 0&&(a=this.market(t));const[o,d]=this.handleMarketTypeAndParams("fetchOrderTrades",a,n);let c;if(o==="spot"){if(t===void 0)throw new Ps(this.id+" fetchOrderTrades() requires a symbol argument");r.symbol=a.id,r.orderId=e,c=await this.spotPrivateGetMyTrades(this.extend(r,d))}else{r.order_id=e;const u=await this.contractPrivateGetOrderDealDetailsOrderId(this.extend(r,d));c=this.safeValue(u,"data")}return this.parseTrades(c,a,s,i,d)}async modifyMarginHelper(e,t,s,i={}){const n=this.safeInteger(i,"positionId");if(n===void 0)throw new Ps(this.id+" modifyMarginHelper() requires a positionId parameter");await this.loadMarkets();const r={positionId:n,amount:t,type:s};return await this.contractPrivatePostPositionChangeMargin(this.extend(r,i))}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"SUB",s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"ADD",s)}async setLeverage(e,t=void 0,s={}){await this.loadMarkets();const i={leverage:e},n=this.safeInteger(s,"positionId");if(n===void 0){const r=this.safeNumber(s,"openType"),a=this.safeNumber(s,"positionType"),o=t!==void 0?this.market(t):void 0;if(r===void 0||a===void 0||o===void 0)throw new Ps(this.id+" setLeverage() requires a positionId parameter or a symbol argument with openType and positionType parameters, use openType 1 or 2 for isolated or cross margin respectively, use positionType 1 or 2 for long or short positions");i.openType=r,i.symbol=o.symbol,i.positionType=a}else i.positionId=n;return await this.contractPrivatePostPositionChangeLeverage(this.extend(i,s))}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),s!==void 0&&(r.page_size=s);const a=await this.contractPrivateGetPositionFundingRecords(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"resultList",[]),c=[];for(let u=0;u<d.length;u++){const h=d[u],l=this.safeInteger(h,"settleTime");c.push({info:h,symbol:e,code:void 0,timestamp:l,datetime:this.iso8601(l),id:this.safeNumber(h,"id"),amount:this.safeNumber(h,"funding")})}return c}parseFundingRate(e,t=void 0){const s=this.safeNumber(e,"fundingRate"),i=this.safeInteger(e,"nextSettleTime"),n=this.safeString(e,"symbol"),r=this.safeSymbol(n,t),a=this.safeInteger(e,"timestamp"),o=this.iso8601(a);return{info:e,symbol:r,markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:a,datetime:o,fundingRate:s,fundingTimestamp:i,fundingDatetime:this.iso8601(i),nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.contractPublicGetFundingRateSymbol(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseFundingRate(r,s)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Ps(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.page_size=s);const a=await this.contractPublicGetFundingRateHistory(this.extend(r,i)),o=this.safeValue(a,"data"),d=this.safeValue(o,"resultList",[]),c=[];for(let h=0;h<d.length;h++){const l=d[h],p=this.safeString(l,"symbol"),m=this.safeSymbol(p),g=this.safeInteger(l,"settleTime");c.push({info:l,symbol:m,fundingRate:this.safeNumber(l,"fundingRate"),timestamp:g,datetime:this.iso8601(g)})}const u=this.sortBy(c,"timestamp");return this.filterBySymbolSinceLimit(u,n.symbol,t,s)}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const s=await this.contractPublicGetDetail(t),i=this.safeValue(s,"data");return this.parseLeverageTiers(i,e,"symbol")}parseMarketLeverageTiers(e,t){let s=this.safeString(e,"maintenanceMarginRate"),i=this.safeString(e,"initialMarginRate");const n=this.safeString(e,"maxVol"),r=this.safeString(e,"riskIncrVol"),a=this.safeString(e,"riskIncrMmr"),o=this.safeString(e,"riskIncrImr");let d="0";const c=[],u=this.safeString(e,"quoteCoin");for(;fi.stringLt(d,n);){const h=fi.stringAdd(d,r);c.push({tier:this.parseNumber(fi.stringDiv(h,r)),currency:this.safeCurrencyCode(u),notionalFloor:this.parseNumber(d),notionalCap:this.parseNumber(h),maintenanceMarginRate:this.parseNumber(s),maxLeverage:this.parseNumber(fi.stringDiv("1",i)),info:e}),i=fi.stringAdd(i,o),s=fi.stringAdd(s,a),d=h}return c}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeCurrencyCode(void 0,t),n=this.safeString(e,"chain"),r=this.safeNetwork(n);return this.checkAddress(s),{currency:i,address:s,tag:void 0,network:r,info:e}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const i={coin:this.currency(e).id},n=await this.spotPrivateGetCapitalDepositAddress(this.extend(i,t)),r=[];for(let a=0;a<n.length;a++){const o=n[a],d=this.safeString(o,"coin"),c=this.currency(d),u=this.safeString(o,"network"),h=this.safeNetwork(u),l=this.safeString(o,"address",void 0),p=this.safeString(o,"tag",void 0);r.push({currency:c.id,network:h,address:l,tag:p})}return r}async fetchDepositAddress(e,t={}){const s=this.safeStringUpper(t,"network");t=this.omit(t,"network");const i=await this.fetchDepositAddressesByNetwork(e,t);if(s!==void 0)for(let r=0;r<i.length;r++){const a=i[r],o=this.safeStringUpper(a,"network");if(s===o)return a}const n=this.safeValue(i,0);if(n===void 0)throw new O9(this.id+" fetchDepositAddress() cannot find a deposit address for "+e+", consider creating one using the MEXC platform");return n}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Ps(this.id+" fetchDeposits() requires a currency code argument");await this.loadMarkets();const n={};let r;const a=this.safeString(i,"network");if(i=this.omit(i,"network"),a===void 0)throw new Ps(this.id+" fetchDeposits() requires a network parameter when the currency is specified");if(r=this.currency(e),n.coin=r.id+"-"+a,t!==void 0&&(n.startTime=t),s!==void 0){if(s>1e3)throw new Xa("This exchange supports a maximum limit of 1000");n.limit=s}const o=await this.spotPrivateGetCapitalDepositHisrec(this.extend(n,i));return this.parseTransactions(o,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Ps(this.id+" fetchWithdrawals() requires a currency code argument");await this.loadMarkets();const n={},r=this.currency(e);if(n.coin=r.id,t!==void 0&&(n.startTime=t),s!==void 0){if(s>1e3)throw new Xa("This exchange supports a maximum limit of 1000");n.limit=s}const a=await this.spotPrivateGetCapitalWithdrawHistory(this.extend(n,i));return this.parseTransactions(a,r,t,s)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=s===void 0?"deposit":"withdrawal",n=this.safeInteger2(e,"insertTime","applyTime"),r=this.safeString(e,"currency"),a=this.safeString(e,"network"),o=this.safeCurrencyCode(r,t),d=this.parseTransactionStatus(this.safeString(e,"status"));let c=this.safeString(e,"amount");const u=this.safeString(e,"address"),h=this.safeString(e,"txId");let l;const p=this.safeString(e,"transactionFee");return p!==void 0&&(l={cost:this.parseNumber(p),currency:o}),i==="withdrawal"&&(c=fi.stringSub(c,p)),{info:e,id:s,txid:h,timestamp:n,datetime:this.iso8601(n),network:a,address:u,addressTo:u,addressFrom:void 0,tag:this.safeString(e,"memo"),tagTo:void 0,tagFrom:void 0,type:i,amount:this.parseNumber(c),currency:o,status:d,updated:void 0,fee:l}}parseTransactionStatus(e){const t={WAIT:"pending",WAIT_PACKAGING:"pending",SUCCESS:"ok"};return this.safeString(t,e,e)}async fetchPosition(e,t={}){await this.loadMarkets();const i={symbol:this.market(e).id},n=await this.fetchPositions(void 0,this.extend(i,t));return this.safeValue(n,0)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.contractPrivateGetPositionOpenPositions(t),i=this.safeValue(s,"data",[]);return this.parsePositions(i,e)}parsePosition(e,t=void 0){t=this.safeMarket(this.safeString(e,"symbol"),t);const s=t.symbol,i=this.safeString(e,"holdVol"),n=this.safeNumber(e,"openAvgPrice"),r=this.safeString(e,"im"),o=this.safeString(e,"positionType")==="1"?"long":"short",c=this.safeString(e,"margin_mode")==="1"?"isolated":"cross",u=this.safeNumber(e,"leverage"),h=this.safeNumber(e,"liquidatePrice"),l=this.safeNumber(e,"updateTime");return{info:e,id:void 0,symbol:s,contracts:this.parseNumber(i),contractSize:void 0,entryPrice:n,collateral:void 0,side:o,unrealizedProfit:void 0,leverage:this.parseNumber(u),percentage:void 0,marginType:c,notional:void 0,markPrice:void 0,liquidationPrice:h,initialMargin:this.parseNumber(r),initialMarginPercentage:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,marginRatio:void 0,timestamp:l,datetime:this.iso8601(l)}}async fetchTransfer(e,t=void 0,s=void 0,i={}){const[n,r]=this.handleMarketTypeAndParams("fetchTransfer",void 0,i);if(await this.loadMarkets(),n==="spot"){const a={transact_id:e},o=await this.spot2PrivateGetAssetInternalTransferInfo(this.extend(a,r)),d=this.safeValue(o,"data",{});return this.parseTransfer(d)}else if(n==="swap")throw new hs(this.id+" fetchTransfer() is not supported for "+n)}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){const[n,r]=this.handleMarketTypeAndParams("fetchTransfers",void 0,i);await this.loadMarkets();const a={};let o,d;if(e!==void 0&&(o=this.currency(e),a.currency=o.id),n==="spot"){if(t!==void 0&&(a.start_time=t),s!==void 0){if(s>50)throw new Xa("This exchange supports a maximum limit of 50");a["page-size"]=s}const c=await this.spot2PrivateGetAssetInternalTransferRecord(this.extend(a,r)),u=this.safeValue(c,"data",{});d=this.safeValue(u,"result_list",[])}else if(n==="swap"){s!==void 0&&(a.page_size=s);const c=await this.contractPrivateGetAccountTransferRecord(this.extend(a,r)),u=this.safeValue(c,"data");d=this.safeValue(u,"resultList")}return this.parseTransfers(d,o,t,s)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a={spot:"SPOT",swap:"FUTURES",margin:"ISOLATED_MARGIN"},o=this.safeString(a,s),d=this.safeString(a,i);if(o===void 0){const l=Object.keys(a);throw new Xa(this.id+" fromAccount must be one of "+l.join(", "))}if(d===void 0){const l=Object.keys(a);throw new Xa(this.id+" toAccount must be one of "+l.join(", "))}const c={asset:r.id,amount:t,fromAccountType:o,toAccountType:d};if(o==="ISOLATED_MARGIN"||d==="ISOLATED_MARGIN"){const l=this.safeString(n,"symbol");if(n=this.omit(n,"symbol"),l===void 0)throw new Ps(this.id+" transfer() requires a symbol argument for isolated margin");const p=this.market(l);c.symbol=p.id}const u=await this.spotPrivatePostCapitalTransfer(this.extend(c,n)),h=this.parseTransfer(u,r);return this.extend(h,{amount:t,fromAccount:s,toAccount:i})}parseTransfer(e,t=void 0){const s=this.safeString(e,"currency"),i=this.safeStringN(e,["transact_id","txid","tranId"]),n=this.safeInteger(e,"createTime"),r=n!==void 0?this.iso8601(n):void 0,a=this.safeString(e,"type");let o,d;return a!==void 0?(o=a==="IN"?"MAIN":"CONTRACT",d=a==="IN"?"CONTRACT":"MAIN"):(o=this.safeString(e,"from"),d=this.safeString(e,"to")),{info:e,id:i,timestamp:n,datetime:r,currency:this.safeCurrencyCode(s,t),amount:this.safeNumber(e,"amount"),fromAccount:this.parseAccountId(o),toAccount:this.parseAccountId(d),status:this.parseTransferStatus(this.safeString2(e,"transact_state","state"))}}parseAccountId(e){const t={MAIN:"spot",CONTRACT:"swap"};return this.safeString(t,e,e)}parseTransferStatus(e){const t={SUCCESS:"ok",FAILED:"failed",WAIT:"pending"};return this.safeString(t,e,e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n);const r=this.safeValue(this.options,"networks",{});let a=this.safeStringUpper2(n,"network","chain");a=this.safeString(r,a,a),this.checkAddress(s),await this.loadMarkets();const o=this.currency(e),d={coin:o.id,address:s,amount:t};i!==void 0&&(d.memo=i),a!==void 0&&(d.network=a,n=this.omit(n,"network"));const c=await this.spotPrivatePostCapitalWithdrawApply(this.extend(d,n));return this.parseTransaction(c,o)}async setPositionMode(e,t=void 0,s={}){const i={positionMode:e?1:2};return await this.contractPrivatePostPositionChangePositionMode(this.extend(i,s))}async fetchPositionMode(e=void 0,t={}){const s=await this.contractPrivateGetPositionPositionMode(t),i=this.safeInteger(s,"data");return{info:s,hedged:i===1}}async borrowMargin(e,t,s=void 0,i={}){if(await this.loadMarkets(),s===void 0)throw new Ps(this.id+" borrowMargin() requires a symbol argument for isolated margin");const n=this.market(s),r=this.currency(e),a={asset:r.id,amount:this.currencyToPrecision(e,t),symbol:n.id},o=await this.spotPrivatePostMarginLoan(this.extend(a,i)),d=this.parseMarginLoan(o,r);return this.extend(d,{amount:t,symbol:s})}async repayMargin(e,t,s=void 0,i={}){if(await this.loadMarkets(),s===void 0)throw new Ps(this.id+" repayMargin() requires a symbol argument for isolated margin");const n=this.safeString2(i,"id","borrowId");if(n===void 0)throw new Ps(this.id+" repayMargin() requires a borrowId argument in the params");const r=this.market(s),a=this.currency(e),o={asset:a.id,amount:this.currencyToPrecision(e,t),borrowId:n,symbol:r.id},d=await this.spotPrivatePostMarginRepay(this.extend(o,i)),c=this.parseMarginLoan(d,a);return this.extend(c,{amount:t,symbol:s})}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.spotPrivateGetCapitalConfigGetall(t);return this.parseTransactionFees(s,e)}parseTransactionFees(e,t=void 0){const s={};for(let i=0;i<e.length;i++){const n=e[i],r=this.safeString(n,"coin"),a=this.safeCurrency(r),o=this.safeString(a,"code");(t===void 0||this.inArray(o,t))&&(s[o]=this.parseTransactionFee(n,a))}return{withdraw:s,deposit:{},info:e}}parseTransactionFee(e,t=void 0){const s=this.safeValue(e,"networkList",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"network"),o=this.safeString(this.options.networks,a,a),d=this.safeNumber(r,"withdrawFee");i[o]=d}return i}parseMarginLoan(e,t=void 0){return{id:this.safeString(e,"tranId"),currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}handleMarginModeAndParams(e,t={},s=void 0){const i=this.safeString(this.options,"defaultType"),n=this.safeValue(t,"margin",!1);let r;return[r,t]=super.handleMarginModeAndParams(e,t,s),(i==="margin"||n===!0)&&(r="isolated"),[r,t]}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const[a,o]=t;[e,i]=this.resolvePath(e,i);let d;if(a==="spot"){d=this.urls.api[a][o]+"/api/"+this.version+"/"+e;let c="";if(o==="private"&&(i.timestamp=this.milliseconds(),i.recvWindow=this.safeInteger(this.options,"recvWindow",5e3)),Object.keys(i).length&&(c=this.urlencode(i),d+="?"+c),o==="private"){this.checkRequiredCredentials();const u=this.hmac(this.encode(c),this.encode(this.secret),"sha256");d+="&signature="+u,n={"X-MEXC-APIKEY":this.apiKey}}s==="POST"&&(n["Content-Type"]="application/json")}else if(a==="contract"||a==="spot2")if(d=this.urls.api[a][o]+"/"+this.implodeParams(e,i),i=this.omit(i,this.extractParams(e)),o==="public")Object.keys(i).length&&(d+="?"+this.urlencode(i));else{this.checkRequiredCredentials();const c=this.milliseconds().toString();let u="";n={ApiKey:this.apiKey,"Request-Time":c,"Content-Type":"application/json"},s==="POST"?(u=this.json(i),r=u):(i=this.keysort(i),Object.keys(i).length&&(u+=this.urlencode(i),d+="?"+u)),u=this.apiKey+c+u;const h=this.hmac(this.encode(u),this.encode(this.secret),"sha256");n.Signature=h}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0||this.safeValue(a,"success",!1)===!0)return;const u=this.safeString(a,"code",void 0);if(u!==void 0&&u!=="200"&&u!=="0"){const h=this.id+" "+r;throw this.throwBroadlyMatchedException(this.exceptions.broad,r,h),this.throwExactlyMatchedException(this.exceptions.exact,u,h),new Xa(h)}}};const C9=ge,{AuthenticationError:M9,ExchangeError:oh,PermissionDenied:P9,BadRequest:A9,CancelPending:B9,OrderNotFound:E9,InsufficientFunds:Kv,RateLimitExceeded:N9,InvalidOrder:jn,AccountSuspended:V9,BadSymbol:Xv,OnMaintenance:q9,ArgumentsRequired:L9,AccountNotEnabled:R9}=de,{TICK_SIZE:F9}=me;var D9=class extends C9{describe(){return this.deepExtend(super.describe(),{id:"novadax",name:"NovaDAX",countries:["BR"],rateLimit:16.6667,version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactions:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"ONE_MIN","5m":"FIVE_MIN","15m":"FIFTEEN_MIN","30m":"HALF_HOU","1h":"ONE_HOU","1d":"ONE_DAY","1w":"ONE_WEE","1M":"ONE_MON"},urls:{logo:"https://user-images.githubusercontent.com/1294454/92337550-2b085500-f0b3-11ea-98e7-5794fb07dd3b.jpg",api:{public:"https://api.novadax.com",private:"https://api.novadax.com"},www:"https://www.novadax.com.br",doc:["https://doc.novadax.com/pt-BR/"],fees:"https://www.novadax.com.br/fees-and-limits",referral:"https://www.novadax.com.br/?s=ccxt"},api:{public:{get:{"common/symbol":1.2,"common/symbols":1.2,"common/timestamp":1.2,"market/tickers":1.2,"market/ticker":1.2,"market/depth":1.2,"market/trades":1.2,"market/kline/history":1.2}},private:{get:{"orders/get":3,"orders/list":3,"orders/fill":3,"orders/fills":3,"account/getBalance":3,"account/subs":3,"account/subs/balance":3,"account/subs/transfer/record":3,"wallet/query/deposit-withdraw":3},post:{"orders/create":3,"orders/cancel":3,"account/withdraw/coin":3,"account/subs/transfer":3}}},fees:{trading:{tierBased:!1,percentage:!0,taker:this.parseNumber("0.005"),maker:this.parseNumber("0.0025")}},requiredCredentials:{apiKey:!0,secret:!0},precisionMode:F9,exceptions:{exact:{A99999:oh,A10001:A9,A10002:oh,A10003:M9,A10004:N9,A10005:P9,A10006:V9,A10007:R9,A10011:Xv,A10012:Xv,A10013:q9,A30001:E9,A30002:jn,A30003:jn,A30004:jn,A30005:jn,A30006:jn,A30007:Kv,A30008:jn,A30009:jn,A30010:B9,A30011:jn,A30012:jn,A40004:Kv},broad:{}},options:{fetchOHLCV:{volume:"amount"},transfer:{fillResponseFromRequest:!0}}})}async fetchTime(e={}){const t=await this.publicGetCommonTimestamp(e);return this.safeInteger(t,"data")}async fetchMarkets(e={}){const t=await this.publicGetCommonSymbols(e),s=[],i=this.safeValue(t,"data",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"baseCurrency"),o=this.safeString(r,"quoteCurrency"),d=this.safeString(r,"symbol"),c=this.safeCurrencyCode(a),u=this.safeCurrencyCode(o),h=this.safeString(r,"status");s.push({id:d,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:h==="ONLINE",contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"amountPrecision"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"pricePrecision"))),cost:this.parseNumber(this.parsePrecision(this.safeString(r,"valuePrecision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"minOrderAmount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(r,"minOrderValue"),max:void 0}},info:r})}return s}parseTicker(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t,"_"),r=this.safeString(e,"open24h"),a=this.safeString(e,"lastPrice"),o=this.safeString(e,"baseVolume24h"),d=this.safeString(e,"quoteVolume24h");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high24h"),low:this.safeString(e,"low24h"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:r,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:o,quoteVolume:d,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetMarketTicker(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetMarketTickers(t),i=this.safeValue(s,"data",[]),n={};for(let r=0;r<i.length;r++){const a=this.parseTicker(i[r]),o=a.symbol;n[o]=a}return this.filterByArray(n,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetMarketDepth(this.extend(n,s)),a=this.safeValue(r,"data",{}),o=this.safeInteger(a,"timestamp");return this.parseOrderBook(a,i.symbol,o,"bids","asks")}parseTrade(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"orderId"),n=this.safeInteger(e,"timestamp"),r=this.safeStringLower(e,"side"),a=this.safeString(e,"price"),o=this.safeString(e,"amount"),d=this.safeString(e,"symbol"),c=this.safeSymbol(d,t,"_"),u=this.safeStringLower(e,"role"),h=this.safeString(e,"fee");let l;if(h!==void 0){const p=this.safeString(e,"feeCurrency"),m=this.safeCurrencyCode(p);l={cost:this.safeString(e,"feeAmount"),currency:m}}return this.safeTrade({id:s,order:i,timestamp:n,datetime:this.iso8601(n),symbol:c,type:void 0,side:r,price:a,amount:o,cost:void 0,takerOrMaker:u,fee:l,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetMarketTrades(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,unit:this.timeframes[t]},o=this.parseTimeframe(t),d=this.seconds();if(i===void 0&&(i=3e3),s===void 0)a.from=d-i*o,a.to=d;else{const h=parseInt(s/1e3);a.from=h,a.to=this.sum(h,i*o)}const c=await this.publicGetMarketKlineHistory(this.extend(a,n)),u=this.safeValue(c,"data",[]);return this.parseOHLCVs(u,r,t,s,i)}parseOHLCV(e,t=void 0){const s=this.safeValue(this.options,"fetchOHLCV",{}),i=this.safeString(s,"volume","amount");return[this.safeTimestamp(e,"score"),this.safeNumber(e,"openPrice"),this.safeNumber(e,"highPrice"),this.safeNumber(e,"lowPrice"),this.safeNumber(e,"closePrice"),this.safeNumber(e,i)]}parseBalance(e){const t=this.safeValue(e,"data",[]),s={info:e,timestamp:void 0,datetime:void 0};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(n,"balance"),o.free=this.safeString(n,"available"),o.used=this.safeString(n,"hold"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountGetBalance(e);return this.parseBalance(t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o=t.toUpperCase();const d=s.toUpperCase(),c={symbol:a.id,side:d},u=this.safeValue2(r,"triggerPrice","stopPrice");if(u===void 0){if(o==="STOP_LIMIT"||o==="STOP_MARKET")throw new L9(this.id+" createOrder() requires a stopPrice parameter for "+o+" orders")}else{o==="LIMIT"?o="STOP_LIMIT":o==="MARKET"&&(o="STOP_MARKET");const p=d==="BUY"?"LTE":"GTE";c.operator=this.safeString(r,"operator",p),c.stopPrice=this.priceToPrecision(e,u),r=this.omit(r,["triggerPrice","stopPrice"])}if(o==="LIMIT"||o==="STOP_LIMIT")c.price=this.priceToPrecision(e,n),c.amount=this.amountToPrecision(e,i);else if(o==="MARKET"||o==="STOP_MARKET"){if(d==="SELL")c.amount=this.amountToPrecision(e,i);else if(d==="BUY"){let p=this.safeNumber(r,"value");if(this.safeValue(this.options,"createMarketBuyOrderRequiresPrice",!0)){if(n!==void 0)p===void 0&&(p=i*n);else if(p===void 0)throw new jn(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total cost value in the 'amount' argument or in the 'value' extra parameter (the exchange-specific behaviour)")}else p=p===void 0?i:p;c.value=this.costToPrecision(e,p)}}c.type=o;const h=await this.privatePostOrdersCreate(this.extend(c,r)),l=this.safeValue(h,"data",{});return this.parseOrder(l,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privatePostOrdersCancel(this.extend(i,s)),r=this.safeValue(n,"data",{});return this.parseOrder(r)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.privateGetOrdersGet(this.extend(i,s)),r=this.safeValue(n,"data",{});return this.parseOrder(r)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),s!==void 0&&(n.limit=s),t!==void 0&&(n.fromTimestamp=t);const a=await this.privateGetOrdersList(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseOrders(o,r,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"SUBMITTED,PROCESSING,PARTIAL_FILLED,CANCELING"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"FILLED,CANCELED,REJECTED"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={id:e},a=await this.privateGetOrdersFill(this.extend(r,n));let o;t!==void 0&&(o=this.market(t));const d=this.safeValue(a,"data",[]);return this.parseTrades(d,o,s,i)}parseOrderStatus(e){const t={SUBMITTED:"open",PROCESSING:"open",PARTIAL_FILLED:"open",CANCELING:"open",FILLED:"closed",CANCELED:"canceled",REJECTED:"rejected"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"amount"),n=this.safeString(e,"price"),r=this.safeString2(e,"filledValue","value"),a=this.safeStringLower(e,"type"),o=this.safeStringLower(e,"side"),d=this.parseOrderStatus(this.safeString(e,"status")),c=this.safeInteger(e,"timestamp"),u=this.safeString(e,"averagePrice"),h=this.safeString(e,"filledAmount");let l;const p=this.safeNumber(e,"filledFee");p!==void 0&&(l={cost:p,currency:void 0});const m=this.safeString(e,"symbol"),g=this.safeSymbol(m,t,"_"),y=this.safeNumber(e,"stopPrice");return this.safeOrder({id:s,clientOrderId:void 0,info:e,timestamp:c,datetime:this.iso8601(c),lastTradeTimestamp:void 0,symbol:g,type:a,timeInForce:void 0,postOnly:void 0,side:o,price:n,stopPrice:y,amount:i,cost:r,average:u,filled:h,remaining:void 0,status:d,fee:l,trades:void 0},t)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e);if(s!=="main"&&i!=="main")throw new oh(this.id+" transfer() supports transfers between main account and subaccounts only");const a=s==="main"?"master-transfer-in":"master-transfer-out",o={transferAmount:this.currencyToPrecision(e,t),currency:r.id,subId:a==="master-transfer-in"?i:s,transferType:a},d=await this.privatePostAccountSubsTransfer(this.extend(o,n)),c=this.parseTransfer(d,r),u=this.safeValue(this.options,"transfer",{});return this.safeValue(u,"fillResponseFromRequest",!0)&&(c.fromAccount=s,c.toAccount=i,c.amount=t),c}parseTransfer(e,t=void 0){const s=this.safeString(e,"data"),i=this.safeString(e,"message"),n=this.safeCurrencyCode(void 0,t);return{info:e,id:s,amount:void 0,code:n,currency:n,fromAccount:void 0,toAccount:void 0,timestamp:void 0,datetime:void 0,status:i}}parseTransferStatus(e){const t={SUCCESS:"pending"};return this.safeString(t,e,"failed")}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets();const r=this.currency(e),a={code:r.id,amount:this.currencyToPrecision(e,t),wallet:s};i!==void 0&&(a.tag=i);const o=await this.privatePostAccountWithdrawCoin(this.extend(a,n));return this.parseTransaction(o,r)}async fetchAccounts(e={}){const t=await this.privateGetAccountSubs(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"subId"),o=this.safeString(r,"subAccount");i.push({id:a,type:o,currency:void 0,info:r})}return i}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){const n={type:"coin_in"};return await this.fetchTransactions(e,t,s,this.extend(n,i))}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const n={type:"coin_out"};return await this.fetchTransactions(e,t,s,this.extend(n,i))}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.size=s);const a=await this.privateGetWalletQueryDepositWithdraw(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,r,t,s)}parseTransactionStatus(e){const t=e.split(" ");e=this.safeString(t,1,e);const s={Pending:"pending",confirming:"pending",SUCCESS:"ok",FAIL:"failed"};return this.safeString(s,e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"id","data");let i=this.safeString(e,"type");i==="COIN_IN"?i="deposit":i==="COIN_OUT"&&(i="withdraw");const n=this.safeNumber(e,"amount"),r=this.safeString(e,"address"),a=this.safeString(e,"addressTag"),o=this.safeString(e,"txHash"),d=this.safeInteger(e,"createdAt"),c=this.safeInteger(e,"updatedAt"),u=this.safeString(e,"currency"),h=this.safeCurrencyCode(u,t),l=this.parseTransactionStatus(this.safeString(e,"state")),p=this.safeString(e,"chain");return{info:e,id:s,currency:h,amount:n,network:p,address:r,addressTo:r,addressFrom:void 0,tag:a,tagTo:a,tagFrom:void 0,status:l,type:i,updated:c,txid:o,timestamp:d,datetime:this.iso8601(d),fee:void 0}}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),s!==void 0&&(n.limit=s),t!==void 0&&(n.fromTimestamp=t);const a=await this.privateGetOrdersFills(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,r,t,s)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a="/"+this.version+"/"+this.implodeParams(e,i);let o=this.urls.api[t]+a;const d=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(d).length&&(o+="?"+this.urlencode(d));else if(t==="private"){this.checkRequiredCredentials();const c=this.milliseconds().toString();n={"X-Nova-Access-Key":this.apiKey,"X-Nova-Timestamp":c};let u;s==="POST"?(r=this.json(d),u=this.hash(this.encode(r),"md5"),n["Content-Type"]="application/json"):(Object.keys(d).length&&(o+="?"+this.urlencode(d)),u=this.urlencode(this.keysort(d)));const h=s+`
`+a+`
`+u+`
`+c;n["X-Nova-Signature"]=this.hmac(this.encode(h),this.encode(this.secret))}return{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"code");if(c!=="A10000"){const u=this.safeString(a,"message"),h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,h),this.throwBroadlyMatchedException(this.exceptions.broad,u,h),new oh(h)}}};const H9=ge,{ExchangeError:G9,AuthenticationError:Hc,ArgumentsRequired:Yv,BadRequest:Gc,InvalidOrder:U9,InsufficientFunds:$9,OrderNotFound:eg,PermissionDenied:Qv}=de,{TICK_SIZE:j9}=me;var W9=class extends H9{describe(){return this.deepExtend(super.describe(),{id:"oceanex",name:"OceanEx",countries:["BS"],version:"v1",rateLimit:3e3,urls:{logo:"https://user-images.githubusercontent.com/1294454/58385970-794e2d80-8001-11e9-889c-0567cd79b78e.jpg",api:{rest:"https://api.oceanex.pro"},www:"https://www.oceanex.pro.com",doc:"https://api.oceanex.pro/doc/v1",referral:"https://oceanex.pro/signup?referral=VE24QX"},has:{CORS:void 0,spot:!0,margin:!1,swap:void 0,future:void 0,option:void 0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createMarketOrder:!0,createOrder:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchMarkets:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!0,fetchOrders:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTradingLimits:void 0,fetchTransactionFees:void 0},timeframes:{"1m":"1","5m":"5","15m":"15","30m":"30","1h":"60","2h":"120","4h":"240","6h":"360","12h":"720","1d":"1440","3d":"4320","1w":"10080"},api:{public:{get:["markets","tickers/{pair}","tickers_multi","order_book","order_book/multi","fees/trading","trades","timestamp"],post:["k"]},private:{get:["key","members/me","orders","orders/filter"],post:["orders","orders/multi","order/delete","order/delete/multi","orders/clear"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")}},commonCurrencies:{PLA:"Plair"},precisionMode:j9,exceptions:{codes:{"-1":Gc,"-2":Gc,1001:Gc,1004:Yv,1006:Hc,1008:Hc,1010:Hc,1011:Qv,2001:Hc,2002:U9,2004:eg,9003:Qv},exact:{"market does not have a valid value":Gc,"side does not have a valid value":Gc,"Account::AccountError: Cannot lock funds":$9,"The account does not exist":Hc}}})}async fetchMarkets(e={}){const t={show_details:!0},s=await this.publicGetMarkets(this.extend(t,e)),i=[],n=this.safeValue(s,"data",[]);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeValue(a,"id"),d=this.safeValue(a,"name");let[c,u]=d.split("/");const h=this.safeCurrencyCode(c),l=this.safeCurrencyCode(u);c=c.toLowerCase(),u=u.toLowerCase();const p=h+"/"+l;i.push({id:o,symbol:p,base:h,quote:l,settle:void 0,baseId:c,quoteId:u,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(a,"amount_precision"))),price:this.parseNumber(this.parsePrecision(this.safeString(a,"price_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(a,"minimum_trading_amount"),max:void 0}},info:a})}return i}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetTickersPair(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e),e===void 0&&(e=this.symbols);const i={markets:this.marketIds(e)},n=await this.publicGetTickersMulti(this.extend(i,t)),r=this.safeValue(n,"data",[]),a={};for(let o=0;o<r.length;o++){const d=r[o],c=this.safeString(d,"market"),u=this.safeMarket(c),h=u.symbol;a[h]=this.parseTicker(d,u)}return this.filterByArray(a,"symbol",e)}parseTicker(e,t=void 0){const s=this.safeValue(e,"ticker",{}),i=this.safeTimestamp(e,"at"),n=this.safeSymbol(void 0,t);return this.safeTicker({symbol:n,timestamp:i,datetime:this.iso8601(i),high:this.safeString(s,"high"),low:this.safeString(s,"low"),bid:this.safeString(s,"buy"),bidVolume:void 0,ask:this.safeString(s,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:this.safeString(s,"last"),last:this.safeString(s,"last"),previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(s,"volume"),quoteVolume:void 0,info:s},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={market:this.market(e).id};t!==void 0&&(n.limit=t);const r=await this.publicGetOrderBook(this.extend(n,s)),a=this.safeValue(r,"data",{}),o=this.safeTimestamp(a,"timestamp");return this.parseOrderBook(a,e,o)}async fetchOrderBooks(e=void 0,t=void 0,s={}){await this.loadMarkets(),e===void 0&&(e=this.symbols);const n={markets:this.marketIds(e)};t!==void 0&&(n.limit=t);const r=await this.publicGetOrderBookMulti(this.extend(n,s)),a=this.safeValue(r,"data",[]),o={};for(let d=0;d<a.length;d++){const c=a[d],u=this.safeString(c,"market"),h=this.safeSymbol(u),l=this.safeTimestamp(c,"timestamp");o[h]=this.parseOrderBook(c,h,l)}return o}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetTrades(this.extend(r,i)),o=this.safeValue(a,"data");return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){let s=this.safeValue(e,"side");s==="bid"?s="buy":s==="ask"&&(s="sell");const i=this.safeValue(e,"market"),n=this.safeSymbol(i,t);let r=this.safeTimestamp(e,"created_on");r===void 0&&(r=this.parse8601(this.safeString(e,"created_at")));const a=this.safeString(e,"price"),o=this.safeString(e,"volume");return this.safeTrade({info:e,timestamp:r,datetime:this.iso8601(r),symbol:n,id:this.safeString(e,"id"),order:void 0,type:"limit",takerOrMaker:void 0,side:s,price:a,amount:o,cost:void 0,fee:void 0},t)}async fetchTime(e={}){const t=await this.publicGetTimestamp(e);return this.safeTimestamp(t,"data")}async fetchTradingFees(e={}){const t=await this.publicGetFeesTrading(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeValue(r,"ask_fee",{}),o=this.safeValue(r,"bid_fee",{}),d=this.safeString(r,"market"),c=this.safeSymbol(d);i[c]={info:r,symbol:c,maker:this.safeNumber(a,"value"),taker:this.safeNumber(o,"value"),percentage:!0}}return i}async fetchKey(e={}){const t=await this.privateGetKey(e);return this.safeValue(t,"data")}parseBalance(e){const t=this.safeValue(e,"data"),s=this.safeValue(t,"accounts",[]),i={info:e};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeValue(r,"currency"),o=this.safeCurrencyCode(a),d=this.account();d.free=this.safeString(r,"balance"),d.used=this.safeString(r,"locked"),i[o]=d}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetMembersMe(e);return this.parseBalance(t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={market:a.id,side:s,ord_type:t,volume:this.amountToPrecision(e,i)};t==="limit"&&(o.price=this.priceToPrecision(e,n));const d=await this.privatePostOrders(this.extend(o,r)),c=this.safeValue(d,"data");return this.parseOrder(c,a)}async fetchOrder(e,t=void 0,s={}){let i=e;Array.isArray(e)||(i=[e]),await this.loadMarkets();let n;t!==void 0&&(n=this.market(t));const r={ids:i},a=await this.privateGetOrders(this.extend(r,s)),o=this.safeValue(a,"data"),d=o.length;if(o===void 0)throw new eg(this.id+" could not found matching order");if(Array.isArray(e))return this.parseOrders(o,n);if(d===0)throw new eg(this.id+" could not found matching order");return this.parseOrder(o[0],n)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={states:["wait"]};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={states:["done","cancel"]};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Yv(this.id+" fetchOrders() requires a `symbol` argument");await this.loadMarkets();const n=this.market(e),r=this.safeValue(i,"states",["wait","done","cancel"]),a=this.omit(i,"states"),o={market:n.id,states:r,need_price:"True"};s!==void 0&&(o.limit=s);const d=await this.privateGetOrdersFilter(this.extend(o,a)),c=this.safeValue(d,"data",[]);let u=[];for(let h=0;h<c.length;h++){const l=this.safeValue(c[h],"orders",[]),p=this.parseOrderStatus(this.safeValue(c[h],"state")),m=this.parseOrders(l,n,t,s,{status:p});u=this.arrayConcat(u,m)}return u}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={market:r.id,period:this.timeframes[t]};s!==void 0&&(a.timestamp=s),i!==void 0&&(a.limit=i);const o=await this.publicPostK(this.extend(a,n)),d=this.safeValue(o,"data",[]);return this.parseOHLCVs(d,r,t,s,i)}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeValue(e,"state")),i=this.safeString2(e,"market","market_id"),n=this.safeSymbol(i,t);let r=this.safeTimestamp(e,"created_on");r===void 0&&(r=this.parse8601(this.safeString(e,"created_at")));const a=this.safeString(e,"price"),o=this.safeString(e,"avg_price"),d=this.safeString(e,"volume"),c=this.safeString(e,"remaining_volume"),u=this.safeString(e,"executed_volume");return this.safeOrder({info:e,id:this.safeString(e,"id"),clientOrderId:void 0,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,symbol:n,type:this.safeValue(e,"ord_type"),timeInForce:void 0,postOnly:void 0,side:this.safeValue(e,"side"),price:a,stopPrice:void 0,average:o,amount:d,remaining:c,filled:u,status:s,cost:void 0,trades:void 0,fee:void 0},t)}parseOrderStatus(e){const t={wait:"open",done:"closed",cancel:"canceled"};return this.safeString(t,e,e)}async createOrders(e,t,s={}){await this.loadMarkets();const n={market:this.market(e).id,orders:t},a=(await this.privatePostOrdersMulti(this.extend(n,s))).data;return this.parseOrders(a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=await this.privatePostOrderDelete(this.extend({id:e},s)),n=this.safeValue(i,"data");return this.parseOrder(n)}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i=await this.privatePostOrderDeleteMulti(this.extend({ids:e},s)),n=this.safeValue(i,"data");return this.parseOrders(n)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s=await this.privatePostOrdersClear(t),i=this.safeValue(s,"data");return this.parseOrders(i)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="public")if(e==="tickers_multi"||e==="order_book/multi"){let d="?";const c=this.safeValue(i,"markets");for(let h=0;h<c.length;h++)d+="markets[]="+c[h]+"&";const u=this.safeValue(i,"limit");u!==void 0&&(d+="limit="+u),a+=d}else Object.keys(o).length&&(a+="?"+this.urlencode(o));else if(t==="private"){this.checkRequiredCredentials();const d={uid:this.apiKey,data:o},c=this.jwt(d,this.encode(this.secret),"RS256");a+="?user_jwt="+c}return n={"Content-Type":"application/json"},{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"code"),u=this.safeString(a,"message");if(c!==void 0&&c!=="0"){const h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.codes,c,h),this.throwExactlyMatchedException(this.exceptions.exact,u,h),new G9(h)}}};const z9=ge,{ExchangeError:oe,ExchangeNotAvailable:Wo,OnMaintenance:K9,ArgumentsRequired:hi,BadRequest:ls,AccountSuspended:dh,InvalidAddress:tg,PermissionDenied:Is,DDoSProtection:Zv,InsufficientFunds:Cn,InvalidNonce:X9,CancelPending:Y9,InvalidOrder:xe,OrderNotFound:sg,AuthenticationError:Ci,RequestTimeout:Jv,NotSupported:Qa,BadSymbol:eT,RateLimitExceeded:tT}=de,{TICK_SIZE:Q9}=me,Lt=Se;var sC=class extends z9{describe(){return this.deepExtend(super.describe(),{id:"okcoin",name:"OKCoin",countries:["CN","US"],version:"v3",rateLimit:20,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:void 0,future:!0,option:void 0,cancelOrder:!0,createOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchLedger:!0,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:void 0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositions:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTransactions:void 0,fetchWithdrawals:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"60","3m":"180","5m":"300","15m":"900","30m":"1800","1h":"3600","2h":"7200","4h":"14400","6h":"21600","12h":"43200","1d":"86400","1w":"604800","1M":"2678400","3M":"8035200","6M":"16070400","1y":"31536000"},hostname:"okcoin.com",urls:{logo:"https://user-images.githubusercontent.com/51840849/87295551-102fbf00-c50e-11ea-90a9-462eebba5829.jpg",api:{rest:"https://www.{hostname}"},www:"https://www.okcoin.com",doc:"https://www.okcoin.com/docs/en/",fees:"https://www.okcoin.com/coin-fees",referral:"https://www.okcoin.com/account/register?flag=activity&channelId=600001513",test:{rest:"https://testnet.okex.com"}},api:{general:{get:{time:8.3334}},account:{get:{wallet:8.3334,"sub-account":1e3,"asset-valuation":1e3,"wallet/{currency}":8.3334,"withdrawal/history":8.3334,"withdrawal/history/{currency}":8.3334,ledger:5,"deposit/address":8.3334,"deposit/history":8.3334,"deposit/history/{currency}":8.3334,currencies:8.3334,"withdrawal/fee":8.3334,"deposit-lightning":50,"withdrawal-lightning":50,"fiat/deposit/detail":5,"fiat/deposit/details":8.3334,"fiat/withdraw/detail":5,"fiat/withdraw/details":8.3334,"fiat/channel":8.3334},post:{transfer:100,withdrawal:8.3334,"fiat/cancel_deposit":1,"fiat/deposit":8.3334,"fiat/withdraw":8.3334,"fiat/cancel_withdrawal":1}},otc:{get:{"rfq/instruments":50,"rfq/trade":50,"rfq/history":50},post:{"rfq/quote":50,"rfq/trade":50}},users:{get:{"subaccount-info":20,"account-info":20,"subaccount/apikey":20},post:{"create-subaccount":5,"delete-subaccount":5,"subaccount/apikey":50,"subacount/delete-apikey":20,"subacount/modify-apikey":20}},earning:{get:{offers:5,orders:5,positions:8.3334},post:{purchase:5,redeem:5,cancel:5}},spot:{get:{accounts:5,"accounts/{currency}":5,"accounts/{currency}/ledger":5,orders:10,orders_pending:5,"orders/{order_id}":5,"orders/{client_oid}":5,trade_fee:5,fills:10,algo:5,instruments:5,"instruments/{instrument_id}/book":5,"instruments/ticker":5,"instruments/{instrument_id}/ticker":5,"instruments/{instrument_id}/trades":5,"instruments/{instrument_id}/candles":5},post:{order_algo:2.5,orders:1,batch_orders:2,"cancel_orders/{order_id}":1,"cancel_orders/{client_oid}":1,cancel_batch_algos:5,cancel_batch_orders:5,"amend_order/{instrument_id}":2.5,amend_batch_orders:5}},margin:{get:{accounts:5,"accounts/{instrument_id}":5,"accounts/{instrument_id}/ledger":5,"accounts/availability":5,"accounts/{instrument_id}/availability":5,"accounts/borrowed":5,"accounts/{instrument_id}/borrowed":5,orders:10,"accounts/{instrument_id}/leverage":1,"orders/{order_id}":5,"orders/{client_oid}":5,orders_pending:5,fills:10,"instruments/{instrument_id}/mark_price":5},post:{"accounts/borrow":1,"accounts/repayment":1,orders:1,batch_orders:2,cancel_orders:1,"cancel_orders/{order_id}":1,"cancel_orders/{client_oid}":1,cancel_batch_orders:2,"amend_order/{instrument_id}":2.5,amend_batch_orders:5,"accounts/{instrument_id}/leverage":1}},system:{get:{status:250}},market:{get:{oracle:250}},futures:{get:["position","{instrument_id}/position","accounts","accounts/{underlying}","accounts/{underlying}/leverage","accounts/{underlying}/ledger","order_algo/{instrument_id}","orders/{instrument_id}","orders/{instrument_id}/{order_id}","orders/{instrument_id}/{client_oid}","fills","trade_fee","accounts/{instrument_id}/holds","order_algo/{instrument_id}","instruments","instruments/{instrument_id}/book","instruments/ticker","instruments/{instrument_id}/ticker","instruments/{instrument_id}/trades","instruments/{instrument_id}/candles","instruments/{instrument_id}/history/candles","instruments/{instrument_id}/index","rate","instruments/{instrument_id}/estimated_price","instruments/{instrument_id}/open_interest","instruments/{instrument_id}/price_limit","instruments/{instrument_id}/mark_price","instruments/{instrument_id}/liquidation"],post:["accounts/{underlying}/leverage","order","amend_order/{instrument_id}","orders","cancel_order/{instrument_id}/{order_id}","cancel_order/{instrument_id}/{client_oid}","cancel_batch_orders/{instrument_id}","accounts/margin_mode","close_position","cancel_all","order_algo","cancel_algos"]},swap:{get:["position","{instrument_id}/position","accounts","{instrument_id}/accounts","accounts/{instrument_id}/settings","accounts/{instrument_id}/ledger","orders/{instrument_id}","orders/{instrument_id}/{order_id}","orders/{instrument_id}/{client_oid}","fills","accounts/{instrument_id}/holds","trade_fee","order_algo/{instrument_id}","instruments","instruments/{instrument_id}/depth","instruments/ticker","instruments/{instrument_id}/ticker","instruments/{instrument_id}/trades","instruments/{instrument_id}/candles","instruments/{instrument_id}/history/candles","instruments/{instrument_id}/index","rate","instruments/{instrument_id}/open_interest","instruments/{instrument_id}/price_limit","instruments/{instrument_id}/liquidation","instruments/{instrument_id}/funding_time","instruments/{instrument_id}/mark_price","instruments/{instrument_id}/historical_funding_rate"],post:["accounts/{instrument_id}/leverage","order","amend_order/{instrument_id}","orders","cancel_order/{instrument_id}/{order_id}","cancel_order/{instrument_id}/{client_oid}","cancel_batch_orders/{instrument_id}","order_algo","cancel_algos","close_position","cancel_all","order_algo","cancel_algos"]},option:{get:["accounts","position","{underlying}/position","accounts/{underlying}","orders/{underlying}","fills/{underlying}","accounts/{underlying}/ledger","trade_fee","orders/{underlying}/{order_id}","orders/{underlying}/{client_oid}","underlying","instruments/{underlying}","instruments/{underlying}/summary","instruments/{underlying}/summary/{instrument_id}","instruments/{instrument_id}/book","instruments/{instrument_id}/trades","instruments/{instrument_id}/ticker","instruments/{instrument_id}/candles"],post:["order","orders","cancel_order/{underlying}/{order_id}","cancel_order/{underlying}/{client_oid}","cancel_batch_orders/{underlying}","amend_order/{underlying}","amend_batch_orders/{underlying}"]},information:{get:["{currency}/long_short_ratio","{currency}/volume","{currency}/taker","{currency}/sentiment","{currency}/margin"]},index:{get:["{instrument_id}/constituents"]}},fees:{trading:{taker:.002,maker:.001},spot:{taker:.0015,maker:.001}},requiredCredentials:{apiKey:!0,secret:!0,password:!0},exceptions:{exact:{1:oe,"failure to get a peer from the ring-balancer":Wo,"Server is busy, please try again.":Wo,"An unexpected error occurred":oe,"System error":oe,4010:Is,4001:oe,4002:oe,30001:Ci,30002:Ci,30003:Ci,30004:Ci,30005:X9,30006:Ci,30007:ls,30008:Jv,30009:oe,30010:Ci,30011:Is,30012:Ci,30013:Ci,30014:Zv,30015:Ci,30016:oe,30017:oe,30018:oe,30019:Wo,30020:ls,30021:ls,30022:Is,30023:ls,30024:eT,30025:ls,30026:Zv,30027:Ci,30028:Is,30029:dh,30030:Wo,30031:ls,30032:eT,30033:ls,30034:oe,30035:oe,30036:oe,30037:Wo,30038:K9,30044:Jv,32001:dh,32002:Is,32003:Y9,32004:oe,32005:xe,32006:xe,32007:xe,32008:xe,32009:xe,32010:oe,32011:oe,32012:oe,32013:oe,32014:oe,32015:oe,32016:oe,32017:oe,32018:oe,32019:oe,32020:oe,32021:oe,32022:oe,32023:oe,32024:oe,32025:oe,32026:oe,32027:oe,32028:oe,32029:oe,32030:xe,32031:hi,32038:Ci,32040:oe,32044:oe,32045:oe,32046:oe,32047:oe,32048:xe,32049:oe,32050:xe,32051:xe,32052:oe,32053:oe,32057:oe,32054:oe,32055:xe,32056:oe,32058:oe,32059:xe,32060:xe,32061:xe,32062:xe,32063:xe,32064:oe,32065:oe,32066:oe,32067:oe,32068:oe,32069:oe,32070:oe,32071:oe,32072:oe,32073:oe,32074:oe,32075:oe,32076:oe,32077:oe,32078:oe,32079:oe,32080:oe,32083:oe,33001:Is,33002:dh,33003:Cn,33004:oe,33005:oe,33006:oe,33007:oe,33008:Cn,33009:oe,33010:oe,33011:oe,33012:oe,33013:xe,33014:sg,33015:xe,33016:oe,33017:Cn,33018:oe,33020:oe,33021:ls,33022:xe,33023:oe,33024:xe,33025:xe,33026:oe,33027:xe,33028:xe,33029:xe,33034:oe,33035:oe,33036:oe,33037:oe,33038:oe,33039:oe,33040:oe,33041:oe,33042:oe,33043:oe,33044:oe,33045:oe,33046:oe,33047:oe,33048:oe,33049:oe,33050:oe,33051:oe,33059:ls,33060:ls,33061:oe,33062:oe,33063:oe,33064:oe,33065:oe,33085:xe,21009:oe,34001:Is,34002:tg,34003:oe,34004:oe,34005:oe,34006:oe,34007:oe,34008:Cn,34009:oe,34010:oe,34011:oe,34012:oe,34013:oe,34014:oe,34015:oe,34016:Is,34017:dh,34018:Ci,34019:Is,34020:Is,34021:tg,34022:oe,34023:Is,34026:tT,34036:oe,34037:oe,34038:oe,34039:oe,35001:oe,35002:oe,35003:oe,35004:oe,35005:Ci,35008:xe,35010:xe,35012:xe,35014:xe,35015:xe,35017:oe,35019:xe,35020:xe,35021:xe,35022:ls,35024:ls,35025:Cn,35026:ls,35029:sg,35030:xe,35031:xe,35032:oe,35037:oe,35039:Cn,35040:xe,35044:oe,35046:Cn,35047:Cn,35048:oe,35049:xe,35050:xe,35052:Cn,35053:oe,35055:Cn,35057:oe,35058:oe,35059:ls,35060:ls,35061:ls,35062:xe,35063:xe,35064:xe,35066:xe,35067:xe,35068:xe,35069:xe,35070:xe,35071:xe,35072:xe,35073:xe,35074:xe,35075:xe,35076:xe,35077:xe,35078:xe,35079:xe,35080:xe,35081:xe,35082:xe,35083:xe,35084:xe,35085:xe,35086:xe,35087:xe,35088:xe,35089:xe,35090:oe,35091:oe,35092:oe,35093:oe,35094:oe,35095:ls,35096:oe,35097:oe,35098:oe,35099:oe,35102:tT,36001:ls,36002:ls,36005:oe,36101:Ci,36102:Is,36103:Is,36104:Is,36105:Is,36106:Is,36107:Is,36108:Cn,36109:Is,36201:Is,36202:Is,36203:xe,36204:oe,36205:ls,36206:ls,36207:xe,36208:xe,36209:xe,36210:xe,36211:xe,36212:xe,36213:xe,36214:oe,36216:sg,36217:xe,36218:xe,36219:xe,36220:xe,36221:xe,36222:xe,36223:xe,36224:xe,36225:xe,36226:xe,36227:xe,36228:xe,36229:xe,36230:xe},broad:{}},precisionMode:Q9,options:{fetchOHLCV:{type:"Candles"},createMarketBuyOrderRequiresPrice:!0,fetchMarkets:["spot"],defaultType:"spot",accountsByType:{spot:"1",funding:"6",main:"6"},accountsById:{1:"spot",6:"funding"},auth:{time:"public",currencies:"private",instruments:"public",rate:"public","{instrument_id}/constituents":"public"},warnOnFetchCurrenciesWithoutAuthorization:!1},commonCurrencies:{AE:"AET",BOX:"DefiBox",HOT:"Hydro Protocol",HSR:"HC",MAG:"Maggie",SBTC:"Super Bitcoin",TRADE:"Unitrade",YOYO:"YOYOW",WIN:"WinToken"}})}async fetchTime(e={}){const t=await this.generalGetTime(e);return this.parse8601(this.safeString(t,"iso"))}async fetchMarkets(e={}){const t=this.safeValue(this.options,"fetchMarkets");let s=[];for(let i=0;i<t.length;i++){const n=await this.fetchMarketsByType(t[i],e);s=this.arrayConcat(s,n)}return s}parseMarkets(e){const t=[];for(let s=0;s<e.length;s++)t.push(this.parseMarket(e[s]));return t}parseMarket(e){const t=this.safeString(e,"instrument_id");let s=this.safeValue(e,"option_type");const i=this.safeNumber(e,"contract_val"),n=i!==void 0,r=this.safeString(e,"alias");let a="spot";const o=!n,d=s!==void 0,c=!d&&r!==void 0,u=n&&!c&&!d;let h=this.safeString(e,"base_currency"),l=this.safeString(e,"quote_currency");const p=this.safeString(e,"settlement_currency");if(d){const q=this.safeString(e,"underlying").split("-");h=this.safeString(q,0),l=this.safeString(q,1),a="option"}else c?(h=this.safeString(e,"underlying_index"),a="futures"):u&&(a="swap");const m=this.safeCurrencyCode(h),g=this.safeCurrencyCode(l),y=this.safeCurrencyCode(p);let b=m+"/"+g,w=this.safeString(e,"delivery"),k;const T=this.safeValue(e,"strike");n&&(b=b+":"+y,(c||d)&&(c&&(w+="T00:00:00Z"),k=this.parse8601(w),b=b+"-"+this.yymmdd(k),d&&(b=b+":"+T+":"+s,s=s==="C"?"call":"put")));const O=this.safeNumber2(e,"lot_size","trade_increment"),x=this.safeString(e,"tick_size"),C=this.safeString2(e,"min_size","base_min_size"),E=this.parseNumber(C);let P;E!==void 0&&x!==void 0&&(P=this.parseNumber(Lt.stringMul(x,C)));const _=this.safeValue2(this.fees,a,"trading",{}),S=this.safeString(e,"max_leverage","1"),I=this.parseNumber(Lt.stringMax(S,"1")),v=this.parseNumber(x);return this.extend(_,{id:t,symbol:b,base:m,quote:g,settle:y,baseId:h,quoteId:l,settleId:p,type:a,spot:o,margin:!1,swap:u,future:c,futures:c,option:d,active:!0,contract:n,linear:n?g===y:void 0,inverse:n?m===y:void 0,contractSize:i,expiry:k,expiryDatetime:this.iso8601(k),strike:T,optionType:s,precision:{amount:this.safeNumber(e,"size_increment",O),price:v},limits:{leverage:{min:this.parseNumber("1"),max:this.parseNumber(I)},amount:{min:E,max:void 0},price:{min:v,max:void 0},cost:{min:P,max:void 0}},info:e})}async fetchMarketsByType(e,t={}){if(e==="option"){const s=await this.optionGetUnderlying(t);let i=[];for(let n=0;n<s.length;n++){const r=await this.optionGetInstrumentsUnderlying({underlying:s[n]});i=this.arrayConcat(i,r)}return this.parseMarkets(i)}else if(e==="spot"||e==="futures"||e==="swap"){const s=e+"GetInstruments",i=await this[s](t);return this.parseMarkets(i)}else throw new Qa(this.id+" fetchMarketsByType() does not support market type "+e)}async fetchCurrencies(e={}){if(this.checkRequiredCredentials(!1)){const t=await this.accountGetCurrencies(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.safeString(n,"name"),d=this.safeInteger(n,"can_deposit"),c=this.safeInteger(n,"can_withdraw"),u=d===1,h=c===1,l=!!(d&&c);s[a]={id:r,code:a,info:n,type:void 0,name:o,active:l,deposit:u,withdraw:h,fee:void 0,precision:this.parseNumber("0.00000001"),limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.safeNumber(n,"min_withdrawal"),max:void 0}}}}return s}else{if(this.options.warnOnFetchCurrenciesWithoutAuthorization)throw new oe(this.id+' fetchCurrencies() is a private API endpoint that requires authentication with API keys. Set the API keys on the exchange instance or exchange.options["warnOnFetchCurrenciesWithoutAuthorization"] = false to suppress this warning message.');return}}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);let n=i.type+"GetInstrumentsInstrumentId";n+=i.type==="swap"?"Depth":"Book";const r={instrument_id:i.id};t!==void 0&&(r.size=t);const a=await this[n](this.extend(r,s)),o=this.parse8601(this.safeString2(a,"timestamp","time"));return this.parseOrderBook(a,e,o)}parseTicker(e,t=void 0){const s=this.parse8601(this.safeString(e,"timestamp")),i=this.safeString(e,"instrument_id");t=this.safeMarket(i,t,"-");const n=t.symbol,r=this.safeString(e,"last"),a=this.safeString(e,"open_24h");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high_24h"),low:this.safeString(e,"low_24h"),bid:this.safeString(e,"best_bid"),bidVolume:this.safeString(e,"best_bid_size"),ask:this.safeString(e,"best_ask"),askVolume:this.safeString(e,"best_ask_size"),vwap:void 0,open:a,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"base_volume_24h"),quoteVolume:this.safeString(e,"quote_volume_24h"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=s.type+"GetInstrumentsInstrumentIdTicker",n={instrument_id:s.id},r=await this[i](this.extend(n,t));return this.parseTicker(r)}async fetchTickersByType(e,t=void 0,s={}){await this.loadMarkets(),t=this.marketSymbols(t);const i=e+"GetInstrumentsTicker",n=await this[i](s),r={};for(let a=0;a<n.length;a++){const o=this.parseTicker(n[a]),d=o.symbol;r[d]=o}return this.filterByArray(r,"symbol",t)}async fetchTickers(e=void 0,t={}){e=this.marketSymbols(e);const s=this.safeString(e,0);let i;s!==void 0&&(i=this.market(s));let n;return[n,t]=this.handleMarketTypeAndParams("fetchTickers",i,t),await this.fetchTickersByType(n,e,this.omit(t,"type"))}parseTrade(e,t=void 0){const s=this.safeString(e,"instrument_id");t=this.safeMarket(s,t,"-");const i=t.symbol,n=this.parse8601(this.safeString2(e,"timestamp","created_at")),r=this.safeString(e,"price");let a=this.safeString2(e,"size","qty");a=this.safeString(e,"order_qty",a);let o=this.safeString2(e,"exec_type","liquidity");o==="M"?o="maker":o==="T"&&(o="taker");const d=this.safeString(e,"side"),c=this.safeString(e,"fee");let u;if(c!==void 0){const l=d==="buy"?t.base:t.quote;u={cost:Lt.stringNeg(c),currency:l}}const h=this.safeString(e,"order_id");return this.safeTrade({info:e,timestamp:n,datetime:this.iso8601(n),symbol:i,id:this.safeString2(e,"trade_id","ledger_id"),order:h,type:void 0,takerOrMaker:o,side:d,price:r,amount:a,cost:void 0,fee:u},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r=n.type+"GetInstrumentsInstrumentIdTrades";(s===void 0||s>100)&&(s=100);const a={instrument_id:n.id,limit:s},o=await this[r](this.extend(a,i));return this.parseTrades(o,n,t,s)}parseOHLCV(e,t=void 0){if(Array.isArray(e)){const i=e.length>6?6:5;let n=this.safeValue(e,0);return typeof n=="string"&&(n=this.parse8601(n)),[n,this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,i)]}else return[this.parse8601(this.safeString(e,"time")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.parseTimeframe(t),o={instrument_id:r.id,granularity:this.timeframes[t]},d=this.safeValue(this.options,"fetchOHLCV",{}),c=this.safeString(d,"type","Candles"),u=this.safeString(n,"type",c);n=this.omit(n,"type");const h=r.type+"GetInstrumentsInstrumentId"+u;if(u==="Candles"){if(s!==void 0)i!==void 0&&(o.end=this.iso8601(this.sum(s,i*a*1e3))),o.start=this.iso8601(s);else if(i!==void 0){const p=this.milliseconds();o.start=this.iso8601(p-i*a*1e3),o.end=this.iso8601(p)}}else if(u==="HistoryCandles"){if(r.option)throw new Qa(this.id+" fetchOHLCV() does not have "+u+" for "+r.type+" markets");if(s!==void 0)i===void 0&&(i=300),o.start=this.iso8601(this.sum(s,i*a*1e3)),o.end=this.iso8601(s);else if(i!==void 0){const p=this.milliseconds();o.end=this.iso8601(p-i*a*1e3),o.start=this.iso8601(p)}}const l=await this[h](this.extend(o,n));return this.parseOHLCVs(l,r,t,s,i)}parseAccountBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.total=this.safeString(i,"balance"),a.used=this.safeString(i,"hold"),a.free=this.safeString(i,"available"),t[r]=a}return this.safeBalance(t)}parseFuturesBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"info",{}),i=Object.keys(s);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeCurrencyCode(r),o=this.safeValue(s,r,{}),d=this.account(),c=this.safeString(o,"total_avail_balance");if(this.safeString(o,"margin_mode")==="fixed"){const u=this.safeValue(o,"contracts",[]);let h=c;for(let l=0;l<u.length;l++){const p=u[l],m=this.safeString(p,"fixed_balance"),g=this.safeString(p,"realized_pnl"),y=this.safeString(p,"margin_frozen"),b=this.safeString(p,"margin_for_unfilled"),w=Lt.stringSub(Lt.stringSub(Lt.stringAdd(m,g),y),b);h=Lt.stringAdd(h,w)}d.free=h}else{const u=this.safeString(o,"realized_pnl"),h=this.safeString(o,"unrealized_pnl"),l=this.safeString(o,"margin_frozen"),p=this.safeString(o,"margin_for_unfilled"),m=Lt.stringAdd(Lt.stringAdd(c,u),h);d.free=Lt.stringSub(Lt.stringSub(m,l),p)}d.total=this.safeString(o,"equity"),t[a]=d}return this.safeBalance(t)}parseSwapBalance(e){const t={info:e};let s;const i=this.safeValue(e,"info",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"instrument_id"),o=this.safeSymbol(a),d=this.parse8601(this.safeString(r,"timestamp"));s=s===void 0?d:Math.max(s,d);const c=this.account();c.total=this.safeString(r,"equity"),c.free=this.safeString(r,"total_avail_balance"),t[o]=c}return t.timestamp=s,t.datetime=this.iso8601(s),this.safeBalance(t)}async fetchBalance(e={}){const t=this.safeString2(this.options,"fetchBalance","defaultType"),s=this.safeString(e,"type",t);if(s===void 0)throw new hi(this.id+" fetchBalance() requires a type parameter (one of 'account', 'spot', 'futures', 'swap')");await this.loadMarkets();const i=s==="account"?"Wallet":"Accounts",n=s+"Get"+i,r=this.omit(e,"type"),a=await this[n](r);return this.parseBalanceByType(s,a)}parseBalanceByType(e,t){if(e==="account"||e==="spot")return this.parseAccountBalance(t);if(e==="futures")return this.parseFuturesBalance(t);if(e==="swap")return this.parseSwapBalance(t);throw new Qa(this.id+" fetchBalance does not support the '"+e+"' type (the type must be one of 'account', 'spot', 'futures', 'swap')")}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o={instrument_id:a.id};const d=this.safeString2(r,"client_oid","clientOrderId");d!==void 0&&(o.client_oid=d,r=this.omit(r,["client_oid","clientOrderId"]));let c;if(a.futures||a.swap){const l=a.futures?this.numberToString(i):this.amountToPrecision(e,i);o=this.extend(o,{type:t,size:l});const p=this.safeString(r,"order_type");t==="market"||p==="4"?o.order_type="4":o.price=this.priceToPrecision(e,n),a.futures&&(o.leverage="10"),c=a.type+"PostOrder"}else{if(o=this.extend(o,{side:s,type:t}),t==="limit")o.price=this.priceToPrecision(e,n),o.size=this.amountToPrecision(e,i);else if(t==="market")if(s==="buy"){let l=this.safeNumber(r,"notional");if(this.safeValue(this.options,"createMarketBuyOrderRequiresPrice",!0)){if(n!==void 0)l===void 0&&(l=i*n);else if(l===void 0)throw new xe(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total cost value in the 'amount' argument or in the 'notional' extra parameter (the exchange-specific behaviour)")}else l=l===void 0?i:l;o.notional=this.costToPrecision(e,l)}else o.size=this.amountToPrecision(e,i);c="spotPostOrders"}const u=await this[c](this.extend(o,r)),h=this.parseOrder(u,a);return this.extend(h,{type:t,side:s})}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new hi(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t);let n;if(i.futures||i.swap)n=i.type;else{const h=this.safeString2(this.options,"cancelOrder","defaultType",i.type);n=this.safeString(s,"type",h)}if(n===void 0)throw new hi(this.id+" cancelOrder() requires a type parameter (one of 'spot', 'futures', 'swap').");let r=n+"PostCancelOrder";const a={instrument_id:i.id};i.futures||i.swap?r+="InstrumentId":r+="s";const o=this.safeString2(s,"client_oid","clientOrderId");o!==void 0?(r+="ClientOid",a.client_oid=o):(r+="OrderId",a.order_id=e);const d=this.omit(s,["type","client_oid","clientOrderId"]),c=await this[r](this.extend(a,d)),u="result"in c?c:this.safeValue(c,i.id,{});return this.parseOrder(u,i)}parseOrderStatus(e){const t={"-2":"failed","-1":"canceled",0:"open",1:"open",2:"closed",3:"open",4:"canceled"};return this.safeString(t,e,e)}parseOrderSide(e){const t={1:"buy",2:"sell",3:"sell",4:"buy"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"order_id"),i=this.parse8601(this.safeString(e,"timestamp"));let n=this.safeString(e,"side");const r=this.safeString(e,"type");n!=="buy"&&n!=="sell"&&(n=this.parseOrderSide(r));const a=this.safeString(e,"instrument_id");t=this.safeMarket(a,t);let o=this.safeString(e,"size");const d=this.safeString2(e,"filled_size","filled_qty");let c;o!==void 0&&d!==void 0&&(o=Lt.stringMax(o,d),c=Lt.stringMax("0",Lt.stringSub(o,d))),r==="market"&&(c="0");let u=this.safeString2(e,"filled_notional","funds");const h=this.safeString(e,"price");let l=this.safeString(e,"price_avg");u===void 0?d!==void 0&&l!==void 0&&(u=Lt.stringMul(l,d)):l===void 0&&d!==void 0&&Lt.stringGt(d,"0")&&(l=Lt.stringDiv(u,d));const p=this.parseOrderStatus(this.safeString(e,"state")),m=this.safeNumber(e,"fee");let g;m!==void 0&&(g={cost:m,currency:void 0});let y=this.safeString(e,"client_oid");y!==void 0&&y.length<1&&(y=void 0);const b=this.safeNumber(e,"trigger_price");return this.safeOrder({info:e,id:s,clientOrderId:y,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,symbol:t.symbol,type:r,timeInForce:void 0,postOnly:void 0,side:n,price:h,stopPrice:b,average:l,cost:u,amount:o,filled:d,remaining:c,status:p,fee:g,trades:void 0},t)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new hi(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=this.safeString2(this.options,"fetchOrder","defaultType",i.type),r=this.safeString(s,"type",n);if(r===void 0)throw new hi(this.id+" fetchOrder() requires a type parameter (one of 'spot', 'futures', 'swap').");const a=i.futures||i.swap?"InstrumentId":"";let o=r+"GetOrders"+a;const d={instrument_id:i.id},c=this.safeString(s,"client_oid");c!==void 0?(o+="ClientOid",d.client_oid=c):(o+="OrderId",d.order_id=e);const u=this.omit(s,"type"),h=await this[o](this.extend(d,u));return this.parseOrder(h)}async fetchOrdersByState(e,t=void 0,s=void 0,i=void 0,n={}){if(t===void 0)throw new hi(this.id+" fetchOrdersByState() requires a symbol argument");await this.loadMarkets();const r=this.market(t);let a;if(r.futures||r.swap)a=r.type;else{const l=this.safeString2(this.options,"fetchOrder","defaultType",r.type);a=this.safeString(n,"type",l)}if(a===void 0)throw new hi(this.id+" fetchOrdersByState() requires a type parameter (one of 'spot', 'futures', 'swap').");const o={instrument_id:r.id,state:e};let d=a+"GetOrders";(r.futures||r.swap)&&(d+="InstrumentId");const c=this.omit(n,"type"),u=await this[d](this.extend(o,c));let h;if(r.swap||r.futures)h=this.safeValue(u,"order_info",[]);else{h=u;const l=u.length;if(l<1)return[];l>1&&this.safeValue(u[1],"before")!==void 0&&(h=u[0])}return this.parseOrders(h,r,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState("6",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState("7",e,t,s,i)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address");let i=this.safeString2(e,"tag","payment_id");i=this.safeString2(e,"memo","Memo",i);const n=this.safeString(e,"currency"),r=this.safeCurrencyCode(n);return this.checkAddress(s),{currency:r,address:s,tag:i,info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=e.split("-"),n={currency:this.currency(s[0]).id},r=await this.accountGetDepositAddress(this.extend(n,t)),a=this.parseDepositAddresses(r),o=this.safeValue(a,e);if(o===void 0)throw new tg(this.id+" fetchDepositAddress() cannot return nonexistent addresses, you should create withdrawal addresses with the exchange website first");return o}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c={amount:this.currencyToPrecision(e,t),currency:r.id,from:o,to:d,type:"0"};o==="main"?(c.type="1",c.sub_account=d,c.to="0"):d==="main"&&(c.type="2",c.sub_account=o,c.from="0",c.to="6");const u=await this.accountPostTransfer(this.extend(c,n));return this.parseTransfer(u,r)}parseTransfer(e,t=void 0){const s=this.safeValue(this.options,"accountsById",{});return{info:e,id:this.safeString(e,"transfer_id"),timestamp:void 0,datetime:void 0,currency:this.safeCurrencyCode(this.safeString(e,"currency"),t),amount:this.safeNumber(e,"amount"),fromAccount:this.safeString(s,this.safeString(e,"from")),toAccount:this.safeString(s,this.safeString(e,"to")),status:this.parseTransferStatus(this.safeString(e,"result"))}}parseTransferStatus(e){const t={true:"ok"};return this.safeString(t,e,"failed")}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e);i&&(s=s+":"+i);const a=this.safeString(n,"fee");if(a===void 0)throw new hi(this.id+" withdraw() requires a 'fee' string parameter, network transaction fee must be \u2265 0. Withdrawals to OKCoin or OKEx are fee-free, please set '0'. Withdrawing to external digital asset address requires network transaction fee.");const o={currency:r.id,to_address:s,destination:"4",amount:this.numberToString(t),fee:a};"password"in n?o.trade_pwd=n.password:"trade_pwd"in n?o.trade_pwd=n.trade_pwd:this.password&&(o.trade_pwd=this.password);const d=this.omit(n,["fee","password","trade_pwd"]);if(!("trade_pwd"in o))throw new oe(this.id+" withdraw() requires this.password set on the exchange instance or a password / trade_pwd parameter");const c=await this.accountPostWithdrawal(this.extend(o,d));return this.parseTransaction(c,r)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r="accountGetDepositHistory",a;e!==void 0&&(a=this.currency(e),n.currency=a.id,r+="Currency");const o=await this[r](this.extend(n,i));return this.parseTransactions(o,a,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r="accountGetWithdrawalHistory",a;e!==void 0&&(a=this.currency(e),n.currency=a.id,r+="Currency");const o=await this[r](this.extend(n,i));return this.parseTransactions(o,a,t,s,i)}parseTransactionStatus(e){const t={"-3":"pending","-2":"canceled","-1":"failed",0:"pending",1:"pending",2:"ok",3:"pending",4:"pending",5:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){let s,i,n;const r=this.safeString(e,"withdrawal_id"),a=this.safeString(e,"from"),o=this.safeString(e,"to"),d=this.safeString(e,"tag");r!==void 0?(s="withdrawal",i=r,n=o):(i=this.safeString2(e,"payment_id","deposit_id"),s="deposit",n=o);const c=this.safeString(e,"currency"),u=this.safeCurrencyCode(c),h=this.safeNumber(e,"amount"),l=this.parseTransactionStatus(this.safeString(e,"status")),p=this.safeString(e,"txid"),m=this.parse8601(this.safeString(e,"timestamp"));let g;if(s==="deposit")g=0;else if(c!==void 0){const y=this.safeString(e,"fee");if(y!==void 0){const b=c.toLowerCase(),w=y.replace(b,"");g=parseFloat(w)}}return{info:e,id:i,currency:u,amount:h,network:void 0,addressFrom:a,addressTo:o,address:n,tagFrom:void 0,tagTo:d,tag:d,status:l,type:s,updated:void 0,txid:p,timestamp:m,datetime:this.iso8601(m),fee:{currency:u,cost:g}}}parseMyTrade(e,t=void 0){const s=this.safeValue(e,1),i=this.safeValue(e,0),n=this.safeString(i,"instrument_id"),r=this.safeString(s,"instrument_id");if(n!==r)throw new Qa(this.id+" parseMyTrade() received unrecognized response format, differing instrument_ids in one fill, the exchange API might have changed, paste your verbose output: https://github.com/ccxt/ccxt/wiki/FAQ#what-is-required-to-get-help");const a=n;t=this.safeMarket(a,t);const o=t.symbol,d=t.quoteId;let c,u,h;const l=this.safeString(s,"currency");let p;l===d?(c=this.safeString(i,"side"),u=this.safeString(i,"size"),h=this.safeString(s,"size"),p=this.safeString(i,"currency")):(c=this.safeString(s,"side"),u=this.safeString(s,"size"),h=this.safeString(i,"size"),p=this.safeString(s,"currency"));const m=this.safeString(s,"trade_id"),g=this.safeString(s,"price"),y=this.safeString(i,"fee"),b=this.safeString(s,"fee"),w=this.safeCurrencyCode(this.safeString(i,"currency")),k=this.safeCurrencyCode(this.safeString(s,"currency"));let T,O;y!==void 0&&!Lt.stringEquals(y,"0")?b!==void 0&&!Lt.stringEquals(b,"0")?O=[{cost:Lt.stringNeg(y),currency:w},{cost:Lt.stringNeg(b),currency:k}]:T={cost:Lt.stringNeg(y),currency:w}:b!==void 0&&!Lt.stringEquals(b,"0")?T={cost:Lt.stringNeg(b),currency:k}:T={cost:"0",currency:this.safeCurrencyCode(p)};const x=this.parse8601(this.safeString2(s,"timestamp","created_at"));let C=this.safeString2(s,"exec_type","liquidity");C==="M"?C="maker":C==="T"&&(C="taker");const E=this.safeString(s,"order_id");return this.safeTrade({info:e,timestamp:x,datetime:this.iso8601(x),symbol:o,id:m,order:E,type:void 0,takerOrMaker:C,side:c,price:g,amount:u,cost:h,fee:T,fees:O},t)}parseMyTrades(e,t=void 0,s=void 0,i=void 0,n={}){const r=this.groupBy(e,"trade_id"),a=Object.keys(r),o=[];for(let d=0;d<a.length;d++){const c=a[d],u=r[c];if(u.length===2){const l=this.parseMyTrade(u);o.push(l)}}return t=this.safeMarket(void 0,t),this.filterBySymbolSinceLimit(o,t.symbol,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new hi(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e);s!==void 0&&s>100&&(s=100);const r={instrument_id:n.id},a=this.safeString2(this.options,"fetchMyTrades","defaultType"),o=this.safeString(i,"type",a),d=this.omit(i,"type"),c=o+"GetFills",u=await this[c](this.extend(r,d));return this.parseMyTrades(u,n,t,s,i)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){const r={order_id:e};return await this.fetchMyTrades(t,s,i,this.extend(r,n))}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e);let i;const n={instrument_id:s.id},r=s.type;if(r==="futures"||r==="swap")i=r+"GetInstrumentIdPosition";else if(r==="option"){if(this.safeString(t,"underlying")===void 0)throw new hi(this.id+" fetchPosition() requires an underlying parameter for "+r+" market "+e);i=r+"GetUnderlyingPosition"}else throw new Qa(this.id+" fetchPosition() does not support "+r+" market "+e+", supported market types are futures, swap or option");return await this[i](this.extend(n,t))}async fetchPositions(e=void 0,t={}){await this.loadMarkets();let s;const i=this.safeString2(this.options,"fetchPositions","defaultType"),n=this.safeString(t,"type",i);if(n==="futures"||n==="swap")s=n+"GetPosition";else if(n==="option"){if(this.safeString(t,"underlying")===void 0)throw new hi(this.id+" fetchPositions() requires an underlying parameter for "+n+" markets");s=n+"GetUnderlyingPosition"}else throw new Qa(this.id+" fetchPositions() does not support "+n+" markets, supported market types are futures, swap or option");return t=this.omit(t,"type"),await this[s](t)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeString2(this.options,"fetchLedger","defaultType"),r=this.safeString(i,"type",n),a=this.omit(i,"type"),o=r==="account"?"":"Accounts";let d="";const c={};s!==void 0&&(c.limit=s);let u;if(r==="spot"){if(e===void 0)throw new hi(this.id+" fetchLedger() requires a currency code argument for '"+r+"' markets");d="Currency",u=this.currency(e),c.currency=u.id}else if(r==="futures"){if(e===void 0)throw new hi(this.id+" fetchLedger() requires an underlying symbol for '"+r+"' markets");d="Underlying";const m=this.market(e),g=this.safeValue(m,"info",{}),y=this.safeString(g,"settlement_currency"),b=this.safeCurrencyCode(y);u=this.currency(b);const w=this.safeString(g,"underlying");c.underlying=w}else if(r==="swap"){if(e===void 0)throw new hi(this.id+" fetchLedger() requires a code argument (a market symbol) for '"+r+"' markets");d="InstrumentId";const m=this.market(e);u=this.currency(m.base),c.instrument_id=m.id}else if(r==="account")e!==void 0&&(u=this.currency(e),c.currency=u.id);else throw new Qa(this.id+" fetchLedger does not support the '"+r+"' type (the type must be one of 'account', 'spot', 'margin', 'futures', 'swap')");const h=r+"Get"+o+d+"Ledger",l=await this[h](this.extend(c,a));if(l.length<1)return[];if(r==="swap"){const m=this.parseLedger(l);return this.filterBySymbolSinceLimit(m,e,t,s)}return this.parseLedger(l,u,t,s)}parseLedgerEntryType(e){const t={transfer:"transfer",trade:"trade",rebate:"rebate",match:"trade",fee:"fee",settlement:"trade",liquidation:"trade",funding:"fee",margin:"margin"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"ledger_id"),i=void 0,n=this.safeValue(e,"details",{}),r=this.safeString(n,"order_id"),a=void 0,o=this.parseLedgerEntryType(this.safeString(e,"type")),d=this.safeCurrencyCode(this.safeString(e,"currency"),t),c=this.safeNumber(e,"amount"),u=this.parse8601(this.safeString(e,"timestamp")),h={cost:this.safeNumber(e,"fee"),currency:d},l=void 0,p=this.safeNumber(e,"balance"),m="ok",g=this.safeString(e,"instrument_id"),y=this.safeSymbol(g);return{info:e,id:s,account:i,referenceId:r,referenceAccount:a,type:o,currency:d,symbol:y,amount:c,before:l,after:p,status:m,timestamp:u,datetime:this.iso8601(u),fee:h}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=Array.isArray(i);let o="/api/"+t+"/"+this.version+"/";o+=a?e:this.implodeParams(e,i);const d=a?i:this.omit(i,this.extractParams(e));let c=this.implodeHostname(this.urls.api.rest)+o;const u=this.getPathAuthenticationType(e);if(u==="public"||u==="information")Object.keys(d).length&&(c+="?"+this.urlencode(d));else if(u==="private"){this.checkRequiredCredentials();const h=this.iso8601(this.milliseconds());n={"OK-ACCESS-KEY":this.apiKey,"OK-ACCESS-PASSPHRASE":this.password,"OK-ACCESS-TIMESTAMP":h};let l=h+s+o;if(s==="GET"){if(Object.keys(d).length){const m="?"+this.urlencode(d);c+=m,l+=m}}else(a||Object.keys(d).length)&&(r=this.json(d),l+=r),n["Content-Type"]="application/json";const p=this.hmac(this.encode(l),this.encode(this.secret),"sha256","base64");n["OK-ACCESS-SIGN"]=p}return{url:c,method:s,body:r,headers:n}}getPathAuthenticationType(e){if(e==="underlying")return"public";const t=this.safeValue(this.options,"auth",{}),s=this.findBroadlyMatchedKey(t,e);return this.safeString(t,s,"private")}handleErrors(e,t,s,i,n,r,a,o,d){if(!a)return;const c=this.id+" "+r;if(e===503)throw new Wo(c);const u=this.safeString(a,"message"),h=this.safeString2(a,"code","error_code"),l=u!==void 0&&u!=="",p=h!==void 0&&h!=="0";if(l&&(this.throwExactlyMatchedException(this.exceptions.exact,u,c),this.throwBroadlyMatchedException(this.exceptions.broad,u,c)),p&&this.throwExactlyMatchedException(this.exceptions.exact,h,c),p||l)throw new oe(c)}};const Z9=ge,{ExchangeError:be,ExchangeNotAvailable:Za,OnMaintenance:J9,ArgumentsRequired:Li,BadRequest:kt,AccountSuspended:oa,InvalidAddress:ch,PermissionDenied:ig,InsufficientFunds:Wn,InvalidNonce:sT,InvalidOrder:Me,OrderNotFound:uh,AuthenticationError:Kt,RequestTimeout:eG,BadSymbol:Ri,RateLimitExceeded:fh,NetworkError:tG,CancelPending:sG,NotSupported:iT,AccountNotEnabled:iG}=de,{TICK_SIZE:nG}=me,as=Se;var Eb=class extends Z9{describe(){return this.deepExtend(super.describe(),{id:"okx",name:"OKX",countries:["CN","US"],version:"v5",rateLimit:100,pro:!0,certified:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!0,option:void 0,addMargin:!0,borrowMargin:!0,cancelAllOrders:!1,cancelOrder:!0,cancelOrders:!0,createDepositAddress:!1,createOrder:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowInterest:!0,fetchBorrowRate:!0,fetchBorrowRateHistories:!0,fetchBorrowRateHistory:!0,fetchBorrowRates:!0,fetchBorrowRatesPerSymbol:!1,fetchCanceledOrders:!0,fetchClosedOrder:void 0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchIndexOHLCV:!0,fetchL3OrderBook:!1,fetchLedger:!0,fetchLedgerEntry:void 0,fetchLeverage:!0,fetchLeverageTiers:!1,fetchMarketLeverageTiers:!0,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenInterestHistory:!0,fetchOpenOrder:void 0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrders:!1,fetchOrderTrades:!0,fetchPermissions:void 0,fetchPosition:!0,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTradingLimits:!1,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfer:!0,fetchTransfers:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,fetchWithdrawalWhitelist:!1,reduceMargin:!0,repayMargin:!0,setLeverage:!0,setMargin:!1,setMarginMode:!0,setPositionMode:!0,signIn:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1H","2h":"2H","4h":"4H","6h":"6H","12h":"12H","1d":"1D","1w":"1W","1M":"1M","3M":"3M","6M":"6M","1y":"1Y"},hostname:"www.okx.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/152485636-38b19e4a-bece-4dec-979a-5982859ffc04.jpg",api:{rest:"https://{hostname}"},www:"https://www.okx.com",doc:"https://www.okx.com/docs-v5/en/",fees:"https://www.okx.com/pages/products/fees.html",referral:"https://www.okx.com/join/1888677",test:{rest:"https://{hostname}"}},api:{public:{get:{"market/tickers":1,"market/ticker":1,"market/index-tickers":1,"market/books":1,"market/books-lite":1.66,"market/candles":.5,"market/history-candles":1,"market/history-mark-price-candles":120,"market/history-index-candles":120,"market/index-candles":1,"market/mark-price-candles":1,"market/trades":1,"market/platform-24-volume":10,"market/open-oracle":100,"market/index-components":1,"public/instruments":1,"public/delivery-exercise-history":.5,"public/open-interest":1,"public/funding-rate":1,"public/funding-rate-history":1,"public/price-limit":1,"public/opt-summary":1,"public/estimated-price":2,"public/discount-rate-interest-free-quota":10,"public/time":2,"public/liquidation-orders":.5,"public/mark-price":2,"public/position-tiers":2,"public/underlying":1,"public/interest-rate-loan-quota":10,"public/vip-interest-rate-loan-quota":10,"rubik/stat/trading-data/support-coin":4,"rubik/stat/taker-volume":4,"rubik/stat/margin/loan-ratio":4,"rubik/stat/contracts/long-short-account-ratio":4,"rubik/stat/contracts/open-interest-volume":4,"rubik/stat/option/open-interest-volume":4,"rubik/stat/option/open-interest-volume-ratio":4,"rubik/stat/option/open-interest-volume-expiry":4,"rubik/stat/option/open-interest-volume-strike":4,"rubik/stat/option/taker-block-volume":4,"system/status":100,"asset/lending-rate-summary":5/3,"asset/lending-rate-history":5/3,"market/exchange-rate":20}},private:{get:{"account/account-position-risk":2,"account/balance":2,"account/positions":2,"account/bills":5/3,"account/bills-archive":5/3,"account/config":4,"account/max-size":1,"account/max-avail-size":1,"account/leverage-info":1,"account/max-loan":1,"account/trade-fee":4,"account/interest-accrued":4,"account/interest-rate":4,"account/max-withdrawal":1,"account/risk-state":2,"account/borrow-repay-history":4,"account/interest-limits":4,"asset/asset-valuation":1/5,"asset/deposit-address":5/3,"asset/balances":5/3,"asset/transfer-state":10,"asset/deposit-history":5/3,"asset/withdrawal-history":5/3,"asset/currencies":5/3,"asset/bills":5/3,"asset/piggy-balance":5/3,"asset/deposit-lightning":5,"asset/lending-history":5/3,"asset/saving-balance":5/3,"trade/order":1/3,"trade/orders-pending":1,"trade/orders-history":.5,"trade/orders-history-archive":1,"trade/fills":1/3,"trade/fills-history":2,"trade/orders-algo-pending":1,"trade/orders-algo-history":1,"account/subaccount/balances":10,"asset/subaccount/bills":5/3,"users/subaccount/list":10,"users/subaccount/apikey":10,"users/entrust-subaccount-list":10,"broker/nd/info":10,"broker/nd/subaccount-info":10,"asset/broker/nd/subaccount-deposit-address":4,"asset/broker/nd/subaccount-deposit-history":4,"broker/nd/rebate-daily":1,"broker/nd/subaccount/apikey":10,"broker/nd/rebate-per-orders":300,"asset/convert/currencies":5/3,"asset/convert/currency-pair":5/3,"asset/convert/estimate-quote":5,"asset/convert/trade":5,"asset/convert/history":5/3,"account/greeks":2,"finance/staking-defi/offers":1,"finance/staking-defi/orders-active":1,"finance/staking-defi/orders-history":1},post:{"account/set-position-mode":4,"account/set-leverage":1,"account/position/margin-balance":1,"account/set-greeks":4,"account/set-isolated-mode":4,"account/simulated_margin":10,"account/borrow-repay":5/3,"asset/transfer":10,"asset/withdrawal":5/3,"asset/purchase_redempt":5/3,"asset/withdrawal-lightning":5,"asset/set-lending-rate":5/3,"asset/cancel-withdrawal":5/3,"asset/convert-dust-assets":10,"trade/order":1/3,"trade/batch-orders":1/15,"trade/cancel-order":1/3,"trade/cancel-batch-orders":1/15,"trade/amend-order":1/3,"trade/amend-batch-orders":1/3,"trade/close-position":1,"trade/order-algo":1,"trade/cancel-algos":1,"trade/cancel-advance-algos":1,"users/subaccount/delete-apikey":10,"users/subaccount/modify-apikey":10,"users/subaccount/apikey":10,"asset/subaccount/transfer":10,"asset/subaccount/set-transfer-out":10,"broker/nd/create-subaccount":10,"broker/nd/delete-subaccount":10,"broker/nd/set-subaccount-level":4,"broker/nd/set-subaccount-fee-rate":4,"asset/broker/nd/subaccount-deposit-address":4,"broker/nd/subaccount/apikey":10,"broker/nd/subaccount/delete-apikey":10,"broker/nd/subaccount/modify-apikey":10,"broker/nd/rebate-per-orders":36e3,"finance/staking-defi/purchase":3,"finance/staking-defi/redeem":3,"finance/staking-defi/cancel":3}}},fees:{trading:{taker:this.parseNumber("0.0015"),maker:this.parseNumber("0.0010")},spot:{taker:this.parseNumber("0.0015"),maker:this.parseNumber("0.0010")},future:{taker:this.parseNumber("0.0005"),maker:this.parseNumber("0.0002")},swap:{taker:this.parseNumber("0.00050"),maker:this.parseNumber("0.00020")}},requiredCredentials:{apiKey:!0,secret:!0,password:!0},exceptions:{exact:{1:be,2:be,5e4:kt,50001:J9,50002:kt,50004:eG,50005:Za,50006:kt,50007:oa,50008:Kt,50009:oa,50010:be,50011:fh,50012:be,50013:Za,50014:kt,50015:be,50016:be,50017:be,50018:be,50019:be,50020:be,50021:be,50022:be,50023:be,50024:kt,50025:be,50026:Za,50027:ig,50028:be,50044:kt,50100:be,50101:Kt,50102:sT,50103:Kt,50104:Kt,50105:Kt,50106:Kt,50107:Kt,50108:be,50109:be,50110:ig,50111:Kt,50112:Kt,50113:Kt,50114:Kt,50115:kt,51e3:kt,51001:Ri,51002:Ri,51003:kt,51004:Me,51005:Me,51006:Me,51007:Me,51008:Wn,51009:oa,51010:iG,51011:Me,51012:Ri,51014:Ri,51015:Ri,51016:Me,51017:be,51018:be,51019:be,51020:Me,51021:Ri,51022:Ri,51023:be,51024:oa,51025:be,51026:Ri,51027:Ri,51028:Ri,51029:Ri,51030:Ri,51031:Me,51100:Me,51101:Me,51102:Me,51103:Me,51104:Me,51105:Me,51106:Me,51107:Me,51108:Me,51109:Me,51110:Me,51111:kt,51112:Me,51113:fh,51115:Me,51116:Me,51117:Me,51118:Me,51119:Wn,51120:Me,51121:Me,51122:Me,51124:Me,51125:Me,51126:Me,51127:Wn,51128:Me,51129:Me,51130:Ri,51131:Wn,51132:Me,51133:Me,51134:Me,51135:Me,51136:Me,51137:Me,51138:Me,51139:Me,51201:Me,51202:Me,51203:Me,51204:Me,51205:Me,51250:Me,51251:Me,51252:Me,51253:Me,51254:Me,51255:Me,51256:Me,51257:Me,51258:Me,51259:Me,51260:Me,51261:Me,51262:Me,51263:Me,51264:Me,51265:Me,51267:Me,51268:Me,51269:Me,51270:Me,51271:Me,51272:Me,51273:Me,51274:Me,51275:Me,51276:Me,51277:Me,51278:Me,51279:Me,51280:Me,51400:uh,51401:uh,51402:uh,51403:Me,51404:Me,51405:be,51406:be,51407:kt,51408:be,51409:be,51410:sG,51500:be,51501:be,51502:Wn,51503:be,51506:be,51508:be,51509:be,51510:be,51511:be,51600:be,51601:be,51602:be,51603:uh,52e3:be,54e3:be,54001:be,58e3:be,58001:Kt,58002:ig,58003:be,58004:oa,58005:be,58006:be,58007:be,58100:be,58101:oa,58102:fh,58103:be,58104:be,58105:be,58106:be,58107:be,58108:be,58109:be,58110:be,58111:be,58112:be,58114:be,58115:be,58116:be,58117:be,58200:be,58201:be,58202:be,58203:ch,58204:oa,58205:be,58206:be,58207:ch,58208:be,58209:be,58210:be,58211:be,58212:be,58213:Kt,58221:kt,58222:kt,58224:kt,58300:be,58350:Wn,59e3:be,59001:be,59100:be,59101:be,59102:be,59103:Wn,59104:be,59105:be,59106:be,59107:be,59108:Wn,59109:be,59200:Wn,59201:Wn,59300:be,59301:be,59401:be,59500:be,59501:be,59502:be,59503:be,59504:be,59505:be,59506:be,59507:be,59508:oa,60001:Kt,60002:Kt,60003:Kt,60004:Kt,60005:Kt,60006:sT,60007:Kt,60008:Kt,60009:Kt,60010:Kt,60011:Kt,60012:kt,60013:kt,60014:fh,60015:tG,60016:Za,60017:kt,60018:kt,60019:kt,63999:be,70010:kt,70013:kt,70016:kt},broad:{"Internal Server Error":Za,"server error":Za}},httpExceptions:{429:Za},precisionMode:nG,options:{defaultNetwork:"ERC20",networks:{ETH:"ERC20",TRX:"TRC20",OMNI:"Omni",SOLANA:"Solana",POLYGON:"Polygon",OEC:"OEC",ALGO:"ALGO"},fetchOpenInterestHistory:{timeframes:{"5m":"5m","1h":"1H","1d":"1D","5M":"5m","1H":"1H","1D":"1D"}},fetchOHLCV:{timezone:"UTC"},createOrder:"privatePostTradeBatchOrders",createMarketBuyOrderRequiresPrice:!1,fetchMarkets:["spot","future","swap","option"],defaultType:"spot",defaultMarginMode:"cross",fetchLedger:{method:"privateGetAccountBills"},fetchOrder:{method:"privateGetTradeOrder"},fetchOpenOrders:{method:"privateGetTradeOrdersPending"},cancelOrders:{method:"privatePostTradeCancelBatchOrders"},fetchCanceledOrders:{method:"privateGetTradeOrdersHistory"},fetchClosedOrders:{method:"privateGetTradeOrdersHistory"},algoOrderTypes:{conditional:!0,trigger:!0,oco:!0,move_order_stop:!0,iceberg:!0,twap:!0},accountsByType:{spot:"1",future:"3",futures:"3",margin:"5",funding:"6",swap:"9",option:"12",trading:"18"},accountsById:{1:"spot",3:"future",5:"margin",6:"funding",9:"swap",12:"option",18:"trading"},exchangeType:{spot:"SPOT",margin:"MARGIN",swap:"SWAP",future:"FUTURES",futures:"FUTURES",option:"OPTION",SPOT:"SPOT",MARGIN:"MARGIN",SWAP:"SWAP",FUTURES:"FUTURES",OPTION:"OPTION"},brokerId:"e847386590ce4dBC"},commonCurrencies:{AE:"AET",BOX:"DefiBox",HOT:"Hydro Protocol",HSR:"HC",MAG:"Maggie",SBTC:"Super Bitcoin",TRADE:"Unitrade",YOYO:"YOYOW",WIN:"WinToken"}})}handleMarketTypeAndParams(e,t=void 0,s={}){const i=this.safeString(s,"instType");return s=this.omit(s,"instType"),this.safeString(s,"type")===void 0&&i!==void 0&&(s.type=i),super.handleMarketTypeAndParams(e,t,s)}convertToInstrumentType(e){const t=this.safeValue(this.options,"exchangeType",{});return this.safeString(t,e,e)}async fetchStatus(e={}){const t=await this.publicGetSystemStatus(e),s=this.safeValue(t,"data",[]),n={updated:void 0,status:s.length===0?"ok":"maintenance",eta:void 0,url:void 0,info:t};for(let r=0;r<s.length;r++){const a=s[r];this.safeString(a,"state")==="ongoing"&&(n.eta=this.safeInteger(a,"end"),n.status="maintenance")}return n}async fetchTime(e={}){const t=await this.publicGetPublicTime(e),s=this.safeValue(t,"data",[]),i=this.safeValue(s,0,{});return this.safeInteger(i,"ts")}async fetchAccounts(e={}){const t=await this.privateGetAccountConfig(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"uid"),o=this.safeString(r,"acctLv");i.push({id:a,type:o,currency:void 0,info:r})}return i}async fetchMarkets(e={}){const t=this.safeValue(this.options,"fetchMarkets");let s=[],i=[];for(let n=0;n<t.length;n++)s.push(this.fetchMarketsByType(t[n],e));s=await Promise.all(s);for(let n=0;n<s.length;n++)i=this.arrayConcat(i,s[n]);return i}parseMarkets(e){const t=[];for(let s=0;s<e.length;s++)t.push(this.parseMarket(e[s]));return t}parseMarket(e){const t=this.safeString(e,"instId");let s=this.safeStringLower(e,"instType");s==="futures"&&(s="future");const i=s==="spot",n=s==="future",r=s==="swap",a=s==="option",o=r||n||a;let d=this.safeString(e,"baseCcy"),c=this.safeString(e,"quoteCcy");const u=this.safeString(e,"settleCcy"),h=this.safeCurrencyCode(u),l=this.safeString(e,"uly");if(l!==void 0&&!i){const P=l.split("-");d=this.safeString(P,0),c=this.safeString(P,1)}const p=this.safeCurrencyCode(d),m=this.safeCurrencyCode(c);let g=p+"/"+m,y,b,w;if(o){if(g=g+":"+h,y=this.safeInteger(e,"expTime"),n){const P=this.yymmdd(y);g=g+"-"+P}else if(a){b=this.safeString(e,"stk"),w=this.safeString(e,"optType");const P=this.yymmdd(y);g=g+"-"+P+"-"+b+"-"+w,w=w==="P"?"put":"call"}}const k=this.safeString(e,"tickSz"),T=this.safeString(e,"minSz"),O=this.parseNumber(T),x=this.safeValue2(this.fees,s,"trading",{}),C=this.parseNumber(k);let E=this.safeString(e,"lever","1");return E=as.stringMax(E,"1"),this.extend(x,{id:t,symbol:g,base:p,quote:m,settle:h,baseId:d,quoteId:c,settleId:u,type:s,spot:i,margin:i&&as.stringGt(E,"1"),swap:r,future:n,option:a,active:!0,contract:o,linear:o?c===u:void 0,inverse:o?d===u:void 0,contractSize:o?this.safeNumber(e,"ctVal"):void 0,expiry:y,expiryDatetime:this.iso8601(y),strike:b,optionType:w,precision:{amount:this.safeNumber(e,"lotSz"),price:C},limits:{leverage:{min:this.parseNumber("1"),max:this.parseNumber(E)},amount:{min:O,max:void 0},price:{min:C,max:void 0},cost:{min:void 0,max:void 0}},info:e})}async fetchMarketsByType(e,t={}){const s={instType:this.convertToInstrumentType(e)};if(e==="option"){const r=this.safeValue(this.options,"defaultUnderlying","BTC-USD"),a=this.safeString2(t,"uly","marketId",r);if(a===void 0)throw new Li(this.id+" fetchMarketsByType() requires an underlying uly or marketId parameter for options markets");s.uly=a}const i=await this.publicGetPublicInstruments(this.extend(s,t)),n=this.safeValue(i,"data",[]);return this.parseMarkets(n)}safeNetwork(e){const t={Bitcoin:"BTC",Omni:"OMNI",TRON:"TRC20"};return this.safeString(t,e,e)}async fetchCurrencies(e={}){if(!this.checkRequiredCredentials(!1))return;const t=await this.privateGetAssetCurrencies(e),s=this.safeValue(t,"data",[]),i={},n=this.groupBy(s,"ccy"),r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],c=this.safeCurrency(o).code,u=n[o],h={};let l=!1,p,m,g;for(let b=0;b<u.length;b++){const w=u[b],k=this.safeValue(w,"canDep"),T=this.safeValue(w,"canWd"),O=this.safeValue(w,"canInternal"),x=!!(k&&T&&O);l=l===void 0?x:l;const C=this.safeString(w,"chain");if(k&&!p?p=!0:k||(p=!1),T&&!m?m=!0:T||(m=!1),C!==void 0&&C.indexOf("-")>=0){const E=C.split("-"),P=this.safeString(E,1,C),_=this.safeNetwork(P),S=this.parsePrecision(this.safeString(w,"wdTickSz"));g===void 0?g=S:g=as.stringMin(g,S),h[_]={id:C,network:_,active:x,deposit:k,withdraw:T,fee:this.safeNumber(w,"minFee"),precision:this.parseNumber(S),limits:{withdraw:{min:this.safeNumber(w,"minWd"),max:this.safeNumber(w,"maxWd")}},info:w}}}const y=this.safeValue(u,0);i[c]={info:void 0,code:c,id:o,name:this.safeString(y,"name"),active:l,deposit:p,withdraw:m,fee:void 0,precision:this.parseNumber(g),limits:{amount:{min:void 0,max:void 0}},networks:h}}return i}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={instId:this.market(e).id};t=t===void 0?20:t,t!==void 0&&(n.sz=t);const r=await this.publicGetMarketBooks(this.extend(n,s)),a=this.safeValue(r,"data",[]),o=this.safeValue(a,0,{}),d=this.safeInteger(o,"ts");return this.parseOrderBook(o,e,d)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"ts"),i=this.safeString(e,"instId");t=this.safeMarket(i,t,"-");const n=t.symbol,r=this.safeString(e,"last"),a=this.safeString(e,"open24h"),d=this.safeValue(t,"spot",!1)?this.safeString(e,"volCcy24h"):void 0,c=this.safeString(e,"vol24h"),u=this.safeString(e,"high24h"),h=this.safeString(e,"low24h");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:u,low:h,bid:this.safeString(e,"bidPx"),bidVolume:this.safeString(e,"bidSz"),ask:this.safeString(e,"askPx"),askVolume:this.safeString(e,"askSz"),vwap:void 0,open:a,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:c,quoteVolume:d,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={instId:s.id},n=await this.publicGetMarketTicker(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0,{});return this.parseTicker(a,s)}async fetchTickersByType(e,t=void 0,s={}){await this.loadMarkets();const i={instType:this.convertToInstrumentType(e)};if(e==="option"){const a=this.safeValue(this.options,"defaultUnderlying","BTC-USD"),o=this.safeString2(s,"uly","marketId",a);if(o===void 0)throw new Li(this.id+" fetchTickersByType() requires an underlying uly or marketId parameter for options markets");i.uly=o}const n=await this.publicGetMarketTickers(this.extend(i,s)),r=this.safeValue(n,"data",[]);return this.parseTickers(r,t)}async fetchTickers(e=void 0,t={}){e=this.marketSymbols(e);const s=this.safeString(e,0);let i;s!==void 0&&(i=this.market(s));const[n,r]=this.handleMarketTypeAndParams("fetchTickers",i,t);return await this.fetchTickersByType(n,e,r)}parseTrade(e,t=void 0){const s=this.safeString(e,"tradeId"),i=this.safeString(e,"instId");t=this.safeMarket(i,t,"-");const n=t.symbol,r=this.safeInteger(e,"ts"),a=this.safeString2(e,"fillPx","px"),o=this.safeString2(e,"fillSz","sz"),d=this.safeString(e,"side"),c=this.safeString(e,"ordId"),u=this.safeString(e,"fee");let h;if(u!==void 0){const p=as.stringNeg(u),m=this.safeString(e,"feeCcy"),g=this.safeCurrencyCode(m);h={cost:p,currency:g}}let l=this.safeString(e,"execType");return l==="T"?l="taker":l==="M"&&(l="maker"),this.safeTrade({info:e,timestamp:r,datetime:this.iso8601(r),symbol:n,id:s,order:c,type:void 0,takerOrMaker:l,side:d,price:a,amount:o,cost:void 0,fee:h},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={instId:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetMarketTrades(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.safeString(n,"price");n=this.omit(n,"price");const o=this.safeValue(this.options,"fetchOHLCV",{}),d=this.safeString(o,"timezone","UTC");i===void 0&&(i=100);const c=this.parseTimeframe(t);let u=this.timeframes[t];d==="UTC"&&c>=21600&&(u+=d.toLowerCase());const h={instId:r.id,bar:u,limit:i};let l="Candles";if(s!==void 0){this.milliseconds()-s>i*c*1e3&&(l="HistoryCandles");const T=c*1e3,O=Math.max(s-1,0);h.before=O,h.after=this.sum(O,T*i)}const p=this.safeInteger(n,"until");p!==void 0&&(h.after=p,n=this.omit(n,"until")),l=this.safeString(o,"type",l);const m=this.safeString(n,"type",l);n=this.omit(n,"type");let g="publicGetMarket"+m;a==="mark"?g="publicGetMarketMarkPriceCandles":a==="index"&&(g="publicGetMarketIndexCandles");const y=await this[g](this.extend(h,n)),b=this.safeValue(y,"data",[]);return this.parseOHLCVs(b,r,t,s,i)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Li(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={instId:n.id};t!==void 0&&(r.before=Math.max(t-1,0)),s!==void 0&&(r.limit=s);const a=await this.publicGetPublicFundingRateHistory(this.extend(r,i)),o=[],d=this.safeValue(a,"data",[]);for(let u=0;u<d.length;u++){const h=d[u],l=this.safeNumber(h,"fundingTime");o.push({info:h,symbol:this.safeSymbol(this.safeString(h,"instId")),fundingRate:this.safeNumber(h,"realizedRate"),timestamp:l,datetime:this.iso8601(l)})}const c=this.sortBy(o,"timestamp");return this.filterBySymbolSinceLimit(c,n.symbol,t,s)}parseBalanceByType(e,t){return e==="funding"?this.parseFundingBalance(t):this.parseTradingBalance(t)}parseTradingBalance(e){const t={info:e},s=this.safeValue(e,"data",[]),i=this.safeValue(s,0,{}),n=this.safeInteger(i,"uTime"),r=this.safeValue(i,"details",[]);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeString(o,"ccy"),c=this.safeCurrencyCode(d),u=this.account(),h=this.safeString(o,"eq"),l=this.safeString(o,"availEq");h===void 0||l===void 0?(u.free=this.safeString(o,"availBal"),u.used=this.safeString(o,"frozenBal")):(u.total=h,u.free=l),t[c]=u}return t.timestamp=n,t.datetime=this.iso8601(n),this.safeBalance(t)}parseFundingBalance(e){const t={info:e},s=this.safeValue(e,"data",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeString(n,"ccy"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(n,"bal"),o.free=this.safeString(n,"availBal"),o.used=this.safeString(n,"frozenBal"),t[a]=o}return this.safeBalance(t)}parseTradingFee(e,t=void 0){return{info:e,symbol:this.safeSymbol(void 0,t),maker:this.parseNumber(as.stringNeg(this.safeString2(e,"maker","makerU"))),taker:this.parseNumber(as.stringNeg(this.safeString2(e,"taker","takerU")))}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={instType:this.convertToInstrumentType(s.type)};if(s.spot)i.instId=s.id;else if(s.swap||s.future||s.option)i.uly=s.baseId+"-"+s.quoteId;else throw new iT(this.id+" fetchTradingFee() supports spot, swap, future or option markets only");const n=await this.privateGetAccountTradeFee(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0,{});return this.parseTradingFee(a,s)}async fetchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("fetchBalance",void 0,e);let i;t==="funding"?i="privateGetAssetBalances":i="privateGetAccountBalance";const n={},r=await this[i](this.extend(n,s));return this.parseBalanceByType(t,r)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={instId:a.id,side:s,ordType:t,sz:this.amountToPrecision(e,i)},d=a.spot,c=a.contract,u=this.safeValueN(r,["triggerPrice","stopPrice","triggerPx"]),h=this.safeString(r,"timeInForce","GTC"),l=this.safeValue2(r,"takeProfitPrice","tpTriggerPx"),p=this.safeValue(r,"tpOrdPx",n),m=this.safeString(r,"tpTriggerPxType","last"),g=this.safeValue2(r,"stopLossPrice","slTriggerPx"),y=this.safeValue(r,"slOrdPx",n),b=this.safeString(r,"slTriggerPxType","last"),w=this.safeString2(r,"clOrdId","clientOrderId"),k=this.safeString2(this.options,"defaultMarginMode","marginMode","cross");let T=this.safeString2(r,"marginMode","tdMode"),O=!1;if(T!==void 0&&T!=="cash"?O=!0:(T=k,O=this.safeValue(r,"margin",!1)),d){if(O){const se=s==="buy"?a.quote:a.base,we=this.safeString(r,"ccy",se);o.ccy=this.safeCurrencyCode(we)}const J=O?T:"cash";o.tdMode=J}else c&&(o.tdMode=T);const x=t==="market",C=this.isPostOnly(x,t==="post_only",r);r=this.omit(r,["currency","ccy","marginMode","timeInForce","stopPrice","triggerPrice","clientOrderId","stopLossPrice","takeProfitPrice","slOrdPx","tpOrdPx","margin"]);const E=h==="IOC"||t==="ioc",P=h==="FOK"||t==="fok",_=u!==void 0||t==="trigger",S=g!==void 0||l!==void 0||t==="conditional",I=x&&E||t==="optimal_limit_ioc",v=this.safeString(this.options,"createOrder","privatePostTradeBatchOrders"),N=this.safeString(this.options,"tgtCcy","base_ccy"),q=this.safeString(r,"tgtCcy",N);!c&&!O&&(o.tgtCcy=q);let R=v;if(x||I){if(o.ordType="market",d&&s==="buy"&&q==="quote_ccy"){let J=this.safeNumber2(r,"cost","sz");if(this.safeValue(this.options,"createMarketBuyOrderRequiresPrice",!0)){if(n!==void 0){if(J===void 0){const we=this.numberToString(i),le=this.numberToString(n),Oe=as.stringMul(we,le);J=this.parseNumber(Oe)}}else if(J===void 0)throw new Me(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total cost value in the 'amount' argument or in the 'cost' unified extra parameter or in exchange-specific 'sz' extra parameter (the exchange-specific behaviour)")}else J=J===void 0?i:J;o.sz=this.costToPrecision(e,J),r=this.omit(r,["cost","sz"])}I&&c&&(o.ordType="optimal_limit_ioc")}else!_&&!S&&(o.px=this.priceToPrecision(e,n));if(C?(R=v,o.ordType="post_only"):E&&!I?(R=v,o.ordType="ioc"):P?(R=v,o.ordType="fok"):_?(R="privatePostTradeOrderAlgo",o.ordType="trigger",o.triggerPx=this.priceToPrecision(e,u),o.orderPx=x?"-1":this.priceToPrecision(e,n)):S&&(R="privatePostTradeOrderAlgo",o.ordType="conditional",l!==void 0&&g!==void 0&&(o.ordType="oco"),l!==void 0&&(o.tpTriggerPx=this.priceToPrecision(e,l),o.tpOrdPx=p===void 0?"-1":this.priceToPrecision(e,p),o.tpTriggerPxType=m),g!==void 0&&(o.slTriggerPx=this.priceToPrecision(e,g),o.slOrdPx=y===void 0?"-1":this.priceToPrecision(e,y),o.slTriggerPxType=b)),(t==="oco"||t==="move_order_stop"||t==="iceberg"||t==="twap")&&(R="privatePostTradeOrderAlgo"),w===void 0){const J=this.safeString(this.options,"brokerId");J!==void 0&&(o.clOrdId=J+this.uuid16(),o.tag=J)}else o.clOrdId=w,r=this.omit(r,["clOrdId","clientOrderId"]);let G;if(R==="privatePostTradeOrder"||R==="privatePostTradeOrderAlgo")G=this.extend(o,r);else if(R==="privatePostTradeBatchOrders")G=[this.extend(o,r)];else throw new be(this.id+' createOrder() this.options["createOrder"] must be either privatePostTradeBatchOrders or privatePostTradeOrder');const F=await this[R](G),A=this.safeValue(F,"data",[]),V=this.safeValue(A,0),Q=this.parseOrder(V,a);return this.extend(Q,{type:t,side:s})}async cancelOrder(e,t=void 0,s={}){if(this.safeValue(s,"stop")){const h=await this.cancelOrders([e],t,s);return this.safeValue(h,0)}if(t===void 0)throw new Li(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const n=this.market(t),r={instId:n.id},a=this.safeString2(s,"clOrdId","clientOrderId");a!==void 0?r.clOrdId=a:r.ordId=e;const o=this.omit(s,["clOrdId","clientOrderId"]),d=await this.privatePostTradeCancelOrder(this.extend(r,o)),c=this.safeValue(d,"data",[]),u=this.safeValue(c,0);return this.parseOrder(u,n)}parseIds(e){return typeof e=="string"?e.split(","):e}async cancelOrders(e,t=void 0,s={}){if(t===void 0)throw new Li(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=[],r=this.safeValue(this.options,"cancelOrders",{}),a=this.safeString(r,"method","privatePostTradeCancelBatchOrders");let o=this.safeString(s,"method",a);const d=this.parseIds(this.safeValue2(s,"clOrdId","clientOrderId")),c=this.parseIds(this.safeValue(s,"algoId")),u=this.safeValue(s,"stop");if(u&&(o="privatePostTradeCancelAlgos"),d===void 0){if(e=this.parseIds(e),c!==void 0)for(let p=0;p<c.length;p++)n.push({algoId:c[p],instId:i.id});for(let p=0;p<e.length;p++)u?n.push({algoId:e[p],instId:i.id}):n.push({ordId:e[p],instId:i.id})}else for(let p=0;p<d.length;p++)n.push({instId:i.id,clOrdId:d[p]});const h=await this[o](n),l=this.safeValue(h,"data",[]);return this.parseOrders(l,i,void 0,void 0,s)}parseOrderStatus(e){const t={canceled:"canceled",live:"open",partially_filled:"open",filled:"closed",effective:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString2(e,"algoId","ordId"),i=this.safeInteger(e,"cTime"),n=this.safeInteger(e,"fillTime"),r=this.safeString(e,"side");let a=this.safeString(e,"ordType"),o,d;a==="post_only"?(o=!0,a="limit"):a==="fok"?(d="FOK",a="limit"):a==="ioc"&&(d="IOC",a="limit");const c=this.safeString(e,"instId"),u=this.safeSymbol(c,t,"-"),h=this.safeString(e,"accFillSz"),l=this.safeString2(e,"px","ordPx"),p=this.safeString(e,"avgPx"),m=this.parseOrderStatus(this.safeString(e,"state")),g=this.safeString(e,"fee");let y,b;const w=this.safeString(this.options,"tgtCcy","base_ccy"),k=this.safeString(e,"tgtCcy",w),T=this.safeString(e,"instType");r==="buy"&&a==="market"&&T==="SPOT"&&k==="quote_ccy"?b=this.safeString(e,"sz"):y=this.safeString(e,"sz");let O;if(g!==void 0){const P=as.stringNeg(g),_=this.safeString(e,"feeCcy"),S=this.safeCurrencyCode(_);O={cost:this.parseNumber(P),currency:S}}let x=this.safeString(e,"clOrdId");x!==void 0&&x.length<1&&(x=void 0);const C=this.safeNumberN(e,["tpTriggerPx","triggerPx","slTriggerPx"]);let E=this.safeString(e,"reduceOnly");return E!==void 0&&(E=E==="true"),this.safeOrder({info:e,id:s,clientOrderId:x,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:n,symbol:u,type:a,timeInForce:d,postOnly:o,side:r,price:l,stopPrice:C,average:p,cost:b,amount:y,filled:h,remaining:void 0,status:m,fee:O,trades:void 0,reduceOnly:E},t)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Li(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={instId:i.id},r=this.safeString2(s,"clOrdId","clientOrderId"),a=this.safeValue(this.options,"fetchOrder",{}),o=this.safeString(a,"method","privateGetTradeOrder"),d=this.safeString(s,"method",o);if(this.safeValue(s,"stop"))throw new iT(this.id+" fetchOrder() does not support stop orders, use fetchOpenOrders() fetchCanceledOrders() or fetchClosedOrders()");r!==void 0?n.clOrdId=r:n.ordId=e;const u=this.omit(s,["method","clOrdId","clientOrderId"]),h=await this[d](this.extend(n,u)),l=this.safeValue(h,"data",[]),p=this.safeValue(l,0);return this.parseOrder(p,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.instId=r.id),s!==void 0&&(n.limit=s);const a=this.safeValue(this.options,"fetchOpenOrders",{}),o=this.safeValue(this.options,"algoOrderTypes",{}),d=this.safeString(a,"method","privateGetTradeOrdersPending");let c=this.safeString(i,"method",d);const u=this.safeString(i,"ordType"),h=this.safeValue(i,"stop");if((h||u in o)&&(c="privateGetTradeOrdersAlgoPending",h&&u===void 0))throw new Li(this.id+' fetchOpenOrders() requires an "ordType" string parameter, "conditional", "oco", "trigger", "move_order_stop", "iceberg", or "twap"');const l=this.omit(i,["method","stop"]),p=await this[c](this.extend(n,l)),m=this.safeValue(p,"data",[]);return this.parseOrders(m,r,t,s)}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.instId=r.id);let a,o;[a,o]=this.handleMarketTypeAndParams("fetchCanceledOrders",r,i),n.instType=this.convertToInstrumentType(a),s!==void 0&&(n.limit=s),n.state="canceled";const d=this.safeValue(this.options,"fetchCanceledOrders",{}),c=this.safeValue(this.options,"algoOrderTypes",{}),u=this.safeString(d,"method","privateGetTradeOrdersHistory");let h=this.safeString(i,"method",u);const l=this.safeString(i,"ordType"),p=this.safeValue(i,"stop");if(p||l in c){h="privateGetTradeOrdersAlgoHistory";const b=this.safeString(i,"algoId");if(b!==void 0&&(n.algoId=b,i=this.omit(i,"algoId")),p){if(l===void 0)throw new Li(this.id+' fetchCanceledOrders() requires an "ordType" string parameter, "conditional", "oco", "trigger", "move_order_stop", "iceberg", or "twap"');n.ordType=l}}else{t!==void 0&&(n.begin=t);const b=this.safeInteger2(o,"till","until");b!==void 0&&(n.end=b,o=this.omit(o,["until","till"]))}const m=this.omit(o,["method","stop","ordType"]),g=await this[h](this.extend(n,m)),y=this.safeValue(g,"data",[]);return this.parseOrders(y,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.instId=r.id);let a,o;[a,o]=this.handleMarketTypeAndParams("fetchClosedOrders",r,i),n.instType=this.convertToInstrumentType(a),s!==void 0&&(n.limit=s);const d=this.safeValue(this.options,"fetchClosedOrders",{}),c=this.safeValue(this.options,"algoOrderTypes",{}),u=this.safeString(d,"method","privateGetTradeOrdersHistory");let h=this.safeString(i,"method",u);const l=this.safeString(i,"ordType"),p=this.safeValue(i,"stop");if(p||l in c){if(h="privateGetTradeOrdersAlgoHistory",p&&l===void 0)throw new Li(this.id+' fetchClosedOrders() requires an "ordType" string parameter, "conditional", "oco", "trigger", "move_order_stop", "iceberg", or "twap"');n.state="effective"}else{t!==void 0&&(n.begin=t);const b=this.safeInteger2(o,"till","until");b!==void 0&&(n.end=b,o=this.omit(o,["until","till"])),n.state="filled"}const m=this.omit(o,["method","stop"]),g=await this[h](this.extend(n,m)),y=this.safeValue(g,"data",[]);return this.parseOrders(y,r,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.instId=r.id);const[a,o]=this.handleMarketTypeAndParams("fetchMyTrades",r,i);n.instType=this.convertToInstrumentType(a),s!==void 0&&(n.limit=s);const d=await this.privateGetTradeFillsHistory(this.extend(n,o)),c=this.safeValue(d,"data",[]);return this.parseTrades(c,r,t,s,o)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){const r={ordId:e};return await this.fetchMyTrades(t,s,i,this.extend(r,n))}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeValue(this.options,"fetchLedger",{});let r=this.safeString(n,"method");r=this.safeString(i,"method",r),i=this.omit(i,"method");const a={};let o;[o,i]=this.handleMarginModeAndParams("fetchLedger",i),o===void 0&&(o=this.safeString(i,"mgnMode")),r!=="privateGetAssetBills"&&o!==void 0&&(a.mgnMode=o);const[d,c]=this.handleMarketTypeAndParams("fetchLedger",void 0,i);d!==void 0&&(a.instType=this.convertToInstrumentType(d)),s!==void 0&&(a.limit=s);let u;e!==void 0&&(u=this.currency(e),a.ccy=u.id);const h=await this[r](this.extend(a,c)),l=this.safeValue(h,"data",[]);return this.parseLedger(l,u,t,s)}parseLedgerEntryType(e){const t={1:"transfer",2:"trade",3:"trade",4:"rebate",5:"trade",6:"transfer",7:"trade",8:"fee",9:"trade",10:"trade",11:"trade"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"billId"),i=void 0,n=this.safeString(e,"ordId"),r=void 0,a=this.parseLedgerEntryType(this.safeString(e,"type")),o=this.safeCurrencyCode(this.safeString(e,"ccy"),t),d=this.safeString(e,"balChg"),c=this.parseNumber(d),u=this.safeInteger(e,"ts"),h=this.safeString(e,"fee");let l;h!==void 0&&(l={cost:this.parseNumber(as.stringNeg(h)),currency:o});const p=void 0,m=this.safeString(e,"bal"),g=this.parseNumber(m),y="ok",b=this.safeString(e,"instId"),w=this.safeSymbol(b,void 0,"-");return{id:s,info:e,timestamp:u,datetime:this.iso8601(u),account:i,referenceId:n,referenceAccount:r,type:a,currency:o,symbol:w,amount:c,before:p,after:g,status:y,fee:l}}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"addr");let i=this.safeString2(e,"tag","pmtId");i=this.safeString(e,"memo",i);const n=this.safeString(e,"ccy");t=this.safeCurrency(n,t);const r=t.code,a=this.safeString(e,"chain"),o=this.safeValue(t,"networks",{}),d=this.indexBy(o,"id");let c=this.safeValue(d,a);a==="USDT-Polygon"&&(c=this.safeValue(d,"USDT-Polygon-Bridge"));const u=this.safeString(c,"network");return this.checkAddress(s),{currency:r,address:s,tag:i,network:u,info:e}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const i={ccy:this.currency(e).id},n=await this.privateGetAssetDepositAddress(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.filterBy(r,"selected",!0),o=this.parseDepositAddresses(a,[e],!1);return this.indexBy(o,"network")}async fetchDepositAddress(e,t={}){const s=this.safeStringUpper(t,"network"),i=this.safeValue(this.options,"networks",{}),n=this.safeString(i,s,s);t=this.omit(t,"network");const r=await this.fetchDepositAddressesByNetwork(e,t);let a;if(n===void 0){if(a=this.safeValue(r,e),a===void 0){const o=this.safeString(i,e,e);if(a=this.safeValue(r,o),a===void 0){const d=this.safeString(this.options,"defaultNetwork","ERC20");if(a=this.safeValue(r,d),a===void 0){const c=Object.values(r);if(a=this.safeValue(c,0),a===void 0)throw new ch(this.id+" fetchDepositAddress() cannot find deposit address for "+e)}}}return a}if(a=this.safeValue(r,n),a===void 0)throw new ch(this.id+" fetchDepositAddress() cannot find "+n+" deposit address for "+e);return a}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e);i!==void 0&&(s=s+":"+i);const a=this.safeString(n,"fee");if(a===void 0)throw new Li(this.id+" withdraw() requires a 'fee' string parameter, network transaction fee must be \u2265 0. Withdrawals to OKCoin or OKX are fee-free, please set '0'. Withdrawing to external digital asset address requires network transaction fee.");const o={ccy:r.id,toAddr:s,dest:"4",amt:this.numberToString(t),fee:this.numberToString(a)};"password"in n?o.pwd=n.password:"pwd"in n&&(o.pwd=n.pwd);const d=this.safeValue(this.options,"networks",{});let c=this.safeStringUpper(n,"network");c=this.safeString(d,c,c),c!==void 0&&(o.chain=r.id+"-"+c,n=this.omit(n,"network"));const u=this.omit(n,["fee","password","pwd"]);if(!("pwd"in o))throw new be(this.id+" withdraw() requires a password parameter or a pwd parameter, it must be the funding password, not the API passphrase");const h=await this.privatePostAssetWithdrawal(this.extend(o,u)),l=this.safeValue(h,"data",[]),p=this.safeValue(l,0);return this.parseTransaction(p,r)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.ccy=r.id),t!==void 0&&(n.before=Math.max(t-1,0)),s!==void 0&&(n.limit=s);const a=await this.privateGetAssetDepositHistory(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,r,t,s,i)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const i={depId:e};let n;t!==void 0&&(n=this.currency(t),i.ccy=n.id);const r=await this.privateGetAssetDepositHistory(this.extend(i,s)),a=this.safeValue(r,"data"),o=this.safeValue(a,0,{});return this.parseTransaction(o,n)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.ccy=r.id),t!==void 0&&(n.before=Math.max(t-1,0)),s!==void 0&&(n.limit=s);const a=await this.privateGetAssetWithdrawalHistory(this.extend(n,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,r,t,s,i)}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const i={wdId:e};let n;t!==void 0&&(n=this.currency(t),i.ccy=n.id);const r=await this.privateGetAssetWithdrawalHistory(this.extend(i,s)),a=this.safeValue(r,"data"),o=this.safeValue(a,0,{});return this.parseTransaction(o)}parseTransactionStatus(e){const t={"-3":"pending","-2":"canceled","-1":"failed",0:"pending",1:"pending",2:"ok",3:"pending",4:"pending",5:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){let s,i;const n=this.safeString(e,"wdId"),r=this.safeString(e,"from"),a=this.safeString(e,"to"),o=a;let d=this.safeString2(e,"tag","memo");d=this.safeString2(e,"pmtId",d),n!==void 0?(s="withdrawal",i=n):(i=this.safeString(e,"depId"),s="deposit");const c=this.safeString(e,"ccy"),u=this.safeCurrencyCode(c),h=this.safeNumber(e,"amt"),l=this.parseTransactionStatus(this.safeString(e,"state")),p=this.safeString(e,"txId"),m=this.safeInteger(e,"ts");let g;return s==="deposit"?g=0:g=this.safeNumber(e,"fee"),{info:e,id:i,currency:u,amount:h,network:void 0,addressFrom:r,addressTo:a,address:o,tagFrom:void 0,tagTo:d,tag:d,status:l,type:s,updated:void 0,txid:p,timestamp:m,datetime:this.iso8601(m),fee:{currency:u,cost:g}}}async fetchLeverage(e,t={}){await this.loadMarkets();let s;if([s,t]=this.handleMarginModeAndParams("fetchLeverage",t),s===void 0&&(s=this.safeString(t,"mgnMode","cross")),s!=="cross"&&s!=="isolated")throw new kt(this.id+" fetchLeverage() requires a marginMode parameter that must be either cross or isolated");const n={instId:this.market(e).id,mgnMode:s};return await this.privateGetAccountLeverageInfo(this.extend(n,t))}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e),[i,n]=this.handleMarketTypeAndParams("fetchPosition",s,t);s.id,i!==void 0&&this.convertToInstrumentType(i);const r=await this.privateGetAccountPositions(n),a=this.safeValue(r,"data",[]),o=this.safeValue(a,0);return o===void 0?o:this.parsePosition(o)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s={};if(e!==void 0){const a=[];for(let o=0;o<e.length;o++){const d=e[o],c=this.market(d);a.push(c.id)}a.length>0&&(s.instId=a.join(","))}const i=await this.privateGetAccountPositions(this.extend(s,t)),n=this.safeValue(i,"data",[]),r=[];for(let a=0;a<n.length;a++)r.push(this.parsePosition(n[a]));return this.filterByArray(r,"symbol",e,!1)}parsePosition(e,t=void 0){const s=this.safeString(e,"instId");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeString(e,"pos"),r=as.stringAbs(n);let a,o=this.safeString(e,"posSide");const d=o!=="net";n!==void 0&&(a=this.parseNumber(r),o==="net"&&(as.stringGt(n,"0")?o="long":o="short"));const c=this.safeValue(t,"contractSize"),u=this.numberToString(c),h=this.safeString(e,"markPx");let l=this.safeString(e,"notionalUsd");t.inverse&&(l=as.stringDiv(as.stringMul(r,u),h));const p=this.parseNumber(l),m=this.safeString(e,"mgnMode");let g;const y=this.safeString(e,"avgPx"),b=this.safeString(e,"upl"),w=this.safeString(e,"lever");let k,T;m==="cross"?(g=this.safeString(e,"imr"),T=as.stringAdd(g,b)):m==="isolated"&&(k=as.stringDiv("1",w),T=this.safeString(e,"margin"));const O=this.safeString(e,"mmr"),x=this.parseNumber(O);let C=as.stringDiv(O,l);k===void 0?k=this.parseNumber(as.stringDiv(g,l,4)):g===void 0&&(g=as.stringMul(k,l));const E="0.00005";C=this.parseNumber(as.stringDiv(as.stringAdd(C,E),"1",4));const P=this.safeNumber(e,"liqPx"),_=this.safeString(e,"uplRatio"),S=this.parseNumber(as.stringMul(_,"100")),I=this.safeInteger(e,"uTime"),v=this.parseNumber(as.stringDiv(O,T,4));return{info:e,id:void 0,symbol:i,notional:p,marginMode:m,liquidationPrice:P,entryPrice:this.parseNumber(y),unrealizedPnl:this.parseNumber(b),percentage:S,contracts:a,contractSize:c,markPrice:this.parseNumber(h),side:o,hedged:d,timestamp:I,datetime:this.iso8601(I),maintenanceMargin:x,maintenanceMarginPercentage:C,collateral:this.parseNumber(T),initialMargin:this.parseNumber(g),initialMarginPercentage:this.parseNumber(k),leverage:this.parseNumber(w),marginRatio:v}}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c={ccy:r.id,amt:this.currencyToPrecision(e,t),type:"0",from:o,to:d};o==="master"?(c.type="1",c.subAcct=d,c.from=this.safeString(n,"from","6"),c.to=this.safeString(n,"to","6")):d==="master"&&(c.type="2",c.subAcct=o,c.from=this.safeString(n,"from","6"),c.to=this.safeString(n,"to","6"));const u=await this.privatePostAssetTransfer(this.extend(c,n)),h=this.safeValue(u,"data",[]),l=this.safeValue(h,0,{});return this.parseTransfer(l,r)}parseTransfer(e,t=void 0){const s=this.safeString(e,"transId"),i=this.safeString(e,"ccy"),n=this.safeCurrencyCode(i,t),r=this.safeNumber(e,"amt"),a=this.safeString(e,"from"),o=this.safeString(e,"to"),d=this.safeValue(this.options,"accountsById",{}),c=this.safeString(d,a),u=this.safeString(d,o),h=this.milliseconds(),l=this.safeString(e,"state");return{info:e,id:s,timestamp:h,datetime:this.iso8601(h),currency:n,amount:r,fromAccount:c,toAccount:u,status:l}}async fetchTransfer(e,t=void 0,s={}){await this.loadMarkets();const i={transId:e},n=await this.privateGetAssetTransferState(this.extend(i,s)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0);return this.parseTransfer(a)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=Array.isArray(i),o="/api/"+this.version+"/"+this.implodeParams(e,i),d=this.omit(i,this.extractParams(e));let c=this.implodeHostname(this.urls.api.rest)+o;if(t==="public")Object.keys(d).length&&(c+="?"+this.urlencode(d));else if(t==="private"){this.checkRequiredCredentials();const u=this.iso8601(this.milliseconds());n={"OK-ACCESS-KEY":this.apiKey,"OK-ACCESS-PASSPHRASE":this.password,"OK-ACCESS-TIMESTAMP":u};let h=u+s+o;if(s==="GET"){if(Object.keys(d).length){const p="?"+this.urlencode(d);c+=p,h+=p}}else(a||Object.keys(d).length)&&(r=this.json(d),h+=r),n["Content-Type"]="application/json";const l=this.hmac(this.encode(h),this.encode(this.secret),"sha256","base64");n["OK-ACCESS-SIGN"]=l}return{url:c,method:s,body:r,headers:n}}parseFundingRate(e,t=void 0){const s=this.safeInteger(e,"nextFundingTime"),i=this.safeString(e,"instId"),n=this.safeSymbol(i,t),r=this.safeNumber(e,"nextFundingRate"),a=this.safeInteger(e,"fundingTime");return{info:e,symbol:n,markPrice:void 0,indexPrice:void 0,interestRate:this.parseNumber("0"),estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeNumber(e,"fundingRate"),fundingTimestamp:a,fundingDatetime:this.iso8601(a),nextFundingRate:r,nextFundingTimestamp:s,nextFundingDatetime:this.iso8601(s),previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new be(this.id+" fetchFundingRate() is only valid for swap markets");const i={instId:s.id},n=await this.publicGetPublicFundingRate(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0,{});return this.parseFundingRate(a,s)}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={type:"8"};s!==void 0&&(n.limit=s.toString());let r;e!==void 0&&(r=this.market(e),e=r.symbol,r.contract&&(r.linear?(n.ctType="linear",n.ccy=r.quoteId):(n.ctType="inverse",n.ccy=r.baseId)));const[a,o]=this.handleMarketTypeAndParams("fetchFundingHistory",r,i);a==="swap"&&(n.instType=this.convertToInstrumentType(a));const d=await this.privateGetAccountBillsArchive(this.extend(n,o)),c=this.safeValue(d,"data",[]),u=[];for(let l=0;l<c.length;l++){const p=c[l],m=this.safeInteger(p,"ts"),g=this.safeString(p,"instId"),y=this.safeMarket(g),b=this.safeString(p,"ccy"),w=this.safeCurrencyCode(b);u.push({info:p,symbol:y.symbol,code:w,timestamp:m,datetime:this.iso8601(m),id:this.safeString(p,"billId"),amount:this.safeNumber(p,"balChg")})}const h=this.sortBy(u,"timestamp");return this.filterBySymbolSinceLimit(h,e,t,s)}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new Li(this.id+" setLeverage() requires a symbol argument");if(e<1||e>125)throw new kt(this.id+" setLeverage() leverage should be between 1 and 125");await this.loadMarkets();const i=this.market(t);let n;if([n,s]=this.handleMarginModeAndParams("setLeverage",s),n===void 0&&(n=this.safeString(s,"mgnMode","cross")),n!=="cross"&&n!=="isolated")throw new kt(this.id+" setLeverage() requires a marginMode parameter that must be either cross or isolated");const r={lever:e,mgnMode:n,instId:i.id},a=this.safeString(s,"posSide");if(n==="isolated"){if(a===void 0)throw new Li(this.id+" setLeverage() requires a posSide argument for isolated margin");if(a!=="long"&&a!=="short")throw new kt(this.id+' setLeverage() requires the posSide argument to be either "long" or "short"')}return await this.privatePostAccountSetLeverage(this.extend(r,s))}async setPositionMode(e,t=void 0,s={}){let i;e?i="long_short_mode":i="net_mode";const n={posMode:i};return await this.privatePostAccountSetPositionMode(this.extend(n,s))}async setMarginMode(e,t=void 0,s={}){if(t===void 0)throw new Li(this.id+" setMarginMode() requires a symbol argument");if(e=e.toLowerCase(),e!=="cross"&&e!=="isolated")throw new kt(this.id+" setMarginMode() marginMode must be either cross or isolated");await this.loadMarkets();const i=this.market(t),n=this.safeInteger(s,"lever");if(n===void 0||n<1||n>125)throw new kt(this.id+' setMarginMode() params["lever"] should be between 1 and 125');s=this.omit(s,["lever"]);const r={lever:n,mgnMode:e,instId:i.id};return await this.privatePostAccountSetLeverage(this.extend(r,s))}async fetchBorrowRates(e={}){await this.loadMarkets();const t=await this.privateGetAccountInterestRate(e),s=this.milliseconds(),i=this.safeValue(t,"data"),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeCurrencyCode(this.safeString(a,"ccy"));n[o]={currency:o,rate:this.safeNumber(a,"interestRate"),period:864e5,timestamp:s,datetime:this.iso8601(s),info:a}}return n}async fetchBorrowRate(e,t={}){await this.loadMarkets();const i={ccy:this.currency(e).id},n=await this.privateGetAccountInterestRate(this.extend(i,t)),r=this.safeValue(n,"data"),a=this.safeValue(r,0);return this.parseBorrowRate(a)}parseBorrowRate(e,t=void 0){const s=this.safeString(e,"ccy"),i=this.safeInteger(e,"ts");return{currency:this.safeCurrencyCode(s),rate:this.safeNumber2(e,"interestRate","rate"),period:864e5,timestamp:i,datetime:this.iso8601(i),info:e}}parseBorrowRateHistories(e,t,s,i){const n={};for(let a=0;a<e.length;a++){const o=e[a],d=this.safeCurrencyCode(this.safeString(o,"ccy"));if(t===void 0||this.inArray(d,t)){d in n||(n[d]=[]);const c=this.parseBorrowRate(o);n[d].push(c)}}const r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a];n[o]=this.filterByCurrencySinceLimit(n[o],o,s,i)}return n}parseBorrowRateHistory(e,t,s,i){const n=[];for(let a=0;a<e.length;a++){const o=e[a],d=this.parseBorrowRate(o);n.push(d)}const r=this.sortBy(n,"timestamp");return this.filterByCurrencySinceLimit(r,t,s,i)}async fetchBorrowRateHistories(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};t!==void 0&&(n.before=t),s!==void 0&&(n.limit=s);const r=await this.publicGetAssetLendingRateHistory(this.extend(n,i)),a=this.safeValue(r,"data");return this.parseBorrowRateHistories(a,e,t,s)}async fetchBorrowRateHistory(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={ccy:this.currency(e).id};t!==void 0&&(r.before=t),s!==void 0&&(r.limit=s);const a=await this.publicGetAssetLendingRateHistory(this.extend(r,i)),o=this.safeValue(a,"data");return this.parseBorrowRateHistory(o,e,t,s)}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets();const n=this.market(e),r=this.safeString(i,"posSide","net");i=this.omit(i,["posSide"]);const a={instId:n.id,amt:t,type:s,posSide:r},o=await this.privatePostAccountPositionMarginBalance(this.extend(a,i));return this.parseMarginModification(o,n)}parseMarginModification(e,t=void 0){const s=this.safeValue(e,"data",[]),i=this.safeValue(s,0,{}),r=this.safeString(e,"code")==="0"?"ok":"failed",a=this.safeNumber(i,"amt"),d=this.safeString(i,"type")==="reduce"?"reduce":"add",c=this.safeString(i,"instId"),u=this.safeMarket(c,t),h=u.inverse?u.base:u.quote;return{info:e,type:d,amount:a,code:h,symbol:u.symbol,status:r}}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"reduce",s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"add",s)}async fetchMarketLeverageTiers(e,t={}){await this.loadMarkets();const s=this.market(e),i=s.spot?"MARGIN":this.convertToInstrumentType(s.type),n=this.safeString(s.info,"uly");if(!n&&i!=="MARGIN")throw new kt(this.id+" fetchMarketLeverageTiers() cannot fetch leverage tiers for "+e);let r;[r,t]=this.handleMarginModeAndParams("fetchMarketLeverageTiers",t),r===void 0&&(r=this.safeString(t,"tdMode","cross"));const a={instType:i,tdMode:r,uly:n};i==="MARGIN"&&(a.instId=s.id);const o=await this.publicGetPublicPositionTiers(this.extend(a,t)),d=this.safeValue(o,"data");return this.parseMarketLeverageTiers(d,s)}parseMarketLeverageTiers(e,t=void 0){const s=[];for(let i=0;i<e.length;i++){const n=e[i];s.push({tier:this.safeInteger(n,"tier"),currency:t.quote,minNotional:this.safeNumber(n,"minSz"),maxNotional:this.safeNumber(n,"maxSz"),maintenanceMarginRate:this.safeNumber(n,"mmr"),maxLeverage:this.safeNumber(n,"maxLever"),info:n})}return s}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;[r,n]=this.handleMarginModeAndParams("fetchBorrowInterest",n),r===void 0&&(r=this.safeString(n,"mgnMode","cross"));const a={mgnMode:r};let o;if(e!==void 0){const h=this.currency(e);a.ccy=h.id}s!==void 0&&(a.before=s-1),i!==void 0&&(a.limit=i),t!==void 0&&(o=this.market(t),a.instId=o.id);const d=await this.privateGetAccountInterestAccrued(this.extend(a,n)),c=this.safeValue(d,"data"),u=this.parseBorrowInterests(c);return this.filterByCurrencySinceLimit(u,e,s,i)}parseBorrowInterest(e,t=void 0){const s=this.safeString(e,"instId");s!==void 0&&(t=this.safeMarket(s,t));const i=this.safeInteger(e,"ts");return{symbol:this.safeString(t,"symbol"),marginMode:this.safeString(e,"mgnMode"),currency:this.safeCurrencyCode(this.safeString(e,"ccy")),interest:this.safeNumber(e,"interest"),interestRate:this.safeNumber(e,"interestRate"),amountBorrowed:this.safeNumber(e,"liab"),timestamp:i,datetime:this.iso8601(i),info:e}}async borrowMargin(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.currency(e),r={ccy:n.id,amt:this.currencyToPrecision(e,t),side:"borrow"},a=await this.privatePostAccountBorrowRepay(this.extend(r,i)),o=this.safeValue(a,"data",[]),d=this.safeValue(o,0),c=this.parseMarginLoan(d,n);return this.extend(c,{symbol:s})}async repayMargin(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.currency(e),r={ccy:n.id,amt:this.currencyToPrecision(e,t),side:"repay"},a=await this.privatePostAccountBorrowRepay(this.extend(r,i)),o=this.safeValue(a,"data",[]),d=this.safeValue(o,0),c=this.parseMarginLoan(d,n);return this.extend(c,{symbol:s})}parseMarginLoan(e,t=void 0){const s=this.safeString(e,"ccy");return{id:void 0,currency:this.safeCurrencyCode(s,t),amount:this.safeNumber(e,"amt"),symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}async fetchOpenInterest(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.contract)throw new kt(this.id+" fetchOpenInterest() supports contract markets only");const i=this.convertToInstrumentType(s.type),n=this.safeString(s.info,"uly"),r={instType:i,uly:n,instId:s.id},a=await this.publicGetPublicOpenInterest(this.extend(r,t)),o=this.safeValue(a,"data",[]);return this.parseOpenInterest(o[0],s)}async fetchOpenInterestHistory(e,t="5m",s=void 0,i=void 0,n={}){const r=this.safeValue(this.options,"fetchOpenInterestHistory",{}),a=this.safeValue(r,"timeframes",{});if(t=this.safeString(a,t,t),t!=="5m"&&t!=="1H"&&t!=="1D")throw new kt(this.id+" fetchOpenInterestHistory cannot only use the 5m, 1h, and 1d timeframe");await this.loadMarkets();const d={ccy:this.currency(e).id,period:t};s!==void 0&&(d.begin=s);const c=this.safeInteger2(n,"till","until");c!==void 0&&(d.end=c,n=this.omit(n,["until","till"]));const u=await this.publicGetRubikStatContractsOpenInterestVolume(this.extend(d,n)),h=this.safeValue(u,"data");return this.parseOpenInterests(h,void 0,s,i)}parseOpenInterest(e,t=void 0){const s=this.safeString(e,"instId");t=this.safeMarket(s,t);const i=this.safeInteger(e,"ts"),n=this.safeNumber(e,0,i),r=this.safeNumber(e,"oi"),a=this.safeNumber(e,"oiCcy"),o=this.safeNumber(e,1,a);return{symbol:this.safeSymbol(s),baseVolume:void 0,quoteVolume:o,openInterestAmount:r,openInterestValue:o,timestamp:n,datetime:this.iso8601(n),info:e}}setSandboxMode(e){super.setSandboxMode(e),e?this.headers["x-simulated-trading"]="1":"x-simulated-trading"in this.headers&&(this.headers=this.omit(this.headers,"x-simulated-trading"))}handleErrors(e,t,s,i,n,r,a,o,d){if(!a)return;const c=this.safeString(a,"code");if(c!=="0"){const u=this.id+" "+r,h=this.safeValue(a,"data",[]);for(let l=0;l<h.length;l++){const p=h[l],m=this.safeString(p,"sCode"),g=this.safeString(p,"sMsg");this.throwExactlyMatchedException(this.exceptions.exact,m,u),this.throwBroadlyMatchedException(this.exceptions.broad,g,u)}throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),new be(u)}}};const rG=Eb;var iC=class extends rG{describe(){return this.deepExtend(super.describe(),{id:"okex",alias:!0})}};const aG=iC;var oG=class extends aG{describe(){return this.deepExtend(super.describe(),{id:"okex5",alias:!0})}};const dG=ge,{ExchangeError:ng}=de,{TICK_SIZE:cG}=me,uG=Se;var fG=class extends dG{describe(){return this.deepExtend(super.describe(),{id:"paymium",name:"Paymium",countries:["FR","EU"],rateLimit:2e3,version:"v1",has:{CORS:!0,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,fetchBalance:!0,fetchDepositAddress:!0,fetchDepositAddresses:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarkOHLCV:!1,fetchOpenInterestHistory:!1,fetchOrderBook:!0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,transfer:!0},urls:{logo:"https://user-images.githubusercontent.com/51840849/87153930-f0f02200-c2c0-11ea-9c0a-40337375ae89.jpg",api:{rest:"https://paymium.com/api"},www:"https://www.paymium.com",fees:"https://www.paymium.com/page/help/fees",doc:["https://github.com/Paymium/api-documentation","https://www.paymium.com/page/developers","https://paymium.github.io/api-documentation/"],referral:"https://www.paymium.com/page/sign-up?referral=eDAzPoRQFMvaAB8sf-qj"},api:{public:{get:["countries","data/{currency}/ticker","data/{currency}/trades","data/{currency}/depth","bitcoin_charts/{id}/trades","bitcoin_charts/{id}/depth"]},private:{get:["user","user/addresses","user/addresses/{address}","user/orders","user/orders/{uuid}","user/price_alerts","merchant/get_payment/{uuid}"],post:["user/addresses","user/orders","user/withdrawals","user/email_transfers","user/payment_requests","user/price_alerts","merchant/create_payment"],delete:["user/orders/{uuid}","user/orders/{uuid}/cancel","user/price_alerts/{id}"]}},markets:{"BTC/EUR":{id:"eur",symbol:"BTC/EUR",base:"BTC",quote:"EUR",baseId:"btc",quoteId:"eur",type:"spot",spot:!0}},fees:{trading:{maker:this.parseNumber("-0.001"),taker:this.parseNumber("0.005")}},precisionMode:cG})}parseBalance(e){const t={info:e},s=Object.keys(this.currencies);for(let i=0;i<s.length;i++){const n=s[i],a=this.currency(n).id,o="balance_"+a;if(o in e){const d=this.account(),c="locked_"+a;d.free=this.safeString(e,o),d.used=this.safeString(e,c),t[n]=d}}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetUser(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={currency:i.id},r=await this.publicGetDataCurrencyDepth(this.extend(n,s));return this.parseOrderBook(r,i.symbol,void 0,"bids","asks","price","amount")}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeTimestamp(e,"at"),n=this.safeString(e,"vwap"),r=this.safeString(e,"volume"),a=uG.stringMul(r,n),o=this.safeString(e,"price");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:n,open:this.safeString(e,"open"),close:o,last:o,previousClose:void 0,change:void 0,percentage:this.safeString(e,"variation"),average:void 0,baseVolume:r,quoteVolume:a,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={currency:s.id},n=await this.publicGetDataCurrencyTicker(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t){const s=this.safeTimestamp(e,"created_at_int"),i=this.safeString(e,"uuid");t=this.safeMarket(void 0,t);const n=this.safeString(e,"side"),r=this.safeString(e,"price"),a="traded_"+t.base.toLowerCase(),o=this.safeString(e,a);return this.safeTrade({info:e,id:i,order:void 0,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:void 0,side:n,takerOrMaker:void 0,price:r,amount:o,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={currency:n.id},a=await this.publicGetDataCurrencyTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async createDepositAddress(e,t={}){await this.loadMarkets();const s=await this.privatePostUserAddresses(t);return this.parseDepositAddress(s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s={address:e},i=await this.privateGetUserAddressesAddress(this.extend(s,t));return this.parseDepositAddress(i)}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetUserAddresses(t);return this.parseDepositAddresses(s,e)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"currency");return{info:e,currency:this.safeCurrencyCode(i,t),address:s,tag:void 0,network:void 0}}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={type:this.capitalize(t)+"Order",currency:a.id,direction:s,amount:i};t!=="market"&&(o.price=n);const d=await this.privatePostUserOrders(this.extend(o,r));return{info:d,id:d.uuid}}async cancelOrder(e,t=void 0,s={}){const i={uuid:e};return await this.privateDeleteUserOrdersUuidCancel(this.extend(i,s))}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e);if(i.indexOf("@")<0)throw new ng(this.id+" transfer() only allows transfers to an email address");if(e!=="BTC"&&e!=="EUR")throw new ng(this.id+" transfer() only allows BTC or EUR");const a={currency:r.id,amount:this.currencyToPrecision(e,t),email:i},o=await this.privatePostUserEmailTransfers(this.extend(a,n));return this.parseTransfer(o,r)}parseTransfer(e,t=void 0){const s=this.safeString(e,"currency"),i=this.safeString(e,"updated_at"),n=this.parseDate(i),r=this.safeValue(e,"account_operations"),a=this.safeValue(r,0,{}),o=this.safeString(e,"state");return{info:e,id:this.safeString(e,"uuid"),timestamp:n,datetime:this.iso8601(n),currency:this.safeCurrencyCode(s,t),amount:this.safeNumber(e,"amount"),fromAccount:void 0,toAccount:this.safeString(a,"address"),status:this.parseTransferStatus(o)}}parseTransferStatus(e){const t={executed:"ok"};return this.safeString(t,e,e)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(t==="public")Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials();const d=this.nonce().toString();let c=d+a;if(n={"Api-Key":this.apiKey,"Api-Nonce":d},s==="POST")Object.keys(o).length&&(r=this.json(o),c+=r,n["Content-Type"]="application/json");else if(Object.keys(o).length){const u=this.urlencode(o);c+=u,a+="?"+u}n["Api-Signature"]=this.hmac(this.encode(c),this.encode(this.secret))}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;if(this.safeValue(a,"errors")!==void 0)throw new ng(this.id+" "+this.json(a))}};const hG=ge,{ExchangeError:Ns,BadSymbol:Uc,AuthenticationError:rg,InsufficientFunds:zn,InvalidOrder:ve,ArgumentsRequired:Vs,OrderNotFound:hh,BadRequest:$s,PermissionDenied:lh,AccountSuspended:lG,CancelPending:ph,DDoSProtection:nT,DuplicateOrderId:ag,RateLimitExceeded:pG}=de,{TICK_SIZE:mG}=me,ps=Se;var nC=class extends hG{describe(){return this.deepExtend(super.describe(),{id:"phemex",name:"Phemex",countries:["CN"],rateLimit:100,version:"v1",certified:!1,pro:!0,hostname:"api.phemex.com",has:{CORS:void 0,spot:!0,margin:!1,swap:!0,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistories:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!0,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransfers:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!0,setMargin:!0,setMarginMode:!0,setPositionMode:!1,transfer:!0,withdraw:void 0},urls:{logo:"https://user-images.githubusercontent.com/1294454/85225056-221eb600-b3d7-11ea-930d-564d2690e3f6.jpg",test:{v1:"https://testnet-api.phemex.com/v1",public:"https://testnet-api.phemex.com/exchange/public",private:"https://testnet-api.phemex.com"},api:{v1:"https://{hostname}/v1",public:"https://{hostname}/exchange/public",private:"https://{hostname}"},www:"https://phemex.com",doc:"https://github.com/phemex/phemex-api-docs",fees:"https://phemex.com/fees-conditions",referral:{url:"https://phemex.com/register?referralCode=EDNVJ",discount:.1}},timeframes:{"1m":"60","3m":"180","5m":"300","15m":"900","30m":"1800","1h":"3600","2h":"7200","3h":"10800","4h":"14400","6h":"21600","12h":"43200","1d":"86400","1w":"604800","1M":"2592000"},api:{public:{get:["cfg/v2/products","cfg/fundingRates","products","nomics/trades","md/kline"]},v1:{get:["md/orderbook","md/trade","md/ticker/24hr","md/ticker/24hr/all","md/spot/ticker/24hr","md/spot/ticker/24hr/all","exchange/public/products"]},private:{get:["spot/orders/active","spot/orders","spot/wallets","exchange/spot/order","exchange/spot/order/trades","accounts/accountPositions","accounts/positions","api-data/futures/funding-fees","orders/activeList","exchange/order/list","exchange/order","exchange/order/trade","phemex-user/users/children","phemex-user/wallets/v2/depositAddress","phemex-user/wallets/tradeAccountDetail","phemex-user/order/closedPositionList","exchange/margins/transfer","exchange/wallets/confirm/withdraw","exchange/wallets/withdrawList","exchange/wallets/depositList","exchange/wallets/v2/depositAddress","api-data/spots/funds","assets/convert","assets/transfer","assets/spots/sub-accounts/transfer","assets/futures/sub-accounts/transfer","assets/quote","assets/convert"],post:["spot/orders","orders","positions/assign","exchange/wallets/transferOut","exchange/wallets/transferIn","exchange/margins","exchange/wallets/createWithdraw","exchange/wallets/cancelWithdraw","exchange/wallets/createWithdrawAddress","assets/transfer","assets/spots/sub-accounts/transfer","assets/futures/sub-accounts/transfer","assets/universal-transfer","assets/convert"],put:["spot/orders","orders/replace","positions/leverage","positions/riskLimit"],delete:["spot/orders","spot/orders/all","orders/cancel","orders","orders/all"]}},precisionMode:mG,fees:{trading:{tierBased:!1,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0.001")}},requiredCredentials:{apiKey:!0,secret:!0},exceptions:{exact:{412:$s,6001:$s,19999:$s,10001:ag,10002:hh,10003:ph,10004:ph,10005:ph,11001:zn,11002:ve,11003:zn,11004:ve,11005:zn,11006:Ns,11007:Ns,11008:Ns,11009:Ns,11010:zn,11011:ve,11012:ve,11013:ve,11014:ve,11015:ve,11016:$s,11017:Ns,11018:Ns,11019:Ns,11020:Ns,11021:Ns,11022:lG,11023:Ns,11024:Ns,11025:$s,11026:Ns,11027:Uc,11028:Uc,11029:Ns,11030:Ns,11031:nT,11032:nT,11033:ag,11034:ve,11035:ve,11036:ve,11037:ve,11038:ve,11039:ve,11040:ve,11041:ve,11042:ve,11043:ve,11044:ve,11045:ve,11046:ve,11047:ve,11048:ve,11049:ve,11050:ve,11051:ve,11052:ve,11053:ve,11054:ve,11055:ve,11056:ve,11057:ve,11058:ve,11059:ve,11060:ve,11061:ph,11062:ve,11063:ve,11064:ve,11065:ve,11066:ve,11067:ve,11068:ve,11069:Ns,11070:Uc,11071:ve,11072:ve,11073:ve,11074:ve,11075:ve,11076:ve,11077:ve,11078:ve,11079:ve,11080:ve,11081:ve,11082:zn,11083:ve,11084:ve,11085:ag,11086:ve,11087:ve,11088:ve,11089:ve,11090:ve,11091:ve,11092:ve,11093:ve,11094:ve,11095:ve,11096:ve,11097:$s,11098:$s,11099:Ns,11100:zn,11101:zn,11102:$s,11103:$s,11104:$s,11105:zn,11106:zn,11107:Ns,11108:ve,11109:ve,11110:ve,11111:ve,11112:ve,11113:$s,11114:ve,11115:ve,11116:ve,11117:ve,11118:ve,11119:ve,11120:ve,11121:ve,11122:ve,11123:ve,11124:ve,11125:ve,11126:ve,11128:ve,11129:ve,11130:ve,11131:ve,11132:ve,11133:ve,11134:ve,3e4:$s,30018:$s,34003:lh,35104:zn,39995:pG,39996:lh},broad:{"401 Insufficient privilege":lh,"401 Request IP mismatch":lh,"Failed to find api-key":rg,"Missing required parameter":$s,"API Signature verification failed":rg,"Api key not found":rg}},options:{brokerId:"ccxt2022","x-phemex-request-expiry":60,createOrderByQuoteRequiresPrice:!0,networks:{TRC20:"TRX",ERC20:"ETH"},defaultNetworks:{USDT:"ETH"},defaultSubType:"linear",accountsByType:{spot:"spot",future:"future"},transfer:{fillResponseFromRequest:!0}}})}parseSafeNumber(e=void 0){if(e===void 0)return e;let t=e.split(",");return e=t.join(""),t=e.split(" "),this.safeNumber(t,0)}parseSwapMarket(e){const t=this.safeString(e,"symbol"),s=this.safeString2(e,"baseCurrency","contractUnderlyingAssets"),i=this.safeString(e,"quoteCurrency"),n=this.safeString(e,"settleCurrency"),r=this.safeCurrencyCode(s),a=this.safeCurrencyCode(i),o=this.safeCurrencyCode(n);let d=!1;n!==i&&(d=!0);const c=this.safeInteger(e,"priceScale"),u=this.safeInteger(e,"ratioScale"),h=this.safeInteger(e,"valueScale"),l=this.safeString(e,"minPriceEp"),p=this.safeString(e,"maxPriceEp"),m=this.safeString(e,"makerFeeRateEr"),g=this.safeString(e,"takerFeeRateEr"),y=this.safeString(e,"status"),b=this.safeString(e,"contractSize"," ");let w;if(b.indexOf(" ")){const k=b.split(" ");w=this.parseNumber(k[0])}else w=this.parseNumber(b);return{id:t,symbol:r+"/"+a+":"+o,base:r,quote:a,settle:o,baseId:s,quoteId:i,settleId:n,type:"swap",spot:!1,margin:!1,swap:!0,future:!1,option:!1,active:y==="Listed",contract:!0,linear:!d,inverse:d,taker:this.parseNumber(this.fromEn(g,u)),maker:this.parseNumber(this.fromEn(m,u)),contractSize:w,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,priceScale:c,valueScale:h,ratioScale:u,precision:{amount:this.safeNumber(e,"lotSize"),price:this.safeNumber(e,"tickSize")},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(e,"maxLeverage")},amount:{min:void 0,max:void 0},price:{min:this.parseNumber(this.fromEn(l,c)),max:this.parseNumber(this.fromEn(p,c))},cost:{min:void 0,max:this.parseNumber(this.safeString(e,"maxOrderQty"))}},info:e}}parseSpotMarket(e){const t=this.safeStringLower(e,"type"),s=this.safeString(e,"symbol"),i=this.safeString(e,"quoteCurrency"),n=this.safeString(e,"baseCurrency"),r=this.safeCurrencyCode(n),a=this.safeCurrencyCode(i),o=this.safeString(e,"status"),d=this.parseSafeNumber(this.safeString(e,"baseTickSize")),c=this.parseSafeNumber(this.safeString(e,"quoteTickSize"));return{id:s,symbol:r+"/"+a,base:r,quote:a,settle:void 0,baseId:n,quoteId:i,settleId:void 0,type:t,spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:o==="Listed",contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(e,"defaultTakerFee"),maker:this.safeNumber(e,"defaultMakerFee"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,priceScale:8,valueScale:8,ratioScale:8,precision:{amount:d,price:c},limits:{leverage:{min:void 0,max:void 0},amount:{min:d,max:this.parseSafeNumber(this.safeString(e,"maxBaseOrderSize"))},price:{min:c,max:void 0},cost:{min:this.parseSafeNumber(this.safeString(e,"minOrderValue")),max:this.parseSafeNumber(this.safeString(e,"maxOrderValue"))}},info:e}}async fetchMarkets(e={}){const t=await this.publicGetCfgV2Products(e),s=await this.v1GetExchangePublicProducts(e),i=this.safeValue(s,"data",[]),n=this.safeValue(t,"data",{}),r=this.safeValue(n,"products",[]),a=this.safeValue(n,"riskLimits",[]),o=this.indexBy(a,"symbol"),d=this.indexBy(i,"symbol"),c=[];for(let u=0;u<r.length;u++){let h=r[u];if(this.safeStringLower(h,"type")==="perpetual"){const p=this.safeString(h,"symbol"),m=this.safeValue(o,p,{});h=this.extend(h,m);const g=this.safeValue(d,p,{});h=this.extend(h,g),h=this.parseSwapMarket(h)}else h=this.parseSpotMarket(h);c.push(h)}return c}async fetchCurrencies(e={}){const t=await this.publicGetCfgV2Products(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"currencies",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"currency"),d=this.safeString(a,"name"),c=this.safeCurrencyCode(o),u=this.safeString(a,"valueScale"),h=parseInt(u),l=this.safeString(a,"minValueEv"),p=this.safeString(a,"maxValueEv");let m,g,y;if(h!==void 0){const b=this.parsePrecision(u);y=this.parseNumber(b),m=this.parseNumber(ps.stringMul(l,b)),g=this.parseNumber(ps.stringMul(p,b))}n[c]={id:o,info:a,code:c,name:d,active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,precision:y,limits:{amount:{min:m,max:g},withdraw:{min:void 0,max:void 0}},valueScale:h}}return n}parseBidAsk(e,t=0,s=1,i=void 0){if(i===void 0)throw new Vs(this.id+" parseBidAsk() requires a market argument");let n=this.safeString(e,s);return i.spot&&(n=this.fromEv(n,i)),[this.parseNumber(this.fromEp(this.safeString(e,t),i)),this.parseNumber(n)]}parseOrderBook(e,t,s=void 0,i="bids",n="asks",r=0,a=1,o=void 0){const d={symbol:t,timestamp:s,datetime:this.iso8601(s),nonce:void 0},c=[i,n];for(let u=0;u<c.length;u++){const h=c[u],l=[],p=this.safeValue(e,h);for(let m=0;m<p.length;m++)l.push(this.parseBidAsk(p[m],r,a,o));d[h]=l}return d[i]=this.sortBy(d[i],0,!0),d[n]=this.sortBy(d[n],0),d}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id},r=await this.v1GetMdOrderbook(this.extend(n,s)),a=this.safeValue(r,"result",{}),o=this.safeValue(a,"book",{}),d=this.safeIntegerProduct(a,"timestamp",1e-6),c=this.parseOrderBook(o,e,d,"bids","asks",0,1,i);return c.nonce=this.safeInteger(a,"sequence"),c}toEn(e,t){const s=e.toString(),i=new ps(s);i.decimals=i.decimals-t,i.reduce();const n=i.toString();return parseInt(parseFloat(n))}toEv(e,t=void 0){return e===void 0||t===void 0?e:this.toEn(e,t.valueScale)}toEp(e,t=void 0){return e===void 0||t===void 0?e:this.toEn(e,t.priceScale)}fromEn(e,t){if(e===void 0)return;const s=new ps(e);return s.decimals=this.sum(s.decimals,t),s.reduce(),s.toString()}fromEp(e,t=void 0){return e===void 0||t===void 0?e:this.fromEn(e,this.safeInteger(t,"priceScale"))}fromEv(e,t=void 0){return e===void 0||t===void 0?e:this.fromEn(e,this.safeInteger(t,"valueScale"))}fromEr(e,t=void 0){return e===void 0||t===void 0?e:this.fromEn(e,this.safeInteger(t,"ratioScale"))}parseOHLCV(e,t=void 0){let s;return t!==void 0&&t.spot?s=this.parseNumber(this.fromEv(this.safeString(e,7),t)):s=this.safeNumber(e,7),[this.safeTimestamp(e,0),this.parseNumber(this.fromEp(this.safeString(e,3),t)),this.parseNumber(this.fromEp(this.safeString(e,4),t)),this.parseNumber(this.fromEp(this.safeString(e,5),t)),this.parseNumber(this.fromEp(this.safeString(e,6),t)),s]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){const r={resolution:this.timeframes[t]},a=this.parseTimeframe(t),o=this.seconds(),d=2e3;i===void 0?i=100:i=Math.min(i,d),s!==void 0?(i=Math.min(i,d),s=parseInt(s/1e3),r.from=s,r.to=Math.min(o,this.sum(s,a*i))):(i<d&&(i=i+1),r.from=o-a*i,r.to=o),await this.loadMarkets();const c=this.market(e);r.symbol=c.id;const u=await this.publicGetMdKline(this.extend(r,n)),h=this.safeValue(u,"data",{}),l=this.safeValue(h,"rows",[]);return this.parseOHLCVs(l,c,t,s,i)}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeIntegerProduct(e,"timestamp",1e-6),r=this.fromEp(this.safeString(e,"lastEp"),t),a=this.fromEv(this.safeString(e,"turnoverEv"),t);let o=this.safeString(e,"volume");o===void 0&&(o=this.fromEv(this.safeString(e,"volumeEv"),t));const d=this.fromEp(this.safeString(e,"openEp"),t);return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.fromEp(this.safeString(e,"highEp"),t),low:this.fromEp(this.safeString(e,"lowEp"),t),bid:this.fromEp(this.safeString(e,"bidEp"),t),bidVolume:void 0,ask:this.fromEp(this.safeString(e,"askEp"),t),askVolume:void 0,vwap:void 0,open:d,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:o,quoteVolume:a,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=s.spot?"v1GetMdSpotTicker24hr":"v1GetMdTicker24hr",r=await this[n](this.extend(i,t)),a=this.safeValue(r,"result",{});return this.parseTicker(a,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=await this.v1GetMdTrade(this.extend(r,i)),o=this.safeValue(a,"result",{}),d=this.safeValue(o,"trades",[]);return this.parseTrades(d,n,t,s)}parseTrade(e,t=void 0){let s,i,n,r,a,o,d,c;const u=this.safeString(e,"symbol");t=this.safeMarket(u,t);const h=t.symbol;let l,p;if(Array.isArray(e)){const m=e.length;n=this.safeIntegerProduct(e,0,1e-6),m>4&&(r=this.safeString(e,m-4)),a=this.safeStringLower(e,m-3),s=this.fromEp(this.safeString(e,m-2),t),i=this.fromEv(this.safeString(e,m-1),t)}else{n=this.safeIntegerProduct(e,"transactTimeNs",1e-6),r=this.safeString2(e,"execId","execID"),l=this.safeString(e,"orderID"),a=this.safeStringLower(e,"side"),d=this.parseOrderType(this.safeString(e,"ordType")),this.safeString(e,"execStatus")==="MakerFill"&&(p="maker"),s=this.fromEp(this.safeString(e,"execPriceEp"),t),i=this.fromEv(this.safeString(e,"execBaseQtyEv"),t),i=this.safeString(e,"execQty",i),o=this.fromEv(this.safeString2(e,"execQuoteQtyEv","execValueEv"),t);const g=this.fromEv(this.safeString(e,"execFeeEv"),t);if(g!==void 0){const y=this.fromEr(this.safeString(e,"feeRateEr"),t);let b;if(t.spot)b=a==="buy"?t.base:t.quote;else{const w=this.safeValue(t,"info");if(w!==void 0){const k=this.safeString(w,"settlementCurrency");b=this.safeCurrencyCode(k)}}c={cost:g,rate:y,currency:b}}}return this.safeTrade({info:e,id:r,symbol:h,timestamp:n,datetime:this.iso8601(n),order:l,type:d,side:a,takerOrMaker:p,price:s,amount:i,cost:o,fee:c},t)}parseSpotBalance(e){let t;const s={info:e},i=this.safeValue(e,"data",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.safeValue(this.currencies,o,{}),c=this.safeInteger(d,"valueScale",8),u=this.account(),h=this.safeString(r,"balanceEv"),l=this.safeString(r,"lockedTradingBalanceEv"),p=this.safeString(r,"lockedWithdrawEv"),m=this.fromEn(h,c),g=this.fromEn(l,c),y=this.fromEn(p,c),b=ps.stringAdd(g,y),w=this.safeIntegerProduct(r,"lastUpdateTimeNs",1e-6);t=t===void 0?w:Math.max(t,w),u.total=m,u.used=b,s[o]=u}return s.timestamp=t,s.datetime=this.iso8601(t),this.safeBalance(s)}parseSwapBalance(e){const t={info:e},s=this.safeValue(e,"data",{}),i=this.safeValue(s,"account",{}),n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.currency(r),o=this.account(),d=this.safeString(i,"accountBalanceEv"),c=this.safeString(i,"totalUsedBalanceEv"),u=this.safeInteger(a,"valueScale",8);return o.total=this.fromEn(d,u),o.used=this.fromEn(c,u),t[r]=o,this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString2(this.options,"defaultType","fetchBalance","spot"),s=this.safeString(e,"type",t);let i="privateGetSpotWallets";const n={};if(s==="swap"){const o=this.safeString(e,"code");if(o!==void 0){const d=this.currency(o);n.currency=d.id,e=this.omit(e,"code")}else if(this.safeString(e,"currency")===void 0)throw new Vs(this.id+" fetchBalance() requires a code parameter or a currency parameter for "+s+" type");i="privateGetAccountsAccountPositions"}e=this.omit(e,"type");const r=await this[i](this.extend(n,e));return s==="swap"?this.parseSwapBalance(r):this.parseSpotBalance(r)}parseOrderStatus(e){const t={Created:"open",Untriggered:"open",Deactivated:"closed",Triggered:"open",Rejected:"rejected",New:"open",PartiallyFilled:"open",Filled:"closed",Canceled:"canceled"};return this.safeString(t,e,e)}parseOrderType(e){const t={Limit:"limit",Market:"market"};return this.safeString(t,e,e)}parseTimeInForce(e){const t={GoodTillCancel:"GTC",PostOnly:"PO",ImmediateOrCancel:"IOC",FillOrKill:"FOK"};return this.safeString(t,e,e)}parseSpotOrder(e,t=void 0){const s=this.safeString(e,"orderID");let i=this.safeString(e,"clOrdID");i!==void 0&&i.length<1&&(i=void 0);const n=this.safeString(e,"symbol"),r=this.safeSymbol(n,t),a=this.fromEp(this.safeString(e,"priceEp"),t),o=this.fromEv(this.safeString(e,"baseQtyEv"),t),d=this.omitZero(this.fromEv(this.safeString(e,"leavesBaseQtyEv"),t)),c=this.fromEv(this.safeString2(e,"cumBaseQtyEv","cumBaseValueEv"),t),u=this.fromEv(this.safeString2(e,"cumQuoteValueEv","quoteQtyEv"),t),h=this.fromEp(this.safeString(e,"avgPriceEp"),t),l=this.parseOrderStatus(this.safeString(e,"ordStatus")),p=this.safeStringLower(e,"side"),m=this.parseOrderType(this.safeString(e,"ordType")),g=this.safeIntegerProduct2(e,"actionTimeNs","createTimeNs",1e-6);let y;const b=this.fromEv(this.safeString(e,"cumFeeEv"),t);b!==void 0&&(y={cost:b,currency:void 0});const w=this.parseTimeInForce(this.safeString(e,"timeInForce")),k=this.parseNumber(this.omitZero(this.fromEp(this.safeString(e,"stopPxEp",t)))),T=w==="PO";return this.safeOrder({info:e,id:s,clientOrderId:i,timestamp:g,datetime:this.iso8601(g),lastTradeTimestamp:void 0,symbol:r,type:m,timeInForce:w,postOnly:T,side:p,price:a,stopPrice:k,amount:o,cost:u,average:h,filled:c,remaining:d,status:l,fee:y,trades:void 0},t)}parseSwapOrder(e,t=void 0){const s=this.safeString(e,"orderID");let i=this.safeString(e,"clOrdID");i!==void 0&&i.length<1&&(i=void 0);const n=this.safeString(e,"symbol"),r=this.safeSymbol(n,t),a=this.parseOrderStatus(this.safeString(e,"ordStatus")),o=this.safeStringLower(e,"side"),d=this.parseOrderType(this.safeString(e,"orderType")),c=this.parseNumber(this.fromEp(this.safeString(e,"priceEp"),t)),u=this.safeNumber(e,"orderQty"),h=this.safeNumber(e,"cumQty"),l=this.safeNumber(e,"leavesQty"),p=this.safeIntegerProduct(e,"actionTimeNs",1e-6),m=this.safeNumber(e,"cumValue");let g=this.safeIntegerProduct(e,"transactTimeNs",1e-6);g===0&&(g=void 0);const y=this.parseTimeInForce(this.safeString(e,"timeInForce")),b=this.safeNumber(e,"stopPx"),w=y==="PO";let k=this.safeValue(e,"reduceOnly");return this.safeString(e,"execInst")==="ReduceOnly"&&(k=!0),{info:e,id:s,clientOrderId:i,datetime:this.iso8601(p),timestamp:p,lastTradeTimestamp:g,symbol:r,type:d,timeInForce:y,postOnly:w,reduceOnly:k,side:o,price:c,stopPrice:b,amount:u,filled:h,remaining:l,cost:m,average:void 0,status:a,fee:void 0,trades:void 0}}parseOrder(e,t=void 0){return"closedPnl"in e?this.parseSwapOrder(e,t):this.parseSpotOrder(e,t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);s=this.capitalize(s),t=this.capitalize(t);const o=this.safeValue(r,"reduceOnly"),d={symbol:a.id,side:s,ordType:t},c=this.safeString2(r,"clOrdID","clientOrderId");if(c===void 0){const y=this.safeString(this.options,"brokerId");y!==void 0&&(d.clOrdID=y+this.uuid16())}else d.clOrdID=c,r=this.omit(r,["clOrdID","clientOrderId"]);const u=this.safeString2(r,"stopPx","stopPrice");if(u!==void 0&&(d.stopPxEp=this.toEp(u,a)),r=this.omit(r,["stopPx","stopPrice"]),a.spot){let y=this.safeValue(r,"qtyType","ByBase");if((t==="Market"||t==="Stop"||t==="MarketIfTouched")&&n!==void 0&&(y="ByQuote"),d.qtyType=y,y==="ByQuote"){let b=this.safeNumber(r,"cost");if(r=this.omit(r,"cost"),this.options.createOrderByQuoteRequiresPrice){if(n!==void 0){const k=this.numberToString(i),T=this.numberToString(n),O=ps.stringMul(k,T);b=this.parseNumber(O)}else if(b===void 0)throw new Vs(this.id+" createOrder() "+y+" requires a price argument or a cost parameter")}b=b===void 0?i:b;const w=b.toString();d.quoteQtyEv=this.toEv(w,a)}else{const b=i.toString();d.baseQtyEv=this.toEv(b,a)}}else if(a.swap&&(o!==void 0&&(d.reduceOnly=o),d.orderQty=parseInt(i),u!==void 0)){const y=this.safeString(r,"triggerType","ByMarkPrice");d.triggerType=y}if(t==="Limit"||t==="StopLimit"||t==="LimitIfTouched"){const y=n.toString();d.priceEp=this.toEp(y,a)}const h=this.safeString(r,"takeProfitPrice");h!==void 0&&(d.takeProfitEp=this.toEp(h,a),r=this.omit(r,"takeProfitPrice"));const l=this.safeString(r,"stopLossPrice");l!==void 0&&(d.stopLossEp=this.toEp(l,a),r=this.omit(r,"stopLossPrice"));const p=a.spot?"privatePostSpotOrders":"privatePostOrders";r=this.omit(r,"reduceOnly");const m=await this[p](this.extend(d,r)),g=this.safeValue(m,"data",{});return this.parseOrder(g,a)}async editOrder(e,t,s=void 0,i=void 0,n=void 0,r=void 0,a={}){if(t===void 0)throw new Vs(this.id+" editOrder() requires a symbol argument");if(s!==void 0)throw new Vs(this.id+" editOrder() type changing is not implemented. Try to cancel & recreate order for that purpose");if(i!==void 0)throw new Vs(this.id+" editOrder() side changing is not implemented. Try to cancel & recreate order for that purpose");await this.loadMarkets();const o=this.market(t),d={symbol:o.id},c=this.safeString2(a,"clientOrderId","clOrdID");a=this.omit(a,["clientOrderId","clOrdID"]),c!==void 0?d.clOrdID=c:d.orderID=e,r!==void 0&&(d.priceEp=this.toEp(r,o));const u=this.safeString(a,"baseQtyEv");a=this.omit(a,["baseQtyEv"]),u!==void 0?d.baseQtyEV=u:n!==void 0&&(d.baseQtyEV=this.toEv(n,o));const h=this.safeString2(a,"stopPx","stopPrice");h!==void 0&&(d.stopPxEp=this.toEp(h,o)),a=this.omit(a,["stopPx","stopPrice"]);const l=o.spot?"privatePutSpotOrders":"privatePutOrdersReplace",p=await this[l](this.extend(d,a)),m=this.safeValue(p,"data",{});return this.parseOrder(m,o)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Vs(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={symbol:i.id},r=this.safeString2(s,"clientOrderId","clOrdID");s=this.omit(s,["clientOrderId","clOrdID"]),r!==void 0?n.clOrdID=r:n.orderID=e;const a=i.spot?"privateDeleteSpotOrders":"privateDeleteOrdersCancel",o=await this[a](this.extend(n,s)),d=this.safeValue(o,"data",{});return this.parseOrder(d,i)}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new Vs(this.id+" cancelAllOrders() requires a symbol argument");await this.loadMarkets();const s={},i=this.market(e);let n="privateDeleteSpotOrdersAll";return i.swap&&(n="privateDeleteOrdersAll"),s.symbol=i.id,await this[n](this.extend(s,t))}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Vs(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=i.spot?"privateGetSpotOrdersActive":"privateGetExchangeOrder",r={symbol:i.id},a=this.safeString2(s,"clientOrderId","clOrdID");s=this.omit(s,["clientOrderId","clOrdID"]),a!==void 0?r.clOrdID=a:r.orderID=e;const o=await this[n](this.extend(r,s)),d=this.safeValue(o,"data",{});let c=d;if(Array.isArray(d)){if(d.length<1)throw a!==void 0?new hh(this.id+" fetchOrder() "+t+" order with clientOrderId "+a+" not found"):new hh(this.id+" fetchOrder() "+t+" order with id "+e+" not found");c=this.safeValue(d,0,{})}return this.parseOrder(c,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Vs(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=n.spot?"privateGetSpotOrders":"privateGetExchangeOrderList",a={symbol:n.id};t!==void 0&&(a.start=t),s!==void 0&&(a.limit=s);const o=await this[r](this.extend(a,i)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"rows",[]);return this.parseOrders(c,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Vs(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=n.spot?"privateGetSpotOrders":"privateGetOrdersActiveList",a={symbol:n.id};let o;try{o=await this[r](this.extend(a,i))}catch(c){if(c instanceof hh)return[]}const d=this.safeValue(o,"data",{});if(Array.isArray(d))return this.parseOrders(d,n,t,s);{const c=this.safeValue(d,"rows",[]);return this.parseOrders(c,n,t,s)}}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Vs(this.id+" fetchClosedOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=n.spot?"privateGetExchangeSpotOrder":"privateGetExchangeOrderList",a={symbol:n.id};t!==void 0&&(a.start=t),s!==void 0&&(a.limit=s);const o=await this[r](this.extend(a,i)),d=this.safeValue(o,"data",{});if(Array.isArray(d))return this.parseOrders(d,n,t,s);{const c=this.safeValue(d,"rows",[]);return this.parseOrders(c,n,t,s)}}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Vs(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=n.spot?"privateGetExchangeSpotOrderTrades":"privateGetExchangeOrderTrade",a={symbol:n.id};t!==void 0&&(a.start=t),n.swap&&s!==void 0&&(a.limit=s);const o=await this[r](this.extend(a,i)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"rows",[]);return this.parseTrades(c,n,t,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=this.safeValue(this.options,"defaultNetworks"),r=this.safeStringUpper(n,e),a=this.safeValue(this.options,"networks",{});let o=this.safeStringUpper(t,"network",r);o=this.safeString(a,o,o),o===void 0?i.chainName=s.id:(i.chainName=o,t=this.omit(t,"network"));const d=await this.privateGetPhemexUserWalletsV2DepositAddress(this.extend(i,t)),c=this.safeValue(d,"data",{}),u=this.safeString(c,"address"),h=this.safeString(c,"tag");return this.checkAddress(u),{currency:e,address:u,tag:h,network:void 0,info:d}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r=await this.privateGetExchangeWalletsDepositList(i),a=this.safeValue(r,"data",{});return this.parseTransactions(a,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r=await this.privateGetExchangeWalletsWithdrawList(i),a=this.safeValue(r,"data",{});return this.parseTransactions(a,n,t,s)}parseTransactionStatus(e){const t={Success:"ok",Succeed:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"address"),n=void 0,r=this.safeString(e,"txHash"),a=this.safeString(e,"currency");t=this.safeCurrency(a,t);const o=t.code,d=this.safeInteger2(e,"createdAt","submitedAt");let c=this.safeStringLower(e,"type");const u=this.parseNumber(this.fromEn(this.safeString(e,"feeEv"),t.valueScale));let h;u!==void 0&&(c="withdrawal",h={cost:u,currency:o});const l=this.parseTransactionStatus(this.safeString(e,"status")),p=this.parseNumber(this.fromEn(this.safeString(e,"amountEv"),t.valueScale));return{info:e,id:s,txid:r,timestamp:d,datetime:this.iso8601(d),network:void 0,address:i,addressTo:i,addressFrom:void 0,tag:n,tagTo:n,tagFrom:void 0,type:c,amount:p,currency:o,status:l,updated:void 0,fee:h}}async fetchPositions(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeString(this.options,"defaultSubType","linear");let i=this.safeString(t,"code");i===void 0?i=s==="linear"?"USD":"BTC":t=this.omit(t,"code");const r={currency:this.currency(i).id},a=await this.privateGetAccountsAccountPositions(this.extend(r,t)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"positions",[]),c=[];for(let u=0;u<d.length;u++){const h=d[u];c.push(this.parsePosition(h))}return this.filterByArray(c,"symbol",e,!1)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeString(e,"positionMargin"),r=this.safeString(e,"value"),a=this.safeString(e,"maintMarginReq"),o=ps.stringMul(r,a),d=this.safeString(e,"assignedPosBalance"),c=ps.stringDiv(d,r),u=this.safeNumber(e,"liquidationPrice"),h=this.safeString(e,"markPrice"),l=this.safeString(e,"size"),p=this.safeValue(t,"contractSize"),m=this.numberToString(p),g=this.safeNumber(e,"leverage"),y=this.safeString(e,"avgEntryPrice"),w=this.safeString(e,"side")==="Buy"?"long":"short";let k;this.safeString(e,"currency")==="USD"?w==="long"?k=ps.stringSub(h,y):k=ps.stringSub(y,h):w==="long"?k=ps.stringSub(ps.stringDiv("1",y),ps.stringDiv("1",h)):k=ps.stringSub(ps.stringDiv("1",h),ps.stringDiv("1",y));const O=ps.stringMul(ps.stringMul(k,l),m),x=ps.stringMul(ps.stringDiv(O,d),"100"),C=ps.stringDiv(o,n);return{info:e,id:void 0,symbol:i,contracts:this.parseNumber(l),contractSize:p,unrealizedPnl:this.parseNumber(O),leverage:g,liquidationPrice:u,collateral:this.parseNumber(n),notional:this.parseNumber(r),markPrice:this.parseNumber(h),entryPrice:this.parseNumber(y),timestamp:void 0,initialMargin:this.parseNumber(d),initialMarginPercentage:this.parseNumber(c),maintenanceMargin:this.parseNumber(o),maintenanceMarginPercentage:this.parseNumber(a),marginRatio:this.parseNumber(C),datetime:void 0,marginMode:void 0,side:w,hedged:!1,percentage:this.parseNumber(x)}}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),e===void 0)throw new Vs(this.id+" fetchFundingHistory() requires a symbol argument");const n=this.market(e),r={symbol:n.id};if(s>200)throw new $s(this.id+" fetchFundingHistory() limit argument cannot exceed 200");s!==void 0&&(r.limit=s);const a=await this.privateGetApiDataFuturesFundingFees(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"rows",[]),c=[];for(let u=0;u<d.length;u++){const h=d[u],l=this.safeInteger(h,"createTime");c.push({info:h,symbol:this.safeString(h,"symbol"),code:this.safeCurrencyCode(this.safeString(h,"currency")),timestamp:l,datetime:this.iso8601(l),id:void 0,amount:this.fromEv(this.safeString(h,"execFeeEv"),n)})}return c}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new Uc(this.id+" fetchFundingRate() supports swap contracts only");const i={symbol:s.id},n=await this.v1GetMdTicker24hr(this.extend(i,t)),r=this.safeValue(n,"result",{});return this.parseFundingRate(r,s)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeIntegerProduct(e,"timestamp",1e-6);return{info:e,symbol:i,markPrice:this.fromEp(this.safeString(e,"markEp"),t),indexPrice:this.fromEp(this.safeString(e,"indexEp"),t),interestRate:void 0,estimatedSettlePrice:void 0,timestamp:n,datetime:this.iso8601(n),fundingRate:this.fromEr(this.safeString(e,"fundingRateEr"),t),fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:this.fromEr(this.safeString(e,"predFundingRateEr"),t),nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async setMargin(e,t,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id,posBalanceEv:this.toEv(t,i)},r=await this.privatePostPositionsAssign(this.extend(n,s));return this.extend(this.parseMarginModification(r,i),{amount:t})}parseMarginStatus(e){const t={0:"ok"};return this.safeString(t,e,e)}parseMarginModification(e,t=void 0){t=this.safeMarket(void 0,t);const i=this.safeValue(t,"inverse")?"base":"quote";return{info:e,type:"set",amount:void 0,total:void 0,code:t[i],symbol:this.safeSymbol(void 0,t),status:this.parseMarginStatus(this.safeString(e,"code"))}}async setMarginMode(e,t=void 0,s={}){if(t===void 0)throw new Vs(this.id+" setMarginMode() requires a symbol argument");if(e=e.toLowerCase(),e!=="isolated"&&e!=="cross")throw new $s(this.id+" setMarginMode() marginMode argument should be isolated or cross");await this.loadMarkets();const i=this.market(t);if(i.type!=="swap")throw new Uc(this.id+" setMarginMode() supports swap contracts only");let n=this.safeInteger(s,"leverage");if(e==="cross"&&(n=0),n===void 0)throw new Vs(this.id+" setMarginMode() requires a leverage parameter");const r={symbol:i.id,leverage:n};return await this.privatePutPositionsLeverage(this.extend(r,s))}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetCfgV2Products(t),i=this.safeValue(s,"data",{}),n=this.safeValue(i,"riskLimits");return this.parseLeverageTiers(n,e,"symbol")}parseMarketLeverageTiers(e,t=void 0){t=this.safeMarket(void 0,t);const s=t.info.riskLimits,i=[];let n=0;for(let r=0;r<s.length;r++){const a=s[r],o=this.safeInteger(a,"limit");i.push({tier:this.sum(r,1),currency:t.settle,minNotional:n,maxNotional:o,maintenanceMarginRate:this.safeString(a,"maintenanceMargin"),maxLeverage:void 0,info:a}),n=o}return i}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.omit(i,this.extractParams(e)),o="/"+this.implodeParams(e,i);let d=o,c="";if((s==="GET"||s==="DELETE"||s==="PUT"||d==="/positions/assign")&&Object.keys(a).length&&(c=this.urlencodeWithArrayRepeat(a),d+="?"+c),t==="private"){this.checkRequiredCredentials();const u=this.seconds(),h=this.safeInteger(this.options,"x-phemex-request-expiry",60),p=this.sum(u,h).toString();n={"x-phemex-access-token":this.apiKey,"x-phemex-request-expiry":p};let m="";s==="POST"&&(m=this.json(i),r=m,n["Content-Type"]="application/json");const g=o+c+p+m;n["x-phemex-request-signature"]=this.hmac(this.encode(g),this.encode(this.secret))}return d=this.implodeHostname(this.urls.api[t])+d,{url:d,method:s,body:r,headers:n}}async setLeverage(e,t=void 0,s={}){if(t===void 0)throw new Vs(this.id+" setLeverage() requires a symbol argument");if(e<1||e>100)throw new $s(this.id+" setLeverage() leverage should be between 1 and 100");await this.loadMarkets();const n={symbol:this.market(t).id,leverage:e};return await this.privatePutPositionsLeverage(this.extend(n,s))}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c=this.toEv(t,r);let u,h;if(o==="spot"&&d==="future"?u=2:o==="future"&&d==="spot"&&(u=1),u!==void 0){const m={currency:r.id,moveOp:u,amountEv:c},g=await this.privatePostAssetsTransfer(this.extend(m,n)),y=this.safeValue(g,"data",{});h=this.parseTransfer(y,r)}else{const m={fromUserId:o,toUserId:d,amountEv:c,currency:r.id,bizType:this.safeString(n,"bizType","SPOT")},g=await this.privatePostAssetsUniversalTransfer(this.extend(m,n));h=this.parseTransfer(g)}const l=this.safeValue(this.options,"transfer",{});return this.safeValue(l,"fillResponseFromRequest",!0)&&(h.fromAccount===void 0&&(h.fromAccount=s),h.toAccount===void 0&&(h.toAccount=i),h.amount===void 0&&(h.amount=t),h.currency===void 0&&(h.currency=e)),h}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),e===void 0)throw new Vs(this.id+" fetchTransfers() requires a code argument");const n=this.currency(e),r={currency:n.id};t!==void 0&&(r.start=t),s!==void 0&&(r.limit=s);const a=await this.privateGetAssetsTransfer(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"rows",[]);return this.parseTransfers(d,n,t,s)}parseTransfer(e,t=void 0){const s=this.safeString(e,"linkKey"),i=this.safeString(e,"status"),n=this.safeString(e,"amountEv"),r=this.fromEv(n,t),a=this.safeString(e,"currency"),o=this.safeCurrencyCode(a,t),d=this.safeInteger(e,"side");let c,u;d===1?(c="swap",u="spot"):d===2&&(c="spot",u="swap");const h=this.safeInteger(e,"createTime");return{info:e,id:s,timestamp:h,datetime:this.iso8601(h),currency:o,amount:r,fromAccount:c,toAccount:u,status:this.parseTransferStatus(i)}}parseTransferStatus(e){const t={3:"rejected",6:"canceled",10:"ok",11:"failed"};return this.safeString(t,e,e)}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeValue(a,"error",a),u=this.safeString(c,"code"),h=this.safeString(c,"msg");if(u!==void 0&&u!=="0"){const l=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,l),this.throwBroadlyMatchedException(this.exceptions.broad,h,l),new Ns(l)}}};const gG=ge,{ArgumentsRequired:rT,ExchangeError:aT,ExchangeNotAvailable:yG,RequestTimeout:bG,AuthenticationError:wG,PermissionDenied:oT,RateLimitExceeded:dT,InsufficientFunds:kG,OrderNotFound:mh,InvalidOrder:$c,AccountSuspended:og,CancelPending:SG,InvalidNonce:vG,OnMaintenance:TG,BadSymbol:dg}=de,{DECIMAL_PLACES:OG}=me,cT=Se;var IG=class extends gG{describe(){return this.deepExtend(super.describe(),{id:"poloniex",name:"Poloniex",countries:["US"],rateLimit:5,certified:!1,pro:!1,has:{CORS:void 0,spot:!0,margin:void 0,swap:void 0,future:void 0,option:void 0,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createMarketOrder:void 0,createOrder:!0,editOrder:!1,fetchBalance:!0,fetchClosedOrder:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionMode:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawals:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"MINUTE_1","5m":"MINUTE_5","10m":"MINUTE_10","15m":"MINUTE_15","30m":"MINUTE_30","1h":"HOUR_1","2h":"HOUR_2","4h":"HOUR_4","6h":"HOUR_6","12h":"HOUR_12","1d":"DAY_1","3d":"DAY_3","1w":"WEEK_1","1M":"MONTH_1"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766817-e9456312-5ee6-11e7-9b3c-b628ca5626a5.jpg",api:"https://api.poloniex.com",test:"https://sand-spot-api-gateway.poloniex.com",www:"https://www.poloniex.com",doc:"https://docs.poloniex.com",fees:"https://poloniex.com/fees",referral:"https://poloniex.com/signup?c=UBFZJRPJ"},api:{public:{get:{markets:20,"markets/{symbol}":1,currencies:20,"currencies/{currency}":20,timestamp:1,"markets/price":1,"markets/{symbol}/price":1,"markets/{symbol}/orderBook":1,"markets/{symbol}/candles":1,"markets/{symbol}/trades":20,"markets/ticker24h":20,"markets/{symbol}/ticker24h":20}},private:{get:{accounts:4,"accounts/activity":4,"accounts/balances":4,"accounts/{id}/balances":4,"accounts/transfer":20,"accounts/transfer/{id}":4,feeinfo:20,"wallets/addresses":20,"wallets/activity":20,"wallets/addresses/{currency}":20,orders:20,"orders/{id}":4,"orders/history":20,"orders/killSwitchStatus":4,smartorders:20,"smartorders/{id}":4,"smartorders/history":20,trades:20,"orders/{id}/trades":4},post:{"accounts/transfer":4,"wallets/address":20,"wallets/withdraw":20,orders:4,"orders/killSwitch":4,"orders/batch":20,smartorders:4},delete:{"orders/{id}":4,"orders/cancelByIds":20,orders:20,"smartorders/{id}":4,"smartorders/cancelByIds":20,smartorders:20}}},fees:{trading:{feeSide:"get",maker:this.parseNumber("0.0009"),taker:this.parseNumber("0.0009")},funding:{}},commonCurrencies:{AIR:"AirCoin",APH:"AphroditeCoin",BCC:"BTCtalkcoin",BCHABC:"BCHABC",BDG:"Badgercoin",BTM:"Bitmark",CON:"Coino",GOLD:"GoldEagles",GPUC:"GPU",HOT:"Hotcoin",ITC:"Information Coin",KEY:"KEYCoin",MASK:"NFTX Hashmasks Index",MEME:"Degenerator Meme",PLX:"ParallaxCoin",REPV2:"REP",STR:"XLM",SOC:"SOCC",TRADE:"Unitrade",XAP:"API Coin",USDTTRON:"USDT",USDTETH:"USDT",UST:"USTC"},options:{networks:{BEP20:"BSC",ERC20:"ETH",TRX:"TRON",TRC20:"TRON"},limits:{cost:{min:{BTC:1e-4,ETH:1e-4,USDT:1,TRX:100,BNB:.06,USDC:1,USDJ:1,TUSD:1e-4,DAI:1,PAX:1,BUSD:1}}},accountsByType:{spot:"spot",future:"futures"},accountsById:{exchange:"spot",futures:"future"}},precisionMode:OG,exceptions:{exact:{"You may only place orders that reduce your position.":$c,"Invalid order number, or you are not the person who placed the order.":mh,"Permission denied":oT,"Permission denied.":oT,"Connection timed out. Please try again.":bG,"Internal error. Please try again.":yG,"Currently in maintenance mode.":TG,"Order not found, or you are not the person who placed it.":mh,"Invalid API key/secret pair.":wG,"Please do not make more than 8 API calls per second.":dT,"This IP has been temporarily throttled. Please ensure your requests are valid and try again in one minute.":dT,"Rate must be greater than zero.":$c,"Invalid currency pair.":dg,"Invalid currencyPair parameter.":dg,"Trading is disabled in this market.":dg,"Invalid orderNumber parameter.":mh,"Order is beyond acceptable bounds.":$c,"This account is closed.":og},broad:{"Total must be at least":$c,"This account is frozen":og,"This account is locked.":og,"Not enough":kG,"Nonce must be greater":vG,"You have already called cancelOrder":SG,"Amount must be at least":$c,"is either completed or does not exist":mh,"Error pulling ":aT}}})}parseOHLCV(e,t=void 0){return[this.safeInteger(e,12),this.safeNumber(e,2),this.safeNumber(e,1),this.safeNumber(e,0),this.safeNumber(e,3),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,interval:this.timeframes[t]};s!==void 0&&(a.startTime=s),i!==void 0&&(a.limit=i);const o=await this.publicGetMarketsSymbolCandles(this.extend(a,n));return this.parseOHLCVs(o,r,t,s,i)}async loadMarkets(e=!1,t={}){const s=await super.loadMarkets(e,t);return(this.safeValue(this.options,"currenciesByNumericId")===void 0||e)&&(this.options.currenciesByNumericId=this.indexBy(this.currencies,"numericId")),s}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=[];for(let i=0;i<t.length;i++){const n=this.safeValue(t,i),r=this.safeString(n,"symbol"),a=this.safeString(n,"baseCurrencyName"),o=this.safeString(n,"quoteCurrencyName"),d=this.safeCurrencyCode(a),c=this.safeCurrencyCode(o),h=this.safeString(n,"state")==="NORMAL",l=this.safeValue(n,"symbolTradeLimit");s.push({id:r,symbol:d+"/"+c,base:d,quote:c,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:h,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeInteger(l,"quantityScale"),price:this.safeInteger(l,"priceScale")},limits:{amount:{min:this.safeNumber(l,"minQuantity"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(l,"minAmount"),max:void 0}},info:n})}return s}async fetchTime(e={}){const t=await this.publicGetTimestamp(e);return this.safeInteger(t,"serverTime")}parseTicker(e,t=void 0){const s=this.safeInteger(e,"ts"),i=this.safeString(e,"symbol");t=this.safeMarket(i);const n=this.safeString(e,"close"),r=this.safeString(e,"percentChange"),a=cT.stringMul(r,"100");return this.safeTicker({id:i,symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:n,last:n,previousClose:void 0,change:void 0,percentage:a,average:void 0,baseVolume:this.safeString(e,"quantity"),quoteVolume:this.safeString(e,"amount"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetMarketsTicker24h(t);return this.parseTickers(s,e)}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s={};for(let i=0;i<t.length;i++){const n=this.safeValue(t,i),r=Object.keys(n),a=this.safeValue(r,0),o=this.safeValue(n,a),d=this.safeCurrencyCode(a),c=this.safeValue(o,"delisted"),h=this.safeString(o,"walletState")==="ENABLED",p=!c&&h,m=this.safeInteger(o,"id"),g=this.safeNumber(o,"withdrawalFee");s[d]={id:a,numericId:m,code:d,info:o,name:o.name,active:p,deposit:void 0,withdraw:void 0,fee:g,precision:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:g,max:void 0}}}}return s}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetMarketsSymbolTicker24h(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){const s=this.safeString2(e,"id","tradeID"),i=this.safeString(e,"orderId"),n=this.safeInteger2(e,"ts","createTime"),r=this.safeString(e,"symbol");t=this.safeMarket(r,t,"_");const a=t.symbol,o=this.safeStringLower(e,"side");let d;const c=this.safeString(e,"price"),u=this.safeString(e,"quantity"),h=this.safeString(e,"amount"),l=this.safeString(e,"feeCurrency"),p=this.safeString(e,"feeAmount");if(p!==void 0){const m=this.safeCurrencyCode(l);d={cost:p,currency:m}}return this.safeTrade({id:s,info:e,timestamp:n,datetime:this.iso8601(n),symbol:a,order:i,type:this.safeStringLower(e,"type"),side:o,takerOrMaker:this.safeStringLower(e,"matchRole"),price:c,amount:u,cost:h,fee:d},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetMarketsSymbolTrades(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e));const r={};t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=parseInt(s));const a=await this.privateGetTrades(this.extend(r,i)),o=this.parseTrades(a,n);return this.filterBySinceLimit(o,t,s)}parseOrderStatus(e){const t={NEW:"open",PARTIALLY_FILLED:"open",FILLED:"closed",PENDING_CANCEL:"canceled",PARTIALLY_CANCELED:"canceled",CANCELED:"canceled",FAILED:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){let s=this.safeInteger2(e,"timestamp","createTime");s===void 0&&(s=this.parse8601(this.safeString(e,"date")));const i=this.safeString(e,"symbol");t=this.safeMarket(i,t,"_");const n=t.symbol;let r=this.safeValue(e,"resultingTrades");Array.isArray(r)||(r=this.safeValue(r,this.safeString(t,"id",i)));const a=this.safeString2(e,"price","rate"),o=this.safeString(e,"quantity"),d=this.safeString(e,"filledQuantity"),c=this.parseOrderStatus(this.safeString(e,"state")),u=this.safeStringLower(e,"side"),h=this.safeString(e,"type"),l=this.parseOrderType(h),p=this.safeString2(e,"orderNumber","id");let m;const g=this.safeString(e,"tokenFeeCurrency");let y,b;const w=this.safeString(e,"fee");g===void 0?b=u==="buy"?t.base:t.quote:(b=this.safeCurrencyCode(g),y=this.safeString(e,"tokenFee")),y!==void 0&&(m={rate:w,cost:y,currency:b});const k=this.safeString(e,"clientOrderId");return this.safeOrder({info:e,id:p,clientOrderId:k,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:this.safeInteger(e,"updateTime"),status:c,symbol:n,type:l,timeInForce:this.safeString(e,"timeInForce"),postOnly:void 0,side:u,price:a,stopPrice:void 0,cost:void 0,average:this.safeString(e,"avgPrice"),amount:o,filled:d,remaining:void 0,trades:r,fee:m},t)}parseOrderType(e){const t={MARKET:"market",LIMIT:"limit","STOP-LIMIT":"limit","STOP-MARKET":"market"};return this.safeString(t,e,e)}parseOpenOrders(e,t,s){for(let i=0;i<e.length;i++){const n=e[i],r=this.extend(n,{status:"open",type:"limit",side:n.type,price:n.rate});s.push(this.parseOrder(r,t))}return s}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.symbol=n.id),s!==void 0&&(r.limit=s);const a=await this.privateGetOrders(this.extend(r,i)),o={status:"open"};return this.parseOrders(a,n,t,s,o)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o=t.toUpperCase();const d=o==="MARKET";this.isPostOnly(d,o==="LIMIT_MAKER",r)&&(o="LIMIT_MAKER",r=this.omit(r,"postOnly"));const u={symbol:a.id,side:s,type:o};d?s==="buy"?u.amount=this.currencyToPrecision(a.quote,i):u.quantity=this.amountToPrecision(e,i):(u.quantity=this.amountToPrecision(e,i),u.price=this.priceToPrecision(e,n));const h=this.safeString(r,"clientOrderId");h!==void 0&&(u.clientOrderId=h,r=this.omit(r,"clientOrderId"));let l=await this.privatePostOrders(this.extend(u,r));return l=this.extend(l,{type:s}),this.parseOrder(l,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={},n=this.safeValue(s,"clientOrderId");return n!==void 0&&(e=n),i.id=e,s=this.omit(s,"clientOrderId"),await this.privateDeleteOrdersId(this.extend(i,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;return e!==void 0&&(i=this.market(e),s.symbols=[i.id]),await this.privateDeleteOrders(this.extend(s,t))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets(),e=e.toString();const i={id:e},n=await this.privateGetOrdersId(this.extend(i,s));return this.extend(this.parseOrder(n),{id:e})}async fetchOrderStatus(e,t=void 0,s={}){await this.loadMarkets();const i=await this.fetchOpenOrders(t,void 0,void 0,s),n=this.indexBy(i,"id");return e in n?"open":"closed"}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={id:e},a=await this.privateGetOrdersIdTrades(this.extend(r,n));return this.parseTrades(a)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=this.safeValue(e,s,{}),n=this.safeValue(i,"balances");for(let r=0;r<n.length;r++){const a=this.safeValue(n,r),o=this.safeString(a,"currency"),d=this.safeCurrencyCode(o),c=this.account();c.free=this.safeString(a,"available"),c.used=this.safeString(a,"hold"),t[d]=c}}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t={accountType:"SPOT"},s=await this.privateGetAccountsBalances(this.extend(t,e));return this.parseBalance(s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetFeeinfo(e),s={};for(let i=0;i<this.symbols.length;i++){const n=this.symbols[i];s[n]={info:t,symbol:n,maker:this.safeNumber(t,"makerRate"),taker:this.safeNumber(t,"takerRate"),percentage:!0,tierBased:!0}}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetMarketsSymbolOrderBook(this.extend(n,s)),a=this.safeInteger(r,"time"),o=this.safeValue(r,"asks"),d=this.safeValue(r,"bids"),c=[],u=[];for(let h=0;h<o.length;h++)if(h%2<1){const l=this.safeNumber(o,h),p=this.safeNumber(o,this.sum(h,1));c.push([l,p])}for(let h=0;h<d.length;h++)if(h%2<1){const l=this.safeNumber(d,h),p=this.safeNumber(d,this.sum(h,1));u.push([l,p])}return{symbol:i.symbol,bids:this.sortBy(u,0,!0),asks:this.sortBy(c,0),timestamp:a,datetime:this.iso8601(a),nonce:void 0}}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper(t,"network");if(r=this.safeString(n,r,r),r!==void 0)i.currency+=r,t=this.omit(t,"network");else if(s.id==="USDT")throw new rT(this.id+" createDepositAddress requires a network parameter for "+e+".");const a=await this.privatePostWalletsAddress(this.extend(i,t));let o=this.safeString(a,"address"),d;if(this.checkAddress(o),s!==void 0){const c=this.safeString(s.info,"depositAddress");c!==void 0&&(d=o,o=c)}return{currency:e,address:o,tag:d,network:r,info:a}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper(t,"network");if(r=this.safeString(n,r,r),r!==void 0)i.currency+=r,t=this.omit(t,"network");else if(s.id==="USDT")throw new rT(this.id+" fetchDepositAddress requires a network parameter for "+e+".");const a=await this.privateGetWalletsAddresses(this.extend(i,t));let o=this.safeString(a,i.currency),d;if(this.checkAddress(o),s!==void 0){const c=this.safeString(s.info,"depositAddress");c!==void 0&&(d=o,o=c)}return{currency:e,address:o,tag:d,network:r,info:a}}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e);t=this.currencyToPrecision(e,t);const a=this.safeValue(this.options,"accountsByType",{}),o=this.safeString(a,s,s),d=this.safeString(a,i,s),c={amount:t,currency:r.id,fromAccount:o,toAccount:d},u=await this.privatePostAccountsTransfer(this.extend(c,n));return this.parseTransfer(u,r)}parseTransferStatus(e){const t={1:"ok"};return this.safeString(t,e,e)}parseTransfer(e,t=void 0){const i=this.safeString(e,"message").split(" "),n=this.safeNumber(i,1),r=this.safeString(i,2),a=this.safeString(i,4),o=this.safeString(i,6),d=this.safeValue(this.options,"accountsById",{});return{info:e,id:void 0,timestamp:void 0,datetime:void 0,currency:this.safeCurrencyCode(r,t),amount:n,fromAccount:this.safeString(d,a),toAccount:this.safeString(d,o),status:this.parseOrderStatus(this.safeString(e,"success","failed"))}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency:r.id,amount:t,address:s};i!==void 0&&(a.paymentId=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeString(o,d,d),d!==void 0&&(a.currency+=d,n=this.omit(n,"network"));const c=await this.privatePostWalletsWithdraw(this.extend(a,n));return this.parseTransaction(c,r)}async fetchTransactionsHelper(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=31104e3,r=this.seconds(),o={start:t!==void 0?parseInt(t/1e3):r-10*n,end:r};return await this.privateGetWalletsActivity(this.extend(o,i))}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=await this.fetchTransactionsHelper(e,t,s,i);let r;e!==void 0&&(r=this.currency(e));const a=this.safeValue(n,"withdrawals",[]),o=this.safeValue(n,"deposits",[]),d=this.parseTransactions(a,r,t,s),c=this.parseTransactions(o,r,t,s),u=this.arrayConcat(c,d);return this.filterByCurrencySinceLimit(this.sortBy(u,"timestamp"),e,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const n=await this.fetchTransactionsHelper(e,t,s,i);let r;e!==void 0&&(r=this.currency(e));const a=this.safeValue(n,"withdrawals",[]),o=this.parseTransactions(a,r,t,s);return this.filterByCurrencySinceLimit(o,e,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){const n=await this.fetchTransactionsHelper(e,t,s,i);let r;e!==void 0&&(r=this.currency(e));const a=this.safeValue(n,"deposits",[]),o=this.parseTransactions(a,r,t,s);return this.filterByCurrencySinceLimit(o,e,t,s)}parseTransactionStatus(e){const t={COMPLETE:"ok",COMPLETED:"ok","AWAITING APPROVAL":"pending",AWAITING_APPROVAL:"pending",PENDING:"pending",PROCESSING:"pending","COMPLETE ERROR":"failed",COMPLETE_ERROR:"failed"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeTimestamp(e,"timestamp"),i=this.safeString(e,"currency"),n=this.safeCurrencyCode(i);let r=this.safeString(e,"status","pending");r=this.parseTransactionStatus(r);const a=this.safeString(e,"txid"),o="withdrawalRequestsId"in e?"withdrawal":"deposit",d=this.safeString2(e,"withdrawalRequestsId","depositNumber"),c=this.safeString(e,"address"),u=this.safeString(e,"paymentID");let h=this.safeString(e,"amount");const l=this.safeString(e,"fee");return o==="withdrawal"&&(h=cT.stringSub(h,l)),{info:e,id:d,currency:n,amount:this.parseNumber(h),network:void 0,address:c,addressTo:void 0,addressFrom:void 0,tag:u,tagTo:void 0,tagFrom:void 0,status:r,type:o,updated:void 0,txid:a,timestamp:s,datetime:this.iso8601(s),fee:{currency:n,cost:this.parseNumber(l)}}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api;const o=this.omit(i,this.extractParams(e)),d=this.implodeParams(e,i);if(t==="public")a+="/"+d,Object.keys(o).length&&(a+="?"+this.urlencode(o));else{this.checkRequiredCredentials();const c=this.nonce().toString();let u=s+`
`;if(a+="/"+d,u+="/"+d,s==="POST"||s==="PUT"||s==="DELETE")u+=`
`,Object.keys(o).length&&(r=this.json(o),u+="requestBody="+r+"&"),u+="signTimestamp="+c;else{let l=this.extend({signTimestamp:c},o);l=this.keysort(l),u+=`
`+this.urlencode(l),Object.keys(o).length&&(a+="?"+this.urlencode(o))}const h=this.hmac(this.encode(u),this.encode(this.secret),"sha256","base64");n={"Content-Type":"application/json",key:this.apiKey,signTimestamp:c,signature:h}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&"error"in a){const c=a.error,u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,c,u),new aT(u)}}};const xG=ge,{ExchangeError:_G,ExchangeNotAvailable:uT,BadResponse:CG,BadRequest:cg,InvalidOrder:fT,InsufficientFunds:MG,AuthenticationError:ug,ArgumentsRequired:hT,InvalidAddress:lT,RateLimitExceeded:PG,DDoSProtection:AG,BadSymbol:fg}=de,{TRUNCATE:BG,TICK_SIZE:EG}=me,gh=Se;var NG=class extends xG{describe(){return this.deepExtend(super.describe(),{id:"probit",name:"ProBit",countries:["SC","KR"],rateLimit:50,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddresses:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,signIn:!0,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","10m":"10m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","6h":"6h","12h":"12h","1d":"1D","1w":"1W","1M":"1M"},version:"v1",urls:{logo:"https://user-images.githubusercontent.com/51840849/79268032-c4379480-7ea2-11ea-80b3-dd96bb29fd0d.jpg",api:{accounts:"https://accounts.probit.com",public:"https://api.probit.com/api/exchange",private:"https://api.probit.com/api/exchange"},www:"https://www.probit.com",doc:["https://docs-en.probit.com","https://docs-ko.probit.com"],fees:"https://support.probit.com/hc/en-us/articles/360020968611-Trading-Fees",referral:"https://www.probit.com/r/34608773"},api:{public:{get:{market:1,currency:1,currency_with_platform:1,time:1,ticker:1,order_book:1,trade:1,candle:1}},private:{post:{new_order:2,cancel_order:1,withdrawal:2},get:{balance:1,order:1,open_order:1,order_history:1,trade_history:1,deposit_address:1}},accounts:{post:{token:1}}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},exceptions:{exact:{UNAUTHORIZED:ug,INVALID_ARGUMENT:cg,TRADING_UNAVAILABLE:uT,NOT_ENOUGH_BALANCE:MG,NOT_ALLOWED_COMBINATION:cg,INVALID_ORDER:fT,RATE_LIMIT_EXCEEDED:PG,MARKET_UNAVAILABLE:uT,INVALID_MARKET:fg,MARKET_CLOSED:fg,MARKET_NOT_FOUND:fg,INVALID_CURRENCY:cg,TOO_MANY_OPEN_ORDERS:AG,DUPLICATE_ADDRESS:lT,invalid_grant:ug}},requiredCredentials:{apiKey:!0,secret:!0},precisionMode:EG,options:{createMarketBuyOrderRequiresPrice:!0,timeInForce:{limit:"gtc",market:"ioc"},networks:{BEP20:"BSC",ERC20:"ETH",TRC20:"TRON",TRX:"TRON"}},commonCurrencies:{AUTO:"Cube",AZU:"Azultec",BCC:"BCC",BDP:"BidiPass",BIRD:"Birdchain",BTCBEAR:"BEAR",BTCBULL:"BULL",CBC:"CryptoBharatCoin",CHE:"Chellit",CLR:"Color Platform",CTK:"Cryptyk",CTT:"Castweet",DIP:"Dipper",DKT:"DAKOTA",EGC:"EcoG9coin",EPS:"Epanus",FX:"Fanzy",GDT:"Gorilla Diamond",GM:"GM Holding",GOGOL:"GOL",GOL:"Goldofir",GRB:"Global Reward Bank",HBC:"Hybrid Bank Cash",HUSL:"The Hustle App",LAND:"Landbox",LBK:"Legal Block",ORC:"Oracle System",PXP:"PIXSHOP COIN",PYE:"CreamPYE",ROOK:"Reckoon",SOC:"Soda Coin",SST:"SocialSwap",TCT:"Top Coin Token",TOR:"Torex",TPAY:"Tetra Pay",UNI:"UNICORN Token",UNISWAP:"UNI"}})}async fetchMarkets(e={}){const t=await this.publicGetMarket(e),s=this.safeValue(t,"data",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"id"),o=this.safeString(r,"base_currency_id"),d=this.safeString(r,"quote_currency_id"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d),h=this.safeValue(r,"closed",!1),l=this.safeString(r,"taker_fee_rate"),p=gh.stringDiv(l,"100"),m=this.safeString(r,"maker_fee_rate"),g=gh.stringDiv(m,"100");i.push({id:a,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!h,contract:!1,linear:void 0,inverse:void 0,taker:this.parseNumber(p),maker:this.parseNumber(g),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"quantity_precision"))),price:this.safeNumber(r,"price_increment"),cost:this.parseNumber(this.parsePrecision(this.safeString(r,"cost_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"min_quantity"),max:this.safeNumber(r,"max_quantity")},price:{min:this.safeNumber(r,"min_price"),max:this.safeNumber(r,"max_price")},cost:{min:this.safeNumber(r,"min_cost"),max:this.safeNumber(r,"max_cost")}},info:r})}return i}async fetchCurrencies(e={}){const t=await this.publicGetCurrencyWithPlatform(e),s=this.safeValue(t,"data",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"id"),o=this.safeCurrencyCode(a),d=this.safeValue(r,"display_name"),c=this.safeString(d,"en-us"),u=this.safeValue(r,"platform",[]),h=this.sortBy(u,"priority"),l=this.safeValue(h,0,{}),p=this.safeValue(l,"deposit_suspended"),m=this.safeValue(l,"withdrawal_suspended"),g=!p,y=!m,b=g&&y,w=this.safeValue(l,"withdrawal_fee",{}),k=[];for(let C=0;C<w.length;C++){const E=w[C],P=this.safeNumber(E,"amount"),_=this.safeInteger(E,"priority");P!==void 0&&_!==void 0&&k.push(E)}const T=this.sortBy(k,"priority"),O=this.safeValue(T,0,{}),x=this.safeNumber(O,"amount");i[o]={id:a,code:o,info:r,name:c,active:b,deposit:g,withdraw:y,fee:x,precision:this.parseNumber(this.parsePrecision(this.safeString(l,"precision"))),limits:{amount:{min:void 0,max:void 0},deposit:{min:this.safeNumber(l,"min_deposit_amount"),max:void 0},withdraw:{min:this.safeNumber(l,"min_withdrawal_amount"),max:void 0}}}}return i}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"data",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeString(n,"currency_id"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(n,"total"),o.free=this.safeString(n,"available"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={market_id:i.id},r=await this.publicGetOrderBook(this.extend(n,s)),a=this.safeValue(r,"data",[]),o=this.groupBy(a,"side");return this.parseOrderBook(o,i.symbol,void 0,"buy","sell","price","quantity")}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};if(e!==void 0){const r=this.marketIds(e);s.market_ids=r.join(",")}const i=await this.publicGetTicker(this.extend(s,t)),n=this.safeValue(i,"data",[]);return this.parseTickers(n,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market_ids:s.id},n=await this.publicGetTicker(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0);if(a===void 0)throw new CG(this.id+" fetchTicker() returned an empty response");return this.parseTicker(a,s)}parseTicker(e,t=void 0){const s=this.parse8601(this.safeString(e,"time")),i=this.safeString(e,"market_id"),n=this.safeSymbol(i,t,"-"),r=this.safeString(e,"last"),a=this.safeString(e,"change"),o=this.safeString(e,"base_volume"),d=this.safeString(e,"quote_volume");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:a,percentage:void 0,average:void 0,baseVolume:o,quoteVolume:d,info:e},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={limit:100,start_time:this.iso8601(0),end_time:this.iso8601(this.milliseconds())};e!==void 0&&(n=this.market(e),r.market_id=n.id),t!==void 0&&(r.start_time=this.iso8601(t)),s!==void 0&&(r.limit=s);const a=await this.privateGetTradeHistory(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market_id:n.id,limit:100,start_time:"1970-01-01T00:00:00.000Z",end_time:this.iso8601(this.milliseconds())};t!==void 0&&(r.start_time=this.iso8601(t)),s!==void 0&&(r.limit=s);const a=await this.publicGetTrade(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"time")),i=this.safeString(e,"id");let n;if(i!==void 0){const l=i.split(":");n=this.safeString(l,0)}n=this.safeString(e,"market_id",n);const r=this.safeSymbol(n,t,"-"),a=this.safeString(e,"side"),o=this.safeString(e,"price"),d=this.safeString(e,"quantity"),c=this.safeString(e,"order_id"),u=this.safeString(e,"fee_amount");let h;if(u!==void 0){const l=this.safeString(e,"fee_currency_id"),p=this.safeCurrencyCode(l);h={cost:u,currency:p}}return this.safeTrade({id:i,info:e,timestamp:s,datetime:this.iso8601(s),symbol:r,order:c,type:void 0,side:a,takerOrMaker:void 0,price:o,amount:d,cost:void 0,fee:h},t)}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.parse8601(this.safeString(t,"data"))}normalizeOHLCVTimestamp(e,t,s=!1){const i=this.parseTimeframe(t);if(t==="1M"){const r=this.iso8601(e).split("-"),a=this.safeString(r,0);let o=this.safeInteger(r,1);return s&&(o=this.sum(o,1)),o<10?o="0"+o.toString():o=o.toString(),a+"-"+o+"-01T00:00:00.000Z"}else if(t==="1w"){e=parseInt(e/1e3);const n=259200,r=e-n,a=Math.floor(r/i);let o=this.sum(n,a*i);return s&&(o=this.sum(o,i)),this.iso8601(o*1e3)}else return e=parseInt(e/1e3),e=i*parseInt(e/i),s&&(e=this.sum(e,i)),this.iso8601(e*1e3)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.timeframes[t];i=i===void 0?100:i;let o=this.sum(i,1);o=Math.min(1e3,o);const d={market_ids:r.id,interval:a,sort:"asc",limit:o},c=this.milliseconds(),u=this.parseTimeframe(t);let h=s,l=c;s===void 0?(i===void 0&&(i=o),h=c-i*u*1e3):i===void 0?l=c:l=this.sum(s,this.sum(i,1)*u*1e3);const p=this.normalizeOHLCVTimestamp(h,t),m=this.normalizeOHLCVTimestamp(l,t,!0);d.start_time=p,d.end_time=m;const g=await this.publicGetCandle(this.extend(d,n)),y=this.safeValue(g,"data",[]);return this.parseOHLCVs(y,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"start_time")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"base_volume")]}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),t=this.parse8601(t);const n={};let r;e!==void 0&&(r=this.market(e),n.market_id=r.id);const a=await this.privateGetOpenOrder(this.extend(n,i)),o=this.safeValue(a,"data");return this.parseOrders(o,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={start_time:this.iso8601(0),end_time:this.iso8601(this.milliseconds()),limit:100};let r;e!==void 0&&(r=this.market(e),n.market_id=r.id),t&&(n.start_time=this.iso8601(t)),s&&(n.limit=s);const a=await this.privateGetOrderHistory(this.extend(n,i)),o=this.safeValue(a,"data");return this.parseOrders(o,r,t,s)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new hT(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={market_id:i.id},r=this.safeString2(s,"clientOrderId","client_order_id");r!==void 0?n.client_order_id=r:n.order_id=e;const a=this.omit(s,["clientOrderId","client_order_id"]),o=await this.privateGetOrder(this.extend(n,a)),d=this.safeValue(o,"data",[]),c=this.safeValue(d,0);return this.parseOrder(c,i)}parseOrderStatus(e){const t={open:"open",cancelled:"canceled",filled:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString(e,"status")),i=this.safeString(e,"id"),n=this.safeString(e,"type"),r=this.safeString(e,"side"),a=this.safeString(e,"market_id"),o=this.safeSymbol(a,t,"-"),d=this.parse8601(this.safeString(e,"time"));let c=this.safeString(e,"limit_price");const u=this.safeString(e,"filled_quantity");let h=this.safeString(e,"open_quantity");const l=this.safeString(e,"cancelled_quantity");l!==void 0&&(h=gh.stringAdd(h,l));const p=this.safeString(e,"quantity",gh.stringAdd(u,h)),m=this.safeString2(e,"filled_cost","cost");n==="market"&&(c=void 0);const g=this.safeString(e,"client_order_id"),y=this.safeStringUpper(e,"time_in_force");return this.safeOrder({id:i,info:e,clientOrderId:g,timestamp:d,datetime:this.iso8601(d),lastTradeTimestamp:void 0,symbol:o,type:n,timeInForce:y,side:r,status:s,price:c,stopPrice:void 0,amount:p,filled:u,remaining:h,average:void 0,cost:m,fee:void 0,trades:void 0},t)}costToPrecision(e,t){return this.decimalToPrecision(t,BG,this.markets[e].precision.cost,this.precisionMode)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeValue(this.options,"timeInForce"),d=this.safeValue(o,t),c=this.safeString2(r,"timeInForce","time_in_force",d),u={market_id:a.id,type:t,side:s,time_in_force:c},h=this.safeString2(r,"clientOrderId","client_order_id");h!==void 0&&(u.client_order_id=h);let l;if(t==="limit")u.limit_price=this.priceToPrecision(e,n),u.quantity=this.amountToPrecision(e,i);else if(t==="market")if(s==="buy"){let b=this.safeNumber(r,"cost");if(this.safeValue(this.options,"createMarketBuyOrderRequiresPrice",!0)){if(n!==void 0)b===void 0&&(b=i*n);else if(b===void 0)throw new fT(this.id+" createOrder() requires the price argument for market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total cost value in the 'amount' argument or in the 'cost' extra parameter (the exchange-specific behaviour)")}else b=b===void 0?i:b;l=this.costToPrecision(e,b),u.cost=l}else u.quantity=this.amountToPrecision(e,i);const p=this.omit(r,["timeInForce","time_in_force","clientOrderId","client_order_id"]),m=await this.privatePostNewOrder(this.extend(u,p)),g=this.safeValue(m,"data"),y=this.parseOrder(g,a);return t==="market"&&s==="buy"&&(y.amount=void 0,y.cost=this.parseNumber(l),y.remaining=void 0),y}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new hT(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const n={market_id:this.market(t).id,order_id:e},r=await this.privatePostCancelOrder(this.extend(n,s)),a=this.safeValue(r,"data");return this.parseOrder(a)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"destination_tag"),n=this.safeString(e,"currency_id");t=this.safeCurrency(n,t);const r=t.code,a=this.safeString(e,"platform_id");return this.checkAddress(s),{currency:r,address:s,tag:i,network:a,info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency_id:s.id},n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper(t,"network");r=this.safeString(n,r,r),r!==void 0&&(i.platform_id=r,t=this.omit(t,"platform_id"));const a=await this.privateGetDepositAddress(this.extend(i,t)),o=this.safeValue(a,"data",[]),d=this.safeValue(o,0);if(d===void 0)throw new lT(this.id+" fetchDepositAddress() returned an empty response");return this.parseDepositAddress(d,s)}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s={};if(e){const r=[];for(let a=0;a<e.length;a++){const o=this.currency(e[a]);r.push(o.id)}s.currency_id=e.join(",")}const i=await this.privateGetDepositAddress(this.extend(s,t)),n=this.safeValue(i,"data",[]);return this.parseDepositAddresses(n)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e);i===void 0&&(i="");const a={currency_id:r.id,address:s,destination_tag:i,amount:this.numberToString(t)},o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeString(o,d,d),d!==void 0&&(a.platform_id=d,n=this.omit(n,"network"));const c=await this.privatePostWithdrawal(this.extend(a,n)),u=this.safeValue(c,"data");return this.parseTransaction(u,r)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeNumber(e,"amount"),n=this.safeString(e,"address"),r=this.safeString(e,"destination_tag"),a=this.safeString(e,"hash"),o=this.parse8601(this.safeString(e,"time")),d=this.safeString(e,"type"),c=this.safeString(e,"currency_id"),u=this.safeCurrencyCode(c),h=this.parseTransactionStatus(this.safeString(e,"status")),l=this.safeNumber(e,"fee");let p;return l!==void 0&&l!==0&&(p={currency:u,cost:l}),{id:s,currency:u,amount:i,network:void 0,addressFrom:void 0,address:n,addressTo:n,tagFrom:void 0,tag:r,tagTo:r,status:h,type:d,txid:a,timestamp:o,datetime:this.iso8601(o),updated:void 0,fee:p,info:e}}parseTransactionStatus(e){const t={requested:"pending",pending:"pending",confirming:"pending",confirmed:"pending",applying:"pending",done:"ok",cancelled:"canceled",cancelling:"canceled"};return this.safeString(t,e,e)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t]+"/";const o=this.omit(i,this.extractParams(e));if(t==="accounts"){this.checkRequiredCredentials(),a+=this.implodeParams(e,i);const d=this.apiKey+":"+this.secret,c=this.stringToBase64(d);n={Authorization:"Basic "+this.decode(c),"Content-Type":"application/json"},Object.keys(o).length&&(r=this.json(o))}else if(a+=this.version+"/",t==="public")a+=this.implodeParams(e,i),Object.keys(o).length&&(a+="?"+this.urlencode(o));else if(t==="private"){const d=this.milliseconds();this.checkRequiredCredentials();const c=this.safeInteger(this.options,"expires");if(c===void 0||c<d)throw new ug(this.id+" access token expired, call signIn() method");n={Authorization:"Bearer "+this.safeString(this.options,"accessToken")},a+=this.implodeParams(e,i),s==="GET"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):Object.keys(o).length&&(r=this.json(o),n["Content-Type"]="application/json")}return{url:a,method:s,body:r,headers:n}}async signIn(e={}){this.checkRequiredCredentials();const t={grant_type:"client_credentials"},s=await this.accountsPostToken(this.extend(t,e)),i=this.safeInteger(s,"expires_in"),n=this.safeString(s,"access_token");return this.options.accessToken=n,this.options.expires=this.sum(this.milliseconds(),i*1e3),s}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&"errorCode"in a){const c=this.safeString(a,"errorCode"),u=this.safeString(a,"message");if(c!==void 0){const h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwBroadlyMatchedException(this.exceptions.exact,c,h),new _G(h)}}}};const VG=ge,{ExchangeError:qG,InvalidOrder:pT,InsufficientFunds:LG,AuthenticationError:RG,RateLimitExceeded:FG,BadSymbol:DG}=de,{TICK_SIZE:HG}=me,mT=Se;var GG=class extends VG{describe(){return this.deepExtend(super.describe(),{id:"qtrade",name:"qTrade",countries:["US"],rateLimit:1e3,version:"v1",urls:{logo:"https://user-images.githubusercontent.com/51840849/80491487-74a99c00-896b-11ea-821e-d307e832f13e.jpg",api:{rest:"https://api.qtrade.io"},www:"https://qtrade.io",doc:"https://qtrade-exchange.github.io/qtrade-docs",referral:"https://qtrade.io/?ref=BKOQWVFGRH2C",fees:"https://qtrade.io/fees"},has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactions:void 0,fetchTransfer:!1,fetchTransfers:!0,fetchWithdrawal:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"5m":"fivemin","15m":"fifteenmin","30m":"thirtymin","1h":"onehour","2h":"twohour","4h":"fourhour","1d":"oneday"},api:{public:{get:["ticker/{market_string}","tickers","currency/{code}","currencies","common","market/{market_string}","markets","market/{market_string}/trades","orderbook/{market_string}","market/{market_string}/ohlcv/{interval}"]},private:{get:["me","balances","balances_all","market/{market_string}","orders","order/{order_id}","trades","withdraw/{withdraw_id}","withdraws","deposit/{deposit_id}","deposits","transfers"],post:["cancel_order","withdraw","deposit_address/{currency}","sell_limit","buy_limit"]}},fees:{trading:{feeSide:"quote",tierBased:!0,percentage:!0,taker:this.parseNumber("0.005"),maker:this.parseNumber("0.0")},funding:{withdraw:{}}},commonCurrencies:{BTM:"Bitmark"},precisionMode:HG,exceptions:{exact:{invalid_auth:RG,insuff_funds:LG,market_not_found:DG,too_small:pT,limit_exceeded:FG}}})}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"markets",[]),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"market_string"),d=this.safeInteger(a,"id"),c=this.safeString(a,"market_currency"),u=this.safeString(a,"base_currency"),h=this.safeCurrencyCode(c),l=this.safeCurrencyCode(u),p=this.safeValue(a,"can_view",!1),g=this.safeValue(a,"can_trade",!1)&&p;n.push({id:o,numericId:d,symbol:h+"/"+l,base:h,quote:l,settle:void 0,baseId:c,quoteId:u,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:g,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(a,"taker_fee"),maker:this.safeNumber(a,"maker_fee"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(a,"market_precision"))),price:this.parseNumber(this.parsePrecision(this.safeString(a,"base_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(a,"minimum_sell_value"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(a,"minimum_buy_value"),max:void 0}},info:a})}return n}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"currencies",[]),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"code"),d=this.safeCurrencyCode(o),c=this.safeString(a,"long_name"),u=this.safeString(a,"type"),h=this.safeValue(a,"can_withdraw",!0),l=this.safeValue(a,"withdraw_disabled",!1),m=!this.safeValue(a,"deposit_disabled",!1),g=h&&!l,y=this.safeValue(a,"config",{}),b=this.safeString(a,"status"),w=g&&m&&b==="ok";n[d]={id:o,code:d,info:a,type:u,name:c,fee:this.safeNumber(y,"withdraw_fee"),precision:this.parseNumber(this.parsePrecision(this.safeString(a,"precision"))),active:w,deposit:m,withdraw:g,limits:{amount:{min:this.safeNumber(a,"minimum_order"),max:void 0},withdraw:{min:void 0,max:void 0}}}}return n}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"time")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"market_volume")]}async fetchOHLCV(e,t="5m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={market_string:r.id,interval:this.timeframes[t]},o=await this.publicGetMarketMarketStringOhlcvInterval(this.extend(a,n)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"slices",[]);return this.parseOHLCVs(c,r,t,s,i)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={market_string:i.id},r=await this.publicGetOrderbookMarketString(this.extend(n,s)),a=this.safeValue(r,"data",{}),o={},d={buy:"bids",sell:"asks"},c=Object.keys(d);for(let h=0;h<c.length;h++){const l=c[h],p=d[l],m=this.safeValue(a,l,{}),g=Object.keys(m),y=[];for(let b=0;b<g.length;b++){const w=g[b],k=this.safeNumber(g,b),T=this.safeNumber(m,w);y.push([k,T])}o[p]=y}const u=this.safeIntegerProduct(a,"last_change",.001);return this.parseOrderBook(o,i.symbol,u)}parseTicker(e,t=void 0){const s=this.safeString(e,"id_hr"),i=this.safeSymbol(s,t,"_"),n=this.safeIntegerProduct(e,"last_change",.001),r=this.safeString(e,"day_open"),a=this.safeString(e,"last"),o=this.safeString(e,"day_change"),d=this.safeString(e,"day_avg_price"),c=this.safeString(e,"day_volume_market"),u=this.safeString(e,"day_volume_base"),h=mT.stringMul(o,"100"),l=mT.stringMul(o,r);return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"day_high"),low:this.safeString(e,"day_low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:r,close:a,last:a,previousClose:void 0,change:l,percentage:h,average:d,baseVolume:c,quoteVolume:u,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTickers(t),i=this.safeValue(s,"data",{}),n=this.safeValue(i,"markets",[]),r={};for(let a=0;a<n.length;a++){const o=this.parseTicker(n[a]),d=o.symbol;r[d]=o}return this.filterByArray(r,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market_string:s.id},n=await this.publicGetTickerMarketString(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTicker(r,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market_string:n.id},a=await this.publicGetMarketMarketStringTrades(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"trades",[]);return this.parseTrades(d,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={desc:!0};let r;const a=this.safeValue(i,"market_id");a!==void 0?n.market_id=a:e!==void 0&&(r=this.market(e),n.market_string=r.id);const o=await this.privateGetTrades(this.extend(n,i)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"trades",[]);return this.parseTrades(c,r,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"id");let i=this.safeIntegerProduct(e,"created_at_ts",.001);i===void 0&&(i=this.parse8601(this.safeString(e,"created_at")));const n=this.safeString(e,"side"),r=this.safeString(e,"market_string");t=this.safeMarket(r,t);const a=this.safeString2(e,"base_volume","base_amount"),o=this.safeString(e,"price"),d=this.safeString2(e,"market_amount","amount");let c;const u=this.safeString(e,"base_fee");u!==void 0&&(c={currency:t===void 0?void 0:t.quote,cost:u});const l=this.safeValue(e,"taker",!0)?"taker":"maker",p=this.safeString(e,"order_id");return this.safeTrade({id:s,info:e,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,order:p,type:void 0,side:n,takerOrMaker:l,price:o,amount:d,cost:a,fee:c},t)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={market_string:s.id},n=await this.publicGetMarketMarketString(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"market",{});return{info:a,symbol:s.symbol,maker:this.safeNumber(a,"maker_fee"),taker:this.safeNumber(a,"taker_fee"),percentage:!0,tierBased:!0}}parseBalance(e){const t=this.safeValue(e,"data",{});let s=this.safeValue(t,"balances",[]);const i={info:e,timestamp:void 0,datetime:void 0};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=o in i?i[o]:this.account();d.free=this.safeString(r,"balance"),d.used="0",i[o]=d}s=this.safeValue(t,"order_balances",[]);for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=o in i?i[o]:this.account();d.used=this.safeString(r,"balance"),i[o]=d}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalancesAll(e);return this.parseBalance(t)}async createOrder(e,t,s,i,n=void 0,r={}){if(t!=="limit")throw new pT(this.id+" createOrder() allows limit orders only");await this.loadMarkets();const a=this.market(e),o={amount:this.amountToPrecision(a.symbol,i),market_id:a.numericId,price:this.priceToPrecision(a.symbol,n)},c=await this[s==="sell"?"privatePostSellLimit":"privatePostBuyLimit"](this.extend(o,r)),u=this.safeValue(c,"data",{}),h=this.safeValue(u,"order",{});return this.parseOrder(h,a)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.parse8601(this.safeString(e,"created_at")),n=this.safeString(e,"order_type");let r,a;if(n!==void 0){const y=n.split("_");a=this.safeString(y,0),r=this.safeString(y,1)}const o=this.safeString(e,"price"),d=this.safeString(e,"market_amount"),c=this.safeString(e,"market_amount_remaining"),u=this.safeValue(e,"open",!1),h=this.safeString(e,"close_reason");let l;u?l="open":h==="canceled"?l="canceled":l="closed";const p=this.safeString(e,"market_string");t=this.safeMarket(p,t,"_");const m=t.symbol,g=this.safeValue(e,"trades",[]);return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,symbol:m,type:r,timeInForce:void 0,postOnly:void 0,side:a,price:o,stopPrice:void 0,average:void 0,amount:d,remaining:c,filled:void 0,status:l,fee:void 0,fees:void 0,cost:void 0,trades:g},t)}async cancelOrder(e,t=void 0,s={}){const i={id:parseInt(e)};return await this.privatePostCancelOrder(this.extend(i,s))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},n=await this.privateGetOrderOrderId(this.extend(i,s)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"order",{});return this.parseOrder(a)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;const a=this.safeValue(i,"market_id");a!==void 0?n.market_id=a:e!==void 0&&(r=this.market(e),n.market_string=r.id);const o=await this.privateGetOrders(this.extend(n,i)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"orders",[]);return this.parseOrders(c,r,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={open:!0};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={open:!1};return await this.fetchOrders(e,t,s,this.extend(n,i))}parseDepositAddress(e,t=void 0){const s=t===void 0?void 0:t.code;let i=this.safeString(e,"address"),n;if(i!==void 0){const r=i.split(":");i=this.safeString(r,0),n=this.safeString(r,1)}return this.checkAddress(i),{currency:s,address:i,tag:n,network:void 0,info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=await this.privatePostDepositAddressCurrency(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseDepositAddress(r,s)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const i={deposit_id:e},n=await this.privateGetDepositDepositId(this.extend(i,s)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"deposit",{});return this.parseTransaction(a)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r=await this.privateGetDeposits(i),a=this.safeValue(r,"data",{}),o=this.safeValue(a,"deposits",[]);return this.parseTransactions(o,n,t,s)}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r=await this.privateGetTransfers(i),a=this.safeValue(r,"data",{}),o=this.safeValue(a,"transfers",[]);return this.parseTransfers(o,n,t,s)}parseTransfer(e,t=void 0){const s=this.safeString(e,"currency"),i=this.safeString(e,"created_at");return{info:e,id:this.safeString(e,"id"),timestamp:this.parse8601(i),datetime:i,currency:this.safeCurrencyCode(s,t),amount:this.safeNumber(e,"amount"),fromAccount:this.safeString(e,"sender_id"),toAccount:void 0,status:"ok"}}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const i={withdraw_id:e},n=await this.privateGetWithdrawWithdrawId(this.extend(i,s)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"withdraw",{});return this.parseTransaction(a)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.currency(e));const r=await this.privateGetWithdraws(i),a=this.safeValue(r,"data",{}),o=this.safeValue(a,"withdraws",[]);return this.parseTransactions(o,n,t,s)}parseTransaction(e,t=void 0){const s=this.parse8601(this.safeString(e,"created_at")),i=this.safeString(e,"id"),n=this.safeValue(e,"network_data",{}),r=this.safeValue(n,"unsigned_tx",{}),a=this.safeString(r,"from"),o=this.safeString(n,"txid");let d=this.safeString(e,"address"),c;if(d!==void 0){const O=d.split(":");O.length>1&&(d=this.safeString(O,0),c=this.safeString(O,1))}const u=d,h=void 0,l=c,p=this.safeValue(e,"cancel_requested"),m=p===void 0?"deposit":"withdrawal",g=this.safeNumber(e,"amount"),y=this.safeString(e,"currency"),b=this.safeCurrencyCode(y);let w=this.parseTransactionStatus(this.safeString(e,"status"));const k=this.safeString(e,"code");p?w="canceled":w===void 0&&(w=this.parseTransactionStatus(k));const T=void 0;return{info:e,id:i,txid:o,timestamp:s,datetime:this.iso8601(s),network:void 0,addressFrom:a,addressTo:u,address:d,tagFrom:h,tagTo:l,tag:c,type:m,amount:g,currency:b,status:w,updated:void 0,fee:T}}parseTransactionStatus(e){const t={initiated:"pending",needs_create:"pending",credited:"ok",confirmed:"ok"};return this.safeString(t,e,e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets();const r=this.currency(e),a={address:s,amount:t,currency:r.id};i!==void 0&&(a.address+=":"+i);const o=await this.privatePostWithdraw(this.extend(a,n)),d=this.safeValue(o,"data",{}),c=this.parseTransaction(d);return this.extend(c,{currency:e,address:s,addressTo:s,tag:i,tagTo:i,amount:t})}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a="/"+this.version+"/";t==="private"&&(a+="user/"),a+=this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(s==="POST"?r=this.json(o):Object.keys(o).length&&(a+="?"+this.urlencode(o)),t==="private"){const d=this.milliseconds().toString(),u=[s,a,d,s==="POST"?r:"",this.secret].join(`
`),h=this.hash(this.encode(u),"sha256","base64");let l=this.apiKey;typeof l!="string"&&(l=l.toString()),n={Authorization:"HMAC-SHA256 "+l+":"+h,"HMAC-Timestamp":d},s==="POST"&&(n["Content-Type"]="application/json")}return a=this.urls.api.rest+a,{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeValue(a,"errors",[]);if(c.length<1)return;const h=this.id+" "+r;for(let l=0;l<c.length;l++){const p=c[l],m=this.safeString(p,"code");this.throwExactlyMatchedException(this.exceptions.exact,m,h)}throw new qG(h)}};const UG=ge,{AuthenticationError:gT,ExchangeError:hg,BadSymbol:yT,BadRequest:lg,InvalidOrder:bT,ArgumentsRequired:yh,OrderNotFound:$G,InsufficientFunds:jG,DDoSProtection:WG}=de,{TICK_SIZE:zG}=me;var rC=class extends UG{describe(){return this.deepExtend(super.describe(),{id:"ripio",name:"Ripio",countries:["AR","BR"],rateLimit:50,version:"v1",pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/94507548-a83d6a80-0218-11eb-9998-28b9cec54165.jpg",api:{public:"https://api.exchange.ripio.com/api",private:"https://api.exchange.ripio.com/api"},www:"https://exchange.ripio.com",doc:["https://exchange.ripio.com/en/api/"],fees:"https://exchange.ripio.com/en/fee"},api:{public:{get:["rate/all/","rate/{pair}/","orderbook/{pair}/","tradehistory/{pair}/","pair/","currency/","orderbook/{pair}/depth/"]},private:{get:["balances/exchange_balances/","order/{pair}/{order_id}/","order/{pair}/","trade/{pair}/"],post:["order/{pair}/","order/{pair}/{order_id}/cancel/"]}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0"),maker:this.parseNumber("0.0")}},precisionMode:zG,requiredCredentials:{apiKey:!0,secret:!1},exceptions:{exact:{},broad:{"Authentication credentials were not provided":gT,"Disabled pair":yT,"Invalid order type":bT,"Your balance is not enough":jG,"Order couldn't be created":hg,"not found":$G,"Invalid pair":yT,"amount must be a number":lg,"Total must be at least":bT,"Account not found":lg,"Wrong password provided":gT,"User tokens limit":WG,"Something unexpected ocurred":hg,account_balance:lg}}})}async fetchMarkets(e={}){const t=await this.publicGetPair(e),s=[],i=this.safeValue(t,"results",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"base"),o=this.safeString(r,"quote"),d=this.safeString(r,"symbol"),c=this.safeCurrencyCode(a),u=this.safeCurrencyCode(o),h=this.safeValue(r,"fees",[]),l=this.safeValue(h,0,{});s.push({id:d,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:this.safeValue(r,"enabled",!0),contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(l,"taker_fee",0),maker:this.safeNumber(l,"maker_fee",0),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(r,"min_amount"),price:this.safeNumber(r,"price_tick")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"min_amount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(r,"min_value"),max:void 0}},info:r})}return s}async fetchCurrencies(e={}){const t=await this.publicGetCurrency(e),s=this.safeValue(t,"results",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.safeString(r,"name"),c=this.safeValue(r,"enabled",!0);i[o]={id:a,code:o,name:d,info:r,active:c,deposit:void 0,withdraw:void 0,fee:void 0,precision:this.parseNumber(this.parsePrecision(this.safeString(r,"decimal_places"))),limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}}}return i}parseTicker(e,t=void 0){const s=this.parse8601(this.safeString(e,"created_at")),i=this.safeString(e,"pair");t=this.safeMarket(i,t,"_");const n=t.symbol,r=this.safeString(e,"last_price"),a=this.safeString(e,"avg");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:this.safeString(e,"bid_volume"),ask:this.safeString(e,"ask"),askVolume:this.safeString(e,"ask_volume"),vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:a,baseVolume:void 0,quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetRatePair(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetRateAll(t),i={};for(let n=0;n<s.length;n++){const r=this.parseTicker(s[n]),a=r.symbol;i[a]=r}return this.filterByArray(i,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id},r=await this.publicGetOrderbookPair(this.extend(n,s)),a=this.parseOrderBook(r,i.symbol,void 0,"buy","sell","price","amount");return a.nonce=this.safeInteger(r,"updated_id"),a}parseTrade(e,t=void 0){const s=this.safeString(e,"id");let i=this.safeInteger(e,"timestamp");i=this.safeTimestamp(e,"created_at",i);let n=this.safeString(e,"side");const a=this.safeString(e,"taker_side")===n?"taker":"maker";n!==void 0&&(n=n.toLowerCase());const o=this.safeString2(e,"price","match_price"),d=this.safeString2(e,"amount","exchanged"),c=this.safeString(e,"pair");t=this.safeMarket(c,t);const u=this.safeString(e,a+"_fee"),h=this.safeString(e,a);let l;return u!==void 0&&(l={cost:u,currency:n==="buy"?t.base:t.quote}),this.safeTrade({id:s,order:h,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,type:void 0,side:n,price:o,amount:d,cost:void 0,takerOrMaker:a,fee:l,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id},a=await this.publicGetTradehistoryPair(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetPair(e),s=this.safeValue(t,"results",[]),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeSymbol(a,void 0,"_"),d=this.safeValue(r,"fees",[]),c=this.safeValue(d,0,{});i[o]={info:r,symbol:o,maker:this.safeNumber(c,"maker_fee"),taker:this.safeNumber(c,"taker_fee"),tierBased:!1}}return i}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"symbol"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"available"),a.used=this.safeString(i,"locked"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalancesExchangeBalances(e);return this.parseBalance(t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=t.toUpperCase(),d=s.toUpperCase(),c={pair:a.id,order_type:o,side:d,amount:this.amountToPrecision(e,i)};o==="LIMIT"&&(c.limit_price=this.priceToPrecision(e,n));const u=await this.privatePostOrderPair(this.extend(c,r));return this.parseOrder(u,a)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new yh(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={pair:i.id,order_id:e},r=await this.privatePostOrderPairOrderIdCancel(this.extend(n,s));return this.parseOrder(r,i)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new yh(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={pair:i.id,order_id:e},r=await this.privateGetOrderPairOrderId(this.extend(n,s));return this.parseOrder(r,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new yh(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={pair:n.id};s!==void 0&&(r.offset=s);const a=await this.privateGetOrderPair(this.extend(r,i)),o=this.safeValue(a,"results",{}),d=this.safeValue(o,"data",[]);return this.parseOrders(d,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"OPEN,PART"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"CLOS,CANC,COMP"};return await this.fetchOrders(e,t,s,this.extend(n,i))}parseOrderStatus(e){const t={OPEN:"open",PART:"open",CLOS:"canceled",CANC:"canceled",COMP:"closed"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"order_id"),i=this.safeString(e,"amount"),n=this.safeString(e,"notional"),r=this.safeStringLower(e,"order_type"),a=r==="market"?"fill_price":"limit_price",o=this.safeString(e,a),d=this.safeStringLower(e,"side"),c=this.parseOrderStatus(this.safeString(e,"status")),u=this.safeTimestamp(e,"created_at"),h=this.safeString(e,"fill_price"),l=this.safeString(e,"filled"),p=this.safeValue(e,"fills"),m=this.safeString(e,"pair");return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:u,datetime:this.iso8601(u),lastTradeTimestamp:void 0,symbol:this.safeSymbol(m,t,"_"),type:r,timeInForce:void 0,postOnly:void 0,side:d,price:o,stopPrice:this.safeString(e,"stop_price"),amount:i,cost:n,average:h,filled:l,remaining:void 0,status:c,fee:void 0,trades:p},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new yh(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={pair:n.id};s!==void 0&&(r.limit=s);const a=await this.privateGetTradePair(this.extend(r,i)),o=this.safeValue(a,"results",{}),d=this.safeValue(o,"data",[]);return this.parseTrades(d,n,t,s)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a="/"+this.version+"/"+this.implodeParams(e,i);let o=this.urls.api[t]+a;const d=this.omit(i,this.extractParams(e));return t==="public"?Object.keys(d).length&&(o+="?"+this.urlencode(d)):t==="private"&&(this.checkRequiredCredentials(),s==="POST"?r=this.json(d):Object.keys(d).length&&(o+="?"+this.urlencode(d)),n={"Content-Type":"application/json",Authorization:"Bearer "+this.apiKey}),{url:o,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"detail");if(c!==void 0){const h=this.id+" "+r;this.throwBroadlyMatchedException(this.exceptions.broad,c,h)}const u=this.safeValue(a,"errors");if(u!==void 0){const h=this.id+" "+r,l=Object.keys(u);for(let p=0;p<l.length;p++){const m=l[p],g=this.safeValue(u,m,[]),y=this.safeString(g,0);this.throwBroadlyMatchedException(this.exceptions.broad,y,h)}throw new hg(h)}}};const KG=ge,{ArgumentsRequired:XG,AuthenticationError:YG,ExchangeError:zo,InsufficientFunds:QG,OrderNotFound:wT,PermissionDenied:kT,BadRequest:ZG,BadSymbol:JG,DDoSProtection:e7,InvalidOrder:t7,AccountSuspended:s7}=de,{TICK_SIZE:i7}=me,Kn=Se;var n7=class extends KG{describe(){return this.deepExtend(super.describe(),{id:"stex",name:"STEX",countries:["EE"],rateLimit:1e3/3,certified:!1,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createMarketOrder:!1,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrder:!0,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactionFees:!0,fetchWithdrawal:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!0,withdraw:!0},version:"v3",urls:{logo:"https://user-images.githubusercontent.com/1294454/69680782-03fd0b80-10bd-11ea-909e-7f603500e9cc.jpg",api:{rest:"https://api3.stex.com"},www:"https://www.stex.com",doc:["https://apidocs.stex.com/","https://help.stex.com/en/collections/1593608-api-v3-documentation"],fees:"https://app.stex.com/en/pairs-specification",referral:"https://app.stex.com?ref=36416021"},requiredCredentials:{apiKey:!1,secret:!1,token:!0},timeframes:{"1m":"1","5m":"5","30m":"30","1h":"60","4h":"240","12h":"720","1d":"1D"},api:{public:{get:{currencies:1,"currencies/{currencyId}":1,markets:1,"pairs-groups":1,"currency_pairs/list/{code}":1,"currency_pairs/group/{currencyPairGroupId}":1,"currency_pairs/{currencyPairId}":1,ticker:1,"ticker/{currencyPairId}":1,"trades/{currencyPairId}":1,"orderbook/{currencyPairId}":1,"chart/{currencyPairId}/{candlesType}":1,"deposit-statuses":1,"deposit-statuses/{statusId}":1,"withdrawal-statuses":1,"withdrawal-statuses/{statusId}":1,ping:1,"mobile-versions":1,twitter:1}},trading:{get:{"fees/{currencyPairId}":1,orders:12,"orders/{currencyPairId}":6,"order/{orderId}":12},post:{"orders/{currencyPairId}":1.5,"orders/bulk/{currencyPairId}":12},delete:{orders:30,"orders/{currencyPairId}":12,"order/{orderId}":1.5}},reports:{get:{currencies:12,currency_pairs:12,orders:12,"orders/{orderId}":12,"trades/{currencyPairId}":12,"background/{listMode}":12,"background/{id}":12,"background/download/{id}":12},post:{"background/create":12},delete:{"background/{id}":12}},profile:{get:{info:3,wallets:3,"wallets/{walletId}":3,"wallets/address/{walletId}":3,deposits:3,"deposits/{id}":3,rewards:3,"rewards/{id}":3,addressbook:3,"addressbook/{itemId}":3,withdrawals:3,"withdrawals/{id}":3,notifications:3,"notifications/price":3,"favorite/currency_pairs":3,"token-scopes":3},post:{"wallets/burn/{walletId}":3,"wallets/{walletId}/hold_amount":3,"wallets/{currencyId}":3,"wallets/address/{walletId}":3,"addressbook/disable_item/{itemId}":3,"addressbook/enable_item/{itemId}":3,"addressbook/enable_strict_wd":3,"addressbook/disable_strict_wd":3,withdraw:30,"notifications/price":3,"referral/program":3,"referral/insert/{code}":3,"referral/bonus_transfer/{currencyId}":3},put:{"favorite/currency_pairs/set":3},delete:{"addressbook/{itemId}":3,"withdraw/{withdrawalId}":30,"notifications/price/{priceAlertId}":3}},verification:{get:{countries:1,status:1,"fractal/url":1,"smart-id":1,stex:1,"cryptonomica/code":1},post:{"smart-id":1,stex:1,cryptonomica:1}},settings:{get:{"notifications/{event}":1,notifications:1},put:{notifications:1,"notifications/set":1}}},fees:{trading:{tierBased:!1,percentage:!0,taker:this.parseNumber("0.002"),maker:this.parseNumber("0.002")}},commonCurrencies:{BC:"Bitcoin Confidential",BITS:"Bitcoinus",BITSW:"BITS",BHD:"Bithold",BTH:"Bithereum",MPH:"Chasyr Token",SBTC:"SBTCT"},options:{parseOrderToPrecision:!1,networks:{ERC20:5,ETH:5,OMNI:10,XLM:20,BEP2:22,TRC20:24,TRX:24,SOL:25,BEP20:501},accountsByType:{spot:"spot",hold:"hold",funding:"funding",referal:"referal"},transfer:{fillResponseFromRequest:!0}},precisionMode:i7,exceptions:{exact:{"Wrong parameters":ZG,"Unauthenticated.":YG,"Server Error":zo,"This feature is only enabled for users verifies by Cryptonomica":kT,"Too Many Attempts.":e7,"Selected Pair is disabled":JG,"Invalid scope(s) provided.":kT,"The maximum amount of open orders with the same price cannot exceed 10":t7,"Your account not verified!":s7},broad:{"Not enough":QG}}})}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s={},i=this.safeValue(t,"data",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"id"),o=this.safeInteger(r,"id"),d=this.safeCurrencyCode(this.safeString(r,"code")),c=this.parseNumber(this.parsePrecision(this.safeString(r,"precision"))),u=this.safeNumber(r,"withdrawal_fee_const"),h=this.safeValue(r,"active",!0);s[d]={id:a,numericId:o,code:d,info:r,type:void 0,name:this.safeString(r,"name"),active:h,deposit:void 0,withdraw:void 0,fee:u,precision:c,limits:{amount:{min:c,max:void 0},deposit:{min:this.safeNumber(r,"minimum_deposit_amount"),max:void 0},withdraw:{min:this.safeNumber(r,"minimum_withdrawal_amount"),max:void 0}}}}return s}async fetchMarkets(e={}){const t={code:"ALL"},s=await this.publicGetCurrencyPairsListCode(this.extend(t,e)),i=[],n=this.safeValue(s,"data",[]);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeString(a,"id"),d=this.safeInteger(a,"id"),c=this.safeString(a,"currency_id"),u=this.safeString(a,"market_currency_id"),h=this.safeInteger(a,"currency_id"),l=this.safeInteger(a,"market_currency_id"),p=this.safeCurrencyCode(this.safeString(a,"currency_code")),m=this.safeCurrencyCode(this.safeString(a,"market_code")),g=this.safeString(a,"min_buy_price"),y=this.safeString(a,"min_sell_price"),b=Kn.stringMax(g,y),w=Kn.stringDiv(this.safeString(a,"buy_fee_percent"),"100"),k=Kn.stringDiv(this.safeString(a,"sell_fee_percent"),"100"),T=Kn.stringMax(w,k);i.push({id:o,numericId:d,symbol:p+"/"+m,base:p,quote:m,settle:void 0,baseId:c,quoteId:u,settleId:void 0,baseNumericId:h,quoteNumericId:l,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:this.safeValue(a,"active"),contract:!1,linear:void 0,inverse:void 0,taker:T,maker:T,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(a,"currency_precision"))),price:this.parseNumber(this.parsePrecision(this.safeString(a,"market_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(a,"min_order_amount"),max:void 0},price:{min:b,max:void 0},cost:{min:void 0,max:void 0}},info:a})}return i}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={currencyPairId:s.id},n=await this.publicGetTickerCurrencyPairId(this.extend(i,t)),r=this.safeValue(n,"data",{});return this.parseTicker(r,s)}async fetchTime(e={}){const t=await this.publicGetPing(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"server_datetime",{});return this.parse8601(this.safeString(i,"date"))}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={currencyPairId:this.market(e).id};t!==void 0&&(n.limit_bids=t,n.limit_asks=t);const r=await this.publicGetOrderbookCurrencyPairId(this.extend(n,s)),a=this.safeValue(r,"data",{});return this.parseOrderBook(a,e,void 0,"bid","ask","price","amount")}parseTicker(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString2(e,"id","symbol"),n=this.safeSymbol(i,t,"_"),r=this.safeString(e,"last"),a=this.safeString(e,"open");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:a,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volumeQuote"),quoteVolume:this.safeString(e,"volume"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTicker(t),i=this.safeValue(s,"data",[]);return this.parseTickers(i,e)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"time"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={currencyPairId:r.id,candlesType:this.timeframes[t]};i===void 0?i=100:a.limit=i;const o=this.parseTimeframe(t),d=i*o;s===void 0?(a.timeEnd=this.seconds(),a.timeStart=a.timeEnd-d):(a.timeStart=parseInt(s/1e3),a.timeEnd=this.sum(a.timeStart,d));const c=await this.publicGetChartCurrencyPairIdCandlesType(this.extend(a,n)),u=this.safeValue(c,"data",[]);return this.parseOHLCVs(u,r,t,s,i)}parseTrade(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeTimestamp(e,"timestamp"),n=this.safeString(e,"price"),r=this.safeString(e,"amount");let a;a===void 0&&t!==void 0&&(a=t.symbol);const o=this.safeStringLower2(e,"type","trade_type");return this.safeTrade({info:e,timestamp:i,datetime:this.iso8601(i),symbol:a,id:s,order:void 0,type:void 0,takerOrMaker:void 0,side:o,price:n,amount:r,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={currencyPairId:n.id};s!==void 0&&(r.limit=s),t!==void 0&&(r.sort="ASC",r.from=parseInt(t/1e3));const a=await this.publicGetTradesCurrencyPairId(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={currencyPairId:s.id},n=await this.tradingGetFeesCurrencyPairId(this.extend(i,t)),r=this.safeValue(n,"data");return{info:n,symbol:s.symbol,maker:this.safeNumber(r,"sell_fee"),taker:this.safeNumber(r,"buy_fee"),percentage:!0,tierBased:!0}}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"data",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeCurrencyCode(this.safeString(n,"currency_id")),a=this.account();a.free=this.safeString(n,"balance"),a.used=this.safeString(n,"frozen_balance"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.profileGetWallets(e);return this.parseBalance(t)}parseOrderStatus(e){const t={PROCESSING:"open",PENDING:"open",PARTIAL:"open",FINISHED:"closed",CANCELLED:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.parseOrderStatus(this.safeString(e,"status")),n=this.safeString2(e,"currency_pair_id","currency_pair_name"),r=this.safeSymbol(n,t,"_"),a=this.safeTimestamp(e,"timestamp"),o=this.safeString(e,"price"),d=this.safeString(e,"initial_amount"),c=this.safeString(e,"processed_amount");let u,h;c!==void 0&&(d!==void 0&&(u=Kn.stringSub(d,c),this.options.parseOrderToPrecision&&(u=this.amountToPrecision(r,u)),u=Kn.stringMax(u,"0.0")),o!==void 0&&h===void 0&&(h=Kn.stringMul(o,c)));let l=this.safeString(e,"original_type");(l==="BUY"||l==="SELL")&&(l=void 0);const p=this.safeStringLower(e,"type"),m=this.safeValue(e,"trades"),g=this.safeNumber(e,"trigger_price"),y={info:e,id:s,clientOrderId:void 0,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:void 0,symbol:r,type:l,timeInForce:void 0,postOnly:void 0,side:p,price:o,stopPrice:g,amount:d,cost:h,average:void 0,filled:c,remaining:u,status:i,trades:m},b=this.safeValue(e,"fees");if(b===void 0)y.fee=void 0;else if(b.length>0){y.fees=[];for(let k=0;k<b.length;k++){const T=this.safeString(b[k],"amount");if(T!==void 0){const O=this.safeString(b[k],"currency_id"),x=this.safeCurrencyCode(O);y.fees.push({cost:T,currency:x})}}}else y.fee=void 0;return this.safeOrder(y,t)}async createOrder(e,t,s,i,n=void 0,r={}){if(t==="market")throw new zo(this.id+" createOrder() allows limit orders only");await this.loadMarkets();const a=this.market(e);t==="limit"&&(t=s);const o={currencyPairId:a.id,type:t.toUpperCase(),amount:parseFloat(this.amountToPrecision(e,i)),price:parseFloat(this.priceToPrecision(e,n))},d=await this.tradingPostOrdersCurrencyPairId(this.extend(o,r)),c=this.safeValue(d,"data",{});return this.parseOrder(c,a)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e},n=await this.tradingGetOrderOrderId(this.extend(i,s)),r=this.safeValue(n,"data",{});let a;return t!==void 0&&(a=this.market(t)),this.parseOrder(r,a)}async fetchClosedOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e},n=await this.reportsGetOrdersOrderId(this.extend(i,s)),r=this.safeValue(n,"data",{});let a;return t!==void 0&&(a=this.market(t)),this.parseOrder(r,a)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){return(await this.fetchClosedOrder(e,t,n)).trades}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r="tradingGetOrders";const a={};e!==void 0&&(r="tradingGetOrdersCurrencyPairId",n=this.market(e),a.currencyPairId=n.id),s!==void 0&&(a.limit=s);const o=await this[r](this.extend(a,i)),d=this.safeValue(o,"data",[]);return this.parseOrders(d,n,t,s)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e},n=await this.tradingDeleteOrderOrderId(this.extend(i,s)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"put_into_processing_queue",[]),o=this.safeValue(r,"not_put_into_processing_queue",[]),d=a.length,c=o.length;if(d<1){if(c<1)throw new wT(this.id+" cancelOrder() received an empty response: "+this.json(n));return this.parseOrder(o[0])}else{if(c<1)return this.parseOrder(a[0]);throw new wT(this.id+" cancelOrder() received an empty response: "+this.json(n))}}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i="tradingDeleteOrders";if(e!==void 0){const r=this.market(e);s.currencyPairId=r.id,i="tradingDeleteOrdersCurrencyPairId"}return await this[i](this.extend(s,t))}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new XG(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={currencyPairId:n.id};t!==void 0&&(r.timeStart=this.iso8601(t)),s!==void 0&&(r.limit=s);const a=await this.reportsGetTradesCurrencyPairId(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTrades(o,n,t,s)}async createDepositAddress(e,t={}){await this.loadMarkets();const i={currencyId:this.currency(e).id},n=await this.profilePostWalletsCurrencyId(this.extend(i,t)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"deposit_address",{}),o=this.safeString(a,"address"),d=this.safeString(a,"additional_address_parameter");return this.checkAddress(o),{currency:e,address:o,tag:d,info:n}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=await this.fetchBalance(),i=this.safeValue(s.info,"data",[]),n=this.indexBy(i,"currency_id"),r=this.currency(e),a=this.safeValue(n,r.id);if(a===void 0)throw new zo(this.id+" fetchDepositAddress() could not find the wallet id for currency code "+e+", try to call createDepositAddress() first");const o=this.safeInteger(a,"id");if(o===void 0)throw new zo(this.id+" fetchDepositAddress() could not find the wallet id for currency code "+e+", try to call createDepositAddress() first");const d={walletId:o},c=await this.profileGetWalletsWalletId(this.extend(d,t)),u=this.safeValue(c,"data",[]),h=this.safeValue(u,"deposit_address",{}),l=this.safeString(h,"address"),p=this.safeString(h,"additional_address_parameter");return this.checkAddress(l),{currency:e,address:l,tag:p,network:void 0,info:c}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+t+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));return t==="public"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):(this.checkRequiredCredentials(),n={Authorization:"Bearer "+this.token},s==="GET"||s==="DELETE"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):(r=this.json(o),Object.keys(o).length&&(n["Content-Type"]="application/json"))),{url:a,method:s,body:r,headers:n}}parseTransactionStatus(e){const t={processing:"pending","checking by system":"pending",hodl:"pending","amount too low":"failed","not confirmed":"pending","cancelled by user":"canceled",approved:"pending",finished:"ok","withdrawal error":"failed","deposit error":"failed","cancelled by admin":"canceled",awaiting:"pending"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeValue(e,"withdrawal_address",{}),n=this.safeString(i,"address"),r=this.safeString(i,"additional_address_parameter"),a=this.safeString(e,"currency_id");let o;a in this.currencies_by_id?t=this.currencies_by_id[a]:o=this.commonCurrencyCode(this.safeString(e,"currency_code")),o===void 0&&t!==void 0&&(o=t.code);const d="deposit_status_id"in e?"deposit":"withdrawal",c=this.safeNumber(e,"amount"),u=this.parseTransactionStatus(this.safeStringLower(e,"status")),h=this.safeTimestamp2(e,"timestamp","created_ts"),l=this.safeTimestamp(e,"updated_ts"),p=this.safeString(e,"txid");let m;const g=this.safeNumber(e,"fee");if(g!==void 0){const b=this.safeString2(e,"fee_currency_id","deposit_fee_currency_id"),w=this.safeCurrencyCode(b);m={cost:g,currency:w}}const y=this.safeString(i,"protocol_name");return{info:e,id:s,txid:p,timestamp:h,datetime:this.iso8601(h),network:y,addressFrom:void 0,address:n,addressTo:n,tagFrom:void 0,tag:r,tagTo:r,type:d,amount:c,currency:o,status:u,updated:l,fee:m}}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.profileGetDepositsId(this.extend(i,s)),r=this.safeValue(n,"data",{});return this.parseTransaction(r)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.currencyId=n.id),s!==void 0&&(r.limit=s),t!==void 0&&(r.timeStart=t);const a=await this.profileGetDeposits(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s)}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},n=await this.profileGetWithdrawalsId(this.extend(i,s)),r=this.safeValue(n,"data",{});return this.parseTransaction(r)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.currency(e),r.currencyId=n.id),s!==void 0&&(r.limit=s),t!==void 0&&(r.timeStart=t);const a=await this.profileGetWithdrawals(this.extend(r,i)),o=this.safeValue(a,"data",[]);return this.parseTransactions(o,n,t,s)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e);let a;const o={};if(s==="referal"&&i==="spot")o.currencyId=r.id,a="profilePostReferralBonusTransferCurrencyId";else if(i==="hold")o.walletId=s,t=this.currencyToPrecision(e,t),t=Kn.stringNeg(t),o.amount=t,a="profilePostWalletsWalletIdHoldAmount";else if(s==="hold")o.walletId=i,o.amount=t,a="profilePostWalletsWalletIdHoldAmount";else throw new zo(this.id+" transfer() only allows transfers of referal to spot and between a walletId and funding");const d=await this[a](this.extend(o,n)),c=this.safeValue(d,"data",{}),u=this.parseTransfer(c,r),h=this.safeValue(this.options,"transfer",{});return this.safeValue(h,"fillResponseFromRequest",!0)&&(u.fromAccount=s,u.toAccount=i,typeof t=="string"&&Kn.stringLt(t,"0")&&(t=this.parseNumber(Kn.stringNeg(t))),u.amount=t,u.currency===void 0&&(u.currency=e)),u}parseTransfer(e,t=void 0){const s=this.safeString(e,"currency_id");let i;return s in this.currencies_by_id?t=this.currencies_by_id[s]:i=this.commonCurrencyCode(this.safeString(e,"currency_code")),i===void 0&&(i=this.safeValue(t,"code")),{info:e,id:this.safeString(e,"id"),timestamp:void 0,datetime:void 0,currency:i,amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={currency_id:r.id,amount:parseFloat(this.currencyToPrecision(e,t)),address:s};i!==void 0&&(a.additional_address_parameter=i);const o=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(n,"network");d=this.safeInteger(o,d,d),d!==void 0&&(a.protocol_id=d,n=this.omit(n,"network"));const c=await this.profilePostWithdraw(this.extend(a,n)),u=this.safeValue(c,"data",{});return this.parseTransaction(u,r)}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=Object.keys(this.currencies),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.currencies[r];if(e!==void 0&&!this.inArray(r,e))continue;const o=this.safeValue(a,"info");i[r]={withdraw:this.safeNumber(a,"fee"),deposit:this.safeNumber(o,"deposit_fee_const"),info:o}}return i}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;if(!this.safeValue(a,"success",!1)){const u=this.safeString(a,"message"),h=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,h),this.throwBroadlyMatchedException(this.exceptions.broad,u,h),new zo(h)}}};const r7=ge,{ExchangeError:ST,ArgumentsRequired:pg,BadRequest:Ja,OrderNotFound:a7,InvalidAddress:vT}=de,{TICK_SIZE:o7}=me,da=Se;var d7=class extends r7{describe(){return this.deepExtend(super.describe(),{id:"therock",name:"TheRockTrading",countries:["MT"],rateLimit:100,version:"v1",has:{CORS:void 0,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelOrder:!0,createOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransactions:"emulated",fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawals:!0,transfer:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766869-75057fa2-5ee9-11e7-9a6f-13e641fa4707.jpg",api:{rest:"https://api.therocktrading.com"},www:"https://therocktrading.com",doc:["https://api.therocktrading.com/doc/v1/index.html","https://api.therocktrading.com/doc/"]},api:{public:{get:{funds:1,"funds/{id}":1,"funds/{id}/orderbook":1,"funds/{id}/ticker":1,"funds/{id}/trades":1,"funds/{id}/ohlc_statistics":1,"funds/tickers":1}},private:{get:{balances:1,"balances/{id}":1,discounts:1,"discounts/{id}":1,funds:1,"funds/{id}":1,"funds/{id}/trades":1,"funds/{fund_id}/orders":1,"funds/{fund_id}/orders/{id}":1,"funds/{fund_id}/position_balances":1,"funds/{fund_id}/positions":1,"funds/{fund_id}/positions/{id}":1,transactions:1,"transactions/{id}":1,"withdraw_limits/{id}":1,withdraw_limits:1},post:{"atms/withdraw":1,"funds/{fund_id}/orders":1},delete:{"funds/{fund_id}/orders/{id}":1,"funds/{fund_id}/orders/remove_all":1}}},fees:{trading:{maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{BTC:0,BCH:0,PPC:0,ETH:0,ZEC:0,LTC:0,EUR:0}}},precisionMode:o7,exceptions:{exact:{"Request already running":Ja,"cannot specify multiple address types":Ja,"Currency is not included in the list":Ja,"Record not found":a7},broad:{"before must be greater than after param":Ja,"must be shorter than 60 days":Ja,"must be a multiple of (period param) in minutes":Ja,"Address allocation limit reached for currency":vT,"is not a valid value for param currency":Ja," is invalid":vT}},options:{withdraw:{fillResponseFromRequest:!0}}})}async fetchMarkets(e={}){const t=await this.publicGetFunds(e),s=this.safeValue(t,"funds"),i=[];if(s===void 0)throw new ST(this.id+" fetchMarkets() got an unexpected response");for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"id"),o=this.safeString(r,"trade_currency"),d=this.safeString(r,"base_currency"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d),h=this.safeString(r,"buy_fee"),l=this.safeString(r,"sell_fee");let p=da.stringMax(h,l);p=this.parseNumber(da.stringDiv(p,"100"));const m=this.safeValue(r,"leverages"),g=m.length;i.push({id:a,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:g>0,swap:!1,future:!1,option:!1,contract:!1,linear:void 0,inverse:void 0,taker:p,maker:p,contractSize:void 0,active:!0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"trade_currency_decimals"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"base_currency_decimals")))},limits:{leverage:{min:1,max:this.safeValue(m,g-1,1)},amount:{min:this.safeNumber(r,"minimum_quantity_offer"),max:void 0},price:{min:this.safeNumber(r,"minimum_price_offer"),max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}parseBalance(e){const t=this.safeValue(e,"balances",[]),s={info:e};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(n,"trading_balance"),o.total=this.safeString(n,"balance"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalances(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={id:i.id},r=await this.publicGetFundsIdOrderbook(this.extend(n,s)),a=this.parse8601(this.safeString(r,"date"));return this.parseOrderBook(r,i.symbol,a,"bids","asks","price","amount")}parseTicker(e,t=void 0){const s=this.parse8601(this.safeString(e,"date"));t=this.safeMarket(void 0,t);const i=this.safeString(e,"last");return this.safeTicker({symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:i,last:i,previousClose:this.safeString(e,"close"),change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume_traded"),quoteVolume:this.safeString(e,"volume"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetFundsTickers(t),i=this.indexBy(s.tickers,"fund_id"),n=Object.keys(i),r={};for(let a=0;a<n.length;a++){const o=n[a],d=this.safeMarket(o),c=d.symbol,u=i[o];r[c]=this.parseTicker(u,d)}return this.filterByArray(r,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={id:s.id},n=await this.publicGetFundsIdTicker(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"fund_id"),i=this.safeSymbol(s,t),n=this.parse8601(this.safeString(e,"date")),r=this.safeString(e,"id"),a=this.safeString(e,"order_id"),o=this.safeString(e,"side"),d=this.safeString(e,"price"),c=this.safeString(e,"amount");let u,h;const l=this.safeValue(e,"transactions",[]),p=this.groupBy(l,"type"),m=this.safeValue(p,"paid_commission",[]);for(let g=0;g<m.length;g++)h===void 0&&(h="0.0"),h=da.stringAdd(h,this.safeString(m[g],"price"));return h!==void 0&&(u={cost:h,currency:t.quote}),this.safeTrade({info:e,id:r,order:a,timestamp:n,datetime:this.iso8601(n),symbol:i,type:void 0,side:o,takerOrMaker:void 0,price:d,amount:c,cost:void 0,fee:u},t)}parseLedgerEntryDirection(e){const t={affiliate_earnings:"in",atm_payment:"in",bought_currency_from_fund:"out",bought_shares:"out",paid_commission:"out",paypal_payment:"in",pos_payment:"in",released_currency_to_fund:"out",rollover_commission:"out",sold_currency_to_fund:"in",sold_shares:"in",transfer_received:"in",transfer_sent:"out",withdraw:"out"};return this.safeString(t,e,e)}parseLedgerEntryType(e){const t={affiliate_earnings:"referral",atm_payment:"transaction",bought_currency_from_fund:"trade",bought_shares:"trade",paid_commission:"fee",paypal_payment:"transaction",pos_payment:"transaction",released_currency_to_fund:"trade",rollover_commission:"fee",sold_currency_to_fund:"trade",sold_shares:"trade",transfer_received:"transfer",transfer_sent:"transfer",withdraw:"transaction"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"id");let i,n=this.safeString(e,"type");const r=this.parseLedgerEntryDirection(n);n=this.parseLedgerEntryType(n),(n==="trade"||n==="fee")&&(i=this.safeString(e,"trade_id"));const a=this.safeString(e,"currency"),o=this.safeCurrencyCode(a),d=this.safeNumber(e,"price"),c=this.parse8601(this.safeString(e,"date"));return{info:e,id:s,direction:r,account:void 0,referenceId:i,referenceAccount:void 0,type:n,currency:o,amount:d,before:void 0,after:void 0,status:"ok",timestamp:c,datetime:this.iso8601(c),fee:void 0}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),t!==void 0&&(n.after=this.iso8601(t));const a=await this.privateGetTransactions(this.extend(n,i)),o=this.safeValue(a,"transactions",[]);return this.parseLedger(o,r,t,s)}parseTransactionType(e){const t={withdraw:"withdrawal",atm_payment:"deposit"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"id","transaction_id"),i=this.parseTransactionType(this.safeString(e,"type")),n=this.safeValue(e,"transfer_detail",{}),r=this.safeString(n,"method");let a,o;r!==void 0&&r!=="wire_transfer"&&(a=this.safeString(n,"id"),o=this.safeString(n,"recipient"));const d=this.safeString(e,"currency"),c=this.safeCurrencyCode(d),u=this.safeNumber(e,"price"),h=this.parse8601(this.safeString(e,"date")),l="ok",p=this.safeString(n,"method");return{info:e,id:s,currency:c,amount:u,network:p,addressFrom:void 0,addressTo:o,address:o,tagFrom:void 0,tagTo:void 0,tag:void 0,status:l,type:i,updated:void 0,txid:a,timestamp:h,datetime:this.iso8601(h),fee:void 0}}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const n={type:"withdraw"};return await this.fetchTransactions(e,t,s,this.extend(n,i))}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){const n={type:"atm_payment"};return await this.fetchTransactions(e,t,s,this.extend(n,i))}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),t!==void 0&&(n.after=this.iso8601(t)),i=this.extend(n,i);const a=await this.privateGetTransactions(i),o=this.safeValue(a,"transactions",[]),d=["withdraw","atm_payment"],c=this.filterByArray(o,"type",d,!1);return this.parseTransactions(c,r,t,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),await this.loadMarkets();const r=this.currency(e);t=this.currencyToPrecision(e,t);const a={currency:r.id,destination_address:s,amount:parseFloat(t)};i!==void 0&&(a.destination_tag=i);const o=await this.privatePostAtmsWithdraw(this.extend(a,n)),d=this.parseTransaction(o,r),c=this.safeValue(this.options,"withdraw",{});return this.safeValue(c,"fillResponseFromRequest",!0)&&(d.addressTo===s&&(d.addressTo=s),d.address===void 0&&(d.address=s),d.tagTo===void 0&&(d.tagTo=i),d.tag===void 0&&(d.tag=i),d.amount===void 0&&(d.amount=t)),d}parseOrderStatus(e){const t={active:"open",executed:"closed",deleted:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"fund_id"),n=this.safeSymbol(i,t),r=this.parseOrderStatus(this.safeString(e,"status")),a=this.parse8601(this.safeString(e,"date")),o=this.safeString(e,"type"),d=this.safeString(e,"side"),c=this.safeNumber(e,"amount"),u=this.safeNumber(e,"amount_unfilled");let h;c!==void 0&&u!==void 0&&(h=c-u);const l=this.safeNumber(e,"price");let p=this.safeValue(e,"trades"),m,g,y;if(p!==void 0){const w=p.length;if(w>0){p=this.parseTrades(p,t,void 0,void 0,{orderId:s}),m=0,h=0;for(let k=0;k<w;k++){const T=p[k];m=this.sum(m,T.cost),h=this.sum(h,T.amount)}h>0&&(g=m/h),y=p[w-1].timestamp}else m=0}const b=this.safeNumber(e,"conditional_price");return{id:s,clientOrderId:void 0,info:e,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:y,status:r,symbol:n,type:o,timeInForce:void 0,postOnly:void 0,side:d,price:l,stopPrice:b,cost:m,amount:c,filled:h,average:g,remaining:u,fee:void 0,trades:p}}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"active"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={status:"executed"};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new pg(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={fund_id:n.id};t!==void 0&&(r.after=this.iso8601(t));const a=await this.privateGetFundsFundIdOrders(this.extend(r,i)),o=this.safeValue(a,"orders",[]);return this.parseOrders(o,n,t,s)}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new pg(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n={id:e,fund_id:i.id},r=await this.privateGetFundsFundIdOrdersId(this.extend(n,s));return this.parseOrder(r)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets(),t==="market"&&(n=0);const o={fund_id:this.market(e).id,side:s,amount:i,price:n},d=await this.privatePostFundsFundIdOrders(this.extend(o,r));return this.parseOrder(d)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e,fund_id:this.marketId(t)},n=await this.privateDeleteFundsFundIdOrdersId(this.extend(i,s));return this.parseOrder(n)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.parseTimeframe(t),o=parseInt(a/60),d={id:r.id,period:o};s===void 0&&(d.after=this.iso8601(s));const c=await this.publicGetFundsIdOhlcStatistics(this.extend(d,n));return this.parseOHLCVs(c,r,t,s,i)}parseOHLCV(e,t=void 0){const s=this.safeString(e,"interval_starts_at");return[this.parse8601(s),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"base_volume")]}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new pg(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={id:n.id};s!==void 0&&(r.per_page=s),t!==void 0&&(r.after=this.iso8601(t));const a=await this.privateGetFundsIdTrades(this.extend(r,i)),o=this.safeValue(a,"trades",[]);return this.parseTrades(o,n,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={id:n.id};s!==void 0&&(r.per_page=s),t!==void 0&&(r.after=this.iso8601(t));const a=await this.publicGetFundsIdTrades(this.extend(r,i));return this.parseTrades(a.trades,n,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e);let i={id:s.id};const n=await this.publicGetFundsId(this.extend(i,t));i={id:s.quoteId};const r=await this.privateGetDiscountsId(this.extend(i,t));return this.parseTradingFee(n,r,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetFunds(e),s=await this.privateGetDiscounts(e),i=this.safeValue(t,"funds",[]),n=this.safeValue(s,"discounts",[]),r={};for(let a=0;a<i.length;a++){const o=i[a],d=this.safeString(o,"id"),c=this.safeMarket(d),u=this.safeValue(c,"quoteId"),h=this.filterBy(n,"currency",u),l=this.parseTradingFee(o,h,c),p=l.symbol;r[p]=l}return r}parseTradingFee(e,t=void 0,s=void 0){const i=this.safeString(e,"id"),n=this.safeString(e,"buy_fee"),r=this.safeString(e,"sell_fee"),a=this.safeString(t,"discount","0"),o=da.stringSub("100",a),d=this.parseNumber(da.stringDiv(da.stringMul(n,o),"10000")),c=this.parseNumber(da.stringDiv(da.stringMul(r,o),"10000"));return{info:e,symbol:this.safeSymbol(i,s),maker:c,taker:d,percentage:!0,tierBased:!0}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(n=n===void 0?{}:n,t==="private"){if(this.checkRequiredCredentials(),Object.keys(o).length)if(s==="POST")r=this.json(o),n["Content-Type"]="application/json";else{const u=this.rawencode(o);u.length&&(a+="?"+u)}const d=this.nonce().toString(),c=d+a;n["X-TRT-KEY"]=this.apiKey,n["X-TRT-NONCE"]=d,n["X-TRT-SIGN"]=this.hmac(this.encode(c),this.encode(this.secret),"sha512")}else t==="public"&&Object.keys(o).length&&(a+="?"+this.rawencode(o));return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeValue(a,"errors",[]),u=c.length;if(u>0){const h=this.id+" "+r;for(let l=0;l<u;l++){const p=c[l],m=this.safeString(p,"message");this.throwExactlyMatchedException(this.exceptions.exact,m,h),this.throwBroadlyMatchedException(this.exceptions.broad,m,h)}throw new ST(h)}}};const c7=ge,{ExchangeError:jc,ArgumentsRequired:u7,ExchangeNotAvailable:mg,InsufficientFunds:TT,OrderNotFound:f7,DDoSProtection:h7,InvalidOrder:eo,AuthenticationError:gg,PermissionDenied:l7}=de,{TICK_SIZE:p7}=me,OT=Se;var m7=class extends c7{describe(){return this.deepExtend(super.describe(),{id:"tidex",name:"Tidex",countries:["UK"],rateLimit:2e3,version:"3",userAgent:this.userAgents.chrome,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchCurrencies:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/30781780-03149dc4-a12e-11e7-82bb-313b269d24d4.jpg",api:{web:"https://gate.tidex.com/api",public:"https://api.tidex.com/api/3",private:"https://api.tidex.com/tapi"},www:"https://tidex.com",doc:"https://tidex.com/exchange/public-api",referral:"https://tidex.com/exchange",fees:["https://tidex.com/exchange/assets-spec","https://tidex.com/exchange/pairs-spec"]},api:{web:{get:["currency","pairs","tickers","orders","ordershistory","trade-data","trade-data/{id}"]},public:{get:["info","ticker/{pair}","depth/{pair}","trades/{pair}"]},private:{post:["getInfoExt","getInfo","Trade","ActiveOrders","OrderInfo","CancelOrder","TradeHistory","getDepositAddress","createWithdraw","getWithdraw"]}},fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0.001")}},commonCurrencies:{DSH:"DASH",EMGO:"MGO",MGO:"WMGO"},precisionMode:p7,exceptions:{exact:{803:eo,804:eo,805:eo,806:eo,807:eo,831:TT,832:TT,833:f7},broad:{"Invalid pair name":jc,"invalid api key":gg,"invalid sign":gg,"api key dont have trade permission":gg,"invalid parameter":eo,"invalid order":eo,"Requests too often":h7,"not available":mg,"data unavailable":mg,"external service unavailable":mg,"IP restricted":l7}},options:{fetchTickersMaxLength:2048},orders:{}})}async fetchCurrencies(e={}){const t=await this.webGetCurrency(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"symbol"),a=this.safeCurrencyCode(r);let d=this.safeValue(n,"visible")===!0;const c=this.safeValue(n,"withdrawEnable",!0),u=this.safeValue(n,"depositEnable",!0);(!c||!u)&&(d=!1);const h=this.safeString(n,"name"),l=this.safeNumber(n,"withdrawFee");s[a]={id:r,code:a,name:h,active:d,deposit:u,withdraw:c,precision:this.parseNumber(this.parsePrecision(this.safeString(n,"amountPoint"))),funding:{withdraw:{active:c,fee:l},deposit:{active:u,fee:this.parseNumber("0")}},limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.safeNumber(n,"withdrawMinAmount"),max:void 0},deposit:{min:this.safeNumber(n,"depositMinAmount"),max:void 0}},info:n}}return s}async fetchMarkets(e={}){const s=(await this.publicGetInfo(e)).pairs,i=Object.keys(s),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=s[a],[d,c]=a.split("_"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),l=this.safeInteger(o,"hidden");let p=this.safeString(o,"fee");p=OT.stringDiv(p,"100"),n.push({id:a,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:l===0,contract:!1,linear:void 0,inverse:void 0,taker:this.parseNumber(p),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(o,"decimal_places"))),price:this.parseNumber(this.parsePrecision(this.safeString(o,"decimal_places")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(o,"min_amount"),max:this.safeNumber(o,"max_amount")},price:{min:this.safeNumber(o,"min_price"),max:this.safeNumber(o,"max_price")},cost:{min:this.safeNumber(o,"min_total"),max:void 0}},info:o})}return n}parseBalance(e){const t=this.safeValue(e,"return"),s=this.safeTimestamp(t,"server_time"),i={info:e,timestamp:s,datetime:this.iso8601(s)},n=this.safeValue(t,"funds",{}),r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeCurrencyCode(o),c=this.safeValue(n,o,{}),u=this.account();u.free=this.safeString(c,"value"),u.used=this.safeString(c,"inOrders"),i[d]=u}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetInfoExt(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetDepthPair(this.extend(n,s));if(!(i.id in r))throw new jc(this.id+" "+i.symbol+" order book is empty or not available");const o=r[i.id];return this.parseOrderBook(o,e)}async fetchOrderBooks(e=void 0,t=void 0,s={}){await this.loadMarkets();let i;if(e===void 0){if(i=this.ids.join("-"),i.length>2048){const o=this.ids.length;throw new jc(this.id+" fetchOrderBooks() has "+o.toString()+" symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchOrderBooks")}}else i=this.marketIds(e),i=i.join("-");const n={pair:i};t!==void 0&&(n.limit=t);const r=await this.publicGetDepthPair(this.extend(n,s)),a={};i=Object.keys(r);for(let o=0;o<i.length;o++){const d=i[o],c=this.safeSymbol(d);a[c]=this.parseOrderBook(r[d],c)}return a}parseTicker(e,t=void 0){const s=this.safeTimestamp(e,"updated");t=this.safeMarket(void 0,t);const i=this.safeString(e,"last");return this.safeTicker({symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:i,last:i,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeString(e,"avg"),baseVolume:this.safeString(e,"vol_cur"),quoteVolume:this.safeString(e,"vol"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s=this.ids;if(e===void 0){const o=s.length;if(s=s.join("-"),s.length>this.options.fetchTickersMaxLength){const d=this.safeInteger(this.options,"fetchTickersMaxLength",2048);throw new u7(this.id+" fetchTickers() has "+o.toString()+" markets exceeding max URL length for this endpoint ("+d.toString()+" characters), please, specify a list of symbols of interest in the first argument to fetchTickers")}}else s=this.marketIds(e),s=s.join("-");const i={pair:s},n=await this.publicGetTickerPair(this.extend(i,t)),r={},a=Object.keys(n);for(let o=0;o<a.length;o++){const d=a[o],c=this.safeMarket(d),u=c.symbol;r[u]=this.parseTicker(n[d],c)}return this.filterByArray(r,"symbol",e)}async fetchTicker(e,t={}){return(await this.fetchTickers([e],t))[e]}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"timestamp");let i=this.safeString(e,"type");i==="ask"?i="sell":i==="bid"&&(i="buy");const n=this.safeString2(e,"rate","price"),r=this.safeString2(e,"trade_id","tid"),a=this.safeString(e,"order_id"),o=this.safeString(e,"pair"),d=this.safeSymbol(o,t),c=this.safeString(e,"amount"),u=this.parseNumber(n),h=this.parseNumber(c),l=this.parseNumber(OT.stringMul(n,c)),p="limit";let m,g;const y=this.safeNumber(e,"commission");if(y!==void 0){const w=this.safeString(e,"commissionCurrency"),k=this.safeCurrencyCode(w);g={cost:y,currency:k}}const b=this.safeValue(e,"is_your_order");return b!==void 0&&(m="taker",b&&(m="maker"),g===void 0&&(g=this.calculateFee(d,p,i,h,u,m))),{id:r,order:a,timestamp:s,datetime:this.iso8601(s),symbol:d,type:p,side:i,takerOrMaker:m,price:u,amount:h,cost:l,fee:g,info:e}}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetTradesPair(this.extend(r,i));return Array.isArray(a)&&a.length===0?[]:this.parseTrades(a[n.id],n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){if(t==="market")throw new jc(this.id+" createOrder() allows limit orders only");const a=i.toString(),o=n.toString();await this.loadMarkets();const d=this.market(e),c={pair:d.id,type:s,amount:this.amountToPrecision(e,i),rate:this.priceToPrecision(e,n)},u=await this.privatePostTrade(this.extend(c,r));let h,l="open",p="0.0",m=a;const g=this.safeValue(u,"return");g!==void 0&&(h=this.safeString(g,"order_id"),h==="0"&&(h=this.safeString(g,"init_order_id"),l="closed"),p=this.safeString(g,"received",p),m=this.safeString(g,"remains",a));const y=this.milliseconds();return this.safeOrder({id:h,timestamp:y,datetime:this.iso8601(y),lastTradeTimestamp:void 0,status:l,symbol:e,type:t,side:s,price:o,cost:void 0,amount:a,remaining:m,filled:p,fee:void 0,info:u,clientOrderId:void 0,average:void 0,trades:void 0},d)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:parseInt(e)};return await this.privatePostCancelOrder(this.extend(i,s))}parseOrderStatus(e){const t={0:"open",1:"closed",2:"canceled",3:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.parseOrderStatus(this.safeString(e,"status")),n=this.safeTimestamp(e,"timestamp_created"),r=this.safeString(e,"pair"),a=this.safeSymbol(r,t);let o,d;const c=this.safeString(e,"rate");"start_amount"in e?(d=this.safeString(e,"start_amount"),o=this.safeString(e,"amount")):o=this.safeString(e,"amount");const u=void 0;return this.safeOrder({info:e,id:s,clientOrderId:void 0,symbol:a,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,type:"limit",timeInForce:void 0,postOnly:void 0,side:this.safeString(e,"type"),price:c,stopPrice:void 0,cost:void 0,amount:d,remaining:o,filled:void 0,status:i,fee:u,average:void 0,trades:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:parseInt(e)},n=await this.privatePostOrderInfo(this.extend(i,s));e=e.toString();const r=this.safeValue(n,"return",{}),a=this.safeValue(r,e);return this.parseOrder(this.extend({id:e},a))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.pair=r.id);const a=await this.privatePostActiveOrders(this.extend(n,i)),o=this.safeValue(a,"return",[]);return this.parseOrders(o,r,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.pair=n.id),s!==void 0&&(r.count=parseInt(s)),t!==void 0&&(r.since=parseInt(t/1e3));const a=await this.privatePostTradeHistory(this.extend(r,i)),o=this.safeValue(a,"return",[]);return this.parseTrades(o,n,t,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={asset:r.id,amount:parseFloat(t),address:s};i!==void 0&&(a.memo=i);const o=await this.privatePostCreateWithdraw(this.extend(a,n)),d=this.safeValue(o,"return",{}),c=this.safeValue(d,"withdraw_info",{});return this.parseTransaction(c,r)}parseTransaction(e,t=void 0){return t=this.safeCurrency(void 0,t),{id:this.safeString(e,"id"),txid:void 0,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0,info:e}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t];const o=this.omit(i,this.extractParams(e));if(t==="private"){this.checkRequiredCredentials();const d=this.nonce();r=this.urlencode(this.extend({nonce:d,method:e},o));const c=this.hmac(this.encode(r),this.encode(this.secret),"sha512");n={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:c}}else t==="public"?(a+="/"+this.implodeParams(e,i),Object.keys(o).length&&(a+="?"+this.urlencode(o))):(a+="/"+this.implodeParams(e,i),s==="GET"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):Object.keys(o).length&&(r=this.json(o),n={"Content-Type":"application/json"}));return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&"success"in a){let c=this.safeValue(a,"success",!1);if(typeof c=="string"&&(c==="true"||c==="1"?c=!0:c=!1),!c){const u=this.safeString(a,"code"),h=this.safeString(a,"error"),l=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,l),this.throwExactlyMatchedException(this.exceptions.exact,h,l),this.throwBroadlyMatchedException(this.exceptions.broad,h,l),new jc(l)}}}};const g7=ge,{ArgumentsRequired:IT,ExchangeError:bh,PermissionDenied:xT,ExchangeNotAvailable:y7,InsufficientFunds:_T,OrderNotFound:CT,InvalidOrder:MT,RateLimitExceeded:b7,NotSupported:w7,BadRequest:Ko,AuthenticationError:wh}=de,{TICK_SIZE:k7}=me,yg=Se;var S7=class extends g7{describe(){return this.deepExtend(super.describe(),{id:"timex",name:"TimeX",countries:["AU"],version:"v1",rateLimit:1500,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,cancelOrders:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,editOrder:!0,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchWithdrawal:!1,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},timeframes:{"1m":"I1","5m":"I5","15m":"I15","30m":"I30","1h":"H1","2h":"H2","4h":"H4","6h":"H6","12h":"H12","1d":"D1","1w":"W1"},urls:{logo:"https://user-images.githubusercontent.com/1294454/70423869-6839ab00-1a7f-11ea-8f94-13ae72c31115.jpg",api:{rest:"https://plasma-relay-backend.timex.io"},www:"https://timex.io",doc:"https://docs.timex.io",referral:"https://timex.io/?refcode=1x27vNkTbP1uwkCck"},api:{addressbook:{get:["me"],post:["","id/{id}","id/{id}/remove"]},custody:{get:["credentials","credentials/h/{hash}","credentials/k/{key}","credentials/me","credentials/me/address","deposit-addresses","deposit-addresses/h/{hash}"]},history:{get:["orders","orders/details","orders/export/csv","trades","trades/export/csv"]},currencies:{get:["a/{address}","i/{id}","s/{symbol}"],post:["perform","prepare","remove/perform","s/{symbol}/remove/prepare","s/{symbol}/update/perform","s/{symbol}/update/prepare"]},manager:{get:["deposits","transfers","withdrawals"]},markets:{get:["i/{id}","s/{symbol}"],post:["perform","prepare","remove/perform","s/{symbol}/remove/prepare","s/{symbol}/update/perform","s/{symbol}/update/prepare"]},public:{get:["candles","currencies","markets","orderbook","orderbook/raw","orderbook/v2","tickers","trades"]},statistics:{get:["address"]},trading:{get:["balances","fees","orders"],post:["orders","orders/json"],put:["orders","orders/json"],delete:["orders","orders/json"]},tradingview:{get:["config","history","symbol_info","time"]}},precisionMode:k7,exceptions:{exact:{0:bh,1:w7,4e3:Ko,4001:Ko,4002:_T,4003:wh,4004:wh,4005:Ko,4006:Ko,4007:Ko,4300:xT,4100:wh,4400:CT,5001:MT,5002:bh,400:Ko,401:wh,403:xT,404:CT,429:b7,500:bh,503:y7},broad:{Insufficient:_T}},options:{expireIn:31536e3,fetchTickers:{period:"1d"},fetchTrades:{sort:"timestamp,asc"},fetchMyTrades:{sort:"timestamp,asc"},fetchOpenOrders:{sort:"createdAt,asc"},fetchClosedOrders:{sort:"createdAt,asc"},defaultSort:"timestamp,asc",defaultSortOrders:"createdAt,asc"}})}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=[];for(let i=0;i<t.length;i++)s.push(this.parseMarket(t[i]));return s}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s=[];for(let i=0;i<t.length;i++){const n=t[i];s.push(this.parseCurrency(n))}return this.indexBy(s,"code")}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeString(i,"address");if(i=this.omit(i,"address"),n===void 0)throw new IT(this.id+" fetchDeposits() requires an address parameter");const r={address:n},a=await this.managerGetDeposits(this.extend(r,i));return this.parseTransactions(a,e,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const n=this.safeString(i,"address");if(i=this.omit(i,"address"),n===void 0)throw new IT(this.id+" fetchDeposits() requires an address parameter");const r={address:n},a=await this.managerGetWithdrawals(this.extend(r,i));return this.parseTransactions(a,e,t,s)}getCurrencyByAddress(e){const t=this.currencies;for(let s=0;s<t.length;s++){const i=t[s],n=this.safeValue(i,"info",{});if(this.safeString(n,"address")===e)return i}}parseTransaction(e,t=void 0){const s=this.safeString(e,"timestamp"),i=this.safeString(e,"token","");return t=this.getCurrencyByAddress(i),{info:e,id:this.safeString2(e,"transferHash"),txid:this.safeString(e,"txid"),timestamp:this.parse8601(s),datetime:s,network:void 0,address:void 0,addressTo:this.safeString(e,"to"),addressFrom:this.safeString(e,"from"),tag:void 0,tagTo:void 0,tagFrom:void 0,type:void 0,amount:this.safeNumber(e,"value"),currency:this.safeCurrencyCode(void 0,t),status:"ok",updated:void 0,fee:void 0}}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=this.safeString(this.options.fetchTickers,"period","1d"),i={period:this.timeframes[s]},n=await this.publicGetTickers(this.extend(i,t));return this.parseTickers(n,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=this.safeString(this.options.fetchTickers,"period","1d"),n={market:s.id,period:this.timeframes[i]},r=await this.publicGetTickers(this.extend(n,t)),a=this.safeValue(r,0);return this.parseTicker(a,s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={market:this.market(e).id};t!==void 0&&(n.limit=t);const r=await this.publicGetOrderbookV2(this.extend(n,s)),a=this.parse8601(this.safeString(r,"timestamp"));return this.parseOrderBook(r,e,a,"bid","ask","price","baseTokenAmount")}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r=this.safeValue(this.options,"fetchTrades",{}),a=this.safeValue(r,"sort","timestamp,asc"),o=this.safeString(i,"sort",a),d=this.omit(i,"sort"),c={market:n.id,sort:o};t!==void 0&&(c.from=this.iso8601(t)),s!==void 0&&(c.size=s);const u=await this.publicGetTrades(this.extend(c,d));return this.parseTrades(u,n,t,s)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={market:r.id,period:this.timeframes[t]},o=this.parseTimeframe(t);if(i===void 0&&(i=1e3),s!==void 0)a.from=this.iso8601(s),a.till=this.iso8601(this.sum(s,this.sum(i,1)*o*1e3));else{const c=this.milliseconds();a.till=this.iso8601(c),a.from=this.iso8601(c-i*o*1e3-1)}const d=await this.publicGetCandles(this.extend(a,n));return this.parseOHLCVs(d,r,t,s,i)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.total=this.safeString(i,"totalBalance"),a.used=this.safeString(i,"lockedBalance"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.tradingGetBalances(e);return this.parseBalance(t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=s.toUpperCase();let d=t.toUpperCase();this.safeValue(r,"postOnly",!1)&&(d="POST_ONLY",r=this.omit(r,["postOnly"]));const u={symbol:a.id,quantity:this.amountToPrecision(e,i),side:o,orderTypes:d};let h=r;if(d==="LIMIT"||d==="POST_ONLY"){u.price=this.priceToPrecision(e,n);const g=this.safeInteger(this.options,"expireIn"),y=this.safeValue(r,"expireTime"),b=this.safeValue(r,"expireIn",g);if(y!==void 0)u.expireTime=y;else if(b!==void 0)u.expireIn=b;else throw new MT(this.id+" createOrder() method requires a expireTime or expireIn param for a "+t+" order, you can also set the expireIn exchange-wide option");h=this.omit(r,["expireTime","expireIn"])}else u.price=0;const l=await this.tradingPostOrders(this.extend(u,h)),p=this.safeValue(l,"orders",[]),m=this.safeValue(p,0,{});return this.parseOrder(m,a)}async editOrder(e,t,s,i,n=void 0,r=void 0,a={}){await this.loadMarkets();const o=this.market(t),d={id:e};n!==void 0&&(d.quantity=this.amountToPrecision(t,n)),r!==void 0&&(d.price=this.priceToPrecision(t,r));const c=await this.tradingPutOrders(this.extend(d,a));if("unchangedOrders"in c){const p=this.safeValue(c,"unchangedOrders",[]);return{id:this.safeString(p,0),info:c}}const u=this.safeValue(c,"changedOrders",[]),h=this.safeValue(u,0,{}),l=this.safeValue(h,"newOrder",{});return this.parseOrder(l,o)}async cancelOrder(e,t=void 0,s={}){return await this.loadMarkets(),await this.cancelOrders([e],t,s)}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i={id:e};return await this.tradingDeleteOrders(this.extend(i,s))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderHash:e},n=await this.historyGetOrdersDetails(i),r=this.safeValue(n,"order",{}),a=this.safeValue(n,"trades",[]);return this.parseOrder(this.extend(r,{trades:a}))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeValue(this.options,"fetchOpenOrders",{}),r=this.safeValue(n,"sort","createdAt,asc"),a=this.safeString(i,"sort",r),o=this.omit(i,"sort"),d={sort:a};let c;e!==void 0&&(c=this.market(e),d.symbol=c.id),s!==void 0&&(d.size=s);const u=await this.tradingGetOrders(this.extend(d,o)),h=this.safeValue(u,"orders",[]);return this.parseOrders(h,c,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeValue(this.options,"fetchClosedOrders",{}),r=this.safeValue(n,"sort","createdAt,asc"),a=this.safeString(i,"sort",r),o=this.omit(i,"sort"),d={sort:a,side:"BUY"};let c;e!==void 0&&(c=this.market(e),d.symbol=c.id),t!==void 0&&(d.from=this.iso8601(t)),s!==void 0&&(d.size=s);const u=await this.historyGetOrders(this.extend(d,o)),h=this.safeValue(u,"orders",[]);return this.parseOrders(h,c,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.safeValue(this.options,"fetchMyTrades",{}),r=this.safeValue(n,"sort","timestamp,asc"),a=this.safeString(i,"sort",r),o=this.omit(i,"sort"),d={sort:a};let c;e!==void 0&&(c=this.market(e),d.symbol=c.id),t!==void 0&&(d.from=this.iso8601(t)),s!==void 0&&(d.size=s);const u=await this.historyGetTrades(this.extend(d,o)),h=this.safeValue(u,"trades",[]);return this.parseTrades(h,c,t,s)}parseTradingFee(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeNumber(e,"fee");return{info:e,symbol:this.safeSymbol(s,t),maker:i,taker:i}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={markets:s.id},n=await this.tradingGetFees(this.extend(i,t)),r=this.safeValue(n,0,{});return this.parseTradingFee(r,s)}parseMarket(e){const t=this.safeValue(e,"locked"),s=this.safeString(e,"symbol"),i=this.safeString(e,"baseCurrency"),n=this.safeString(e,"quoteCurrency"),r=this.safeCurrencyCode(i),a=this.safeCurrencyCode(n),o=this.safeString(e,"quantityIncrement"),d=this.safeString(e,"baseMinSize"),c=yg.stringMax(o,d),u=this.safeString(e,"tickSize"),h=this.safeString(e,"quoteMinSize");return{id:s,symbol:r+"/"+a,base:r,quote:a,settle:void 0,baseId:i,quoteId:n,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!t,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(e,"takerFee"),maker:this.safeNumber(e,"makerFee"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(e,"quantityIncrement"),price:this.safeNumber(e,"tickSize")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.parseNumber(c),max:void 0},price:{min:this.parseNumber(u),max:void 0},cost:{min:h,max:void 0}},info:e}}parseCurrency(e){const t=this.safeString(e,"symbol"),s=this.safeCurrencyCode(t),i=this.safeString(e,"name"),n=this.safeValue(e,"depositEnabled"),r=this.safeValue(e,"withdrawalEnabled"),a=this.safeValue(e,"active"),o=n&&r&&a,d=this.safeString(e,"withdrawalFee"),c=this.safeInteger(e,"tradeDecimals");let u;if(d!==void 0&&c!==void 0){const l=d.length-c;if(l>0){const p=d.slice(0,l),m=d.slice(-l);u=this.parseNumber(p+"."+m)}else{let p=".";for(let m=0;m<-l;m++)p+="0";u=this.parseNumber(p+d)}}return{id:s,code:s,info:e,type:void 0,name:i,active:o,deposit:n,withdraw:r,fee:u,precision:this.parseNumber(this.parsePrecision(this.safeString(e,"decimals"))),limits:{withdraw:{min:u,max:void 0},amount:{min:void 0,max:void 0}}}}parseTicker(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeSymbol(s,t,"/"),n=this.parse8601(this.safeString(e,"timestamp")),r=this.safeString(e,"last"),a=this.safeString(e,"open");return this.safeTicker({symbol:i,info:e,timestamp:n,datetime:this.iso8601(n),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:a,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:this.safeString(e,"volumeQuote")},t)}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.parse8601(this.safeString(e,"timestamp")),r=this.safeString(e,"price"),a=this.safeString(e,"quantity"),o=this.parseNumber(r),d=this.parseNumber(a),c=this.parseNumber(yg.stringMul(r,a)),u=this.safeString(e,"id"),h=this.safeStringLower2(e,"direction","side"),l=this.safeStringLower(e,"makerOrTaker");let p;l!==void 0&&(p=this.safeString(e,l+"OrderId"));let m;const g=this.safeNumber(e,"fee"),y=this.safeCurrencyCode(this.safeString(e,"feeToken"));return g!==void 0&&(m={cost:g,currency:y}),{info:e,id:u,timestamp:n,datetime:this.iso8601(n),symbol:i,order:p,type:void 0,side:h,price:o,amount:d,cost:c,takerOrMaker:l,fee:m}}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"timestamp")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeStringLower(e,"type"),n=this.safeStringLower(e,"side"),r=this.safeString(e,"symbol"),a=this.safeSymbol(r,t),o=this.parse8601(this.safeString(e,"createdAt")),d=this.safeString(e,"price"),c=this.safeString(e,"quantity"),u=this.safeString(e,"filledQuantity"),h=this.omitZero(this.safeString(e,"cancelledQuantity"));let l;yg.stringEquals(u,c)?l="closed":h!==void 0?l="canceled":l="open";const p=this.safeValue(e,"trades",[]),m=this.safeString(e,"clientOrderId");return this.safeOrder({info:e,id:s,clientOrderId:m,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:void 0,symbol:a,type:i,timeInForce:void 0,postOnly:void 0,side:n,price:d,stopPrice:void 0,amount:c,cost:void 0,average:void 0,filled:u,remaining:void 0,status:l,fee:void 0,trades:p},t)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+t+"/"+e;if(Object.keys(i).length&&(a+="?"+this.urlencodeWithArrayRepeat(i)),t!=="public"){this.checkRequiredCredentials();const o=this.stringToBase64(this.apiKey+":"+this.secret);n={authorization:"Basic "+this.decode(o)}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&e>=400){const c=this.id+" "+r;let u=this.safeValue(a,"error");u===void 0&&(u=a);const h=this.safeString2(u,"code","status"),l=this.safeString2(u,"message","debugMessage");throw this.throwBroadlyMatchedException(this.exceptions.broad,l,c),this.throwExactlyMatchedException(this.exceptions.exact,h,c),this.throwExactlyMatchedException(this.exceptions.exact,l,c),new bh(c)}}};const v7=ge,{ExchangeError:gt,ArgumentsRequired:PT,ExchangeNotAvailable:Wc,InsufficientFunds:Xt,OrderNotFound:bg,InvalidOrder:ms,DDoSProtection:zc,InvalidNonce:T7,AuthenticationError:Qs,RateLimitExceeded:Kc,PermissionDenied:wr,NotSupported:O7,BadRequest:Te,BadSymbol:Xo,AccountSuspended:Yo,OrderImmediatelyFillable:kh,OnMaintenance:I7,BadResponse:AT,RequestTimeout:x7,OrderNotFillable:_7,MarginModeAlreadySet:C7}=de,{TRUNCATE:BT,DECIMAL_PLACES:M7}=me,P7=Se;var A7=class extends v7{describe(){return this.deepExtend(super.describe(),{id:"tokocrypto",name:"Tokocrypto",countries:["ID"],certified:!1,pro:!1,version:"v1",has:{CORS:void 0,spot:!0,margin:!0,swap:!1,future:!1,option:!1,addMargin:void 0,borrowMargin:void 0,cancelAllOrders:!1,cancelOrder:!0,cancelOrders:void 0,createDepositAddress:!1,createOrder:!0,createReduceOnlyOrder:void 0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!0,fetchAccounts:!1,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowInterest:void 0,fetchBorrowRate:void 0,fetchBorrowRateHistories:void 0,fetchBorrowRateHistory:void 0,fetchBorrowRates:void 0,fetchBorrowRatesPerSymbol:void 0,fetchCanceledOrders:!1,fetchClosedOrder:!1,fetchClosedOrders:"emulated",fetchCurrencies:!1,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchL3OrderBook:!1,fetchLedger:void 0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrders:!0,fetchOrderTrades:!1,fetchPosition:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!1,fetchTicker:!1,fetchTickers:!1,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTradingLimits:!1,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,fetchWithdrawalWhitelist:!1,reduceMargin:!1,repayMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,setPositionMode:!1,signIn:!1,transfer:!1,withdraw:!1},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/183870484-d3398d0c-f6a1-4cce-91b8-d58792308716.jpg",api:{rest:{public:"https://www.tokocrypto.com",binance:"https://api.binance.com/api/v3",private:"https://www.tokocrypto.com"}},www:"https://tokocrypto.com",doc:"https://www.tokocrypto.com/apidocs/",fees:"https://www.tokocrypto.com/fees/newschedule"},api:{binance:{get:{ping:1,time:1,depth:{cost:1,byLimit:[[100,1],[500,5],[1e3,10],[5e3,50]]},trades:1,aggTrades:1,historicalTrades:5,klines:1,"ticker/24hr":{cost:1,noSymbol:40},"ticker/price":{cost:1,noSymbol:2},"ticker/bookTicker":{cost:1,noSymbol:2},exchangeInfo:10},put:{userDataStream:1},post:{userDataStream:1},delete:{userDataStream:1}},public:{get:{"open/v1/common/time":1,"open/v1/common/symbols":1,"open/v1/market/depth":1,"open/v1/market/trades":1,"open/v1/market/agg-trades":1,"open/v1/market/klines":1}},private:{get:{"open/v1/orders/detail":1,"open/v1/orders":1,"open/v1/account/spot":1,"open/v1/account/spot/asset":1,"open/v1/orders/trades":1,"open/v1/withdraws":1,"open/v1/deposits":1,"open/v1/deposits/address":1},post:{"open/v1/orders":1,"open/v1/orders/cancel":1,"open/v1/orders/oco":1,"open/v1/withdraws":1,"open/v1/user-data-stream":1}}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0075"),maker:this.parseNumber("0.0075")}},precisionMode:M7,options:{defaultTimeInForce:"GTC",hasAlreadyAuthenticatedSuccessfully:!1,warnOnFetchOpenOrdersWithoutSymbol:!0,recvWindow:5*1e3,timeDifference:0,adjustForTimeDifference:!1,newOrderRespType:{market:"FULL",limit:"FULL"},quoteOrderQty:!1,networks:{ERC20:"ETH",TRC20:"TRX",BEP2:"BNB",BEP20:"BSC",OMNI:"OMNI",EOS:"EOS",SPL:"SOL"},reverseNetworks:{"tronscan.org":"TRC20","etherscan.io":"ERC20","bscscan.com":"BSC","explorer.binance.org":"BEP2","bithomp.com":"XRP","bloks.io":"EOS","stellar.expert":"XLM","blockchair.com/bitcoin":"BTC","blockchair.com/bitcoin-cash":"BCH","blockchair.com/ecash":"XEC","explorer.litecoin.net":"LTC","explorer.avax.network":"AVAX","solscan.io":"SOL","polkadot.subscan.io":"DOT","dashboard.internetcomputer.org":"ICP","explorer.chiliz.com":"CHZ","cardanoscan.io":"ADA","mainnet.theoan.com":"AION","algoexplorer.io":"ALGO","explorer.ambrosus.com":"AMB","viewblock.io/zilliqa":"ZIL","viewblock.io/arweave":"AR","explorer.ark.io":"ARK","atomscan.com":"ATOM","www.mintscan.io":"CTK","explorer.bitcoindiamond.org":"BCD","btgexplorer.com":"BTG","bts.ai":"BTS","explorer.celo.org":"CELO","explorer.nervos.org":"CKB","cerebro.cortexlabs.ai":"CTXC","chainz.cryptoid.info":"VIA","explorer.dcrdata.org":"DCR","digiexplorer.info":"DGB","dock.subscan.io":"DOCK","dogechain.info":"DOGE","explorer.elrond.com":"EGLD","blockscout.com":"ETC","explore-fetchhub.fetch.ai":"FET","filfox.info":"FIL","fio.bloks.io":"FIO","explorer.firo.org":"FIRO","neoscan.io":"NEO","ftmscan.com":"FTM","explorer.gochain.io":"GO","block.gxb.io":"GXS","hash-hash.info":"HBAR","www.hiveblockexplorer.com":"HIVE","explorer.helium.com":"HNT","tracker.icon.foundation":"ICX","www.iostabc.com":"IOST","explorer.iota.org":"IOTA","iotexscan.io":"IOTX","irishub.iobscan.io":"IRIS","kava.mintscan.io":"KAVA","scope.klaytn.com":"KLAY","kmdexplorer.io":"KMD","kusama.subscan.io":"KSM","explorer.lto.network":"LTO","polygonscan.com":"POLYGON","explorer.ont.io":"ONT","minaexplorer.com":"MINA","nanolooker.com":"NANO","explorer.nebulas.io":"NAS","explorer.nbs.plus":"NBS","explorer.nebl.io":"NEBL","nulscan.io":"NULS","nxscan.com":"NXS","explorer.harmony.one":"ONE","explorer.poa.network":"POA","qtum.info":"QTUM","explorer.rsk.co":"RSK","www.oasisscan.com":"ROSE","ravencoin.network":"RVN","sc.tokenview.com":"SC","secretnodes.com":"SCRT","explorer.skycoin.com":"SKY","steemscan.com":"STEEM","explorer.stacks.co":"STX","www.thetascan.io":"THETA","scan.tomochain.com":"TOMO","explore.vechain.org":"VET","explorer.vite.net":"VITE","www.wanscan.org":"WAN","wavesexplorer.com":"WAVES","wax.eosx.io":"WAXP","waltonchain.pro":"WTC","chain.nem.ninja":"XEM","verge-blockchain.info":"XVG","explorer.yoyow.org":"YOYOW","explorer.zcha.in":"ZEC","explorer.zensystem.io":"ZEN"},impliedNetworks:{ETH:{ERC20:"ETH"},TRX:{TRC20:"TRX"}},legalMoney:{MXN:!0,UGX:!0,SEK:!0,CHF:!0,VND:!0,AED:!0,DKK:!0,KZT:!0,HUF:!0,PEN:!0,PHP:!0,USD:!0,TRY:!0,EUR:!0,NGN:!0,PLN:!0,BRL:!0,ZAR:!0,KES:!0,ARS:!0,RUB:!0,AUD:!0,NOK:!0,CZK:!0,GBP:!0,UAH:!0,GHS:!0,HKD:!0,CAD:!0,INR:!0,JPY:!0,NZD:!0}},exceptions:{exact:{"System is under maintenance.":I7,"System abnormality":gt,"You are not authorized to execute this request.":wr,"API key does not exist":Qs,"Order would trigger immediately.":kh,"Stop price would trigger immediately.":kh,"Order would immediately match and take.":kh,"Account has insufficient balance for requested action.":Xt,"Rest API trading is not enabled.":Wc,"You don't have permission.":wr,"Market is closed.":Wc,"Too many requests. Please try again later.":zc,"This action disabled is on this account.":Yo,"-1000":Wc,"-1001":Wc,"-1002":Qs,"-1003":Kc,"-1004":zc,"-1005":wr,"-1006":AT,"-1007":x7,"-1010":AT,"-1011":wr,"-1013":ms,"-1014":ms,"-1015":Kc,"-1016":Wc,"-1020":Te,"-1021":T7,"-1022":Qs,"-1023":Te,"-1099":Qs,"-1100":Te,"-1101":Te,"-1102":Te,"-1103":Te,"-1104":Te,"-1105":Te,"-1106":Te,"-1108":Te,"-1109":Qs,"-1110":Te,"-1111":Te,"-1112":ms,"-1113":Te,"-1114":Te,"-1115":Te,"-1116":Te,"-1117":Te,"-1118":Te,"-1119":Te,"-1120":Te,"-1121":Xo,"-1125":Qs,"-1127":Te,"-1128":Te,"-1130":Te,"-1131":Te,"-1136":Te,"-2008":Qs,"-2010":gt,"-2011":bg,"-2013":bg,"-2014":Qs,"-2015":Qs,"-2016":Te,"-2018":Xt,"-2019":Xt,"-2020":_7,"-2021":kh,"-2022":ms,"-2023":Xt,"-2024":Xt,"-2025":ms,"-2026":ms,"-2027":ms,"-2028":Xt,"-3000":gt,"-3001":Qs,"-3002":Xo,"-3003":Te,"-3004":gt,"-3005":Xt,"-3006":Xt,"-3007":gt,"-3008":Xt,"-3009":Te,"-3010":gt,"-3011":Te,"-3012":gt,"-3013":Te,"-3014":Yo,"-3015":gt,"-3016":Te,"-3017":gt,"-3018":Yo,"-3019":Yo,"-3020":Xt,"-3021":Te,"-3022":Yo,"-3023":Te,"-3024":gt,"-3025":Te,"-3026":Te,"-3027":Xo,"-3028":Xo,"-3029":gt,"-3036":Yo,"-3037":gt,"-3038":Te,"-3041":Xt,"-3042":Te,"-3043":Te,"-3044":zc,"-3045":gt,"-3999":gt,"-4001":Te,"-4002":Te,"-4003":Te,"-4004":Qs,"-4005":Kc,"-4006":Te,"-4007":Te,"-4008":Te,"-4010":Te,"-4011":Te,"-4012":Te,"-4013":Qs,"-4014":wr,"-4015":gt,"-4016":wr,"-4017":wr,"-4018":Xo,"-4019":Xo,"-4021":Te,"-4022":Te,"-4023":gt,"-4024":Xt,"-4025":Xt,"-4026":Xt,"-4027":gt,"-4028":Te,"-4029":Te,"-4030":gt,"-4031":gt,"-4032":gt,"-4033":Te,"-4034":gt,"-4035":wr,"-4036":Te,"-4037":gt,"-4038":gt,"-4039":Te,"-4040":Te,"-4041":gt,"-4042":gt,"-4043":Te,"-4044":Te,"-4045":gt,"-4046":Qs,"-4047":Te,"-5001":Te,"-5002":Xt,"-5003":Xt,"-5004":Te,"-5005":Xt,"-5006":Te,"-5007":Te,"-5008":Xt,"-5009":Te,"-5010":gt,"-5011":Te,"-5012":gt,"-5013":Xt,"-5021":Te,"-6001":Te,"-6003":Te,"-6004":gt,"-6005":ms,"-6006":Te,"-6007":Te,"-6008":Te,"-6009":Kc,"-6011":Te,"-6012":Xt,"-6013":gt,"-6014":Te,"-6015":Te,"-6016":Te,"-6017":Te,"-6018":Te,"-6019":Qs,"-6020":Te,"-7001":Te,"-7002":Te,"-9000":Xt,"-10017":Te,"-11008":Xt,"-12014":Kc,"-13000":Te,"-13001":Te,"-13002":Te,"-13003":Te,"-13004":Te,"-13005":Te,"-13006":ms,"-13007":Qs,"-21001":Te,"-21002":Te,"-21003":Te,100001003:Te,2202:Xt,3210:ms,3203:ms,3211:ms,3207:ms,3218:bg},broad:{"has no operation privilege":wr,MAX_POSITION:ms}}})}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeInteger(t,"serverTime")}async fetchMarkets(e={}){const t=await this.publicGetOpenV1CommonSymbols(e);this.options.adjustForTimeDifference&&await this.loadTimeDifference();const s=this.safeValue(t,"data",{}),i=this.safeValue(s,"list",[]),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"baseAsset"),d=this.safeString(a,"quoteAsset"),c=this.safeString(a,"symbol"),u=this.safeStringLower(a,"symbol"),h=this.safeString(a,"marginAsset"),l=this.safeCurrencyCode(o),p=this.safeCurrencyCode(d),m=this.safeCurrencyCode(h),g=l+"/"+p,y=this.safeValue(a,"filters",[]),b=this.indexBy(y,"filterType");let k=this.safeString2(a,"status","contractStatus")==="TRADING";const T=this.safeValue(a,"permissions",[]);for(let C=0;C<T.length;C++)if(T[C]==="TRD_GRP_003"){k=!1;break}const O=this.safeValue(a,"isMarginTradingAllowed",!1),x={id:c,lowercaseId:u,symbol:g,base:l,quote:p,settle:m,baseId:o,quoteId:d,settleId:h,type:"spot",spot:!0,margin:O,swap:!1,future:!1,delivery:!1,option:!1,active:k,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeInteger(a,"quantityPrecision"),price:this.safeInteger(a,"pricePrecision"),base:this.safeInteger(a,"baseAssetPrecision"),quote:this.safeInteger(a,"quotePrecision")},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:a};if("PRICE_FILTER"in b){const C=this.safeValue(b,"PRICE_FILTER",{}),E=this.safeString(C,"tickSize");x.precision.price=this.precisionFromString(E),x.limits.price={min:this.safeNumber(C,"minPrice"),max:this.safeNumber(C,"maxPrice")},x.precision.price=this.precisionFromString(C.tickSize)}if("LOT_SIZE"in b){const C=this.safeValue(b,"LOT_SIZE",{}),E=this.safeString(C,"stepSize");x.precision.amount=this.precisionFromString(E),x.limits.amount={min:this.safeNumber(C,"minQty"),max:this.safeNumber(C,"maxQty")}}if("MARKET_LOT_SIZE"in b){const C=this.safeValue(b,"MARKET_LOT_SIZE",{});x.limits.market={min:this.safeNumber(C,"minQty"),max:this.safeNumber(C,"maxQty")}}if("MIN_NOTIONAL"in b){const C=this.safeValue(b,"MIN_NOTIONAL",{});x.limits.cost.min=this.safeNumber2(C,"minNotional","notional")}n.push(x)}return n}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={symbol:i.baseId+i.quoteId};t!==void 0&&(n.limit=t);const r=await this.binanceGetDepth(this.extend(n,s)),a=this.safeInteger(r,"T"),o=this.parseOrderBook(r,e,a);return o.nonce=this.safeInteger(r,"lastUpdateId"),o}parseTrade(e,t=void 0){const s=this.safeInteger2(e,"T","time"),i=this.safeString2(e,"p","price"),n=this.safeString2(e,"q","qty"),r=this.safeString2(e,"quoteQty","baseQty"),a=this.safeString(e,"symbol"),o=this.safeSymbol(a,t);let d=this.safeString2(e,"t","a");d=this.safeString2(e,"id","tradeId",d);let c;const u=this.safeString(e,"orderId"),h=this.safeValue2(e,"m","isBuyerMaker");let l;h!==void 0?(c=h?"sell":"buy",l="taker"):"side"in e?c=this.safeStringLower(e,"side"):"isBuyer"in e&&(c=e.isBuyer?"buy":"sell");let p;return"commission"in e&&(p={cost:this.safeString(e,"commission"),currency:this.safeCurrencyCode(this.safeString(e,"commissionAsset"))}),"isMaker"in e&&(l=e.isMaker?"maker":"taker"),"maker"in e&&(l=e.maker?"maker":"taker"),this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:o,id:d,order:u,type:void 0,side:c,takerOrMaker:l,price:i,amount:n,cost:r,fee:p},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.baseId+n.quoteId},a="binanceGetTrades",o=this.safeString(this.options,"fetchTradesMethod",a);o==="binanceGetAggTrades"&&t!==void 0&&(r.startTime=t,r.endTime=this.sum(t,36e5)),s!==void 0&&(r.limit=s);const d=await this[o](this.extend(r,i));return this.parseTrades(d,n,t,s)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"closeTime"),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.safeString(e,"lastPrice"),a="baseVolume"in e;let o,d;return a?(o=this.safeString(e,"baseVolume"),d=this.safeString(e,"volume")):(o=this.safeString(e,"volume"),d=this.safeString(e,"quoteVolume")),this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"highPrice"),low:this.safeString(e,"lowPrice"),bid:this.safeString(e,"bidPrice"),bidVolume:this.safeString(e,"bidQty"),ask:this.safeString(e,"askPrice"),askVolume:this.safeString(e,"askQty"),vwap:this.safeString(e,"weightedAvgPrice"),open:this.safeString(e,"openPrice"),close:r,last:r,previousClose:this.safeString(e,"prevClosePrice"),change:this.safeString(e,"priceChange"),percentage:this.safeString(e,"priceChangePercent"),average:void 0,baseVolume:o,quoteVolume:d,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s="binanceGetTicker24hr",i=this.safeString(this.options,"fetchTickersMethod",s),n=await this[i](t);return this.parseTickers(n,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.baseId+s.quoteId},n=await this.binanceGetTicker24hr(this.extend(i,t));if(Array.isArray(n)){const r=this.safeValue(n,0,{});return this.parseTicker(r,s)}return this.parseTicker(n,s)}async fetchBidsAsks(e=void 0,t={}){await this.loadMarkets();const s=await this.binanceGetTickerBookTicker(t);return this.parseTickers(s,e)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=500,o=1500,d=this.safeString(n,"price"),c=this.safeInteger(n,"until");n=this.omit(n,["price","until"]),i=i===void 0?a:Math.min(i,o);const u={interval:this.timeframes[t],limit:i};d==="index"?u.pair=r.id:u.symbol=r.baseId+r.quoteId,s!==void 0&&(u.startTime=s),c!==void 0&&(u.endTime=c);const h=await this.binanceGetKlines(this.extend(u,n));return this.parseOHLCVs(h,r,t,s,i)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString2(this.options,"fetchBalance","defaultType","spot"),s=this.safeString(e,"type",t),i=this.safeString2(this.options,"marginMode","defaultMarginMode"),n=this.safeStringLower(e,"marginMode",i),r={},a=await this.privateGetOpenV1AccountSpot(this.extend(r,e));return this.parseBalance(a,s,n)}parseBalance(e,t=void 0,s=void 0){const i=this.safeInteger(e,"updateTime"),n={info:e,timestamp:i,datetime:this.iso8601(i)},r=this.safeValue(e,"data",{}),a=this.safeValue(r,"accountAssets",[]);for(let o=0;o<a.length;o++){const d=a[o],c=this.safeString(d,"asset"),u=this.safeCurrencyCode(c),h=this.account();h.free=this.safeString(d,"free"),h.used=this.safeString(d,"locked"),n[u]=h}return this.safeBalance(n)}parseOrderStatus(e){const t={"-2":"open",0:"open",1:"open",2:"closed",3:"canceled",4:"canceling",5:"rejected",6:"expired",NEW:"open",PARTIALLY_FILLED:"open",FILLED:"closed",CANCELED:"canceled",PENDING_CANCEL:"canceling",REJECTED:"rejected",EXPIRED:"expired"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString(e,"status")),i=this.safeString(e,"symbol"),n=this.safeSymbol(i,t),r=this.safeString(e,"executedQty","0"),a=this.safeInteger(e,"createTime"),o=this.safeString(e,"avgPrice"),d=this.safeString(e,"price"),c=this.safeString(e,"origQty");let u=this.safeString2(e,"cummulativeQuoteQty","cumQuote");u=this.safeString(e,"cumBase",u);const h=this.safeString(e,"orderId");let l=this.safeStringLower(e,"type"),p=this.safeStringLower(e,"side");p==="0"?p="buy":p==="1"&&(p="sell");const m=this.safeValue(e,"fills",[]),g=this.safeString(e,"clientOrderId");let y=this.safeString(e,"timeInForce");y==="GTX"&&(y="PO");const b=l==="limit_maker"||y==="PO";l==="limit_maker"&&(l="limit");const w=this.safeString(e,"stopPrice"),k=this.parseNumber(this.omitZero(w));return this.safeOrder({info:e,id:h,clientOrderId:g,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:void 0,symbol:n,type:l,timeInForce:y,postOnly:b,reduceOnly:this.safeValue(e,"reduceOnly"),side:p,price:d,stopPrice:k,amount:c,cost:u,average:o,filled:r,remaining:void 0,status:s,fee:void 0,trades:m},t)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeString2(r,"clientOrderId","clientId");this.safeValue(r,"postOnly",!1)&&(t="LIMIT_MAKER"),r=this.omit(r,["clientId","clientOrderId"]);const c=t.toUpperCase();let u=c;const h=this.safeValue2(r,"triggerPrice","stopPrice");h!==void 0&&(r=this.omit(r,["triggerPrice","stopPrice"]),u==="MARKET"?u="STOP_LOSS":u==="LIMIT"&&(u="STOP_LOSS_LIMIT"));const l=this.safeValue(a.info,"orderTypes");if(!this.inArray(u,l))throw c!==u?new ms(this.id+" stopPrice parameter is not allowed for "+e+" "+t+" orders"):new ms(this.id+" "+t+" is not a valid order type for the "+e+" market");const p={LIMIT:1,MARKET:2,STOP_LOSS:3,STOP_LOSS_LIMIT:4,TAKE_PROFIT:5,TAKE_PROFIT_LIMIT:6,LIMIT_MAKER:7},m={symbol:a.baseId+"_"+a.quoteId,type:this.safeString(p,u)};if(s==="buy"?m.side=0:s==="sell"&&(m.side=1),o===void 0){const T=this.safeValue(this.options,"broker");if(T!==void 0){const O=this.safeString(T,"marketType");O!==void 0&&(m.clientId=O+this.uuid22())}}else m.clientId=o;let g=!1,y=!1,b=!1;if(u==="MARKET")if(this.safeValue(this.options,"quoteOrderQty",!0)){const O=this.safeValue2(r,"quoteOrderQty","cost"),x=a.precision.price;O!==void 0?(m.quoteOrderQty=this.decimalToPrecision(O,BT,x,this.precisionMode),r=this.omit(r,["quoteOrderQty","cost"])):n!==void 0?m.quoteOrderQty=this.decimalToPrecision(i*n,BT,x,this.precisionMode):b=!0}else b=!0;else u==="LIMIT"?(g=!0,b=!0):u==="STOP_LOSS"||u==="TAKE_PROFIT"?(y=!0,b=!0,(a.linear||a.inverse)&&(g=!0)):u==="STOP_LOSS_LIMIT"||u==="TAKE_PROFIT_LIMIT"?(b=!0,y=!0,g=!0):u==="LIMIT_MAKER"&&(g=!0,b=!0);if(b&&(m.quantity=this.amountToPrecision(e,i)),g){if(n===void 0)throw new ms(this.id+" createOrder() requires a price argument for a "+t+" order");m.price=this.priceToPrecision(e,n)}if(y){if(h===void 0)throw new ms(this.id+" createOrder() requires a stopPrice extra param for a "+t+" order");m.stopPrice=this.priceToPrecision(e,h)}const w=await this.privatePostOpenV1Orders(this.extend(m,r)),k=this.safeValue(w,"data",{});return this.parseOrder(k,a)}async fetchOrder(e,t=void 0,s={}){const i={orderId:e},n=await this.privateGetOpenV1Orders(this.extend(i,s)),r=this.safeValue(n,"data",{}),a=this.safeValue(r,"list",[]),o=this.safeValue(a,0,{});return this.parseOrder(o)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new PT(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=s);const a=await this.privateGetOpenV1Orders(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"list",[]);return this.parseOrders(d,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const n={type:1};return await this.fetchOrders(e,t,s,this.extend(n,i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const n={type:2};return await this.fetchOrders(e,t,s,this.extend(n,i))}async cancelOrder(e,t=void 0,s={}){const i={orderId:e},n=await this.privatePostOpenV1OrdersCancel(this.extend(i,s)),r=this.safeValue(n,"data",{});return this.parseOrder(r)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new PT(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id},a=this.safeInteger2(i,"until","endTime");if(t!==void 0){const u=parseInt(t);r.startTime=u}a!==void 0&&(r.endTime=a,i=this.omit(i,["endTime","until"])),s!==void 0&&(r.limit=s);const o=await this.privateGetOpenV1OrdersTrades(this.extend(r,i)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"list",[]);return this.parseTrades(c,n,t,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={asset:this.currency(e).id},n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper(t,"network");r=this.safeString(n,r,r),r!==void 0&&(i.network=r,t=this.omit(t,"network"));const a=await this.privateGetOpenV1DepositsAddress(this.extend(i,t)),o=this.safeValue(a,"data",{}),d=this.safeString(o,"address");let c=this.safeString(o,"addressTag","");return c.length===0&&(c=void 0),this.checkAddress(d),{currency:e,address:d,tag:c,network:this.safeString(o,"network"),info:a}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={},a=this.safeInteger(i,"until");if(e!==void 0&&(n=this.currency(e),r.coin=n.id),t!==void 0){r.startTime=t;let u=this.sum(t,7776e6);a!==void 0&&(u=Math.min(u,a)),r.endTime=u}s!==void 0&&(r.limit=s);const o=await this.privateGetOpenV1Deposits(this.extend(r,i)),d=this.safeValue(o,"data",{}),c=this.safeValue(d,"list",[]);return this.parseTransactions(c,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.coin=r.id),t!==void 0&&(n.startTime=t,n.endTime=this.sum(t,7776e6)),s!==void 0&&(n.limit=s);const a=await this.privateGetOpenV1Withdraws(this.extend(n,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"list",[]);return this.parseTransactions(d,r,t,s)}parseTransactionStatusByType(e,t=void 0){const s={deposit:{0:"pending",1:"ok"},withdrawal:{0:"pending",1:"canceled",2:"pending",3:"failed",4:"pending",5:"failed",10:"ok"}},i=this.safeValue(s,t,{});return this.safeString(i,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"address");let n=this.safeString(e,"addressTag");n!==void 0&&n.length<1&&(n=void 0);let r=this.safeString(e,"txId");r!==void 0&&r.indexOf("Internal transfer ")>=0&&(r=r.slice(18));const a=this.safeString2(e,"coin","fiatCurrency"),o=this.safeCurrencyCode(a,t);let d;const c=this.safeInteger(e,"insertTime"),u=this.safeInteger(e,"createTime");let h=this.safeString(e,"type");h===void 0&&(c!==void 0&&u===void 0?(h="deposit",d=c):c===void 0&&u!==void 0&&(h="withdrawal",d=u));const l=this.parseTransactionStatusByType(this.safeString(e,"status"),h),p=this.safeNumber(e,"amount"),m=this.safeNumber2(e,"transactionFee","totalFee");let g;m!==void 0&&(g={currency:o,cost:m});const y=this.safeInteger2(e,"successTime","updateTime");let b=this.safeInteger(e,"transferType");b!==void 0&&(b=!!b);const w=this.safeString(e,"network");return{info:e,id:s,txid:r,timestamp:d,datetime:this.iso8601(d),network:w,address:i,addressTo:i,addressFrom:void 0,tag:n,tagTo:n,tagFrom:void 0,type:h,amount:p,currency:o,status:l,updated:y,internal:b,fee:g}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){if(!(t in this.urls.api.rest))throw new O7(this.id+" does not have a testnet/sandbox URL for "+t+" endpoints");let a=this.urls.api.rest[t];if(a+="/"+e,t==="wapi"&&(a+=".html"),e==="userDataStream"||e==="listenKey")if(this.apiKey)n={"X-MBX-APIKEY":this.apiKey,"Content-Type":"application/x-www-form-urlencoded"},s!=="GET"&&(r=this.urlencode(i));else throw new Qs(this.id+" userDataStream endpoint requires `apiKey` credential");else if(t==="private"||t==="sapi"&&e!=="system/status"||t==="sapiV3"||t==="wapi"&&e!=="systemStatus"||t==="dapiPrivate"||t==="dapiPrivateV2"||t==="fapiPrivate"||t==="fapiPrivateV2"){this.checkRequiredCredentials();let d;const c=this.safeInteger(this.options,"recvWindow"),u=this.extend({timestamp:this.nonce()},i);c!==void 0&&(u.recvWindow=c);const h=this.safeInteger(i,"recvWindow");h!==void 0&&(u.recvWindow=h),t==="sapi"&&e==="asset/dust"?d=this.urlencodeWithArrayRepeat(u):e==="batchOrders"||e.indexOf("sub-account")>=0||e==="capital/withdraw/apply"||e.indexOf("staking")>=0?d=this.rawencode(u):d=this.urlencode(u);const l=this.hmac(this.encode(d),this.encode(this.secret));d+="&signature="+l,n={"X-MBX-APIKEY":this.apiKey},s==="GET"||s==="DELETE"||t==="wapi"?a+="?"+d:(r=d,n["Content-Type"]="application/x-www-form-urlencoded")}else Object.keys(i).length&&(a+="?"+this.urlencode(i));return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(e===418||e===429)throw new zc(this.id+" "+e.toString()+" "+t+" "+r);if(e>=400){if(r.indexOf("Price * QTY is zero or less")>=0)throw new ms(this.id+" order cost = amount * price is zero or less "+r);if(r.indexOf("LOT_SIZE")>=0)throw new ms(this.id+" order amount should be evenly divisible by lot size "+r);if(r.indexOf("PRICE_FILTER")>=0)throw new ms(this.id+" order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid value in general, use this.priceToPrecision (symbol, amount) "+r)}if(a===void 0)return;const c=this.safeValue(a,"success",!0);if(!c){const l=this.safeString(a,"msg");let p;if(l!==void 0){try{p=JSON.parse(l)}catch{p=void 0}p!==void 0&&(a=p)}}const u=this.safeString(a,"msg");u!==void 0&&(this.throwExactlyMatchedException(this.exceptions.exact,u,this.id+" "+u),this.throwBroadlyMatchedException(this.exceptions.broad,u,this.id+" "+u));const h=this.safeString(a,"code");if(h!==void 0){if(h==="200"||P7.stringEquals(h,"0"))return;if(h==="-2015"&&this.options.hasAlreadyAuthenticatedSuccessfully)throw new zc(this.id+" "+r);const l=this.id+" "+r;throw u==="No need to change margin type."?new C7(l):(this.throwExactlyMatchedException(this.exceptions.exact,h,l),new gt(l))}if(!c)throw new gt(this.id+" "+r)}calculateRateLimiterCost(e,t,s,i,n={},r={}){if("noCoin"in n&&!("coin"in i))return n.noCoin;if("noSymbol"in n&&!("symbol"in i))return n.noSymbol;if("noPoolId"in n&&!("poolId"in i))return n.noPoolId;if("byLimit"in n&&"limit"in i){const a=i.limit,o=n.byLimit;for(let d=0;d<o.length;d++){const c=o[d];if(a<=c[0])return c[1]}}return this.safeInteger(n,"cost",1)}};const B7=ge,{ExchangeError:Xc,BadRequest:E7,AuthenticationError:wg,InvalidOrder:Yc,InsufficientFunds:N7,OrderNotFound:V7,PermissionDenied:ET,AddressPending:q7}=de,{TICK_SIZE:L7}=me,NT=Se;var aC=class extends B7{describe(){return this.deepExtend(super.describe(),{id:"upbit",name:"Upbit",countries:["KR"],version:"v1",rateLimit:1e3,pro:!0,has:{CORS:!0,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelOrder:!0,createDepositAddress:!0,createMarketOrder:!0,createOrder:!0,fetchBalance:!0,fetchCanceledOrders:!0,fetchClosedOrders:!0,fetchDepositAddress:!0,fetchDepositAddresses:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:void 0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!0,fetchOrders:void 0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactions:void 0,fetchWithdrawals:!0,transfer:!1,withdraw:!0},timeframes:{"1m":"minutes","3m":"minutes","5m":"minutes","15m":"minutes","30m":"minutes","1h":"minutes","4h":"minutes","1d":"days","1w":"weeks","1M":"months"},hostname:"api.upbit.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/49245610-eeaabe00-f423-11e8-9cba-4b0aed794799.jpg",api:{public:"https://{hostname}",private:"https://{hostname}"},www:"https://upbit.com",doc:"https://docs.upbit.com/docs/%EC%9A%94%EC%B2%AD-%EC%88%98-%EC%A0%9C%ED%95%9C",fees:"https://upbit.com/service_center/guide"},api:{public:{get:["market/all","candles/{timeframe}","candles/{timeframe}/{unit}","candles/minutes/{unit}","candles/minutes/1","candles/minutes/3","candles/minutes/5","candles/minutes/15","candles/minutes/30","candles/minutes/60","candles/minutes/240","candles/days","candles/weeks","candles/months","trades/ticks","ticker","orderbook"]},private:{get:["accounts","orders/chance","order","orders","withdraws","withdraw","withdraws/chance","deposits","deposit","deposits/coin_addresses","deposits/coin_address"],post:["orders","withdraws/coin","withdraws/krw","deposits/generate_coin_address"],delete:["order"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.0025"),taker:this.parseNumber("0.0025")},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}},precisionMode:L7,exceptions:{exact:{"This key has expired.":wg,"Missing request parameter error. Check the required parameters!":E7,"side is missing, side does not have a valid value":Yc},broad:{thirdparty_agreement_required:ET,out_of_scope:ET,order_not_found:V7,insufficient_funds:N7,invalid_access_key:wg,jwt_verification:wg,create_ask_error:Xc,create_bid_error:Xc,volume_too_large:Yc,invalid_funds:Yc}},options:{createMarketBuyOrderRequiresPrice:!0,fetchTickersMaxLength:4096,fetchOrderBooksMaxLength:4096,tradingFeesByQuoteCurrency:{KRW:5e-4}},commonCurrencies:{TON:"Tokamak Network"}})}async fetchCurrency(e,t={}){await this.loadMarkets();const s=this.currency(e);return await this.fetchCurrencyById(s.id,t)}async fetchCurrencyById(e,t={}){const s={currency:e},i=await this.privateGetWithdrawsChance(this.extend(s,t)),n=this.safeValue(i,"member_level",{}),r=this.safeValue(i,"currency",{}),a=this.safeValue(i,"withdraw_limit",{}),o=this.safeValue(a,"can_withdraw"),d=this.safeString(r,"wallet_state"),c=this.safeValue(n,"wallet_locked"),u=this.safeValue(n,"locked");let h=!0;(o!==void 0&&!o||d!=="working"||c!==void 0&&c||u!==void 0&&u)&&(h=!1);const l=this.safeNumber(a,"onetime"),p=this.safeNumber(a,"daily",l),m=this.safeNumber(a,"remaining_daily",p);let g;m>0?g=m:g=p;const y=this.safeString(r,"code"),b=this.safeCurrencyCode(y);return{info:i,id:y,code:b,name:b,active:h,fee:this.safeNumber(r,"withdraw_fee"),precision:void 0,limits:{withdraw:{min:this.safeNumber(a,"minimum"),max:g}}}}async fetchMarket(e,t={}){await this.loadMarkets();const s=this.market(e);return await this.fetchMarketById(s.id,t)}async fetchMarketById(e,t={}){const s={market:e},i=await this.privateGetOrdersChance(this.extend(s,t)),n=this.safeValue(i,"market"),r=this.safeValue(n,"bid"),a=this.safeValue(n,"ask"),o=this.safeString(n,"id"),d=this.safeString(a,"currency"),c=this.safeString(r,"currency"),u=this.safeCurrencyCode(d),h=this.safeCurrencyCode(c),l=this.safeString(n,"state"),p=this.safeNumber(i,"bid_fee"),m=this.safeNumber(i,"ask_fee"),g=Math.max(p,m);return{id:o,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:l==="active",contract:!1,linear:void 0,inverse:void 0,taker:g,maker:g,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber("0.00000001"),price:this.parseNumber("0.00000001")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(a,"min_total"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(r,"min_total"),max:this.safeNumber(n,"max_total")},info:i}}}async fetchMarkets(e={}){const t=await this.publicGetMarketAll(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"market"),[a,o]=r.split("-"),d=this.safeCurrencyCode(o),c=this.safeCurrencyCode(a);s.push({id:r,symbol:d+"/"+c,base:d,quote:c,settle:void 0,baseId:o,quoteId:a,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(this.options.tradingFeesByQuoteCurrency,c,this.fees.trading.taker),maker:this.safeNumber(this.options.tradingFeesByQuoteCurrency,c,this.fees.trading.maker),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{price:this.parseNumber("0.00000001"),amount:this.parseNumber("0.00000001")},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:n})}return s}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"balance"),a.used=this.safeString(i,"locked"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccounts(e);return this.parseBalance(t)}async fetchOrderBooks(e=void 0,t=void 0,s={}){await this.loadMarkets();let i;if(e===void 0){if(i=this.ids.join(","),i.length>this.options.fetchOrderBooksMaxLength){const o=this.ids.length;throw new Xc(this.id+" fetchOrderBooks() has "+o.toString()+" symbols ("+i.length.toString()+" characters) exceeding max URL length ("+this.options.fetchOrderBooksMaxLength.toString()+" characters), you are required to specify a list of symbols in the first argument to fetchOrderBooks")}}else i=this.marketIds(e),i=i.join(",");const n={markets:i},r=await this.publicGetOrderbook(this.extend(n,s)),a={};for(let o=0;o<r.length;o++){const d=r[o],c=this.safeString(d,"market"),u=this.safeSymbol(c,void 0,"-"),h=this.safeInteger(d,"timestamp");a[u]={symbol:u,bids:this.sortBy(this.parseBidsAsks(d.orderbook_units,"bid_price","bid_size"),0,!0),asks:this.sortBy(this.parseBidsAsks(d.orderbook_units,"ask_price","ask_size"),0),timestamp:h,datetime:this.iso8601(h),nonce:void 0}}return a}async fetchOrderBook(e,t=void 0,s={}){const i=await this.fetchOrderBooks([e],t,s);return this.safeValue(i,e)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"trade_timestamp"),i=this.safeString2(e,"market","code");t=this.safeMarket(i,t,"-");const n=this.safeString(e,"trade_price");return this.safeTicker({symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high_price"),low:this.safeString(e,"low_price"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:this.safeString(e,"opening_price"),close:n,last:n,previousClose:this.safeString(e,"prev_closing_price"),change:this.safeString(e,"signed_change_price"),percentage:this.safeString(e,"signed_change_rate"),average:void 0,baseVolume:this.safeString(e,"acc_trade_volume_24h"),quoteVolume:this.safeString(e,"acc_trade_price_24h"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s;if(e===void 0){if(s=this.ids.join(","),s.length>this.options.fetchTickersMaxLength){const a=this.ids.length;throw new Xc(this.id+" fetchTickers() has "+a.toString()+" symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchTickers")}}else s=this.marketIds(e),s=s.join(",");const i={markets:s},n=await this.publicGetTicker(this.extend(i,t)),r={};for(let a=0;a<n.length;a++){const o=this.parseTicker(n[a]),d=o.symbol;r[d]=o}return this.filterByArray(r,"symbol",e)}async fetchTicker(e,t={}){const s=await this.fetchTickers([e],t);return this.safeValue(s,e)}parseTrade(e,t=void 0){const s=this.safeString2(e,"sequential_id","uuid"),i=void 0;let n=this.safeInteger(e,"timestamp");n===void 0&&(n=this.parse8601(this.safeString(e,"created_at")));let r;const a=this.safeStringLower2(e,"ask_bid","side");a==="ask"?r="sell":a==="bid"&&(r="buy");const o=this.safeString(e,"funds"),d=this.safeString2(e,"trade_price","price"),c=this.safeString2(e,"trade_volume","volume"),u=this.safeString2(e,"market","code");t=this.safeMarket(u,t,"-");let h;const l=this.safeString(e,a+"_fee");return l!==void 0&&(h={currency:t.quote,cost:l}),this.safeTrade({id:s,info:e,order:i,timestamp:n,datetime:this.iso8601(n),symbol:t.symbol,type:void 0,side:r,takerOrMaker:void 0,price:d,amount:c,cost:o,fee:h},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);s===void 0&&(s=200);const r={market:n.id,count:s},a=await this.publicGetTradesTicks(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const i={market:this.market(e).id},n=await this.privateGetOrdersChance(this.extend(i,t)),r=this.safeString(n,"ask_fee"),a=this.safeString(n,"bid_fee"),o=NT.stringMax(r,a),d=this.safeString(n,"maker_ask_fee"),c=this.safeString(n,"maker_bid_fee"),u=NT.stringMax(d,c);return{info:n,symbol:e,maker:this.parseNumber(u),taker:this.parseNumber(o),percentage:!0,tierBased:!1}}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"candle_date_time_utc")),this.safeNumber(e,"opening_price"),this.safeNumber(e,"high_price"),this.safeNumber(e,"low_price"),this.safeNumber(e,"trade_price"),this.safeNumber(e,"candle_acc_trade_volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.parseTimeframe(t),o=this.timeframes[t];i===void 0&&(i=200);const d={market:r.id,timeframe:o,count:i};let c="publicGetCandlesTimeframe";if(o==="minutes"){const h=Math.round(a/60);d.unit=h,c+="Unit"}s!==void 0&&(d.to=this.iso8601(this.sum(s,a*i*1e3)));const u=await this[c](this.extend(d,n));return this.parseOHLCVs(u,r,t,s,i)}async createOrder(e,t,s,i,n=void 0,r={}){if(t==="market"&&s==="buy"&&this.options.createMarketBuyOrderRequiresPrice){if(n===void 0)throw new Yc(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)");i=i*n}let a;if(s==="buy")a="bid";else if(s==="sell")a="ask";else throw new Yc(this.id+" createOrder() allows buy or sell side only!");await this.loadMarkets();const d={market:this.market(e).id,side:a};t==="limit"?(d.volume=this.amountToPrecision(e,i),d.price=this.priceToPrecision(e,n),d.ord_type=t):t==="market"&&(s==="buy"?(d.ord_type="price",d.price=this.priceToPrecision(e,i)):s==="sell"&&(d.ord_type=t,d.volume=this.amountToPrecision(e,i)));const c=this.safeString2(r,"clientOrderId","identifier");c!==void 0&&(d.identifier=c),r=this.omit(r,["clientOrderId","identifier"]);const u=await this.privatePostOrders(this.extend(d,r));return this.parseOrder(u)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={uuid:e},n=await this.privateDeleteOrder(this.extend(i,s));return this.parseOrder(n)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.limit=s);const a=await this.privateGetDeposits(this.extend(n,i));return this.parseTransactions(a,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.limit=s);const a=await this.privateGetWithdraws(this.extend(n,i));return this.parseTransactions(a,r,t,s)}parseTransactionStatus(e){const t={submitting:"pending",submitted:"pending",almost_accepted:"pending",rejected:"failed",accepted:"pending",processing:"pending",done:"ok",canceled:"canceled"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"uuid"),i=this.safeNumber(e,"amount"),n=void 0,r=void 0,a=this.safeString(e,"txid"),o=this.safeString(e,"done_at"),d=this.parse8601(o),c=this.parse8601(this.safeString(e,"created_at",o));let u=this.safeString(e,"type");u==="withdraw"&&(u="withdrawal");const h=this.safeString(e,"currency"),l=this.safeCurrencyCode(h),p=this.parseTransactionStatus(this.safeStringLower(e,"state")),m=this.safeNumber(e,"fee");return{info:e,id:s,currency:l,amount:i,network:void 0,address:n,addressTo:void 0,addressFrom:void 0,tag:r,tagTo:void 0,tagFrom:void 0,status:p,type:u,updated:d,txid:a,timestamp:c,datetime:this.iso8601(c),fee:{currency:l,cost:m}}}parseOrderStatus(e){const t={wait:"open",done:"closed",cancel:"canceled"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"uuid");let i=this.safeString(e,"side");i==="bid"?i="buy":i="sell";let n=this.safeString(e,"ord_type");const r=this.parse8601(this.safeString(e,"created_at")),a=this.parseOrderStatus(this.safeString(e,"state"));let o,d=this.safeNumber(e,"price");const c=this.safeNumber(e,"volume"),u=this.safeNumber(e,"remaining_volume"),h=this.safeNumber(e,"executed_volume");let l;n==="price"&&(n="market",l=d,d=void 0);let p,m,g=this.safeNumber(e,"paid_fee");const y=this.safeString(e,"market");t=this.safeMarket(y,t);let b=this.safeValue(e,"trades",[]);b=this.parseTrades(b,t,void 0,void 0,{order:s,type:n});const w=b.length;if(w>0){o=b[w-1].timestamp;let T=!1;g===void 0&&(T=!0,g=0),l=0;for(let O=0;O<w;O++){const x=b[O];if(l=this.sum(l,x.cost),T){const C=this.safeValue(b[O],"fee",{}),E=this.safeNumber(C,"cost");E!==void 0&&(g=this.sum(g,E))}}p=l/h}return g!==void 0&&(m={currency:t.quote,cost:g}),{info:e,id:s,clientOrderId:void 0,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:o,symbol:t.symbol,type:n,timeInForce:void 0,postOnly:void 0,side:i,price:d,stopPrice:void 0,cost:l,average:p,amount:c,filled:h,remaining:u,status:a,fee:m,trades:b}}async fetchOrdersByState(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={state:e};let a;t!==void 0&&(a=this.market(t),r.market=a.id);const o=await this.privateGetOrders(this.extend(r,n));return this.parseOrders(o,a,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState("wait",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState("done",e,t,s,i)}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState("cancel",e,t,s,i)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={uuid:e},n=await this.privateGetOrder(this.extend(i,s));return this.parseOrder(n)}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetDepositsCoinAddresses(t);return this.parseDepositAddresses(s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"deposit_address"),i=this.safeString(e,"secondary_address"),n=this.safeString(e,"currency"),r=this.safeCurrencyCode(n);return this.checkAddress(s),{currency:r,address:s,tag:i,network:void 0,info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i=await this.privateGetDepositsCoinAddress(this.extend({currency:s.id},t));return this.parseDepositAddress(i)}async createDepositAddress(e,t={}){await this.loadMarkets();const i={currency:this.currency(e).id},n=await this.privatePostDepositsGenerateCoinAddress(this.extend(i,t));if(this.safeString(n,"message")!==void 0)throw new q7(this.id+" is generating "+e+" deposit address, call fetchDepositAddress or createDepositAddress one more time later to retrieve the generated address");return this.parseDepositAddress(n)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e),a={amount:t};let o="privatePostWithdraws";e!=="KRW"?(o+="Coin",a.currency=r.id,a.address=s,i!==void 0&&(a.secondary_address=i)):o+="Krw";const d=await this[o](this.extend(a,n));return this.parseTransaction(d)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.implodeParams(this.urls.api[t],{hostname:this.hostname});a+="/"+this.version+"/"+this.implodeParams(e,i);const o=this.omit(i,this.extractParams(e));if(s!=="POST"&&Object.keys(o).length&&(a+="?"+this.urlencode(o)),t==="private"){this.checkRequiredCredentials();const d=this.nonce(),c={access_key:this.apiKey,nonce:d};if(Object.keys(o).length){const h=this.urlencode(o),l=this.hash(this.encode(h),"sha512");c.query_hash=l,c.query_hash_alg="SHA512"}n={Authorization:"Bearer "+this.jwt(c,this.encode(this.secret))},s!=="GET"&&s!=="DELETE"&&(r=this.json(i),n["Content-Type"]="application/json")}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeValue(a,"error");if(c!==void 0){const u=this.safeString(c,"message"),h=this.safeString(c,"name"),l=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,l),this.throwExactlyMatchedException(this.exceptions.exact,h,l),this.throwBroadlyMatchedException(this.exceptions.broad,u,l),this.throwBroadlyMatchedException(this.exceptions.broad,h,l),new Xc(l)}}};const R7=ge,{ArgumentsRequired:F7,AuthenticationError:Mi,InsufficientFunds:Sh,InvalidOrder:ca,AccountSuspended:D7,ExchangeError:Qc,DuplicateOrderId:H7,OrderNotFound:G7,BadSymbol:U7,ExchangeNotAvailable:VT,BadRequest:vh}=de,Th=Se;var $7=class extends R7{describe(){return this.deepExtend(super.describe(),{id:"wavesexchange",name:"Waves.Exchange",countries:["CH"],certified:!1,pro:!1,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchDepositAddress:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTransfer:!1,fetchTransfers:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,signIn:!0,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","3h":"3h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/84547058-5fb27d80-ad0b-11ea-8711-78ac8b3c7f31.jpg",test:{matcher:"https://matcher-testnet.waves.exchange",node:"https://nodes-testnet.wavesnodes.com",public:"https://api-testnet.wavesplatform.com/v0",private:"https://api-testnet.waves.exchange/v1",forward:"https://testnet.waves.exchange/api/v1/forward/matcher",market:"https://testnet.waves.exchange/api/v1/forward/marketdata/api/v1"},api:{matcher:"https://matcher.waves.exchange",node:"https://nodes.waves.exchange",public:"https://api.wavesplatform.com/v0",private:"https://api.waves.exchange/v1",forward:"https://waves.exchange/api/v1/forward/matcher",market:"https://waves.exchange/api/v1/forward/marketdata/api/v1"},doc:"https://docs.waves.exchange",www:"https://waves.exchange"},api:{matcher:{get:["matcher","matcher/settings","matcher/settings/rates","matcher/balance/reserved/{publicKey}","matcher/debug/allSnashotOffsets","matcher/debug/currentOffset","matcher/debug/lastOffset","matcher/debug/oldestSnapshotOffset","matcher/orderbook","matcher/orderbook/{amountAsset}/{priceAsset}","matcher/orderbook/{baseId}/{quoteId}/publicKey/{publicKey}","matcher/orderbook/{baseId}/{quoteId}/{orderId}","matcher/orderbook/{baseId}/{quoteId}/info","matcher/orderbook/{baseId}/{quoteId}/status","matcher/orderbook/{baseId}/{quoteId}/tradeableBalance/{address}","matcher/orderbook/{publicKey}","matcher/orderbook/{publicKey}/{orderId}","matcher/orders/{address}","matcher/orders/{address}/{orderId}","matcher/transactions/{orderId}"],post:["matcher/orderbook","matcher/orderbook/market","matcher/orderbook/cancel","matcher/orderbook/{baseId}/{quoteId}/cancel","matcher/orderbook/{amountAsset}/{priceAsset}/calculateFee","matcher/debug/saveSnapshots","matcher/orders/{address}/cancel","matcher/orders/cancel/{orderId}"],delete:["matcher/orderbook/{baseId}/{quoteId}","matcher/settings/rates/{assetId}"],put:["matcher/settings/rates/{assetId}"]},node:{get:["addresses","addresses/balance/{address}","addresses/balance/{address}/{confirmations}","addresses/balance/details/{address}","addresses/data/{address}","addresses/data/{address}/{key}","addresses/effectiveBalance/{address}","addresses/effectiveBalance/{address}/{confirmations}","addresses/publicKey/{publicKey}","addresses/scriptInfo/{address}","addresses/scriptInfo/{address}/meta","addresses/seed/{address}","addresses/seq/{from}/{to}","addresses/validate/{address}","alias/by-address/{address}","alias/by-alias/{alias}","assets/{assetId}/distribution/{height}/{limit}","assets/balance/{address}","assets/balance/{address}/{assetId}","assets/details/{assetId}","assets/nft/{address}/limit/{limit}","blockchain/rewards","blockchain/rewards/height","blocks/address/{address}/{from}/{to}/","blocks/at/{height}","blocks/delay/{signature}/{blockNum}","blocks/first","blocks/headers/last","blocks/headers/seq/{from}/{to}","blocks/height","blocks/height/{signature}","blocks/last","blocks/seq/{from}/{to}","blocks/signature/{signature}","consensus/algo","consensus/basetarget","consensus/basetarget/{blockId}","consensus/{generatingbalance}/address","consensus/generationsignature","consensus/generationsignature/{blockId}","debug/balances/history/{address}","debug/blocks/{howMany}","debug/configInfo","debug/historyInfo","debug/info","debug/minerInfo","debug/portfolios/{address}","debug/state","debug/stateChanges/address/{address}","debug/stateChanges/info/{id}","debug/stateWaves/{height}","leasing/active/{address}","node/state","node/version","peers/all","peers/blacklisted","peers/connected","peers/suspended","transactions/address/{address}/limit/{limit}","transactions/info/{id}","transactions/status","transactions/unconfirmed","transactions/unconfirmed/info/{id}","transactions/unconfirmed/size","utils/seed","utils/seed/{length}","utils/time","wallet/seed"],post:["addresses","addresses/data/{address}","addresses/sign/{address}","addresses/signText/{address}","addresses/verify/{address}","addresses/verifyText/{address}","debug/blacklist","debug/print","debug/rollback","debug/validate","node/stop","peers/clearblacklist","peers/connect","transactions/broadcast","transactions/calculateFee","tranasctions/sign","transactions/sign/{signerAddress}","tranasctions/status","utils/hash/fast","utils/hash/secure","utils/script/compileCode","utils/script/compileWithImports","utils/script/decompile","utils/script/estimate","utils/sign/{privateKey}","utils/transactionsSerialize"],delete:["addresses/{address}","debug/rollback-to/{signature}"]},public:{get:["assets","pairs","candles/{baseId}/{quoteId}","transactions/exchange"]},private:{get:["deposit/addresses/{currency}","deposit/addresses/{currency}/{platform}","platforms","deposit/currencies","withdraw/currencies","withdraw/addresses/{currency}/{address}"],post:["oauth2/token"]},forward:{get:["matcher/orders/{address}","matcher/orders/{address}/{orderId}"],post:["matcher/orders/{wavesAddress}/cancel"]},market:{get:["tickers"]}},currencies:{WX:{id:"EMAMLxDnv3xiz8RXg8Btj33jcEw3wLczL3JKYYmuubpc",numericId:void 0,code:"WX",precision:8}},options:{allowedCandles:1440,accessToken:void 0,createMarketBuyOrderRequiresPrice:!0,matcherPublicKey:void 0,quotes:void 0,createOrderDefaultExpiry:24192e5,wavesAddress:void 0,withdrawFeeUSDN:7420,withdrawFeeWAVES:1e5,wavesPrecision:8,messagePrefix:"W",networks:{ERC20:"ETH",BEP20:"BSC"},reverseNetworks:{ETH:"ERC20",BSC:"BEP20"}},commonCurrencies:{EGG:"Waves Ducks"},requiresEddsa:!0,exceptions:{3147270:Sh,112:Sh,4:Qc,13:VT,14:VT,3145733:D7,3148040:H7,3148801:Mi,9440512:Mi,9440771:U7,9441026:ca,9441282:ca,9441286:ca,9441295:ca,9441540:ca,9441542:ca,106954752:Mi,106954769:Mi,106957828:Mi,106960131:Mi,106981137:Mi,9437184:vh,9437193:G7,1048577:vh,1051904:Mi}})}setSandboxMode(e){return this.options.messagePrefix=e?"T":"W",super.setSandboxMode(e)}async getFeesForAsset(e,t,s,i,n={}){await this.loadMarkets();const r=this.market(e);s=this.amountToPrecision(e,s),i=this.priceToPrecision(e,i);const a=this.extend({amountAsset:r.baseId,priceAsset:r.quoteId,orderType:t,amount:s,price:i},n);return await this.matcherPostMatcherOrderbookAmountAssetPriceAssetCalculateFee(a)}async calculateFee(e,t,s,i,n,r="taker",a={}){const o=await this.getFeesForAsset(e,s,i,n),d=this.safeValue(a,"isDiscountFee",!1);let c;d?c=this.safeValue(o,"discount"):c=this.safeValue(o,"base");const u=this.safeString(c,"matcherFee"),h=this.safeString(c,"feeAssetId"),l=this.safeCurrencyCode(h),p=this.currencyFromPrecision(l,u),m=this.numberToString(i),g=this.numberToString(n),y=this.feeToPrecision(e,this.parseNumber(p)),b=Th.stringDiv(p,Th.stringMul(m,g));return{type:r,currency:l,rate:this.parseNumber(b),cost:this.parseNumber(y)}}async getQuotes(){let e=this.safeValue(this.options,"quotes");if(e)return e;{const t=await this.matcherGetMatcherSettings();e={};const s=this.safeValue(t,"priceAssets");for(let i=0;i<s.length;i++)e[s[i]]=!0;return this.options.quotes=e,e}}async fetchMarkets(e={}){const t=await this.marketGetTickers(),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"amountAssetID"),a=this.safeString(n,"priceAssetID"),o=r+"/"+a,d=this.safeString(n,"symbol");let[c,u]=d.split("/");c=this.safeCurrencyCode(c),u=this.safeCurrencyCode(u);const h=c+"/"+u;s.push({id:o,symbol:h,base:c,quote:u,settle:void 0,baseId:r,quoteId:a,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeInteger(n,"amountAssetDecimals"),price:this.safeInteger(n,"priceAssetDecimals")},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:n})}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n=this.extend({amountAsset:i.baseId,priceAsset:i.quoteId},s),r=await this.matcherGetMatcherOrderbookAmountAssetPriceAsset(n),a=this.safeInteger(r,"timestamp"),o=this.parseOrderBookSide(this.safeValue(r,"bids"),i,t),d=this.parseOrderBookSide(this.safeValue(r,"asks"),i,t);return{symbol:e,bids:o,asks:d,timestamp:a,datetime:this.iso8601(a),nonce:void 0}}parseOrderBookSide(e,t=void 0,s=void 0){const i=t.precision,n=this.safeInteger(this.options,"wavesPrecision",8),r=Math.pow(10,i.amount),a=i.amount-i.price,o=Math.pow(10,n-a),d=[];for(let c=0;c<e.length;c++){const u=e[c],h=this.safeInteger(u,"price",0)/o,l=this.safeInteger(u,"amount",0)/r;if(s!==void 0&&c>s)break;d.push([h,l])}return d}checkRequiredKeys(){if(this.apiKey===void 0)throw new Mi(this.id+" requires apiKey credential");if(this.secret===void 0)throw new Mi(this.id+" requires secret credential");let e,t;try{e=this.base58ToBinary(this.apiKey)}catch{throw new Mi(this.id+" apiKey must be a base58 encoded public key")}try{t=this.base58ToBinary(this.secret)}catch{throw new Mi(this.id+" secret must be a base58 encoded private key")}const s=this.binaryToBase16(e),i=this.binaryToBase16(t);if(s.length!==64)throw new Mi(this.id+" apiKey must be a base58 encoded public key");if(i.length!==64)throw new Mi(this.id+" secret must be a base58 encoded private key")}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.omit(i,this.extractParams(e)),o=e==="matcher/orders/{wavesAddress}/cancel";e=this.implodeParams(e,i);let d=this.urls.api[t]+"/"+e,c=this.urlencodeWithArrayRepeat(a);if(t==="private"||t==="forward"){n={Accept:"application/json"};const u=this.safeString(this.options,"accessToken");u&&(n.Authorization="Bearer "+u),s==="POST"?n["content-type"]="application/json":n["content-type"]="application/x-www-form-urlencoded",o&&(r=this.json([a.orderId]),c=""),c.length>0&&(d+="?"+c)}else t==="matcher"?s==="POST"?(n={Accept:"application/json","Content-Type":"application/json"},r=this.json(a)):n=a:s==="POST"?(n={"content-type":"application/json"},r=this.json(a)):(n={"content-type":"application/x-www-form-urlencoded"},c.length>0&&(d+="?"+c));return{url:d,method:s,body:r,headers:n}}async signIn(e={}){if(!this.safeString(this.options,"accessToken")){const t="ffffff01";let i=this.sum(this.seconds(),604800);i=i.toString();const n="waves.exchange",a=this.safeString(this.options,"messagePrefix","W")+":"+n+":"+i,o=this.binaryToBase16(this.stringToBinary(this.encode(a))),d=t+o,c=this.binaryToBase16(this.base58ToBinary(this.secret)),u=this.eddsa(d,c,"ed25519"),h={grant_type:"password",scope:"general",username:this.apiKey,password:i+":"+u,client_id:n},l=await this.privatePostOauth2Token(h);return this.options.accessToken=this.safeString(l,"access_token"),this.options.accessToken}}parseTicker(e,t=void 0){const i=this.safeString(e,"amountAsset"),n=this.safeString(e,"priceAsset");let r;if(i!==void 0&&n!==void 0){const m=i+"/"+n;t=this.safeMarket(m,t,"/"),r=t.symbol}const a=this.safeValue(e,"data",{}),o=this.safeString(a,"lastPrice"),d=this.safeString(a,"low"),c=this.safeString(a,"high"),u=this.safeString(a,"weightedAveragePrice"),h=this.safeString(a,"volume"),l=this.safeString(a,"quoteVolume"),p=this.safeString(a,"firstPrice");return this.safeTicker({symbol:r,timestamp:void 0,datetime:this.iso8601(void 0),high:c,low:d,bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:u,open:p,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:h,quoteVolume:l,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pairs:s.id},n=await this.publicGetPairs(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0,{});return this.parseTicker(a,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetPairs(t),i=this.safeValue(s,"data",[]);return this.parseTickers(i,e)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={baseId:r.baseId,quoteId:r.quoteId,interval:this.timeframes[t]},o=this.safeInteger(this.options,"allowedCandles",1440);i===void 0&&(i=o),i=Math.min(o,i);const d=this.parseTimeframe(t)*1e3;if(s===void 0){const m=parseInt(this.milliseconds()/d)*d,g=(i-1)*d,y=m-g;a.timeStart=y.toString()}else{a.timeStart=s.toString();const m=this.sum(s,d*i);a.timeEnd=m.toString()}const c=await this.publicGetCandlesBaseIdQuoteId(this.extend(a,n)),u=this.safeValue(c,"data",[]);let h=this.parseOHLCVs(u,r,t,s,i);h=this.filterFutureCandles(h);let l;const p=h.length;for(let m=0;m<h.length;m++){const g=p-m-1,y=h[g];y[1]===void 0&&(y[1]=l,y[2]=l,y[3]=l,y[4]=l,h[g]=y),l=y[4]}return h}filterFutureCandles(e){const t=[],s=this.milliseconds();for(let i=0;i<e.length&&!(e[i][0]>s);i++)t.push(e[i]);return t}parseOHLCV(e,t=void 0){const s=this.safeValue(e,"data",{});return[this.parse8601(this.safeString(s,"time")),this.safeNumber(s,"open"),this.safeNumber(s,"high"),this.safeNumber(s,"low"),this.safeNumber(s,"close"),this.safeNumber(s,"volume",0)]}async fetchDepositAddress(e,t={}){await this.signIn();const s=this.safeValue(this.options,"networks",{}),i=this.safeStringUpper(t,"network"),n=this.safeString(s,i,i);t=this.omit(t,["network"]);const r=await this.privateGetPlatforms(),a={},o={},d=this.safeValue(r,"items",[]);for(let y=0;y<d.length;y++){const b=d[y],w=this.safeString(b,"id"),k=this.safeValue(b,"currencies",[]);for(let T=0;T<k.length;T++){const O=this.safeString(k,T);a[O]=!0,O in o||(o[O]={}),o[O][w]=!0}}if(!(e in a)){const y=Object.keys(a);throw new Qc(this.id+" fetchDepositAddress() "+e+" not supported. Currency code must be one of "+y.join(", "))}let c;if(n===void 0){const y={currency:e};c=await this.privateGetDepositAddressesCurrency(this.extend(y,t))}else{const y=o[e];if(!(n in y)){const b=Object.keys(y);throw new Qc(this.id+" "+n+" network "+e+" deposit address not supported. Network must be one of "+b.join(", "))}if(n==="WAVES"){const b={publicKey:this.apiKey},w=await this.nodeGetAddressesPublicKeyPublicKey(this.extend(b,b));return{address:this.safeString(w,"address"),code:e,currency:e,network:n,tag:void 0,info:w}}else{const b={currency:e,platform:n};c=await this.privateGetDepositAddressesCurrencyPlatform(this.extend(b,t))}}const u=this.safeValue(c,"currency"),h=this.safeString(u,"platform_id"),l=this.safeValue(this.options,"reverseNetworks",{}),p=this.safeString(l,h,h),m=this.safeValue(c,"deposit_addresses");return{address:this.safeString(m,0),code:e,currency:e,tag:void 0,network:p,info:c}}async getMatcherPublicKey(){const e=this.safeString(this.options,"matcherPublicKey");if(e)return e;{const t=await this.matcherGetMatcher();return this.options.matcherPublicKey=t.slice(1,t.length-1),this.options.matcherPublicKey}}getAssetBytes(e){return e==="WAVES"?this.numberToBE(0,1):this.binaryConcat(this.numberToBE(1,1),this.base58ToBinary(e))}getAssetId(e){return e==="WAVES"?"":e}priceToPrecision(e,t){const s=this.markets[e],i=this.safeInteger(this.options,"wavesPrecision",8),n=s.precision.amount-s.precision.price;return parseInt(parseFloat(this.toPrecision(t,i-n)))}amountToPrecision(e,t){return parseInt(parseFloat(this.toPrecision(t,this.markets[e].precision.amount)))}currencyToPrecision(e,t,s=void 0){return parseInt(parseFloat(this.toPrecision(t,this.currencies[e].precision)))}fromPrecision(e,t){if(e===void 0)return;const s=new Th(e);return s.decimals=this.sum(s.decimals,t),s.reduce(),s.toString()}toPrecision(e,t){const s=e.toString(),i=new Th(s);return i.decimals=i.decimals-t,i.reduce(),i.toString()}currencyFromPrecision(e,t){const s=this.currencies[e].precision;return this.fromPrecision(t,s)}priceFromPrecision(e,t){const s=this.markets[e],i=this.safeInteger(this.options,"wavesPrecision",8),n=this.sum(i,s.precision.price)-s.precision.amount;return this.fromPrecision(t,n)}safeGetDynamic(e){const t=this.safeValue(e,"orderFee");return"dynamic"in t?this.safeValue(t,"dynamic"):this.safeValue(t.composite.default,"dynamic")}safeGetRates(e){const t=this.safeValue(e,"rates");return t===void 0?{WAVES:1}:t}async createOrder(e,t,s,i,n=void 0,r={}){this.checkRequiredDependencies(),this.checkRequiredKeys(),await this.loadMarkets();const a=this.market(e),o=await this.getMatcherPublicKey(),d=this.getAssetId(a.baseId),c=this.getAssetId(a.quoteId),u=t==="market";if(u&&n===void 0)throw new ca(this.id+" createOrder() requires a price argument for "+t+" orders to determine the max price for buy and the min price for sell");const h=s==="buy"?0:1,l=this.milliseconds(),p=this.safeInteger(this.options,"createOrderDefaultExpiry",24192e5),m=this.sum(l,p),g=await this.getFeesForAsset(e,s,i,n),y=this.safeValue(g,"base"),b=this.safeString(y,"feeAssetId"),w=this.safeCurrencyCode(b),k=this.safeString(y,"matcherFee"),T=this.safeValue(g,"discount"),O=this.safeString(T,"feeAssetId"),x=this.safeCurrencyCode(O),C=this.safeString(T,"matcherFee");let E,P;if("feeAsset"in r||"feeAsset"in this.options){const R=this.safeString(r,"feeAsset",this.safeString(this.options,"feeAsset")),G=this.currency(R);E=this.safeString(G,"id")}const _=await this.fetchBalance();if(E!==void 0){if(b!==E&&O!==E)throw new ca(this.id+" asset fee must be "+w+" or "+x);const R=this.safeCurrencyCode(E),G=E===b?k:C,F=parseFloat(this.currencyFromPrecision(R,G));if(R in _&&_[R].free>=F)P=parseInt(G);else throw new Sh(this.id+" not enough funds of the selected asset fee")}if(E===void 0){const R=parseFloat(this.currencyFromPrecision(w,k));if(w in _&&_[w].free>=R)E=b,P=parseInt(k);else{const G=parseFloat(this.currencyFromPrecision(x,C));x in _&&_[x].free>=G&&(E=O,P=parseInt(C))}}if(E===void 0)throw new Sh(this.id+" not enough funds on none of the eligible asset fees");i=this.amountToPrecision(e,i),n=this.priceToPrecision(e,n);const S=[this.numberToBE(3,1),this.base58ToBinary(this.apiKey),this.base58ToBinary(o),this.getAssetBytes(a.baseId),this.getAssetBytes(a.quoteId),this.numberToBE(h,1),this.numberToBE(n,8),this.numberToBE(i,8),this.numberToBE(l,8),this.numberToBE(m,8),this.numberToBE(P,8),this.getAssetBytes(E)],I=this.binaryConcatArray(S),v=this.eddsa(this.binaryToBase16(I),this.binaryToBase16(this.base58ToBinary(this.secret)),"ed25519"),N={amountAsset:d,priceAsset:c},q={senderPublicKey:this.apiKey,matcherPublicKey:o,assetPair:N,orderType:s,price:n,amount:i,timestamp:l,expiration:m,matcherFee:parseInt(P),signature:v,version:3};if(E!=="WAVES"&&(q.matcherFeeAssetId=E),u){const R=await this.matcherPostMatcherOrderbookMarket(q),G=this.safeValue(R,"message");return this.parseOrder(G,a)}else{const R=await this.matcherPostMatcherOrderbook(q),G=this.safeValue(R,"message");return this.parseOrder(G,a)}}async cancelOrder(e,t=void 0,s={}){this.checkRequiredDependencies(),this.checkRequiredKeys(),await this.signIn();const i=await this.getWavesAddress(),n=await this.forwardPostMatcherOrdersWavesAddressCancel({wavesAddress:i,orderId:e}),r=this.safeValue(n,"message"),a=this.safeValue(r,0),o=this.safeValue(a,0),d=this.safeString(o,"orderId");return{info:n,id:d,clientOrderId:void 0,timestamp:void 0,datetime:void 0,lastTradeTimestamp:void 0,symbol:t,type:void 0,side:void 0,price:void 0,amount:void 0,cost:void 0,average:void 0,filled:void 0,remaining:void 0,status:void 0,fee:void 0,trades:void 0}}async fetchOrder(e,t=void 0,s={}){this.checkRequiredDependencies(),this.checkRequiredKeys(),await this.loadMarkets();let i;t!==void 0&&(i=this.market(t));const n=this.milliseconds(),r=[this.base58ToBinary(this.apiKey),this.numberToBE(n,8)],a=this.binaryConcatArray(r),o=this.binaryToBase16(this.base58ToBinary(this.secret)),d=this.eddsa(this.binaryToBase16(a),o,"ed25519"),c={Timestamp:n.toString(),Signature:d,publicKey:this.apiKey,orderId:e},u=await this.matcherGetMatcherOrderbookPublicKeyOrderId(this.extend(c,s));return this.parseOrder(u,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(this.checkRequiredDependencies(),this.checkRequiredKeys(),e===void 0)throw new F7(this.id+" fetchOrders() requires symbol argument");await this.loadMarkets();const n=this.market(e),r=this.milliseconds(),a=[this.base58ToBinary(this.apiKey),this.numberToBE(r,8)],o=this.binaryConcatArray(a),d=this.binaryToBase16(this.base58ToBinary(this.secret)),c=this.eddsa(this.binaryToBase16(o),d,"ed25519"),u={Accept:"application/json",Timestamp:r.toString(),Signature:c,publicKey:this.apiKey,baseId:n.baseId,quoteId:n.quoteId},h=await this.matcherGetMatcherOrderbookBaseIdQuoteIdPublicKeyPublicKey(this.extend(u,i));return this.parseOrders(h,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.signIn();let n;e!==void 0&&(n=this.market(e));const a={address:await this.getWavesAddress(),activeOnly:!0},o=await this.forwardGetMatcherOrdersAddress(a);return this.parseOrders(o,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.signIn();let n;e!==void 0&&(n=this.market(e));const a={address:await this.getWavesAddress(),closedOnly:!0},o=await this.forwardGetMatcherOrdersAddress(a);return this.parseOrders(o,n,t,s)}parseOrderStatus(e){const t={Cancelled:"canceled",Accepted:"open",Filled:"closed",PartiallyFilled:"open"};return this.safeString(t,e,e)}getSymbolFromAssetPair(e){const t=this.safeString(e,"amountAsset","WAVES"),s=this.safeString(e,"priceAsset","WAVES");return this.safeCurrencyCode(t)+"/"+this.safeCurrencyCode(s)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString2(e,"type","orderType");let n="limit";"type"in e&&(n=this.safeString(e,"orderType",n));const r=this.safeString(e,"id"),a=this.safeString(e,"filled"),o=this.safeString(e,"price"),d=this.safeString(e,"amount"),c=this.safeValue(e,"assetPair");let u;c!==void 0?u=this.getSymbolFromAssetPair(c):t!==void 0&&(u=t.symbol);const h=this.safeCurrencyCode(this.safeString(c,"amountAsset","WAVES")),l=this.priceFromPrecision(u,o),p=this.currencyFromPrecision(h,d),m=this.currencyFromPrecision(h,a),g=this.priceFromPrecision(u,this.safeString(e,"avgWeighedPrice")),y=this.parseOrderStatus(this.safeString(e,"status"));let b;if("type"in e){const w=this.safeCurrencyCode(this.safeString(e,"feeAsset"));b={currency:w,fee:this.parseNumber(this.currencyFromPrecision(w,this.safeString(e,"filledFee")))}}else{const w=this.safeCurrencyCode(this.safeString(e,"matcherFeeAssetId","WAVES"));b={currency:w,fee:this.parseNumber(this.currencyFromPrecision(w,this.safeString(e,"matcherFee")))}}return this.safeOrder({info:e,id:r,clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,symbol:u,type:n,timeInForce:void 0,postOnly:void 0,side:i,price:l,stopPrice:void 0,amount:p,cost:void 0,average:g,filled:m,remaining:void 0,status:y,fee:b,trades:void 0},t)}async getWavesAddress(){const e=this.safeString(this.options,"wavesAddress");if(e===void 0){const t={publicKey:this.apiKey},s=await this.nodeGetAddressesPublicKeyPublicKey(t);return this.options.wavesAddress=this.safeString(s,"address"),this.options.wavesAddress}else return e}async fetchBalance(e={}){this.checkRequiredDependencies(),this.checkRequiredKeys(),await this.loadMarkets();const t=await this.getWavesAddress(),s={address:t},i=await this.nodeGetAssetsBalanceAddress(s),n=this.safeValue(i,"balances",[]),r={};let a;const o=[],d=[];for(let O=0;O<n.length;O++){const x=n[O],C=this.safeInteger(x,"timestamp");a=a===void 0?C:Math.max(a,C);const E=this.safeValue(x,"issueTransaction"),P=this.safeString(x,"assetId"),_=this.safeString(x,"balance");if(E===void 0){o.push(P),d.push(_);continue}const S=this.safeInteger(E,"decimals");let I;P in this.currencies_by_id&&(I=this.safeCurrencyCode(P),r[I]=this.account(),r[I].total=this.fromPrecision(_,S))}if(o.length){const O={ids:o},x=await this.publicGetAssets(O),C=this.safeValue(x,"data",[]);for(let E=0;E<C.length;E++){const P=C[E],_=d[E],S=this.safeValue(P,"data"),I=this.safeInteger(S,"precision"),v=this.safeString(S,"ticker"),N=this.safeCurrencyCode(v);r[N]=this.account(),r[N].total=this.fromPrecision(_,I)}}const u=this.milliseconds(),h=[this.base58ToBinary(this.apiKey),this.numberToBE(u,8)],l=this.binaryConcatArray(h),p=this.binaryToBase16(this.base58ToBinary(this.secret)),m=this.eddsa(this.binaryToBase16(l),p,"ed25519"),g={publicKey:this.apiKey,signature:m,timestamp:u.toString()},y=await this.matcherGetMatcherBalanceReservedPublicKey(g),b=Object.keys(y);for(let O=0;O<b.length;O++){const x=b[O],C=this.safeCurrencyCode(x);C in r||(r[C]=this.account());const E=this.safeString(y,x);C in this.currencies?r[C].used=this.currencyFromPrecision(C,E):r[C].used=E}const w={address:t},k=await this.nodeGetAddressesBalanceAddress(w);r.WAVES=this.safeValue(r,"WAVES",{}),r.WAVES.total=this.currencyFromPrecision("WAVES",this.safeString(k,"balance"));const T=Object.keys(r);for(let O=0;O<T.length;O++){const x=T[O];this.safeValue(r[x],"used")===void 0&&(r[x].used="0")}return r.timestamp=a,r.datetime=this.iso8601(a),this.safeBalance(r)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={sender:await this.getWavesAddress()};let a;e!==void 0&&(a=this.market(e),r.amountAsset=a.baseId,r.priceAsset=a.quoteId);const o=await this.publicGetTransactionsExchange(r),d=this.safeValue(o,"data");return this.parseTrades(d,a,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={amountAsset:n.baseId,priceAsset:n.quoteId};s!==void 0&&(r.limit=s),t!==void 0&&(r.timeStart=t);const a=await this.publicGetTransactionsExchange(r),o=this.safeValue(a,"data");return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){const s=this.safeValue(e,"data"),i=this.safeString(s,"timestamp"),n=this.parse8601(i),r=this.safeString(s,"id"),a=this.safeString(s,"price"),o=this.safeString(s,"amount"),d=this.safeValue(s,"order1"),c=this.safeValue(s,"order2");let u;this.safeString(d,"senderPublicKey")===this.apiKey?u=d:u=c;let h;const l=this.safeValue(u,"assetPair");l!==void 0?h=this.getSymbolFromAssetPair(l):t!==void 0&&(h=t.symbol);const p=this.safeString(u,"orderType"),m=this.safeString(u,"id"),g={cost:this.safeString(u,"matcherFee"),currency:this.safeCurrencyCode(this.safeString(u,"matcherFeeAssetId","WAVES"))};return this.safeTrade({info:e,timestamp:n,datetime:i,symbol:h,id:r,order:m,type:void 0,side:p,takerOrMaker:void 0,price:a,amount:o,cost:void 0,fee:g},t)}handleErrors(e,t,s,i,n,r,a,o,d){const c=this.safeString(a,"error"),u=this.safeValue(a,"success",!0),h=this.safeValue(this.exceptions,c);if(h!==void 0){const p=this.safeString(a,"message");throw new h(this.id+" "+p)}if(this.safeString(a,"message")==="Validation Error")throw new vh(this.id+" "+r);if(!u)throw new Qc(this.id+" "+r)}async withdraw(e,t,s,i=void 0,n={}){if([i,n]=this.handleWithdrawTagAndParams(i,n),e!=="WAVES"){const E=await this.privateGetWithdrawCurrencies(),P={},_=this.safeValue(E,"items",[]);for(let S=0;S<_.length;S++){const I=_[S],v=this.safeString(I,"id");P[v]=!0}if(!(e in P)){const S=Object.keys(P);throw new Qc(this.id+" withdraw() "+e+" not supported. Currency code must be one of "+S.toString())}}await this.loadMarkets();const r=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"],a={};for(let E=0;E<r.length;E++){const P=r[E];a[P]=!0}let o=!0;const c=this.remove0xPrefix(s).toLowerCase();for(let E=0;E<c.length;E++)if(!(c[E]in a)){o=!1;break}await this.signIn();let u;if(e==="WAVES"&&!o)u=s;else{const E={address:s,currency:e},P=await this.privateGetWithdrawAddressesCurrencyAddress(E),_=this.safeValue(P,"currency"),S=this.safeValue(_,"allowed_amount"),I=this.safeNumber(S,"min");if(t<=I)throw new vh(this.id+" "+e+" withdraw failed, amount "+t.toString()+" must be greater than the minimum allowed amount of "+I.toString());const v=this.safeValue(P,"proxy_addresses",[]);u=this.safeString(v,0)}const h=this.safeInteger(this.options,"withdrawFeeWAVES",1e5),l="WAVES",p=4,m=2,g=this.currencyToPrecision(e,t),y=this.currency(e),b=this.milliseconds(),w=[this.numberToBE(4,1),this.numberToBE(2,1),this.base58ToBinary(this.apiKey),this.getAssetBytes(y.id),this.getAssetBytes(l),this.numberToBE(b,8),this.numberToBE(g,8),this.numberToBE(h,8),this.base58ToBinary(u),this.numberToBE(0,2)],k=this.binaryConcatArray(w),T=this.binaryToBase16(this.base58ToBinary(this.secret)),O=this.eddsa(this.binaryToBase16(k),T,"ed25519"),x={senderPublicKey:this.apiKey,amount:g,fee:h,type:p,version:m,attachment:"",feeAssetId:this.getAssetId(l),proofs:[O],assetId:this.getAssetId(y.id),recipient:u,timestamp:b,signature:O},C=await this.nodePostTransactionsBroadcast(x);return this.parseTransaction(C,y)}parseTransaction(e,t=void 0){return t=this.safeCurrency(void 0,t),{id:void 0,txid:void 0,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0,info:e}}};const j7=ge,{ExchangeError:kg,BadRequest:Zc,RateLimitExceeded:W7,BadSymbol:z7,ArgumentsRequired:Sg,PermissionDenied:K7,InsufficientFunds:X7,InvalidOrder:qT}=de,{TICK_SIZE:Y7}=me,LT=Se;var oC=class extends j7{describe(){return this.deepExtend(super.describe(),{id:"wazirx",name:"WazirX",countries:["IN"],version:"v2",rateLimit:1e3,pro:!0,has:{CORS:!1,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchBidsAsks:!1,fetchClosedOrders:!1,fetchCurrencies:!1,fetchDepositAddress:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!1,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfers:!1,fetchWithdrawals:!1,transfer:!1,withdraw:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/148647666-c109c20b-f8ac-472f-91c3-5f658cb90f49.jpeg",api:{rest:"https://api.wazirx.com/sapi/v1"},www:"https://wazirx.com",doc:"https://docs.wazirx.com/#public-rest-api-for-wazirx",fees:"https://wazirx.com/fees",referral:"https://wazirx.com/invite/k7rrnks5"},api:{public:{get:{exchangeInfo:1,depth:1,ping:1,systemStatus:1,"tickers/24hr":1,"ticker/24hr":1,time:1,trades:1,klines:1}},private:{get:{account:1,allOrders:1,funds:1,historicalTrades:1,openOrders:1,order:1,myTrades:1},post:{order:1,"order/test":1},delete:{order:1,openOrders:1}}},fees:{WRX:{maker:this.parseNumber("0.0"),taker:this.parseNumber("0.0")}},precisionMode:Y7,exceptions:{exact:{"-1121":z7,1999:Zc,2002:X7,2005:Zc,2078:K7,2098:Zc,2031:qT,2113:Zc,2115:Zc,2136:W7,94001:qT}},timeframes:{"1m":"1m","5m":"5m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","1w":"1w"},options:{recvWindow:1e4}})}async fetchMarkets(e={}){const t=await this.publicGetExchangeInfo(e),s=this.safeValue(t,"symbols",[]),i=[];for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"symbol"),o=this.safeString(r,"baseAsset"),d=this.safeString(r,"quoteAsset"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d),h=this.safeValue(r,"isSpotTradingAllowed"),l=this.safeValue(r,"filters");let p;for(let w=0;w<l.length;w++){const k=l[w];this.safeString(k,"filterType")==="PRICE_FILTER"&&(p=this.safeNumber(k,"minPrice"))}const m=this.safeValue(this.fees,u,{});let g=this.safeString(m,"taker","0.2");g=LT.stringDiv(g,"100");let y=this.safeString(m,"maker","0.2");y=LT.stringDiv(y,"100");const b=this.safeString(r,"status");i.push({id:a,symbol:c+"/"+u,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:h,margin:!1,swap:!1,future:!1,option:!1,active:b==="trading",contract:!1,linear:void 0,inverse:void 0,taker:this.parseNumber(g),maker:this.parseNumber(y),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"baseAssetPrecision"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"quoteAssetPrecision")))},limits:{leverage:{min:void 0,max:void 0},price:{min:p,max:void 0},amount:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:r})}return i}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,interval:this.timeframes[t]};i!==void 0&&(a.limit=i);const o=this.safeInteger(n,"until");n=this.omit(n,["until"]),s!==void 0&&(a.startTime=parseInt(s/1e3)),o!==void 0&&(a.endTime=o);const d=await this.publicGetKlines(this.extend(a,n));return this.parseOHLCVs(d,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={symbol:this.market(e).id};t!==void 0&&(n.limit=t);const r=await this.publicGetDepth(this.extend(n,s)),a=this.safeInteger(r,"timestamp");return this.parseOrderBook(r,e,a)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.publicGetTicker24hr(this.extend(i,t));return this.parseTicker(n,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickers24hr(),i={};for(let n=0;n<s.length;n++){const r=s[n],a=this.parseTicker(r),o=a.symbol;i[o]=a}return i}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s);const a=this.safeString(this.options,"fetchTradesMethod","publicGetTrades"),o=await this[a](this.extend(r,i));return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeInteger(e,"time"),n=this.iso8601(i);t=this.safeMarket(void 0,t);const a=this.safeValue(e,"isBuyerMaker")?"sell":"buy",o=this.safeNumber(e,"price"),d=this.safeNumber(e,"qty"),c=this.safeNumber(e,"quoteQty");return this.safeTrade({info:e,id:s,timestamp:i,datetime:n,symbol:t.symbol,order:s,type:void 0,side:a,takerOrMaker:void 0,price:o,amount:d,cost:c,fee:void 0},t)}async fetchStatus(e={}){const t=await this.publicGetSystemStatus(e);return{status:this.safeString(t,"status")==="normal"?"ok":"maintenance",updated:void 0,eta:void 0,url:void 0,info:t}}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeInteger(t,"serverTime")}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeString(e,"lastPrice"),r=this.safeString(e,"openPrice"),a=this.safeString(e,"highPrice"),o=this.safeString(e,"lowPrice"),d=this.safeString(e,"volume"),c=this.safeString(e,"bidPrice"),u=this.safeString(e,"askPrice"),h=this.safeInteger(e,"at");return this.safeTicker({symbol:i,timestamp:h,datetime:this.iso8601(h),high:a,low:o,bid:c,bidVolume:void 0,ask:u,askVolume:void 0,vwap:void 0,open:r,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:d,quoteVolume:void 0,info:e},t)}parseBalance(e){const t={};for(let s=0;s<e.length;s++){const i=e[s],n=this.safeString(i,"asset"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"free"),a.used=this.safeString(i,"locked"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetFunds(e);return this.parseBalance(t)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Sg(this.id+" fetchOrders() requires a `symbol` argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};t!==void 0&&(r.startTime=t),s!==void 0&&(r.limit=s);const a=await this.privateGetAllOrders(this.extend(r,i));let o=this.parseOrders(a,n,t,s);return o=this.filterBy(o,"symbol",e),o}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id);const a=await this.privateGetOpenOrders(this.extend(n,i));return this.parseOrders(a,r,t,s)}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new Sg(this.id+" cancelAllOrders() requires a `symbol` argument");await this.loadMarkets();const i={symbol:this.market(e).id};return await this.privateDeleteOpenOrders(this.extend(i,t))}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Sg(this.id+" cancelOrder() requires a `symbol` argument");await this.loadMarkets();const n={symbol:this.market(t).id,orderId:e},r=await this.privateDeleteOrder(this.extend(n,s));return this.parseOrder(r)}async createOrder(e,t,s,i,n=void 0,r={}){if(t=t.toLowerCase(),t!=="limit"&&t!=="stop_limit")throw new kg(this.id+" createOrder() supports limit and stop_limit orders only");if(n===void 0)throw new kg(this.id+" createOrder() requires a price argument");await this.loadMarkets();const a=this.market(e),o={symbol:a.id,side:s,quantity:i,type:"limit"};o.price=this.priceToPrecision(e,n),this.safeString(r,"stopPrice")!==void 0&&(o.type="stop_limit");const c=await this.privatePostOrder(this.extend(o,r));return this.parseOrder(c,a)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"createdTime"),i=this.safeInteger(e,"updatedTime"),n=this.safeString(e,"symbol"),r=this.safeSymbol(n,t),a=this.safeString(e,"quantity"),o=this.safeString(e,"executedQty"),d=this.parseOrderStatus(this.safeString(e,"status")),c=this.safeString(e,"id"),u=this.safeString(e,"price"),h=this.safeStringLower(e,"type"),l=this.safeStringLower(e,"side");return this.safeOrder({info:e,id:c,clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:i,status:d,symbol:r,type:h,timeInForce:void 0,postOnly:void 0,side:l,price:u,amount:a,filled:o,remaining:void 0,cost:void 0,fee:void 0,average:void 0,trades:[]},t)}parseOrderStatus(e){const t={wait:"open",done:"closed",cancel:"canceled"};return this.safeString(t,e,e)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/"+e;if(t==="public"&&Object.keys(i).length&&(a+="?"+this.urlencode(i)),t==="private"){this.checkRequiredCredentials();const o=this.milliseconds();let d=this.extend({recvWindow:this.options.recvWindow,timestamp:o},i);d=this.keysort(d);const c=this.hmac(this.encode(this.urlencode(d)),this.encode(this.secret),"sha256");a+="?"+this.urlencode(d),a+="&signature="+c,n={"Content-Type":"application/x-www-form-urlencoded","X-Api-Key":this.apiKey}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.safeString(a,"code");if(c!==void 0){const u=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,c,u),new kg(u)}}};const Q7=ge,{ExchangeNotAvailable:Z7,ExchangeError:RT,DDoSProtection:J7,BadSymbol:FT,InvalidOrder:Jc,ArgumentsRequired:Qo,AuthenticationError:eU,OrderNotFound:DT,PermissionDenied:vg,InsufficientFunds:Tg,BadRequest:Og,NotSupported:Ig}=de,{TICK_SIZE:tU}=me,xg=Se;var dC=class extends Q7{describe(){return this.deepExtend(super.describe(),{id:"whitebit",name:"WhiteBit",version:"v2",countries:["EE"],rateLimit:500,has:{CORS:void 0,spot:!0,margin:!0,swap:!1,future:!1,option:!1,borrowMargin:!1,cancelAllOrders:!1,cancelOrder:!0,cancelOrders:!1,createDepositAddress:void 0,createLimitOrder:void 0,createMarketOrder:void 0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:void 0,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrderBook:!0,fetchOrderTrades:!0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFees:!0,repayMargin:!1,setLeverage:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/66732963-8eb7dd00-ee66-11e9-849b-10d9282bb9e0.jpg",api:{v1:{public:"https://whitebit.com/api/v1/public",private:"https://whitebit.com/api/v1"},v2:{public:"https://whitebit.com/api/v2/public"},v4:{public:"https://whitebit.com/api/v4/public",private:"https://whitebit.com/api/v4"}},www:"https://www.whitebit.com",doc:"https://github.com/whitebit-exchange/api-docs",fees:"https://whitebit.com/fee-schedule",referral:"https://whitebit.com/referral/d9bdf40e-28f2-4b52-b2f9-cd1415d82963"},api:{web:{get:["v1/healthcheck"]},v1:{public:{get:["markets","tickers","ticker","symbols","depth/result","history","kline"]},private:{post:["account/balance","order/new","order/cancel","orders","account/order_history","account/executed_history","account/executed_history/all","account/order"]}},v2:{public:{get:["markets","ticker","assets","fee","depth/{market}","trades/{market}"]}},v4:{public:{get:["assets","collateral/markets","fee","orderbook/{market}","ticker","trades/{market}","time","ping"]},private:{post:["collateral-account/balance","collateral-account/positions/history","collateral-account/leverage","collateral-account/positions/open","collateral-account/summary","main-account/address","main-account/balance","main-account/create-new-address","main-account/codes","main-account/codes/apply","main-account/codes/my","main-account/codes/history","main-account/fiat-deposit-url","main-account/history","main-account/withdraw","main-account/withdraw-pay","main-account/transfer","trade-account/balance","trade-account/executed-history","trade-account/order","trade-account/order/history","order/collateral/limit","order/collateral/market","order/collateral/trigger_market","order/new","order/market","order/stock_market","order/stop_limit","order/stop_market","order/cancel","orders","profile/websocket_token"]}}},fees:{trading:{tierBased:!1,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0.001")}},options:{fiatCurrencies:["EUR","USD","RUB","UAH"],accountsByType:{main:"main",spot:"spot",margin:"collateral",trade:"spot"}},precisionMode:tU,exceptions:{exact:{"Unauthorized request.":eU,"The market format is invalid.":FT,"Market is not available":FT,"Invalid payload.":Og,"Amount must be greater than 0":Jc,"Not enough balance.":Tg,"The order id field is required.":Jc,"Not enough balance":Tg,"This action is unauthorized.":vg,"This API Key is not authorized to perform this action.":vg,"Unexecuted order was not found.":DT,"The selected from is invalid.":Og,503:Z7,422:DT},broad:{"Given amount is less than min amount":Jc,"Total is less than":Jc,"fee must be no less than":Jc,"Enable your key in API settings":vg,"You don't have such amount for transfer":Tg}}})}async fetchMarkets(e={}){let t=[this.v4PublicGetCollateralMarkets(e),this.v2PublicGetMarkets(e)];t=await Promise.all(t);const s=t[0],i=t[1],n=this.safeValue(i,"result",[]),r=this.safeValue(s,"result",[]),a=[];for(let o=0;o<n.length;o++){const d=n[o],c=this.safeString(d,"name"),u=this.safeString(d,"stock"),h=this.safeString(d,"money"),l=this.safeCurrencyCode(u),p=this.safeCurrencyCode(h),m=l+"/"+p,g=this.safeValue(d,"tradesEnabled"),y=this.inArray(c,r),b={id:c,symbol:m,base:l,quote:p,settle:void 0,baseId:u,quoteId:h,settleId:void 0,type:"spot",spot:!0,margin:y,swap:!1,future:!1,option:!1,active:g,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(d,"makerFee"),maker:this.safeNumber(d,"takerFee"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(d,"stockPrec"))),price:this.parseNumber(this.parsePrecision(this.safeString(d,"moneyPrec")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(d,"minAmount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(d,"minTotal"),max:void 0}},info:d};a.push(b)}return a}async fetchCurrencies(e={}){const t=await this.v4PublicGetAssets(e),s=Object.keys(t),i={};for(let n=0;n<s.length;n++){const r=s[n],a=t[r],o=this.safeValue(a,"can_deposit",!0),d=this.safeValue(a,"can_withdraw",!0),c=o&&d,u=this.safeCurrencyCode(r);i[u]={id:r,code:u,info:a,name:void 0,active:c,deposit:o,withdraw:d,fee:void 0,precision:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.safeNumber(a,"min_withdraw"),max:this.safeNumber(a,"max_withdraw")}}}}return i}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.v4PublicGetFee(t),i=Object.keys(s),n={},r={};for(let a=0;a<i.length;a++){const o=i[a],d=s[o],c=this.safeCurrencyCode(o),u=this.safeValue(d,"withdraw",{});n[c]=this.safeString(u,"fixed");const h=this.safeValue(d,"deposit",{});r[c]=this.safeString(h,"fixed")}return{withdraw:n,deposit:r,info:s}}async fetchTradingFees(e={}){const t=await this.v4PublicGetAssets(e),s={};for(let i=0;i<this.symbols.length;i++){const n=this.symbols[i],r=this.market(n),a=this.safeValue(t,r.baseId,{});let o=this.safeString(a,"maker_fee"),d=this.safeString(a,"taker_fee");o=xg.stringDiv(o,"100"),d=xg.stringDiv(d,"100"),s[n]={info:a,symbol:r.symbol,percentage:!0,tierBased:!1,maker:this.parseNumber(o),taker:this.parseNumber(d)}}return s}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id},n=await this.v1PublicGetTicker(this.extend(i,t)),r=this.safeValue(n,"result",{});return this.parseTicker(r,s)}parseTicker(e,t=void 0){t=this.safeMarket(void 0,t);const s=this.safeString(e,"last_price");return this.safeTicker({symbol:t.symbol,timestamp:void 0,datetime:void 0,high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:s,last:s,previousClose:void 0,change:void 0,percentage:this.safeString(e,"change"),average:void 0,baseVolume:this.safeString2(e,"base_volume","volume"),quoteVolume:this.safeString2(e,"quote_volume","deal"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.v4PublicGetTicker(t),i=Object.keys(s),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeMarket(a),d=this.parseTicker(s[a],o),c=d.symbol;n[c]=d}return this.filterByArray(n,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={market:this.market(e).id};t!==void 0&&(n.depth=t);const r=await this.v4PublicGetOrderbookMarket(this.extend(n,s)),a=this.parseNumber(xg.stringMul(this.safeString(r,"timestamp"),"1000"));return this.parseOrderBook(r,e,a)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={market:n.id},a=await this.v4PublicGetTradesMarket(this.extend(r,i));return this.parseTrades(a,n,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.market=n.id);const a=await this.v4PrivatePostTradeAccountExecutedHistory(this.extend(r,i));if(Array.isArray(a))return this.parseTrades(a,n,t,s);{let o=[];const d=Object.keys(a);for(let u=0;u<d.length;u++){const h=d[u],l=this.safeMarket(h,void 0,"_"),p=this.safeValue(a,h,[]),m=this.parseTrades(p,l,t,s);o=this.arrayConcat(o,m)}o=this.sortBy2(o,"timestamp","id");const c=t===void 0;return this.filterBySinceLimit(o,t,s,"timestamp",c)}}parseTrade(e,t=void 0){t=this.safeMarket(void 0,t);const s=this.safeTimestamp2(e,"time","trade_timestamp"),i=this.safeString2(e,"dealOrderId","orderId"),n=this.safeString(e,"deal"),r=this.safeString(e,"price"),a=this.safeString2(e,"amount","base_volume"),o=this.safeString2(e,"id","tradeID"),d=this.safeString2(e,"type","side"),c=t.symbol,u=this.safeInteger(e,"role");let h;u!==void 0&&(h=u===1?"maker":"taker");let l;const p=this.safeString(e,"fee");return p!==void 0&&(l={cost:p,currency:t.quote}),this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:c,id:o,order:i,type:void 0,takerOrMaker:h,side:d,price:r,amount:a,cost:n,fee:l},t)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={market:r.id,interval:this.timeframes[t]};if(s!==void 0){i===void 0&&(i=1440),i=Math.min(i,1440);const u=parseInt(s/1e3),h=this.parseTimeframe(t),l=this.sum(u,h*i);a.start=u,a.end=l}i!==void 0&&(a.limit=i);const o=await this.v1PublicGetKline(this.extend(a,n)),d=this.safeValue(o,"result",[]);return this.parseOHLCVs(d,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,5)]}async fetchStatus(e={}){const t=await this.v4PublicGetPing(e),s=this.safeString(t,0);return{status:s==="pong"?"ok":s,updated:void 0,eta:void 0,url:void 0,info:t}}async fetchTime(e={}){const t=await this.v4PublicGetTime(e);return this.safeInteger(t,"time")}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const o={market:this.market(e).id,side:s,amount:this.amountToPrecision(e,i)},d=t==="limit",c=t==="market",u=this.safeNumberN(r,["triggerPrice","stopPrice","activation_price"]),h=u!==void 0,l=this.isPostOnly(c,!1,r),[p,m]=this.handleMarginModeAndParams("createOrder",r);l&&(o.postOnly=!0);let g;if(h)o.activation_price=this.priceToPrecision(e,u),d?(g="v4PrivatePostOrderStopLimit",o.price=this.priceToPrecision(e,n)):g="v4PrivatePostOrderStopMarket";else if(d){if(g="v4PrivatePostOrderNew",p!==void 0){if(p!=="cross")throw new Ig(this.id+" createOrder() is only available for cross margin");g="v4PrivatePostOrderCollateralLimit"}o.price=this.priceToPrecision(e,n)}else if(g="v4PrivatePostOrderStockMarket",p!==void 0){if(p!=="cross")throw new Ig(this.id+" createOrder() is only available for cross margin");g="v4PrivatePostOrderCollateralMarket"}r=this.omit(m,["postOnly","triggerPrice","stopPrice"]);const y=await this[g](this.extend(o,r));return this.parseOrder(y)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Qo(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const n={market:this.market(t).id,orderId:parseInt(e)};return await this.v4PrivatePostOrderCancel(this.extend(n,s))}parseBalance(e){const t=Object.keys(e),s={};for(let i=0;i<t.length;i++){const n=t[i],r=e[n],a=this.safeCurrencyCode(n),o=this.account();o.free=this.safeString(r,"available"),o.used=this.safeString(r,"freeze"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.v4PrivatePostTradeAccountBalance(e);return this.parseBalance(t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Qo(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={market:n.id};s!==void 0&&(r.limit=s);const a=await this.v4PrivatePostOrders(this.extend(r,i));return this.parseOrders(a,n,t,s,{status:"open"})}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),e=r.symbol,n.market=r.id),s!==void 0&&(n.limit=s);const a=await this.v4PrivatePostTradeAccountOrderHistory(this.extend(n,i)),o=Object.keys(a);let d=[];for(let c=0;c<o.length;c++){const u=o[c],h=this.safeMarket(u,void 0,"_"),l=a[u];for(let p=0;p<l.length;p++){const m=this.parseOrder(l[p],h);d.push(this.extend(m,{status:"closed"}))}}return d=this.sortBy(d,"timestamp"),d=this.filterBySymbolSinceLimit(d,e,t,s),d}parseOrderType(e){const t={limit:"limit",market:"market","stop market":"market","stop limit":"limit","stock market":"market","margin limit":"limit","margin market":"market"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"market");t=this.safeMarket(s,t,"_");const i=t.symbol,n=this.safeString(e,"side"),r=this.safeString(e,"dealStock"),a=this.safeString(e,"left"),o=this.safeString(e,"clientOrderId"),d=this.safeString(e,"price"),c=this.safeNumber(e,"activation_price"),u=this.safeString2(e,"orderId","id"),h=this.safeString(e,"type");let l=this.safeString(e,"amount");const p=this.safeString(e,"dealMoney");n==="buy"&&(h==="market"||h==="stop market")&&(l=r);const m=this.safeString(e,"dealFee");let g;m!==void 0&&(g={cost:this.parseNumber(m),currency:t.quote});const y=this.safeTimestamp2(e,"ctime","timestamp"),b=this.safeTimestamp(e,"ftime");return this.safeOrder({info:e,id:u,symbol:i,clientOrderId:o,timestamp:y,datetime:this.iso8601(y),lastTradeTimestamp:b,timeInForce:void 0,postOnly:void 0,status:void 0,side:n,price:d,type:this.parseOrderType(h),stopPrice:c,amount:l,filled:r,remaining:a,average:void 0,cost:p,fee:g,trades:void 0},t)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={orderId:parseInt(e)};let a;t!==void 0&&(a=this.market(t),r.market=a.id),i!==void 0&&(r.limit=i);const o=await this.v4PrivatePostTradeAccountOrder(this.extend(r,n)),d=this.safeValue(o,"records",[]);return this.parseTrades(d,a)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const i={ticker:this.currency(e).id};let n="v4PrivatePostMainAccountAddress";if(this.isFiat(e)){n="v4PrivatePostMainAccountFiatDepositUrl";const u=this.safeNumber(t,"provider");if(u===void 0)throw new Qo(this.id+" fetchDepositAddress() requires a provider when the ticker is fiat");i.provider=u;const h=this.safeNumber(t,"amount");if(h===void 0)throw new Qo(this.id+" fetchDepositAddress() requires an amount when the ticker is fiat");if(i.amount=h,this.safeValue(t,"uniqueId")===void 0)throw new Qo(this.id+" fetchDepositAddress() requires an uniqueId when the ticker is fiat")}const r=await this[n](this.extend(i,t)),a=this.safeString(r,"url"),o=this.safeValue(r,"account",{}),d=this.safeString(o,"address",a),c=this.safeString(o,"memo");return this.checkAddress(d),{currency:e,address:d,tag:c,network:void 0,info:r}}async setLeverage(e,t=void 0,s={}){if(await this.loadMarkets(),t!==void 0)throw new Ig(this.id+" setLeverage() does not allow to set per symbol");if(e<1||e>20)throw new Og(this.id+" setLeverage() leverage should be between 1 and 20");const i={leverage:e};return await this.v4PrivatePostCollateralAccountLeverage(this.extend(i,s))}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a=this.safeValue(this.options,"accountsByType"),o=this.safeString(a,s,s),d=this.safeString(a,i,i),c=t.toString(),u={ticker:r.id,amount:this.currencyToPrecision(e,c),from:o,to:d},h=await this.v4PrivatePostMainAccountTransfer(this.extend(u,n)),l=this.parseTransfer(h,r);return this.extend(l,{amount:this.currencyToPrecision(e,c),fromAccount:s,toAccount:i})}parseTransfer(e,t){return{info:e,id:void 0,timestamp:void 0,datetime:void 0,currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0}}async withdraw(e,t,s,i=void 0,n={}){await this.loadMarkets();const r=this.currency(e),a={ticker:r.id,amount:this.currencyToPrecision(e,t),address:s};let o=this.safeValue(n,"uniqueId");if(o===void 0&&(o=this.uuid22()),a.uniqueId=o,i!==void 0&&(a.memo=i),this.isFiat(e)){const c=this.safeValue(n,"provider");if(c===void 0)throw new Qo(this.id+" withdraw() requires a provider when the ticker is fiat");a.provider=c}const d=await this.v4PrivatePostMainAccountWithdraw(this.extend(a,n));return this.extend({id:o},this.parseTransaction(d,r))}parseTransaction(e,t=void 0){t=this.safeCurrency(void 0,t);const s=this.safeString(e,"address"),i=this.safeTimestamp(e,"createdAt"),n=this.safeString(e,"ticker"),r=this.safeString(e,"status"),a=this.safeString(e,"method");return{id:this.safeString(e,"uniqueId"),txid:this.safeString(e,"transactionHash"),timestamp:i,datetime:this.iso8601(i),network:this.safeString(e,"network"),addressFrom:a==="1"?s:void 0,address:s,addressTo:a==="2"?s:void 0,amount:this.safeNumber(e,"amount"),type:a==="1"?"deposit":"withdrawal",currency:this.safeCurrencyCode(n,t),status:this.parseTransactionStatus(r),updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:this.safeString(e,"description"),fee:{cost:this.safeNumber(e,"fee"),currency:this.safeCurrencyCode(n,t)},info:e}}parseTransactionStatus(e){const t={1:"pending",2:"pending",3:"ok",4:"canceled",5:"pending",6:"pending",7:"ok",9:"canceled",10:"pending",11:"pending",12:"pending",13:"pending",14:"pending",15:"pending",16:"pending",17:"pending"};return this.safeString(t,e,e)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();let i;const n={transactionMethod:1,uniqueId:e,limit:1,offset:0};t!==void 0&&(i=this.currency(t),n.ticker=i.id);const r=await this.v4PrivatePostMainAccountHistory(this.extend(n,s)),a=this.safeValue(r,"records",[]),o=this.safeValue(a,0,{});return this.parseTransaction(o,i)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={transactionMethod:1,limit:100,offset:0};e!==void 0&&(n=this.currency(e),r.ticker=n.id),s!==void 0&&(r.limit=s);const a=await this.v4PrivatePostMainAccountHistory(this.extend(r,i)),o=this.safeValue(a,"records",[]);return this.parseTransactions(o,n,t,s)}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r={};let a;t!==void 0&&(a=this.market(t),r.market=a.id);const o=await this.v4PrivatePostCollateralAccountPositionsOpen(this.extend(r,n)),d=this.parseBorrowInterests(o,a);return this.filterByCurrencySinceLimit(d,e,s,i)}parseBorrowInterest(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeSymbol(s,t,"_"),n=this.safeTimestamp(e,"modifyDate");return{symbol:i,marginMode:"cross",currency:"USDT",interest:this.safeNumber(e,"unrealizedFunding"),interestRate:98e-5,amountBorrowed:this.safeNumber(e,"amount"),timestamp:n,datetime:this.iso8601(n),info:e}}isFiat(e){const t=this.safeValue(this.options,"fiatCurrencies",[]);return this.inArray(e,t)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=this.omit(i,this.extractParams(e)),o=this.safeValue(t,0),d=this.safeValue(t,1),c="/"+this.implodeParams(e,i);let u=this.urls.api[o][d]+c;if(d==="public"&&Object.keys(a).length&&(u+="?"+this.urlencode(a)),d==="private"){this.checkRequiredCredentials();const h=this.nonce().toString(),l=this.stringToBinary(this.encode(this.secret)),p="/api/"+o+c;r=this.json(this.extend({request:p,nonce:h},i));const m=this.stringToBase64(r),g=this.hmac(m,l,"sha512");n={"Content-Type":"application/json","X-TXC-APIKEY":this.apiKey,"X-TXC-PAYLOAD":this.decode(m),"X-TXC-SIGNATURE":g}}return{url:u,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(e===418||e===429)throw new J7(this.id+" "+e.toString()+" "+t+" "+r);if(e===404)throw new RT(this.id+" "+e.toString()+" endpoint not found");if(a!==void 0){const c=this.safeString(a,"status"),u=this.safeString(a,"message"),h=this.safeInteger(a,"code"),l=c!==void 0&&c!=="200";if(l||h!==void 0){const p=this.id+" "+r;let m=u;if(l)m=c;else{const g=this.safeValue(a,"errors");if(g!==void 0){const y=Object.keys(g)[0],b=this.safeValue(g,y,[]);m=b.length>0?b[0]:r}}throw this.throwExactlyMatchedException(this.exceptions.exact,m,p),this.throwBroadlyMatchedException(this.exceptions.broad,r,p),new RT(p)}}}};const sU=ge,{ArgumentsRequired:_g,AuthenticationError:HT,RateLimitExceeded:iU,BadRequest:Mn,ExchangeError:GT,InvalidOrder:ua}=de,{TICK_SIZE:nU}=me,an=Se;var rU=class extends sU{describe(){return this.deepExtend(super.describe(),{id:"woo",name:"WOO X",countries:["KY"],rateLimit:100,version:"v1",certified:!1,hostname:"woo.org",has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!1,option:!1,addMargin:!1,borrowMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelWithdraw:!1,createDepositAddress:!1,createMarketOrder:!1,createOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchAccounts:!0,fetchBalance:!0,fetchCanceledOrders:!1,fetchClosedOrder:!1,fetchClosedOrders:!1,fetchCurrencies:!0,fetchDepositAddress:!1,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!1,fetchOpenOrders:!1,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchStatus:!1,fetchTicker:!1,fetchTickers:!1,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:!0,fetchTransfers:!0,fetchWithdrawals:!0,reduceMargin:!1,repayMargin:!0,setLeverage:!0,setMargin:!1,transfer:!0,withdraw:!1},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","12h":"12h","1d":"1d","1w":"1w","1M":"1mon","1y":"1y"},urls:{logo:"https://user-images.githubusercontent.com/1294454/150730761-1a00e5e0-d28c-480f-9e65-089ce3e6ef3b.jpg",api:{pub:"https://api-pub.woo.org",public:"https://api.{hostname}",private:"https://api.{hostname}"},test:{pub:"https://api-pub.staging.woo.org",public:"https://api.staging.woo.org",private:"https://api.staging.woo.org"},www:"https://woo.org/",doc:["https://docs.woo.org/"],fees:["https://support.woo.org/hc/en-001/articles/4404611795353--Trading-Fees"],referral:"https://referral.woo.org/BAJS6oNmZb3vi3RGA"},api:{v1:{pub:{get:{"hist/kline":10}},public:{get:{info:1,"info/{symbol}":1,system_info:1,market_trades:1,token:1,token_network:1,funding_rates:1,"funding_rate/{symbol}":1,funding_rate_history:1,futures:1,"futures/{symbol}":1}},private:{get:{"client/token":1,"order/{oid}":1,"client/order/{client_order_id}":1,orders:1,"orderbook/{symbol}":1,kline:1,"client/trade/{tid}":1,"order/{oid}/trades":1,"client/trades":1,"client/info":60,"asset/deposit":120,"asset/history":60,"sub_account/all":60,"sub_account/assets":60,token_interest:60,"token_interest/{token}":60,"interest/history":60,"interest/repay":60,"funding_fee/history":30,positions:3.33,"position/{symbol}":3.33},post:{order:5,"asset/main_sub_transfer":30,"asset/withdraw":120,"interest/repay":60,"client/account_mode":120,"client/leverage":120},delete:{order:1,"client/order":1,orders:1,"asset/withdraw":120}}},v2:{private:{get:{"client/holding":1}}},v3:{private:{get:{"algo/order/{oid}":1,"algo/orders":1},post:{"algo/order":5},delete:{"algo/order/{oid}":1,"algo/orders/pending":1,"algo/orders/pending/{symbol}":1,"orders/pending":1}}}},fees:{trading:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.0002"),taker:this.parseNumber("0.0005")}},options:{createMarketBuyOrderRequiresPrice:!0,"network-aliases-for-tokens":{HT:"ERC20",OMG:"ERC20",UATOM:"ATOM",ZRX:"ZRX"},defaultNetworkCodeForCurrencies:{},transfer:{fillResponseFromRequest:!0}},commonCurrencies:{},exceptions:{exact:{"-1000":GT,"-1001":HT,"-1002":HT,"-1003":iU,"-1004":Mn,"-1005":Mn,"-1006":Mn,"-1007":Mn,"-1008":ua,"-1009":Mn,"-1011":GT,"-1012":Mn,"-1101":ua,"-1102":ua,"-1103":ua,"-1104":ua,"-1105":ua},broad:{"symbol must not be blank":Mn,"The token is not supported":Mn,"Your order and symbol are not valid or already canceled":Mn,"Insufficient WOO. Please enable margin trading for leverage trading":Mn}},precisionMode:nU})}async fetchMarkets(e={}){const t=await this.v1PublicGetInfo(e),s=[],i=this.safeValue(t,"rows",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"symbol"),o=a.split("_");let d=this.safeStringLower(o,0);const c=d==="spot",u=d==="perp",h=this.safeString(o,1),l=this.safeString(o,2),p=this.safeCurrencyCode(h),m=this.safeCurrencyCode(l);let g,y,b=p+"/"+m,w,k;u&&(g=this.safeString(o,2),y=this.safeCurrencyCode(g),b=p+"/"+m+":"+y,w=this.parseNumber("1"),d="swap",k=!0),s.push({id:a,symbol:b,base:p,quote:m,settle:y,baseId:h,quoteId:l,settleId:g,type:d,spot:c,margin:!0,swap:u,future:!1,option:!1,active:void 0,contract:u,linear:k,inverse:void 0,contractSize:w,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(r,"base_tick"),price:this.safeNumber(r,"quote_tick")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"base_min"),max:this.safeNumber(r,"base_max")},price:{min:this.safeNumber(r,"quote_min"),max:this.safeNumber(r,"quote_max")},cost:{min:this.safeNumber(r,"min_notional"),max:void 0}},info:r})}return s}async fetchTrades(e,t=void 0,s=void 0,i={}){if(e===void 0)throw new _g(this.id+" fetchTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r={symbol:n.id};s!==void 0&&(r.limit=s);const a=await this.v1PublicGetMarketTrades(this.extend(r,i)),o=this.safeValue(a,"rows",{});return this.parseTrades(o,n,t,s)}parseTrade(e,t=void 0){const s="id"in e,i=this.safeTimestamp(e,"executed_timestamp"),n=this.safeString(e,"symbol");t=this.safeMarket(n,t);const r=t.symbol,a=this.safeString(e,"executed_price"),o=this.safeString(e,"executed_quantity"),d=this.safeString(e,"order_id"),c=this.parseTokenAndFeeTemp(e,"fee_asset","fee"),u=an.stringMul(a,o),h=this.safeStringLower(e,"side"),l=this.safeString(e,"id");let p;return s&&(p=this.safeString(e,"is_maker")==="1"?"maker":"taker"),this.safeTrade({id:l,timestamp:i,datetime:this.iso8601(i),symbol:r,side:h,price:a,amount:o,cost:u,order:d,takerOrMaker:p,type:void 0,fee:c,info:e},t)}parseTokenAndFeeTemp(e,t,s){const i=this.safeString(e,s);let n;if(i!==void 0){const r=this.safeString(e,t),a=this.safeCurrencyCode(r);n={cost:i,currency:a}}return n}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.v1PrivateGetClientInfo(e),s=this.safeValue(t,"application",{}),i=this.safeString(s,"maker_fee_rate"),n=this.safeString(s,"taker_fee_rate"),r={};for(let a=0;a<this.symbols.length;a++){const o=this.symbols[a];r[o]={info:t,symbol:o,maker:this.parseNumber(an.stringDiv(i,"10000")),taker:this.parseNumber(an.stringDiv(n,"10000")),percentage:!0,tierBased:!0}}return r}async fetchCurrencies(e={}){const t={},s=await this.v1PublicGetToken(e),i=this.safeValue(s,"rows",[]),n=this.groupBy(i,"balance_token"),r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=n[o],c=this.safeCurrencyCode(o);let u,h;const l={};for(let p=0;p<d.length;p++){const m=d[p];u=this.safeString(m,"fullname");const g=this.safeString(m,"token"),b=g.split("_")[0],w=this.parsePrecision(this.safeString(m,"decimals"));w!==void 0&&(h=h===void 0?w:an.stringMin(w,h)),l[b]={id:g,network:b,limits:{withdraw:{min:void 0,max:void 0},deposit:{min:void 0,max:void 0}},active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,precision:this.parseNumber(w),info:m}}t[c]={id:o,name:u,code:c,precision:this.parseNumber(h),active:void 0,fee:void 0,networks:l,limits:{deposit:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}},info:d}}return t}async createOrder(e,t,s,i,n=void 0,r={}){const a=this.safeValue(r,"reduceOnly"),o=t.toUpperCase();if(a!==void 0&&o!=="LIMIT")throw new ua(this.id+" createOrder() only support reduceOnly for limit orders");await this.loadMarkets();const d=this.market(e),c=s.toUpperCase(),u={symbol:d.id,order_type:o,side:c};if(a&&(u.reduce_only=a),n!==void 0&&(u.order_price=this.priceToPrecision(e,n)),o==="MARKET")if(c==="BUY"){const p=this.safeNumber(r,"cost");if(this.safeValue(this.options,"createMarketBuyOrderRequiresPrice",!0))if(p===void 0){if(n===void 0)throw new ua(this.id+" createOrder() requires the price argument for market buy orders to calculate total order cost. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or alternatively, supply the total cost value in the 'order_amount' in  exchange-specific parameters");{const m=this.numberToString(i),g=this.numberToString(n),y=an.stringMul(m,g);u.order_amount=this.costToPrecision(e,y)}}else u.order_amount=this.costToPrecision(e,p)}else u.order_quantity=this.amountToPrecision(e,i);else u.order_quantity=this.amountToPrecision(e,i);const h=this.safeString2(r,"clOrdID","clientOrderId");h!==void 0&&(u.client_order_id=h),r=this.omit(r,["clOrdID","clientOrderId"]);const l=await this.v1PrivatePostOrder(this.extend(u,r));return this.extend(this.parseOrder(l,d),{type:t})}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new _g(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i={},n=this.safeString2(s,"clOrdID","clientOrderId"),r=this.safeString2(s,"client_order_id",n),a=r!==void 0;a?(i.client_order_id=r,s=this.omit(s,["clOrdID","clientOrderId","client_order_id"])):i.order_id=e;let o;t!==void 0&&(o=this.market(t)),i.symbol=o.id;const d=await this.v1PrivateDeleteOrder(this.extend(i,s)),c={symbol:t};return a?c.client_order_id=r:c.id=e,this.extend(this.parseOrder(d),c)}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new _g(this.id+" canelOrders() requires a symbol argument");await this.loadMarkets();const i={symbol:this.market(e).id};return await this.v1PrivateDeleteOrders(this.extend(i,t))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=t!==void 0?this.market(t):void 0,n={},r=this.safeString2(s,"clOrdID","clientOrderId");let a;r?(a="v1PrivateGetClientOrderClientOrderId",n.client_order_id=r):(a="v1PrivateGetOrderOid",n.oid=e);const o=await this[a](this.extend(n,s));return this.parseOrder(o,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),t!==void 0&&(n.start_t=t);const a=await this.v1PrivateGetOrders(this.extend(n,i)),o=this.safeValue(a,"rows");return this.parseOrders(o,r,t,s,i)}parseOrder(e,t=void 0){const s=this.safeTimestamp2(e,"timestamp","created_time"),i=this.safeString(e,"order_id"),n=this.safeString(e,"client_order_id"),r=this.safeString(e,"symbol");t=this.safeMarket(r,t);const a=t.symbol,o=this.safeString2(e,"order_price","price"),d=this.safeString2(e,"order_quantity","quantity"),c=this.safeString2(e,"order_amount","amount"),u=this.safeStringLower2(e,"order_type","type"),h=this.safeValue(e,"status"),l=this.safeStringLower(e,"side"),p=this.safeValue(e,"executed"),m=an.stringSub(c,p),g=this.safeValue(e,"total_fee"),y=this.safeString(e,"fee_asset"),b=this.safeValue(e,"Transactions");return this.safeOrder({id:i,clientOrderId:n,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,status:this.parseOrderStatus(h),symbol:a,type:u,timeInForce:void 0,postOnly:void 0,reduceOnly:this.safeValue(e,"reduce_only"),side:l,price:o,stopPrice:void 0,average:void 0,amount:d,filled:p,remaining:m,cost:c,trades:b,fee:{cost:g,currency:y},info:e},t)}parseOrderStatus(e){if(e!==void 0){const t={NEW:"open",FILLED:"closed",CANCEL_SENT:"canceled",CANCEL_ALL_SENT:"canceled",CANCELLED:"canceled",PARTIAL_FILLED:"open",REJECTED:"rejected",INCOMPLETE:"open",COMPLETED:"closed"};return this.safeString(t,e,e)}return e}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n={symbol:this.market(e).id};t!==void 0&&(t=Math.min(t,1e3),n.max_level=t);const r=await this.v1PrivateGetOrderbookSymbol(this.extend(n,s)),a=this.safeInteger(r,"timestamp");return this.parseOrderBook(r,e,a,"bids","asks","price","quantity")}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,type:this.timeframes[t]};i!==void 0&&(a.limit=Math.min(i,1e3));const o=await this.v1PrivateGetKline(this.extend(a,n)),d=this.safeValue(o,"rows",[]);return this.parseOHLCVs(d,r,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"start_timestamp"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();let r;t!==void 0&&(r=this.market(t));const a={oid:e},o=await this.v1PrivateGetOrderOidTrades(this.extend(a,n)),d=this.safeValue(o,"rows",[]);return this.parseTrades(d,r,s,i,n)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),t!==void 0&&(n.start_t=t);const a=await this.v1PrivateGetClientTrades(this.extend(n,i)),o=this.safeValue(a,"rows",[]);return this.parseTrades(o,r,t,s,i)}async fetchAccounts(e={}){const t=await this.v1PrivateGetSubAccountAssets(e),s=this.safeValue(t,"rows",[]);return this.parseAccounts(s,e)}parseAccount(e){const t=this.safeString(e,"account");return{info:e,id:this.safeString(e,"application_id"),name:t,code:void 0,type:t==="Main"?"main":"subaccount"}}async fetchBalance(e={}){await this.loadMarkets();const t=await this.v2PrivateGetClientHolding(e);return this.parseBalance(t)}parseBalance(e){const t={info:e},s=this.safeValue(e,"holding",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeCurrencyCode(this.safeString(n,"token")),a=this.account();a.total=this.safeString(n,"holding");const o=this.safeString(n,"outstanding_holding");a.used=an.stringNeg(o),t[r]=a}return this.safeBalance(t)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i=this.defaultNetworkCodeForCurrency(e),n=this.safeString(t,"network",i);t=this.omit(t,"network");const a={token:n+"_"+s.code},o=await this.v1PrivateGetAssetDeposit(this.extend(a,t)),d=this.safeString(o,"extra"),c=this.safeString(o,"address");return this.checkAddress(c),{currency:e,address:c,tag:d,network:n,info:o}}async getAssetHistoryRows(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.balance_token=r.id),t!==void 0&&(n.start_t=t),s!==void 0&&(n.pageSize=s);const a=this.safeString(i,"type");i=this.omit(i,"type"),a!==void 0&&(n.type=a);const o=await this.v1PrivateGetAssetHistory(this.extend(n,i));return[r,this.safeValue(o,"rows",{})]}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){const[n,r]=await this.getAssetHistoryRows(e,t,s,i);return this.parseLedger(r,n,t,s,i)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"token"),n=this.getCurrencyFromChaincode(s,t).code,r=this.safeNumber(e,"amount"),o=this.safeString(e,"token_side")==="DEPOSIT"?"in":"out",d=this.safeTimestamp(e,"created_time"),c=this.parseTokenAndFeeTemp(e,"fee_token","fee_amount");return{id:this.safeString(e,"id"),currency:n,account:this.safeString(e,"account"),referenceAccount:void 0,referenceId:this.safeString(e,"tx_id"),status:this.parseTransactionStatus(this.safeString(e,"status")),amount:r,before:void 0,after:void 0,fee:c,direction:o,timestamp:d,datetime:this.iso8601(d),type:this.parseLedgerEntryType(this.safeString(e,"type")),info:e}}parseLedgerEntryType(e){const t={BALANCE:"transaction",COLLATERAL:"transfer"};return this.safeString(t,e,e)}getCurrencyFromChaincode(e,t){if(t!==void 0)return t;{const s=e.split("_"),i=s.length,n=this.safeString(s,0);let r=this.safeString(s,1,n);i>2&&(r+="_"+this.safeString(s,2)),t=this.safeCurrency(r)}return t}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){const n={token_side:"DEPOSIT"};return await this.fetchTransactions(e,t,s,this.extend(n,i))}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const n={token_side:"WITHDRAW"};return await this.fetchTransactions(e,t,s,this.extend(n,i))}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){const n={type:"BALANCE"},[r,a]=await this.getAssetHistoryRows(e,t,s,this.extend(n,i));return this.parseTransactions(a,r,t,s,i)}parseTransaction(e,t=void 0){const s=this.safeString(e,"token"),n=this.getCurrencyFromChaincode(s,t).code;let r=this.safeStringLower(e,"token_side");r==="withdraw"&&(r="withdrawal");const a=this.parseTokenAndFeeTemp(e,"fee_token","fee_amount");a.rate=void 0;const o=this.safeString(e,"target_address"),d=this.safeString(e,"source_address"),c=this.safeTimestamp(e,"created_time");return{id:this.safeString(e,"id"),txid:this.safeString(e,"tx_id"),timestamp:c,datetime:this.iso8601(c),address:void 0,addressFrom:d,addressTo:o,tag:this.safeString(e,"extra"),type:r,amount:this.safeNumber(e,"amount"),currency:n,status:this.parseTransactionStatus(this.safeString(e,"status")),updated:this.safeTimestamp(e,"updated_time"),fee:a,info:e}}parseTransactionStatus(e){const t={NEW:"pending",CONFIRMING:"pending",PROCESSING:"pending",COMPLETED:"ok",CANCELED:"canceled"};return this.safeString(t,e,e)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const r=this.currency(e),a={token:r.id,amount:this.parseNumber(t),from_application_id:s,to_application_id:i},o=await this.v1PrivatePostAssetMainSubTransfer(this.extend(a,n)),d=this.parseTransfer(o,r),c=this.safeValue(this.options,"transfer",{});return this.safeValue(c,"fillResponseFromRequest",!0)&&(d.amount=t,d.fromAccount=s,d.toAccount=i),d}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){const n={type:"COLLATERAL"},[r,a]=await this.getAssetHistoryRows(e,t,s,this.extend(n,i));return this.parseTransfers(a,r,t,s,i)}parseTransfer(e,t=void 0){const s=this.safeString(e,"token"),n=this.getCurrencyFromChaincode(s,t).code;let r=this.safeStringLower(e,"token_side");r==="withdraw"&&(r="withdrawal");let a,o;r==="withdraw"?(a=void 0,o="spot"):r==="deposit"&&(a="spot",o=void 0);const d=this.safeTimestamp(e,"created_time"),c=this.safeValue(e,"success");let u;return c!==void 0&&(u=c?"ok":"failed"),{id:this.safeString(e,"id"),timestamp:d,datetime:this.iso8601(d),currency:n,amount:this.safeNumber(e,"amount"),fromAccount:a,toAccount:o,status:this.parseTransferStatus(this.safeString(e,"status",u)),info:e}}parseTransferStatus(e){const t={NEW:"pending",CONFIRMING:"pending",PROCESSING:"pending",COMPLETED:"ok",CANCELED:"canceled"};return this.safeString(t,e,e)}async repayMargin(e,t,s=void 0,i={}){await this.loadMarkets();let n;s!==void 0&&(n=this.market(s),s=n.symbol);const r=this.currency(e),a={token:r.id,amount:this.currencyToPrecision(e,t)},o=await this.v1PrivatePostInterestRepay(this.extend(a,i)),d=this.parseMarginLoan(o,r);return this.extend(d,{amount:t,symbol:s})}parseMarginLoan(e,t=void 0){return{id:void 0,currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const a=t[0],o=t[1];let d=this.implodeHostname(this.urls.api[o]);if(d+="/"+a+"/",e=this.implodeParams(e,i),i=this.omit(i,this.extractParams(e)),i=this.keysort(i),o==="public")d+=o+"/"+e,Object.keys(i).length&&(d+="?"+this.urlencode(i));else{this.checkRequiredCredentials(),d+=e;const c=this.nonce().toString();let u=this.urlencode(i);a==="v3"&&s==="POST"?(r=u,u=c+s+"/"+a+"/"+e+r):(s==="POST"||s==="DELETE"?r=u:d+="?"+u,u+="|"+c);const h=this.hmac(this.encode(u),this.encode(this.secret),"sha256");n={"x-api-key":this.apiKey,"x-api-signature":h,"x-api-timestamp":c,"Content-Type":"application/x-www-form-urlencoded"}}return{url:d,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(!a)return;const c=this.safeValue(a,"success"),u=this.safeString(a,"code");if(!c){const h=this.id+" "+this.json(a);this.throwBroadlyMatchedException(this.exceptions.broad,r,h),this.throwExactlyMatchedException(this.exceptions.exact,u,h)}}parseIncome(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeNumber(e,"funding_fee"),r=this.safeCurrencyCode("USD"),a=this.safeString(e,"id"),o=this.safeTimestamp(e,"updated_time"),d=this.safe_number(e,"funding_rate");return{info:e,symbol:i,code:r,timestamp:o,datetime:this.iso8601(o),id:a,amount:n,rate:d}}parseIncomes(e,t=void 0,s=void 0,i=void 0){const n=[];for(let a=0;a<e.length;a++){const o=e[a],d=this.parseIncome(o,t);n.push(d)}const r=this.sortBy(n,"timestamp");return this.filterBySinceLimit(r,s,i,"timestamp")}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.market(e),n.symbol=r.id),t!==void 0&&(n.start_t=t);const a=await this.v1PrivateGetFundingFeeHistory(this.extend(n,i)),o=this.safeValue(a,"rows",[]);return this.parseIncomes(o,r,t,s)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"symbol");t=this.market(s);const i=this.safeInteger(e,"next_funding_time"),n=this.safeInteger(e,"est_funding_rate_timestamp"),r=this.safeInteger(e,"last_funding_rate_timestamp");return{info:e,symbol:t.symbol,markPrice:void 0,indexPrice:void 0,interestRate:this.parseNumber("0"),estimatedSettlePrice:void 0,timestamp:n,datetime:this.iso8601(n),fundingRate:this.safeNumber(e,"est_funding_rate"),fundingTimestamp:i,fundingDatetime:this.iso8601(i),nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:this.safeNumber(e,"last_funding_rate"),previousFundingTimestamp:r,previousFundingDatetime:this.iso8601(r)}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.v1PublicGetFundingRateSymbol(this.extend(i,t));return this.parseFundingRate(n,s)}async fetchFundingRates(e,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.v1PublicGetFundingRates(t),i=this.safeValue(s,"rows",{}),n=this.parseFundingRates(i);return this.filterByArray(n,"symbol",e)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};if(e!==void 0){const c=this.market(e);e=c.symbol,n.symbol=c.id}t!==void 0&&(n.start_t=parseInt(t/1e3));const r=await this.v1PublicGetFundingRateHistory(this.extend(n,i)),a=this.safeValue(r,"rows"),o=[];for(let c=0;c<a.length;c++){const u=a[c],h=this.safeString(u,"symbol"),l=this.safeInteger(u,"funding_rate_timestamp");o.push({info:u,symbol:this.safeSymbol(h),fundingRate:this.safeNumber(u,"funding_rate"),timestamp:l,datetime:this.iso8601(l)})}const d=this.sortBy(o,"timestamp");return this.filterBySymbolSinceLimit(d,e,t,s)}async fetchLeverage(e,t={}){await this.loadMarkets();const s=await this.v1PrivateGetClientInfo(t),i=this.safeValue(s,"application"),n=this.safeNumber(i,"leverage");return{info:s,leverage:n}}async setLeverage(e,t=void 0,s={}){if(await this.loadMarkets(),e<1||e>20)throw new Mn(this.id+" leverage should be between 1 and 20");const i={leverage:e};return await this.v1PrivatePostClientLeverage(this.extend(i,s))}async fetchPosition(e=void 0,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},n=await this.v1PrivateGetPositionSymbol(this.extend(i,t));return this.parsePosition(n,s)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.v1PrivateGetPositions(t),i=this.safeValue(s,"positions",[]);return this.parsePositions(i,e)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);let i=this.safeString(e,"holding"),n;an.stringGt(i,"0")?n="long":n="short";const r=this.safeString(t,"contractSize"),a=this.safeString(e,"mark_price"),o=this.safeTimestamp(e,"timestamp"),d=this.safeString(e,"average_open_price"),c=an.stringSub(a,d),u=an.stringMul(c,i);i=an.stringAbs(i);const h=an.stringMul(i,a);return{info:e,id:void 0,symbol:this.safeString(t,"symbol"),timestamp:o,datetime:this.iso8601(o),initialMargin:void 0,initialMarginPercentage:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,entryPrice:this.parseNumber(d),notional:this.parseNumber(h),leverage:void 0,unrealizedPnl:this.parseNumber(u),contracts:this.parseNumber(i),contractSize:this.parseNumber(r),marginRatio:void 0,liquidationPrice:this.safeNumber(e,"est_liq_price"),markPrice:this.parseNumber(a),collateral:void 0,marginMode:"cross",marginType:void 0,side:n,percentage:void 0}}defaultNetworkCodeForCurrency(e){const s=this.currency(e).networks,i=Object.keys(s);for(let n=0;n<i.length;n++){const r=i[n];if(r==="ETH")return r}return this.safeValue(i,0)}};const aU=ge,{ExchangeError:Zo,ArgumentsRequired:Cg,ExchangeNotAvailable:Mg,InvalidNonce:oU,InsufficientFunds:Pg,OrderNotFound:dU,DDoSProtection:cU,InvalidOrder:Pn,AuthenticationError:Oh,RateLimitExceeded:uU}=de,{TICK_SIZE:fU}=me,Ag=Se;var hU=class extends aU{describe(){return this.deepExtend(super.describe(),{id:"yobit",name:"YoBit",countries:["RU"],rateLimit:2e3,version:"3",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createDepositAddress:!0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchDepositAddress:!0,fetchDeposits:void 0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:void 0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawals:void 0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766910-cdcbfdae-5eea-11e7-9859-03fea873272d.jpg",api:{public:"https://yobit.net/api",private:"https://yobit.net/tapi"},www:"https://www.yobit.net",doc:"https://www.yobit.net/en/api/",fees:"https://www.yobit.net/en/fees/"},api:{public:{get:{"depth/{pair}":1,info:1,"ticker/{pair}":1,"trades/{pair}":1}},private:{post:{ActiveOrders:1,CancelOrder:1,GetDepositAddress:1,getInfo:1,OrderInfo:1,Trade:1,TradeHistory:1,WithdrawCoinsToAddress:1}}},fees:{trading:{maker:.002,taker:.002},funding:{withdraw:{}}},commonCurrencies:{AIR:"AirCoin",ANI:"ANICoin",ANT:"AntsCoin",ATMCHA:"ATM",ASN:"Ascension",AST:"Astral",ATM:"Autumncoin",AUR:"AuroraCoin",BAB:"Babel",BAN:"BANcoin",BCC:"BCH",BCS:"BitcoinStake",BITS:"Bitstar",BLN:"Bulleon",BNS:"Benefit Bonus Coin",BOT:"BOTcoin",BON:"BONES",BPC:"BitcoinPremium",BST:"BitStone",BTS:"Bitshares2",CAT:"BitClave",CBC:"CryptoBossCoin",CMT:"CometCoin",COIN:"Coin.com",COV:"Coven Coin",COVX:"COV",CPC:"Capricoin",CREDIT:"Creditbit",CS:"CryptoSpots",DCT:"Discount",DFT:"DraftCoin",DGD:"DarkGoldCoin",DIRT:"DIRTY",DROP:"FaucetCoin",DSH:"DASH",EGC:"EverGreenCoin",EGG:"EggCoin",EKO:"EkoCoin",ENTER:"ENTRC",EPC:"ExperienceCoin",ESC:"EdwardSnowden",EUROPE:"EUROP",EXT:"LifeExtension",FUND:"FUNDChains",FUNK:"FUNKCoin",FX:"FCoin",GCC:"GlobalCryptocurrency",GEN:"Genstake",GENE:"Genesiscoin",GMR:"Gimmer",GOLD:"GoldMint",GOT:"Giotto Coin",GSX:"GlowShares",GT:"GTcoin",HTML5:"HTML",HYPERX:"HYPER",ICN:"iCoin",INSANE:"INSN",JNT:"JointCoin",JPC:"JupiterCoin",JWL:"Jewels",KNC:"KingN Coin",LBTCX:"LiteBitcoin",LIZI:"LiZi",LOC:"LocoCoin",LOCX:"LOC",LUNYR:"LUN",LUN:"LunarCoin",LUNA:"Luna Coin",MASK:"Yobit MASK",MDT:"Midnight",MEME:"Memez Token",MIS:"MIScoin",MM:"MasterMint",NAV:"NavajoCoin",NBT:"NiceBytes",OMG:"OMGame",ONX:"Onix",PAC:"$PAC",PLAY:"PlayCoin",PIVX:"Darknet",PRS:"PRE",PURE:"PurePOS",PUTIN:"PutinCoin",SPACE:"Spacecoin",STK:"StakeCoin",SUB:"Subscriptio",PAY:"EPAY",PLC:"Platin Coin",RAI:"RaiderCoin",RCN:"RCoin",REP:"Republicoin",RUR:"RUB",SBTC:"Super Bitcoin",SMC:"SmartCoin",SOLO:"SoloCoin",SOUL:"SoulCoin",STAR:"StarCoin",SUPER:"SuperCoin",TNS:"Transcodium",TTC:"TittieCoin",UNI:"Universe",UST:"Uservice",VOL:"VolumeCoin",XIN:"XINCoin",XMT:"SummitCoin",XRA:"Ratecoin"},options:{fetchOrdersRequiresSymbol:!0,fetchTickersMaxLength:512,networks:{ETH:"ERC20",TRX:"TRC20",BSC:"BEP20"}},precisionMode:fU,exceptions:{exact:{803:Pn,804:Pn,805:Pn,806:Pn,807:Pn,831:Pg,832:Pg,833:dU},broad:{"Invalid pair name":Zo,"invalid api key":Oh,"invalid sign":Oh,"api key dont have trade permission":Oh,"invalid parameter":Pn,"invalid order":Pn,"The given order has already been cancelled":Pn,"Requests too often":cU,"not available":Mg,"data unavailable":Mg,"external service unavailable":Mg,"Total transaction amount":Pn,"The given order has already been closed and cannot be cancelled":Pn,"Insufficient funds":Pg,"invalid key":Oh,"invalid nonce":oU,"Total order amount is less than minimal amount":Pn,"Rate Limited":uU}},orders:{}})}parseBalance(e){const t=this.safeValue(e,"return",{}),s=this.safeInteger(t,"server_time"),i={info:e,timestamp:s,datetime:this.iso8601(s)},n=this.safeValue(t,"funds",{}),r=this.safeValue(t,"funds_incl_orders",{}),a=Object.keys(this.extend(n,r));for(let o=0;o<a.length;o++){const d=a[o],c=this.safeCurrencyCode(d),u=this.account();u.free=this.safeString(n,d),u.total=this.safeString(r,d),i[c]=u}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetInfo(e);return this.parseBalance(t)}async fetchMarkets(e={}){const t=await this.publicGetInfo(e),s=this.safeValue(t,"pairs",{}),i=Object.keys(s),n=[];for(let r=0;r<i.length;r++){const a=i[r],o=s[a],[d,c]=a.split("_");let u=d.toUpperCase(),h=c.toUpperCase();u=this.safeCurrencyCode(u),h=this.safeCurrencyCode(h);const l=this.safeInteger(o,"hidden");let p=this.safeString(o,"fee");p=Ag.stringDiv(p,"100"),n.push({id:a,symbol:u+"/"+h,base:u,quote:h,settle:void 0,baseId:d,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:l===0,contract:!1,linear:void 0,inverse:void 0,taker:this.parseNumber(p),maker:this.parseNumber(p),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(o,"decimal_places"))),price:this.parseNumber(this.parsePrecision(this.safeString(o,"decimal_places")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(o,"min_amount"),max:this.safeNumber(o,"max_amount")},price:{min:this.safeNumber(o,"min_price"),max:this.safeNumber(o,"max_price")},cost:{min:this.safeNumber(o,"min_total"),max:void 0}},info:o})}return n}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id};t!==void 0&&(n.limit=t);const r=await this.publicGetDepthPair(this.extend(n,s));if(!(i.id in r))throw new Zo(this.id+" "+i.symbol+" order book is empty or not available");const o=r[i.id];return this.parseOrderBook(o,e)}async fetchOrderBooks(e=void 0,t=void 0,s={}){await this.loadMarkets();let i;if(e===void 0){if(i=this.ids.join("-"),i.length>2048){const o=this.ids.length;throw new Zo(this.id+" fetchOrderBooks() has "+o.toString()+" symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchOrderBooks")}}else i=this.marketIds(e),i=i.join("-");const n={pair:i};t!==void 0&&(n.limit=t);const r=await this.publicGetDepthPair(this.extend(n,s)),a={};i=Object.keys(r);for(let o=0;o<i.length;o++){const d=i[o],c=this.safeSymbol(d);a[c]=this.parseOrderBook(r[d],c)}return a}parseTicker(e,t=void 0){const s=this.safeTimestamp(e,"updated"),i=this.safeString(e,"last");return this.safeTicker({symbol:this.safeSymbol(void 0,t),timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:i,last:i,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeString(e,"avg"),baseVolume:this.safeString(e,"vol_cur"),quoteVolume:this.safeString(e,"vol"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s=this.ids;if(e===void 0){const o=s.length;s=s.join("-");const d=this.safeInteger(this.options,"fetchTickersMaxLength",2048);if(s.length>this.options.fetchTickersMaxLength)throw new Cg(this.id+" fetchTickers() has "+o.toString()+" markets exceeding max URL length for this endpoint ("+d.toString()+" characters), please, specify a list of symbols of interest in the first argument to fetchTickers")}else s=this.marketIds(e),s=s.join("-");const i={pair:s},n=await this.publicGetTickerPair(this.extend(i,t)),r={},a=Object.keys(n);for(let o=0;o<a.length;o++){const d=a[o],c=n[d],u=this.safeMarket(d),h=u.symbol;r[h]=this.parseTicker(c,u)}return this.filterByArray(r,"symbol",e)}async fetchTicker(e,t={}){return(await this.fetchTickers([e],t))[e]}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"timestamp");let i=this.safeString(e,"type");i==="ask"?i="sell":i==="bid"&&(i="buy");const n=this.safeString2(e,"rate","price"),r=this.safeString2(e,"trade_id","tid"),a=this.safeString(e,"order_id"),o=this.safeString(e,"pair"),d=this.safeSymbol(o,t),c=this.safeString(e,"amount"),u=this.parseNumber(n),h=this.parseNumber(c),l="limit";let p;const m=this.safeNumber(e,"commission");if(m!==void 0){const y=this.safeString(e,"commissionCurrency"),b=this.safeCurrencyCode(y);p={cost:m,currency:b}}if(this.safeValue(e,"is_your_order")!==void 0&&p===void 0){const y=this.calculateFee(d,l,i,h,u,"taker");p={currency:this.safeString(y,"currency"),cost:this.safeString(y,"cost"),rate:this.safeString(y,"rate")}}return this.safeTrade({id:r,order:a,timestamp:s,datetime:this.iso8601(s),symbol:d,type:l,side:i,takerOrMaker:void 0,price:n,amount:c,cost:void 0,fee:p,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id};s!==void 0&&(r.limit=s);const a=await this.publicGetTradesPair(this.extend(r,i));if(Array.isArray(a)&&a.length===0)return[];const o=this.safeValue(a,n.id,[]);return this.parseTrades(o,n,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetInfo(e),s=this.safeValue(t,"pairs",{}),i=Object.keys(s),n={};for(let r=0;r<i.length;r++){const a=i[r],o=this.safeValue(s,a,{}),d=this.safeSymbol(a,void 0,"_"),c=this.safeString(o,"fee_buyer"),u=this.safeString(o,"fee_seller"),h=this.parseNumber(Ag.stringDiv(c,"100")),l=this.parseNumber(Ag.stringDiv(u,"100"));n[d]={info:o,symbol:d,taker:h,maker:l,percentage:!0,tierBased:!1}}return n}async createOrder(e,t,s,i,n=void 0,r={}){if(t==="market")throw new Zo(this.id+" createOrder() allows limit orders only");await this.loadMarkets();const a=this.market(e),o={pair:a.id,type:s,amount:this.amountToPrecision(e,i),rate:this.priceToPrecision(e,n)},d=await this.privatePostTrade(this.extend(o,r)),c=this.safeValue(d,"return");return this.parseOrder(c,a)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:parseInt(e)},n=await this.privatePostCancelOrder(this.extend(i,s)),r=this.safeValue(n,"return",{});return this.parseOrder(r)}parseOrderStatus(e){const t={0:"open",1:"closed",2:"canceled",3:"open"};return this.safeString(t,e,e)}parseOrder(e,t=void 0){let s=this.safeString2(e,"id","order_id"),i=this.parseOrderStatus(this.safeString(e,"status","open"));s==="0"&&(s=this.safeString(e,"init_order_id"),i="closed");const n=this.safeTimestamp2(e,"timestamp_created","server_time"),r=this.safeString(e,"pair"),a=this.safeSymbol(r,t),o=this.safeString(e,"start_amount"),d=this.safeString2(e,"amount","remains"),c=this.safeString(e,"received","0.0"),u=this.safeString(e,"rate"),h=void 0,l="limit",p=this.safeString(e,"type");return this.safeOrder({info:e,id:s,clientOrderId:void 0,symbol:a,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,type:l,timeInForce:void 0,postOnly:void 0,side:p,price:u,stopPrice:void 0,cost:void 0,amount:o,remaining:d,filled:c,status:i,fee:h,average:void 0,trades:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:parseInt(e)},n=await this.privatePostOrderInfo(this.extend(i,s));e=e.toString();const r=this.safeValue(n,"return",{});return this.parseOrder(this.extend({id:e},r[e]))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Cg(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n={},r=void 0;if(e!==void 0){const d=this.market(e);n.pair=d.id}const a=await this.privatePostActiveOrders(this.extend(n,i)),o=this.safeValue(a,"return",{});return this.parseOrders(o,r,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Cg(this.id+" fetchMyTrades() requires a `symbol` argument");await this.loadMarkets();const n=this.market(e),r={pair:n.id};s!==void 0&&(r.count=parseInt(s)),t!==void 0&&(r.since=parseInt(t/1e3));const a=await this.privatePostTradeHistory(this.extend(r,i)),o=this.safeValue(a,"return",{}),d=Object.keys(o),c=[];for(let u=0;u<d.length;u++){const h=d[u],l=this.parseTrade(this.extend(o[h],{trade_id:h}),n);c.push(l)}return this.filterBySymbolSinceLimit(c,n.symbol,t,s)}async createDepositAddress(e,t={}){const s={need_new:1},i=await this.fetchDepositAddress(e,this.extend(s,t)),n=this.safeString(i,"address");return this.checkAddress(n),{currency:e,address:n,tag:void 0,info:i.info}}async fetchDepositAddress(e,t={}){await this.loadMarkets();let i=this.currency(e).id;const n=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper(t,"network");r=this.safeString(n,r,r),r!==void 0&&(r!=="ERC20"&&(i=i+r.toLowerCase()),t=this.omit(t,"network"));const a={coinName:i,need_new:0},o=await this.privatePostGetDepositAddress(this.extend(a,t)),d=this.safeString(o.return,"address");return this.checkAddress(d),{currency:e,address:d,tag:void 0,network:void 0,info:o}}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const a={coinName:this.currency(e).id,amount:t,address:s};if(i!==void 0)throw new Zo(this.id+" withdraw() does not support the tag argument yet due to a lack of docs on withdrawing with tag/memo on behalf of the exchange.");return{info:await this.privatePostWithdrawCoinsToAddress(this.extend(a,n)),id:void 0}}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api[t];const o=this.omit(i,this.extractParams(e));if(t==="private"){this.checkRequiredCredentials();const d=this.nonce();r=this.urlencode(this.extend({nonce:d,method:e},o));const c=this.hmac(this.encode(r),this.encode(this.secret),"sha512");n={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:c}}else t==="public"?(a+="/"+this.version+"/"+this.implodeParams(e,i),Object.keys(o).length&&(a+="?"+this.urlencode(o))):(a+="/"+this.implodeParams(e,i),s==="GET"?Object.keys(o).length&&(a+="?"+this.urlencode(o)):Object.keys(o).length&&(r=this.json(o),n={"Content-Type":"application/json"}));return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&"success"in a){let c=this.safeValue(a,"success",!1);if(typeof c=="string"&&(c==="true"||c==="1"?c=!0:c=!1),!c){const u=this.safeString(a,"code"),h=this.safeString(a,"error"),l=this.id+" "+r;throw this.throwExactlyMatchedException(this.exceptions.exact,u,l),this.throwExactlyMatchedException(this.exceptions.exact,h,l),this.throwBroadlyMatchedException(this.exceptions.broad,h,l),new Zo(l)}}}};const lU=ge,{ExchangeError:Ih,BadRequest:pU}=de,{TICK_SIZE:mU}=me,gU=Se;var yU=class extends lU{describe(){return this.deepExtend(super.describe(),{id:"zaif",name:"Zaif",countries:["JP"],rateLimit:100,version:"1",has:{CORS:void 0,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelOrder:!0,createMarketOrder:void 0,createOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrderBook:!0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766927-39ca2ada-5eeb-11e7-972f-1b4199518ca6.jpg",api:{rest:"https://api.zaif.jp"},www:"https://zaif.jp",doc:["https://techbureau-api-document.readthedocs.io/ja/latest/index.html","https://corp.zaif.jp/api-docs","https://corp.zaif.jp/api-docs/api_links","https://www.npmjs.com/package/zaif.jp","https://github.com/you21979/node-zaif"],fees:"https://zaif.jp/fee?lang=en"},fees:{trading:{percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0")}},api:{public:{get:{"depth/{pair}":1,"currencies/{pair}":1,"currencies/all":1,"currency_pairs/{pair}":1,"currency_pairs/all":1,"last_price/{pair}":1,"ticker/{pair}":1,"trades/{pair}":1}},private:{post:{active_orders:5,cancel_order:5,deposit_history:5,get_id_info:5,get_info:10,get_info2:5,get_personal_info:5,trade:5,trade_history:50,withdraw:5,withdraw_history:5}},ecapi:{post:{createInvoice:1,getInvoice:1,getInvoiceIdsByOrderNumber:1,cancelInvoice:1}},tlapi:{post:{get_positions:66,position_history:66,active_positions:5,create_position:33,change_position:33,cancel_position:33}},fapi:{get:{"groups/{group_id}":1,"last_price/{group_id}/{pair}":1,"ticker/{group_id}/{pair}":1,"trades/{group_id}/{pair}":1,"depth/{group_id}/{pair}":1}}},options:{fees:{"BTC/JPY":{maker:this.parseNumber("0"),taker:this.parseNumber("0.001")},"BCH/JPY":{maker:this.parseNumber("0"),taker:this.parseNumber("0.003")},"BCH/BTC":{maker:this.parseNumber("0"),taker:this.parseNumber("0.003")},"PEPECASH/JPY":{maker:this.parseNumber("0"),taker:this.parseNumber("0.0001")},"PEPECASH/BT":{maker:this.parseNumber("0"),taker:this.parseNumber("0.0001")}}},precisionMode:mU,exceptions:{exact:{"unsupported currency_pair":pU},broad:{}}})}async fetchMarkets(e={}){const t=await this.publicGetCurrencyPairsAll(e),s=[];for(let i=0;i<t.length;i++){const n=t[i],r=this.safeString(n,"currency_pair"),a=this.safeString(n,"name"),[o,d]=a.split("/"),c=this.safeCurrencyCode(o),u=this.safeCurrencyCode(d),h=c+"/"+u,l=this.safeValue(this.options.fees,h,this.fees.trading);s.push({id:r,symbol:h,base:c,quote:u,settle:void 0,baseId:o,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:void 0,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,taker:l.taker,maker:l.maker,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(n,"item_unit_step"),price:this.parseNumber(this.parsePrecision(this.safeString(n,"aux_unit_point")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(n,"item_unit_min"),max:void 0},price:{min:this.safeNumber(n,"aux_unit_min"),max:void 0},cost:{min:void 0,max:void 0}},info:n})}return s}parseBalance(e){const t=this.safeValue(e,"return",{}),s=this.safeValue(t,"deposit"),i={info:e,timestamp:void 0,datetime:void 0},n=this.safeValue(t,"funds",{}),r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeCurrencyCode(o),c=this.safeString(n,o),u=this.account();u.free=c,u.total=c,s!==void 0&&o in s&&(u.total=this.safeString(s,o)),i[d]=u}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetInfo(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={pair:i.id},r=await this.publicGetDepthPair(this.extend(n,s));return this.parseOrderBook(r,i.symbol)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.milliseconds(),n=this.safeString(e,"vwap"),r=this.safeString(e,"volume"),a=gU.stringMul(r,n),o=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:n,open:void 0,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:a,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},n=await this.publicGetTickerPair(this.extend(i,t));return this.parseTicker(n,s)}parseTrade(e,t=void 0){let s=this.safeString(e,"trade_type");s=s==="bid"?"buy":"sell";const i=this.safeTimestamp(e,"date"),n=this.safeString2(e,"id","tid"),r=this.safeString(e,"price"),a=this.safeString(e,"amount"),o=this.safeString(e,"currency_pair"),d=this.safeSymbol(o,t,"_");return this.safeTrade({id:n,info:e,timestamp:i,datetime:this.iso8601(i),symbol:d,type:void 0,side:s,order:void 0,takerOrMaker:void 0,price:r,amount:a,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r={pair:n.id};let a=await this.publicGetTradesPair(this.extend(r,i));if(a.length===1){const d=a[0];Object.keys(d).length||(a=[])}return this.parseTrades(a,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){if(await this.loadMarkets(),t!=="limit")throw new Ih(this.id+" createOrder() allows limit orders only");const o={currency_pair:this.market(e).id,action:s==="buy"?"bid":"ask",amount:i,price:n},d=await this.privatePostTrade(this.extend(o,r));return{info:d,id:d.return.order_id.toString()}}async cancelOrder(e,t=void 0,s={}){const i={order_id:e};return await this.privatePostCancelOrder(this.extend(i,s))}parseOrder(e,t=void 0){let s=this.safeString(e,"action");s=s==="bid"?"buy":"sell";const i=this.safeTimestamp(e,"timestamp"),n=this.safeString(e,"currency_pair"),r=this.safeSymbol(n,t,"_"),a=this.safeString(e,"price"),o=this.safeString(e,"amount"),d=this.safeString(e,"id");return this.safeOrder({id:d,clientOrderId:void 0,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,status:"open",symbol:r,type:"limit",timeInForce:void 0,postOnly:void 0,side:s,price:a,stopPrice:void 0,cost:void 0,amount:o,filled:void 0,remaining:void 0,trades:void 0,fee:void 0,info:e,average:void 0},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.currency_pair=n.id);const a=await this.privatePostActiveOrders(this.extend(r,i));return this.parseOrders(a.return,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;const r={};e!==void 0&&(n=this.market(e),r.currency_pair=n.id);const a=await this.privatePostTradeHistory(this.extend(r,i));return this.parseOrders(a.return,n,t,s)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n),this.checkAddress(s),await this.loadMarkets();const r=this.currency(e);if(e==="JPY")throw new Ih(this.id+" withdraw() does not allow "+e+" withdrawals");const a={currency:r.id,amount:t,address:s};i!==void 0&&(a.message=i);const o=await this.privatePostWithdraw(this.extend(a,n)),d=this.safeValue(o,"return");return this.parseTransaction(d,r)}parseTransaction(e,t=void 0){t=this.safeCurrency(void 0,t);let s;const i=this.safeValue(e,"fee");return i!==void 0&&(s={cost:i,currency:t.code}),{id:this.safeString(e,"id"),txid:this.safeString(e,"txid"),timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:s,info:e}}nonce(){return parseFloat(this.milliseconds()/1e3).toFixed(8)}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){let a=this.urls.api.rest+"/";if(t==="public")a+="api/"+this.version+"/"+this.implodeParams(e,i);else if(t==="fapi")a+="fapi/"+this.version+"/"+this.implodeParams(e,i);else{this.checkRequiredCredentials(),t==="ecapi"?a+="ecapi":t==="tlapi"?a+="tlapi":a+="tapi";const o=this.nonce();r=this.urlencode(this.extend({method:e,nonce:o},i)),n={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:this.hmac(this.encode(r),this.encode(this.secret),"sha512")}}return{url:a,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a===void 0)return;const c=this.id+" "+r,u=this.safeString(a,"error");if(u!==void 0)throw this.throwExactlyMatchedException(this.exceptions.exact,u,c),this.throwBroadlyMatchedException(this.exceptions.broad,u,c),new Ih(c);if(!this.safeValue(a,"success",!0))throw new Ih(c)}};const bU=ge,{BadRequest:li,BadSymbol:Bg,ExchangeError:Ve,ArgumentsRequired:Rt,AuthenticationError:Yt,InsufficientFunds:os,NotSupported:xh,OrderNotFound:to,ExchangeNotAvailable:so,RateLimitExceeded:Jo,PermissionDenied:on,InvalidOrder:$e,InvalidAddress:wU,OnMaintenance:UT,RequestTimeout:_h,AccountSuspended:Eg,NetworkError:$T,DDoSProtection:kU,DuplicateOrderId:SU,BadResponse:eu}=de,{TICK_SIZE:vU}=me,TU=Se;var cC=class extends bU{describe(){return this.deepExtend(super.describe(),{id:"zb",name:"ZB",countries:["CN"],rateLimit:6,version:"v1",pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:void 0,option:void 0,addMargin:!0,borrowMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createMarketOrder:void 0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchBorrowRate:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!0,fetchCanceledOrders:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddresses:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!0,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!0,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchWithdrawals:!0,reduceMargin:!0,setLeverage:!0,setMarginMode:!1,setPositionMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","3d":"3d","5d":"5d","1w":"1w"},hostname:"zb.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/32859187-cd5214f0-ca5e-11e7-967d-96568e2e2bd1.jpg",api:{spot:{v1:{public:"https://api.{hostname}/data",private:"https://trade.{hostname}/api"}},contract:{v1:{public:"https://fapi.{hostname}/api/public"},v2:{public:"https://fapi.{hostname}/Server/api",private:"https://fapi.{hostname}/Server/api"}}},www:"https://www.zb.com",doc:"https://www.zb.com/i/developer",fees:"https://www.zb.com/i/rate",referral:{url:"https://www.zb.com/en/register?ref=4301lera",discount:.16}},api:{spot:{v1:{public:{get:{markets:16.667,ticker:16.667,allTicker:16.667,depth:16.667,trades:16.667,kline:166.667,getGroupMarkets:16.667,getFeeInfo:16.667}},private:{get:{order:1,orderMoreV2:1,cancelOrder:1,cancelAllOrdersAfter:1,getOrder:1,getOrders:1,getOrdersNew:16.667,getOrdersIgnoreTradeType:1,getUnfinishedOrdersIgnoreTradeType:1,getFinishedAndPartialOrders:1,getAccountInfo:16.667,getUserAddress:16.667,getPayinAddress:16.667,getWithdrawAddress:16.667,getWithdrawRecord:16.667,getChargeRecord:16.667,getCnyWithdrawRecord:16.667,getCnyChargeRecord:16.667,withdraw:16.667,addSubUser:16.667,getSubUserList:16.667,doTransferFunds:16.667,createSubUserKey:16.667,getLeverAssetsInfo:16.667,getLeverBills:16.667,transferInLever:16.667,transferOutLever:16.667,loan:16.667,cancelLoan:16.667,getLoans:16.667,getLoanRecords:16.667,borrow:16.667,autoBorrow:16.667,repay:16.667,doAllRepay:16.667,getRepayments:16.667,getFinanceRecords:16.667,changeInvestMark:16.667,changeLoop:16.667,getCrossAssets:16.667,getCrossBills:16.667,transferInCross:16.667,transferOutCross:16.667,doCrossLoan:16.667,doCrossRepay:16.667,getCrossRepayRecords:16.667}}}},contract:{v1:{public:{get:{depth:16.667,fundingRate:16.667,indexKline:16.667,indexPrice:16.667,kline:16.667,markKline:16.667,markPrice:16.667,ticker:16.667,trade:16.667}}},v2:{public:{get:{allForceOrders:3.334,"config/marketList":3.334,topLongShortAccountRatio:3.334,topLongShortPositionRatio:3.334,fundingRate:3.334,premiumIndex:3.334}},private:{get:{"Fund/balance":3.334,"Fund/getAccount":3.334,"Fund/getBill":3.334,"Fund/getBillTypeList":3.334,"Fund/marginHistory":3.334,"Positions/getPositions":3.334,"Positions/getNominalValue":3.334,"Positions/marginInfo":3.334,"setting/get":3.334,"trade/getAllOrders":3.334,"trade/getOrder":3.334,"trade/getOrderAlgos":3.334,"trade/getTradeList":3.334,"trade/getUndoneOrders":3.334,"trade/tradeHistory":3.334},post:{"activity/buyTicket":3.334,"Fund/transferFund":3.334,"Positions/setMarginCoins":3.334,"Positions/updateAppendUSDValue":3.334,"Positions/updateMargin":3.334,"setting/setLeverage":3.334,"setting/setPositionsMode":3.334,"trade/batchOrder":3.334,"trade/batchCancelOrder":3.334,"trade/cancelAlgos":3.334,"trade/cancelAllOrders":3.334,"trade/cancelOrder":3.334,"trade/order":3.334,"trade/orderAlgo":3.334,"trade/updateOrderAlgo":3.334}}}}},fees:{funding:{withdraw:{}},trading:{maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},commonCurrencies:{ANG:"Anagram",ENT:"ENTCash",BCHABC:"BCHABC",BCHSV:"BCHSV"},options:{timeframes:{spot:{"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","2h":"2hour","4h":"4hour","6h":"6hour","12h":"12hour","1d":"1day","3d":"3day","1w":"1week"},swap:{"1m":"1M","5m":"5M","15m":"15M","30m":"30M","1h":"1H","6h":"6H","1d":"1D","5d":"5D"}}},precisionMode:vU,exceptions:{ws:{1001:Ve,1002:Ve,1003:Yt,1004:Yt,1005:Yt,1006:on,1007:Ve,1009:UT,1010:so,1012:on,1013:Ve,1014:Ve,2001:os,2002:os,2003:os,2005:os,2006:os,2007:os,2008:os,2009:os,3001:to,3002:$e,3003:$e,3004:Yt,3005:li,3006:on,3007:_h,3008:Ve,3009:$e,3010:on,3011:$e,3012:$e,4001:Eg,4002:Jo},exact:{10001:Ve,10002:on,10003:eu,10004:eu,10005:on,10006:li,10007:Ve,10008:Ve,10009:Ve,1001:Ve,10010:Yt,10011:Yt,10012:Eg,10013:Yt,10014:Yt,10015:Yt,10016:Yt,10017:on,10018:Eg,10019:_h,1002:Ve,10020:li,10021:li,10022:li,10023:Jo,10024:Yt,10025:Ve,10026:$T,10027:_h,10028:so,10029:kU,1003:Yt,10030:li,10031:li,10032:li,10033:li,10034:li,10035:li,10036:li,10037:Rt,10038:li,10039:eu,1004:Yt,10040:eu,10041:eu,10042:Ve,10043:Ve,10044:Ve,10045:Ve,10046:Ve,10047:Ve,10048:Ve,10049:$T,1005:Yt,1006:Yt,1009:so,1010:so,10100:UT,1012:on,1013:Ve,1014:Ve,11e3:Ve,11001:Ve,110011:Ve,11002:Ve,11003:Ve,11004:os,11005:$e,11006:os,11007:to,11008:Ve,11009:Ve,110110:Ve,11012:os,11013:Ve,11014:Ve,11015:Yt,11016:Yt,11017:Ve,11018:os,11019:Ve,11021:os,11023:Ve,11030:on,11031:Ve,11032:Ve,11033:Rt,11034:Ve,12e3:$e,12001:$e,12002:$e,12003:$e,12004:$e,12005:$e,12006:$e,12007:$e,12008:$e,12009:$e,12010:$e,12011:$e,12012:to,12013:$e,12014:$e,12015:$e,12016:$e,12017:$e,12018:$e,12019:Rt,12020:Ve,12021:$e,12022:$e,12023:to,12024:$e,12025:$e,12026:SU,12027:so,12028:$e,12029:$e,12201:$e,12202:$e,12203:$e,12204:$e,12205:$e,12206:$e,12207:Jo,13001:Yt,13002:on,13003:$e,13004:$e,13005:Jo,13006:Ve,13007:Ve,13008:Ve,13009:Ve,14e3:Ve,14001:Yt,14002:Yt,14003:Ve,14100:Ve,14101:Jo,14200:Rt,14300:Ve,14301:Ve,14302:Ve,14303:Ve,14305:Ve,14306:Ve,14307:$e,14308:$e,14309:Ve,14310:xh,14311:xh,14312:Ve,14313:on,14314:Ve,2001:os,2002:os,2003:os,2005:os,2006:os,2007:os,2008:os,2009:os,3001:to,3002:$e,3003:$e,3004:Yt,3005:li,3006:Yt,3007:Yt,3008:to,3009:$e,3010:on,3011:$e,3012:$e,4001:so,4002:Jo,9999:Ve},broad:{"\u63D0\u5E01\u5730\u5740\u6709\u8BEF, \u8BF7\u5148\u6DFB\u52A0\u63D0\u5E01\u5730\u5740\u3002":wU,"\u8D44\u91D1\u4E0D\u8DB3,\u65E0\u6CD5\u5212\u8D26":os,\u54CD\u5E94\u8D85\u65F6:_h}}})}async fetchMarkets(e={}){let t=[this.spotV1PublicGetMarkets(e),this.contractV2PublicGetConfigMarketList(e)];t=await Promise.all(t);const s=t[0],i=t[1],n=this.safeValue(i,"data",[]),r=this.indexBy(n,"marketName"),a=this.deepExtend(r,s),o=Object.keys(a),d=[];for(let c=0;c<o.length;c++){const u=o[c],h=a[u],[l,p]=u.split("_"),m=this.safeCurrencyCode(l),g=this.safeCurrencyCode(p),y=this.safeValue(h,"marginCurrencyName"),b=this.safeCurrencyCode(y),w=b===void 0,k=this.safeValue(h,"futures",!1),T=k?!0:void 0;let O=!0,x=m+"/"+g;k&&(O=this.safeString(h,"status")==="1",x=m+"/"+g+":"+b),d.push({id:u,symbol:x,base:m,quote:g,settle:b,baseId:l,quoteId:p,settleId:y,type:k?"swap":"spot",spot:w,margin:!1,swap:k,future:!1,option:!1,active:O,contract:k,linear:T,inverse:k?!T:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString2(h,"amountScale","amountDecimal"))),price:this.parseNumber(this.parsePrecision(this.safeString2(h,"priceScale","priceDecimal")))},limits:{leverage:{min:void 0,max:this.safeNumber(h,"maxLeverage")},amount:{min:this.safeNumber(h,"minAmount"),max:this.safeNumber(h,"maxAmount")},price:{min:void 0,max:void 0},cost:{min:this.safeNumber2(h,"minSize","minTradeMoney"),max:this.safeNumber(h,"maxTradeMoney")}},info:h})}return d}async fetchCurrencies(e={}){const t=await this.spotV1PublicGetGetFeeInfo(e),s=this.safeValue(t,"result",{}),i=Object.keys(s),n={};for(let r=0;r<i.length;r++){const a=i[r],o=s[a],d=this.safeCurrencyCode(a);let c=!0,u=!0;const h={};for(let p=0;p<o.length;p++){const m=o[p],g=this.safeString(m,"chainName"),y=this.safeNumber(m,"fee"),b=this.safeValue(m,"canDeposit"),w=this.safeValue(m,"canWithdraw");u=u||b,c=c||w,h[g]=y}const l=c&&u;n[d]={id:a,name:void 0,code:d,precision:void 0,info:o,active:l,deposit:u,withdraw:c,fee:void 0,fees:h,limits:this.limits}}return n}parseBalance(e){const t=this.safeValue(e.result,"coins"),s={info:e};for(let i=0;i<t.length;i++){const n=t[i],r=this.account(),a=this.safeString(n,"key"),o=this.safeCurrencyCode(a);r.free=this.safeString(n,"available"),r.used=this.safeString(n,"freez"),s[o]=r}return this.safeBalance(s)}parseSwapBalance(e){const t={info:e},s=this.safeValue(e,"data",{});for(let i=0;i<s.length;i++){const n=s[i],r=this.safeCurrencyCode(this.safeString(n,"currencyName")),a=this.account();a.total=this.safeString(n,"accountBalance"),a.free=this.safeString(n,"allowTransferOutAmount"),a.used=this.safeString(n,"freezeAmount"),t[r]=a}return this.safeBalance(t)}parseMarginBalance(e,t){const s={info:e};let i;if(t==="isolated"){const n=this.safeValue(e,"message",{}),r=this.safeValue(n,"datas",{});i=this.safeValue(r,"levers",[])}else{const n=this.safeValue(e,"result",{});i=this.safeValue(n,"list",[])}for(let n=0;n<i.length;n++){const r=i[n],a=this.account();if(t==="isolated"){const o=this.safeCurrencyCode(this.safeString(r,"fShowName"));a.total=this.safeString(r,"fAvailableUSD"),a.free=this.safeString(r,"couldTransferOutFiat"),a.used=this.safeString(r,"fFreeze"),s[o]=a}else{const o=this.safeCurrencyCode(this.safeString(r,"key"));a.total=this.safeString(r,"amount"),a.free=this.safeString(r,"canTransferOut"),a.used=this.safeString(r,"freeze"),s[o]=a}}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),[i,n]=this.handleMarginModeAndParams("fetchBalance",s),r=t==="swap",a=i==="cross"?"spotV1PrivateGetGetCrossAssets":"spotV1PrivateGetGetLeverAssetsInfo";let o=this.getSupportedMapping(t,{spot:"spotV1PrivateGetGetAccountInfo",swap:"contractV2PrivateGetFundBalance",margin:a});i==="isolated"?o="spotV1PrivateGetGetLeverAssetsInfo":i==="cross"&&(o="spotV1PrivateGetGetCrossAssets");const d={};r&&(d.futuresAccountType=1);const c=await this[o](this.extend(d,n));return r?this.parseSwapBalance(c):i!==void 0?this.parseMarginBalance(c,i):this.parseBalance(c)}parseDepositAddress(e,t=void 0){let s=this.safeString2(e,"key","address"),i;const n=this.safeString(e,"memo");if(n!==void 0)i=n;else if(s.indexOf("_")>=0){const o=s.split("_");s=o[0],i=o[1]}this.checkAddress(s);const r=this.safeString(e,"blockChain");return{currency:this.safeCurrencyCode(r,t),address:s,tag:i,network:void 0,info:e}}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s=await this.spotV1PrivateGetGetPayinAddress(t),i=this.safeValue(s,"message",{}),n=this.safeValue(i,"datas",[]);return this.parseDepositAddresses(n,e)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},n=await this.spotV1PrivateGetGetUserAddress(this.extend(i,t)),r=this.safeValue(n,"message",{}),a=this.safeValue(r,"datas",{});return this.parseDepositAddress(a,s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n={},r=i.swap?"symbol":"market";n[r]=i.id;const a=this.getSupportedMapping(i.type,{spot:"spotV1PublicGetDepth",swap:"contractV1PublicGetDepth"});t!==void 0&&(n.size=t);const o=await this[a](this.extend(n,s));let d,c;return i.type==="swap"?(d=this.safeValue(o,"data"),c=this.safeInteger(d,"time")):(d=o,c=this.safeTimestamp(o,"timestamp")),this.parseOrderBook(d,e,c)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.spotV1PublicGetAllTicker(t),i={},n={},r=Object.keys(this.markets_by_id);for(let o=0;o<r.length;o++){const d=r[o].replace("_","");n[d]=this.markets_by_id[r[o]]}const a=Object.keys(s);for(let o=0;o<a.length;o++){const d=this.safeValue(n,a[o]);if(d!==void 0){const c=d.symbol,u=this.safeValue(s,a[o]);u!==void 0&&(i[c]=this.parseTicker(u,d))}}return this.filterByArray(i,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={},n=s.swap?"symbol":"market";i[n]=s.id;const r=this.getSupportedMapping(s.type,{spot:"spotV1PublicGetTicker",swap:"contractV1PublicGetTicker"}),a=await this[r](this.extend(i,t));let o;if(s.type==="swap"){o={};const d=this.safeValue(a,"data"),c=this.safeValue(d,s.id,[]);for(let u=0;u<c.length;u++)o.open=this.safeValue(c,0),o.high=this.safeValue(c,1),o.low=this.safeValue(c,2),o.last=this.safeValue(c,3),o.vol=this.safeValue(c,4),o.riseRate=this.safeValue(c,5)}else o=this.safeValue(a,"ticker",{}),o.date=this.safeValue(a,"date");return this.parseTicker(o,s)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"date",this.milliseconds()),i=this.safeString(e,"last");return this.safeTicker({symbol:this.safeSymbol(void 0,t),timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:i,last:i,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"vol"),quoteVolume:void 0,info:e},t)}parseOHLCV(e,t=void 0){return t.swap?e.length>5?[this.safeTimestamp(e,5),this.safeNumber(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4)]:[this.safeTimestamp(e,4),this.safeNumber(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),void 0]:[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=r.swap,o=r.spot,d=this.safeValue(this.options,"timeframes",{}),c=this.safeValue(d,r.type,{}),u=this.safeString(c,t);if(u===void 0)throw new xh(this.id+" fetchOHLCV() does not support "+t+" timeframe for "+r.type+" markets");i===void 0&&(i=1e3);const h={size:i},l=a?"symbol":"market";h[l]=r.id;const p=a?"period":"type";h[p]=u;const m=this.safeString(n,"price");n=this.omit(n,"price");let g=this.getSupportedMapping(r.type,{spot:"spotV1PublicGetKline",swap:"contractV1PublicGetKline"});a?m==="mark"?g="contractV1PublicGetMarkKline":m==="index"&&(g="contractV1PublicGetIndexKline"):o&&s!==void 0&&(h.since=s);const y=await this[g](this.extend(h,n)),b=this.safeValue(y,"data",[]);return this.parseOHLCVs(b,r,t,s,i)}parseTrade(e,t=void 0){const s=t.swap?"side":"trade_type";let i=this.safeString(e,s),n;const r=this.safeValue(e,"maker");r!==void 0&&(n=r?"maker":"taker"),t.spot?i=i==="bid"?"buy":"sell":i==="3"?i="sell":i==="4"||i==="1"?i="buy":i==="2"&&(i="sell");let a;t.swap?a=this.safeInteger(e,"createTime"):a=this.safeTimestamp(e,"date");const o=this.safeString(e,"price"),d=this.safeString(e,"amount");let c;const u=this.safeString(e,"feeAmount");if(u!==void 0){const h=this.safeString(e,"feeCurrency");c={cost:u,currency:this.safeCurrencyCode(h)}}return t=this.safeMarket(void 0,t),this.safeTrade({info:e,id:this.safeString(e,"tid"),timestamp:a,datetime:this.iso8601(a),symbol:t.symbol,type:void 0,side:i,order:this.safeString(e,"orderId"),takerOrMaker:n,price:o,amount:d,cost:void 0,fee:c},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){if(e===void 0)throw new Rt(this.id+" fetchTrades() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=n.swap,a={};s!==void 0&&(a.pageSize=s),t!==void 0&&(a.startTime=t);const o=r?"symbol":"market";a[o]=n.id,r&&i.pageNum===void 0&&(a.pageNum=1);const d=this.getSupportedMapping(n.type,{spot:"spotV1PublicGetTrades",swap:"contractV2PrivateGetTradeTradeHistory"});let c=await this[d](this.extend(a,i));if(r){const u=this.safeValue(c,"data");c=this.safeValue(u,"list")}return this.parseTrades(c,n,t,s)}async createOrder(e,t,s,i,n=void 0,r={}){await this.loadMarkets();const a=this.market(e),[o,d]=this.handleMarginModeAndParams("createOrder",r),c=a.swap,u=a.spot,h=this.safeString(r,"timeInForce");let l=this.safeValue(r,"reduceOnly");const p=this.safeValue2(r,"triggerPrice","stopPrice"),m=this.safeValue(r,"stopLossPrice"),g=this.safeValue(r,"takeProfitPrice"),y=m!==void 0,b=g!==void 0,w=p!==void 0;if(this.sum(y,b,w))throw new Ve(this.id+" createOrder() stopLossPrice and takeProfitPrice cannot both be defined");const k=y||b||w;if(k&&u)throw new Ve(this.id+" createOrder() it is not possible to make a stop order on spot markets");if(t==="market")throw new $e(this.id+" createOrder() on "+a.type+" markets does not allow market orders");let T=this.getSupportedMapping(a.type,{spot:"spotV1PrivateGetOrder",margin:"spotV1PrivateGetOrder",swap:"contractV2PrivatePostTradeOrder"});const O={amount:this.amountToPrecision(e,i)};if(u){const E=this.safeInteger(r,"orderType",t)===1,P=this.isPostOnly(!1,E,r);O.tradeType=s==="buy"?1:0,O.currency=a.id,P?O.orderType=1:h==="IOC"&&(O.orderType=2),n!==void 0&&(O.price=this.priceToPrecision(e,n)),o!==void 0&&(o==="isolated"?O.acctType=1:o==="cross"&&(O.acctType=2))}else if(c){const E=this.safeInteger(r,"action",t)===4,P=this.isPostOnly(!1,E,r);(y||b)&&(l=!0),l?O.side=0:O.side=s==="buy"?5:6,k?(T="contractV2PrivatePostTradeOrderAlgo",y?(O.orderType=2,O.bizType=2,O.triggerPrice=this.priceToPrecision(e,m)):b?(O.orderType=2,O.bizType=1,O.triggerPrice=this.priceToPrecision(e,g)):w&&(O.orderType=1,O.triggerPrice=this.priceToPrecision(e,p)),O.algoPrice=this.priceToPrecision(e,n),O.pricetype=2):h==="IOC"?O.action=3:P?O.action=4:h==="FOK"?O.action=5:t==="limit"?O.action=1:O.action=t,n!==void 0&&(O.price=this.priceToPrecision(e,n)),O.symbol=a.id;const _=this.safeString(r,"clientOrderId");_!==void 0&&(O.clientOrderId=_);const S=this.safeValue(r,"extend",void 0);S!==void 0&&(O.extend=S)}r=this.omit(d,["takeProfitPrice","stopLossPrice","stopPrice","reduceOnly","orderType","triggerPrice","priceType","clientOrderId","extend"]);const x=await this[T](this.extend(O,r));let C=x;return c&&!k&&(C=this.safeValue(x,"data")),this.parseOrder(C,a)}async cancelOrder(e,t=void 0,s={}){if(t===void 0)throw new Rt(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),n=i.swap,r={},a=n?"symbol":"currency";r[a]=this.marketId(t);const o=n?"orderId":"id";r[o]=e.toString();const d=this.getSupportedMapping(i.type,{spot:"spotV1PrivateGetCancelOrder",swap:"contractV2PrivatePostTradeCancelOrder"}),c=await this[d](this.extend(r,s));return this.parseOrder(c,i)}async cancelAllOrders(e=void 0,t={}){if(e===void 0)throw new Rt(this.id+" cancelAllOrders() requires a symbol argument");await this.loadMarkets();const s=this.market(e),i=this.safeValue(t,"stop");if(s.spot)throw new xh(this.id+" cancelAllOrders() is not supported on "+s.type+" markets");const n={symbol:s.id};let r="contractV2PrivatePostTradeCancelAllOrders";i&&(r="contractV2PrivatePostTradeCancelAlgos");const a=this.omit(t,"stop");return await this[r](this.extend(n,a))}async fetchOrder(e,t=void 0,s={}){if(t===void 0)throw new Rt(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t);if(this.safeInteger(s,"orderType")!==void 0)throw new Ve(this.id+" fetchOrder() it is not possible to fetch a single conditional order, use fetchOrders() instead");const r=i.swap,a={},o=r?"symbol":"currency";a[o]=this.marketId(t);const d=r?"orderId":"id";a[d]=e.toString();const c=this.getSupportedMapping(i.type,{spot:"spotV1PrivateGetGetOrder",swap:"contractV2PrivateGetTradeGetOrder"}),u=await this[c](this.extend(a,s));let h=u;return r&&(h=this.safeValue(u,"data")),this.parseOrder(h,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Rt(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=this.safeInteger(i,"orderType"),a=n.swap,o={pageSize:s},d=n.swap?"symbol":"currency";o[d]=n.id;const c=n.swap?"pageNum":"pageIndex";o[c]=1,a&&(o.startTime=t);let u=this.getSupportedMapping(n.type,{spot:"spotV1PrivateGetGetOrdersIgnoreTradeType",swap:"contractV2PrivateGetTradeGetAllOrders"});"tradeType"in i&&(u="spotV1PrivateGetGetOrdersNew"),r!==void 0&&(u="contractV2PrivateGetTradeGetOrderAlgos");const h=await this[u](this.extend(o,i));let l=h;if(a){const p=this.safeValue(h,"data",{});l=this.safeValue(p,"list",[])}return this.parseOrders(l,n,t,s)}async fetchCanceledOrders(e=void 0,t=void 0,s=10,i={}){if(e===void 0)throw new Rt(this.id+" fetchCanceledOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=this.safeValue(i,"reduceOnly"),a=this.safeValue(i,"stop"),o={pageSize:s},d=n.spot?"currency":"symbol";o[d]=n.id;const c=n.spot?"pageIndex":"pageNum";o[c]=1;let u="spotV1PrivateGetGetOrdersIgnoreTradeType";if(a){u="contractV2PrivateGetTradeGetOrderAlgos";const m=this.safeInteger(i,"orderType");if(m===void 0)throw new Rt(this.id+" fetchCanceledOrders() requires an orderType parameter for stop orders");const g=this.safeValue(i,"side"),y=this.safeInteger(i,"bizType");g==="sell"&&r?o.side=3:g==="buy"&&r?o.side=4:g==="buy"?o.side=1:g==="sell"?o.side=2:g===5?o.side=5:g===6?o.side=6:g===0&&(o.side=0),m===1?o.orderType=1:(m===2||y)&&(o.orderType=2,o.bizType=y),o.status=2}"tradeType"in i&&(u="spotV1PrivateGetGetOrdersNew");let h;try{h=await this[u](this.extend(o,i))}catch(m){if(m instanceof to)return[];throw m}const l=this.omit(i,["reduceOnly","stop","side","orderType","bizType"]);if(h=await this[u](this.extend(o,l)),a){const m=this.safeValue(h,"data",{});h=this.safeValue(m,"list",[])}const p=[];if(n.type==="spot"){for(let m=0;m<h.length;m++){const g=h[m];this.safeString(g,"status")==="1"&&p.push(g)}h=p}return this.parseOrders(h,n,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=10,i={}){if(e===void 0)throw new Rt(this.id+" fetchClosedOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=n.swap,a=this.safeInteger(i,"orderType"),o={pageSize:s},d=n.spot?"currency":"symbol";o[d]=n.id;const c=n.spot?"pageIndex":"pageNum";o[c]=1,r&&t!==void 0&&(o.startTime=t);const u=this.getSupportedMapping(n.type,{spot:"spotV1PrivateGetGetFinishedAndPartialOrders",swap:"contractV2PrivateGetTradeGetOrderAlgos"});if(r&&a===void 0)throw new Ve(this.id+" fetchClosedOrders() can not fetch swap orders, use fetchOrders instead");r&&(o.status=5);const h=await this[u](this.extend(o,i));let l=h;if(r){const p=this.safeValue(h,"data",{});l=this.safeValue(p,"list",[])}return this.parseOrders(l,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Rt(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const n=this.market(e),r=this.safeInteger(i,"orderType"),a=n.swap,o={};s!==void 0&&(o.pageSize=s);const d=n.swap?"symbol":"currency";o[d]=n.id;const c=n.swap?"pageNum":"pageIndex";o[c]=1,a&&t!==void 0&&(o.startTime=t);let u=this.getSupportedMapping(n.type,{spot:"spotV1PrivateGetGetUnfinishedOrdersIgnoreTradeType",swap:"contractV2PrivateGetTradeGetUndoneOrders"});r!==void 0&&(u="contractV2PrivateGetTradeGetOrderAlgos",o.status=1),"tradeType"in i&&(u="spotV1PrivateGetGetOrdersNew");const h=await this[u](this.extend(o,i));let l=h;if(a){const p=this.safeValue(h,"data",{});l=this.safeValue(p,"list",[])}return this.parseOrders(l,n,t,s)}parseOrder(e,t=void 0){let s=t.swap?this.safeString2(e,"orderId","data"):this.safeString(e,"id");s===void 0&&(s=this.safeValue(e,"id"));let i=this.safeInteger2(e,"type","side");i===void 0?i=void 0:t.spot?i=i===1?"buy":"sell":t.swap&&(i===0?i=void 0:i===1||i===4||i===5?i="buy":(i===2||i===3||i===6)&&(i="sell"));let n=this.safeInteger(e,"trade_date");n===void 0&&(n=this.safeInteger(e,"createTime"));const r=this.safeString(e,"currency");t=this.safeMarket(r,t,"_");const a=this.safeString2(e,"price","algoPrice"),o=t.swap?this.safeString(e,"tradeAmount"):this.safeString(e,"trade_amount");let d=this.safeString(e,"total_amount");d===void 0&&(d=this.safeString(e,"amount"));const c=this.safeString(e,"trade_money"),u=this.parseOrderStatus(this.safeString(e,"status"),t),h=this.safeString(e,"timeInForce"),l=h==="PO",p=this.safeNumber(e,"fees");let m;if(p!==void 0){let g;this.safeValue(e,"useZbFee")===!0?g="ZB":g=i==="sell"?t.quote:t.base,m={cost:p,currency:g}}return this.safeOrder({info:e,id:s,clientOrderId:this.safeString(e,"userId"),timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,symbol:t.symbol,type:"limit",timeInForce:h,postOnly:l,side:i,price:a,stopPrice:this.safeNumber(e,"triggerPrice"),average:this.safeString(e,"avgPrice"),cost:c,amount:d,filled:o,remaining:void 0,status:u,fee:m,trades:void 0},t)}parseOrderStatus(e,t=void 0){let s={};return t.type==="spot"?s={0:"open",1:"canceled",2:"closed",3:"open"}:s={1:"open",2:"canceled",3:"open",4:"rejected",5:"closed"},this.safeString(s,e,e)}parseTransactionStatus(e){const t={0:"pending",1:"failed",2:"ok",3:"canceled",5:"ok"};return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"hash"),n=this.safeNumber(e,"amount");let r=this.parse8601(this.safeString(e,"submit_time"));r=this.safeInteger(e,"submitTime",r);let a=this.safeString2(e,"toAddress","address"),o;if(a!==void 0){const y=a.split("_");a=this.safeString(y,0),o=this.safeString(y,1)}const d=this.safeInteger(e,"confirmTimes"),c=this.safeInteger(e,"manageTime");let u;const h=this.safeString(e,"currency"),l=this.safeCurrencyCode(h,t);a!==void 0&&(u=d===void 0?"withdrawal":"deposit");const p=this.parseTransactionStatus(this.safeString(e,"status"));let m;const g=this.safeNumber(e,"fees");return g!==void 0&&(m={cost:g,currency:l}),{info:e,id:s,txid:i,timestamp:r,datetime:this.iso8601(r),network:void 0,addressFrom:void 0,address:a,addressTo:a,tagFrom:void 0,tag:o,tagTo:o,type:u,amount:n,currency:l,status:p,updated:c,fee:m}}async setLeverage(e,t=void 0,s={}){if(await this.loadMarkets(),t===void 0)throw new Rt(this.id+" setLeverage() requires a symbol argument");if(e<1||e>125)throw new li(this.id+" setLeverage() leverage should be between 1 and 125");const i=this.market(t);let n;if(i.swap)n=1;else throw new Bg(this.id+" setLeverage() supports swap contracts only");const r={symbol:i.id,leverage:e,futuresAccountType:n};return await this.contractV2PrivatePostSettingSetLeverage(this.extend(r,s))}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};if(e!==void 0){const u=this.market(e);e=u.symbol,n.symbol=u.id}t!==void 0&&(n.startTime=t);const r=this.safeInteger2(i,"until","till");i=this.omit(i,["endTime","till","until"]),r!==void 0&&(n.endTime=r),s!==void 0&&(n.limit=s);const a=await this.contractV2PublicGetFundingRate(this.extend(n,i)),o=this.safeValue(a,"data",[]),d=[];for(let u=0;u<o.length;u++){const h=o[u],l=this.safeString(h,"symbol"),p=this.safeSymbol(l),m=this.safeInteger(h,"fundingTime");d.push({info:h,symbol:p,fundingRate:this.safeNumber(h,"fundingRate"),timestamp:m,datetime:this.iso8601(m)})}const c=this.sortBy(d,"timestamp");return this.filterBySymbolSinceLimit(c,e,t,s)}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new Bg(this.id+" fetchFundingRate() does not supports contracts only");const i={symbol:s.id},n=await this.contractV1PublicGetFundingRate(this.extend(i,t)),r=this.safeValue(n,"data");return this.parseFundingRate(r,s)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),n=this.safeNumber2(e,"fundingRate","lastFundingRate"),r=this.parse8601(this.safeString(e,"nextCalculateTime")),a=this.safeInteger(e,"nextFundingTime");return{info:e,symbol:i,markPrice:this.safeString(e,"markPrice"),indexPrice:this.safeString(e,"indexPrice"),interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:n,fundingTimestamp:a,fundingDatetime:this.iso8601(a),nextFundingRate:void 0,nextFundingTimestamp:r,nextFundingDatetime:this.iso8601(r),previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.contractV2PublicGetPremiumIndex(t),i=this.safeValue(s,"data",[]),n=this.parseFundingRates(i);return this.filterByArray(n,"symbol",e)}async withdraw(e,t,s,i=void 0,n={}){[i,n]=this.handleWithdrawTagAndParams(i,n);const r=this.safeString(n,"safePwd",this.password);if(r===void 0)throw new Rt(this.id+" withdraw() requires exchange.password or a safePwd parameter");const a=this.safeNumber(n,"fees");if(a===void 0)throw new Rt(this.id+" withdraw() requires a fees parameter");this.checkAddress(s),await this.loadMarkets();const o=this.currency(e);i!==void 0&&(s+="_"+i);const d={amount:this.currencyToPrecision(e,t),currency:o.id,fees:this.currencyToPrecision(e,a),method:"withdraw",receiveAddr:s,safePwd:r},c=await this.spotV1PrivateGetWithdraw(this.extend(d,n)),u=this.parseTransaction(c,o);return this.extend(u,{type:"withdrawal",address:s,addressTo:s,amount:t})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.pageSize=s);const a=await this.spotV1PrivateGetGetWithdrawRecord(this.extend(n,i)),o=this.safeValue(a,"message",{}),d=this.safeValue(o,"datas",{}),c=this.safeValue(d,"list",[]);return this.parseTransactions(c,r,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n={};let r;e!==void 0&&(r=this.currency(e),n.currency=r.id),s!==void 0&&(n.pageSize=s);const a=await this.spotV1PrivateGetGetChargeRecord(this.extend(n,i)),o=this.safeValue(a,"message",{}),d=this.safeValue(o,"datas",{}),c=this.safeValue(d,"list",[]);return this.parseTransactions(c,r,t,s)}async fetchPosition(e,t={}){await this.loadMarkets();let s;e!==void 0&&(s=this.market(e));const i={futuresAccountType:1},n=await this.contractV2PrivateGetPositionsGetPositions(this.extend(i,t)),r=this.safeValue(n,"data",[]),a=this.safeValue(r,0);return this.parsePosition(a,s)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s={futuresAccountType:1},i=await this.contractV2PrivateGetPositionsGetPositions(this.extend(s,t)),n=this.safeValue(i,"data",[]);return this.parsePositions(n,e)}parsePosition(e,t=void 0){const s=this.safeString(e,"marketName");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeString(e,"amount"),r=this.safeNumber(e,"avgPrice"),a=this.safeString(e,"margin"),d=this.safeString(e,"side")==="1"?"long":"short",u=this.safeString(e,"marginMode")==="1"?"isolated":"cross",h=this.safeString(e,"leverage"),l=this.safeNumber(e,"liquidatePrice"),p=this.safeNumber(e,"unrealizedPnl"),m=this.safeNumber(e,"maintainMargin"),g=this.safeNumber(e,"marginRate"),y=this.safeNumber(e,"nominalValue"),b=TU.stringMul(this.safeString(e,"returnRate"),"100"),w=this.safeNumber(e,"createTime");return{info:e,id:void 0,symbol:i,contracts:this.parseNumber(n),contractSize:void 0,entryPrice:r,collateral:void 0,side:d,unrealizedProfit:p,leverage:this.parseNumber(h),percentage:b,marginMode:u,notional:y,markPrice:void 0,liquidationPrice:l,initialMargin:this.parseNumber(a),initialMarginPercentage:void 0,maintenanceMargin:m,maintenanceMarginPercentage:void 0,marginRatio:g,timestamp:w,datetime:this.iso8601(w)}}parseLedgerEntryType(e){const t={1:"realized pnl",2:"commission",3:"funding fee subtract",4:"funding fee addition",5:"insurance clear",6:"transfer in",7:"transfer out",8:"margin addition",9:"margin subtraction",10:"commission addition",11:"bill type freeze",12:"bill type unfreeze",13:"system take over margin",14:"transfer",15:"realized pnl collection",16:"funding fee collection",17:"recommender return commission",18:"by level subtract positions",19:"system add",20:"system subtract",23:"trading competition take over fund",24:"trading contest tickets",25:"return of trading contest tickets",26:"experience expired recall",50:"test register gift",51:"register gift",52:"deposit gift",53:"trading volume gift",54:"awards gift",55:"trading volume gift",56:"awards gift expire",201:"open positions",202:"close positions",203:"take over positions",204:"trading competition take over positions",205:"one way open long",206:"one way open short",207:"one way close long",208:"one way close short",301:"coupon deduction service charge",302:"experience deduction",303:"experience expired"};return this.safeString(t,e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeInteger(e,"createTime");let i;this.safeNumber(e,"isIn")===1?i="increase":i="reduce";let r;const a=this.safeNumber(e,"fee");return a!==void 0&&(r={cost:a,currency:this.safeCurrencyCode(this.safeString(e,"unit"))}),{id:this.safeString(e,"id"),info:e,timestamp:s,datetime:this.iso8601(s),direction:i,account:this.safeString(e,"userId"),referenceId:void 0,referenceAccount:void 0,type:this.parseLedgerEntryType(this.safeInteger(e,"type")),currency:this.safeCurrencyCode(this.safeString(e,"unit")),amount:this.safeNumber(e,"changeAmount"),before:this.safeNumber(e,"beforeAmount"),after:this.safeNumber(e,"available"),status:void 0,fee:r}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new Rt(this.id+" fetchLedger() requires a code argument");await this.loadMarkets();const n=this.currency(e),r={futuresAccountType:1};e!==void 0&&(r.currencyName=n.id),t!==void 0&&(r.startTime=t),s!==void 0&&(r.pageSize=s);const a=await this.contractV2PrivateGetFundGetBill(this.extend(r,i)),o=this.safeValue(a,"data",{}),d=this.safeValue(o,"list",[]);return this.parseLedger(d,n,t,s)}async transfer(e,t,s,i,n={}){await this.loadMarkets();const[r,a]=this.handleMarketTypeAndParams("transfer",void 0,n),[o,d]=this.handleMarginModeAndParams("transfer",a),c=this.currency(e),u=r==="swap",h=this.currencyToPrecision(e,t),l={amount:h};let p,m;if(u)p="contractV2PrivatePostFundTransferFund",s==="spot"||i==="future"?m=1:m=0,l.currencyName=c.id,l.clientId=this.safeString(n,"clientId"),l.side=m;else{if(o==="isolated"||i==="isolated"||s==="isolated"){s==="spot"||i==="isolated"?p="spotV1PrivateGetTransferInLever":p="spotV1PrivateGetTransferOutLever";const y=this.safeString2(n,"marketName","symbol");if(y===void 0)throw new Rt(this.id+" transfer() requires a symbol argument for isolated margin");const b=this.market(y);l.marketName=this.safeSymbol(b.id,b,"_")}else(o==="cross"||i==="cross"||s==="cross")&&(s==="spot"||i==="cross"?p="spotV1PrivateGetTransferInCross":p="spotV1PrivateGetTransferOutCross");l.coin=c.id}const g=await this[p](this.extend(l,d));return this.extend(this.parseTransfer(g,c),{amount:this.parseNumber(h),fromAccount:s,toAccount:i})}parseTransfer(e,t=void 0){const s=this.milliseconds();return{id:this.safeString(e,"data"),timestamp:s,datetime:this.iso8601(s),currency:this.safeCurrencyCode(void 0,"currency"),amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0}}async modifyMarginHelper(e,t,s,i={}){if(i.positionsId===void 0)throw new Rt(this.id+" modifyMarginHelper() requires a positionsId argument in the params");await this.loadMarkets();const n=this.market(e);t=this.amountToPrecision(e,t);const a={positionsId:this.safeString(i,"positionsId"),amount:t,type:s,futuresAccountType:1},o=await this.contractV2PrivatePostPositionsUpdateMargin(this.extend(a,i));return this.extend(this.parseMarginModification(o,n),{amount:this.parseNumber(t)})}parseMarginModification(e,t=void 0){const s=this.safeValue(e,"data",{}),n=this.safeInteger(s,"side")===1?"add":"reduce",a=this.safeInteger(s,"status")===1?"ok":"failed";return{info:e,type:n,amount:void 0,code:t.quote,symbol:t.symbol,status:a}}async addMargin(e,t,s={}){if(s.positionsId===void 0)throw new Rt(this.id+" addMargin() requires a positionsId argument in the params");return await this.modifyMarginHelper(e,t,1,s)}async reduceMargin(e,t,s={}){if(s.positionsId===void 0)throw new Rt(this.id+" reduceMargin() requires a positionsId argument in the params");return await this.modifyMarginHelper(e,t,0,s)}async fetchBorrowRate(e,t={}){await this.loadMarkets();const i={coin:this.currency(e).id},n=await this.spotV1PrivateGetGetLoans(this.extend(i,t)),r=this.milliseconds(),a=this.safeValue(n,"result",[]),o=this.safeValue(a,0,{});return{currency:this.safeCurrencyCode(this.safeString(o,"coinName")),rate:this.safeNumber(o,"interestRateOfDay"),period:this.safeNumber(o,"repaymentDay"),timestamp:r,datetime:this.iso8601(r),info:o}}async fetchBorrowRates(e={}){if(e.coin===void 0)throw new Rt(this.id+" fetchBorrowRates() requires a coin argument in the params");await this.loadMarkets();const s={coin:this.currency(this.safeString(e,"coin")).id},i=await this.spotV1PrivateGetGetLoans(this.extend(s,e)),n=this.milliseconds(),r=this.safeValue(i,"result",[]),a=[];for(let o=0;o<r.length;o++){const d=r[o];a.push({currency:this.safeCurrencyCode(this.safeString(d,"coinName")),rate:this.safeNumber(d,"interestRateOfDay"),period:this.safeNumber(d,"repaymentDay"),timestamp:n,datetime:this.iso8601(n),info:d})}return a}async setPositionMode(e,t=void 0,s={}){if(await this.loadMarkets(),t===void 0)throw new Rt(this.id+" setPositionMode() requires a symbol argument");const i=this.market(t);let n;if(i.swap)n=1;else throw new Bg(this.id+" setPositionMode() supports swap contracts only");const r={marketId:i.id,positionMode:e?2:1,futuresAccountType:n};return await this.contractV2PrivatePostSettingSetPositionsMode(this.extend(r,s))}async borrowMargin(e,t,s=void 0,i={}){await this.loadMarkets();let n;s!==void 0&&(n=this.market(s),s=n.symbol);let r;[r,i]=this.handleMarginModeAndParams("borrowMargin",i),r===void 0&&(s!==void 0?r="isolated":r="cross");const a=this.safeString(i,"safePwd",this.password),o=this.currency(e),d={coin:o.id,amount:this.currencyToPrecision(e,t),safePwd:a};let c;if(r==="isolated"){if(s===void 0)throw new Rt(this.id+" borrowMargin() requires a symbol argument for isolated margin");const l=this.market(s);d.marketName=this.safeSymbol(l.id,l,"_"),c="spotV1PrivateGetBorrow"}else r==="cross"&&(c="spotV1PrivateGetDoCrossLoan");const u=await this[c](this.extend(d,i)),h=this.parseMarginLoan(u,o);return this.extend(h,{amount:t,symbol:s})}parseMarginLoan(e,t=void 0){return{id:void 0,currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},n=void 0,r=void 0){const[a,o,d]=t;let c=this.implodeHostname(this.urls.api[a][o][d]);if(d==="public")e==="getFeeInfo"?c=this.implodeHostname(this.urls.api[a][o].private)+"/"+e:c+="/"+o+"/"+e,Object.keys(i).length&&(c+="?"+this.urlencode(i));else if(a==="contract"){const u=this.milliseconds(),h=this.iso8601(u);let l=h+s+"/Server/api/"+o+"/"+e;if(i=this.keysort(i),n={"ZB-APIKEY":this.apiKey,"ZB-TIMESTAMP":h},c+="/"+o+"/"+e,s==="POST")n["Content-Type"]="application/json",r=this.json(i),l+=this.urlencode(i);else if(Object.keys(i).length){const g=this.urlencode(i);c+="?"+g,l+=g}const p=this.hash(this.encode(this.secret),"sha1"),m=this.hmac(this.encode(l),this.encode(p),"sha256","base64");n["ZB-SIGN"]=m}else{let u=this.keysort(this.extend({method:e,accesskey:this.apiKey},i));const h=this.nonce();u=this.keysort(u);const l=this.rawencode(u),p=this.hash(this.encode(this.secret),"sha1"),g="sign="+this.hmac(this.encode(l),this.encode(p),"md5")+"&reqTime="+h.toString();c+="/"+e+"?"+l+"&"+g}return{url:c,method:s,body:r,headers:n}}handleErrors(e,t,s,i,n,r,a,o,d){if(a!==void 0&&r[0]==="{"){const c=this.id+" "+r;if(this.throwBroadlyMatchedException(this.exceptions.broad,r,c),"code"in a){const h=this.safeString(a,"code");if(this.throwExactlyMatchedException(this.exceptions.exact,h,c),h!=="1000"&&h!=="10000")throw new Ve(c)}const u=this.safeValue(a,"result");if(u!==void 0&&!u)throw this.safeString(a,"message")==="\u670D\u52A1\u7AEF\u5FD9\u788C"?new so(c):new Ve(c)}}};const OU=jl;var IU=class extends OU{describe(){return this.deepExtend(super.describe(),{id:"zipmex",name:"Zipmex",countries:["AU","SG","TH","ID"],certified:!1,pro:!0,urls:{logo:"https://user-images.githubusercontent.com/1294454/146103275-c39a34d9-68a4-4cd2-b1f1-c684548d311b.jpg",test:void 0,api:{public:"https://apws.zipmex.com:8443/AP",private:"https://apws.zipmex.com:8443/AP"},www:"https://zipmex.com/",referral:"https://trade.zipmex.com/global/accounts/sign-up?aff=KLm7HyCsvN",fees:"https://zipmex.com/fee-schedule"},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.002"),maker:this.parseNumber("0.002")}}})}};class uC extends Array{constructor(e=void 0){super(),Object.defineProperty(this,"maxSize",{__proto__:null,value:e,writable:!0})}clear(){this.length=0}}class fC extends uC{constructor(e=void 0){super(e),Object.defineProperty(this,"nestedNewUpdatesBySymbol",{__proto__:null,value:!1,writable:!0}),Object.defineProperty(this,"newUpdatesBySymbol",{__proto__:null,value:{},writable:!0}),Object.defineProperty(this,"clearUpdatesBySymbol",{__proto__:null,value:{},writable:!0}),Object.defineProperty(this,"allNewUpdates",{__proto__:null,value:0,writable:!0}),Object.defineProperty(this,"clearAllUpdates",{__proto__:null,value:!1,writable:!0})}getLimit(e,t){let s;return e===void 0?(s=this.allNewUpdates,this.clearAllUpdates=!0):(s=this.newUpdatesBySymbol[e],s!==void 0&&this.nestedNewUpdatesBySymbol&&(s=s.size),this.clearUpdatesBySymbol[e]=!0),s===void 0?t:t!==void 0?Math.min(s,t):s}append(e){this.maxSize&&this.length===this.maxSize&&this.shift(),this.push(e),this.clearAllUpdates&&(this.clearAllUpdates=!1,this.clearUpdatesBySymbol={},this.allNewUpdates=0,this.newUpdatesBySymbol={}),this.clearUpdatesBySymbol[e.symbol]&&(this.clearUpdatesBySymbol[e.symbol]=!1,this.newUpdatesBySymbol[e.symbol]=0),this.newUpdatesBySymbol[e.symbol]=(this.newUpdatesBySymbol[e.symbol]||0)+1,this.allNewUpdates=(this.allNewUpdates||0)+1}}class xU extends uC{constructor(e=void 0){super(e),Object.defineProperty(this,"hashmap",{__proto__:null,value:{},writable:!0}),Object.defineProperty(this,"sizeTracker",{__proto__:null,value:new Set,writable:!0}),Object.defineProperty(this,"newUpdates",{__proto__:null,value:0,writable:!0}),Object.defineProperty(this,"clearUpdates",{__proto__:null,value:!1,writable:!0})}getLimit(e,t){return this.clearUpdates=!0,t===void 0?this.newUpdates:Math.min(this.newUpdates,t)}append(e){if(e[0]in this.hashmap){const t=this.hashmap[e[0]];if(t!==e)for(const s in e)t[s]=e[s]}else{if(this.hashmap[e[0]]=e,this.maxSize&&this.length===this.maxSize){const t=this.shift();delete this.hashmap[t[0]]}this.push(e)}this.clearUpdates&&(this.clearUpdates=!1,this.sizeTracker.clear()),this.sizeTracker.add(e[0]),this.newUpdates=this.sizeTracker.size}}class _U extends fC{constructor(e=void 0){super(e),this.nestedNewUpdatesBySymbol=!0,Object.defineProperty(this,"hashmap",{__proto__:null,value:{},writable:!0})}append(e){const t=this.hashmap[e.symbol]=this.hashmap[e.symbol]||{};if(e.id in t){const r=t[e.id];if(r!==e)for(const o in e)r[o]=e[o];e=r;const a=this.findIndex(o=>o.id===e.id);this.splice(a,1)}else t[e.id]=e;if(this.maxSize&&this.length===this.maxSize){const r=this.shift();delete this.hashmap[r.symbol][r.id]}this.push(e),this.clearAllUpdates&&(this.clearAllUpdates=!1,this.clearUpdatesBySymbol={},this.allNewUpdates=0,this.newUpdatesBySymbol={}),this.newUpdatesBySymbol[e.symbol]===void 0&&(this.newUpdatesBySymbol[e.symbol]=new Set),this.clearUpdatesBySymbol[e.symbol]&&(this.clearUpdatesBySymbol[e.symbol]=!1,this.newUpdatesBySymbol[e.symbol].clear());const s=this.newUpdatesBySymbol[e.symbol],i=s.size;s.add(e.id);const n=s.size;this.allNewUpdates=(this.allNewUpdates||0)+(n-i)}}var rt={ArrayCache:fC,ArrayCacheByTimestamp:xU,ArrayCacheBySymbolById:_U};const CU=A_,{ArrayCache:MU,ArrayCacheByTimestamp:PU,ArrayCacheBySymbolById:AU,NotSupported:BU,AuthenticationError:EU}=rt;var NU=class extends CU{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOHLCV:!0,watchOrderBook:!0,watchTicker:!0,watchTrades:!0,watchBalance:!0,watchOrders:!0},urls:{api:{ws:{public:"wss://realtime.aax.com/marketdata/v2/",private:"wss://stream.aax.com/notification/v2/"}}},options:{OHLCVLimit:1e3,tradesLimit:1e3,ordersLimit:1e3,myTradesLimit:1e3}})}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r="candles",a=this.market(e);e=a.symbol;const o=this.timeframes[t],d=a.id+"@"+o+"_"+r,c=this.urls.api.ws.public,u={e:"subscribe",stream:d},h=this.deepExtend(u,n),l=await this.watch(c,d,h,d);return this.newUpdates&&(i=l.getLimit(e,i)),this.filterBySinceLimit(l,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"e"),i=s.split("@"),n=this.safeString(i,0),r=this.safeString(i,1),o=this.safeMarket(n).symbol,d=[this.safeTimestamp(t,"s"),this.safeNumber(t,"o"),this.safeNumber(t,"h"),this.safeNumber(t,"l"),this.safeNumber(t,"c"),this.safeNumber(t,"v")],c=r.split("_"),u=this.safeString(c,0),h=this.findTimeframe(u);this.ohlcvs[o]=this.safeValue(this.ohlcvs,o,{});let l=this.safeValue(this.ohlcvs[o],h);if(l===void 0){const p=this.safeInteger(this.options,"OHLCVLimit",1e3);l=new PU(p),this.ohlcvs[o][h]=l}l.append(d),e.resolve(l,s)}async watchTicker(e,t={}){const s="tickers";await this.loadMarkets();const n=this.market(e).id+"@"+s,r=this.urls.api.ws.public,a={e:"subscribe",stream:s},o=this.extend(a,t);return await this.watch(r,n,o,s)}handleTickers(e,t){const s=this.safeString(t,"e"),i=this.safeInteger(t,"t"),n={timestamp:i,datetime:this.iso8601(i)},r=this.parseTickers(this.safeValue(t,"tickers",[]),void 0,n),a=Object.keys(r);for(let o=0;o<a.length;o++){const d=a[o];if(d in this.markets){const c=this.market(d),u=r[d];this.tickers[d]=u;const h=c.id+"@"+s;e.resolve(u,h)}}}async watchTrades(e,t=void 0,s=void 0,i={}){const n="trade";await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=r.id+"@"+n,o=this.urls.api.ws.public,d={e:"subscribe",stream:a},c=this.extend(d,i),u=await this.watch(o,a,c,a);return this.newUpdates&&(s=u.getLimit(e,s)),this.filterBySinceLimit(u,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeString(t,"e"),i=s.split("@"),n=this.safeString(i,0),r=this.safeMarket(n),a=r.symbol,o=this.parseTrade(t,r);let d=this.safeValue(this.trades,a);if(d===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);d=new MU(c),this.trades[a]=d}d.append(o),e.resolve(d,s)}async watchOrderBook(e,t=void 0,s={}){const i="book";await this.loadMarkets();const n=this.market(e);if(t=t===void 0?20:t,t!==20&&t!==50)throw new BU(this.id+" watchOrderBook() accepts limit values of 20 or 50 only");const r=n.id+"@"+i+"_"+t.toString(),a=this.urls.api.ws.public,o={e:"subscribe",stream:r},d=this.extend(o,s);return(await this.watch(a,r,d,r)).limit()}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBook(e,t){const s=this.safeString(t,"e"),[i,n]=s.split("@"),r=n.split("_"),o=this.safeMarket(i).symbol,d=this.safeString(r,1),c=parseInt(d),u=this.safeInteger(t,"t"),h=this.parseOrderBook(t,o,u);let l;o in this.orderbooks?(l=this.orderbooks[o],l.reset(h)):(l=this.orderBook(h,c),this.orderbooks[o]=l),e.resolve(l,s)}requestId(){const e=this.sum(this.safeInteger(this.options,"reqid",0),1);return this.options.reqid=e,e}async handshake(e={}){const t=this.urls.api.ws.private,s=this.client(t),i="handshake",n=s.future(i);if(this.safeValue(s.subscriptions,i)===void 0){const a=this.requestId(),o={event:"#"+i,data:{},cid:a},d=this.extend(o,e),c=a.toString(),u=await this.watch(t,c,d,i);n.resolve(u)}return await n}async authenticate(e={}){const t=this.urls.api.ws.private,s=this.client(t),i="login",n=s.future(i);if(this.safeValue(s.subscriptions,i)===void 0){const a=this.milliseconds(),o=a.toString()+":"+this.apiKey,d=this.hmac(this.encode(o),this.encode(this.secret)),c=this.requestId(),u={event:i,data:{apiKey:this.apiKey,nonce:a,signature:d},cid:c},h=this.extend(u,e),l=c.toString(),p=await this.watch(t,l,h,i),m=this.safeValue(p,"data",{});if(this.safeValue(m,"isAuthenticated",!1))n.resolve(p);else throw new EU(this.id+" "+this.json(p))}return await n}async watchBalance(e={}){await this.loadMarkets(),await this.handshake(e);const t=await this.authenticate(e),s=this.safeValue(t,"data",{}),i=this.safeString(s,"uid"),n=this.urls.api.ws.private,r=this.safeString2(this.options,"userId","userID",i),a=this.safeString2(e,"userId","userID",r),o=this.safeString2(this.options,"watchBalance","defaultType","spot"),d=this.safeString(e,"type",o),c=this.omit(e,["userId","userID","type"]),u="user/"+a,h=d+":balance",l=this.requestId(),p={event:"#subscribe",data:{channel:u},cid:l},m=this.deepExtend(p,c);return await this.watch(n,h,m,u)}handleBalance(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(s,"purseType"),n=this.safeValue(this.options,"accountsById",{}),r=this.safeString(n,i),a=r+":balance",o=this.safeString(s,"currency"),d=this.safeCurrencyCode(o),c=this.account();c.free=this.safeString(s,"available"),c.used=this.safeString(s,"unavailable"),r in this.balance||(this.balance[r]={}),this.balance[r][d]=c,this.balance[r]=this.safeBalance(this.balance[r]),e.resolve(this.balance[r],a)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.handshake(i);const n=await this.authenticate(i),r=this.safeValue(n,"data",{}),a=this.safeString(r,"uid"),o=this.urls.api.ws.private,d=this.safeString2(this.options,"userId","userID",a),c=this.safeString2(i,"userId","userID",d),u=this.omit(i,["userId","userID"]),h="user/"+c;let l="orders";e!==void 0&&(e=this.symbol(e),l+=":"+e);const p=this.requestId(),m={event:"#subscribe",data:{channel:h},cid:p},g=this.deepExtend(m,u),y=await this.watch(o,l,g,l);return this.newUpdates&&(s=y.getLimit(e,s)),this.filterBySymbolSinceLimit(y,e,t,s,!0)}handleOrder(e,t){const s="orders",i=this.safeValue(t,"data"),n=this.safeValue(i,"order"),r=n===void 0?this.parseOrder(i):this.parseOrder(n),a=this.safeString(r,"symbol"),o=this.safeString(r,"id");if(a!==void 0){if(this.orders===void 0){const l=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new AU(l)}const d=this.orders,c=this.safeValue(d.hashmap,a,{}),u=this.safeValue(c,o);if(u!==void 0){const l=this.safeValue(u,"fee");l!==void 0&&(r.fee=l);const p=this.safeValue(u,"fees");p!==void 0&&(r.fees=p),r.trades=this.safeValue(u,"trades"),r.timestamp=this.safeInteger(u,"timestamp"),r.datetime=this.safeString(u,"datetime")}d.append(r),e.resolve(this.orders,s);const h=s+":"+a;e.resolve(this.orders,h)}}handleSystemStatus(e,t){return t}handleSubscriptionStatus(e,t){const s=this.safeString(t,"rid");return e.resolve(t,s),t}async pong(e,t){const s="#2";await e.send(s)}handlePing(e,t){this.spawn(this.pong,e,t)}handleNotification(e,t){const s=this.safeValue(t,"event"),i={USER_FUNDS:this.handleBalance,USER_BALANCE:this.handleBalance,SPOT:this.handleOrder,FUTURES:this.handleOrder},n=this.safeValue(i,s);if(n!==void 0)return n.call(this,e,t)}handleMessage(e,t){if(typeof t=="string")t==="#1"&&this.handlePing(e,t);else{const s=this.safeString(t,"event"),i=this.safeString(t,"e");if(s==="#publish"){const n=this.safeValue(t,"data",{}),r=this.safeValue(n,"data",{});this.handleNotification(e,r)}else if(i===void 0)this.safeString(t,"rid")!==void 0&&this.handleSubscriptionStatus(e,t);else{const n=i.split("@"),r=n.length,a={reply:this.handleSubscriptionStatus,system:this.handleSystemStatus,book:this.handleOrderBook,trade:this.handleTrades,empty:void 0,tickers:this.handleTickers,candles:this.handleOHLCV,done:this.handleOrder};let o;if(r>1){const c=this.safeString(n,1).split("_"),u=this.safeString(c,0),h=this.safeString(c,1);o=this.safeValue2(a,u,h)}else{const d=this.safeString(n,0);o=this.safeValue(a,d)}if(o!==void 0)return o.call(this,e,t)}}}};const VU=B_,{AuthenticationError:qU}=de,{ArrayCache:LU,ArrayCacheByTimestamp:RU,ArrayCacheBySymbolById:FU}=rt;var DU=class extends VU{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!1,watchTrades:!0},urls:{api:{ws:{public:"wss://ascendex.com:443/api/pro/v2/stream",private:"wss://ascendex.com:443/{accountGroup}/api/pro/v2/stream"}},test:{ws:{public:"wss://api-test.ascendex-sandbox.com:443/api/pro/v2/stream",private:"wss://api-test.ascendex-sandbox.com:443/{accountGroup}/api/pro/v2/stream"}}},options:{tradesLimit:1e3,ordersLimit:1e3,OHLCVLimit:1e3,categoriesAccount:{cash:"spot",futures:"swap",margin:"margin"}}})}async watchPublic(e,t={}){const s=this.urls.api.ws.public,n={id:this.nonce().toString(),op:"sub"},r=this.extend(n,t);return await this.watch(s,e,r,e)}async watchPrivate(e,t,s={}){await this.loadAccounts();const i=this.safeString(this.options,"account-group");let n=this.urls.api.ws.private;n=this.implodeParams(n,{accountGroup:i});const a={id:this.nonce().toString(),op:"sub",ch:e},o=this.extend(a,s);return await this.authenticate(n,s),await this.watch(n,t,o,e)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol,(i===void 0||i>1440)&&(i=100);const o="bar:"+this.timeframes[t]+":"+r.id;n={ch:o};const d=await this.watchPublic(o,n);return this.newUpdates&&(i=d.getLimit(e,i)),this.filterBySinceLimit(d,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"s"),i=this.safeSymbol(s),n=this.safeString(t,"m"),r=this.safeValue(t,"data",{}),a=this.safeString(r,"i"),o=n+":"+a+":"+s,d=this.findTimeframe(a),c=this.market(i),u=this.parseOHLCV(t,c);this.ohlcvs[i]=this.safeValue(this.ohlcvs,i,{});let h=this.safeValue(this.ohlcvs[i],d);if(h===void 0){const l=this.safeInteger(this.options,"OHLCVLimit",1e3);h=new RU(l),this.ohlcvs[i][d]=h}return h.append(u),e.resolve(h,o),t}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="trades:"+n.id;i=this.extend(i,{ch:r});const a=await this.watchPublic(r,i);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySinceLimit(a,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeString(t,"symbol"),i=this.safeSymbol(s),r=this.safeString(t,"m")+":"+s,a=this.market(i);let o=this.safeValue(t,"data");o===void 0&&(o=[]);const d=this.parseTrades(o,a);let c=this.safeValue(this.trades,i);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new LU(u)}for(let u=0;u<d.length;u++)c.append(d[u]);this.trades[i]=c,e.resolve(c,r)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n="depth-realtime:"+this.market(e).id;return s=this.extend(s,{ch:n}),(await this.watchPublic(n,s)).limit()}async watchOrderBookSnapshot(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n="depth-snapshot-realtime",r=n+":"+i.id;return s=this.extend(s,{action:n,args:{symbol:i.id},op:"req"}),(await this.watchPublic(r,s)).limit()}handleOrderBookSnapshot(e,t){const s=this.safeString(t,"symbol"),i=this.safeSymbol(s),r=this.safeString(t,"m")+":"+i,a=this.orderbooks[i],o=this.safeValue(t,"data"),d=this.parseOrderBook(o,i);d.nonce=this.safeInteger(o,"seqnum"),a.reset(d);const c=a.cache;for(let u=0;u<c.length;u++){const h=c[u];this.handleOrderBookMessage(e,h,a)}this.orderbooks[i]=a,e.resolve(a,r)}handleOrderBook(e,t){const s=this.safeString(t,"m"),i=this.safeString(t,"symbol"),n=this.safeSymbol(i),r=s+":"+i;let a=this.safeValue(this.orderbooks,n);a===void 0&&(a=this.orderBook({})),a.nonce===void 0?a.cache.push(t):(this.handleOrderBookMessage(e,t,a),e.resolve(a,r))}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s){const i=this.safeValue(t,"data",{}),n=this.safeInteger(i,"seqnum");if(n>s.nonce){const r=this.safeValue(i,"asks",[]),a=this.safeValue(i,"bids",[]);this.handleDeltas(s.asks,r),this.handleDeltas(s.bids,a),s.nonce=n;const o=this.safeInteger(i,"ts");s.timestamp=o,s.datetime=this.iso8601(o)}return s}async watchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("watchBalance",void 0,e);let i,n;if(t==="spot"||t==="margin"){const r=this.safeValue(this.options,"accountCategories",{});let a=this.safeString(r,t,"cash");a=a.toUpperCase(),i="order:"+a,n="balance:"+t}else i="futures-account-update",n="balance:swap";return await this.watchPrivate(i,n,s)}handleBalance(e,t){const s=this.safeString(t,"m");let i,n;if(s==="order"||s==="futures-order"){const a=this.safeValue(t,"data"),o=this.safeString(a,"s"),d=this.safeMarket(o),c=this.account();c.free=this.safeString(a,"bab"),c.total=this.safeString(a,"btb");const u=this.account();u.free=this.safeString(a,"qab"),u.total=this.safeString(a,"qtb"),d.contract?(n="swap",i=this.safeValue(this.balance,n,{})):(n=d.type,i=this.safeValue(this.balance,n,{})),i[d.base]=c,i[d.quote]=u}else{const a=this.safeStringLower2(t,"ac","at"),o=this.safeValue(this.options,"categoriesAccount");n=this.safeString(o,a,"spot"),i=this.safeValue(this.balance,n,{});const d=this.safeValue(t,"data");let c;d===void 0?c=this.safeValue(t,"col"):c=[d];for(let u=0;u<c.length;u++){const h=c[u],l=this.safeCurrencyCode(this.safeString(h,"a")),p=this.account();p.free=this.safeString(h,"ab"),p.total=this.safeString2(h,"tb","b"),i[l]=p}}const r="balance:"+n;e.resolve(this.safeBalance(i),r)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e),e=n.symbol);const[r,a]=this.handleMarketTypeAndParams("watchOrders",n,i);let o,d;if(r!=="spot")d="futures-order",o="order:FUTURES";else{const u=this.safeValue(this.options,"accountCategories",{});let h=this.safeString(u,r,"cash");h=h.toUpperCase(),o="order:"+h,d=o}e!==void 0&&(o=o+":"+e);const c=await this.watchPrivate(d,o,a);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}handleOrder(e,t){const i="order:"+this.safeString(t,"ac"),n=this.safeValue(t,"data",t),r=this.parseWsOrder(n);if(this.orders===void 0){const d=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new FU(d)}const a=this.orders;a.append(r);const o=i+":"+r.symbol;e.resolve(a,o),e.resolve(a,i)}parseWsOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString(e,"st")),i=this.safeString(e,"s"),n=this.safeInteger(e,"t"),r=this.safeSymbol(i,t,"/"),a=this.safeInteger(e,"t"),o=this.safeString(e,"p"),d=this.safeString(e,"q"),c=this.safeString(e,"ap"),u=this.safeString(e,"cfq"),h=this.safeString(e,"orderId"),l=this.safeStringLower(e,"ot"),p=this.safeStringLower(e,"sd"),m=this.safeNumber(e,"cf");let g;if(m!==void 0){const b=this.safeString(e,"fa"),w=this.safeCurrencyCode(b);g={cost:m,currency:w}}const y=this.parseNumber(this.omitZero(this.safeString(e,"sp")));return this.safeOrder({info:e,id:h,clientOrderId:void 0,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:a,symbol:r,type:l,timeInForce:void 0,postOnly:void 0,side:p,price:o,stopPrice:y,amount:d,cost:void 0,average:c,filled:u,remaining:void 0,status:s,fee:g,trades:void 0},t)}handleErrorMessage(e,t){const s=this.safeInteger(t,"code");try{if(s!==void 0){const i=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,i);const n=this.safeValue(t,"message");n!==void 0&&this.throwBroadlyMatchedException(this.exceptions.broad,n,i)}}catch(i){if(i instanceof qU){e.reject(i,"authenticated");const n="auth";return n in e.subscriptions&&delete e.subscriptions[n],!1}else e.reject(i)}return t}handleAuthenticate(e,t){return e.futures.authenticated.resolve(1),t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;const s=this.safeString(t,"m"),i={ping:this.handlePing,auth:this.handleAuthenticate,sub:this.handleSubscriptionStatus,"depth-realtime":this.handleOrderBook,"depth-snapshot-realtime":this.handleOrderBookSnapshot,trades:this.handleTrades,bar:this.handleOHLCV,balance:this.handleBalance,"futures-account-update":this.handleBalance},n=this.safeValue(i,s);return n!==void 0&&n.call(this,e,t),(s==="order"||s==="futures-order")&&(this.handleOrder(e,t),s==="order"&&this.handleBalance(e,t)),t}handleSubscriptionStatus(e,t){return this.safeString(t,"ch","").indexOf("depth-realtime")>-1&&this.handleOrderBookSubscription(e,t),t}handleOrderBookSubscription(e,t){const n=this.safeString(t,"ch").split(":")[1],r=this.safeSymbol(n);r in this.orderbooks&&delete this.orderbooks[r],this.orderbooks[r]=this.orderBook({}),this.spawn(this.watchOrderBookSnapshot,r)}async pong(e,t){await e.send({op:"pong",hp:this.safeInteger(t,"hp")})}handlePing(e,t){this.spawn(this.pong,e,t)}async authenticate(e,t={}){this.checkRequiredCredentials();const s="authenticated",i=this.client(e);let n=this.safeValue(i.futures,s);if(n===void 0){n=i.future("authenticated"),i.future(s);const r=this.milliseconds().toString(),a=e.split("/"),o=a.length,d=this.safeString(a,o-1),c=this.safeString(a,o-2),u=r+"+"+c+"/"+d,h=this.base64ToBinary(this.secret),l=this.hmac(this.encode(u),h,"sha256","base64"),p={op:"auth",id:this.nonce().toString(),t:r,key:this.apiKey,sig:l};this.spawn(this.watch,e,s,this.extend(p,t))}return await n}};const HU=$l,{ArrayCache:GU,ArrayCacheByTimestamp:UU}=rt;var Nb=class extends HU{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchOrderBook:!0,watchBalance:!1,watchOHLCV:!0},urls:{api:{ws:"wss://api.hitbtc.com/api/2/ws"}},options:{tradesLimit:1e3,methods:{orderbook:"subscribeOrderbook",ticker:"subscribeTicker",trades:"subscribeTrades",ohlcv:"subscribeCandles"}}})}async watchPublic(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.marketId(e),r=this.urls.api.ws;let a=t+":"+n;s!==void 0&&(a+=":"+s);const o=this.safeValue(this.options,"methods",{}),d=this.safeString(o,t,t),c=this.nonce(),u={method:d,params:{symbol:n},id:c},h=this.deepExtend(u,i);return await this.watch(r,a,h,a)}async watchOrderBook(e,t=void 0,s={}){return(await this.watchPublic(e,"orderbook",void 0,s)).limit()}handleOrderBookSnapshot(e,t){const s=this.safeValue(t,"params",{}),i=this.safeString(s,"symbol"),r=this.safeMarket(i).symbol,a=this.parse8601(this.safeString(s,"timestamp")),o=this.safeInteger(s,"sequence");r in this.orderbooks&&delete this.orderbooks[r];const d=this.parseOrderBook(s,r,a,"bid","ask","price","size"),c=this.orderBook(d);c.nonce=o,this.orderbooks[r]=c;const u="orderbook:"+i;e.resolve(c,u)}handleOrderBookUpdate(e,t){const s=this.safeValue(t,"params",{}),i=this.safeString(s,"symbol"),r=this.safeMarket(i).symbol;if(r in this.orderbooks){const a=this.parse8601(this.safeString(s,"timestamp")),o=this.safeInteger(s,"sequence"),d=this.orderbooks[r],c=this.safeValue(s,"ask",[]),u=this.safeValue(s,"bid",[]);this.handleDeltas(d.asks,c),this.handleDeltas(d.bids,u),d.timestamp=a,d.datetime=this.iso8601(a),d.nonce=o,this.orderbooks[r]=d;const h="orderbook:"+i;e.resolve(d,h)}}handleDelta(e,t){const s=this.safeFloat(t,"price"),i=this.safeFloat(t,"size");e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchTicker(e,t={}){return await this.watchPublic(e,"ticker",void 0,t)}handleTicker(e,t){const s=this.safeValue(t,"params"),i=this.safeValue(s,"symbol"),n=this.safeMarket(i),r=n.symbol,a=this.parseTicker(s,n);this.tickers[r]=a;const d=this.safeValue(t,"method")+":"+i;e.resolve(a,d)}async watchTrades(e,t=void 0,s=void 0,i={}){const n=await this.watchPublic(e,"trades",void 0,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"params",{}),i=this.safeValue(s,"data",[]),n=this.safeString(s,"symbol"),r=this.safeMarket(n),a=r.symbol,o="trades:"+n,d=this.safeInteger(this.options,"tradesLimit",1e3);let c=this.safeValue(this.trades,a);if(c===void 0&&(c=new GU(d),this.trades[a]=c),Array.isArray(i)){const u=this.parseTrades(i,r);for(let h=0;h<u.length;h++)c.append(u[h])}else{const u=this.parseTrade(t,r);c.append(u)}return e.resolve(c,o),t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){const r=this.timeframes[t],a={params:{period:r}},o=this.deepExtend(a,n),d=await this.watchPublic(e,"ohlcv",r,o);return this.newUpdates&&(i=d.getLimit(e,i)),this.filterBySinceLimit(d,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"params",{}),i=this.safeValue(s,"data",[]),n=this.safeString(s,"symbol"),r=this.safeMarket(n),a=r.symbol,o=this.safeString(s,"period"),d=this.findTimeframe(o),c="ohlcv:"+n+":"+o;for(let u=0;u<i.length;u++){const h=i[u],l=this.parseOHLCV(h,r);this.ohlcvs[a]=this.safeValue(this.ohlcvs,a,{});let p=this.safeValue(this.ohlcvs[a],d);if(p===void 0){const m=this.safeInteger(this.options,"OHLCVLimit",1e3);p=new UU(m),this.ohlcvs[a][d]=p}p.append(l),e.resolve(p,c)}return t}handleNotification(e,t){return t}handleMessage(e,t){const s={snapshotOrderbook:this.handleOrderBookSnapshot,updateOrderbook:this.handleOrderBookUpdate,ticker:this.handleTicker,snapshotTrades:this.handleTrades,updateTrades:this.handleTrades,snapshotCandles:this.handleOHLCV,updateCandles:this.handleOHLCV},i=this.safeString(t,"method"),n=this.safeValue(s,i);n===void 0?this.handleNotification(e,t):n.call(this,e,t)}};const $U=Nb;var jU=class extends $U{describe(){return this.deepExtend(super.describe(),{id:"bequant",name:"Bequant",countries:["MT"],pro:!0,urls:{logo:"https://user-images.githubusercontent.com/1294454/55248342-a75dfe00-525a-11e9-8aa2-05e9dca943c6.jpg",api:{public:"https://api.bequant.io",private:"https://api.bequant.io"},www:"https://bequant.io",doc:["https://api.bequant.io/"],fees:["https://bequant.io/fees-and-limits"],referral:"https://bequant.io"}})}};const WU=Gu,zU=Se,{ExchangeError:Ng}=de,{ArrayCache:KU,ArrayCacheByTimestamp:XU,ArrayCacheBySymbolById:jT}=rt;var Wl=class extends WU{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0},urls:{test:{ws:{spot:"wss://testnet.binance.vision/ws",margin:"wss://testnet.binance.vision/ws",future:"wss://stream.binancefuture.com/ws",delivery:"wss://dstream.binancefuture.com/ws"}},api:{ws:{spot:"wss://stream.binance.com:9443/ws",margin:"wss://stream.binance.com:9443/ws",future:"wss://fstream.binance.com/ws",delivery:"wss://dstream.binance.com/ws"}}},options:{streamLimits:{spot:1024,margin:1024,future:200,delivery:200},streamBySubscriptionsHash:{},streamIndex:-1,watchOrderBookRate:100,tradesLimit:1e3,ordersLimit:1e3,OHLCVLimit:1e3,requestId:{},watchOrderBookLimit:1e3,watchTrades:{name:"trade"},watchTicker:{name:"ticker"},watchBalance:{fetchBalanceSnapshot:!1,awaitBalanceSnapshot:!0},wallet:"wb",listenKeyRefreshRate:12e5,ws:{cost:5}}})}requestId(e){const t=this.safeValue(this.options,"requestId",{}),s=this.safeInteger(t,e,0),i=this.sum(s,1);return this.options.requestId[e]=i,i}stream(e,t){const s=this.safeValue(this.options,"streamBySubscriptionsHash",{});let i=this.safeString(s,t);if(i===void 0){let n=this.safeInteger(this.options,"streamIndex",-1);const r=this.safeValue(this.options,"streamLimits"),a=this.safeInteger(r,e);n=n+1,n===a&&(n=0),this.options.streamIndex=n,i=this.numberToString(n),s[t]=i}return i}onError(e,t){this.options.streamBySubscriptionsHash={},this.options.streamIndex=-1,super.onError(e,t)}onClose(e,t){this.options.streamBySubscriptionsHash={},this.options.streamIndex=-1,super.onClose(e,t)}async watchOrderBook(e,t=void 0,s={}){if(t!==void 0&&t!==5&&t!==10&&t!==20&&t!==50&&t!==100&&t!==500&&t!==1e3)throw new Ng(this.id+" watchOrderBook limit argument must be undefined, 5, 10, 20, 50, 100, 500 or 1000");await this.loadMarkets();const i=this.safeString2(this.options,"watchOrderBook","defaultType","spot"),n=this.safeString(s,"type",i),r=this.omit(s,"type"),a=this.market(e),o="depth",d=a.lowercaseId+"@"+o,c=this.urls.api.ws[n]+"/"+this.stream(n,d),u=this.requestId(c),h=this.safeString(this.options,"watchOrderBookRate","100"),l={method:"SUBSCRIBE",params:[d+"@"+h+"ms"],id:u},p={id:u.toString(),messageHash:d,name:o,symbol:a.symbol,method:this.handleOrderBookSubscription,limit:t,type:n,params:s},m=this.extend(l,r);return(await this.watch(c,d,m,d,p)).limit()}async fetchOrderBookSnapshot(e,t,s){const i=this.safeInteger(this.options,"watchOrderBookLimit",1e3),n=this.safeValue(s,"type"),r=this.safeString(s,"symbol"),a=this.safeString(s,"messageHash"),o=this.safeInteger(s,"limit",i),d=this.safeValue(s,"params"),c=await this.fetchOrderBook(r,o,d),u=this.safeValue(this.orderbooks,r);if(u===void 0)return;u.reset(c);const h=u.cache;for(let l=0;l<h.length;l++){const p=h[l],m=this.safeInteger(p,"U"),g=this.safeInteger(p,"u"),y=this.safeInteger(p,"pu");if(n==="future"){if(g<u.nonce)continue;(m<=u.nonce&&g>=u.nonce||y===u.nonce)&&this.handleOrderBookMessage(e,p,u)}else{if(g<=u.nonce)continue;m-1<=u.nonce&&g-1>=u.nonce&&this.handleOrderBookMessage(e,p,u)}}this.orderbooks[r]=u,e.resolve(u,a)}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s){const i=this.safeInteger(t,"u");this.handleDeltas(s.asks,this.safeValue(t,"a",[])),this.handleDeltas(s.bids,this.safeValue(t,"b",[])),s.nonce=i;const n=this.safeInteger(t,"E");return s.timestamp=n,s.datetime=this.iso8601(n),s}handleOrderBook(e,t){const s=this.safeString(t,"s"),i=this.safeMarket(s),n=i.symbol,r="depth",a=i.lowercaseId+"@"+r,o=this.safeValue(this.orderbooks,n);if(o===void 0)return;const d=this.safeInteger(o,"nonce");if(d===void 0)o.cache.push(t);else try{const c=this.safeInteger(t,"U"),u=this.safeInteger(t,"u"),h=this.safeInteger(t,"pu");if(h===void 0){if(u>o.nonce){const l=this.safeInteger(o,"timestamp");let p;if(l===void 0?p=c-1<=o.nonce&&u-1>=o.nonce:p=c-1===o.nonce,p)this.handleOrderBookMessage(e,t,o),d<o.nonce&&e.resolve(o,a);else throw new Ng(this.id+" handleOrderBook received an out-of-order nonce")}}else if(u>=o.nonce)if(c<=o.nonce||h===o.nonce)this.handleOrderBookMessage(e,t,o),d<=o.nonce&&e.resolve(o,a);else throw new Ng(this.id+" handleOrderBook received an out-of-order nonce")}catch(c){delete this.orderbooks[n],delete e.subscriptions[a],e.reject(c,a)}}handleOrderBookSubscription(e,t,s){const i=this.safeInteger(this.options,"watchOrderBookLimit",1e3),n=this.safeString(s,"symbol"),r=this.safeInteger(s,"limit",i);n in this.orderbooks&&delete this.orderbooks[n],this.orderbooks[n]=this.orderBook({},r),this.spawn(this.fetchOrderBookSnapshot,e,t,s)}handleSubscriptionStatus(e,t){const s=this.safeString(t,"id"),i=this.indexBy(e.subscriptions,"id"),n=this.safeValue(i,s,{}),r=this.safeValue(n,"method");return r!==void 0&&r.call(this,e,t,n),t}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r=this.safeValue(this.options,"watchTrades",{}),a=this.safeString(r,"name","trade"),o=n.lowercaseId+"@"+a,d=this.safeString(this.options,"defaultType","spot"),c=this.safeString2(r,"type","defaultType",d),u=this.safeString(i,"type",c),h=this.omit(i,"type"),l=this.urls.api.ws[u]+"/"+this.stream(u,o),p=this.requestId(l),m={method:"SUBSCRIBE",params:[o],id:p},g={id:p},y=await this.watch(l,o,this.extend(m,h),o,g);return this.newUpdates&&(s=y.getLimit(e,s)),this.filterBySinceLimit(y,t,s,"timestamp",!0)}parseTrade(e,t=void 0){const i=this.safeString(e,"x")==="TRADE";if(!i)return super.parseTrade(e,t);const n=this.safeString2(e,"t","a"),r=this.safeInteger(e,"T"),a=this.safeFloat2(e,"L","p");let o=this.safeFloat(e,"q");i&&(o=this.safeFloat(e,"l",o));let d=this.safeFloat(e,"Y");d===void 0&&a!==void 0&&o!==void 0&&(d=a*o);const c=this.safeString(e,"s"),u=this.safeSymbol(c);let h=this.safeStringLower(e,"S"),l;const p=this.safeString(e,"i");"m"in e&&(h===void 0&&(h=e.m?"sell":"buy"),l=e.m?"maker":"taker");let m;const g=this.safeFloat(e,"n");if(g!==void 0){const b=this.safeString(e,"N"),w=this.safeCurrencyCode(b);m={cost:g,currency:w}}const y=this.safeStringLower(e,"o");return{info:e,timestamp:r,datetime:this.iso8601(r),symbol:u,id:n,order:p,type:y,takerOrMaker:l,side:h,price:a,amount:o,cost:d,fee:m}}handleTrade(e,t){const s=this.safeString(t,"s"),i=this.safeMarket(s),n=i.symbol,r=this.safeStringLower(t,"s"),a=this.safeString(t,"e"),o=r+"@"+a,d=this.parseTrade(t,i);let c=this.safeValue(this.trades,n);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new KU(u)}c.append(d),this.trades[n]=c,e.resolve(c,o)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const a=this.market(e).lowercaseId,o=this.timeframes[t],d="kline",c=a+"@"+d+"_"+o,u=this.safeValue(this.options,"watchOHLCV",{}),h=this.safeString(this.options,"defaultType","spot"),l=this.safeString2(u,"type","defaultType",h),p=this.safeString(n,"type",l),m=this.omit(n,"type"),g=this.urls.api.ws[p]+"/"+this.stream(p,c),y=this.requestId(g),b={method:"SUBSCRIBE",params:[c],id:y},w={id:y},k=await this.watch(g,c,this.extend(b,m),c,w);return this.newUpdates&&(i=k.getLimit(e,i)),this.filterBySinceLimit(k,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"s"),i=this.safeStringLower(t,"s"),n=this.safeString(t,"e"),r=this.safeValue(t,"k"),a=this.safeString(r,"i"),o=this.findTimeframe(a),d=i+"@"+n+"_"+a,c=[this.safeInteger(r,"t"),this.safeFloat(r,"o"),this.safeFloat(r,"h"),this.safeFloat(r,"l"),this.safeFloat(r,"c"),this.safeFloat(r,"v")],u=this.safeSymbol(s);this.ohlcvs[u]=this.safeValue(this.ohlcvs,u,{});let h=this.safeValue(this.ohlcvs[u],o);if(h===void 0){const l=this.safeInteger(this.options,"OHLCVLimit",1e3);h=new XU(l),this.ohlcvs[u][o]=h}h.append(c),e.resolve(h,d)}async watchTicker(e,t={}){await this.loadMarkets();const i=this.market(e).lowercaseId,n=this.safeValue(this.options,"watchTicker",{}),r=this.safeString(n,"name","ticker"),a=i+"@"+r,o=this.safeString2(this.options,"defaultType","spot"),d=this.safeString2(n,"type","defaultType",o),c=this.safeString(t,"type",d),u=this.omit(t,"type"),h=this.urls.api.ws[c]+"/"+this.stream(c,a),l=this.requestId(h),p={method:"SUBSCRIBE",params:[a],id:l},m={id:l};return await this.watch(h,a,this.extend(p,u),a,m)}handleTicker(e,t){let s=this.safeString(t,"e","bookTicker");s==="24hrTicker"&&(s="ticker");const n=this.safeStringLower(t,"s")+"@"+s;let r;const a=this.milliseconds();s==="bookTicker"?r=this.safeInteger(t,"E",a):r=this.safeInteger(t,"C",a);const o=this.safeString(t,"s"),d=this.safeSymbol(o),c=this.safeFloat(t,"c"),u={symbol:d,timestamp:r,datetime:this.iso8601(r),high:this.safeFloat(t,"h"),low:this.safeFloat(t,"l"),bid:this.safeFloat(t,"b"),bidVolume:this.safeFloat(t,"B"),ask:this.safeFloat(t,"a"),askVolume:this.safeFloat(t,"A"),vwap:this.safeFloat(t,"w"),open:this.safeFloat(t,"o"),close:c,last:c,previousClose:this.safeFloat(t,"x"),change:this.safeFloat(t,"p"),percentage:this.safeFloat(t,"P"),average:void 0,baseVolume:this.safeFloat(t,"v"),quoteVolume:this.safeFloat(t,"q"),info:t};this.tickers[d]=u,e.resolve(u,n)}async authenticate(e={}){const t=this.milliseconds();let s=this.safeString2(this.options,"defaultType","authenticate","spot");s=this.safeString(e,"type",s);const i=this.safeValue(this.options,s,{}),n=this.safeInteger(i,"lastAuthenticatedTime",0),r=this.safeInteger(this.options,"listenKeyRefreshRate",12e5),a=this.sum(r,1e4);if(t-n>a){let o="publicPostUserDataStream";s==="future"?o="fapiPrivatePostListenKey":s==="delivery"?o="dapiPrivatePostListenKey":s==="margin"&&(o="sapiPostUserDataStream");const d=await this[o]();this.options[s]=this.extend(i,{listenKey:this.safeString(d,"listenKey"),lastAuthenticatedTime:t}),this.delay(r,this.keepAliveListenKey,e)}}async keepAliveListenKey(e={}){let t=this.safeString2(this.options,"defaultType","authenticate","spot");t=this.safeString(e,"type",t);const s=this.safeValue(this.options,t,{}),i=this.safeString(s,"listenKey");if(i===void 0)return;let n="publicPutUserDataStream";t==="future"?n="fapiPrivatePutListenKey":t==="delivery"?n="dapiPrivatePutListenKey":t==="margin"&&(n="sapiPutUserDataStream");const r={listenKey:i},a=this.milliseconds(),o=this.omit(e,"type");try{await this[n](this.extend(r,o))}catch(u){const h=this.urls.api.ws[t]+"/"+this.options[t].listenKey,l=this.client(h),p=Object.keys(l.futures);for(let m=0;m<p.length;m++){const g=p[m];l.reject(u,g)}this.options[t]=this.extend(s,{listenKey:void 0,lastAuthenticatedTime:0});return}this.options[t]=this.extend(s,{listenKey:i,lastAuthenticatedTime:a});const d=Object.values(this.clients),c=this.safeInteger(this.options,"listenKeyRefreshRate",12e5);for(let u=0;u<d.length;u++){const h=d[u],l=Object.keys(h.subscriptions);for(let p=0;p<l.length;p++)if(l[p]===t)return this.delay(c,this.keepAliveListenKey,e)}}setBalanceCache(e,t){if(t in e.subscriptions)return;const s=this.safeValue(this.options,"watchBalance");if(this.safeValue(s,"fetchBalanceSnapshot",!1)){const n=t+":fetchBalanceSnapshot";n in e.futures||(e.future(n),this.spawn(this.loadBalanceSnapshot,e,n,t))}else this.balance[t]={}}async loadBalanceSnapshot(e,t,s){const i=await this.fetchBalance({type:s});this.balance[s]=this.extend(i,this.safeValue(this.balance,s,{})),e.futures[t].resolve(),e.resolve(this.balance[s],s+":balance")}async watchBalance(e={}){await this.loadMarkets(),await this.authenticate(e);const t=this.safeString(this.options,"defaultType","spot"),s=this.safeString(e,"type",t),i=this.urls.api.ws[s]+"/"+this.options[s].listenKey,n=this.client(i);this.setBalanceCache(n,s);const r=this.safeValue(this.options,"watchBalance"),a=this.safeValue(r,"fetchBalanceSnapshot",!1),o=this.safeValue(r,"awaitBalanceSnapshot",!0);a&&o&&await n.future(s+":fetchBalanceSnapshot");const d=s+":balance",c=void 0;return await this.watch(i,d,c,s)}handleBalance(e,t){const s=this.safeValue(this.options,"wallet","wb"),n=Object.keys(e.subscriptions)[0],r=n+":balance";if(this.balance[n].info=t,this.safeString(t,"e")==="balanceUpdate"){const d=this.safeString(t,"a"),c=this.safeCurrencyCode(d),u=this.account(),h=this.safeString(t,"d");if(c in this.balance[n]){let l=this.balance[n][c].free;typeof l!="string"&&(l=this.numberToString(l)),u.free=zU.stringAdd(l,h)}else u.free=h;this.balance[n][c]=u}else{t=this.safeValue(t,"a",t);const d=this.safeValue(t,"B");for(let c=0;c<d.length;c++){const u=d[c],h=this.safeString(u,"a"),l=this.safeCurrencyCode(h),p=this.account();p.free=this.safeString(u,"f"),p.used=this.safeString(u,"l"),p.total=this.safeString(u,s),this.balance[n][l]=p}}const o=this.safeInteger(t,"E");this.balance[n].timestamp=o,this.balance[n].datetime=this.iso8601(o),this.balance[n]=this.safeBalance(this.balance[n]),e.resolve(this.balance[n],r)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate(i);let n="orders",r;e!==void 0&&(r=this.market(e),e=r.symbol,n+=":"+e);let a;[a,i]=this.handleMarketTypeAndParams("watchOrders",r,i);const o=this.urls.api.ws[a]+"/"+this.options[a].listenKey,d=this.client(o);this.setBalanceCache(d,a);const c=void 0,u=await this.watch(o,n,c,a);return this.newUpdates&&(s=u.getLimit(e,s)),this.filterBySymbolSinceLimit(u,e,t,s,!0)}parseWsOrder(e,t=void 0){const s=this.safeString(e,"x"),i=this.safeString(e,"i"),n=this.safeString(e,"s"),r=this.safeSymbol(n);let a=this.safeInteger(e,"O");const o=this.safeInteger(e,"T");let d;s==="NEW"?a===void 0&&(a=o):s==="TRADE"&&(d=o);let c;const u=this.safeFloat(e,"n");if(u!==void 0&&u>0){const _=this.safeString(e,"N"),S=this.safeCurrencyCode(_);c={cost:u,currency:S}}const h=this.safeFloat(e,"p"),l=this.safeFloat(e,"q"),p=this.safeStringLower(e,"S"),m=this.safeStringLower(e,"o"),g=this.safeFloat(e,"z"),y=this.safeFloat(e,"Z");let b=l,w=this.safeFloat(e,"ap"),k=y;g!==void 0&&(k===void 0&&h!==void 0&&(k=g*h),l!==void 0&&(b=Math.max(l-g,0)),w===void 0&&y!==void 0&&g>0&&(w=y/g));const T=this.safeString(e,"X"),O=this.parseOrderStatus(T),x=void 0;let C=this.safeString(e,"C");(C===void 0||C.length===0)&&(C=this.safeString(e,"c"));const E=this.safeFloat2(e,"P","sp");let P=this.safeString(e,"f");return P==="GTX"&&(P="PO"),{info:e,symbol:r,id:i,clientOrderId:C,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:d,type:m,timeInForce:P,postOnly:void 0,side:p,price:h,stopPrice:E,amount:l,cost:k,average:w,filled:g,remaining:b,status:O,fee:c,trades:x}}handleOrderUpdate(e,t){this.safeString(t,"e")==="ORDER_TRADE_UPDATE"&&(t=this.safeValue(t,"o",t)),this.handleMyTrade(e,t),this.handleOrder(e,t)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate(i);const n=this.safeString2(this.options,"watchMyTrades","defaultType","spot"),r=this.safeString(i,"type",n),a=this.urls.api.ws[r]+"/"+this.options[r].listenKey;let o="myTrades";e!==void 0&&(o+=":"+e);const d=this.client(a);this.setBalanceCache(d,r);const c=void 0,u=await this.watch(a,o,c,r);return this.newUpdates&&(s=u.getLimit(e,s)),this.filterBySymbolSinceLimit(u,e,t,s,!0)}handleMyTrade(e,t){const s="myTrades";if(this.safeString(t,"x")==="TRADE"){const n=this.parseTrade(t),r=this.safeString(n,"order"),a=this.safeValue(n,"fee"),o=this.safeString(n,"symbol");if(r!==void 0&&a!==void 0&&o!==void 0){const u=this.orders;if(u!==void 0){const h=this.safeValue(u.hashmap,o,{}),l=this.safeValue(h,r);if(l!==void 0){const p=this.safeValue(l,"fees"),m=this.safeValue(l,"fee");if(p!==void 0){let y=!0;for(let b=0;b<p.length;b++){const w=p[b];if(w.currency===a.currency){const k=this.sum(a.cost,w.cost);l.fees[b].cost=parseFloat(this.currencyToPrecision(a.currency,k)),y=!1;break}}y&&l.fees.push(a)}else if(m!==void 0)if(m.currency===a.currency){const y=this.sum(m.cost,a.cost);l.fee.cost=parseFloat(this.currencyToPrecision(a.currency,y))}else m.currency===void 0?l.fee=a:(l.fees=[m,a],l.fee=void 0);else l.fee=a;const g=this.safeValue(l,"trades",[]);g.push(n),l.trades=g}}}if(this.myTrades===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new jT(u)}this.myTrades.append(n),e.resolve(this.myTrades,s);const c=s+":"+o;e.resolve(this.myTrades,c)}}handleOrder(e,t){const s="orders",i=this.parseWsOrder(t),n=this.safeString(i,"symbol"),r=this.safeString(i,"id");if(n!==void 0){if(this.orders===void 0){const u=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new jT(u)}const a=this.orders,o=this.safeValue(a.hashmap,n,{}),d=this.safeValue(o,r);if(d!==void 0){const u=this.safeValue(d,"fee");u!==void 0&&(i.fee=u);const h=this.safeValue(d,"fees");h!==void 0&&(i.fees=h),i.trades=this.safeValue(d,"trades"),i.timestamp=this.safeInteger(d,"timestamp"),i.datetime=this.safeString(d,"datetime")}a.append(i),e.resolve(this.orders,s);const c=s+":"+n;e.resolve(this.orders,c)}}handleMessage(e,t){const s={depthUpdate:this.handleOrderBook,trade:this.handleTrade,aggTrade:this.handleTrade,kline:this.handleOHLCV,"24hrTicker":this.handleTicker,bookTicker:this.handleTicker,outboundAccountPosition:this.handleBalance,balanceUpdate:this.handleBalance,ACCOUNT_UPDATE:this.handleBalance,executionReport:this.handleOrderUpdate,ORDER_TRADE_UPDATE:this.handleOrderUpdate},i=this.safeString(t,"e"),n=this.safeValue(s,i);if(n===void 0){if(this.safeString(t,"id")!==void 0)return this.handleSubscriptionStatus(e,t);i===void 0&&this.handleTicker(e,t)}else return n.call(this,e,t)}};const YU=Wl;var QU=class extends YU{describe(){return this.deepExtend(super.describe(),{id:"binancecoinm",name:"Binance COIN-M",urls:{logo:"https://user-images.githubusercontent.com/1294454/117738721-668c8d80-b205-11eb-8c49-3fad84c4a07f.jpg"},options:{defaultType:"delivery"}})}};const ZU=Wl;var JU=class extends ZU{describe(){return this.deepExtend(super.describe(),{id:"binanceus",name:"Binance US",countries:["US"],certified:!1,urls:{logo:"https://user-images.githubusercontent.com/1294454/65177307-217b7c80-da5f-11e9-876e-0b748ba0a358.jpg",api:{ws:{spot:"wss://stream.binance.us:9443/ws"},web:"https://www.binance.us",wapi:"https://api.binance.us/wapi/v3",public:"https://api.binance.us/api/v1",private:"https://api.binance.us/api/v3",v3:"https://api.binance.us/api/v3",v1:"https://api.binance.us/api/v1"},www:"https://www.binance.us",referral:"https://www.binance.us/?ref=35005074",doc:"https://github.com/binance-us/binance-official-api-docs",fees:"https://www.binance.us/en/fee/schedule"},options:{fetchCurrencies:!1,quoteOrderQty:!1},fees:{trading:{tierBased:!1,percentage:!0,taker:0,maker:0}}})}};const e$=Wl;var t$=class extends e${describe(){return this.deepExtend(super.describe(),{id:"binanceusdm",name:"Binance USD\u24C8-M",urls:{logo:"https://user-images.githubusercontent.com/1294454/117738721-668c8d80-b205-11eb-8c49-3fad84c4a07f.jpg"},options:{defaultType:"future"}})}};const s$=Nb;var i$=class extends s${describe(){return this.deepExtend(super.describe(),{id:"bitcoincom",name:"bitcoin.com",countries:["KN"],urls:{logo:"https://user-images.githubusercontent.com/1294454/97296144-514fa300-1861-11eb-952b-3d55d492200b.jpg",api:{ws:"wss://api.fmfw.io/api/2/ws"}},fees:{trading:{maker:.15/100,taker:.2/100}}})}};const n$=V_,{ExchangeError:r$,AuthenticationError:a$}=de,{ArrayCache:o$,ArrayCacheBySymbolById:d$}=rt;var c$=class extends n${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchTickers:!1,watchOrderBook:!0,watchTrades:!0,watchBalance:!1,watchOHLCV:!1},urls:{api:{ws:{public:"wss://api-pub.bitfinex.com/ws/1",private:"wss://api.bitfinex.com/ws/1"}}},options:{watchOrderBook:{prec:"P0",freq:"F0"},ordersLimit:1e3}})}async subscribe(e,t,s={}){await this.loadMarkets();const n=this.market(t).id,r=this.urls.api.ws.public,a=e+":"+n,o={event:"subscribe",channel:e,symbol:n,messageHash:a};return await this.watch(r,a,this.deepExtend(o,s),a)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.subscribe("trades",e,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}async watchTicker(e,t={}){return await this.subscribe("ticker",e,t)}handleTrades(e,t,s){const i=this.safeValue(s,"channel"),n=this.safeString(s,"pair"),r=i+":"+n,a=this.safeInteger(this.options,"tradesLimit",1e3);if(n in this.markets_by_id){const o=this.markets_by_id[n],d=o.symbol,c=this.safeValue(t,1);let u=this.safeValue(this.trades,d);if(u===void 0&&(u=new o$(a),this.trades[d]=u),Array.isArray(c)){const h=this.parseTrades(c,o);for(let l=0;l<h.length;l++)u.append(h[l])}else{if(this.safeString(t,1)!=="tu")return;const l=this.parseTrade(t,o);u.append(l)}e.resolve(u,r)}return t}parseTrade(e,t=void 0){if(!Array.isArray(e))return super.parseTrade(e,t);const s=e.length,i=this.safeString(e,1);let n;i==="tu"&&(n=this.safeString(e,s-4));const r=this.safeTimestamp(e,s-3),a=this.safeFloat(e,s-2);let o=this.safeFloat(e,s-1),d;o!==void 0&&(d=o>0?"buy":"sell",o=Math.abs(o));let c;a!==void 0&&o!==void 0&&(c=a*o);const h=this.safeString(e,2).split("-");let l=this.safeString(h,1);l!==void 0&&(l=l.replace("t",""));const p=this.safeSymbol(l,t),m=void 0,g=void 0;return{info:e,timestamp:r,datetime:this.iso8601(r),symbol:p,id:n,order:g,type:void 0,takerOrMaker:m,side:d,price:a,amount:o,cost:c,fee:void 0}}handleTicker(e,t,s){const i=this.milliseconds(),n=this.safeString(s,"pair"),r=this.safeSymbol(n),o="ticker"+":"+n,d=this.safeFloat(t,7),c=this.safeFloat(t,5);let u;d!==void 0&&c!==void 0&&(u=d-c);const h={symbol:r,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(t,9),low:this.safeFloat(t,10),bid:this.safeFloat(t,1),bidVolume:void 0,ask:this.safeFloat(t,3),askVolume:void 0,vwap:void 0,open:u,close:d,last:d,previousClose:void 0,change:c,percentage:this.safeFloat(t,6),average:void 0,baseVolume:this.safeFloat(t,8),quoteVolume:void 0,info:t};this.tickers[r]=h,e.resolve(h,o)}async watchOrderBook(e,t=void 0,s={}){if(t!==void 0&&t!==25&&t!==100)throw new r$(this.id+" watchOrderBook limit argument must be undefined, 25 or 100");const i=this.safeValue(this.options,"watchOrderBook",{}),n=this.safeString(i,"prec","P0"),r=this.safeString(i,"freq","F0"),a={prec:n,freq:r,len:t};return(await this.subscribe("book",e,this.deepExtend(a,s))).limit()}handleOrderBook(e,t,s){const i=this.safeString(s,"pair"),n=this.safeSymbol(i),a="book"+":"+i,d=this.safeString(s,"prec","P0")==="R0";if(Array.isArray(t[1])){const c=this.safeInteger(s,"len");d?this.orderbooks[n]=this.indexedOrderBook({},c):this.orderbooks[n]=this.countedOrderBook({},c);const u=this.orderbooks[n];if(d){const h=t[1];for(let l=0;l<h.length;l++){const p=h[l],m=this.safeString(p,0),g=this.safeFloat(p,1),y=p[2]<0?-p[2]:p[2],b=p[2]<0?"asks":"bids";u[b].store(g,y,m)}}else{const h=t[1];for(let l=0;l<h.length;l++){const p=h[l],m=p[2]<0?-p[2]:p[2],g=p[2]<0?"asks":"bids";u[g].store(p[0],m,p[1])}}e.resolve(u,a)}else{const c=this.orderbooks[n];if(d){const u=this.safeString(t,1),h=this.safeFloat(t,2),l=t[3]<0?-t[3]:t[3],p=t[3]<0?"asks":"bids",m=c[p],g=h>0?l:0;m.store(h,g,u)}else{const u=t[3]<0?-t[3]:t[3],h=t[3]<0?"asks":"bids";c[h].store(t[1],u,t[2])}e.resolve(c,a)}}handleHeartbeat(e,t){const s=this.safeString(t,"event");e.resolve(t,s)}handleSystemStatus(e,t){return t}handleSubscriptionStatus(e,t){const s=this.safeString(t,"chanId");return e.subscriptions[s]=t,t}async authenticate(e={}){const t=this.urls.api.ws.private,s=this.client(t),i=s.future("authenticated"),n="auth";if(this.safeValue(s.subscriptions,n)===void 0){const a=this.milliseconds(),o="AUTH"+a.toString(),d=this.hmac(this.encode(o),this.encode(this.secret),"sha384","hex"),c={apiKey:this.apiKey,authSig:d,authNonce:a,authPayload:o,event:n,filter:["trading","wallet"]};this.spawn(this.watch,t,n,c,1)}return await i}handleAuthenticationMessage(e,t){if(this.safeString(t,"status")==="OK")this.safeValue(e.futures,"authenticated").resolve(!0);else{const i=new a$(this.json(t));e.reject(i,"authenticated");const n=this.safeString(t,"event");n in e.subscriptions&&delete e.subscriptions[n]}}async watchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.urls.api.ws.private;return await this.authenticate(),await this.watch(i,e,void 0,1)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate(),e!==void 0&&(e=this.symbol(e));const n=this.urls.api.ws.private,r=await this.watch(n,"os",void 0,1);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySymbolSinceLimit(r,e,t,s,!0)}handleOrders(e,t,s){const i=this.safeValue(t,2,[]);if(this.safeString(t,1)==="os")for(let r=0;r<i.length;r++){const a=i[r];this.handleOrder(e,a)}else this.handleOrder(e,i);this.orders!==void 0&&e.resolve(this.orders,"os")}parseWsOrderStatus(e){const t={ACTIVE:"open",CANCELED:"canceled"};return this.safeString(t,e,e)}handleOrder(e,t){const s=this.safeString(t,0),i=this.safeString(t,1),n=this.safeSymbol(i);let r=this.safeFloat(t,2),a=this.safeFloat(t,3),o="buy";r<0&&(r=Math.abs(r),a=Math.abs(a),o="sell");let d=this.safeString(t,4);d.indexOf("LIMIT")>-1?d="limit":d.indexOf("MARKET")>-1&&(d="market");const c=this.parseWsOrderStatus(this.safeString(t,5)),u=this.safeFloat(t,6),h=this.safeString(t,8),l=this.parse8601(h),p={info:t,id:s,clientOrderId:void 0,timestamp:l,datetime:this.iso8601(l),lastTradeTimestamp:void 0,symbol:n,type:d,side:o,price:u,stopPrice:void 0,average:void 0,amount:r,remaining:a,filled:r-a,status:c,fee:void 0,cost:void 0,trades:void 0};if(this.orders===void 0){const g=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new d$(g)}return this.orders.append(p),e.resolve(p,s),p}handleMessage(e,t){if(Array.isArray(t)){const s=this.safeString(t,0);if(t[1]==="hb")return t;const i=this.safeValue(e.subscriptions,s,{}),n=this.safeString(i,"channel"),r=this.safeString(t,1),a={book:this.handleOrderBook,ticker:this.handleTicker,trades:this.handleTrades,os:this.handleOrders,on:this.handleOrders,oc:this.handleOrders},o=this.safeValue2(a,n,r);return o===void 0?t:o.call(this,e,t,i)}else{const s=this.safeString(t,"event");if(s!==void 0){const i={info:this.handleSystemStatus,subscribed:this.handleSubscriptionStatus,auth:this.handleAuthenticationMessage},n=this.safeValue(i,s);return n===void 0?t:n.call(this,e,t)}}}};const u$=q_,Vg=Se,{ExchangeError:f$,AuthenticationError:h$,InvalidNonce:l$}=de,{ArrayCache:p$,ArrayCacheBySymbolById:WT,ArrayCacheByTimestamp:m$}=rt;var g$=class extends u${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchTickers:!1,watchOrderBook:!0,watchTrades:!0,watchMyTrades:!0,watchBalance:!0,watchOHLCV:!0,watchOrders:!0},urls:{api:{ws:{public:"wss://api-pub.bitfinex.com/ws/2",private:"wss://api.bitfinex.com/ws/2"}}},options:{watchOrderBook:{prec:"P0",freq:"F0"},ordersLimit:1e3,checksum:!0}})}async subscribe(e,t,s={}){await this.loadMarkets();const n=this.market(t).id,r=this.urls.api.ws.public,a=this.client(r),o=e+":"+n,d={event:"subscribe",channel:e,symbol:n},c=await this.watch(r,o,this.deepExtend(d,s),o,{checksum:!1});return this.safeValue(this.options,"checksum",!0)&&!a.subscriptions[o].checksum&&e==="book"&&(a.subscriptions[o].checksum=!0,a.send({event:"conf",flags:131072})),c}async subscribePrivate(e){await this.loadMarkets(),await this.authenticate();const t=this.urls.api.ws.private;return await this.watch(t,e,void 0,1)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=this.timeframes[t],o="candles",d="trade:"+a+":"+r.id,c=o+":"+a+":"+r.id,u={event:"subscribe",channel:o,key:d},h=this.urls.api.ws.public,l=await this.watch(h,c,this.deepExtend(u,n),c);return this.newUpdates&&(i=l.getLimit(e,i)),this.filterBySinceLimit(l,s,i,0,!0)}handleOHLCV(e,t,s){const i=this.safeValue(t,1,[]);let n;const r=this.safeValue(i,0);Array.isArray(r)?n=i:n=[i];const a=this.safeValue(s,"channel"),o=this.safeString(s,"key"),d=o.split(":"),c=this.safeString(d,1);let u=o;u=u.replace("trade:",""),u=u.replace(c+":","");const h=this.safeMarket(u),l=this.findTimeframe(c),p=h.symbol,m=a+":"+c+":"+u;this.ohlcvs[p]=this.safeValue(this.ohlcvs,p,{});let g=this.safeValue(this.ohlcvs[p],l);if(g===void 0){const b=this.safeInteger(this.options,"OHLCVLimit",1e3);g=new m$(b),this.ohlcvs[p][l]=g}const y=n.length;for(let b=0;b<y;b++){const w=n[y-b-1],k=this.parseOHLCV(w,h);g.append(k)}e.resolve(g,m)}async watchTrades(e,t=void 0,s=void 0,i={}){const n=await this.subscribe("trades",e,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n="myTrade";if(e!==void 0){const a=this.market(e);n+=":"+a.id}const r=await this.subscribePrivate(n);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySymbolSinceLimit(r,e,t,s,!0)}async watchTicker(e,t={}){return await this.subscribe("ticker",e,t)}handleMyTrade(e,t){const s="myTrade",i=this.safeValue(t,2),n=this.parseWsTrade(i,!1),r=n.symbol,a=this.market(r),o=s+":"+a.id;if(this.myTrades===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new WT(c)}const d=this.myTrades;d.append(n),this.myTrades=d,e.resolve(d,s),e.resolve(d,o)}handleTrades(e,t,s){const i=this.safeValue(s,"channel"),n=this.safeString(s,"symbol"),r=this.safeMarket(n),a=i+":"+n,o=this.safeInteger(this.options,"tradesLimit",1e3),d=r.symbol;let c=this.safeValue(this.trades,d);c===void 0&&(c=new p$(o),this.trades[d]=c);const u=!0;if(t.length===2){const l=this.safeValue(t,1,[]);for(let p=0;p<l.length;p++){const m=this.parseWsTrade(l[p],u,r);c.append(m)}}else{if(this.safeString(t,1)==="tu")return;const p=this.safeValue(t,2,[]),m=this.parseWsTrade(p,u,r);c.append(m)}return e.resolve(c,a),t}parseWsTrade(e,t=!1,s=void 0){let i=t?void 0:this.safeString(e,1);s=this.safeMarket(i,s);const n=t?1:2,r=t?3:5,a=t?2:4;i=s.id;let o=this.safeString(e,6);o!==void 0&&(o.indexOf("LIMIT")>-1?o="limit":o.indexOf("MARKET")>-1&&(o="market"));const d=t?void 0:this.safeString(e,3),c=this.safeString(e,0),u=this.safeInteger(e,n),h=this.safeString(e,r),l=this.safeString(e,a),p=this.parseNumber(Vg.stringAbs(l));let m;p!==void 0&&(m=Vg.stringGt(l,"0")?"buy":"sell");const g=this.safeSymbol(i,s),y=this.safeString(e,9);let b;if(y!==void 0){const T=this.safeString(e,10),O=this.safeCurrencyCode(T);b={cost:y,currency:O}}const w=this.safeInteger(e,8);let k;return w!==void 0&&(k=w===-1?"taker":"maker"),this.safeTrade({info:e,timestamp:u,datetime:this.iso8601(u),symbol:g,id:c,order:d,type:o,takerOrMaker:k,side:m,price:h,amount:p,cost:void 0,fee:b},s)}handleTicker(e,t,s){const i=this.safeValue(t,1),n=this.safeString(s,"symbol"),r=this.safeMarket(n),a=this.safeSymbol(n),o=this.parseWsTicker(i,r),c="ticker"+":"+n;this.tickers[a]=o,e.resolve(o,c)}parseWsTicker(e,t=void 0){t=this.safeMarket(void 0,t);const s=t.symbol,i=this.safeString(e,6),n=this.safeString(e,4);return this.safeTicker({symbol:s,timestamp:void 0,datetime:void 0,high:this.safeString(e,8),low:this.safeString(e,9),bid:this.safeString(e,0),bidVolume:this.safeString(e,1),ask:this.safeString(e,2),askVolume:this.safeString(e,3),vwap:void 0,open:void 0,close:i,last:i,previousClose:void 0,change:n,percentage:this.safeString(e,5),average:void 0,baseVolume:this.safeString(e,7),quoteVolume:void 0,info:e},t)}async watchOrderBook(e,t=void 0,s={}){if(t!==void 0&&t!==25&&t!==100)throw new f$(this.id+" watchOrderBook limit argument must be undefined, 25 or 100");const i=this.safeValue(this.options,"watchOrderBook",{}),n=this.safeString(i,"prec","P0"),r=this.safeString(i,"freq","F0"),a={prec:n,freq:r};return t!==void 0&&(a.len=t),(await this.subscribe("book",e,this.deepExtend(a,s))).limit()}handleOrderBook(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeSymbol(i),a="book"+":"+i,d=this.safeString(s,"prec","P0")==="R0",c=this.safeString(t,0);let u=this.safeValue(this.orderbooks,n);if(u===void 0){const h=this.safeInteger(s,"len");if(d?this.orderbooks[n]=this.indexedOrderBook({},h):this.orderbooks[n]=this.countedOrderBook({},h),u=this.orderbooks[n],d){const l=t[1];for(let p=0;p<l.length;p++){const m=l[p],g=m[2]<0?-m[2]:m[2],y=m[2]<0?"asks":"bids",b=u[y],w=this.safeString(m,0),k=this.safeFloat(m,1);b.store(k,g,w)}}else{const l=t[1];for(let p=0;p<l.length;p++){const m=l[p],g=this.safeNumber(m,2),y=this.safeNumber(m,1),b=this.safeNumber(m,0),w=g<0?-g:g,k=g<0?"asks":"bids";u[k].store(b,w,y)}}e.resolve(u,a)}else{const h=t[1],l=this.orderbooks[n];if(d){const p=this.safeFloat(h,1),m=h[2]<0?-h[2]:h[2],g=h[2]<0?"asks":"bids",y=l[g],b=p>0?m:0;y.store(p,b,c)}else{const p=this.safeNumber(h,2),m=this.safeNumber(h,1),g=this.safeNumber(h,0),y=p<0?-p:p,b=p<0?"asks":"bids";l[b].store(g,y,m)}e.resolve(l,a)}}handleChecksum(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeSymbol(i),a="book"+":"+i,o=this.safeValue(this.orderbooks,n);if(o===void 0)return;const d=this.safeInteger(s,"len"),c=[],u=o.bids,h=o.asks;for(let g=0;g<d;g++)c.push(u[g][0]),c.push(u[g][1]),c.push(h[g][0]),c.push(-h[g][1]);const l=c.join(":"),p=this.crc32(l,!0);if(this.safeInteger(t,2)!==p){const g=new l$(this.id+" invalid checksum");e.reject(g,a)}}async watchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"wallet","exchange");e=this.omit(e,"wallet");const s="balance:"+t;return await this.subscribePrivate(s)}handleBalance(e,t,s){const i=this.safeValue(t,1);let n;i==="ws"?n=this.safeValue(t,2):n=[this.safeValue(t,2)];const r={};for(let o=0;o<n.length;o++){const d=n[o],c=this.safeString(d,1),u=this.safeCurrencyCode(c),h=this.parseWsBalance(d),l=this.safeString(d,0),p=this.safeValue(this.balance,l,{});p[u]=h,p.info=t,this.balance[l]=this.safeBalance(p),r[l]=!0}const a=Object.keys(r);for(let o=0;o<a.length;o++){const d=a[o],c="balance:"+d;e.resolve(this.balance[d],c)}}parseWsBalance(e){const t=this.safeString(e,2),s=this.safeString(e,4),i=this.account();return s!==void 0&&(i.free=s),i.total=t,i}handleSystemStatus(e,t){return t}handleSubscriptionStatus(e,t){const s=this.safeString(t,"chanId");return e.subscriptions[s]=t,t}async authenticate(e={}){const t=this.urls.api.ws.private,s=this.client(t),i=s.future("authenticated"),n="auth";if(this.safeValue(s.subscriptions,n)===void 0){const a=this.milliseconds(),o="AUTH"+a.toString(),d=this.hmac(this.encode(o),this.encode(this.secret),"sha384","hex"),c={apiKey:this.apiKey,authSig:d,authNonce:a,authPayload:o,event:n};this.spawn(this.watch,t,n,c,1)}return await i}handleAuthenticationMessage(e,t){if(this.safeString(t,"status")==="OK")this.safeValue(e.futures,"authenticated").resolve(!0);else{const i=new h$(this.json(t));e.reject(i,"authenticated");const n=this.safeString(t,"event");n in e.subscriptions&&delete e.subscriptions[n]}}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n="orders";if(e!==void 0){const a=this.market(e);n+=":"+a.id}const r=await this.subscribePrivate(n);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySymbolSinceLimit(r,e,t,s,!0)}handleOrders(e,t,s){const i=this.safeValue(t,2,[]),n=this.safeString(t,1);if(this.orders===void 0){const c=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new WT(c)}const r=this.orders,a={};if(n==="os"){if(i.length===0)return;for(let u=0;u<i.length;u++){const h=i[u],l=this.parseWsOrder(h),p=l.symbol;a[p]=!0,r.append(l)}}else{const c=this.parseWsOrder(i);r.append(c)}const o="orders";e.resolve(this.orders,o);const d=Object.keys(a);for(let c=0;c<d.length;c++){const u=d[c],h=this.safeMarket(u),l=o+":"+h.id;e.resolve(this.orders,l)}}parseWsOrderStatus(e){const t={ACTIVE:"open",CANCELED:"canceled",EXECUTED:"closed","PARTIALLY FILLED":"open"};return this.safeString(t,e,e)}parseWsOrder(e,t=void 0){const s=this.safeString(e,0),i=this.safeString(e,1),n=this.safeString(e,3),r=this.safeSymbol(n);t=this.safeMarket(r);let a=this.safeNumber(e,7),o="buy";a<0&&(a=Math.abs(a),o="sell");const d=Vg.stringAbs(this.safeString(e,6));let c=this.safeString(e,8);c.indexOf("LIMIT")>-1?c="limit":c.indexOf("MARKET")>-1&&(c="market");const h=this.safeString(e,13).split(" "),l=this.safeString(h,0),p=this.parseWsOrderStatus(l),m=this.safeString(e,16),g=this.safeInteger(e,4),y=this.safeString(e,17),b=this.omitZero(this.safeString(e,18));return this.safeOrder({info:e,id:s,clientOrderId:i,timestamp:g,datetime:this.iso8601(g),lastTradeTimestamp:void 0,symbol:r,type:c,side:o,price:m,stopPrice:b,average:y,amount:a,remaining:d,filled:void 0,status:p,fee:void 0,cost:void 0,trades:void 0},t)}handleMessage(e,t){const s=this.safeString(t,0);if(Array.isArray(t)){if(t[1]==="hb")return t;const i=this.safeValue(e.subscriptions,s,{}),n=this.safeString(i,"channel"),r=this.safeString(t,1),a={book:this.handleOrderBook,cs:this.handleChecksum,candles:this.handleOHLCV,ticker:this.handleTicker,trades:this.handleTrades},o={os:this.handleOrders,ou:this.handleOrders,on:this.handleOrders,oc:this.handleOrders,wu:this.handleBalance,ws:this.handleBalance,tu:this.handleMyTrade};let d;return s==="0"?d=this.safeValue(o,r):d=this.safeValue2(a,r,n),d===void 0?t:d.call(this,e,t,i)}else{const i=this.safeString(t,"event");if(i!==void 0){const n={info:this.handleSystemStatus,subscribed:this.handleSubscriptionStatus,auth:this.handleAuthenticationMessage},r=this.safeValue(n,i);return r===void 0?t:r.call(this,e,t)}}}};const y$=L_,{ArgumentsRequired:zT,AuthenticationError:b$}=de,{ArrayCache:w$,ArrayCacheByTimestamp:k$,ArrayCacheBySymbolById:S$}=rt;var v$=class extends y${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchOrderBook:!0,watchOrders:!0,watchTrades:!0,watchOHLCV:!0},urls:{api:{ws:{public:"wss://ws-manager-compress.{hostname}/api?protocol=1.1",private:"wss://ws-manager-compress.{hostname}/user?protocol=1.1"}}},options:{defaultType:"spot",watchOrderBook:{depth:"depth5"},ws:{inflate:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","45m":"45m","1h":"1H","2h":"2H","3h":"3H","4h":"4H","1d":"1D","1w":"1W","1M":"1M"}},streaming:{keepAlive:15e3}})}async subscribe(e,t,s={}){await this.loadMarkets();const i=this.market(t),n=this.implodeHostname(this.urls.api.ws.public),r=i.type+"/"+e+":"+i.id,a={op:"subscribe",args:[r]};return await this.watch(n,r,this.deepExtend(a,s),r)}async subscribePrivate(e,t,s={}){await this.loadMarkets();const i=this.market(t),n=this.implodeHostname(this.urls.api.ws.private),r=e+":"+i.id;await this.authenticate();const a={op:"subscribe",args:[r]};return await this.watch(n,r,this.deepExtend(a,s),r)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.subscribe("trade",e,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}async watchTicker(e,t={}){return await this.subscribe("ticker",e,t)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new zT(this.id+" watchOrders requires a symbol argument");await this.loadMarkets();const n=this.market(e);if(e=n.symbol,n.type!=="spot")throw new zT(this.id+" watchOrders supports spot markets only");const r="spot/user/order",a=await this.subscribePrivate(r,e,i);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySymbolSinceLimit(a,e,t,s,!0)}handleOrders(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]);if(i.length>0){const r=this.safeInteger(this.options,"ordersLimit",1e3);this.orders===void 0&&(this.orders=new S$(r));const a=this.orders,o=[];for(let d=0;d<i.length;d++){const c=this.parseWsOrder(i[d]);a.append(c);const u=c.symbol,h=this.market(u);o.push(h.id)}for(let d=0;d<o.length;d++){const c=s+":"+o[d];e.resolve(this.orders,c)}}}parseWsOrder(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeString(e,"order_id"),n=this.safeString(e,"clientOid"),r=this.safeString(e,"price"),a=this.safeString(e,"filled_size"),o=this.safeString(e,"size"),d=this.safeString(e,"type"),c=this.safeString(e,"state"),u=this.parseOrderStatusByType(t.type,c),h=this.safeInteger(e,"ms_t"),l=t.symbol,p=this.safeStringLower(e,"side");return this.safeOrder({info:e,symbol:l,id:i,clientOrderId:n,timestamp:void 0,datetime:void 0,lastTradeTimestamp:h,type:d,timeInForce:void 0,postOnly:void 0,side:p,price:r,stopPrice:void 0,amount:o,cost:void 0,average:void 0,filled:a,remaining:void 0,status:u,fee:void 0,trades:void 0},t)}handleTrade(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]),n=this.safeInteger(this.options,"tradesLimit",1e3);for(let r=0;r<i.length;r++){const a=this.parseTrade(i[r]),o=a.symbol,d=this.safeString(a.info,"symbol"),c=s+":"+d;let u=this.safeValue(this.trades,o);u===void 0&&(u=new w$(n),this.trades[o]=u),u.append(a),e.resolve(u,c)}return t}handleTicker(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]);for(let n=0;n<i.length;n++){const r=this.parseTicker(i[n]),a=r.symbol,o=this.safeString(r.info,"symbol"),d=s+":"+o;this.tickers[a]=r,e.resolve(r,d)}return t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets(),e=this.symbol(e);const r=this.safeValue(this.options,"timeframes",{}),o="kline"+this.safeString(r,t),d=await this.subscribe(o,e,n);return this.newUpdates&&(i=d.getLimit(e,i)),this.filterBySinceLimit(d,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]),n=s.split("/"),a=this.safeString(n,1).replace("kline",""),o=this.safeValue(this.options,"timeframes",{}),d=this.findTimeframe(a,o),u=this.parseTimeframe(d)*1e3;for(let h=0;h<i.length;h++){const l=this.safeString(i[h],"symbol"),p=this.safeValue(i[h],"candle"),m=this.safeMarket(l),g=m.symbol,y=this.parseOHLCV(p,m);y[0]=parseInt(y[0]/u)*u,this.ohlcvs[g]=this.safeValue(this.ohlcvs,g,{});let b=this.safeValue(this.ohlcvs[g],d);if(b===void 0){const k=this.safeInteger(this.options,"OHLCVLimit",1e3);b=new k$(k),this.ohlcvs[g][d]=b}b.append(y);const w=s+":"+l;e.resolve(b,w)}}async watchOrderBook(e,t=void 0,s={}){const i=this.safeValue(this.options,"watchOrderBook",{}),n=this.safeString(i,"depth","depth400");return(await this.subscribe(n,e,s)).limit()}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s){const i=this.safeValue(t,"asks",[]),n=this.safeValue(t,"bids",[]);this.handleDeltas(s.asks,i),this.handleDeltas(s.bids,n);const r=this.safeInteger(t,"ms_t"),a=this.safeString(t,"symbol"),o=this.safeSymbol(a);return s.symbol=o,s.timestamp=r,s.datetime=this.iso8601(r),s}handleOrderBook(e,t){const s=this.safeValue(t,"data",[]),i=this.safeString(t,"table"),n=i.split("/"),a=this.safeString(n,1).replace("depth",""),o=parseInt(a);for(let d=0;d<s.length;d++){const c=s[d],u=this.safeString(c,"symbol"),h=this.safeSymbol(u);let l=this.safeValue(this.orderbooks,h);l===void 0&&(l=this.orderBook({},o),this.orderbooks[h]=l),l.reset({}),this.handleOrderBookMessage(e,c,l);const p=i+":"+u;e.resolve(l,p)}return t}async authenticate(e={}){this.checkRequiredCredentials();const t=this.implodeHostname(this.urls.api.ws.private),s="login",i=this.client(t);let n=this.safeValue(i.subscriptions,s);if(n===void 0){n=i.future("authenticated");const r=this.milliseconds().toString(),a=this.uid,o="bitmart.WebSocket",d=r+"#"+a+"#"+o,c=this.hmac(this.encode(d),this.encode(this.secret),"sha256"),u={op:s,args:[this.apiKey,r,c]};this.spawn(this.watch,t,s,u,s,n)}return await n}handleSubscriptionStatus(e,t){return t}handleAuthenticate(e,t){return e.resolve(t,"authenticated"),t}handleErrorMessage(e,t){const s=this.safeString(t,"errorCode");try{if(s!==void 0){const i=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,i);const n=this.safeValue(t,"message");n!==void 0&&this.throwBroadlyMatchedException(this.exceptions.broad,n,i)}}catch(i){if(i instanceof b$){e.reject(i,"authenticated");const n="login";return n in e.subscriptions&&delete e.subscriptions[n],!1}}return t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;const s=this.safeString(t,"table");if(s===void 0){const i=this.safeString(t,"event");if(i!==void 0){const n={login:this.handleAuthenticate,subscribe:this.handleSubscriptionStatus},r=this.safeValue(n,i);return r===void 0?t:r.call(this,e,t)}}else{const i=s.split("/"),n=this.safeString(i,1),r={depth:this.handleOrderBook,depth5:this.handleOrderBook,depth400:this.handleOrderBook,ticker:this.handleTicker,trade:this.handleTrade};let a=this.safeValue(r,n);return n.indexOf("kline")>=0&&(a=this.handleOHLCV),this.safeString(i,2)==="order"&&(a=this.handleOrders),a===void 0?t:a.call(this,e,t)}}};const T$=R_,{AuthenticationError:O$,ExchangeError:KT,RateLimitExceeded:I$}=de,{ArrayCache:x$,ArrayCacheByTimestamp:_$,ArrayCacheBySymbolById:XT}=rt;var C$=class extends T${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0},urls:{test:{ws:"wss://testnet.bitmex.com/realtime"},api:{ws:"wss://www.bitmex.com/realtime"}},versions:{ws:"0.2.0"},options:{watchOrderBookLevel:"orderBookL2",tradesLimit:1e3,OHLCVLimit:1e3},exceptions:{ws:{exact:{},broad:{"Rate limit exceeded":I$}}}})}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),n="instrument"+":"+s.id,r=this.urls.api.ws,a={op:"subscribe",args:[n]};return await this.watch(r,n,this.extend(a,t),n)}handleTicker(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeValue(r,"symbol"),o=this.safeMarket(a),d=o.symbol,c=s+":"+a;let u=this.safeValue(this.tickers,d,{});const h=this.safeValue(u,"info",{});u=this.parseTicker(this.extend(h,r),o),this.tickers[d]=u,e.resolve(u,c)}return t}async watchBalance(e={}){await this.loadMarkets(),await this.authenticate();const t="margin",s=this.urls.api.ws,i={op:"subscribe",args:[t]};return await this.watch(s,t,this.extend(i,e),t)}handleBalance(e,t){const s=this.safeValue(t,"data"),i=this.parseBalance(s);this.balance=this.extend(this.balance,i);const n=this.safeString(t,"table");e.resolve(this.balance,n)}handleTrades(e,t){const s="trade",i=this.safeValue(t,"data",[]),n=this.groupBy(i,"symbol"),r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeMarket(o),c=s+":"+o,u=d.symbol,h=this.parseTrades(n[o],d);let l=this.safeValue(this.trades,u);if(l===void 0){const p=this.safeInteger(this.options,"tradesLimit",1e3);l=new x$(p),this.trades[u]=l}for(let p=0;p<h.length;p++)l.append(h[p]);e.resolve(l,c)}}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const a="trade"+":"+n.id,o=this.urls.api.ws,d={op:"subscribe",args:[a]},c=await this.watch(o,a,this.extend(d,i),a);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySinceLimit(c,t,s,"timestamp",!0)}async authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i=s.future("authenticated"),n="authKeyExpires";if(this.safeValue(s.subscriptions,n)===void 0)try{this.checkRequiredCredentials();const a=this.milliseconds(),o="GET/realtime"+a.toString(),d=this.hmac(this.encode(o),this.encode(this.secret)),c={op:n,args:[this.apiKey,a,d]};this.spawn(this.watch,t,n,c,n)}catch(a){s.reject(a,"authenticated"),n in s.subscriptions&&delete s.subscriptions[n]}return await i}handleAuthenticationMessage(e,t){if(this.safeValue(t,"success",!1))this.safeValue(e.futures,"authenticated").resolve(!0);else{const i=new O$(this.json(t));e.reject(i,"authenticated");const n="authKeyExpires";n in e.subscriptions&&delete e.subscriptions[n]}}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate();const n="order",r=n;let a=n;e!==void 0&&(e=this.symbol(e),a+=":"+e);const o=this.urls.api.ws,d={op:"subscribe",args:[r]},c=await this.watch(o,a,d,r);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}handleOrders(e,t){const s=this.safeValue(t,"data",[]),i="order",n=s.length;if(n>0){if(this.orders===void 0){const d=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new XT(d)}const r=this.orders,a={};for(let d=0;d<n;d++){const c=s[d],u=this.safeString(c,"orderID"),h=this.safeValue(r.hashmap,u);let l=c;h!==void 0&&(l=this.extend(h.info,c));const p=this.parseOrder(l);r.append(p);const m=p.symbol;a[m]=!0}e.resolve(this.orders,i);const o=Object.keys(a);for(let d=0;d<o.length;d++){const c=o[d];e.resolve(this.orders,i+":"+c)}}}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate();const n="execution",r=n;let a=n;e!==void 0&&(e=this.symbol(e),a+=":"+e);const o=this.urls.api.ws,d={op:"subscribe",args:[r]},c=await this.watch(o,a,d,r);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}handleMyTrades(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]),n=this.groupBy(i,"execType"),r=this.safeValue(n,"Trade",[]),a=this.parseTrades(r);if(this.myTrades===void 0){const h=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new XT(h)}const o=this.myTrades,d={};for(let h=0;h<a.length;h++){const l=a[h],p=l.symbol;o.append(l),d[p]=l}a.length>0&&e.resolve(o,s);const u=Object.keys(d);for(let h=0;h<u.length;h++)e.resolve(o,s+":"+u[h])}async watchOrderBook(e,t=void 0,s={}){let i;if(t===void 0)i=this.safeString(this.options,"watchOrderBookLevel","orderBookL2");else if(t===25)i="orderBookL2_25";else if(t===10)i="orderBookL10";else throw new KT(this.id+" watchOrderBook limit argument must be undefined (L2), 25 (L2) or 10 (L3)");await this.loadMarkets();const n=this.market(e),r=i+":"+n.id,a=this.urls.api.ws,o={op:"subscribe",args:[r]};return(await this.watch(a,r,this.deepExtend(o,s),r)).limit()}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const o="tradeBin"+this.timeframes[t]+":"+r.id,d=this.urls.api.ws,c={op:"subscribe",args:[o]},u=await this.watch(d,o,this.extend(c,n),o);return this.newUpdates&&(i=u.getLimit(e,i)),this.filterBySinceLimit(u,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"table"),i=s.replace("tradeBin",""),n=this.findTimeframe(i),r=this.parseTimeframe(n),a=this.safeValue(t,"data",[]),o={};for(let c=0;c<a.length;c++){const u=a[c],h=this.safeString(u,"symbol"),l=this.safeMarket(h),p=l.symbol,m=s+":"+l.id,g=[this.parse8601(this.safeString(u,"timestamp"))-r*1e3,this.safeFloat(u,"open"),this.safeFloat(u,"high"),this.safeFloat(u,"low"),this.safeFloat(u,"close"),this.safeFloat(u,"volume")];this.ohlcvs[p]=this.safeValue(this.ohlcvs,p,{});let y=this.safeValue(this.ohlcvs[p],n);if(y===void 0){const b=this.safeInteger(this.options,"OHLCVLimit",1e3);y=new _$(b),this.ohlcvs[p][n]=y}y.append(g),o[m]=y}const d=Object.keys(o);for(let c=0;c<d.length;c++){const u=d[c];e.resolve(o[u],u)}}async watchHeartbeat(e={}){await this.loadMarkets();const t="heartbeat",s=this.urls.api.ws;return await this.watch(s,t)}handleOrderBook(e,t){const s=this.safeString(t,"action"),i=this.safeString(t,"table"),n=this.safeValue(t,"data",[]);if(s==="partial"){const r=this.safeValue(t,"filter",{}),a=this.safeValue(r,"symbol"),d=this.safeMarket(a).symbol;i==="orderBookL2"?this.orderbooks[d]=this.indexedOrderBook():i==="orderBookL2_25"?this.orderbooks[d]=this.indexedOrderBook({},25):i==="orderBook10"&&(this.orderbooks[d]=this.indexedOrderBook({},10));const c=this.orderbooks[d];for(let h=0;h<n.length;h++){const l=this.safeFloat(n[h],"price"),p=this.safeFloat(n[h],"size"),m=this.safeString(n[h],"id");let g=this.safeString(n[h],"side");g=g==="Buy"?"bids":"asks",c[g].store(l,p,m)}const u=i+":"+a;e.resolve(c,u)}else{const r={};for(let o=0;o<n.length;o++){const d=this.safeValue(n[o],"symbol");d in r||(r[d]=0),r[d]=this.sum(r,1);const u=this.safeMarket(d).symbol,h=this.orderbooks[u],l=this.safeFloat(n[o],"price"),p=this.safeFloat(n[o],"size",0),m=this.safeString(n[o],"id");let g=this.safeString(n[o],"side");g=g==="Buy"?"bids":"asks",h[g].store(l,p,m)}const a=Object.keys(r);for(let o=0;o<a.length;o++){const d=a[o],c=i+":"+d,h=this.safeMarket(d).symbol,l=this.orderbooks[h];e.resolve(l,c)}}}handleSystemStatus(e,t){return t}handleSubscriptionStatus(e,t){return t}handleErrorMessage(e,t){const s=this.safeValue(t,"error");if(s!==void 0){const i=this.safeValue(t,"request",{}),n=this.safeString(i,"args",[]);if(n.length>0){const a=n[0],o=this.exceptions.ws.broad,d=this.findBroadlyMatchedKey(o,s);let c;return d===void 0?c=new KT(s):c=new o[d](s),e.reject(c,a),!1}}return!0}handleMessage(e,t){if(this.handleErrorMessage(e,t)){const s=this.safeString(t,"table"),i={orderBookL2:this.handleOrderBook,orderBookL2_25:this.handleOrderBook,orderBook10:this.handleOrderBook,instrument:this.handleTicker,trade:this.handleTrades,tradeBin1m:this.handleOHLCV,tradeBin5m:this.handleOHLCV,tradeBin1h:this.handleOHLCV,tradeBin1d:this.handleOHLCV,order:this.handleOrders,execution:this.handleMyTrades,margin:this.handleBalance},n=this.safeValue(i,s);if(n===void 0){const r=this.safeValue(t,"request",{});return this.safeValue(r,"op")==="authKeyExpires"?this.handleAuthenticationMessage.call(this,e,t):t}else return n.call(this,e,t)}}};const M$=F_,{ExchangeError:P$}=de,{ArrayCache:A$}=rt;var B$=class extends M${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!1,watchOHLCV:!1,watchOrderBook:!0,watchOrders:!1,watchTicker:!0,watchTickers:!1,watchTrades:!0},urls:{ws:{public:"wss://stream.bitopro.com:9443/ws/v1/pub",private:"wss://stream.bitopro.com:9443/ws/v1/pub/auth"}},requiredCredentials:{apiKey:!0,secret:!0,login:!0},options:{tradesLimit:1e3,ordersLimit:1e3,ws:{options:{headers:{}}}}})}async watchPublic(e,t,s){const i=this.urls.ws.public+"/"+e+"/"+s;return await this.watch(i,t,void 0,t)}async watchOrderBook(e,t=void 0,s={}){if(t!==void 0&&t!==5&&t!==10&&t!==20&&t!==50&&t!==100&&t!==500&&t!==1e3)throw new P$(this.id+" watchOrderBook limit argument must be undefined, 5, 10, 20, 50, 100, 500 or 1000");await this.loadMarkets();const i=this.market(e);e=i.symbol;const n="ORDER_BOOK:"+e;let r;return t===void 0?r=i.id:r=i.id+":"+t,(await this.watchPublic("order-books",n,r)).limit()}handleOrderBook(e,t){const s=this.safeString(t,"pair"),n=this.safeMarket(s,void 0,"_").symbol,a=this.safeString(t,"event")+":"+n;let o=this.safeValue(this.orderbooks,n);o===void 0&&(o=this.orderBook({}));const d=this.safeInteger(t,"timestamp"),c=this.parseOrderBook(t,n,d,"bids","asks","price","amount");o.reset(c),e.resolve(o,a)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="TRADE:"+e,a=await this.watchPublic("trades",r,n.id,s);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySinceLimit(a,t,s,"timestamp",!0)}handleTrade(e,t){const s=this.safeString(t,"pair"),i=this.safeMarket(s,void 0,"_"),n=i.symbol,a=this.safeString(t,"event")+":"+n,o=this.safeValue(t,"data",[]),d=this.parseTrades(o,i);let c=this.safeValue(this.trades,n);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new A$(u)}for(let u=0;u<d.length;u++)c.append(d[u]);this.trades[n]=c,e.resolve(c,a)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i="TICKER:"+e;return await this.watchPublic("tickers",i,s.id)}handleTicker(e,t){const s=this.safeString(t,"pair"),n=this.safeMarket(s,void 0,"_").symbol,a=this.safeString(t,"event")+":"+n,o=this.parseTicker(t),d=this.safeInteger(t,"timestamp"),c=this.safeString(t,"datetime");o.timestamp=d,o.datetime=c,this.tickers[n]=o,e.resolve(o,a)}authenticate(e){if(this.clients!==void 0&&e in this.clients)return;this.checkRequiredCredentials();const t=this.milliseconds(),s=this.json({nonce:t,identity:this.login}),i=this.stringToBase64(s),n=this.hmac(i,this.encode(this.secret),"sha384"),r={ws:{options:{headers:{}}}};this.options=this.extend(r,this.options);const a=this.options.ws.options.headers;this.options.ws.options.headers={"X-BITOPRO-API":"ccxt","X-BITOPRO-APIKEY":this.apiKey,"X-BITOPRO-PAYLOAD":i,"X-BITOPRO-SIGNATURE":n},this.client(e),this.options.ws.options.headers=a}async watchBalance(e={}){this.checkRequiredCredentials(),await this.loadMarkets();const t="ACCOUNT_BALANCE",s=this.urls.ws.private+"/account-balance";return this.authenticate(s),await this.watch(s,t,void 0,t)}handleBalance(e,t){const s=this.safeString(t,"event"),i=this.safeValue(t,"data"),n=Object.keys(i),r={};for(let a=0;a<n.length;a++){const o=this.safeString(n,a),d=this.safeValue(i,o),c=this.safeString(d,"currency"),u=this.safeCurrencyCode(c),h=this.account();h.free=this.safeString(d,"available"),h.total=this.safeString(d,"amount"),r[u]=h}this.balance=this.safeBalance(r),e.resolve(this.balance,s)}handleMessage(e,t){const s={TRADE:this.handleTrade,TICKER:this.handleTicker,ORDER_BOOK:this.handleOrderBook,ACCOUNT_BALANCE:this.handleBalance},i=this.safeString(t,"event"),n=this.safeValue(s,i);return n===void 0?t:n.call(this,e,t)}};const E$=D_,{ArgumentsRequired:N$,AuthenticationError:V$}=de,{ArrayCache:q$,ArrayCacheBySymbolById:L$}=rt;var R$=class extends E${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchOrders:!0,watchTrades:!0,watchOHLCV:!1,watchTicker:!1,watchTickers:!1},urls:{api:{ws:"wss://ws.bitstamp.net"}},options:{expiresIn:"",userId:"",wsSessionToken:"",watchOrderBook:{type:"order_book"},tradesLimit:1e3,OHLCVLimit:1e3},exceptions:{exact:{4009:V$}}})}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n=this.safeValue(this.options,"watchOrderBook",{}),r=this.safeString(n,"type","order_book"),a=r+"_"+i.id,o=this.urls.api.ws,d={event:"bts:subscribe",data:{channel:a}},c={messageHash:a,type:r,symbol:e,method:this.handleOrderBookSubscription,limit:t,params:s},u=this.extend(d,s);return(await this.watch(o,a,u,a,c)).limit()}async fetchOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit"),r=this.safeValue(s,"params"),a=this.safeString(s,"messageHash"),o=await this.fetchOrderBook(i,n,r),d=this.safeValue(this.orderbooks,i);if(d!==void 0){d.reset(o);const c=d.cache;for(let u=0;u<c.length;u++){const h=c[u];this.handleOrderBookMessage(e,h,d)}this.orderbooks[i]=d,e.resolve(d,a)}}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1),n=this.safeString(t,2);n===void 0?e.store(s,i):e.store(s,i,n)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s,i=void 0){const n=this.safeValue(t,"data",{}),r=this.safeInteger(n,"microtimestamp");if(i!==void 0&&r<=i)return s;this.handleDeltas(s.asks,this.safeValue(n,"asks",[])),this.handleDeltas(s.bids,this.safeValue(n,"bids",[])),s.nonce=r;const a=parseInt(r/1e3);return s.timestamp=a,s.datetime=this.iso8601(a),s}handleOrderBook(e,t){const s=this.safeString(t,"channel"),i=this.safeValue(e.subscriptions,s),n=this.safeString(i,"symbol"),r=this.safeString(i,"type"),a=this.safeValue(this.orderbooks,n);if(a===void 0)return t;if(r==="order_book")a.reset({}),this.handleOrderBookMessage(e,t,a),e.resolve(a,s);else if(r==="detail_order_book")a.reset({}),this.handleOrderBookMessage(e,t,a),e.resolve(a,s);else if(r==="diff_order_book"){const o=this.safeInteger(a,"nonce");if(o===void 0)a.cache.push(t);else try{this.handleOrderBookMessage(e,t,a,o),e.resolve(a,s)}catch(d){n in this.orderbooks&&delete this.orderbooks[n],s in e.subscriptions&&delete e.subscriptions[s],e.reject(d,s)}}}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r=this.safeValue(this.options,"watchTrades",{}),a=this.safeString(r,"type","live_trades"),o=a+"_"+n.id,d=this.urls.api.ws,c={event:"bts:subscribe",data:{channel:o}},u={messageHash:o,type:a,symbol:e,limit:s,params:i},h=this.extend(c,i),l=await this.watch(d,o,h,o,u);return this.newUpdates&&(s=l.getLimit(e,s)),this.filterBySinceLimit(l,t,s,"timestamp",!0)}parseTrade(e,t=void 0){const s=this.safeInteger(e,"microtimestamp");if(s===void 0)return super.parseTrade(e,t);const i=this.safeString(e,"id"),n=parseInt(s/1e3),r=this.safeFloat(e,"price"),a=this.safeFloat(e,"amount");let o;r!==void 0&&a!==void 0&&(o=r*a);let d;const c=this.safeString(e,"s");c in this.markets_by_id&&(t=this.markets_by_id[c]),d===void 0&&t!==void 0&&(d=t.symbol);let u=this.safeInteger(e,"type");return u=u===0?"buy":"sell",{info:e,timestamp:n,datetime:this.iso8601(n),symbol:d,id:i,order:void 0,type:void 0,takerOrMaker:void 0,side:u,price:r,amount:a,cost:o,fee:void 0}}handleTrade(e,t){const s=this.safeString(t,"channel"),i=this.safeValue(t,"data"),n=this.safeValue(e.subscriptions,s),r=this.safeString(n,"symbol"),a=this.market(r),o=this.parseTrade(i,a);let d=this.safeValue(this.trades,r);if(d===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);d=new q$(c),this.trades[r]=d}d.append(o),e.resolve(d,s)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new N$(this.id+" watchOrders requires a symbol argument");await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="private-my_orders",a=r+"_"+n.id,o={symbol:e,limit:s,type:r,params:i},d=await this.subscribePrivate(o,a,i);return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySinceLimit(d,t,s,"timestamp",!0)}handleOrders(e,t){const s=this.safeString(t,"channel"),i=this.safeValue(t,"data",{}),n=this.safeInteger(this.options,"ordersLimit",1e3);this.orders===void 0&&(this.orders=new L$(n));const r=this.orders,a=this.safeValue(e.subscriptions,s),o=this.safeString(a,"symbol"),d=this.market(o),c=this.parseWsOrder(i,d);r.append(c),e.resolve(this.orders,s)}parseWsOrder(e,t=void 0){const s=this.safeString(e,"id_str"),i=this.safeStringLower(e,"order_type"),n=this.safeString(e,"price_str"),r=this.safeString(e,"amount_str"),a=i==="1"?"sell":"buy",o=this.safeIntegerProduct(e,"datetime",1e3);t=this.safeMarket(void 0,t);const d=t.symbol;return this.safeOrder({info:e,symbol:d,id:s,clientOrderId:void 0,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:void 0,type:void 0,timeInForce:void 0,postOnly:void 0,side:a,price:n,stopPrice:void 0,amount:r,cost:void 0,average:void 0,filled:void 0,remaining:void 0,status:void 0,fee:void 0,trades:void 0},t)}handleOrderBookSubscription(e,t,s){const i=this.safeString(s,"type"),n=this.safeString(s,"symbol");if(n in this.orderbooks&&delete this.orderbooks[n],i==="order_book"){const r=this.safeInteger(s,"limit",100);this.orderbooks[n]=this.orderBook({},r)}else if(i==="detail_order_book"){const r=this.safeInteger(s,"limit",100);this.orderbooks[n]=this.indexedOrderBook({},r)}else if(i==="diff_order_book"){const r=this.safeInteger(s,"limit");this.orderbooks[n]=this.orderBook({},r),this.spawn(this.fetchOrderBookSnapshot,e,t,s)}}handleSubscriptionStatus(e,t){const s=this.safeString(t,"channel"),i=this.safeValue(e.subscriptions,s,{}),n=this.safeValue(i,"method");return n!==void 0&&n.call(this,e,t,i),t}handleSubject(e,t){const s=this.safeString(t,"channel"),i=this.safeValue(e.subscriptions,s),n=this.safeString(i,"type"),r={live_trades:this.handleTrade,order_book:this.handleOrderBook,detail_order_book:this.handleOrderBook,diff_order_book:this.handleOrderBook,"private-my_orders":this.handleOrders},a=this.safeValue(r,n);return a===void 0?t:a.call(this,e,t)}handleErrorMessage(e,t){if(this.safeString(t,"event")==="bts:error"){const i=this.id+" "+this.json(t),n=this.safeValue(t,"data",{}),r=this.safeNumber(n,"code");this.throwExactlyMatchedException(this.exceptions.exact,r,i)}return t}handleMessage(e,t){return this.handleErrorMessage(e,t)?this.safeString(t,"event")==="bts:subscription_succeeded"?this.handleSubscriptionStatus(e,t):this.handleSubject(e,t):void 0}async authenticate(e={}){this.checkRequiredCredentials();const t=this.milliseconds(),s=this.safeInteger(this.options,"expiresIn");if(t>s){const i=await this.privatePostWebsocketsToken(e),n=this.safeString(i,"token");if(n!==void 0){const r=this.safeNumber(i,"user_id"),a=this.safeIntegerProduct(i,"valid_sec",1e3);return this.options.expiresIn=this.sum(t,a),this.options.userId=r,this.options.wsSessionToken=n,i}}}async subscribePrivate(e,t,s={}){const i=this.urls.api.ws;await this.authenticate(),t+="-"+this.options.userId;const n={event:"bts:subscribe",data:{channel:t,auth:this.options.wsSessionToken}};return e.messageHash=t,await this.watch(i,t,this.extend(n,s),t,e)}};const F$=H_,{InvalidNonce:D$,BadRequest:H$}=de,{ArrayCache:G$,ArrayCacheByTimestamp:U$,ArrayCacheBySymbolById:YT}=rt;var $$=class extends F${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchHeartbeat:!0,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0},urls:{api:{ws:"wss://socket-v3.bittrex.com/signalr/connect",signalr:"https://socket-v3.bittrex.com/signalr"}},api:{signalr:{get:["negotiate","start"]}},options:{tradesLimit:1e3,hub:"c3",I:this.milliseconds()}})}getSignalRUrl(e){const t=this.safeString(e.response,"ConnectionToken"),s=this.extend(e.request,{connectionToken:t});return this.urls.api.ws+"?"+this.urlencode(s)}makeRequest(e,t,s){return{H:this.safeString(this.options,"hub","c3"),M:t,A:s,I:e}}makeRequestToSubscribe(e,t){const s="Subscribe";return this.makeRequest(e,s,t)}makeRequestToAuthenticate(e){const t=this.milliseconds(),s=this.uuid(),i=t.toString()+s,n=this.hmac(this.encode(i),this.encode(this.secret),"sha512"),r=[this.apiKey,t,s,n],a="Authenticate";return this.makeRequest(e,a,r)}requestId(){const e=this.sum(this.safeInteger(this.options,"I",0),1);return this.options.I=e,e}async sendRequestToSubscribe(e,t,s,i={}){const n=[t],r=this.requestId().toString(),a=this.makeRequestToSubscribe(r,[n]);s=this.extend({id:r,negotiation:e},s);const o=this.getSignalRUrl(e);return await this.watch(o,t,a,t,s)}async authenticate(e={}){await this.loadMarkets();const t=await this.negotiate();return await this.sendRequestToAuthenticate(t,!1,e)}async sendRequestToAuthenticate(e,t=!1,s={}){const i=this.getSignalRUrl(e),n=this.client(i),r="authenticate";let a=this.safeValue(n.subscriptions,r);if(a===void 0||t){a=n.future(r),n.subscriptions[r]=a;const o=this.requestId().toString(),d=this.makeRequestToAuthenticate(o),c={id:o,params:s,negotiation:e,method:this.handleAuthenticate};this.spawn(this.watch,i,r,d,o,c)}return await a}async sendAuthenticatedRequestToSubscribe(e,t,s={}){const i=this.safeValue(e,"negotiation"),n={params:s};return await this.sendRequestToSubscribe(i,t,n,s)}handleAuthenticate(e,t,s){const i=this.safeString(s,"id");i in e.subscriptions&&delete e.subscriptions[i],e.resolve(s,"authenticate")}async handleAuthenticationExpiringHelper(){const e=await this.negotiate();return await this.sendRequestToAuthenticate(e,!0)}handleAuthenticationExpiring(e,t){this.spawn(this.handleAuthenticationExpiringHelper)}createSignalRQuery(e={}){const s=[{name:this.safeString(this.options,"hub","c3")}],i=this.milliseconds();return this.extend({transport:"webSockets",connectionData:this.json(s),clientProtocol:1.5,_:i,tid:this.sum(i%10,1)},e)}async negotiate(e={}){const t=this.client(this.urls.api.ws),s="negotiate";let i=this.safeValue(t.subscriptions,s);if(i===void 0){i=t.future(s),t.subscriptions[s]=i;const n=this.createSignalRQuery(e),r=await this.signalrGetNegotiate(this.extend(n,e)),a={request:n,response:r};t.resolve(a,s)}return await i}async start(e,t={}){const s=this.safeString(e.response,"ConnectionToken"),i=this.createSignalRQuery(this.extend(e.request,{connectionToken:s}));return await this.signalrGetStart(i)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),e!==void 0&&(e=this.symbol(e));const n=await this.authenticate(),r=await this.subscribeToOrders(n,i);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySymbolSinceLimit(r,e,t,s,!0)}async subscribeToOrders(e,t={}){const s="order";return await this.sendAuthenticatedRequestToSubscribe(e,s,t)}handleOrder(e,t){const s=this.safeValue(t,"delta",{}),i=this.parseOrder(s);if(this.orders===void 0){const a=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new YT(a)}this.orders.append(i);const r="order";e.resolve(this.orders,r)}async watchBalance(e={}){await this.loadMarkets();const t=await this.authenticate();return await this.subscribeToBalance(t,e)}async subscribeToBalance(e,t={}){const s="balance";return await this.sendAuthenticatedRequestToSubscribe(e,s,t)}handleBalance(e,t){const s=this.safeValue(t,"delta",{}),i=this.safeString(s,"currencySymbol"),n=this.safeCurrencyCode(i),r=this.account();r.free=this.safeString(s,"available"),r.total=this.safeString(s,"total"),this.balance[n]=r,this.balance=this.safeBalance(this.balance);const a="balance";e.resolve(this.balance,a)}async watchHeartbeat(e={}){await this.loadMarkets();const t=await this.negotiate();return await this.subscribeToHeartbeat(t,e)}async subscribeToHeartbeat(e,t={}){await this.loadMarkets();const s=this.getSignalRUrl(e),i=this.milliseconds().toString(),n="heartbeat",r=[n],a=this.makeRequestToSubscribe(i,[r]),o={id:i,params:t,negotiation:e};return await this.watch(s,n,a,n,o)}handleHeartbeat(e,t){e.resolve(t,"heartbeat")}async watchTicker(e,t={}){await this.loadMarkets();const s=await this.negotiate();return await this.subscribeToTicker(s,e,t)}async subscribeToTicker(e,t,s={}){await this.loadMarkets();const i=this.market(t);t=i.symbol;const r="ticker"+"_"+i.id,a={marketId:i.id,symbol:t,params:s};return await this.sendRequestToSubscribe(e,r,a)}handleTicker(e,t){const s=this.parseTicker(t),i=s.symbol,n=this.market(i);this.tickers[i]=s;const a="ticker"+"_"+n.id;e.resolve(s,a)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets(),e=this.symbol(e);const r=await this.negotiate(),a=await this.subscribeToOHLCV(r,e,t,n);return this.newUpdates&&(i=a.getLimit(e,i)),this.filterBySinceLimit(a,s,i,0,!0)}async subscribeToOHLCV(e,t,s="1m",i={}){await this.loadMarkets();const n=this.market(t),r=this.timeframes[s],o="candle"+"_"+n.id+"_"+r,d={symbol:t,timeframe:s,messageHash:o,params:i};return await this.sendRequestToSubscribe(e,o,d)}handleOHLCV(e,t){const s="candle",i=this.safeString(t,"marketSymbol"),n=this.safeSymbol(i,void 0,"-"),r=this.safeString(t,"interval"),a=s+"_"+i+"_"+r,o=this.findTimeframe(r),d=this.safeValue(t,"delta",{}),c=this.parseOHLCV(d);this.ohlcvs[n]=this.safeValue(this.ohlcvs,n,{});let u=this.safeValue(this.ohlcvs[n],o);if(u===void 0){const h=this.safeInteger(this.options,"OHLCVLimit",1e3);u=new U$(h),this.ohlcvs[n][o]=u}u.append(c),e.resolve(u,a)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.negotiate(),r=await this.subscribeToTrades(n,e,i);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySinceLimit(r,t,s,"timestamp",!0)}async subscribeToTrades(e,t,s={}){await this.loadMarkets();const i=this.market(t),r="trade"+"_"+i.id,a={symbol:t,messageHash:r,params:s};return await this.sendRequestToSubscribe(e,r,a)}handleTrades(e,t){const s=this.safeValue(t,"deltas",[]),i=this.safeString(t,"marketSymbol"),n=this.safeSymbol(i,void 0,"-"),r=this.market(n),o="trade"+"_"+i;let d=this.safeValue(this.trades,n);if(d===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);d=new G$(u)}const c=this.parseTrades(s,r);for(let u=0;u<c.length;u++)d.append(c[u]);this.trades[n]=d,e.resolve(d,o)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.authenticate(),r=await this.subscribeToMyTrades(n,i);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySymbolSinceLimit(r,e,t,s,!0)}async subscribeToMyTrades(e,t={}){const s="execution";return await this.sendAuthenticatedRequestToSubscribe(e,s,t)}handleMyTrades(e,t){const s=this.safeValue(t,"deltas",{}),i=this.parseTrades(s);let n=this.myTrades;if(n===void 0){const a=this.safeInteger(this.options,"tradesLimit",1e3);n=new YT(a),this.myTrades=n}for(let a=0;a<i.length;a++)n.append(i[a]);const r="execution";e.resolve(n,r)}async watchOrderBook(e,t=void 0,s={}){if(t=t===void 0?25:t,t!==1&&t!==25&&t!==500)throw new H$(this.id+" watchOrderBook() limit argument must be undefined, 1, 25 or 500, default is 25");await this.loadMarkets(),e=this.symbol(e);const i=await this.negotiate();return(await this.subscribeToOrderBook(i,e,t,s)).limit()}async subscribeToOrderBook(e,t,s=void 0,i={}){await this.loadMarkets();const n=this.market(t),a="orderbook"+"_"+n.id+"_"+s.toString(),o={symbol:t,messageHash:a,method:this.handleSubscribeToOrderBook,limit:s,params:i};return await this.sendRequestToSubscribe(e,a,o)}async fetchOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit"),r=this.safeString(s,"messageHash");try{const a=await this.fetchOrderBook(i,n),o=this.orderbooks[i],d=o.cache,c=this.safeValue(d,0,{}),u=this.safeInteger(c,"sequence"),h=this.safeInteger(a,"nonce");if(u!==void 0&&h<u){const l=this.safeValue(this.options,"fetchOrderBookSnapshot",{}),p=this.safeInteger(l,"maxAttempts",3);let m=this.safeInteger(s,"numAttempts",0);if(m<p)r in e.subscriptions&&(m=this.sum(m,1),s.numAttempts=m,e.subscriptions[r]=s,this.spawn(this.fetchOrderBookSnapshot,e,t,s));else throw new D$(this.id+" failed to synchronize WebSocket feed with the snapshot for symbol "+i+" in "+p.toString()+" attempts")}else{o.reset(a);for(let l=0;l<d.length;l++){const p=d[l];this.handleOrderBookMessage(e,p,o)}this.orderbooks[i]=o,e.resolve(o,r)}}catch(a){e.reject(a,r)}}handleSubscribeToOrderBook(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit");i in this.orderbooks&&delete this.orderbooks[i],this.orderbooks[i]=this.orderBook({},n),this.spawn(this.fetchOrderBookSnapshot,e,t,s)}handleDelta(e,t){const s=this.safeFloat(t,"rate"),i=this.safeFloat(t,"quantity");e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBook(e,t){const s=this.safeString(t,"marketSymbol"),i=this.safeSymbol(s,void 0,"-"),n=this.safeInteger(t,"depth");let r=this.safeValue(this.orderbooks,i);r===void 0&&(r=this.orderBook({},n)),r.nonce!==void 0?this.handleOrderBookMessage(e,t,r):r.cache.push(t)}handleOrderBookMessage(e,t,s){const i=this.safeString(t,"marketSymbol"),n=this.safeString(t,"depth"),a="orderbook"+"_"+i+"_"+n,o=this.safeInteger(t,"sequence");return o>s.nonce&&(this.handleDeltas(s.asks,this.safeValue(t,"askDeltas",[])),this.handleDeltas(s.bids,this.safeValue(t,"bidDeltas",[])),s.nonce=o,e.resolve(s,a)),s}async handleSystemStatusHelper(){const e=await this.negotiate();await this.start(e)}handleSystemStatus(e,t){return this.spawn(this.handleSystemStatusHelper),t}handleSubscriptionStatus(e,t){const s=this.safeString(t,"I");let i=this.safeValue(e.subscriptions,s);if(i===void 0){const r=this.indexBy(e.subscriptions,"id");i=this.safeValue(r,s,{})}else delete e.subscriptions[s];const n=this.safeValue(i,"method");return n===void 0?e.resolve(t,s):n.call(this,e,t,i),t}handleMessage(e,t){const s={authenticationExpiring:this.handleAuthenticationExpiring,order:this.handleOrder,balance:this.handleBalance,trade:this.handleTrades,candle:this.handleOHLCV,orderBook:this.handleOrderBook,heartbeat:this.handleHeartbeat,ticker:this.handleTicker,execution:this.handleMyTrades},i=this.safeValue(t,"M",[]);for(let a=0;a<i.length;a++){const o=this.safeValue(i[a],"M"),d=this.safeValue(s,o);if(d!==void 0)if(o==="heartbeat")d.call(this,e,t);else if(o==="authenticationExpiring")d.call(this,e,t);else{const c=this.safeValue(i[a],"A",[]);for(let u=0;u<c.length;u++){const h=this.inflate64(c[u]),l=JSON.parse(h);d.call(this,e,l)}}}"I"in t&&this.handleSubscriptionStatus(e,t),"S"in t&&this.handleSystemStatus(e,t),Object.keys(t).length<1&&this.handleHeartbeat(e,t)}};const j$=G_,{AuthenticationError:W$,ArgumentsRequired:QT}=de,{ArrayCache:ZT,ArrayCacheByTimestamp:z$,ArrayCacheBySymbolById:K$}=rt;var X$=class extends j${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTrades:!0,watchTicker:!0,watchOHLCV:!0,watchOrders:!0,watchMyTrades:!0},urls:{api:{ws:"wss://ws.bitvavo.com/v2"}},options:{tradesLimit:1e3,ordersLimit:1e3,OHLCVLimit:1e3}})}async watchPublic(e,t,s={}){await this.loadMarkets();const i=this.market(t),n=e+"@"+i.id,r=this.urls.api.ws,a={action:"subscribe",channels:[{name:e,markets:[i.id]}]},o=this.extend(a,s);return await this.watch(r,n,o,n)}async watchTicker(e,t={}){return await this.watchPublic("ticker24h",e,t)}handleTicker(e,t){const s=this.safeString(t,"event"),i=this.safeValue(t,"data",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"market"),o=this.safeMarket(a,void 0,"-"),d=s+"@"+a,c=this.parseTicker(r,o),u=c.symbol;this.tickers[u]=c,e.resolve(c,d)}return t}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.watchPublic("trades",e,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}handleTrade(e,t){const s=this.safeString(t,"market"),i=this.safeMarket(s,void 0,"-"),n=i.symbol,a="trades"+"@"+s,o=this.parseTrade(t,i);let d=this.safeValue(this.trades,n);if(d===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);d=new ZT(c)}d.append(o),this.trades[n]=d,e.resolve(d,a)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a="candles",o=r.id,d=this.timeframes[t],c=a+"@"+o+"_"+d,u=this.urls.api.ws,h={action:"subscribe",channels:[{name:"candles",interval:[d],markets:[o]}]},l=this.extend(h,n),p=await this.watch(u,c,l,c);return this.newUpdates&&(i=p.getLimit(e,i)),this.filterBySinceLimit(p,s,i,0,!0)}handleOHLCV(e,t){const s="candles",i=this.safeString(t,"market"),n=this.safeMarket(i,void 0,"-"),r=n.symbol,a=this.safeString(t,"interval"),o=this.findTimeframe(a),d=s+"@"+i+"_"+a,c=this.safeValue(t,"candle");this.ohlcvs[r]=this.safeValue(this.ohlcvs,r,{});let u=this.safeValue(this.ohlcvs[r],o);if(u===void 0){const h=this.safeInteger(this.options,"OHLCVLimit",1e3);u=new z$(h),this.ohlcvs[r][o]=u}for(let h=0;h<c.length;h++){const l=c[h],p=this.parseOHLCV(l,n);u.append(p)}e.resolve(u,d)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n="book",r=n+"@"+i.id,a=this.urls.api.ws,o={action:"subscribe",channels:[{name:n,markets:[i.id]}]},d={messageHash:r,name:n,symbol:e,marketId:i.id,method:this.handleOrderBookSubscription,limit:t,params:s},c=this.extend(o,s);return(await this.watch(a,r,c,r,d)).limit()}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s){const i=this.safeInteger(t,"nonce");return i>s.nonce&&(this.handleDeltas(s.asks,this.safeValue(t,"asks",[])),this.handleDeltas(s.bids,this.safeValue(t,"bids",[])),s.nonce=i),s}handleOrderBook(e,t){const s=this.safeString(t,"event"),i=this.safeString(t,"market"),n=this.safeMarket(i,void 0,"-"),r=n.symbol,a=s+"@"+n.id,o=this.safeValue(this.orderbooks,r);if(o!==void 0)if(o.nonce===void 0){const d=this.safeValue(e.subscriptions,a,{});if(this.safeValue(d,"watchingOrderBookSnapshot")===void 0){d.watchingOrderBookSnapshot=!0,e.subscriptions[a]=d;const u=this.safeValue(this.options,"watchOrderBookSnapshot",{}),h=this.safeInteger(u,"delay",this.rateLimit);this.delay(h,this.watchOrderBookSnapshot,e,t,d)}o.cache.push(t)}else this.handleOrderBookMessage(e,t,o),e.resolve(o,a)}async watchOrderBookSnapshot(e,t,s){const i=this.safeValue(s,"params"),n=this.safeString(s,"marketId"),r="getBook",a=r+"@"+n,o=this.urls.api.ws,d={action:r,market:n};return(await this.watch(o,a,this.extend(d,i),a,s)).limit()}handleOrderBookSnapshot(e,t){const s=this.safeValue(t,"response");if(s===void 0)return t;const i=this.safeString(s,"market");let n;i in this.markets_by_id&&(n=this.markets_by_id[i].symbol);const a="book"+"@"+i,o=this.orderbooks[n],d=this.parseOrderBook(s,n);d.nonce=this.safeInteger(s,"nonce"),o.reset(d);const c=o.cache;for(let u=0;u<c.length;u++){const h=c[u];this.handleOrderBookMessage(e,h,o)}this.orderbooks[n]=o,e.resolve(o,a)}handleOrderBookSubscription(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit");i in this.orderbooks&&delete this.orderbooks[i],this.orderbooks[i]=this.orderBook({},n)}handleOrderBookSubscriptions(e,t,s){const i="book";for(let n=0;n<s.length;n++){const r=this.safeString(s,n);if(r in this.markets_by_id){const o=this.markets_by_id[r].symbol,d=i+"@"+r;if(!(o in this.orderbooks)){const c=this.safeValue(e.subscriptions,d),u=this.safeValue(c,"method");u!==void 0&&u.call(this,e,t,c)}}}}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new QT(this.id+" watchOrders requires a symbol argument");await this.loadMarkets(),await this.authenticate();const n=this.market(e);e=n.symbol;const r=n.id,a=this.urls.api.ws,o="account",d=o+"@"+r,c=d+"_order",u={action:"subscribe",channels:[{name:o,markets:[r]}]},h=await this.watch(a,c,u,d);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySymbolSinceLimit(h,e,t,s,!0)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new QT(this.id+" watchMyTrades requires a symbol argument");await this.loadMarkets(),await this.authenticate();const n=this.market(e);e=n.symbol;const r=n.id,a=this.urls.api.ws,o="account",d=o+"@"+r,c=d+"_fill",u={action:"subscribe",channels:[{name:o,markets:[r]}]},h=await this.watch(a,c,u,d);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySymbolSinceLimit(h,e,t,s,!0)}handleOrder(e,t){const s="account",i=this.safeString(t,"event"),n=this.safeString(t,"market","-"),r=s+"@"+n+"_"+i;if(n in this.markets_by_id){const a=this.markets_by_id[n],o=this.parseOrder(t,a);if(this.orders===void 0){const c=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new K$(c)}this.orders.append(o),e.resolve(this.orders,r)}}handleMyTrade(e,t){const s="account",i=this.safeString(t,"event"),n=this.safeString(t,"market"),r=s+"@"+n+"_"+i,a=this.safeMarket(n,void 0,"-"),o=this.parseTrade(t,a);if(this.myTrades===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new ZT(c)}const d=this.myTrades;d.append(o),this.myTrades=d,e.resolve(d,r)}handleSubscriptionStatus(e,t){const s=this.safeValue(t,"subscriptions",{}),i={book:this.handleOrderBookSubscriptions},n=Object.keys(s);for(let r=0;r<n.length;r++){const a=n[r],o=this.safeValue(i,a);if(o!==void 0){const d=this.safeValue(s,a);o.call(this,e,t,d)}}return t}async authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i=s.future("authenticated"),n="authenticate";if(this.safeValue(s.subscriptions,n)===void 0)try{this.checkRequiredCredentials();const a=this.milliseconds(),d=a.toString()+"GET/"+this.version+"/websocket",c=this.hmac(this.encode(d),this.encode(this.secret)),u={action:n,key:this.apiKey,signature:c,timestamp:a};this.spawn(this.watch,t,n,u,n)}catch(a){s.reject(a,"authenticated"),n in s.subscriptions&&delete s.subscriptions[n]}return await i}handleAuthenticationMessage(e,t){if(this.safeValue(t,"authenticated",!1))this.safeValue(e.futures,"authenticated").resolve(!0);else{const i=new W$(this.json(t));e.reject(i,"authenticated");const n=this.safeValue(t,"event");n in e.subscriptions&&delete e.subscriptions[n]}}handleMessage(e,t){const s={subscribed:this.handleSubscriptionStatus,book:this.handleOrderBook,getBook:this.handleOrderBookSnapshot,trade:this.handleTrade,candle:this.handleOHLCV,ticker24h:this.handleTicker,authenticate:this.handleAuthenticationMessage,order:this.handleOrder,fill:this.handleMyTrade},i=this.safeString(t,"event");let n=this.safeValue(s,i);if(n===void 0){const r=this.safeString(t,"action");return n=this.safeValue(s,r),n===void 0?t:n.call(this,e,t)}else return n.call(this,e,t)}};const Ch=Se,Y$=U_,{AuthenticationError:JT,BadRequest:Q$,NotSupported:Z$}=de,{ArrayCache:J$,ArrayCacheBySymbolById:eO,ArrayCacheByTimestamp:tO}=rt;var ej=class extends Y${describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0},urls:{api:{ws:{inverse:{public:"wss://stream.{hostname}/realtime",private:"wss://stream.{hostname}/realtime"},linear:{public:"wss://stream.{hostname}/realtime_public",private:"wss://stream.{hostname}/realtime_private"},spot:{public:"wss://stream.{hostname}/spot/quote/ws/v2",private:"wss://stream.{hostname}/spot/ws"},usdc:{option:{public:"wss://stream.{hostname}/trade/option/usdc/public/v1",private:"wss://stream.{hostname}/trade/option/usdc/private/v1"},swap:{public:"wss://stream.{hostname}/perpetual/ws/v1/realtime_public",private:"wss://stream.{hostname}/trade/option/usdc/private/v1"}}}},test:{ws:{inverse:{public:"wss://stream-testnet.{hostname}/realtime",private:"wss://stream-testnet.{hostname}/realtime"},linear:{public:"wss://stream-testnet.{hostname}/realtime_public",private:"wss://stream-testnet.{hostname}/realtime_private"},spot:{public:"wss://stream-testnet.{hostname}/spot/quote/ws/v2",private:"wss://stream-testnet.{hostname}/spot/ws"},usdc:{option:{public:"wss://stream-testnet.{hostname}/trade/option/usdc/public/v1",private:"wss://stream-testnet.{hostname}/trade/option/usdc/private/v1"},swap:{public:"wss://stream-testnet.{hostname}/perpetual/ws/v1/realtime_public",private:"wss://stream-testnet.{hostname}/trade/option/usdc/private/v1"}}}}},options:{watchTicker:{name:"realtimes"}},streaming:{ping:this.ping,keepAlive:2e4},exceptions:{ws:{exact:{}}}})}getUrlByMarketType(e=void 0,t=!1,s=void 0,i={}){const n=t?"private":"public";let r,a,o,d,c,u=this.urls.api.ws;if(e!==void 0)c=this.market(e),r=c.settle==="USDC",a=c.spot,o=c.type,d=c.linear;else{[o,i]=this.handleMarketTypeAndParams(s,void 0,i);const h=this.safeString(this.options,"defaultSubType","linear"),l=this.safeString(i,"subType",h);let p=this.safeString(this.options,"defaultSettle");p=this.safeString2(i,"settle","defaultSettle",p),r=p==="USDC",a=o==="spot",d=l==="linear"}return a?u=u.spot[n]:r?u=u.usdc[o][n]:d?u=u.linear[n]:u=u.inverse[n],u=this.implodeHostname(u),u}cleanParams(e){return e=this.omit(e,["type","subType","settle","defaultSettle"]),e}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i="ticker:"+s.symbol,n=this.getUrlByMarketType(e,!1,t);if(t=this.cleanParams(t),s.spot){const r=this.safeValue(this.options,"watchTicker",{}),a=this.safeString(r,"name","realtimes"),o={symbol:s.id};return await this.watchSpotPublic(n,a,i,o,t)}else{const a=["instrument_info.100ms."+s.id];return await this.watchContractPublic(n,i,a,t)}}handleTicker(e,t){const s=this.safeString(t,"topic","");if(s==="realtimes"||s==="bookTicker"){const o=this.safeValue(t,"data"),d=this.parseWsTicker(o),c=d.symbol;this.tickers[c]=d;const u="ticker:"+c;e.resolve(d,u);return}const i=this.safeString(t,"type",""),n=this.safeValue(t,"data",{});let r;if(i==="snapshot"){const o=this.parseWsTicker(n);r=o.symbol,this.tickers[r]=o}if(i==="delta"){const o=s.split("."),d=o.length,c=this.safeString(o,d-1);r=this.market(c).symbol;const h=this.safeValue(n,"update",[]);let l=this.safeValue(this.tickers,r,{});for(let p=0;p<h.length;p++){const m=h[p];l=this.updateTicker(l,m)}this.tickers[r]=l}const a="ticker:"+r;e.resolve(this.tickers[r],a)}updateTicker(e,t){const s=e.info,i=Object.keys(t);if(i.length>0){for(let a=0;a<i.length;a++){const o=i[a];o in s&&(s[o]=t[o])}return this.parseWsTicker(s)}return e}parseWsTicker(e,t=void 0){let s=this.safeInteger2(e,"time","t");if(s===void 0&&(s=this.parse8601(this.safeString2(e,"updated_at","updatedAt")),s===void 0)){const g=this.safeString(e,"updated_at_e9");s=Ch.stringDiv(g,"1000000"),s=this.parseNumber(s),s=s!==void 0?parseInt(s):void 0}const i=this.safeString2(e,"symbol","s"),n=this.safeSymbol(i,t),r=this.safeStringN(e,["c","last_price","lastPrice"]),a=this.safeStringN(e,["prev_price_24h","o","prevPrice24h"]);let o=this.safeStringN(e,["v","turnover24h"]);o===void 0&&(o=this.safeString2(e,"turnover_24h_e8","turnover24hE8"),o=Ch.stringDiv(o,"100000000"));let d=this.safeStringN(e,["qv","volume24h","volume_24h"]);d===void 0&&(d=this.safeString2(e,"volume_24h_e8","volume24hE8"),d=Ch.stringDiv(d,"100000000"));const c=this.safeStringN(e,["bidPrice","bid1_price","bid1Price"]),u=this.safeStringN(e,["askPrice","ask1_price","ask1Price"]),h=this.safeStringN(e,["high_price_24h","high24h","h","highPrice24h"]),l=this.safeStringN(e,["low_price_24h","low24h","l","lowPrice24h"]);let p=this.safeString(e,"m");p===void 0&&(p=this.safeString2(e,"price_24h_pcnt_e6","price24hPcntE6"),p=Ch.stringDiv(p,"1000000"));const m=this.safeString(e,"change24h");return this.safeTicker({symbol:n,timestamp:s,datetime:this.iso8601(s),high:h,low:l,bid:c,bidVolume:this.safeString2(e,"bidSize","bidQty"),ask:u,askVolume:this.safeString2(e,"askSize","askQty"),vwap:void 0,open:a,close:r,last:r,previousClose:void 0,change:m,percentage:p,average:void 0,baseVolume:d,quoteVolume:o,info:e},t)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=this.timeframes[t],o=this.getUrlByMarketType(e,!1,n);n=this.cleanParams(n);const d="kline:"+t+":"+e;let c;if(r.spot){const u="kline",h={symbol:r.id,klineType:t};c=await this.watchSpotPublic(o,u,d,h,n)}else{const l=[(r.linear?"candle":"klineV2")+"."+a+"."+r.id];c=await this.watchContractPublic(o,d,l,n)}return this.newUpdates&&(i=c.getLimit(e,i)),this.filterBySinceLimit(c,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(t,"topic");if(Array.isArray(s)){const n=i.split("."),r=n.length,a=this.safeString(n,r-1),o=this.safeString(n,r-2),d={};for(let u=0;u<s.length;u++){const h=s[u],l=this.market(a),p=l.symbol,m=this.parseWsOHLCV(h,l);let g=this.safeValue(this.ohlcvs,p);if(g===void 0){const y=this.safeInteger(this.options,"OHLCVLimit",1e3);g=new tO(y),this.ohlcvs[p]=g}g.append(m),d[p]=o}const c=Object.keys(d);for(let u=0;u<c.length;u++){const h=c[u],l=d[h],m="kline:"+this.findTimeframe(l)+":"+h,g=this.safeValue(this.ohlcvs,h);e.resolve(g,m)}}else{const n=this.safeValue(t,"params",{}),r=this.safeValue(t,"data"),a=this.safeString(n,"symbol"),o=this.safeString(n,"klineType"),d=this.market(a),c=this.parseWsOHLCV(r,d),u=d.symbol;let h=this.safeValue(this.ohlcvs,u);if(h===void 0){const p=this.safeInteger(this.options,"OHLCVLimit",1e3);h=new tO(p),this.ohlcvs[u]=h}h.append(c);const l="kline:"+o+":"+u;e.resolve(h,l)}}parseWsOHLCV(e,t=void 0){let s=this.safeInteger(e,"t");return s===void 0&&(s=this.safeTimestamp(e,"start")),[s,this.safeNumber2(e,"open","o"),this.safeNumber2(e,"high","h"),this.safeNumber2(e,"low","l"),this.safeNumber2(e,"close","c"),this.safeNumber2(e,"volume","v")]}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n=this.getUrlByMarketType(e,!1,s);s=this.cleanParams(s);const r="orderbook:"+e;let a;if(i.spot){const o="depth",d={symbol:i.id};a=await this.watchSpotPublic(n,o,r,d,s)}else{let o;if(i.option)o="delta.orderbook100."+i.marketId;else{if(t!==void 0){if(t!==25&&t!==200)throw new Q$(this.id+" watchOrderBook limit argument must be either 25 or 200")}else t=25;o=(t===25?"orderBookL2_25":"orderBook_200.100ms")+"."+i.id}const d=[o];a=await this.watchContractPublic(n,r,d,s)}return a.limit()}handleOrderBook(e,t){const s=this.safeString(t,"topic",""),i=this.safeValue(t,"data",{});if(s==="depth"){const n=this.safeString(i,"s"),a=this.market(n).symbol,o=this.safeInteger(i,"t"),d=this.parseOrderBook(i,a,o,"b","a");let c;a in this.orderbooks?(c=this.orderbooks[a],c.reset(d)):(c=this.orderBook(d),this.orderbooks[a]=c);const u="orderbook:"+a;e.resolve(c,u);return}if(s.indexOf("orderBook")>=0){const n=this.safeString(t,"type"),r=s.split("."),a=r.length,o=this.safeString(r,a-1),c=this.market(o).symbol,u="orderbook:"+c,h=this.safeInteger2(t,"cross_seq","crossSeq"),l=this.safeIntegerProduct2(t,"timestamp_e6","timestampE6",.001);if(n==="snapshot"){const p=this.safeValue2(i,"order_book","orderBook",i),m=this.parseOrderBook(p,c,l,"Buy","Sell","price","size");m.nonce=h;let g;c in this.orderbooks?(g=this.orderbooks[c],g.reset(m)):(g=this.orderBook(m),this.orderbooks[c]=g)}else if(n==="delta"){const p=this.safeValue(i,"delete",[]),m=this.safeValue(i,"update",[]),g=this.safeValue(i,"insert",[]),y=[];for(let k=0;k<p.length;k++){const T=p[k];T.size=0,y.push(T)}let b=y;b=this.arrayConcat(b,m),b=this.arrayConcat(b,g);const w=this.safeValue(this.orderbooks,c);w.nonce=h,w.timestamp=l,w.datetime=this.iso8601(l),this.handleDeltas(w,b)}e.resolve(this.orderbooks[c],u)}}handleDeltas(e,t){for(let s=0;s<t.length;s++){const i=t[s];this.safeString(i,"side")==="Buy"?this.handleDelta(e.bids,t[s]):this.handleDelta(e.asks,t[s])}}handleDelta(e,t){const s=this.safeNumber(t,"price"),i=this.safeNumber(t,"size");e.store(s,i)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="trade",a=this.getUrlByMarketType(e,!1,i);i=this.cleanParams(i);const o=r+":"+e;let d;if(n.spot){const c={symbol:n.id};d=await this.watchSpotPublic(a,r,o,c,i)}else{let c;n.option?c="recenttrades."+n.baseId:c=r+"."+n.id;const u=[c];d=await this.watchContractPublic(a,o,u,i)}return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySinceLimit(d,t,s,"timestamp",!0)}handleTrades(e,t){let s;const i=this.safeValue(t,"data",[]),n=this.safeString(t,"topic");let r;if(Array.isArray(i)){const u=n.split(".");s=this.safeString(u,1),r=i}else{const u=this.safeValue(t,"params",{});s=this.safeString(u,"symbol"),i.symbol=s,r=[i]}const a=this.safeMarket(s),o=a.symbol;let d=this.safeValue(this.trades,o);if(d===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);d=new J$(u),this.trades[o]=d}for(let u=0;u<r.length;u++){const h=this.parseWsTrade(r[u],a);d.append(h)}const c="trade:"+o;e.resolve(d,c)}parseWsTrade(e,t=void 0){const s=this.safeStringN(e,["trade_id","v","tradeId","T","exec_id"]),i=this.safeString2(e,"symbol","s");t=this.safeMarket(i,t);const n=t.symbol,r=this.safeStringN(e,["p","price","execPrice"]),a=this.safeStringN(e,["q","size","exec_qty","execQty"]),o=this.safeString2(e,"exec_value","execValue");let d=this.safeIntegerN(e,["trade_time_ms","t","tradeTime","tradeTimeMs"]);d===void 0&&(d=this.parse8601(this.safeString(e,"trade_time")));const c=this.safeStringLower(e,"side");let u=this.safeValue2(e,"m","is_maker");u===void 0&&(u=this.safeString(e,"lastLiquidityInd")==="MAKER");const h=u?"maker":"taker",l=this.safeStringN(e,["o","order_id","tradeTime"]);let p;if(this.safeValue(t,"contract")){const g=this.safeString2(e,"exec_fee","execFee");if(g!==void 0){const y=t.linear?t.quote:t.base;p={cost:g,currency:y}}}return this.safeTrade({id:s,info:e,timestamp:d,datetime:this.iso8601(d),symbol:n,order:l,type:void 0,side:c,takerOrMaker:h,price:r,amount:a,cost:o,fee:p},t)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){const n="watchMyTrades";let r="usertrade";await this.loadMarkets();let a,o,d;const c=this.getUrlByMarketType(e,!0,n,i);if(e!==void 0)a=this.market(e),e=a.symbol,r+=":"+e,o=a.type,d=a.settle==="USDC";else{[o,i]=this.handleMarketTypeAndParams(n,void 0,i);let h=this.safeString(this.options,"defaultSettle");h=this.safeString2(i,"settle","defaultSettle",h),d=h==="USDC"}i=this.cleanParams(i);let u;if(o==="spot")u=await this.watchSpotPrivate(c,r,i);else{let h;d?h=o==="option"?"user.openapi.option.trade":"user.openapi.perp.trade":h="execution";const l=[h];r+=":"+h,u=await this.watchContractPrivate(c,r,l,i)}return this.newUpdates&&(s=u.getLimit(e,s)),this.filterBySinceLimit(u,t,s,"timestamp",!0)}handleMyTrades(e,t){const s=this.safeString(t,"topic","");let i=[];if(Array.isArray(t)?i=t:(i=this.safeValue(t,"data",[]),"result"in i&&(i=i.result)),this.myTrades===void 0){const d=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new eO(d)}const n=this.myTrades,r={};for(let d=0;d<i.length;d++){const c=i[d],u=this.parseWsTrade(c),h=u.symbol;r[h]=!0,n.append(u)}const a=Object.keys(r);for(let d=0;d<a.length;d++){let u="usertrade:"+a[d];s&&(u+=":"+s),e.resolve(n,u)}let o="usertrade";s&&(o+=":"+s),e.resolve(n,o)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){const n="watchOrders";let r="order";await this.loadMarkets();let a,o,d;const c=this.getUrlByMarketType(e,!0,n,i);if(e!==void 0)a=this.market(e),e=a.symbol,r+=":"+e,o=a.type,d=a.settle==="USDC";else{[o,i]=this.handleMarketTypeAndParams(n,void 0,i);let h=this.safeString(this.options,"defaultSettle");h=this.safeString2(i,"settle","defaultSettle",h),d=h==="USDC"}i=this.cleanParams(i);let u;if(o==="spot")u=await this.watchSpotPrivate(c,r,i);else{let h;if(d)h=o==="option"?"user.openapi.option.order":"user.openapi.perp.order";else{const p=this.safeString(i,"orderType"),g=this.safeValue(i,"stop",!1)||p==="stop"||p==="conditional";i=this.omit(i,["stop","orderType"]),h=g?"stop_order":"order"}const l=[h];r+=":"+h,u=await this.watchContractPrivate(c,r,l,i)}return this.newUpdates&&(s=u.getLimit(e,s)),this.filterBySymbolSinceLimit(u,e,t,s,!0)}handleOrder(e,t,s=void 0){const i=this.safeString(t,"topic","");let n=[],r=!1;if(Array.isArray(t)?(n=t,r=!0):(n=this.safeValue(t,"data",[]),"result"in n&&(n=n.result)),n.length===0)return;if(this.orders===void 0){const h=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new eO(h)}const o=this.orders,d={};for(let h=0;h<n.length;h++){const l=n[h];let p;r?p=this.parseWsOrder(l):p=this.parseOrder(l);const m=p.symbol;d[m]=!0,o.append(p)}const c=Object.keys(d);for(let h=0;h<c.length;h++){let p="order:"+c[h];i&&(p+=":"+i),e.resolve(o,p)}let u="order";i&&(u+=":"+i),e.resolve(o,u)}parseWsOrder(e,t=void 0){const s=this.safeString(e,"i"),i=this.safeString(e,"s"),n=this.safeSymbol(i,t),r=this.safeInteger(e,"O");let a=this.safeString(e,"p");a==="0"&&(a=void 0);const o=this.safeString(e,"q"),d=this.safeString(e,"z"),c=this.parseOrderStatus(this.safeString(e,"X")),u=this.safeStringLower(e,"S"),h=this.safeString(e,"E"),l=this.safeString(e,"f");let p=this.safeStringLower(e,"o");p.indexOf("market")>=0&&(p="market");let m;const g=this.safeString(e,"n");if(g!==void 0&&g!=="0"){const y=this.safeString(e,"N"),b=this.safeCurrencyCode(y);m={cost:g,currency:b}}return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:h,symbol:n,type:p,timeInForce:l,postOnly:void 0,side:u,price:a,stopPrice:void 0,amount:o,cost:void 0,average:void 0,filled:d,remaining:void 0,status:c,fee:m,trades:void 0},t)}async watchBalance(e={}){const t="watchBalance";let s;if([s,e]=this.handleMarketTypeAndParams(t,void 0,e),s!=="spot"&&s!=="swap")throw new Z$(this.id+" watchBalance does not support "+s+" type");const i="balance:"+s,n=this.getUrlByMarketType(void 0,!0,t,e);if(e=this.cleanParams(e),s==="spot")return await this.watchSpotPrivate(n,i,e);{const r=["wallet"];return await this.watchContractPrivate(n,i,r,e)}}handleBalance(e,t){const s=this.safeString(t,"topic");let i="balance";if(s==="wallet"){const n=this.safeValue(t,"data",[]);for(let r=0;r<n.length;r++){const a=this.account(),o=n[r],d=this.safeString(o,"coin","USDT"),c=this.safeCurrencyCode(d);a.free=this.safeString(o,"available_balance"),a.total=this.safeString(o,"wallet_balance"),this.balance[c]=a,this.balance=this.safeBalance(this.balance)}i+=":swap",e.resolve(this.balance,i);return}if(Array.isArray(t)){for(let n=0;n<t.length;n++){const r=this.safeValue(t[n],"B",[]);for(let a=0;a<r.length;a++){const o=r[a],d=this.account(),c=this.safeCurrencyCode(this.safeString(o,"a"));d.free=this.safeString(o,"f"),d.used=this.safeString(o,"l"),this.balance[c]=d,this.balance=this.safeBalance(this.balance)}}i+=":spot",e.resolve(this.balance,i)}}async watchContractPublic(e,t,s={},i={}){const n={op:"subscribe",args:s},r=this.extend(n,i);return await this.watch(e,t,r,t)}async watchSpotPublic(e,t,s,i={},n={}){i=this.extend(i,{binary:!1});const r={topic:t,event:"sub",params:i},a=this.extend(r,n);return await this.watch(e,s,a,s)}async watchSpotPrivate(e,t,s={}){const i="private";this.checkRequiredCredentials();let n=this.milliseconds()+1e4;n=n.toString();const a="GET/realtime"+n,o=this.hmac(this.encode(a),this.encode(this.secret),"sha256","hex"),d={op:"auth",args:[this.apiKey,n,o]};return await this.watch(e,t,d,i)}async watchContractPrivate(e,t,s,i={}){return await this.authenticateContract(e,i),await this.watchContractPublic(e,t,s,i)}async authenticateContract(e,t={}){this.checkRequiredCredentials();const s="login",i=this.client(e);let n=this.safeValue(i.subscriptions,s);if(n===void 0){n=i.future("authenticated");let r=this.milliseconds()+1e4;r=r.toString();const o="GET/realtime"+r,d=this.hmac(this.encode(o),this.encode(this.secret),"sha256","hex"),c={op:"auth",args:[this.apiKey,r,d]};this.spawn(this.watch,e,s,c,s,n)}return await n}handleErrorMessage(e,t){const s=this.safeInteger(t,"code");try{if(s!==void 0){const n=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,n)}if(!this.safeValue(t,"success",!1)){const n=this.safeString(t,"ret_msg"),r=this.safeValue(t,"request",{});if(this.safeString(r,"op")==="auth")throw new JT("Authentication failed: "+n)}}catch(i){if(i instanceof JT){e.reject(i,"authenticated");const n="login";return n in e.subscriptions&&delete e.subscriptions[n],!1}}return t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;if(this.safeString(t,"ret_msg")==="pong"){this.handlePong(e,t);return}if(this.safeInteger(t,"pong")!==void 0){this.handlePong(e,t);return}if(this.safeString(t,"op")==="pong"){this.handlePong(e,t);return}if(this.safeString(t,"event")==="sub"){this.handleSubscriptionStatus(e,t);return}const a=this.safeString(t,"topic","");if(a.indexOf("kline")>=0||a.indexOf("candle")>=0){this.handleOHLCV(e,t);return}if(a.indexOf("realtimes")>=0||a.indexOf("instrument_info")>=0){this.handleTicker(e,t);return}if(a.indexOf("trade")>=0){if(a.indexOf("user")>=0){this.handleMyTrades(e,t);return}this.handleTrades(e,t)}if(a.indexOf("orderBook")>=0){this.handleOrderBook(e,t);return}if(a.indexOf("order")>=0){this.handleOrder(e,t);return}const o={realtimes:this.handleTicker,bookTicker:this.handleTicker,depth:this.handleOrderBook,wallet:this.handleBalance,execution:this.handleMyTrades},d=this.safeValue(o,a);d!==void 0&&d.call(this,e,t);const c=this.safeValue(t,"request",{});if(this.safeString(c,"op")==="auth"&&this.handleAuthenticate(e,t),this.safeString(t,"type")==="AUTH_RESP"&&this.handleAuthenticate(e,t),Array.isArray(t)){const l=this.safeValue(t,0),p=this.safeString(l,"e");p==="outboundAccountInfo"&&this.handleBalance(e,t),p==="executionReport"&&this.handleOrder(e,t),p==="ticketInfo"&&this.handleMyTrades(e,t)}}ping(e){const t=e.url,s=this.milliseconds();return t.indexOf("spot")>=0?{ping:s}:{op:"ping"}}handlePong(e,t){return e.lastPong=this.safeInteger(t,"pong"),t}handleAuthenticate(e,t){return e.resolve(t,"authenticated"),t}handleSubscriptionStatus(e,t){return t}};const{ExchangeError:qg,ArgumentsRequired:sO}=de,iO=Se,tj=$_,{ArrayCacheBySymbolById:nO,ArrayCacheByTimestamp:sj,ArrayCache:ij}=rt;var nj=class extends tj{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!0,watchTrades:!0,watchMyTrades:!0,watchOrders:!0,watchOrderBook:!0,watchOHLCV:!0,watchPosition:void 0},urls:{api:{ws:"wss://ws.cex.io/ws"}},options:{orderbook:{}},streaming:{},exceptions:{}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}async watchBalance(e={}){await this.authenticate(e);const t="balance",s=this.urls.api.ws,i={e:"get-balance",data:{},oid:this.requestId()},n=this.deepExtend(i,e);return await this.watch(s,t,n,t,n)}handleBalance(e,t){const s=this.safeValue(t,"data",{}),i=this.safeValue(s,"balance",{}),n=this.safeValue(s,"obalance",{}),r={},a=Object.keys(i);for(let o=0;o<a.length;o++){const d=a[o],c=this.account();c.free=this.safeString(i,d),c.used=this.safeString(n,d);const u=this.safeCurrencyCode(d);r[u]=c}this.balance=this.safeBalance(r),e.resolve(this.balance,"balance")}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r=this.urls.api.ws,a="trades",o="old:"+e,d=this.safeValue(this.clients,r);if(d!==void 0){const l=Object.keys(d.subscriptions);for(let p=0;p<l.length;p++){let m=l[p];if(m!==o&&(m=m.slice(0,3),m==="old"))throw new qg(this.id+" watchTrades() only supports watching one symbol at a time.")}}const c={e:"subscribe",rooms:["pair-"+n.base+"-"+n.quote]},u=this.deepExtend(c,i),h=await this.watch(r,a,u,o);for(let l=0;l<h.length;l++)h[l].symbol=e;return this.filterBySinceLimit(h,t,s,"timestamp",!0)}handleTradesSnapshot(e,t){const s=this.safeValue(t,"data",[]),i=this.safeInteger(this.options,"tradesLimit",1e3),n=new ij(i);for(let a=0;a<s.length;a++){const o=s[a],d=this.parseWsOldTrade(o);n.append(d)}const r="trades";this.trades=n,e.resolve(this.trades,r)}parseWsOldTrade(e,t=void 0){Array.isArray(e)||(e=e.split(":"));const s=this.safeString(e,0),i=this.safeNumber(e,1),n=this.safeString(e,2),r=this.safeString(e,3),a=this.safeString(e,4);return this.safeTrade({info:e,id:a,timestamp:i,datetime:this.iso8601(i),symbol:void 0,type:void 0,side:s,order:void 0,takerOrMaker:void 0,price:r,amount:n,cost:void 0,fee:void 0},t)}handleTrade(e,t){const s=this.safeValue(t,"data",[]),i=this.trades;for(let r=0;r<s.length;r++){const a=s[r],o=this.parseWsOldTrade(a);i.append(o)}const n="trades";this.trades=i,e.resolve(this.trades,n)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i=this.urls.api.ws,n="ticker:"+e,r=this.safeString(t,"method","private");let a={e:"subscribe",rooms:["tickers"]},o="tickers";r==="private"&&(await this.authenticate(),a={e:"ticker",data:[s.baseId,s.quoteId],oid:this.requestId()},o="ticker:"+e);const d=this.deepExtend(a,t);return await this.watch(i,n,d,o)}async watchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.urls.api.ws,i="tickers",n={e:"subscribe",rooms:["tickers"]},r=this.deepExtend(n,t),a=await this.watch(s,i,r,i),o=a.symbol;if(e!==void 0&&!this.inArray(e,o))return await this.watchTickers(e,t);if(this.newUpdates){const d={};return d[o]=a,d}return this.filterByArray(this.tickers,"symbol",e)}handleTicker(e,t){const s=this.safeValue(t,"data",{}),i=this.parseWsTicker(s),n=i.symbol,r="ticker:"+n;this.tickers[n]=i,e.resolve(i,r),e.resolve(i,"tickers")}parseWsTicker(e,t=void 0){const s=this.safeValue(e,"pair",[]);let i=this.safeString(e,"symbol1");i===void 0&&(i=this.safeString(s,0));let n=this.safeString(e,"symbol2");n===void 0&&(n=this.safeString(s,1));const r=this.safeCurrencyCode(i),a=this.safeCurrencyCode(n),o=r+"/"+a;let d=this.safeInteger(e,"timestamp");return d!==void 0&&(d=d*1e3),this.safeTicker({symbol:o,timestamp:d,datetime:this.iso8601(d),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open24"),close:void 0,last:this.safeString2(e,"price","last"),previousClose:void 0,change:this.safeString(e,"priceChange"),percentage:this.safeString(e,"priceChangePercentage"),average:void 0,baseVolume:void 0,quoteVolume:this.safeString(e,"volume"),info:e},t)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new sO(this.id+" watchOrders requires a symbol argument");await this.loadMarkets(),await this.authenticate(i);const n=this.urls.api.ws,r=this.market(e);e=r.symbol;const a="orders:"+e,o={e:"open-orders",data:{pair:[r.baseId,r.quoteId]},oid:e},d=this.deepExtend(o,i),c=await this.watch(n,a,d,a,d);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new sO(this.id+" watchOrders requires a symbol argument");await this.loadMarkets(),await this.authenticate(i);const n=this.urls.api.ws,r=this.market(e),a="myTrades:"+r.symbol,o="orders:"+r.symbol,d={e:"open-orders",data:{pair:[r.baseId,r.quoteId]},oid:r.symbol},c=this.deepExtend(d,i),u=await this.watch(n,a,c,o,c);return this.filterBySymbolSinceLimit(u,r.symbol,t,s,!0)}handleTransaction(e,t){const s=this.safeValue(t,"data");this.safeString(s,"symbol2")!==void 0&&(this.handleOrderUpdate(e,t),this.handleMyTrades(e,t))}handleMyTrades(e,t){const s=this.safeValue(t,"data",{});let i=this.myTrades;if(i===void 0){const a=this.safeInteger(this.options,"tradesLimit",1e3);i=new nO(a),this.myTrades=i}const n=this.parseWsTrade(s);i.append(n);const r="myTrades:"+n.symbol;e.resolve(i,r)}parseWsTrade(e,t=void 0){const s=this.safeString(e,"type"),i=this.safeString(e,"price"),n=this.safeString(e,"time"),r=this.safeString(e,"symbol"),a=this.safeString(e,"symbol2"),o=this.safeCurrencyCode(r),d=this.safeCurrencyCode(a);let c=o+"/"+d,u=this.safeString(e,"amount");s==="sell"&&(c=d+"/"+o,u=iO.stringDiv(u,i));const h={id:this.safeString(e,"id"),order:this.safeString(e,"order"),info:e,timestamp:this.parse8601(n),datetime:n,symbol:c,type:void 0,side:s,takerOrMaker:void 0,price:i,cost:void 0,amount:u,fee:void 0},l=this.safeString(e,"fee_amount");return l!==void 0&&(h.fee={cost:l,currency:d,rate:void 0}),this.safeTrade(h,t)}handleOrderUpdate(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(t,"e")==="tx",n=this.safeString2(s,"id","order");let r=this.safeString(s,"remains"),a=this.safeString(s,"symbol"),o=this.safeString(s,"symbol2");const d=this.safeValue(s,"pair");d!==void 0&&(a=this.safeString(d,"symbol1"),o=this.safeString(d,"symbol2"));const c=this.safeCurrencyCode(a),u=this.safeCurrencyCode(o),h=c+"/"+u,l=this.safeMarket(h);r=this.currencyFromPrecision(c,r);const p=this.safeValue(this.orders.hashmap,h,{});let m=this.safeValue(p,n);m===void 0&&(m=this.parseWsOrderUpdate(s,l)),m.remaining=r,this.safeValue(s,"cancel",!1)&&(m.status="canceled"),i&&(m.status="closed");const y=this.safeNumber(s,"fee");y!==void 0&&(m.fee={cost:y,currency:u,rate:void 0});const b=this.safeInteger(s,"time",this.milliseconds());m.timestamp=b,m.datetime=this.iso8601(b),m=this.safeOrder(m);const w=this.orders;w.append(m);const k="orders:"+h;e.resolve(w,k)}parseWsOrderUpdate(e,t=void 0){const s=this.safeValue(e,"d")!==void 0,i=this.safeString(e,"remains");let n;i!==void 0&&(n=this.currencyFromPrecision(t.base,i));const r=this.safeString(e,"amount");s||this.currencyFromPrecision(t.base,r);let a=this.safeString(e,"symbol"),o=this.safeString(e,"symbol2");this.safeValue(e,"pair")!==void 0&&(a=this.safeString(e,"symbol1"),o=this.safeString(e,"symbol2"));const c=this.safeCurrencyCode(a),u=this.safeCurrencyCode(o),h=c+"/"+u;t=this.safeMarket(h,t);const l=this.safeInteger(e,"time",this.milliseconds());let p=l;s&&(p=this.parse8601(l));const m=this.safeValue(e,"cancel",!1);let g="open";m?g="canceled":s&&(g="closed");const y={id:this.safeString2(e,"id","order"),clientOrderId:void 0,info:e,timestamp:p,datetime:this.iso8601(p),lastTradeTimestamp:void 0,status:g,symbol:h,type:void 0,timeInForce:void 0,postOnly:void 0,side:this.safeString(e,"type"),price:this.safeNumber(e,"price"),stopPrice:void 0,average:void 0,cost:void 0,amount:r,filled:void 0,remaining:n,fee:{cost:this.safeNumber2(e,"fee","fee_amount"),currency:u,rate:void 0},trades:void 0};return s&&(y.trades=this.parseWsTrade(e,t)),this.safeOrder(y,t)}fromPrecision(e,t){if(e===void 0)return;const s=new iO(e);return s.decimals=this.sum(s.decimals,t),s.reduce(),s.toString()}currencyFromPrecision(e,t){const s=this.safeInteger(this.currencies[e],"precision",0);return this.fromPrecision(t,s)}handleOrdersSnapshot(e,t){const s=this.safeString(t,"oid"),i=this.safeValue(t,"data",[]);let n=this.orders;if(this.orders===void 0){const a=this.safeInteger(this.options,"ordersLimit",1e3);n=new nO(a)}for(let a=0;a<i.length;a++){const o=i[a],d=this.safeMarket(s),c=this.parseOrder(o,d);c.status="open",n.append(c)}this.orders=n;const r="orders:"+s;e.resolve(n,r)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets(),await this.authenticate();const i=this.market(e);e=i.symbol;const n=this.urls.api.ws,r="orderbook:"+e,a=t===void 0?0:t,o={e:"order-book-subscribe",data:{pair:[i.baseId,i.quoteId],subscribe:!0,depth:a},oid:this.requestId()},d=this.deepExtend(o,s);return(await this.watch(n,r,d,r)).limit(t)}handleOrderBookSnapshot(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(s,"pair"),n=this.pairToSymbol(i),r="orderbook:"+n,a=this.safeInteger2(s,"timestamp_ms","timestamp"),o=this.safeNumber(s,"id"),d=this.orderBook({}),c=this.parseOrderBook(s,n,a,"bids","asks");c.nonce=o,d.reset(c),this.options.orderbook[n]={incrementalId:o},this.orderbooks[n]=d,e.resolve(d,r)}pairToSymbol(e){const t=e.split(":"),s=this.safeString(t,0),i=this.safeString(t,1),n=this.safeCurrencyCode(s),r=this.safeCurrencyCode(i);return n+"/"+r}handleOrderBookUpdate(e,t){const s=this.safeValue(t,"data",{}),i=this.safeNumber(s,"id"),n=this.safeString(s,"pair",""),r=this.pairToSymbol(n),a=this.safeValue(this.orderbooks,r);if(i!==a.nonce+1)throw new qg(this.id+" watchOrderBook() skipped a message");const o="orderbook:"+r,d=this.safeInteger(s,"time"),c=this.safeValue(s,"asks",[]),u=this.safeValue(s,"bids",[]);this.handleDeltas(a.asks,c),this.handleDeltas(a.bids,u),a.timestamp=d,a.datetime=this.iso8601(d),a.nonce=i,e.resolve(a,o)}handleDelta(e,t){const s=this.parseBidAsk(t,0,1);e.storeArray(s)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a="ohlcv:"+e,o=this.urls.api.ws,d={e:"init-ohlcv",i:t,rooms:["pair-"+r.baseId+"-"+r.quoteId]},c=await this.watch(o,a,this.extend(d,n),a);return this.newUpdates&&(i=c.getLimit(e,i)),this.filterBySinceLimit(c,s,i,0,!0)}handleInitOHLCV(e,t){const i=this.safeString(t,"pair").split(":"),n=this.safeString(i,0),r=this.safeString(i,1),a=this.safeCurrencyCode(n),o=this.safeCurrencyCode(r),d=a+"/"+o,c=this.safeMarket(d),u="ohlcv:"+d,h=this.safeValue(t,"data",[]),l=this.safeInteger(this.options,"OHLCVLimit",1e3),p=new sj(l),m=this.sortBy(h,0);for(let g=0;g<m.length;g++)p.append(this.parseOHLCV(m[g],c));this.ohlcvs[d]=p,e.resolve(p,u)}handleOHLCV24(e,t){return t}handleOHLCV1m(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(s,"pair"),n=this.pairToSymbol(i),r="ohlcv:"+n,a=[this.safeTimestamp(s,"time"),this.safeNumber(s,"o"),this.safeNumber(s,"h"),this.safeNumber(s,"l"),this.safeNumber(s,"c"),this.safeNumber(s,"v")],o=this.safeValue(this.ohlcvs,n);o.append(a),e.resolve(o,r)}handleOHLCV(e,t){const s=this.safeValue(t,"data",[]),i=this.safeString(t,"pair"),n=this.pairToSymbol(i),r="ohlcv:"+n,a=this.safeValue(this.ohlcvs,n);for(let o=0;o<s.length;o++){const d=[this.safeTimestamp(s[o],0),this.safeNumber(s[o],1),this.safeNumber(s[o],2),this.safeNumber(s[o],3),this.safeNumber(s[o],4),this.safeNumber(s[o],5)];a.append(d)}s.length>0&&e.resolve(a,r)}handleConnected(e,t){return t}handleErrorMessage(e,t){throw new qg(this.id+" "+this.json(t))}handleMessage(e,t){if(this.safeString(t,"ok")==="error")return this.handleErrorMessage(e,t);const i=this.safeString(t,"e"),n={auth:this.handleAuthenticationMessage,connected:this.handleConnected,tick:this.handleTicker,ticker:this.handleTicker,"init-ohlcv-data":this.handleInitOHLCV,ohlcv24:this.handleOHLCV24,ohlcv1m:this.handleOHLCV1m,ohlcv:this.handleOHLCV,"get-balance":this.handleBalance,"order-book-subscribe":this.handleOrderBookSnapshot,md_update:this.handleOrderBookUpdate,"open-orders":this.handleOrdersSnapshot,order:this.handleOrderUpdate,"history-update":this.handleTrade,history:this.handleTradesSnapshot,tx:this.handleTransaction},r=this.safeValue(n,i);return r!==void 0?r.call(this,e,t):t}handleAuthenticationMessage(e,t){const s=this.safeValue(e.futures,"authenticated");s!==void 0&&s.resolve(!0)}async authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i="authenticated",n=s.future("authenticated");if(this.safeValue(s.subscriptions,i)===void 0){this.checkRequiredCredentials();const a=this.seconds().toString(),o=a+this.apiKey,d=this.hmac(this.encode(o),this.encode(this.secret)),c={e:"auth",auth:{key:this.apiKey,signature:d.toUpperCase(),timestamp:a}};this.spawn(this.watch,t,i,this.extend(c,e),i)}return await n}};const rj=Mb,{BadSymbol:rO}=de,{ArrayCache:aj,ArrayCacheBySymbolById:aO}=rt;var hC=class extends rj{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOHLCV:!1,watchOrderBook:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchBalance:!1,watchStatus:!1,watchOrders:!0,watchMyTrades:!0},urls:{api:{ws:"wss://ws-feed.pro.coinbase.com"}},options:{tradesLimit:1e3,ordersLimit:1e3,myTradesLimit:1e3}})}authenticate(){this.checkRequiredCredentials();const e="/users/self/verify",t=this.nonce(),s=t.toString()+"GET"+e,i=this.hmac(this.encode(s),this.base64ToBinary(this.secret),"sha256","base64");return{timestamp:t,key:this.apiKey,signature:i,passphrase:this.password}}async subscribe(e,t,s,i={}){await this.loadMarkets();const n=this.market(t),r=s+":"+n.id;let a=this.urls.api.ws;"signature"in i&&(a=a+"?");const o={type:"subscribe",product_ids:[n.id],channels:[e]},d=this.extend(o,i);return await this.watch(a,r,d,r)}async watchTicker(e,t={}){const s="ticker";return await this.subscribe(s,e,s,t)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n="matches",r=await this.subscribe(n,e,n,i);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySinceLimit(r,t,s,"timestamp",!0)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new rO(this.id+" watchMyTrades requires a symbol");await this.loadMarkets(),e=this.symbol(e);const n="user",r="myTrades",a=this.authenticate(),o=await this.subscribe(n,e,r,this.extend(i,a));return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new rO(this.id+" watchMyTrades requires a symbol");await this.loadMarkets(),e=this.symbol(e);const n="user",r="orders",a=this.authenticate(),o=await this.subscribe(n,e,r,this.extend(i,a));return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}async watchOrderBook(e,t=void 0,s={}){const i="level2";await this.loadMarkets();const n=this.market(e);e=n.symbol;const r=i+":"+n.id,a=this.urls.api.ws,o={type:"subscribe",product_ids:[n.id],channels:[i]},d=this.extend(o,s),c={messageHash:r,symbol:e,marketId:n.id,limit:t};return(await this.watch(a,r,d,r,c)).limit()}handleTrade(e,t){const s=this.safeString(t,"product_id");if(s!==void 0){const i=this.parseWsTrade(t),n=i.symbol,a="matches"+":"+s;let o=this.safeValue(this.trades,n);if(o===void 0){const d=this.safeInteger(this.options,"tradesLimit",1e3);o=new aj(d),this.trades[n]=o}o.append(i),e.resolve(o,a)}return t}handleMyTrade(e,t){const s=this.safeString(t,"product_id");if(s!==void 0){const i=this.parseWsTrade(t),r="myTrades"+":"+s;let a=this.myTrades;if(a===void 0){const o=this.safeInteger(this.options,"myTradesLimit",1e3);a=new aO(o),this.myTrades=a}a.append(i),e.resolve(a,r)}return t}parseWsTrade(e){const t=super.parseTrade(e);let s;"maker_fee_rate"in e?(t.takerOrMaker="maker",s=this.safeNumber(e,"maker_fee_rate")):(t.takerOrMaker="taker",s=this.safeNumber(e,"taker_fee_rate"));const n=this.market(t.symbol).quote;let r;return t.cost!==void 0&&s!==void 0&&(r=t.cost*s),t.fee={rate:s,cost:r,currency:n},t}parseWsOrderStatus(e){const t={filled:"closed",canceled:"canceled"};return this.safeString(t,e,"open")}handleOrder(e,t){let s=this.orders;if(s===void 0){const r=this.safeInteger(this.options,"ordersLimit",1e3);s=new aO(r),this.orders=s}const i=this.safeString(t,"type"),n=this.safeString(t,"product_id");if(n!==void 0){const r="orders:"+n,a=this.safeSymbol(n),o=this.safeString(t,"order_id"),d=this.safeString(t,"maker_order_id"),c=this.safeString(t,"taker_order_id"),u=this.orders,h=this.safeValue(u.hashmap,a,{});let l=this.safeValue(h,o);if(l===void 0&&(l=this.safeValue2(h,d,c)),l===void 0){const p=this.parseWsOrder(t);u.append(p),e.resolve(u,r)}else{const p=this.safeInteger(t,"sequence"),m=this.safeValue(l,"info",{}),g=this.safeInteger(m,"sequence");if(g===void 0||p>g){if(i==="match"){const y=this.parseWsTrade(t);l.trades===void 0&&(l.trades=[]),l.trades.push(y),l.lastTradeTimestamp=y.timestamp;let b=0,w=0;const k=l.trades;for(let T=0;T<k.length;T++){const O=k[T];b=this.sum(b,O.cost),w=this.sum(w,O.amount)}w>0&&(l.average=b/w),l.cost=b,l.filled!==void 0&&(l.filled+=y.amount,l.amount!==void 0&&(l.remaining=l.amount-l.filled)),l.fee===void 0&&(l.fee={cost:0,currency:y.fee.currency}),l.fee.cost!==void 0&&y.fee.cost!==void 0&&(l.fee.cost=this.sum(l.fee.cost,y.fee.cost)),u.append(l),e.resolve(u,r)}else if(i==="received"||i==="done"){const y=this.extend(l.info,t),b=this.parseWsOrder(y),w=Object.keys(b);for(let k=0;k<w.length;k++){const T=w[k];b[T]!==void 0&&(l[T]=b[T])}u.append(l),e.resolve(u,r)}}}}}parseWsOrder(e){const t=this.safeString(e,"order_id"),s=this.safeString(e,"client_oid"),i=this.safeString(e,"product_id"),n=this.safeSymbol(i),r=this.safeString(e,"side"),a=this.safeNumber(e,"price"),o=this.safeNumber2(e,"size","funds"),d=this.safeString(e,"time"),c=this.parse8601(d),u=this.safeString(e,"reason"),h=this.parseWsOrderStatus(u),l=this.safeString(e,"order_type");let p=this.safeNumber(e,"remaining_size");const m=this.safeString(e,"type");let g;o!==void 0&&p!==void 0?g=o-p:m==="received"&&(g=0,o!==void 0&&(p=o-g));let y;return a!==void 0&&o!==void 0&&(y=a*o),{info:e,symbol:n,id:t,clientOrderId:s,timestamp:c,datetime:this.iso8601(c),lastTradeTimestamp:void 0,type:l,timeInForce:void 0,postOnly:void 0,side:r,price:a,stopPrice:void 0,amount:o,cost:y,average:void 0,filled:g,remaining:p,status:h,fee:void 0,trades:void 0}}handleTicker(e,t){const s=this.safeString(t,"product_id");if(s!==void 0){const i=this.parseTicker(t),n=i.symbol;this.tickers[n]=i;const a=this.safeString(t,"type")+":"+s;e.resolve(i,a)}return t}parseTicker(e,t=void 0){if(this.safeString(e,"type")===void 0)return super.parseTicker(e,t);const i=this.safeString(e,"product_id"),n=this.safeSymbol(i,t,"-"),r=this.parse8601(this.safeString(e,"time")),a=this.safeNumber(e,"price");return{symbol:n,timestamp:r,datetime:this.iso8601(r),high:this.safeNumber(e,"high_24h"),low:this.safeNumber(e,"low_24h"),bid:this.safeNumber(e,"best_bid"),bidVolume:void 0,ask:this.safeNumber(e,"best_ask"),askVolume:void 0,vwap:void 0,open:this.safeNumber(e,"open_24h"),close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeNumber(e,"volume_24h"),quoteVolume:void 0,info:e}}handleDelta(e,t){const s=this.safeNumber(t,0),i=this.safeNumber(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBook(e,t){const s=this.safeString(t,"type"),i=this.safeString(t,"product_id"),r=this.safeMarket(i,void 0,"-").symbol,o="level2"+":"+i,d=this.safeValue(e.subscriptions,o,{}),c=this.safeInteger(d,"limit");if(s==="snapshot"){this.orderbooks[r]=this.orderBook({},c);const u=this.orderbooks[r];this.handleDeltas(u.asks,this.safeValue(t,"asks",[])),this.handleDeltas(u.bids,this.safeValue(t,"bids",[])),u.timestamp=void 0,u.datetime=void 0,e.resolve(u,o)}else if(s==="l2update"){const u=this.orderbooks[r],h=this.parse8601(this.safeString(t,"time")),l=this.safeValue(t,"changes",[]),p={sell:"asks",buy:"bids"};for(let m=0;m<l.length;m++){const g=l[m],y=this.safeString(g,0),b=this.safeString(p,y),w=this.safeNumber(g,1),k=this.safeNumber(g,2);u[b].store(w,k)}u.timestamp=h,u.datetime=this.iso8601(h),e.resolve(u,o)}}handleSubscriptionStatus(e,t){return t}handleMessage(e,t){const s=this.safeString(t,"type"),i={snapshot:this.handleOrderBook,l2update:this.handleOrderBook,subscribe:this.handleSubscriptionStatus,ticker:this.handleTicker,received:this.handleOrder,open:this.handleOrder,change:this.handleOrder,done:this.handleOrder},n=e.url.length-0,r=e.url[n-1]==="?",a=this.safeValue(i,s);if(a===void 0)s==="match"&&(r?(this.handleMyTrade(e,t),this.handleOrder(e,t)):this.handleTrade(e,t));else return a.call(this,e,t)}};const oj=hC;var dj=class extends oj{describe(){return this.deepExtend(super.describe(),{id:"coinbaseprime",name:"Coinbase Prime",has:{ws:!0,watchOrderBook:!0},urls:{test:{ws:"wss://ws-feed-public.sandbox.exchange.coinbase.com"},logo:"https://user-images.githubusercontent.com/1294454/44539184-29f26e00-a70c-11e8-868f-e907fc236a7c.jpg",api:{ws:"wss://ws-feed.exchange.coinbase.com"},www:"https://exchange.coinbase.com",doc:"https://docs.exchange.coinbase.com/",fees:"https://pro.coinbase.com/fees"}})}};const Lg=Se,cj=j_,{AuthenticationError:uj,BadRequest:fj,ExchangeNotAvailable:hj,NotSupported:Mh,RequestTimeout:lj,ExchangeError:Rg}=de,{ArrayCache:pj,ArrayCacheByTimestamp:mj,ArrayCacheBySymbolById:gj}=rt;var yj=class extends cj{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchMyTrades:!1,watchOrders:!0,watchOrderBook:!0,watchOHLCV:!1},urls:{api:{ws:{spot:"wss://socket.coinex.com/",swap:"wss://perpetual.coinex.com/"}}},options:{account:"spot",watchOrderBook:{limits:[5,10,20,50],defaultLimit:50,aggregations:["10","1","0","0.1","0.01"],defaultAggregation:"0"}},streaming:{},exceptions:{codes:{1:fj,2:Rg,3:hj,4:Mh,5:lj,6:uj}},timeframes:{"1m":60,"3m":180,"5m":300,"15m":900,"30m":1800,"1h":3600,"2h":7200,"4h":14400,"6h":21600,"12h":43200,"1d":86400,"3d":259200,"1w":604800}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}handleTicker(e,t){const s=this.safeValue(t,"params",[]),i=this.safeValue(s,0,{}),n=Object.keys(i),r=this.safeString(n,0),a=this.safeSymbol(r),o=this.safeValue(i,r,{}),d=this.safeMarket(r),c=this.parseWSTicker(o,d),u="ticker:"+a;this.tickers[a]=c,e.resolve(c,u)}parseWSTicker(e,t=void 0){return this.safeTicker({symbol:this.safeSymbol(void 0,t),timestamp:void 0,datetime:void 0,high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:this.safeString(e,"buy_total"),ask:void 0,askVolume:this.safeString(e,"sell_total"),vwap:void 0,open:this.safeString(e,"open"),close:this.safeString(e,"close"),last:this.safeString(e,"last"),previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:this.safeString(e,"deal"),info:e},t)}async watchBalance(e={}){await this.loadMarkets(),await this.authenticate(e);const t="balance";let s;[s,e]=this.handleMarketTypeAndParams("watchBalance",void 0,e);const i=this.urls.api.ws[s],r={method:"asset.subscribe",params:Object.keys(this.currencies_by_id),id:this.requestId()},a=this.deepExtend(r,e);return await this.watch(i,t,a,t)}handleBalance(e,t){const s=this.safeValue(t,"params",[]),i=this.safeValue(s,0,{}),n=Object.keys(i);for(let a=0;a<n.length;a++){const o=n[a],d=this.safeCurrencyCode(o),c=this.safeString(i[o],"available"),u=this.safeString(i[o],"frozen"),h=Lg.stringAdd(c,u),l=this.account();l.free=this.parseNumber(c),l.used=this.parseNumber(u),l.total=this.parseNumber(h),this.balance[d]=l,this.balance=this.safeBalance(this.balance)}const r="balance";e.resolve(this.balance,r)}handleTrades(e,t){const s=this.safeValue(t,"params",[]),i=this.safeString(s,0),n=this.safeValue(s,1,[]),r=this.safeMarket(i),a=this.safeSymbol(i),o="trades:"+a;let d=this.safeValue(this.trades,a);if(d===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);d=new pj(c),this.trades[a]=d}for(let c=0;c<n.length;c++){const u=n[c],h=this.parseWSTrade(u,r);d.append(h)}this.trades[a]=d,e.resolve(this.trades[a],o)}parseWSTrade(e,t=void 0){const s=this.safeTimestamp(e,"time");return this.safeTrade({id:this.safeString(e,"id"),info:e,timestamp:s,datetime:this.iso8601(s),symbol:this.safeSymbol(void 0,t),order:void 0,type:void 0,side:this.safeString(e,"type"),takerOrMaker:void 0,price:this.safeString(e,"price"),amount:this.safeString(e,"amount"),cost:void 0,fee:void 0},t)}handleOHLCV(e,t){const s=this.safeValue(t,"params",[]),i="ohlcv",n=this.parseOHLCVs(s);if(Object.keys(this.ohlcvs).length===0){const r=this.safeInteger(this.options,"OHLCVLimit",1e3);this.ohlcvs=new mj(r)}for(let r=0;r<n.length;r++){const a=n[r];this.ohlcvs.append(a)}e.resolve(this.ohlcvs,i)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);let i;[i,t]=this.handleMarketTypeAndParams("watchTicker",s,t);const n=this.urls.api.ws[i],r="ticker:"+e,a={method:"state.subscribe",id:this.requestId(),params:[s.id]},o=this.deepExtend(a,t);return await this.watch(n,r,o,r,o)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;let r;[r,i]=this.handleMarketTypeAndParams("watchTrades",n,i);const a=this.urls.api.ws[r],o="trades:"+e,d={method:"deals.subscribe",params:[n.id],id:this.requestId()},c=this.deepExtend(d,i),u=await this.watch(a,o,c,o,c);return this.filterBySinceLimit(u,t,s,"timestamp",!0)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;let n;[n,s]=this.handleMarketTypeAndParams("watchOrderBook",i,s);const r=this.urls.api.ws[n],o="orderbook"+":"+e,d=this.safeValue(this.options,"watchOrderBook",{}),c=this.safeValue(d,"limits",[]);if(t===void 0&&(t=this.safeValue(d,"defaultLimit",50)),!this.inArray(t,c))throw new Mh(this.id+" watchOrderBook() limit must be one of "+c.join(", "));const u=this.safeString(d,"defaultAggregation","0"),h=this.safeValue(d,"aggregations",[]),l=this.safeString(s,"aggregation",u);if(!this.inArray(l,h))throw new Mh(this.id+" watchOrderBook() aggregation must be one of "+h.join(", "));s=this.omit(s,"aggregation");const p={method:"depth.subscribe",id:this.requestId(),params:[i.id,t,l,!0]},m=this.deepExtend(p,s);return(await this.watch(r,o,m,o)).limit()}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a="ohlcv";let o;if([o,n]=this.handleMarketTypeAndParams("watchOHLCV",r,n),o!=="swap")throw new Mh(this.id+" watchOHLCV() is only supported for swap markets");const d=this.urls.api.ws[o],c={method:"kline.subscribe",id:this.requestId(),params:[r.id,this.safeInteger(this.timeframes,t,t)]},u=this.deepExtend(c,n),h=await this.watch(d,a,u,a);return this.newUpdates&&(i=h.getLimit(e,i)),this.filterBySinceLimit(h,s,i,0,!0)}handleDelta(e,t){const s=this.parseBidAsk(t,0,1);e.storeArray(s)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBook(e,t){const s=this.safeValue(t,"params",[]),i=this.safeValue(s,0);let n=this.safeValue(s,1);const r=this.safeString(s,2),o=this.safeMarket(r).symbol,c="orderbook"+":"+o,u=this.safeNumber(n,"time"),h=this.safeValue(this.orderbooks,o);if(i){const l=this.parseOrderBook(n,o,u);h===void 0?(n=this.orderBook(l),this.orderbooks[o]=n):(n=this.orderbooks[o],n.reset(l))}else{const l=this.safeValue(n,"asks",[]),p=this.safeValue(n,"bids",[]);this.handleDeltas(h.asks,l),this.handleDeltas(h.bids,p),h.nonce=u,h.timestamp=u,h.datetime=this.iso8601(u),this.orderbooks[o]=h}e.resolve(this.orderbooks[o],c)}checkOrderBookChecksum(e){const t=this.safeValue(e,"asks",[]),s=this.safeValue(e,"bids",[]);let i="";const n=s.length;for(let d=0;d<n;d++){const c=s[d];d!==0&&(i+=":"),i+=c[0]+":"+c[1]}const r=t.length;for(let d=0;d<r;d++){const c=t[d];n!==0&&(i+=":"),i+=c[0]+":"+c[1]}const a=this.hash(i,"cr32","hex");if(this.safeString(e,"checksum")!==a)throw new Rg(this.id+" watchOrderBook () checksum failed")}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate(i);let n="orders",r;const[a,o]=this.handleMarketTypeAndParams("watchOrders",r,i),d={method:"order.subscribe",id:this.requestId()};if(e!==void 0)r=this.market(e),e=r.symbol,d.params=[r.id],n+=":"+e;else{const l=Object.keys(this.markets_by_id);d.params=l}const c=this.urls.api.ws[a],u=this.deepExtend(d,o),h=await this.watch(c,n,u,n,u);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySymbolSinceLimit(h,e,t,s,!0)}handleOrders(e,t){const s=this.safeValue(t,"params",[]),i=this.safeValue(s,1,{}),n=this.parseWSOrder(i);if(this.orders===void 0){const a=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new gj(a)}this.orders.append(n);let r="orders";e.resolve(this.orders,r),r+=":"+n.symbol,e.resolve(this.orders,r)}parseWSOrder(e){const t=this.safeTimestamp2(e,"update_time","mtime"),s=this.safeString(e,"market"),i=this.safeString(e,"type"),n=this.safeString({1:"limit",2:"market"},i),r=this.safeString(e,"side"),a=this.safeString({1:"sell",2:"buy"},r),o=this.safeString(e,"left"),d=this.safeString(e,"amount"),c=this.safeString(e,"status"),u=this.safeMarket(s);let h=this.safeString(e,"deal_money"),l=this.safeString(e,"deal_stock"),p;if(u.swap){const y=this.safeString(e,"leverage");h=Lg.stringDiv(l,y),p=Lg.stringDiv(l,d),l=void 0}let m;const g=this.omitZero(this.safeString(e,"money_fee"));if(g!==void 0){const y=this.safeString(e,"fee_asset",u.quote);m={currency:this.safeCurrencyCode(y),cost:g}}return this.safeOrder({info:e,id:this.safeString2(e,"order_id","id"),clientOrderId:this.safeString(e,"client_id"),datetime:this.iso8601(t),timestamp:t,lastTradeTimestamp:this.safeTimestamp(e,"last_deal_time"),symbol:u.symbol,type:n===1?"limit":"market",timeInForce:void 0,postOnly:void 0,side:a,price:this.safeString(e,"price"),stopPrice:this.safeString(e,"stop_price"),amount:d,filled:l,remaining:o,cost:h,average:p,status:this.parseWSOrderStatus(c),fee:m,trades:void 0},u)}parseWSOrderStatus(e){const t={0:"pending",1:"ok"};return this.safeString(t,e,e)}handleMessage(e,t){const s=this.safeValue(t,"error");if(s!==void 0)throw new Rg(this.id+" "+this.json(s));const i=this.safeString(t,"method"),n={"state.update":this.handleTicker,"asset.update":this.handleBalance,"deals.update":this.handleTrades,"depth.update":this.handleOrderBook,"order.update":this.handleOrders,"kline.update":this.handleOHLCV,"order.update_stop":this.handleOrders},r=this.safeValue(n,i);return r!==void 0?r.call(this,e,t):this.handleSubscriptionStatus(e,t)}handleAuthenticationMessage(e,t){const s=this.safeValue(e.futures,"authenticated");return s!==void 0&&s.resolve(!0),t}handleSubscriptionStatus(e,t){const s=this.safeString(t,"id"),i=this.safeValue(e.subscriptions,s);if(i!==void 0){const n=this.safeString(i,"future"),r=this.safeValue(e.futures,n);r!==void 0&&r.resolve(!0),delete e.subscriptions[s]}}authenticate(e={}){let t;[t,e]=this.handleMarketTypeAndParams("authenticate",void 0,e);const s=this.urls.api.ws[t],i=this.client(s),n=this.milliseconds();if(t==="spot"){const r="authenticated:spot";if(this.safeValue(i.futures,r)!==void 0)return;const o=i.future(r),d=this.requestId(),c={id:d,future:"authenticated:spot"},u="access_id="+this.apiKey+"&tonce="+this.numberToString(n)+"&secret_key="+this.secret,h=this.hash(this.encode(u),"md5"),l={method:"server.sign",params:[this.apiKey,h.toUpperCase(),n],id:d};return this.spawn(this.watch,s,r,l,d,c),o}else{const r="authenticated:swap";if(this.safeValue(i.futures,r)!==void 0)return;const o=i.future("authenticated:swap"),d=this.requestId(),c={id:d,future:"authenticated:swap"},u="access_id="+this.apiKey+"&timestamp="+this.numberToString(n)+"&secret_key="+this.secret,h=this.hash(this.encode(u),"sha256","hex"),l={method:"server.sign",params:[this.apiKey,h.toLowerCase(),n],id:d};return this.spawn(this.watch,s,r,l,d,c),o}}};const bj=W_,{AuthenticationError:wj,NotSupported:Ph}=de,{ArrayCache:kj,ArrayCacheByTimestamp:Sj,ArrayCacheBySymbolById:vj}=rt;var Tj=class extends bj{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!1,watchMyTrades:!0,watchTrades:!0,watchOrderBook:!0,watchOrders:!0,watchOHLCV:!0},urls:{api:{ws:{public:"wss://stream.crypto.com/v2/market",private:"wss://stream.crypto.com/v2/user"}},test:{public:"wss://uat-stream.3ona.co/v2/market",private:"wss://uat-stream.3ona.co/v2/user"}},options:{},streaming:{}})}async pong(e,t){await e.send({id:this.safeInteger(t,"id"),method:"public/respond-heartbeat"})}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);if(!i.spot)throw new Ph(this.id+" watchOrderBook() supports spot markets only");const n="book."+i.id;return(await this.watchPublic(n,s)).limit()}handleOrderBookSnapshot(e,t){const s=this.safeString(t,"subscription"),i=this.safeString(t,"instrument_name"),r=this.safeMarket(i).symbol;let a=this.safeValue(t,"data");a=this.safeValue(a,0);const o=this.safeInteger(a,"t"),d=this.parseOrderBook(a,r,o);d.nonce=this.safeInteger(a,"s");let c=this.safeValue(this.orderbooks,r);if(c===void 0){const u=this.safeInteger(t,"depth");c=this.orderBook({},u)}c.reset(d),this.orderbooks[r]=c,e.resolve(c,s)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);if(e=n.symbol,!n.spot)throw new Ph(this.id+" watchTrades() supports spot markets only");const r="trade."+n.id,a=await this.watchPublic(r,i);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySinceLimit(a,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeString(t,"channel"),i=this.safeString(t,"instrument_name"),n=this.safeString(t,"subscription"),r=this.safeMarket(i),a=r.symbol;let o=this.safeValue(this.trades,a);if(o===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);o=new kj(u),this.trades[a]=o}const d=this.safeValue(t,"data",[]),c=this.parseTrades(d,r);for(let u=0;u<c.length;u++)o.append(c[u]);e.resolve(o,n),e.resolve(o,s)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e),e=n.symbol);let a=this.safeString(this.options,"defaultType","spot")==="margin"?"user.margin.trade":"user.trade";a=n!==void 0?a+"."+n.id:a;const o=await this.watchPrivate(a,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.spot)throw new Ph(this.id+" watchTicker() supports spot markets only");const i="ticker."+s.id;return await this.watchPublic(i,t)}handleTicker(e,t){const s=this.safeString(t,"subscription"),i=this.safeString(t,"instrument_name"),n=this.safeMarket(i),r=this.safeValue(t,"data",[]);for(let a=0;a<r.length;a++){const o=r[a],d=this.parseTicker(o,n),c=d.symbol;this.tickers[c]=d,e.resolve(d,s)}}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);if(e=r.symbol,!r.spot)throw new Ph(this.id+" watchOHLCV() supports spot markets only");const o="candlestick."+this.timeframes[t]+"."+r.id,d=await this.watchPublic(o,n);return this.newUpdates&&(i=d.getLimit(e,i)),this.filterBySinceLimit(d,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"subscription"),i=this.safeString(t,"instrument_name"),n=this.safeMarket(i),r=n.symbol,a=this.safeString(t,"interval"),o=this.findTimeframe(a);this.ohlcvs[r]=this.safeValue(this.ohlcvs,r,{});let d=this.safeValue(this.ohlcvs[r],o);if(d===void 0){const u=this.safeInteger(this.options,"OHLCVLimit",1e3);d=new Sj(u),this.ohlcvs[r][o]=d}const c=this.safeValue(t,"data");for(let u=0;u<c.length;u++){const h=c[u],l=this.parseOHLCV(h,n);d.append(l)}e.resolve(d,s)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e),e=n.symbol);let a=this.safeString(this.options,"defaultType","spot")==="margin"?"user.margin.order":"user.order";a=n!==void 0?a+"."+n.id:a;const o=await this.watchPrivate(a,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleOrders(e,t,s=void 0){const i=this.safeString(t,"channel"),n=this.safeString(t,"subscription"),r=this.safeValue(t,"data",[]);if(r.length>0){if(this.orders===void 0){const c=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new vj(c)}const o=this.orders,d=this.parseOrders(r);for(let c=0;c<d.length;c++)o.append(d[c]);e.resolve(o,n),e.resolve(o,i)}}async watchBalance(e={}){const s=this.safeString(this.options,"defaultType","spot")==="margin"?"user.margin.balance":"user.balance";return await this.watchPrivate(s,e)}handleBalance(e,t){const s=this.safeString(t,"subscription"),i=this.safeValue(t,"data");for(let n=0;n<i.length;n++){const r=i[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.account();d.free=this.safeString(r,"available"),d.total=this.safeString(r,"balance"),this.balance[o]=d,this.balance=this.safeBalance(this.balance)}e.resolve(this.balance,s)}async watchPublic(e,t={}){const s=this.urls.api.ws.public,i=this.nonce(),n={method:"subscribe",params:{channels:[e]},nonce:i},r=this.extend(n,t);return await this.watch(s,e,r,e)}async watchPrivate(e,t={}){await this.authenticate();const s=this.urls.api.ws.private,i=this.nonce(),n={method:"subscribe",params:{channels:[e]},nonce:i},r=this.extend(n,t);return await this.watch(s,e,r,e)}handleErrorMessage(e,t){const s=this.safeInteger(t,"code");try{if(s!==void 0&&s!==0){const i=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,i);const n=this.safeValue(t,"message");n!==void 0&&this.throwBroadlyMatchedException(this.exceptions.broad,n,i)}}catch(i){if(i instanceof wj)return e.reject(i,"authenticated"),"public/auth"in e.subscriptions&&delete e.subscriptions["public/auth"],!1;e.reject(i)}return t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;const s=this.safeString(t,"method");if(s==="public/heartbeat"){this.handlePing(e,t);return}if(s==="public/auth"){this.handleAuthenticate(e,t);return}const i={candlestick:this.handleOHLCV,ticker:this.handleTicker,trade:this.handleTrades,book:this.handleOrderBookSnapshot,"user.order":this.handleOrders,"user.margin.order":this.handleOrders,"user.trade":this.handleTrades,"user.margin.trade":this.handleTrades,"user.balance":this.handleBalance,"user.margin.balance":this.handleBalance},n=this.safeValue2(t,"result","info"),r=this.safeString(n,"channel"),a=this.safeValue(i,r);a!==void 0&&a.call(this,e,n)}async authenticate(e={}){const t=this.urls.api.ws.private;this.checkRequiredCredentials();const s=this.client(t),i=s.future("authenticated"),n="public/auth";if(this.safeValue(s.subscriptions,n)===void 0){const a=this.nonce().toString(),o=n+a+this.apiKey+a,d=this.hmac(this.encode(o),this.encode(this.secret),"sha256"),c={id:a,nonce:a,method:n,api_key:this.apiKey,sig:d};this.spawn(this.watch,t,n,this.extend(c,e),n)}return await i}handlePing(e,t){this.spawn(this.pong,e,t)}handleAuthenticate(e,t){return e.futures.authenticated.resolve(1),e.resolve(1,"public/auth"),t}};const Oj=z_,Ij=Se,{ArrayCache:xj,ArrayCacheByTimestamp:_j}=rt;var Cj=class extends Oj{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchOrderBook:!0,watchOHLCV:!0},urls:{api:{ws:"wss://api-adapter.backend.currency.com/connect"}},options:{tradesLimit:1e3,OHLCVLimit:1e3,timeframes:{"1m":"M1","3m":"M3","5m":"M5","15m":"M15","30m":"M30","1h":"H1","4h":"H4","1d":"D1","1w":"W1"}},streaming:{ping:this.ping,keepAlive:2e4}})}ping(e){return{destination:"ping",correlationId:this.requestId().toString(),payload:{}}}handlePong(e,t){return e.lastPong=this.milliseconds(),t}handleBalance(e,t,s){const i=this.safeValue(t,"payload"),n=this.parseBalance(i);this.balance=this.extend(this.balance,n);const r=this.safeString(s,"messageHash");e.resolve(this.balance,r),r in e.subscriptions&&delete e.subscriptions[r]}handleTicker(e,t,s){const i="/api/v1/ticker/24hr",n=this.safeValue(t,"payload"),r=this.safeValue(n,"tickers",[]);for(let a=0;a<r.length;a++){const o=this.parseTicker(r[a]),d=o.symbol;this.tickers[d]=o;const c=i+":"+d;e.resolve(o,c),c in e.subscriptions&&delete e.subscriptions[c]}}handleTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,void 0,"/"),n=this.safeInteger(e,"ts"),r=this.safeString(e,"price"),a=this.safeString(e,"size"),o=this.parseNumber(Ij.stringMul(r,a)),d=this.parseNumber(r),c=this.parseNumber(a),u=this.safeString2(e,"id"),h=this.safeString(e,"orderId"),p=this.safeValue(e,"buyer")?"buy":"sell";return{info:e,timestamp:n,datetime:this.iso8601(n),symbol:i,id:u,order:h,type:void 0,takerOrMaker:void 0,side:p,price:d,amount:c,cost:o,fee:void 0}}handleTrades(e,t,s){const i=this.safeValue(t,"payload"),n=this.handleTrade(i),r=n.symbol,o="trades.subscribe"+":"+r;let d=this.safeValue(this.trades,r);if(d===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);d=new xj(c),this.trades[r]=d}d.append(n),e.resolve(d,o)}findTimeframe(e){const t=this.safeValue(this.options,"timeframes"),s=Object.keys(t);for(let i=0;i<s.length;i++){const n=s[i];if(t[n]===e)return n}}handleOHLCV(e,t){const s="OHLCMarketData.subscribe",i=this.safeValue(t,"payload",{}),n=this.safeString(i,"interval"),r=this.findTimeframe(n),a=this.safeString(i,"symbol"),d=this.safeMarket(a).symbol,c=s+":"+r+":"+d,u=[this.safeInteger(i,"t"),this.safeNumber(i,"o"),this.safeNumber(i,"h"),this.safeNumber(i,"l"),this.safeNumber(i,"c"),void 0];this.ohlcvs[d]=this.safeValue(this.ohlcvs,d,{});let h=this.safeValue(this.ohlcvs[d],r);if(h===void 0){const l=this.safeInteger(this.options,"OHLCVLimit",1e3);h=new _j(l),this.ohlcvs[d][r]=h}h.append(u),e.resolve(h,c)}requestId(){const e=this.sum(this.safeInteger(this.options,"correlationId",0),1);return this.options.correlationId=e,e}async watchPublic(e,t,s={}){await this.loadMarkets();const i=this.market(t);t=i.symbol;const n=e+":"+t,r=this.urls.api.ws,a=this.requestId().toString(),o=this.deepExtend({destination:e,correlationId:a,payload:{symbols:[i.id]}},s),d=this.extend(o,{messageHash:n,symbol:t});return await this.watch(r,n,o,n,d)}async watchPrivate(e,t={}){await this.loadMarkets();const s="/api/v1/account",i=this.urls.api.ws,n=this.requestId().toString(),r={timestamp:this.milliseconds(),apiKey:this.apiKey},a=this.urlencode(this.keysort(r)),o=this.deepExtend({destination:e,correlationId:n,payload:r},t);o.payload.signature=this.hmac(this.encode(a),this.encode(this.secret));const d=this.extend(o,{messageHash:s});return await this.watch(i,s,o,s,d)}async watchBalance(e={}){return await this.loadMarkets(),await this.watchPrivate("/api/v1/account",e)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i="/api/v1/ticker/24hr",n=i+":"+e,r=this.urls.api.ws,a=this.requestId().toString(),o=this.deepExtend({destination:i,correlationId:a,payload:{symbol:s.id}},t),d=this.extend(o,{messageHash:n,symbol:e});return await this.watch(r,n,o,n,d)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.watchPublic("trades.subscribe",e,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}async watchOrderBook(e,t=void 0,s={}){return await this.loadMarkets(),e=this.symbol(e),(await this.watchPublic("depthMarketData.subscribe",e,s)).limit()}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets(),e=this.symbol(e);const r="OHLCMarketData.subscribe",a=r+":"+t,o=this.safeValue(this.options,"timeframes"),d={destination:r,payload:{intervals:[o[t]]}},c=await this.watchPublic(a,e,this.extend(d,n));return this.newUpdates&&(i=c.getLimit(e,i)),this.filterBySinceLimit(c,s,i,0,!0)}handleDeltas(e,t){const s=Object.keys(t);for(let i=0;i<s.length;i++){const n=s[i],r=t[n];e.store(parseFloat(n),parseFloat(r))}}handleOrderBook(e,t){const s=this.safeValue(t,"payload",{}),i=this.safeValue(s,"data",{}),n=this.safeString(s,"symbol"),r=this.safeSymbol(n,void 0,"/"),o="depthMarketData.subscribe"+":"+r,d=this.safeInteger(i,"ts");let c=this.safeValue(this.orderbooks,r);c===void 0&&(c=this.orderBook()),c.reset({timestamp:d,datetime:this.iso8601(d)});const u=this.safeValue(i,"bid",{}),h=this.safeValue(i,"ofr",{});this.handleDeltas(c.bids,u),this.handleDeltas(c.asks,h),this.orderbooks[r]=c,e.resolve(c,o)}handleMessage(e,t){const s=this.safeString(t,"correlationId");if(s!==void 0){const n=this.indexBy(e.subscriptions,"correlationId"),r=this.safeString(t,"status"),a=this.safeValue(n,s);if(a!==void 0&&r==="OK"){const o=this.safeString(a,"destination");if(o!==void 0){const d={"/api/v1/ticker/24hr":this.handleTicker,"/api/v1/account":this.handleBalance},c=this.safeValue(d,o);return c===void 0?t:c.call(this,e,t,a)}}}const i=this.safeString(t,"destination");if(i!==void 0){const n={"marketdepth.event":this.handleOrderBook,"internal.trade":this.handleTrades,"ohlc.event":this.handleOHLCV,ping:this.handlePong},r=this.safeValue(n,i);return r===void 0?t:r.call(this,e,t)}}};const Mj=K_,{NotSupported:oO,ExchangeError:Pj}=de,{ArrayCache:Aj,ArrayCacheBySymbolById:dO,ArrayCacheByTimestamp:Bj}=rt;var Ej=class extends Mj{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchMyTrades:!0,watchOrders:!0,watchOrderBook:!0,watchOHLCV:!0},urls:{test:{ws:"wss://test.deribit.com/ws/api/v2"},api:{ws:"wss://www.deribit.com/ws/api/v2"}},options:{timeframes:{"1m":1,"3m":3,"5m":5,"15m":15,"30m":30,"1h":60,"2h":120,"4h":180,"6h":360,"12h":720,"1d":"1D"},currencies:["BTC","ETH","SOL","USDC"]},streaming:{},exceptions:{}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}async watchBalance(e={}){await this.authenticate(e);const t="balance",s=this.urls.api.ws,i=this.safeValue(this.options,"currencies",[]),n=[];for(let o=0;o<i.length;o++){const d=i[o];n.push("user.portfolio."+d)}const r={jsonrpc:"2.0",method:"private/subscribe",params:{channels:n},id:this.requestId()},a=this.deepExtend(r,e);return await this.watch(s,t,a,t,a)}handleBalance(e,t){const s=this.safeValue(t,"params",{}),i=this.safeValue(s,"data",{}),n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.parseBalance(i);this.balance[r]=a;const o="balance";e.resolve(this.balance,o)}async watchTicker(e,t={}){const s=this.market(e),i=this.urls.api.ws,n=this.safeString(t,"interval","100ms");t=this.omit(t,"interval"),await this.loadMarkets(),n==="raw"&&await this.authenticate();const r="ticker."+s.id+"."+n,a={jsonrpc:"2.0",method:"public/subscribe",params:{channels:["ticker."+s.id+"."+n]},id:this.requestId()},o=this.deepExtend(a,t);return await this.watch(i,r,o,r,o)}handleTicker(e,t){const s=this.safeValue(t,"params",{}),i=this.safeValue(s,"data",{}),n=this.safeString(i,"instrument_name"),r=this.safeSymbol(n),a=this.parseTicker(i),o=this.safeString(s,"channel");this.tickers[r]=a,e.resolve(a,o)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e),r=this.urls.api.ws,a=this.safeString(i,"interval","100ms");i=this.omit(i,"interval");const o="trades."+n.id+"."+a;a==="raw"&&await this.authenticate();const d={jsonrpc:"2.0",method:"public/subscribe",params:{channels:[o]},id:this.requestId()},c=this.deepExtend(d,i),u=await this.watch(r,o,c,o,c);return this.filterBySinceLimit(u,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"params",{}),i=this.safeString(s,"channel",""),n=i.split("."),r=this.safeString(n,1),a=this.safeSymbol(r),o=this.safeMarket(r),d=this.safeValue(s,"data",[]);let c=this.safeValue(this.trades,a);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new Aj(u),this.trades[a]=c}for(let u=0;u<d.length;u++){const h=d[u],l=this.parseTrade(h,o);c.append(l)}this.trades[a]=c,e.resolve(this.trades[a],i)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.authenticate(i),e!==void 0&&(await this.loadMarkets(),e=this.symbol(e));const n=this.urls.api.ws,r=this.safeString(i,"interval","raw");i=this.omit(i,"interval");const a="user.trades.any.any."+r,o={jsonrpc:"2.0",method:"private/subscribe",params:{channels:[a]},id:this.requestId()},d=this.deepExtend(o,i),c=await this.watch(n,a,d,a,d);return this.filterBySymbolSinceLimit(c,e,t,s,!0)}handleMyTrades(e,t){const s=this.safeValue(t,"params",{}),i=this.safeString(s,"channel",""),n=this.safeValue(s,"data",[]);let r=this.myTrades;if(r===void 0){const o=this.safeInteger(this.options,"tradesLimit",1e3);r=new dO(o)}const a=this.parseTrades(n);for(let o=0;o<a.length;o++){const d=a[o];r.append(d),d.symbol}e.resolve(r,i)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n=this.urls.api.ws,r=this.safeString(s,"interval","100ms");s=this.omit(s,"interval"),r==="raw"&&await this.authenticate();const a="book."+i.id+"."+r,o={jsonrpc:"2.0",method:"public/subscribe",params:{channels:[a]},id:this.requestId()},d=this.deepExtend(o,s);return(await this.watch(n,a,d,a)).limit()}handleOrderBook(e,t){const s=this.safeValue(t,"params",{}),i=this.safeValue(s,"data",{}),n=this.safeString(s,"channel"),r=this.safeString(i,"instrument_name"),a=this.safeSymbol(r),o=this.safeNumber(i,"timestamp");let d=this.safeValue(this.orderbooks,a);d===void 0&&(d=this.countedOrderBook());const c=this.safeValue(i,"asks",[]),u=this.safeValue(i,"bids",[]);this.handleDeltas(d.asks,c),this.handleDeltas(d.bids,u),d.nonce=o,d.timestamp=o,d.datetime=this.iso8601(o),d.symbol=a,this.orderbooks[a]=d,e.resolve(d,n)}cleanOrderBook(e){const t=this.safeValue(e,"bids",[]),s=this.safeValue(e,"asks",[]),i=[];for(let r=0;r<t.length;r++)i.push([t[r][1],t[r][2]]);const n=[];for(let r=0;r<s.length;r++)n.push([s[r][1],s[r][2]]);return e.bids=i,e.asks=n,e}handleDelta(e,t){const s=t[1],i=t[2];t[0]==="new"||t[0]==="change"?e.store(s,i,1):t[0]==="delete"&&e.store(s,i,0)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate(i),e!==void 0&&(e=this.symbol(e));const n=this.urls.api.ws,r=this.safeString(i,"currency","any"),a=this.safeString(i,"interval","raw"),o=this.safeString(i,"kind","any");i=this.omit(i,"interval","currency","kind");const d="user.orders."+o+"."+r+"."+a,c={jsonrpc:"2.0",method:"private/subscribe",params:{channels:[d]},id:this.requestId()},u=this.deepExtend(c,i),h=await this.watch(n,d,u,d,u);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySymbolSinceLimit(h,e,t,s,!0)}handleOrders(e,t){if(this.orders===void 0){const a=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new dO(a)}const s=this.safeValue(t,"params",{}),i=this.safeString(s,"channel",""),n=this.safeValue(s,"data",{});let r=[];this.isArray(n)?r=this.parseOrders(n):r=[this.parseOrder(n)];for(let a=0;a<r.length;a++)this.orders.append(r[a]);e.resolve(this.orders,i)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a=this.urls.api.ws,o=this.safeValue(this.options,"timeframes",{}),d=this.safeString(o,t);if(d===void 0)throw new oO(this.id+" this interval is not supported, please provide one of the supported timeframes");const c="chart.trades."+r.id+"."+d,u={jsonrpc:"2.0",method:"public/subscribe",params:{channels:[c]},id:this.requestId()},h=this.deepExtend(u,n),l=await this.watch(a,c,h,c,h);return this.newUpdates&&(i=l.getLimit(r.symbol,i)),this.filterBySinceLimit(l,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"params",{}),i=this.safeString(s,"channel",""),n=i.split("."),r=this.safeString(n,2),a=this.safeSymbol(r),o=this.safeValue(s,"data",{}),d=[this.safeNumber(o,"tick"),this.safeNumber(o,"open"),this.safeNumber(o,"high"),this.safeNumber(o,"low"),this.safeNumber(o,"close"),this.safeNumber(o,"volume")];let c=this.safeValue(this.ohlcvs,a);if(c===void 0){const u=this.safeInteger(this.options,"OHLCVLimit",1e3);c=new Bj(u)}c.append(d),this.ohlcvs[a]=c,e.resolve(c,i)}handleMessage(e,t){const s=this.safeValue(t,"error");if(s!==void 0)throw new Pj(this.id+" "+this.json(s));const i=this.safeValue(t,"params"),n=this.safeString(i,"channel");if(n!==void 0){const o=n.split("."),d=this.safeString(o,0),c={trades:this.handleMyTrades,portfolio:this.handleBalance,orders:this.handleOrders},u={ticker:this.handleTicker,book:this.handleOrderBook,trades:this.handleTrades,chart:this.handleOHLCV,user:this.safeValue(c,this.safeString(o,1))},h=this.safeValue(u,d);if(h!==void 0)return h.call(this,e,t);throw new oO(this.id+" no handler found for this message "+this.json(t))}const r=this.safeValue(t,"result",{});return this.safeString(r,"access_token")!==void 0?this.handleAuthenticationMessage(e,t):t}handleAuthenticationMessage(e,t){const s=this.safeValue(e.futures,"authenticated");return s!==void 0&&s.resolve(!0),t}async authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i=this.milliseconds(),n=this.numberToString(i),r=n,a="authenticated",o=s.future("authenticated");if(this.safeValue(s.subscriptions,a)===void 0){this.checkRequiredCredentials();const c=this.requestId(),u=this.hmac(this.encode(n+`
`+r+`
`),this.encode(this.secret),"sha256"),h={jsonrpc:"2.0",id:c,method:"public/auth",params:{grant_type:"client_signature",client_id:this.apiKey,timestamp:i,signature:u,nonce:r,data:""}};this.spawn(this.watch,t,a,this.extend(h,e),a)}return await o}};const Nj=X_,{NotSupported:Vj}=de,{ArrayCache:qj,ArrayCacheBySymbolById:Lj}=rt;var Rj=class extends Nj{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchMyTrades:!0,watchOrders:!1,watchOrderBook:!0,watchOHLCV:!1},urls:{api:{ws:{public:"wss://ws-api.exmo.com:443/v1/public",spot:"wss://ws-api.exmo.com:443/v1/private",margin:"wss://ws-api.exmo.com:443/v1/margin/private"}}},options:{},streaming:{},exceptions:{}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}async watchBalance(e={}){await this.authenticate(e);const[t,s]=this.handleMarketTypeAndParams("watchBalance",void 0,e),i="balance:"+t,n=this.urls.api.ws[t],r={method:"subscribe",topics:[t+"/wallet"],id:this.requestId()},a=this.deepExtend(r,s);return await this.watch(n,i,a,i,a)}handleBalance(e,t){const i=this.safeString(t,"topic").split("/"),n=this.safeString(i,0);n==="spot"?this.parseSpotBalance(t):n==="margin"&&this.parseMarginBalance(t);const r="balance:"+n;e.resolve(this.balance,r)}parseSpotBalance(e){const t=this.safeString(e,"event"),s=this.safeValue(e,"data");if(t==="snapshot"){const i=this.safeValue(s,"balances",{}),n=this.safeValue(s,"reserved",{}),r=Object.keys(i);for(let a=0;a<r.length;a++){const o=r[a],d=this.safeCurrencyCode(o),c=i[o],u=n[o],h=this.account();h.free=this.parseNumber(c),h.used=this.parseNumber(u),this.balance[d]=h}}else if(t==="update"){const i=this.safeString(s,"currency"),n=this.safeCurrencyCode(i),r=this.account();r.free=this.safeNumber(s,"balance"),r.used=this.safeNumber(s,"reserved"),this.balance[n]=r}this.balance=this.safeBalance(this.balance)}parseMarginBalance(e){const t=this.safeValue(e,"data"),s=Object.keys(t);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeCurrencyCode(n),a=this.safeValue(t,n),o=this.account();o.free=this.safeNumber(a,"free"),o.used=this.safeNumber(a,"used"),o.total=this.safeNumber(a,"balance"),this.balance[r]=o,this.balance=this.safeBalance(this.balance)}}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i=this.urls.api.ws.public,n="ticker:"+e,r={method:"subscribe",topics:["spot/ticker:"+s.id],id:this.requestId()},a=this.deepExtend(r,t);return await this.watch(i,n,a,n,a)}handleTicker(e,t){const i=this.safeString(t,"topic").split(":"),n=this.safeString(i,1),r=this.safeSymbol(n),a=this.safeValue(t,"data",{}),o=this.safeMarket(n),d=this.parseTicker(a,o),c="ticker:"+r;this.tickers[r]=d,e.resolve(d,c)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r=this.urls.api.ws.public,a="trades:"+e,o={method:"subscribe",topics:["spot/trades:"+n.id],id:this.requestId()},d=this.deepExtend(o,i),c=await this.watch(r,a,d,a,d);return this.filterBySinceLimit(c,t,s,"timestamp",!0)}handleTrades(e,t){const i=this.safeString(t,"topic").split(":"),n=this.safeString(i,1),r=this.safeSymbol(n),a=this.safeMarket(n),o=this.safeValue(t,"data",[]),d="trades:"+r;let c=this.safeValue(this.trades,r);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new qj(u),this.trades[r]=c}for(let u=0;u<o.length;u++){const h=o[u],l=this.parseTrade(h,a);c.append(l)}this.trades[r]=c,e.resolve(this.trades[r],d)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate(i);const[n,r]=this.handleMarketTypeAndParams("watchMyTrades",void 0,i),a=this.urls.api.ws[n];let o;if(e===void 0)o="myTrades:"+n;else{const h=this.market(e);e=h.symbol,o="myTrades:"+h.symbol}const d={method:"subscribe",topics:[n+"/user_trades"],id:this.requestId()},c=this.deepExtend(d,r),u=await this.watch(a,o,c,o,c);return this.filterBySymbolSinceLimit(u,e,t,s,!0)}handleMyTrades(e,t){const i=this.safeString(t,"topic").split("/"),r="myTrades:"+this.safeString(i,0),a=this.safeString(t,"event");let o=[],d;if(this.myTrades===void 0){const l=this.safeInteger(this.options,"tradesLimit",1e3);d=new Lj(l),this.myTrades=d}else d=this.myTrades;a==="snapshot"?o=this.safeValue(t,"data",[]):a==="update"&&(o=[this.safeValue(t,"data",{})]);const c=this.parseTrades(o),u={};for(let l=0;l<c.length;l++){const p=c[l];d.append(p),u[p.symbol]=!0}const h=Object.keys(u);for(let l=0;l<h.length;l++){const m="myTrades:"+h[l];e.resolve(d,m)}e.resolve(d,r)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n=this.urls.api.ws.public,r="orderbook:"+e;s=this.omit(s,"aggregation");const a={method:"subscribe",id:this.requestId(),topics:["spot/order_book_updates:"+i.id]},o=this.deepExtend(a,s);return(await this.watch(n,r,o,r)).limit()}handleOrderBook(e,t){const i=this.safeString(t,"topic").split(":"),n=this.safeString(i,1),r=this.safeSymbol(n),a=this.safeValue(t,"data",{}),o="orderbook:"+r,d=this.safeNumber(t,"ts");let c=this.safeValue(this.orderbooks,r);if(c===void 0&&(c=this.orderBook({}),this.orderbooks[r]=c),this.safeString(t,"event")==="snapshot"){const h=this.parseOrderBook(a,r,d,"bid","ask");c.reset(h)}else{const h=this.safeValue(a,"ask",[]),l=this.safeValue(a,"bid",[]);this.handleDeltas(c.asks,h),this.handleDeltas(c.bids,l),c.timestamp=d,c.datetime=this.iso8601(d)}e.resolve(c,o)}handleDelta(e,t){const s=this.parseBidAsk(t,0,1);e.storeArray(s)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleMessage(e,t){const s=this.safeString(t,"event");if(s==="logged_in")return this.handleAuthenticationMessage(e,t);if(s==="update"||s==="snapshot"){const i=this.safeString(t,"topic");if(i!==void 0){const n=i.split(":"),r=this.safeString(n,0),a={"spot/ticker":this.handleTicker,"spot/wallet":this.handleBalance,"margin/wallet":this.handleBalance,"margin/wallets":this.handleBalance,"spot/trades":this.handleTrades,"margin/trades":this.handleTrades,"spot/order_book_updates":this.handleOrderBook,"spot/user_trades":this.handleMyTrades,"margin/user_trades":this.handleMyTrades},o=this.safeValue(a,r);if(o!==void 0)return o.call(this,e,t)}}if(s==="info")return this.handleInfo(e,t);if(s==="subscribed")return this.handleSubscribed(e,t);throw new Vj(this.id+" received an unsupported message: "+this.json(t))}handleSubscribed(e,t){return t}handleInfo(e,t){return t}handleAuthenticationMessage(e,t){const s=this.safeValue(e.futures,"authenticated");s!==void 0&&s.resolve(!0)}async authenticate(e={}){const[t,s]=this.handleMarketTypeAndParams("authenticate",void 0,e),i=this.urls.api.ws[t],n=this.client(i),r=this.milliseconds(),a="authenticated",o=n.future("authenticated");if(this.safeValue(n.subscriptions,a)===void 0){this.checkRequiredCredentials();const c=this.requestId(),u=this.apiKey+r.toString(),h=this.hmac(this.encode(u),this.encode(this.secret),"sha512","base64"),l={method:"login",id:c,api_key:this.apiKey,sign:h,nonce:r};this.spawn(this.watch,i,a,this.extend(l,s),a)}return await o}};const Fj=Pb,{AuthenticationError:Ah,BadRequest:Dj,ArgumentsRequired:Hj,NotSupported:Gj,InvalidNonce:Uj}=de,{ArrayCache:$j,ArrayCacheByTimestamp:jj,ArrayCacheBySymbolById:cO}=rt;var lC=class extends Fj{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchMyTrades:!0,watchOHLCV:!0,watchBalance:!0,watchOrders:!0},urls:{api:{ws:"wss://ws.gate.io/v4",spot:"wss://api.gateio.ws/ws/v4/",swap:{usdt:"wss://fx-ws.gateio.ws/v4/ws/usdt",btc:"wss://fx-ws.gateio.ws/v4/ws/btc"},future:{usdt:"wss://fx-ws.gateio.ws/v4/ws/delivery/usdt",btc:"wss://fx-ws.gateio.ws/v4/ws/delivery/btc"},option:"wss://op-ws.gateio.live/v4/ws"},test:{swap:{usdt:"wss://fx-ws-testnet.gateio.ws/v4/ws/usdt",btc:"wss://fx-ws-testnet.gateio.ws/v4/ws/btc"},future:{usdt:"wss://fx-ws-testnet.gateio.ws/v4/ws/usdt",btc:"wss://fx-ws-testnet.gateio.ws/v4/ws/btc"},option:"wss://op-ws-testnet.gateio.live/v4/ws"}},options:{tradesLimit:1e3,OHLCVLimit:1e3,watchTradesSubscriptions:{},watchTickerSubscriptions:{},watchOrderBookSubscriptions:{},watchOrderBook:{interval:"100ms"},watchBalance:{settle:"usdt",spot:"spot.balances"}},exceptions:{ws:{exact:{2:Dj,4:Ah,6:Ah,11:Ah}}}})}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n=i.id,r=this.safeValue(this.options,"watchOrderBook",{}),a=this.safeInteger(r,"limit",20);t||(t=a);const o=this.safeString(r,"interval","100ms"),d=this.safeString(s,"interval",o),c=i.type,h=this.getUniformType(c)+".order_book_update",l=h+":"+i.symbol,p=this.getUrlByMarketType(c,i.inverse),m=[n,d];if(c!=="spot"){const b=t.toString();m.push(b)}const g={method:this.handleOrderBookSubscription,symbol:e,limit:t};return(await this.subscribePublic(p,h,l,m,g)).limit()}handleOrderBookSubscription(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit");i in this.orderbooks&&delete this.orderbooks[i],this.orderbooks[i]=this.orderBook({},n);const r=this.safeValue(this.options,"handleOrderBookSubscription",{});if(this.safeValue(r,"fetchOrderBookSnapshot",!1)){const o="fetchingOrderBookSnapshot";s[o]=!0;const d=s.messageHash;e.subscriptions[d]=s,this.spawn(this.fetchOrderBookSnapshot,e,t,s)}}async fetchOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit"),r=this.safeString(s,"messageHash");try{const a=await this.fetchOrderBook(i,n),o=this.orderbooks[i],d=o.cache,c=this.safeValue(d,0,{}),u=this.safeValue(c,"result"),h=this.safeInteger(u,"U"),l=this.safeInteger(a,"nonce");if(h===void 0||l<h){const p=this.safeInteger(this.options,"maxOrderBookSyncAttempts",3);let m=this.safeInteger(s,"numAttempts",0);if(m<p)r in e.subscriptions&&(m=this.sum(m,1),s.numAttempts=m,e.subscriptions[r]=s,this.spawn(this.fetchOrderBookSnapshot,e,t,s));else throw delete e.subscriptions[r],new Uj(this.id+" failed to synchronize WebSocket feed with the snapshot for symbol "+i+" in "+p.toString()+" attempts")}else{o.reset(a);for(let p=0;p<d.length;p++){const m=d[p];this.handleOrderBookMessage(e,m,o)}this.orderbooks[i]=o,e.resolve(o,r)}}catch(a){e.reject(a,r)}}handleOrderBook(e,t){const s=this.safeString(t,"channel"),i=this.safeValue(t,"result"),n=this.safeString(i,"s"),r=this.safeSymbol(n);let a=this.safeValue(this.orderbooks,r);a===void 0&&(a=this.orderBook({}),this.orderbooks[r]=a);const o=s+":"+r,d=this.safeValue(e.subscriptions,o,{}),c="fetchingOrderBookSnapshot";if(this.safeValue(d,c,!1)||(d[c]=!0,e.subscriptions[o]=d,this.spawn(this.fetchOrderBookSnapshot,e,t,d)),a.nonce===void 0)a.cache.push(t);else{const h=s+":"+r;this.handleOrderBookMessage(e,t,a,h)}}handleOrderBookMessage(e,t,s,i=void 0){const n=this.safeValue(t,"result"),r=this.safeInteger(n,"u"),a=s.nonce;if(r>=a){const o=this.safeValue(n,"a",[]),d=this.safeValue(n,"b",[]);this.handleDeltas(s.asks,o),this.handleDeltas(s.bids,d),s.nonce=r;const c=this.safeInteger(n,"t");s.timestamp=c,s.datetime=this.iso8601(c),i!==void 0&&e.resolve(s,i)}return s}handleDelta(e,t){let s,i;Array.isArray(t)?(s=this.safeFloat(t,0),i=this.safeFloat(t,1)):(s=this.safeFloat(t,"p"),i=this.safeFloat(t,"s")),e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=s.id,n=s.type,a=this.getUniformType(n)+".tickers",o=a+"."+s.symbol,d=[i],c=this.getUrlByMarketType(n,s.inverse);return await this.subscribePublic(c,a,o,d)}handleTicker(e,t){const s=this.safeString(t,"channel");let i=this.safeValue(t,"result");Array.isArray(i)||(i=[i]);for(let n=0;n<i.length;n++){const r=i[n],a=this.parseTicker(r),o=a.symbol;this.tickers[o]=a;const d=s+"."+o;e.resolve(this.tickers[o],d)}}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r=n.id,a=n.type,d=this.getUniformType(a)+".trades";let c=d;e!==void 0&&(c+=":"+n.symbol);const u=this.getUrlByMarketType(a,n.inverse),h=[r],l=await this.subscribePublic(u,d,c,h);return this.newUpdates&&(s=l.getLimit(e,s)),this.filterBySinceLimit(l,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeString(t,"channel");let i=this.safeValue(t,"result");Array.isArray(i)||(i=[i]);const n=this.parseTrades(i),r={};for(let o=0;o<n.length;o++){const d=n[o],c=d.symbol;let u=this.safeValue(this.trades,c);if(u===void 0){const h=this.safeInteger(this.options,"tradesLimit",1e3);u=new $j(h),this.trades[c]=u}u.append(d),r[c]=!0}const a=Object.keys(r);for(let o=0;o<a.length;o++){const d=a[o],c=s+":"+d,u=this.safeValue(this.trades,d);e.resolve(u,c)}e.resolve(this.trades,s)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=r.id,o=r.type,d=this.timeframes[t],u=this.getUniformType(o)+".candlesticks",h=u+":"+d+":"+r.symbol,l=this.getUrlByMarketType(o,r.inverse),p=[d,a],m=await this.subscribePublic(l,u,h,p);return this.newUpdates&&(i=m.getLimit(e,i)),this.filterBySinceLimit(m,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"channel");let i=this.safeValue(t,"result");Array.isArray(i)||(i=[i]);const r={};for(let o=0;o<i.length;o++){const d=i[o],c=this.safeString(d,"n",""),u=c.split("_"),h=this.safeString(u,0),l=h+"_",p=c.replace(l,""),m=this.safeSymbol(p,void 0,"_"),g=this.parseOHLCV(d);let y=this.safeValue(this.ohlcvs,m);if(y===void 0){const b=this.safeInteger(this.options,"OHLCVLimit",1e3);y=new jj(b),this.ohlcvs[m]=y}y.append(g),r[m]=h}const a=Object.keys(r);for(let o=0;o<a.length;o++){const d=a[o],c=r[d],u=this.timeframes[c],h=s+":"+u+":"+d,l=this.safeValue(this.ohlcvs,d);e.resolve(l,h)}}async authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i=s.future("authenticated"),n="server.sign";if(this.safeValue(s.subscriptions,n)===void 0){const a=this.milliseconds(),o=a.toString(),d=this.hmac(this.encode(o),this.encode(this.secret),"sha512","hex"),c={id:a,method:n,params:[this.apiKey,d,a]},u={id:a,method:this.handleAuthenticationMessage};this.spawn(this.watch,t,a,c,n,u)}return await i}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r,a="!all";if(e!==void 0){const g=this.market(e);e=g.symbol,r=g.type,a=g.id}else if([r,i]=this.handleMarketTypeAndParams("watchMyTrades",void 0,i),r!=="spot"){const g=this.safeValue(this.options,"watchMyTrades",{});n=this.safeValue(g,"subType","linear"),n=this.safeValue(i,"subType",n),i=this.omit(i,"subType")}const d=this.getUniformType(r)+".usertrades";let c=d;e!==void 0&&(c+=":"+e);const u=n==="inverse",h=this.getUrlByMarketType(r,u),l=[a],p=r!=="spot",m=await this.subscribePrivate(h,d,c,l,p);return this.newUpdates&&(s=m.getLimit(e,s)),this.filterBySymbolSinceLimit(m,e,t,s,!0)}handleMyTrades(e,t){const s=this.safeValue(t,"result",[]),i=this.safeString(t,"channel");if(s.length===0)return;let r=this.myTrades;if(r===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);r=new cO(c),this.myTrades=r}const a=this.parseTrades(s),o={};for(let c=0;c<a.length;c++){const u=a[c];r.append(u);const h=u.symbol;o[h]=!0}const d=Object.keys(o);for(let c=0;c<d.length;c++){const u=d[c],h=i+":"+u;e.resolve(r,h)}e.resolve(r,i)}async watchBalance(e={}){await this.loadMarkets();let t;[t,e]=this.handleMarketTypeAndParams("watchBalance",void 0,e);const s=this.safeValue(this.options,"watchBalance",{});let i=this.safeValue(s,"subType","linear");i=this.safeValue(e,"subType",i),e=this.omit(e,"subType");const n=i==="inverse",r=this.getUrlByMarketType(t,n),a=t!=="spot";let o="spot";t==="future"||t==="swap"?o="futures":t==="option"&&(o="options");let d;if(t==="spot"){const c=this.safeValue(this.options,"watchTicker",{});d=this.safeString(c,"spot","spot.balances")}else d=o+".balances";return await this.subscribePrivate(r,d,d,void 0,a)}handleBalance(e,t){const s=t.method,i=t.params[0];this.handleBalanceMessage(e,s,i)}handleBalanceMessage(e,t){const s=this.safeString(t,"channel"),i=this.safeValue(t,"result",[]);for(let n=0;n<i.length;n++){const r=i[n],a=this.account(),o=this.safeString(r,"currency","USDT"),d=this.safeCurrencyCode(o);a.free=this.safeString(r,"available"),a.total=this.safeString2(r,"total","balance"),this.balance[d]=a}this.balance=this.safeBalance(this.balance),e.resolve(this.balance,s)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n;e!==void 0&&(n=this.market(e),e=n.symbol);let r,a;[r,a]=this.handleMarketTypeAndParams("watchOrders",n,i);const d=this.getSupportedMapping(r,{spot:"spot",margin:"spot",future:"futures",swap:"futures",option:"options"})+".orders";let c=d,u=["!all"];e!==void 0&&(c=d+":"+n.id,u=[n.id]);let h;[h,a]=this.handleSubTypeAndParams("watchOrders",n,a);const l=h==="inverse",p=this.getUrlByMarketType(r,l),m=r!=="spot",g=await this.subscribePrivate(p,d,c,u,m);return this.newUpdates&&(s=g.getLimit(e,s)),this.filterBySinceLimit(g,t,s,"timestamp",!0)}handleOrder(e,t){const s=this.safeValue(t,"result",[]),i=this.safeString(t,"channel");if(s.length>0){const r=this.safeInteger(this.options,"ordersLimit",1e3);this.orders===void 0&&(this.orders=new cO(r));const a=this.orders,o={},d=this.parseOrders(s);for(let u=0;u<d.length;u++){const h=d[u],l=this.safeValue(h,"info"),p=this.safeString(l,"event");p==="put"?h.status="open":p==="finish"&&(h.status="closed"),a.append(h);const m=h.symbol,g=this.market(m);o[g.id]=!0}const c=Object.keys(o);for(let u=0;u<c.length;u++){const h=i+":"+c[u];e.resolve(this.orders,h)}e.resolve(this.orders,i)}}handleAuthenticationMessage(e,t,s){const i=this.safeValue(t,"result");if(this.safeString(i,"status")==="success"){const r=this.safeValue(e.futures,"authenticated");r!==void 0&&r.resolve(!0)}else{const r=new Ah(this.id+" handleAuthenticationMessage() error");e.reject(r,"authenticated"),"server.sign"in e.subscriptions&&delete e.subscriptions["server.sign"]}}handleErrorMessage(e,t){const s=this.safeValue(t,"error",{}),i=this.safeInteger(s,"code");if(i!==void 0){const n=this.safeString(t,"id"),r=this.indexBy(e.subscriptions,"id"),a=this.safeValue(r,n);if(a!==void 0)try{this.throwExactlyMatchedException(this.exceptions.ws.exact,i,this.json(t))}catch(o){const d=this.safeString(a,"messageHash");e.reject(o,d),e.reject(o,n),n in e.subscriptions&&delete e.subscriptions[n]}}}handleBalanceSubscription(e,t){this.spawn(this.fetchBalanceSnapshot,e,t)}async fetchBalanceSnapshot(e,t){await this.loadMarkets();const s=this.safeString(t,"channel",""),i=s.split("."),n=this.safeString(i,0);let r=n;n==="futures"?r="future":r==="options"&&(r="option");const a={type:r};if(r==="future"||r==="swap"){const d=this.safeValue(this.options,"watchTicker",{}),c=this.safeString(d,"settle","usdt");a.settle=c}const o=await this.fetchBalance(a);this.balance=o,e.resolve(this.balance,s)}handleSubscriptionStatus(e,t){this.safeString(t,"channel","").indexOf("balance")>=0&&this.handleBalanceSubscription(e,t)}handleMessage(e,t){if(this.handleErrorMessage(e,t),this.safeString(t,"event")==="subscribe"){this.handleSubscriptionStatus(e,t);return}const n=this.safeString(t,"channel","").split("."),r=this.safeValue(n,1),a={usertrades:this.handleMyTrades,candlesticks:this.handleOHLCV,orders:this.handleOrder,tickers:this.handleTicker,trades:this.handleTrades,order_book_update:this.handleOrderBook,balances:this.handleBalanceMessage},o=this.safeValue(a,r);o!==void 0&&o.call(this,e,t)}getUniformType(e){let t="spot";return e==="future"||e==="swap"?t="futures":e==="option"&&(t="options"),t}getUrlByMarketType(e,t=!1){if(e==="spot"){const s=this.urls.api.spot;if(s===void 0)throw new Gj(this.id+" does not have a testnet for the "+e+" market type.");return s}if(e==="swap"){const s=this.urls.api.swap;return t?s.btc:s.usdt}if(e==="future"){const s=this.urls.api.future;return t?s.btc:s.usdt}if(e==="option")return this.urls.api.option}requestId(){const e=this.sum(this.safeInteger(this.options,"reqid",0),1);return this.options.reqid=e,e}async subscribePublic(e,t,s,i,n={}){const r=this.requestId(),a=this.seconds(),o={id:r,time:a,channel:t,event:"subscribe",payload:i};let d={id:r,messageHash:s};return d=this.extend(d,n),await this.watch(e,s,o,s,d)}async subscribePrivate(e,t,s,i=void 0,n=!1){if(this.checkRequiredCredentials(),n){if(this.uid===void 0||this.uid.length===0)throw new Hj(this.id+" requires uid to subscribe");const p=[this.uid];i===void 0?i=p:i=this.arrayConcat(p,i)}const r=this.seconds(),a="subscribe",o="channel="+t+"&event="+a+"&time="+r.toString(),d=this.hmac(this.encode(o),this.encode(this.secret),"sha512","hex"),c={method:"api_key",KEY:this.apiKey,SIGN:d},u=this.requestId(),h={id:u,time:r,channel:t,event:"subscribe",auth:c};i!==void 0&&(h.payload=i);const l={id:u,messageHash:s};return await this.watch(e,s,h,s,l)}};const Wj=lC;var zj=class extends Wj{describe(){return this.deepExtend(super.describe(),{alias:!0,id:"gateio"})}};const Kj=Y_,{AuthenticationError:Xj,BadSymbol:Yj,BadRequest:Qj}=de,{ArrayCache:uO,ArrayCacheBySymbolById:Zj}=rt;var Jj=class extends Kj{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!1,watchOHLCV:!1,watchOrderBook:!0,watchOrders:!0,watchTicker:!1,watchTickers:!1,watchTrades:!0},urls:{api:{ws:"wss://api.hollaex.com/stream"},test:{ws:"wss://api.sandbox.hollaex.com/stream"}},options:{watchBalance:{},watchOrders:{}},streaming:{ping:this.ping},exceptions:{ws:{exact:{"Bearer or HMAC authentication required":Yj,"Error: wrong input":Qj}}}})}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const n="orderbook:"+this.market(e).id;return(await this.watchPublic(n,s)).limit()}handleOrderBook(e,t){const s=this.safeString(t,"symbol"),i=this.safeString(t,"topic"),r=this.safeMarket(s).symbol,a=this.safeValue(t,"data");let o=this.safeString(a,"timestamp");o=this.parse8601(o);const d=this.parseOrderBook(a,r,o);let c;r in this.orderbooks?(c=this.orderbooks[r],c.reset(d)):(c=this.orderBook(d),this.orderbooks[r]=c);const u=i+":"+s;e.resolve(c,u)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="trade:"+n.id,a=await this.watchPublic(r,i);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySinceLimit(a,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeString(t,"topic"),i=this.safeString(t,"symbol"),n=this.safeMarket(i),r=n.symbol;let a=this.safeValue(this.trades,r);if(a===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);a=new uO(u),this.trades[r]=a}const o=this.safeValue(t,"data",[]),d=this.parseTrades(o,n);for(let u=0;u<d.length;u++)a.append(d[u]);const c=s+":"+i;e.resolve(a,c),e.resolve(a,s)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n="usertrade",r;e!==void 0&&(r=this.market(e),e=r.symbol,n+=":"+r.id);const a=await this.watchPrivate(n,i);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySymbolSinceLimit(a,e,t,s,!0)}handleMyTrades(e,t,s=void 0){const i=this.safeString(t,"topic"),n=this.safeValue(t,"data");if(n.length===0)return 0;if(this.myTrades===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new uO(c)}const a=this.myTrades,o={};for(let c=0;c<n.length;c++){const u=n[c],h=this.parseTrade(u);a.append(h);const l=u.symbol,m=this.market(l).id;o[m]=!0}e.resolve(this.myTrades,i);const d=Object.keys(o);for(let c=0;c<d.length;c++){const u=d[c],h=i+":"+u;e.resolve(this.myTrades,h)}}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n="order",r;e!==void 0&&(r=this.market(e),e=r.symbol,n+=":"+r.id);const a=await this.watchPrivate(n,i);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySymbolSinceLimit(a,e,t,s,!0)}handleOrder(e,t,s=void 0){const i=this.safeString(t,"topic"),n=this.safeValue(t,"data",{});if(n.length===0)return 0;if(this.orders===void 0){const u=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new Zj(u)}const a=this.orders;let o;Array.isArray(n)?o=n:o=[n];const d={};for(let u=0;u<o.length;u++){const h=o[u],l=this.parseOrder(h);a.append(l);const p=h.symbol,g=this.market(p).id;d[g]=!0}e.resolve(this.orders,i);const c=Object.keys(d);for(let u=0;u<c.length;u++){const h=c[u],l=i+":"+h;e.resolve(this.orders,l)}}async watchBalance(e={}){const t="wallet";return await this.watchPrivate(t,e)}handleBalance(e,t){const s=this.safeString(t,"topic"),i=this.safeValue(t,"data"),n=Object.keys(i);for(let r=0;r<n.length;r++){const a=n[r],o=a.split("_"),d=this.safeString(o,0),c=this.safeCurrencyCode(d),u=c in this.balance?this.balance[c]:this.account(),l=this.safeString(o,1)==="available"?"free":"total";u[l]=this.safeString(i,a),this.balance[c]=u}this.balance=this.safeBalance(this.balance),e.resolve(this.balance,s)}async watchPublic(e,t={}){const s=this.urls.api.ws,i={op:"subscribe",args:[e]},n=this.extend(i,t);return await this.watch(s,e,n,e)}async watchPrivate(e,t={}){this.checkRequiredCredentials();let s=this.safeString(this.options,"ws-expires");if(s===void 0){const u=parseInt(this.timeout/1e3);s=this.sum(this.seconds(),u),s=s.toString(),this.options["ws-expires"]=s}const i=this.urls.api.ws,n="CONNECT/stream"+s,r=this.hmac(this.encode(n),this.encode(this.secret)),a={"api-key":this.apiKey,"api-signature":r,"api-expires":s},o=i+"?"+this.urlencode(a),d={op:"subscribe",args:[e]},c=this.extend(d,t);return await this.watch(o,e,c,e)}handleErrorMessage(e,t){const s=this.safeInteger(t,"error");try{if(s!==void 0){const i=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.ws.exact,s,i)}}catch(i){if(i instanceof Xj)return!1}return t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;if(this.safeString(t,"message")==="pong"){this.handlePong(e,t);return}const i={trade:this.handleTrades,orderbook:this.handleOrderBook,order:this.handleOrder,wallet:this.handleBalance,usertrade:this.handleMyTrades},n=this.safeValue(t,"topic"),r=this.safeValue(i,n);r!==void 0&&r.call(this,e,t)}ping(e){return{op:"ping"}}handlePong(e,t){return e.lastPong=this.milliseconds(),t}onError(e,t){this.options["ws-expires"]=void 0,super.onError(e,t)}onClose(e,t){this.options["ws-expires"]=void 0,super.onClose(e,t)}};const eW=Ab,{ExchangeError:fO,InvalidNonce:tW,ArgumentsRequired:sW,BadRequest:Fg,BadSymbol:hO,AuthenticationError:lO}=de,{ArrayCache:iW,ArrayCacheByTimestamp:nW,ArrayCacheBySymbolById:pO}=rt;var pC=class extends eW{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchOrders:!0,watchTickers:!1,watchTicker:!0,watchTrades:!0,watchMyTrades:!0,watchBalance:!0,watchOHLCV:!0},urls:{api:{ws:{api:{spot:{public:"wss://{hostname}/ws",private:"wss://{hostname}/ws/v2"},future:{linear:{public:"wss://api.hbdm.com/linear-swap-ws",private:"wss://api.hbdm.com/linear-swap-notification"},inverse:{public:"wss://api.hbdm.com/ws",private:"wss://api.hbdm.com/notification"}},swap:{inverse:{public:"wss://api.hbdm.com/swap-ws",private:"wss://api.hbdm.com/swap-notification"},linear:{public:"wss://api.hbdm.com/linear-swap-ws",private:"wss://api.hbdm.com/linear-swap-notification"}}},"api-aws":{spot:{public:"wss://api-aws.huobi.pro/ws",private:"wss://api-aws.huobi.pro/ws/v2"},future:{linear:{public:"wss://api.hbdm.vn/linear-swap-ws",private:"wss://api.hbdm.vn/linear-swap-notification"},inverse:{public:"wss://api.hbdm.vn/ws",private:"wss://api.hbdm.vn/notification"}},swap:{inverse:{public:"wss://api.hbdm.vn/swap-ws",private:"wss://api.hbdm.vn/swap-notification"},linear:{public:"wss://api.hbdm.vn/linear-swap-ws",private:"wss://api.hbdm.vn/linear-swap-notification"}}}}}},options:{tradesLimit:1e3,OHLCVLimit:1e3,api:"api",maxOrderBookSyncAttempts:3,ws:{gunzip:!0}},exceptions:{ws:{exact:{"bad-request":Fg,2002:lO,2021:Fg,2001:hO,2011:hO,2040:Fg}}}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e.toString()}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i="market."+s.id+".detail",n=this.getUrlByMarketType(s.type,s.linear);return await this.subscribePublic(n,e,i,void 0,t)}handleTicker(e,t){const s=this.safeValue(t,"tick",{}),i=this.safeString(t,"ch"),n=i.split("."),r=this.safeString(n,1),a=this.safeMarket(r),o=this.parseTicker(s,a),d=this.safeValue(t,"ts");o.timestamp=d,o.datetime=this.iso8601(d);const c=o.symbol;return this.tickers[c]=o,e.resolve(o,i),t}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="market."+n.id+".trade.detail",a=this.getUrlByMarketType(n.type,n.linear),o=await this.subscribePublic(a,e,r,void 0,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"tick",{}),i=this.safeValue(s,"data",{}),n=this.safeString(t,"ch"),r=n.split("."),a=this.safeString(r,1),o=this.safeMarket(a),d=o.symbol;let c=this.safeValue(this.trades,d);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new iW(u),this.trades[d]=c}for(let u=0;u<i.length;u++){const h=this.parseTrade(i[u],o);c.append(h)}return e.resolve(c,n),t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=this.timeframes[t],o="market."+r.id+".kline."+a,d=this.getUrlByMarketType(r.type,r.linear),c=await this.subscribePublic(d,e,o,void 0,n);return this.newUpdates&&(i=c.getLimit(e,i)),this.filterBySinceLimit(c,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"ch"),i=s.split("."),n=this.safeString(i,1),r=this.safeMarket(n),a=r.symbol,o=this.safeString(i,3),d=this.findTimeframe(o);this.ohlcvs[a]=this.safeValue(this.ohlcvs,a,{});let c=this.safeValue(this.ohlcvs[a],d);if(c===void 0){const l=this.safeInteger(this.options,"OHLCVLimit",1e3);c=new nW(l),this.ohlcvs[a][d]=c}const u=this.safeValue(t,"tick"),h=this.parseOHLCV(u,r);c.append(h),e.resolve(c,s)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n=[150],r=[20,150];if(t=t===void 0?150:t,i.spot&&!this.inArray(t,n))throw new fO(this.id+" watchOrderBook spot market accepts limits of 150 only");if(!i.spot&&!this.inArray(t,r))throw new fO(this.id+" watchOrderBook swap market accepts limits of 20 and 150 only");let a;i.spot?a="market."+i.id+".mbp."+t.toString():a="market."+i.id+".depth.size_"+t.toString()+".high_freq";const o=this.getUrlByMarketType(i.type,i.linear);let d=this.handleOrderBookSubscription;return i.spot||(s.data_type="incremental",d=void 0),(await this.subscribePublic(o,e,a,d,s)).limit()}handleOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeString(s,"messageHash");try{const r=this.orderbooks[i],a=this.safeValue(t,"data"),o=r.cache,d=this.safeValue(o,0,{}),c=this.parseOrderBook(a,i),u=this.safeValue(d,"tick"),h=this.safeInteger(u,"seqNum"),l=this.safeInteger(a,"seqNum");if(c.nonce=l,h!==void 0&&l<h){const p=this.safeInteger(this.options,"maxOrderBookSyncAttempts",3);let m=this.safeInteger(s,"numAttempts",0);if(m<p)n in e.subscriptions&&(m=this.sum(m,1),s.numAttempts=m,e.subscriptions[n]=s,this.spawn(this.watchOrderBookSnapshot,e,t,s));else throw new tW(this.id+" failed to synchronize WebSocket feed with the snapshot for symbol "+i+" in "+p.toString()+" attempts")}else{r.reset(c);for(let p=0;p<o.length;p++){const m=o[p];this.handleOrderBookMessage(e,m,r)}this.orderbooks[i]=r,e.resolve(r,n)}}catch(r){e.reject(r,n)}}async watchOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit"),r=this.safeValue(s,"params"),a=this.safeInteger(s,"numAttempts",0),o=this.safeString(s,"messageHash"),d=this.market(i),c=this.getUrlByMarketType(d.type,d.linear),u=this.requestId(),h={req:o,id:u},l={id:u,messageHash:o,symbol:i,limit:n,params:r,numAttempts:a,method:this.handleOrderBookSnapshot};return(await this.watch(c,u,h,u,l)).limit()}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s){const n=this.safeValue(t,"ch").split("."),r=this.safeString(n,1),a=this.safeSymbol(r),o=this.safeValue(t,"tick",{}),d=this.safeInteger2(o,"seqNum","version"),c=this.safeInteger(o,"prevSeqNum"),u=this.safeString(o,"event"),h=this.safeInteger(t,"ts");if(u==="snapshot"){const l=this.parseOrderBook(o,a,h);s.reset(l),s.nonce=d}if((c===void 0||c<=s.nonce)&&d>s.nonce){const l=this.safeValue(o,"asks",[]),p=this.safeValue(o,"bids",[]);this.handleDeltas(s.asks,l),this.handleDeltas(s.bids,p),s.nonce=d,s.timestamp=h,s.datetime=this.iso8601(h)}return s}handleOrderBook(e,t){const s=this.safeValue(t,"tick",{}),i=this.safeString(s,"event"),n=this.safeString(t,"ch"),a=this.safeValue(t,"ch").split("."),o=this.safeString(a,1),d=this.safeSymbol(o);let c=this.safeValue(this.orderbooks,d);if(c===void 0){const h=this.safeString(a,3).split("_"),l=this.safeInteger(h,1);c=this.orderBook({},l)}c.nonce===void 0&&c.cache.push(t),(i!==void 0||c.nonce!==void 0)&&(this.orderbooks[d]=this.handleOrderBookMessage(e,t,c),e.resolve(c,n))}handleOrderBookSubscription(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit");i in this.orderbooks&&delete this.orderbooks[i],this.orderbooks[i]=this.orderBook({},n),this.markets[i].spot===!0&&this.spawn(this.watchOrderBookSnapshot,e,t,s)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){this.checkRequiredCredentials();let n,r="*",a,o,d,c,u;if(e!==void 0?(await this.loadMarkets(),a=this.market(e),e=a.symbol,n=a.type,u=a.linear?"linear":"inverse",r=a.lowercaseId):(n=this.safeString(this.options,"defaultType","spot"),n=this.safeString(i,"type",n),u=this.safeString2(this.options,"subType","defaultSubType","linear"),u=this.safeString(i,"subType",u),i=this.omit(i,["type","subType"])),n==="spot"){let h;h===void 0&&(h=this.safeString2(this.options,"watchMyTrades","mode","0"),h=this.safeString(i,"mode",h),i=this.omit(i,"mode")),o="trade.clearing#"+r+"#"+h,d=o}else{const h=this.getOrderChannelAndMessageHash(n,u,a,i);d=this.safeString(h,0),o=this.safeString(h,1)+":trade"}return c=await this.subscribePrivate(d,o,n,u,i),this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}getOrderChannelAndMessageHash(e,t,s=void 0,i={}){let n,r,a=this.safeString(this.options,"orderType","orders");a=this.safeString(i,"orderType",a),i=this.omit(i,"orderType");const o=s!==void 0?s.lowercaseId:void 0,d=s!==void 0?s.lowercaseBaseId:void 0,c=a;if(n=c,t==="linear"){const h=this.safeString(i,"margin","cross")==="cross"?c+"_cross":c;n=h,o!==void 0?(n+="."+o,r=n):r=h+".*"}else e==="future"?d!==void 0?(r=c+"."+d,n=r):r=c+".*":o!==void 0?(r=c+"."+o,n=r):r=c+".*";return[r,n]}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n,r,a,o="*";e!==void 0?(a=this.market(e),e=a.symbol,n=a.type,o=a.lowercaseId,r=a.linear?"linear":"inverse"):(n=this.safeString(this.options,"defaultType","spot"),n=this.safeString(i,"type",n),r=this.safeString2(this.options,"subType","defaultSubType","linear"),r=this.safeString(i,"subType",r),i=this.omit(i,["type","subType"]));let d,c;if(n==="spot")d="orders#"+o,c=d;else{const h=this.getOrderChannelAndMessageHash(n,r,a,i);c=this.safeString(h,0),d=this.safeString(h,1)}const u=await this.subscribePrivate(c,d,n,r,i);return this.newUpdates&&(s=u.getLimit(e,s)),this.filterBySinceLimit(u,t,s,"timestamp",!0)}handleOrder(e,t){const s=this.safeString2(t,"ch","topic"),i=this.safeValue(t,"data");let n=this.safeString(t,"contract_code");n===void 0&&(n=this.safeString(i,"symbol"));const r=this.safeMarket(n);let a;if(i!==void 0)if(this.safeString(i,"eventType")==="trade"){const u=this.parseOrderTrade(i,r);a={id:this.safeString(u,"order"),trades:[u],status:"closed",symbol:r.symbol}}else a=this.parseWsOrder(i,r);else{a=this.parseWsOrder(t,r);const c=this.safeValue(t,"trade",[]);if(c.length>0){const h={trades:c,ch:s,symbol:n},l={order:this.safeString(a,"id"),type:this.safeString(a,"type"),side:this.safeString(a,"side")};this.handleMyTrade(e,h,l)}}if(this.orders===void 0){const c=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new pO(c)}this.orders.append(a),e.resolve(this.orders,s);let d=s.replace("."+r.lowercaseId,"");d=d.replace("."+r.lowercaseBaseId,""),e.resolve(this.orders,d)}parseWsOrder(e,t=void 0){const s=this.safeInteger2(e,"lastActTime","ts"),i=this.safeInteger(e,"orderCreateTime"),n=this.safeString2(e,"contract_code","symbol");t=this.safeMarket(n,t);const r=this.safeSymbol(n,t),a=this.safeString2(e,"orderSize","volume"),o=this.parseOrderStatus(this.safeString2(e,"orderStatus","status")),d=this.safeString2(e,"orderId","order_id"),c=this.safeString2(e,"clientOrderId","client_order_id"),u=this.safeString2(e,"orderPrice","price"),h=this.safeString(e,"execAmt");let l=this.safeString(e,"type");const p=this.safeString(e,"fee");let m;if(p!==void 0){const T=this.safeString(e,"fee_asset");m={cost:p,currency:this.safeCurrencyCode(T)}}const g=this.safeString(e,"trade_avg_price"),y=this.safeValue(e,"trade");l!==void 0&&(l=l.split("-"));let b=this.safeStringLower(l,1);b===void 0&&(b=this.safeString(e,"order_price_type"));let w=this.safeStringLower(l,0);w===void 0&&(w=this.safeString(e,"direction"));const k=this.safeString(e,"orderValue");return this.safeOrder({info:e,id:d,clientOrderId:c,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:s,status:o,symbol:r,type:b,timeInForce:void 0,postOnly:void 0,side:w,price:u,amount:a,filled:h,remaining:void 0,cost:k,fee:m,average:g,trades:y},t)}parseOrderTrade(e,t=void 0){t=this.safeMarket(void 0,t);const s=t.symbol,i=this.safeString(e,"tradeId"),n=this.safeString(e,"tradePrice"),r=this.safeString(e,"tradeVolume"),a=this.safeString(e,"orderId"),o=this.safeInteger(e,"tradeTime");let d=this.safeString(e,"type"),c;if(d!==void 0){const l=d.split("-");c=l[0],d=l[1]}const u=this.safeValue(e,"aggressor");let h;return u!==void 0&&(h=u?"taker":"maker"),this.safeTrade({info:e,timestamp:o,datetime:this.iso8601(o),symbol:s,id:i,order:a,type:d,takerOrMaker:h,side:c,price:n,amount:r,cost:void 0,fee:void 0},t)}async watchBalance(e={}){let t=this.safeString2(this.options,"watchBalance","defaultType","spot");t=this.safeString(e,"type",t);let s=this.safeString2(this.options,"watchBalance","subType","linear");s=this.safeString(e,"subType",s),e=this.omit(e,["type","subType"]),e=this.omit(e,"type"),await this.loadMarkets();let i,n,r;if(t==="spot"){let o=this.safeString2(this.options,"watchBalance","mode","2");o=this.safeString(e,"mode",o),i="accounts.update#"+o,n=i}else{const o=this.safeString(e,"symbol"),d=this.safeString(e,"currency"),c=o!==void 0?this.market(o):void 0,u=d!==void 0?this.currency(d):void 0;r=this.safeString(e,"margin","cross"),e=this.omit(e,["currency","symbol","margin"]);let h="accounts";i=h,s==="linear"?(h=r==="cross"?h+"_cross":h,i=h,r==="isolated"?o!==void 0?(i+="."+c.id,n=i):n=h+".*":u!==void 0?(n=h+"."+u.id,i=n):n=h+".*"):t==="future"?u!==void 0?(i+="."+u.id,n=i):n=h+".*":c!==void 0?(i+="."+c.id,n=i):n=h+".*"}const a={type:t,subType:s,margin:r};return await this.subscribePrivate(n,i,t,s,e,a)}handleBalance(e,t){const s=this.safeString(t,"ch");if(s!==void 0){const i=this.safeValue(t,"data",{}),n=this.safeString(i,"currency"),r=this.safeCurrencyCode(n),a=this.account();a.free=this.safeString(i,"available"),a.total=this.safeString(i,"balance"),this.balance[r]=a,this.balance=this.safeBalance(this.balance),e.resolve(this.balance,s)}else{const i=this.safeValue(t,"data",[]);if(i.length===0)return;const r=this.safeValue(i,0,{});let a=this.safeString(t,"topic"),o=this.safeValue2(e.subscriptions,a,a+".*");if(o===void 0){const u=this.safeString(r,"margin_asset");a+="."+u.toLowerCase(),o=this.safeValue(e.subscriptions,a)}const d=this.safeString(o,"type");if(this.safeString(o,"subType")==="linear")if(this.safeString(o,"margin")==="cross"){const h=d==="future"?"futures_contract_detail":"contract_detail",l=this.safeValue(r,h,[]);if(l.length>0)for(let m=0;m<l.length;m++){const g=l[m],y=this.safeString2(g,"contract_code","margin_account"),b=this.safeMarket(y),w=this.safeString(g,"margin_asset"),k=this.safeCurrency(w),T=this.safeString(b,"settle",k.code);if(T!==void 0){const O=this.account();O.free=this.safeString2(g,"margin_balance","margin_available"),O.used=this.safeString(g,"margin_frozen");const x={};x[T]=O;const C=b.symbol;this.balance[C]=this.safeBalance(x)}}}else for(let h=0;h<i.length;h++){const l=i[h],p=this.account();p.free=this.safeString(l,"margin_balance","margin_available"),p.used=this.safeString(l,"margin_frozen");const m=this.safeString2(l,"margin_asset","symbol"),g=this.safeCurrencyCode(m);this.balance[g]=p,this.balance=this.safeBalance(this.balance)}else for(let u=0;u<i.length;u++){const h=i[u],l=this.safeString(h,"symbol"),p=this.safeCurrencyCode(l),m=this.account();m.free=this.safeString(h,"margin_available"),m.used=this.safeString(h,"margin_frozen"),this.balance[p]=m,this.balance=this.safeBalance(this.balance)}e.resolve(this.balance,a)}}handleSubscriptionStatus(e,t){const s=this.safeString(t,"id"),i=this.indexBy(e.subscriptions,"id"),n=this.safeValue(i,s);if(n!==void 0){const r=this.safeValue(n,"method");if(r!==void 0)return r.call(this,e,t,n);s in e.subscriptions&&delete e.subscriptions[s]}return t}handleSystemStatus(e,t){return t}handleSubject(e,t){const s=this.safeValue(t,"ch",""),i=s.split(".");if(this.safeString(i,0)==="market"){const d=this.safeString(i,2),c={depth:this.handleOrderBook,mbp:this.handleOrderBook,detail:this.handleTicker,trade:this.handleTrades,kline:this.handleOHLCV},u=this.safeValue(c,d);return u===void 0?t:u.call(this,e,t)}const r=s.split("#"),a=this.safeString(r,0,"");if(a==="trade.clearing"){this.handleMyTrade(e,t);return}if(a.indexOf("accounts.update")!==-1){this.handleBalance(e,t);return}if(a==="orders"){this.handleOrder(e,t);return}if(this.safeString(t,"op")==="notify"){const d=this.safeString(t,"topic","");d.indexOf("orders")!==-1&&this.handleOrder(e,t),d.indexOf("account")!==-1&&this.handleBalance(e,t)}}async pong(e,t){const s=this.safeInteger(t,"ping");if(s!==void 0){await e.send({pong:s});return}if(this.safeString(t,"action")==="ping"){const r=this.safeValue(t,"data"),a=this.safeInteger(r,"ts");await e.send({action:"pong",data:{ts:a}});return}if(this.safeString(t,"op")==="ping"){const r=this.safeInteger(t,"ts");await e.send({op:"pong",ts:r})}}handlePing(e,t){this.spawn(this.pong,e,t)}handleAuthenticate(e,t){return e.resolve(t,"auth"),t}handleErrorMessage(e,t){if(this.safeString(t,"status")==="error"){const n=this.safeString(t,"id"),r=this.indexBy(e.subscriptions,"id"),a=this.safeValue(r,n);if(a!==void 0){const o=this.safeString(t,"err-code");try{this.throwExactlyMatchedException(this.exceptions.ws.exact,o,this.json(t))}catch(d){const c=this.safeString(a,"messageHash");e.reject(d,c),e.reject(d,n),n in e.subscriptions&&delete e.subscriptions[n]}}return!1}const i=this.safeInteger(t,"code");if(i!==void 0&&i!==200){const n=this.id+" "+this.json(t);try{this.throwExactlyMatchedException(this.exceptions.ws.exact,i,n)}catch(r){if(r instanceof lO){e.reject(r,"auth");const a="auth";return a in e.subscriptions&&delete e.subscriptions[a],!1}else e.reject(r)}}return t}handleMessage(e,t){if(this.handleErrorMessage(e,t)){if("id"in t){this.handleSubscriptionStatus(e,t);return}if("action"in t){const s=this.safeString(t,"action");if(s==="ping"){this.handlePing(e,t);return}if(s==="sub"){this.handleSubscriptionStatus(e,t);return}}if("ch"in t)if(t.ch==="auth"){this.handleAuthenticate(e,t);return}else{this.handleSubject(e,t);return}if("op"in t){const s=this.safeString(t,"op");if(s==="ping"){this.handlePing(e,t);return}if(s==="auth"){this.handleAuthenticate(e,t);return}if(s==="sub"){this.handleSubscriptionStatus(e,t);return}if(s==="notify"){this.handleSubject(e,t);return}}"ping"in t&&this.handlePing(e,t)}}handleMyTrade(e,t,s={}){if(this.myTrades===void 0){const r=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new pO(r)}const i=this.myTrades,n=this.safeString(t,"ch");if(n!==void 0){const r=this.safeValue(t,"data");if(r!==void 0){const a=this.parseWsTrade(r);this.safeString(a,"symbol")!==void 0&&(i.append(a),e.resolve(this.myTrades,n))}else{const a=this.safeValue(t,"trades",[]),o=this.safeValue(t,"symbol"),d=this.market(o);for(let l=0;l<a.length;l++){const p=a[l];let m=this.parseTrade(p,d);m=this.extend(m,s),i.append(m)}const c=n+":trade";e.resolve(this.myTrades,c);let u=n.replace("."+d.lowercaseId,"");u=u.replace("."+d.lowercaseBaseId,"");const h=u+":trade";e.resolve(this.myTrades,h)}}}parseWsTrade(e){const t=this.safeSymbol(this.safeString(e,"symbol")),s=this.safeString2(e,"side","orderSide"),i=this.safeString(e,"tradeId"),n=this.safeString(e,"tradePrice"),r=this.safeString(e,"tradeVolume"),a=this.safeString(e,"orderId"),o=this.safeInteger(e,"tradeTime"),d=this.market(t);let c=this.safeString(e,"orderType");const u=this.safeValue(e,"aggressor");let h;u!==void 0&&(h=u?"taker":"maker");let l;c!==void 0&&(c=c.split("-"),l=this.safeString(c,1));let p;const m=this.safeCurrencyCode(this.safeString(e,"feeCurrency"));return m!==void 0&&(p={cost:this.safeString(e,"transactFee"),currency:m}),this.safeTrade({info:e,timestamp:o,datetime:this.iso8601(o),symbol:t,id:i,order:a,type:l,takerOrMaker:h,side:s,price:n,amount:r,cost:void 0,fee:p},d)}getUrlByMarketType(e,t=!0,s=!1){const i=this.safeString(this.options,"api","api"),n={hostname:this.hostname};let r,a;if(e==="spot")s?r=this.urls.api.ws[i].spot.private:r=this.urls.api.ws[i].spot.public,a=this.implodeParams(r,n);else{const o=this.urls.api.ws[i][e],d=t?o.linear:o.inverse;a=s?d.private:d.public}return a}async subscribePublic(e,t,s,i=void 0,n={}){const r=this.requestId(),a={sub:s,id:r},o={id:r,messageHash:s,symbol:t,params:n};return i!==void 0&&(o.method=i),await this.watch(e,s,this.extend(a,n),s,o)}async subscribePrivate(e,t,s,i,n={},r={}){const a=this.nonce(),o={id:a,messageHash:t,params:n},d=this.extend(o,r);let c;s==="spot"?c={action:"sub",ch:e}:c={op:"sub",topic:e,cid:a};const u=i==="linear",h=this.getUrlByMarketType(s,u,!0),l=s==="spot"?this.urls.hostnames.spot:this.urls.hostnames.contract,p={type:s,url:h,hostname:l};return s==="spot"&&(this.options.ws.gunzip=!1),await this.authenticate(p),await this.watch(h,t,this.extend(c,n),e,d)}async authenticate(e={}){const t=this.safeString(e,"url"),s=this.safeString(e,"hostname"),i=this.safeString(e,"type");if(t===void 0||s===void 0||i===void 0)throw new sW(this.id+" authenticate requires a url, hostname and type argument");this.checkRequiredCredentials();const n="auth",r=t.replace("wss://"+s,""),a=this.client(t);let o=this.safeValue(a.subscriptions,n);if(o===void 0){o=a.future(n);const d=this.ymdhms(this.milliseconds(),"T");let c;i==="spot"?c={accessKey:this.apiKey,signatureMethod:"HmacSHA256",signatureVersion:"2.1",timestamp:d}:c={AccessKeyId:this.apiKey,SignatureMethod:"HmacSHA256",SignatureVersion:"2",Timestamp:d},c=this.keysort(c);const u=this.urlencode(c),h=["GET",s,r,u].join(`
`),l=this.hmac(this.encode(h),this.encode(this.secret),"sha256","base64");let p;i==="spot"?p={params:{authType:"api",accessKey:this.apiKey,signatureMethod:"HmacSHA256",signatureVersion:"2.1",timestamp:d,signature:l},action:"req",ch:n}:p={op:n,type:"api",AccessKeyId:this.apiKey,SignatureMethod:"HmacSHA256",SignatureVersion:"2",Timestamp:d,Signature:l},await this.watch(t,n,p,n,o)}return await o}};const rW=Q_,{ExchangeError:aW}=de,{ArrayCache:oW,ArrayCacheByTimestamp:dW}=rt;var cW=class extends rW{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTickers:!1,watchTicker:!0,watchTrades:!0,watchBalance:!1,watchOHLCV:!0},urls:{api:{ws:{api:{public:"wss://{hostname}/ws",private:"wss://{hostname}/ws/v2"}}}},options:{tradesLimit:1e3,OHLCVLimit:1e3,api:"api",ws:{gunzip:!0}}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e.toString()}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i="market."+s.id+".detail",n=this.safeString(this.options,"api","api"),r={hostname:this.hostname},a=this.implodeParams(this.urls.api.ws[n].public,r),o=this.requestId(),d={sub:i,id:o},c={id:o,messageHash:i,symbol:e,params:t};return await this.watch(a,i,this.extend(d,t),i,c)}handleTicker(e,t){const s=this.safeValue(t,"tick",{}),i=this.safeString(t,"ch"),n=i.split("."),r=this.safeString(n,1),a=this.safeMarket(r),o=this.parseTicker(s,a),d=this.safeValue(t,"ts");o.timestamp=d,o.datetime=this.iso8601(d);const c=o.symbol;return this.tickers[c]=o,e.resolve(o,i),t}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="market."+n.id+".trade.detail",a=this.safeString(this.options,"api","api"),o={hostname:this.hostname},d=this.implodeParams(this.urls.api.ws[a].public,o),c=this.requestId(),u={sub:r,id:c},h={id:c,messageHash:r,symbol:e,params:i},l=await this.watch(d,r,this.extend(u,i),r,h);return this.newUpdates&&(s=l.getLimit(e,s)),this.filterBySinceLimit(l,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"tick",{}),i=this.safeValue(s,"data",{}),n=this.safeString(t,"ch"),r=n.split("."),a=this.safeString(r,1),o=this.safeMarket(a),d=o.symbol;let c=this.safeValue(this.trades,d);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new oW(u),this.trades[d]=c}for(let u=0;u<i.length;u++){const h=this.parseTrade(i[u],o);c.append(h)}return e.resolve(c,n),t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=this.timeframes[t],o="market."+r.id+".kline."+a,d=this.safeString(this.options,"api","api"),c={hostname:this.hostname},u=this.implodeParams(this.urls.api.ws[d].public,c),h=this.requestId(),l={sub:o,id:h},p={id:h,messageHash:o,symbol:e,timeframe:t,params:n},m=await this.watch(u,o,this.extend(l,n),o,p);return this.newUpdates&&(i=m.getLimit(e,i)),this.filterBySinceLimit(m,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"ch"),i=s.split("."),n=this.safeString(i,1),r=this.safeMarket(n),a=r.symbol,o=this.safeString(i,3),d=this.findTimeframe(o);this.ohlcvs[a]=this.safeValue(this.ohlcvs,a,{});let c=this.safeValue(this.ohlcvs[a],d);if(c===void 0){const l=this.safeInteger(this.options,"OHLCVLimit",1e3);c=new dW(l),this.ohlcvs[a][d]=c}const u=this.safeValue(t,"tick"),h=this.parseOHLCV(u,r);c.append(h),e.resolve(c,s)}async watchOrderBook(e,t=void 0,s={}){if(t!==void 0&&t!==150)throw new aW(this.id+" watchOrderBook accepts limit = 150 only");await this.loadMarkets();const i=this.market(e);e=i.symbol,t=t===void 0?150:t;const n="market."+i.id+".mbp."+t.toString(),r=this.safeString(this.options,"api","api"),a={hostname:this.hostname},o=this.implodeParams(this.urls.api.ws[r].public,a),d=this.requestId(),c={sub:n,id:d},u={id:d,messageHash:n,symbol:e,limit:t,params:s,method:this.handleOrderBookSubscription};return(await this.watch(o,n,this.extend(c,s),n,u)).limit()}handleOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeString(s,"messageHash"),r=this.orderbooks[i],a=this.safeValue(t,"data"),o=this.parseOrderBook(a,i);o.nonce=this.safeInteger(a,"seqNum"),r.reset(o);const d=r.cache;for(let c=0;c<d.length;c++){const u=d[c];this.handleOrderBookMessage(e,u,r)}this.orderbooks[i]=r,e.resolve(r,n)}async watchOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit"),r=this.safeValue(s,"params"),a=this.safeString(s,"messageHash"),o=this.safeString(this.options,"api","api"),d={hostname:this.hostname},c=this.implodeParams(this.urls.api.ws[o].public,d),u=this.requestId(),h={req:a,id:u},l={id:u,messageHash:a,symbol:i,limit:n,params:r,method:this.handleOrderBookSnapshot};return(await this.watch(c,u,h,u,l)).limit()}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s){const i=this.safeValue(t,"tick",{}),n=this.safeInteger(i,"seqNum");if(this.safeInteger(i,"prevSeqNum")<=s.nonce&&n>s.nonce){const a=this.safeValue(i,"asks",[]),o=this.safeValue(i,"bids",[]);this.handleDeltas(s.asks,a),this.handleDeltas(s.bids,o),s.nonce=n;const d=this.safeInteger(t,"ts");s.timestamp=d,s.datetime=this.iso8601(d)}return s}handleOrderBook(e,t){const s=this.safeString(t,"ch"),n=this.safeValue(t,"ch").split("."),r=this.safeString(n,1),a=this.safeSymbol(r),o=this.orderbooks[a];o.nonce===void 0?o.cache.push(t):(this.handleOrderBookMessage(e,t,o),e.resolve(o,s))}handleOrderBookSubscription(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit");i in this.orderbooks&&delete this.orderbooks[i],this.orderbooks[i]=this.orderBook({},n),this.spawn(this.watchOrderBookSnapshot,e,t,s)}handleSubscriptionStatus(e,t){const s=this.safeString(t,"id"),i=this.indexBy(e.subscriptions,"id"),n=this.safeValue(i,s);if(n!==void 0){const r=this.safeValue(n,"method");if(r!==void 0)return r.call(this,e,t,n);s in e.subscriptions&&delete e.subscriptions[s]}return t}handleSystemStatus(e,t){return t}handleSubject(e,t){const i=this.safeValue(t,"ch").split(".");if(this.safeString(i,0)==="market"){const r=this.safeString(i,2),a={mbp:this.handleOrderBook,detail:this.handleTicker,trade:this.handleTrades,kline:this.handleOHLCV},o=this.safeValue(a,r);return o===void 0?t:o.call(this,e,t)}}async pong(e,t){await e.send({pong:this.safeInteger(t,"ping")})}handlePing(e,t){this.spawn(this.pong,e,t)}handleErrorMessage(e,t){if(this.safeString(t,"status")==="error"){const i=this.safeString(t,"id"),n=this.indexBy(e.subscriptions,"id"),r=this.safeValue(n,i);if(r!==void 0){const a=this.safeString(t,"err-code");try{this.throwExactlyMatchedException(this.exceptions.exact,a,this.json(t))}catch(o){const d=this.safeString(r,"messageHash");e.reject(o,d),e.reject(o,i),i in e.subscriptions&&delete e.subscriptions[i]}}return!1}return t}handleMessage(e,t){this.handleErrorMessage(e,t)&&("id"in t?this.handleSubscriptionStatus(e,t):"ch"in t?this.handleSubject(e,t):"ping"in t&&this.handlePing(e,t))}};const uW=pC;var fW=class extends uW{describe(){return this.deepExtend(super.describe(),{alias:!0,id:"huobipro"})}};const hW=Z_,{InvalidNonce:lW}=de,{ArrayCache:pW,ArrayCacheByTimestamp:mW,ArrayCacheBySymbolById:mO}=rt;var gW=class extends hW{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTrades:!0,watchOHLCV:!0,watchTicker:!0,watchTickers:!1,watchOrders:!0,watchTransactions:!0},urls:{test:{ws:"wss://websocket-matic.idex.io/v1"},api:{}},options:{tradesLimit:1e3,ordersLimit:1e3,OHLCVLimit:1e3,watchOrderBookLimit:1e3,orderBookSubscriptions:{},token:void 0,fetchOrderBookSnapshotMaxAttempts:10,fetchOrderBookSnapshotMaxDelay:1e4}})}async subscribe(e,t,s=!0){const i=this.urls.test.ws,n={method:"subscribe",subscriptions:[e]};return await this.watch(i,t,n,t,s)}async subscribePrivate(e,t){const s=await this.authenticate(),i=this.urls.test.ws,n={method:"subscribe",token:s,subscriptions:[e]};return await this.watch(i,t,n,t)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i="tickers",n={name:i,markets:[s.id]},r=i+":"+s.id;return await this.subscribe(this.extend(n,t),r)}handleTicker(e,t){const s=this.safeString(t,"type"),i=this.safeValue(t,"data"),n=this.safeString(i,"m"),r=this.safeSymbol(n),a=s+":"+n,o=this.safeInteger(i,"t"),d=this.safeFloat(i,"c"),c=this.safeFloat(i,"P");let u;c!==void 0&&d!==void 0&&(u=d*c);const h={symbol:r,timestamp:o,datetime:this.iso8601(o),high:this.safeFloat(i,"h"),low:this.safeFloat(i,"l"),bid:this.safeFloat(i,"b"),bidVolume:void 0,ask:this.safeFloat(i,"a"),askVolume:void 0,vwap:void 0,open:this.safeFloat(i,"o"),close:d,last:d,previousClose:void 0,change:u,percentage:c,average:void 0,baseVolume:this.safeFloat(i,"v"),quoteVolume:this.safeFloat(i,"q"),info:t};e.resolve(h,a)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="trades",a={name:r,markets:[n.id]},o=r+":"+n.id,d=await this.subscribe(a,o);return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySinceLimit(d,t,s,"timestamp",!0)}handleTrade(e,t){const s=this.safeString(t,"type"),i=this.safeValue(t,"data"),n=this.safeString(i,"m"),r=s+":"+n,a=this.parseWsTrade(i);if(Object.keys(this.trades).length===0){const u=this.safeInteger(this.options,"tradesLimit");this.trades=new mO(u)}const c=this.trades;c.append(a),e.resolve(c,r)}parseWsTrade(e){const t=this.safeString(e,"m"),s=this.safeSymbol(t),i=this.safeString(e,"i"),n=this.safeFloat(e,"p"),r=this.safeFloat(e,"q"),a=this.safeFloat(e,"Q"),o=this.safeInteger(e,"t"),d=this.safeString(e,"s"),c={currency:this.safeString(e,"a"),cost:this.safeFloat(e,"f")},u=this.safeString(e,"l");return{info:e,timestamp:o,datetime:this.iso8601(o),symbol:s,id:i,order:void 0,type:void 0,takerOrMaker:u,side:d,price:n,amount:r,cost:a,fee:c}}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a="candles",o=this.timeframes[t],d={name:a,markets:[r.id],interval:o},c=a+":"+r.id,u=await this.subscribe(d,c);return this.newUpdates&&(i=u.getLimit(e,i)),this.filterBySinceLimit(u,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"type"),i=this.safeValue(t,"data"),n=this.safeString(i,"m"),r=s+":"+n,a=[this.safeInteger(i,"s"),this.safeFloat(i,"o"),this.safeFloat(i,"h"),this.safeFloat(i,"l"),this.safeFloat(i,"c"),this.safeFloat(i,"v")],o=this.safeSymbol(n),d=this.safeString(i,"i"),c=this.findTimeframe(d);this.ohlcvs[o]=this.safeValue(this.ohlcvs,o,{});let u=this.safeValue(this.ohlcvs[o],c);if(u===void 0){const h=this.safeInteger(this.options,"OHLCVLimit",1e3);u=new mW(h),this.ohlcvs[o][c]=u}u.append(a),e.resolve(u,r)}handleSubscribeMessage(e,t){const s=this.safeValue(t,"subscriptions");for(let i=0;i<s.length;i++){const n=s[i];if(this.safeString(n,"name")==="l2orderbook"){const a=this.safeValue(n,"markets");for(let o=0;o<a.length;o++){const d=a[o],c=this.safeValue(this.options,"orderBookSubscriptions",{});if(!(d in c)){const u=this.safeSymbol(d);if(!(u in this.orderbooks)){const h=this.countedOrderBook({});h.cache=[],this.orderbooks[u]=h}this.spawn(this.fetchOrderBookSnapshot,e,u)}}break}}}async fetchOrderBookSnapshot(e,t,s={}){const i=this.orderbooks[t],r="l2orderbook:"+this.market(t).id,a=e.subscriptions[r];a.fetchingOrderBookSnapshot||(a.startTime=this.milliseconds()),a.fetchingOrderBookSnapshot=!0;const o=this.safeInteger(this.options,"fetchOrderBookSnapshotMaxAttempts",10),d=this.safeInteger(this.options,"fetchOrderBookSnapshotMaxDelay",1e4);try{const c=this.safeInteger(a,"limit",0),u=await this.fetchOrderBook(t,c),h=this.safeValue(i.cache,0),l=this.safeValue(h,"data"),p=this.safeInteger(l,"u"),m=i.cache.length,g=this.safeValue(i.cache,m-1),y=this.safeValue(g,"data"),b=this.safeInteger(y,"u");if(p!==void 0&&b!==void 0&&p<=u.nonce+1&&b>u.nonce){i.reset(u);for(let k=0;k<i.cache.length;k++){const T=i.cache[k],O=this.safeValue(T,"data");this.safeInteger(O,"u")>i.nonce&&this.handleOrderBookMessage(e,T,i)}a.fetchingOrderBookSnapshot=!1,e.resolve(i,r)}else{a.numAttempts=a.numAttempts+1;const k=this.milliseconds()-a.startTime,T=a.numAttempts<o,O=k<d;if(T&&O)this.delay(this.rateLimit,this.fetchOrderBookSnapshot,e,t);else{const x=T?" after "+d.toString()+" milliseconds":" in "+o.toString()+" attempts";throw new lW(this.id+" failed to synchronize WebSocket feed with the snapshot for symbol "+t+x)}}}catch(c){a.fetchingOrderBookSnapshot=!1,e.reject(c,r)}}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),n="l2orderbook",r={name:n,markets:[i.id]},a=n+":"+i.id,o={fetchingOrderBookSnapshot:!1,numAttempts:0,startTime:void 0};return t===void 0?o.limit=1e3:o.limit=t,(await this.subscribe(r,a,o)).limit()}handleOrderBook(e,t){const s=this.safeValue(t,"data"),i=this.safeString(s,"m"),n=this.safeSymbol(i),r=this.orderbooks[n];r.nonce===void 0?r.cache.push(t):this.handleOrderBookMessage(e,t,r)}handleOrderBookMessage(e,t,s){const i=this.safeString(t,"type"),n=this.safeValue(t,"data"),r=this.safeString(n,"m"),a=i+":"+r,o=this.safeInteger(n,"u"),d=this.safeInteger(n,"t"),c=this.safeValue(n,"b"),u=this.safeValue(n,"a");this.handleDeltas(s.bids,c),this.handleDeltas(s.asks,u),s.nonce=o,s.timestamp=d,s.datetime=this.iso8601(d),e.resolve(s,a)}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1),n=this.safeInteger(t,2);e.store(s,i,n)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async authenticate(e={}){const t=this.seconds(),s=this.safeInteger(this.options,"lastAuthenticatedTime",0);if(t-s>900){const i={wallet:this.walletAddress,nonce:this.uuidv1()},n=await this.privateGetWsToken(this.extend(i,e));this.options.lastAuthenticatedTime=t,this.options.token=this.safeString(n,"token")}return this.options.token}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n="orders",r={name:n};let a=n;if(e!==void 0){e=this.symbol(e);const d=this.marketId(e);r.markets=[d],a=n+":"+d}const o=await this.subscribePrivate(r,a);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}handleOrder(e,t){const s=this.safeString(t,"type"),i=this.safeValue(t,"data"),n=this.safeString(i,"m"),r=this.safeSymbol(n),a=this.safeInteger(i,"t"),o=this.safeValue(i,"F"),d=[];for(let _=0;_<o.length;_++)d.push(this.parseWsTrade(o[_]));const c=this.safeString(i,"i"),u=this.safeString(i,"s"),h=this.safeString(i,"o"),l=this.safeFloat(i,"q"),p=this.safeFloat(i,"z");let m;l!==void 0&&p!==void 0&&(m=l-p);const g=this.safeFloat(i,"v"),y=this.safeFloat(i,"price",g);let b;l!==void 0&&y!==void 0&&(b=l*y);const w=this.safeString(i,"X"),k=this.parseOrderStatus(w),T={currency:void 0,cost:void 0};let O;for(let _=0;_<d.length;_++)O=d[_],T.currency=O.fee.currency,T.cost=this.sum(T.cost,O.fee.cost);const x=this.safeInteger(O,"timestamp"),C={info:t,id:c,clientOrderId:void 0,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:x,symbol:r,type:h,side:u,price:y,stopPrice:void 0,amount:l,cost:b,average:g,filled:p,remaining:m,status:k,fee:T,trades:d};if(this.orders===void 0){const _=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new mO(_)}const E=this.orders;E.append(C);const P=s+":"+n;e.resolve(E,P),e.resolve(E,s)}async watchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n="balances",r={name:n};let a=n;e!==void 0&&(a=n+":"+e);const o=await this.subscribePrivate(r,a);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}handleTransaction(e,t){const s=this.safeString(t,"type"),i=this.safeValue(t,"data"),n=this.safeString(i,"a"),r=s+":"+n,a=this.safeCurrencyCode(n),o=this.safeString(i,"w"),d={info:t,id:void 0,currency:a,amount:void 0,address:o,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,status:"ok",type:void 0,updated:void 0,txid:void 0,timestamp:void 0,datetime:void 0,fee:void 0};if(!(a in this.transactions)){const u=this.safeInteger(this.options,"transactionsLimit",1e3);this.transactions[a]=new pW(u)}const c=this.transactions[a];c.append(d),e.resolve(c,r),e.resolve(c,s)}handleMessage(e,t){const s=this.safeString(t,"type"),i={tickers:this.handleTicker,trades:this.handleTrade,subscriptions:this.handleSubscribeMessage,candles:this.handleOHLCV,l2orderbook:this.handleOrderBook,balances:this.handleTransaction,orders:this.handleOrder};s in i&&i[s].call(this,e,t)}};const yW=J_,{BadSymbol:bW,BadRequest:wW,ExchangeError:kW,NotSupported:SW,InvalidNonce:vW}=de,{ArrayCache:gO,ArrayCacheByTimestamp:TW,ArrayCacheBySymbolById:OW}=rt;var IW=class extends yW{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!1,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0},urls:{api:{ws:{public:"wss://ws.kraken.com",private:"wss://ws-auth.kraken.com",beta:"wss://beta-ws.kraken.com"}}},versions:{ws:"0.2.0"},options:{tradesLimit:1e3,OHLCVLimit:1e3,ordersLimit:1e3,symbolsByOrderId:{},checksum:!0},exceptions:{ws:{exact:{"Event(s) not found":wW},broad:{"Currency pair not in ISO 4217-A3 format":bW}}}})}handleTicker(e,t,s){const i=t[3],r="ticker"+":"+i,o=this.safeValue(this.options.marketsByWsName,i).symbol,d=t[1],c=this.safeFloat(d.p,0);let u;const h=this.safeFloat(d.v,0);h!==void 0&&c!==void 0&&(u=h*c);const l=this.safeFloat(d.c,0),p=this.milliseconds(),m={symbol:o,timestamp:p,datetime:this.iso8601(p),high:this.safeFloat(d.h,0),low:this.safeFloat(d.l,0),bid:this.safeFloat(d.b,0),bidVolume:this.safeFloat(d.b,2),ask:this.safeFloat(d.a,0),askVolume:this.safeFloat(d.a,2),vwap:c,open:this.safeFloat(d.o,0),close:l,last:l,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:h,quoteVolume:u,info:d};this.tickers[o]=m,e.resolve(m,r)}handleTrades(e,t,s){const i=this.safeString(t,3),r=this.safeString(t,2)+":"+i,a=this.safeValue(this.options.marketsByWsName,i),o=a.symbol;let d=this.safeValue(this.trades,o);if(d===void 0){const h=this.safeInteger(this.options,"tradesLimit",1e3);d=new gO(h),this.trades[o]=d}const c=this.safeValue(t,1,[]),u=this.parseTrades(c,a);for(let h=0;h<u.length;h++)d.append(u[h]);e.resolve(d,r)}handleOHLCV(e,t,s){const i=this.safeValue(s,"subscription",{}),n=this.safeInteger(i,"interval"),r=this.safeString(i,"name"),a=this.safeString(t,3),d=this.safeValue(this.options.marketsByWsName,a).symbol,c=this.findTimeframe(n),u=this.parseTimeframe(c);if(c!==void 0){const h=this.safeValue(t,1),l=r+":"+c+":"+a;let p=this.safeFloat(h,1);p-=u;const m=[parseInt(p*1e3),this.safeFloat(h,2),this.safeFloat(h,3),this.safeFloat(h,4),this.safeFloat(h,5),this.safeFloat(h,7)];this.ohlcvs[d]=this.safeValue(this.ohlcvs,d,{});let g=this.safeValue(this.ohlcvs[d],c);if(g===void 0){const y=this.safeInteger(this.options,"OHLCVLimit",1e3);g=new TW(y),this.ohlcvs[d][c]=g}g.append(m),e.resolve(g,l)}}requestId(){const e=this.sum(this.safeInteger(this.options,"reqid",0),1);return this.options.reqid=e,e}async watchPublic(e,t,s={}){await this.loadMarkets();const i=this.market(t),n=this.safeValue(i.info,"wsname"),r=e+":"+n,a=this.urls.api.ws.public,d={event:"subscribe",reqid:this.requestId(),pair:[n],subscription:{name:e}},c=this.deepExtend(d,s);return await this.watch(a,r,c,r)}async watchTicker(e,t={}){return await this.watchPublic("ticker",e,t)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n="trade",r=await this.watchPublic(n,e,i);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySinceLimit(r,t,s,"timestamp",!0)}async watchOrderBook(e,t=void 0,s={}){const i="book",n={};if(t!==void 0)if(t===10||t===25||t===100||t===500||t===1e3)n.subscription={depth:t};else throw new SW(this.id+" watchOrderBook accepts limit values of 10, 25, 100, 500 and 1000 only");return(await this.watchPublic(i,e,this.extend(n,s))).limit()}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r="ohlc",a=this.market(e);e=a.symbol;const o=this.safeValue(a.info,"wsname"),d=r+":"+t+":"+o,c=this.urls.api.ws.public,h={event:"subscribe",reqid:this.requestId(),pair:[o],subscription:{name:r,interval:this.timeframes[t]}},l=this.deepExtend(h,n),p=await this.watch(c,d,l,d);return this.newUpdates&&(i=p.getLimit(e,i)),this.filterBySinceLimit(p,s,i,0,!0)}async loadMarkets(e=!1,t={}){const s=await super.loadMarkets(e,t);let i=this.safeValue(this.options,"marketsByWsName");if(i===void 0||e){i={};for(let n=0;n<this.symbols.length;n++){const r=this.symbols[n],a=this.markets[r];if(a.darkpool){const o=this.safeValue(a,"info",{}),d=this.safeString(o,"altname"),c=d.slice(0,3)+"/"+d.slice(3);i[c]=a}else{const o=this.safeValue(a,"info",{}),d=this.safeString(o,"wsname");i[d]=a}}this.options.marketsByWsName=i}return s}async watchHeartbeat(e={}){await this.loadMarkets();const t="heartbeat",s=this.urls.api.ws.public;return await this.watch(s,t)}handleHeartbeat(e,t){const s=this.safeString(t,"event");e.resolve(t,s)}handleOrderBook(e,t,s){const i=t.length,n=t[i-1],a=t[i-2].split("-"),o=this.safeInteger(a,1,10),c=this.safeValue(this.options.marketsByWsName,n).symbol;let u;const h="book:"+n;if("as"in t[1]){this.orderbooks[c]=this.orderBook({},o);const l=this.orderbooks[c],p={as:"asks",bs:"bids"},m=Object.keys(p);for(let g=0;g<m.length;g++){const y=m[g],b=p[y],w=l[b],k=this.safeValue(t[1],y,[]);u=this.handleDeltas(w,k,u)}l.symbol=c,l.timestamp=u,l.datetime=this.iso8601(u),e.resolve(l,h)}else{const l=this.orderbooks[c];let p,m,g;i===5?(p=this.safeValue(t[1],"a",[]),m=this.safeValue(t[2],"b",[]),g=this.safeInteger(t[1],"c"),g=this.safeInteger(t[2],"c",g)):(g=this.safeInteger(t[1],"c"),"a"in t[1]?p=this.safeValue(t[1],"a",[]):m=this.safeValue(t[1],"b",[]));const y=l.asks,b=l.bids;let w;if(p!==void 0&&(u=this.handleDeltas(y,p,u),w=this.safeValue(p,0)),m!==void 0&&(u=this.handleDeltas(b,m,u),w=this.safeValue(m,0)),l.limit(),this.safeValue(this.options,"checksum",!0)){const T=this.safeString(w,0),O=this.safeString(w,1),x=T.split("."),C=O.split("."),E=x[1].length-0,P=C[1].length-0,_=[];if(g!==void 0){for(let v=0;v<10;v++){const N=this.formatNumber(y[v][0],E)+this.formatNumber(y[v][1],P);_.push(N)}for(let v=0;v<10;v++){const N=this.formatNumber(b[v][0],E)+this.formatNumber(b[v][1],P);_.push(N)}}const S=_.join("");if(this.crc32(S,!1)!==g){const v=new vW(this.id+" invalid checksum");e.reject(v,h)}}l.symbol=c,l.timestamp=u,l.datetime=this.iso8601(u),e.resolve(l,h)}}formatNumber(e,t){const i=this.numberToString(e).split("."),n=this.safeString(i,0),a=this.safeString(i,1,"").padEnd(t,"0"),o=n+a;let d=0;for(;o[d]==="0";)d+=1;return d>0?o.slice(d):o}handleDeltas(e,t,s){for(let i=0;i<t.length;i++){const n=t[i],r=parseFloat(n[0]),a=parseFloat(n[1]);s=Math.max(s||0,parseInt(parseFloat(n[2])*1e3)),e.store(r,a)}return s}handleSystemStatus(e,t){return t}async authenticate(e={}){const t=this.urls.api.ws.private,s=this.client(t),i="authenticated";let n=this.safeValue(s.subscriptions,i);if(n===void 0){const r=await this.privatePostGetWebSocketsToken(e);n=this.safeValue(r,"result"),s.subscriptions[i]=n}return this.safeString(n,"token")}async watchPrivate(e,t=void 0,s=void 0,i=void 0,n={}){await this.loadMarkets();const r=await this.authenticate(),a=e;let o=e;t!==void 0&&(t=this.symbol(t),o+=":"+t);const d=this.urls.api.ws.private,u={event:"subscribe",reqid:this.requestId(),subscription:{name:e,token:r}},h=this.deepExtend(u,n),l=await this.watch(d,o,h,a);return this.newUpdates&&(i=l.getLimit(t,i)),this.filterBySymbolSinceLimit(l,t,s,i,!0)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){return await this.watchPrivate("ownTrades",e,t,s,i)}handleMyTrades(e,t,s=void 0){const i=this.safeValue(t,0,[]);if(i.length>0){if(this.myTrades===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new gO(c)}const r=this.myTrades,a={};for(let c=0;c<i.length;c++){const u=this.safeValue(i,c,{}),h=Object.keys(u);for(let l=0;l<h.length;l++){const p=h[l],m=u[p],g=this.parseWsTrade(this.extend({id:p},m));r.append(g);const y=g.symbol;a[y]=!0}}const o="ownTrades";e.resolve(this.myTrades,o);const d=Object.keys(a);for(let c=0;c<d.length;c++){const u=o+":"+d[c];e.resolve(this.myTrades,u)}}}parseWsTrade(e,t=void 0){const s=this.safeString(e,"pair");t=this.safeValue(this.options.marketsByWsName,s,t);let i;const n=this.safeString(e,"ordertxid"),r=this.safeString2(e,"id","postxid"),a=this.safeTimestamp(e,"time"),o=this.safeString(e,"type"),d=this.safeString(e,"ordertype"),c=this.safeFloat(e,"price"),u=this.safeFloat(e,"vol");let h,l;if("fee"in e){let p;t!==void 0&&(p=t.quote),l={cost:this.safeFloat(e,"fee"),currency:p}}return t!==void 0&&(i=t.symbol),c!==void 0&&u!==void 0&&(h=c*u),{id:r,order:n,info:e,timestamp:a,datetime:this.iso8601(a),symbol:i,type:d,side:o,takerOrMaker:void 0,price:c,amount:u,cost:h,fee:l}}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.watchPrivate("openOrders",e,t,s,i)}handleOrders(e,t,s=void 0){const i=this.safeValue(t,0,[]);if(i.length>0){const r=this.safeInteger(this.options,"ordersLimit",1e3);this.orders===void 0&&(this.orders=new OW(r));const a=this.orders,o={};for(let u=0;u<i.length;u++){const h=this.safeValue(i,u,{}),l=Object.keys(h);for(let p=0;p<l.length;p++){const m=l[p],g=h[m],y=this.parseWsOrder(g);y.id=m;let b;const w=this.safeValue(this.options,"symbolsByOrderId",{});y.symbol!==void 0?(b=y.symbol,w[m]=b,this.options.symbolsByOrderId=w):b=this.safeString(w,m);const k=this.safeValue(a.hashmap,b),T=this.safeValue(k,m);let O=y;if(T!==void 0){const C=this.extend(T.info,O.info);O=this.parseWsOrder(C),O.id=m}if(a.length===r&&T===void 0){const C=a[0];C.id in w&&delete w[C.id]}a.append(O),o[b]=!0}}const d="openOrders";e.resolve(this.orders,d);const c=Object.keys(o);for(let u=0;u<c.length;u++){const h=d+":"+c[u];e.resolve(this.orders,h)}}}parseWsOrder(e,t=void 0){const s=this.safeValue(e,"descr",{}),i=this.safeString(s,"order");let n,r,a,o,d;if(i!==void 0){const x=i.split(" ");n=this.safeString(x,0),d=this.safeFloat(x,1),a=this.safeString(x,2),r=this.safeString(x,4),o=this.safeFloat(x,5)}n=this.safeString(s,"type",n),r=this.safeString(s,"ordertype",r),a=this.safeString(s,"pair",a),t=this.safeValue(this.options.marketsByWsName,a,t);let c;const u=this.safeTimestamp(e,"opentm");d=this.safeFloat(e,"vol",d);const h=this.safeFloat(e,"vol_exec");let l;d!==void 0&&h!==void 0&&(l=d-h);let p;const m=this.safeFloat(e,"cost");o=this.safeFloat(s,"price",o),(o===void 0||o===0)&&(o=this.safeFloat(s,"price2")),(o===void 0||o===0)&&(o=this.safeFloat(e,"price",o));const g=this.safeFloat2(e,"avg_price","price");if(t!==void 0&&(c=t.symbol,"fee"in e)){const x=e.oflags;p={cost:this.safeFloat(e,"fee"),rate:void 0},x.indexOf("fciq")>=0?p.currency=t.quote:x.indexOf("fcib")>=0&&(p.currency=t.base)}const y=this.parseOrderStatus(this.safeString(e,"status"));let b=this.safeString(e,"id");if(b===void 0){const x=this.safeValue(e,"txid");b=this.safeString(x,0)}const w=this.safeString(e,"userref"),k=this.safeValue(e,"trades");let T;k!==void 0&&(T=this.parseTrades(k,t,void 0,void 0,{order:b}));const O=this.safeFloat(e,"stopprice");return{id:b,clientOrderId:w,info:e,timestamp:u,datetime:this.iso8601(u),lastTradeTimestamp:void 0,status:y,symbol:c,type:r,timeInForce:void 0,postOnly:void 0,side:n,price:o,stopPrice:O,cost:m,amount:d,filled:h,average:g,remaining:l,fee:p,trades:T}}handleSubscriptionStatus(e,t){const s=this.safeString(t,"channelID");s!==void 0&&(e.subscriptions[s]=t)}handleErrorMessage(e,t){const s=this.safeValue(t,"errorMessage");if(s!==void 0){const i=this.safeValue(t,"reqid");if(i!==void 0){const n=this.exceptions.ws.broad,r=this.findBroadlyMatchedKey(n,s);let a;return r===void 0?a=new kW(s):a=new n[r](s),e.reject(a,i),!1}}return!0}handleMessage(e,t){if(Array.isArray(t)){const s=this.safeString(t,0),i=this.safeValue(e.subscriptions,s,{}),n=this.safeValue(i,"subscription",{}),r=t.length,a=this.safeString(t,r-2),o=this.safeString(n,"name"),d={book:this.handleOrderBook,ohlc:this.handleOHLCV,ticker:this.handleTicker,trade:this.handleTrades,openOrders:this.handleOrders,ownTrades:this.handleMyTrades},c=this.safeValue2(d,o,a);return c===void 0?t:c.call(this,e,t,i)}else if(this.handleErrorMessage(e,t)){const s=this.safeString(t,"event"),i={heartbeat:this.handleHeartbeat,systemStatus:this.handleSystemStatus,subscriptionStatus:this.handleSubscriptionStatus},n=this.safeValue(i,s);return n===void 0?t:n.call(this,e,t)}}};const xW=Bb,{ExchangeError:yO,InvalidNonce:_W,NetworkError:CW}=de,{ArrayCache:MW,ArrayCacheByTimestamp:PW,ArrayCacheBySymbolById:bO}=rt;var AW=class extends xW{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchOrders:!0,watchMyTrades:!0,watchTickers:!1,watchTicker:!0,watchTrades:!0,watchBalance:!0,watchOHLCV:!0},options:{tradesLimit:1e3,watchOrderBookRate:100,fetchOrderBookSnapshot:{maxAttempts:3,delay:1e3},watchTicker:{topic:"market/snapshot"}},streaming:{ping:this.ping}})}async negotiate(e={}){const t=this.client("ws"),s="negotiate";let i=this.safeValue(t.subscriptions,s);if(i===void 0){i=t.future(s),t.subscriptions[s]=i;let n;const r=!1;this.checkRequiredCredentials(r)?n=await this.privatePostBulletPrivate():n=await this.publicPostBulletPublic(),t.resolve(n,s)}return await i}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}async subscribe(e,t,s,i,n,r={}){await this.loadMarkets();const a=this.safeValue(e,"data",{}),o=this.safeValue(a,"instanceServers",[]),d=this.safeValue(o,0,{}),c=this.safeString(d,"endpoint"),u=this.safeString(a,"token"),h=this.requestId(),l={token:u,acceptUserMessage:"true"},p=c+"?"+this.urlencode(l),m={id:h,type:"subscribe",topic:t,response:!0},g={id:h.toString(),symbol:n,topic:t,messageHash:s,method:i},y=this.extend(m,r),b=t;return await this.watch(p,s,y,b,g)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i=await this.negotiate(),n=this.safeValue(this.options,"watchTicker",{}),a="/"+this.safeString(n,"topic","market/snapshot")+":"+s.id,o=a;return await this.subscribe(i,a,o,void 0,e,t)}handleTicker(e,t){const s=this.safeString(t,"topic");let i;if(s!==void 0){const c=s.split(":"),u=this.safeString(c,1);i=this.safeMarket(u,i,"-")}const n=this.safeValue(t,"data",{}),r=this.safeValue(n,"data",n),a=this.parseTicker(r,i),o=a.symbol;this.tickers[o]=a;const d=this.safeString(t,"topic");return d!==void 0&&e.resolve(a,d),t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=await this.negotiate(),a=this.market(e);e=a.symbol;const o=this.timeframes[t],d="/market/candles:"+a.id+"_"+o,c=d,u=await this.subscribe(r,d,c,void 0,e,n);return this.newUpdates&&(i=u.getLimit(e,i)),this.filterBySinceLimit(u,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(s,"symbol"),n=this.safeValue(s,"candles",[]),r=this.safeString(t,"topic"),a=r.split("_"),o=this.safeString(a,1),d=this.findTimeframe(o),c=this.safeSymbol(i),u=this.market(c);this.ohlcvs[c]=this.safeValue(this.ohlcvs,c,{});let h=this.safeValue(this.ohlcvs[c],d);if(h===void 0){const p=this.safeInteger(this.options,"OHLCVLimit",1e3);h=new PW(p),this.ohlcvs[c][d]=h}const l=this.parseOHLCV(n,u);h.append(l),e.resolve(h,r)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=await this.negotiate(),r=this.market(e);e=r.symbol;const a="/market/match:"+r.id,o=a,d=await this.subscribe(n,a,o,void 0,e,i);return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySinceLimit(d,t,s,"timestamp",!0)}handleTrade(e,t){const s=this.safeValue(t,"data",{}),i=this.parseTrade(s),n=this.safeString(t,"topic"),r=i.symbol;let a=this.safeValue(this.trades,r);if(a===void 0){const o=this.safeInteger(this.options,"tradesLimit",1e3);a=new MW(o),this.trades[r]=a}return a.append(i),e.resolve(a,n),t}async watchOrderBook(e,t=void 0,s={}){if(t!==void 0&&t!==20&&t!==100)throw new yO(this.id+" watchOrderBook 'limit' argument must be undefined, 20 or 100");await this.loadMarkets();const i=await this.negotiate(),n=this.market(e);e=n.symbol;const r="/market/level2:"+n.id,a=r;return(await this.subscribe(i,r,a,this.handleOrderBookSubscription,e,s)).limit()}retryFetchOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeString(s,"messageHash"),r=this.safeValue(this.options,"fetchOrderBookSnapshot",{}),a=this.safeInteger(r,"maxAttempts",3);let o=this.safeInteger(s,"numAttempts",0);if(o<a)n in e.subscriptions&&(o=this.sum(o,1),s.numAttempts=o,e.subscriptions[n]=s,this.spawn(this.fetchOrderBookSnapshot,e,t,s));else{n in e.subscriptions&&(s.fetchingOrderBookSnapshot=!1,s.numAttempts=0,e.subscriptions[n]=s);const d=new _W(this.id+" failed to synchronize WebSocket feed with the snapshot for symbol "+i+" in "+a.toString()+" attempts");e.reject(d,n)}}async fetchOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeInteger(s,"limit"),r=this.safeString(s,"messageHash");try{const a=await this.fetchOrderBook(i,n),o=this.orderbooks[i],d=o.cache,c=this.safeValue(d,0,{}),u=this.safeValue(c,"data",{}),h=this.safeInteger(u,"sequenceStart"),l=this.safeInteger(a,"nonce"),p=h-1;if(l<p)this.retryFetchOrderBookSnapshot(e,t,s);else{o.reset(a);for(let m=0;m<d.length;m++){const g=d[m];this.handleOrderBookMessage(e,g,o)}this.orderbooks[i]=o,e.resolve(o,r)}}catch(a){a instanceof CW?this.retryFetchOrderBookSnapshot(e,t,s):e.reject(a,r)}}handleDelta(e,t,s){const i=this.safeFloat(t,0);if(i>0&&this.safeInteger(t,2)>s){const r=this.safeFloat(t,1);e.store(i,r)}}handleDeltas(e,t,s){for(let i=0;i<t.length;i++)this.handleDelta(e,t[i],s)}handleOrderBookMessage(e,t,s){const i=this.safeValue(t,"data",{}),n=this.safeInteger(i,"sequenceEnd");if(n>s.nonce){const r=this.safeInteger(t,"sequenceStart");if(r!==void 0&&r-1>s.nonce)throw new yO(this.id+" handleOrderBook received an out-of-order nonce");const a=this.safeValue(i,"changes",{});let o=this.safeValue(a,"asks",[]),d=this.safeValue(a,"bids",[]);o=this.sortBy(o,2),d=this.sortBy(d,2),this.handleDeltas(s.asks,o,s.nonce),this.handleDeltas(s.bids,d,s.nonce),s.nonce=n,s.timestamp=void 0,s.datetime=void 0}return s}handleOrderBook(e,t){const s=this.safeString(t,"topic"),i=this.safeValue(t,"data"),n=this.safeString(i,"symbol"),r=this.safeSymbol(n,void 0,"-"),a=this.orderbooks[r];if(a.nonce===void 0){const o=this.safeValue(e.subscriptions,s);if(this.safeValue(o,"fetchingOrderBookSnapshot")===void 0){o.fetchingOrderBookSnapshot=!0,e.subscriptions[s]=o;const c=this.safeValue(this.options,"fetchOrderBookSnapshot",{}),u=this.safeInteger(c,"delay",this.rateLimit);this.delay(u,this.fetchOrderBookSnapshot,e,t,o)}a.cache.push(t)}else this.handleOrderBookMessage(e,t,a),e.resolve(a,s)}handleOrderBookSubscription(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeString(s,"limit");i in this.orderbooks&&delete this.orderbooks[i],this.orderbooks[i]=this.orderBook({},n)}handleSubscriptionStatus(e,t){const s=this.safeString(t,"id"),i=this.indexBy(e.subscriptions,"id"),n=this.safeValue(i,s,{}),r=this.safeValue(n,"method");return r!==void 0&&r.call(this,e,t,n),t}handleSystemStatus(e,t){return t}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=await this.negotiate(),r="/spotMarket/tradeOrders",a={privateChannel:!0};let o=r;if(e!==void 0){const c=this.market(e);e=c.symbol,o=o+":"+c.symbol}const d=await this.subscribe(n,r,o,void 0,void 0,this.extend(a,i));return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySymbolSinceLimit(d,e,t,s,!0)}parseWsOrderStatus(e){const t={open:"open",filled:"closed",match:"open",update:"open",canceled:"canceled"};return this.safeString(t,e,e)}parseWsOrder(e,t=void 0){const s=this.safeString(e,"orderId"),i=this.safeString(e,"clientOid"),n=this.safeStringLower(e,"orderType"),r=this.safeString(e,"price"),a=this.safeString(e,"filledSize"),o=this.safeString(e,"size"),d=this.safeString(e,"type"),c=this.parseWsOrderStatus(d),u=this.safeIntegerProduct(e,"orderTime",1e-6),h=this.safeString(e,"symbol");t=this.safeMarket(h,t);const l=t.symbol,p=this.safeStringLower(e,"side");return this.safeOrder({info:e,symbol:l,id:s,clientOrderId:i,timestamp:u,datetime:this.iso8601(u),lastTradeTimestamp:void 0,type:n,timeInForce:void 0,postOnly:void 0,side:p,price:r,stopPrice:void 0,amount:o,cost:void 0,average:void 0,filled:a,remaining:void 0,status:c,fee:void 0,trades:void 0},t)}handleOrder(e,t){const s="/spotMarket/tradeOrders",i=this.safeValue(t,"data"),n=this.parseWsOrder(i),r=this.safeString(n,"symbol"),a=this.safeString(n,"id");if(r!==void 0){if(this.orders===void 0){const h=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new bO(h)}const o=this.orders,d=this.safeValue(o.hashmap,r,{}),c=this.safeValue(d,a);if(c!==void 0){const h=this.safeValue(c,"stopPrice");h!==void 0&&(n.stopPrice=h),c.status==="closed"&&(n.status="closed")}o.append(n),e.resolve(this.orders,s);const u=s+":"+r;e.resolve(this.orders,u)}}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=await this.negotiate(),r="/spot/tradeFills",a={privateChannel:!0};let o=r;if(e!==void 0){const c=this.market(e);e=c.symbol,o=o+":"+c.symbol}const d=await this.subscribe(n,r,o,void 0,void 0,this.extend(a,i));return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySymbolSinceLimit(d,e,t,s)}handleMyTrade(e,t){let s=this.myTrades;if(s===void 0){const o=this.safeInteger(this.options,"tradesLimit",1e3);s=new bO(o)}const i=this.safeValue(t,"data"),n=this.parseWsTrade(i);s.append(n);const r="/spot/tradeFills";e.resolve(s,r);const a=r+":"+n.symbol;e.resolve(s,a)}parseWsTrade(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,"-");const i=t.symbol,n=this.safeString(e,"orderType"),r=this.safeString(e,"side"),a=this.safeString(e,"tradeId"),o=this.safeString(e,"price"),d=this.safeString(e,"size"),c=this.safeString(e,"orderId"),u=this.safeIntegerProduct(e,"time",1e-6),h=t.quote,p={cost:void 0,rate:this.safeString(e,"feeRate"),currency:h};return this.safeTrade({info:e,timestamp:u,datetime:this.iso8601(u),symbol:i,id:a,order:c,type:n,takerOrMaker:void 0,side:r,price:o,amount:d,cost:void 0,fee:p},t)}async watchBalance(e={}){await this.loadMarkets();const t=await this.negotiate(),s="/account/balance",i={privateChannel:!0},n=s;return await this.subscribe(t,s,n,this.handleBalanceSubscription,void 0,this.extend(i,e))}handleBalance(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(t,"topic"),n=this.safeString(s,"currency"),r=this.safeString(s,"relationEvent");let a;if(r!==void 0){const l=r.split(".");a=this.safeString(l,0)}const o=this.safeString2(this.options,"watchBalance","defaultType","trade"),d=this.safeValue(this.options,"accountsByType"),c=this.safeString(d,a,"trade");c in this.balance||(this.balance[c]={});const u=this.safeCurrencyCode(n),h=this.account();h.free=this.safeString(s,"available"),h.used=this.safeString(s,"hold"),h.total=this.safeString(s,"total"),this.balance[c][u]=h,this.balance[c]=this.safeBalance(this.balance[c]),c===o&&e.resolve(this.balance[c],i)}handleBalanceSubscription(e,t,s){this.spawn(this.fetchBalanceSnapshot,e,t)}async fetchBalanceSnapshot(e,t){await this.loadMarkets(),this.checkRequiredCredentials();const s="/account/balance",n={type:this.safeString2(this.options,"watchBalance","defaultType","spot")},r=await this.fetchBalance(n),a=this.safeValue(r.info,"data",[]);if(a.length>0){const o=this.safeString2(this.options,"watchBalance","defaultType","trade");for(let d=0;d<a.length;d++){const c=a[d],u=this.safeString(c,"type"),h=this.safeValue(this.options,"accountsByType"),l=this.safeString(h,u,"trade");l in this.balance||(this.balance[l]={});const p=this.safeString(c,"currency"),m=this.safeCurrencyCode(p),g=this.account();g.free=this.safeString(c,"available"),g.used=this.safeString(c,"holds"),g.total=this.safeString(c,"total"),this.balance[o][m]=g,this.balance[o]=this.safeBalance(this.balance[o])}e.resolve(this.balance[o],s)}}handleSubject(e,t){const s=this.safeString(t,"subject"),i={"trade.l2update":this.handleOrderBook,"trade.ticker":this.handleTicker,"trade.snapshot":this.handleTicker,"trade.l3match":this.handleTrade,"trade.candles.update":this.handleOHLCV,"account.balance":this.handleBalance,"/spot/tradeFills":this.handleMyTrade,orderChange:this.handleOrder},n=this.safeValue(i,s);return n===void 0?t:n.call(this,e,t)}ping(e){return{id:this.requestId().toString(),type:"ping"}}handlePong(e,t){return e.lastPong=this.milliseconds(),t}handleErrorMessage(e,t){return t}handleMessage(e,t){if(this.handleErrorMessage(e,t)){const s=this.safeString(t,"type"),i={welcome:this.handleSystemStatus,ack:this.handleSubscriptionStatus,message:this.handleSubject,pong:this.handlePong},n=this.safeValue(i,s);return n===void 0?t:n.call(this,e,t)}}};const BW=eC,{ArrayCache:EW}=rt;var NW=class extends BW{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!1,watchTickers:!1,watchTrades:!0,watchMyTrades:!1,watchOrders:void 0,watchOrderBook:!0,watchOHLCV:!1},urls:{api:{ws:"wss://ws.luno.com/api/1"}},options:{sequenceNumbers:{}},streaming:{},exceptions:{}})}async watchTrades(e,t=void 0,s=void 0,i={}){await this.checkRequiredCredentials(),await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="/stream/"+n.id,a={symbol:e},o=this.urls.api.ws+r,d="trades:"+e,c={api_key_id:this.apiKey,api_key_secret:this.secret},u=this.deepExtend(c,i),h=await this.watch(o,d,u,r,a);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySinceLimit(h,t,s,"timestamp",!0)}handleTrades(e,t,s){const i=this.safeValue(t,"trade_updates",[]);if(i.length===0)return;const r=s.symbol,a=this.market(r),o="trades:"+r;let d=this.safeValue(this.trades,r);if(d===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);d=new EW(c),this.trades[r]=d}for(let c=0;c<i.length;c++){const u=i[c],h=this.parseTrade(u,a);d.append(h)}this.trades[r]=d,e.resolve(this.trades[r],o)}parseTrade(e,t){return this.safeTrade({info:e,id:void 0,timestamp:void 0,datetime:void 0,symbol:t.symbol,order:void 0,type:void 0,side:void 0,takerOrMaker:void 0,price:void 0,amount:this.safeString(e,"base"),cost:this.safeString(e,"counter"),fee:void 0},t)}async watchOrderBook(e,t=void 0,s={}){await this.checkRequiredCredentials(),await this.loadMarkets();const i=this.market(e);e=i.symbol;const n="/stream/"+i.id,r={symbol:e},a=this.urls.api.ws+n,o="orderbook:"+e,d={api_key_id:this.apiKey,api_key_secret:this.secret},c=this.deepExtend(d,s);return(await this.watch(a,o,c,n,r)).limit(t)}handleOrderBook(e,t,s){const i=s.symbol,n="orderbook:"+i,r=this.safeString(t,"timestamp");let a=this.safeValue(this.orderbooks,i);if(a===void 0&&(a=this.indexedOrderBook({}),this.orderbooks[i]=a),this.safeValue(t,"asks")!==void 0){const c=this.parseOrderBook(t,i,r,"bids","asks","price","volume","id");a.reset(c)}else this.handleDelta(a,t),a.timestamp=r,a.datetime=this.iso8601(r);const d=this.safeInteger(t,"sequence");a.nonce=d,e.resolve(a,n)}parseOrderBook(e,t,s=void 0,i="bids",n="asks",r=0,a=1,o=void 0){const d=this.parseBidsAsks(this.safeValue(e,i,[]),r,a,o),c=this.parseBidsAsks(this.safeValue(e,n,[]),r,a,o);return{symbol:t,bids:this.sortBy(d,0,!0),asks:this.sortBy(c,0),timestamp:s,datetime:this.iso8601(s),nonce:void 0}}parseBidsAsks(e,t=0,s=1,i=void 0){e=this.toArray(e);const n=[];for(let r=0;r<e.length;r++)n.push(this.parseBidAsk(e[r],t,s,i));return n}parseBidAsk(e,t=0,s=1,i=void 0){const n=this.safeNumber(e,t),r=this.safeNumber(e,s),a=[n,r];if(i!==void 0){const o=this.safeString(e,i);a.push(o)}return a}handleDelta(e,t){const s=this.safeValue(t,"create_update"),i=e.asks,n=e.bids;if(s!==void 0){const a=this.parseBidAsk(s,"price","volume","order_id"),o=this.safeString(s,"type");o==="ASK"?i.storeArray(a):o==="BID"&&n.storeArray(a)}const r=this.safeValue(t,"delete_update");if(r!==void 0){const a=this.safeString(r,"order_id");i.storeArray(0,0,a),n.storeArray(0,0,a)}return t}handleMessage(e,t){if(t==="")return;const s=Object.values(e.subscriptions),i=[this.handleOrderBook,this.handleTrades];for(let n=0;n<i.length;n++)i[n].call(this,e,t,s[0]);return t}};const VW=tC,{AuthenticationError:wO,BadSymbol:qW,BadRequest:LW,NotSupported:Dg}=de,{ArrayCache:RW,ArrayCacheBySymbolById:kO,ArrayCacheByTimestamp:FW}=rt;var DW=class extends VW{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0},urls:{api:{ws:{spot:"wss://wbs.mexc.com/raw/ws",swap:"wss://contract.mexc.com/ws"}}},options:{timeframes:{"1m":"Min1","5m":"Min5","15m":"Min15","30m":"Min30","1h":"Min60","4h":"Hour4","8h":"Hour8","1d":"Day1","1w":"Week1","1M":"Month1"}},streaming:{ping:this.ping,keepAlive:1e4},exceptions:{ws:{exact:{"signature validation failed":wO},broad:{"Contract not exists":qW}}}})}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i="sub.ticker",n="ticker:"+e,r={symbol:s.id};if(s.type==="spot")throw new Dg(this.id+" watchTicker does not support spot markets");return await this.watchSwapPublic(n,i,r,t)}handleTicker(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(t,"symbol"),n=this.safeMarket(i),r=n.symbol,a=this.parseTicker(s,n);this.tickers[r]=a;const o="ticker:"+r;return e.resolve(a,o),t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e),a={};e=r.symbol;const o=r.type,d=this.safeValue(this.options,"timeframes",{}),c=this.safeString(d,t),u="sub.kline",h="kline:"+c+":"+e;a.symbol=r.id,a.interval=c,s!==void 0&&(a.start=s);let l;return o==="spot"?l=await this.watchSpotPublic(h,u,a,n):l=await this.watchSwapPublic(h,u,a,n),this.newUpdates&&(i=l.getLimit(e,i)),this.filterBySinceLimit(l,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"symbol"),i=this.safeMarket(s),n=i.symbol,r=this.safeValue(t,"data",{}),a=this.safeString(r,"interval"),o="kline:"+a+":"+n,d=this.safeValue(this.options,"timeframes",{}),c=this.findTimeframe(a,d),u=this.parseWsOHLCV(r,i);this.ohlcvs[n]=this.safeValue(this.ohlcvs,n,{});let h=this.safeValue(this.ohlcvs[n],c);if(h===void 0){const l=this.safeInteger(this.options,"OHLCVLimit",1e3);h=new FW(l),this.ohlcvs[n][c]=h}return h.append(u),e.resolve(h,o),t}parseWsOHLCV(e,t=void 0){return[this.safeIntegerProduct(e,"t",1e3),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber2(e,"v","q")]}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n="orderbook:"+e,r={symbol:i.id};if(t!==void 0){if(t!==5&&t!==10&&t!==20)throw new LW(this.id+" watchOrderBook limit parameter cannot be different from 5, 10 or 20")}else t=20;let a;if(i.type==="swap"){const o="sub.depth";r.compress=!0,r.limit=t,a=await this.watchSwapPublic(n,o,r,s)}else{const o="sub.limit.depth";r.depth=t,a=await this.watchSpotPublic(n,o,r,s)}return a.limit()}handleOrderBook(e,t){const s=this.safeString(t,"symbol"),i=this.safeMarket(s),n=i.symbol,r=this.safeValue(t,"data"),a=this.safeInteger(t,"ts"),o=this.parseOrderBook(r,n,a);let d=this.safeNumber(r,"end");d===void 0&&(d=this.safeNumber(t,"version")),o.nonce=d;let c=this.safeValue(this.orderbooks,n);c===void 0?(c=this.orderBook(o),this.orderbooks[n]=c):i.type==="spot"?c.reset(o):this.handleOrderBookMessage(e,t,c);const u="orderbook:"+n;e.resolve(c,u)}handleOrderBookMessage(e,t,s){const i=this.safeValue(t,"data",{}),n=this.safeNumber(i,"end"),r=this.safeValue(i,"asks",[]),a=this.safeValue(i,"bids",[]);this.handleDeltas(s.asks,r),this.handleDeltas(s.bids,a);const o=this.safeInteger(t,"ts"),d=this.safeString(t,"symbol"),c=this.safeSymbol(d);return s.nonce=n,s.symbol=c,s.timestamp=o,s.datetime=this.iso8601(o),s}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="sub.deal",a="trades:"+e,o={symbol:n.id};let d;return n.type==="spot"?d=await this.watchSpotPublic(a,r,o,i):d=await this.watchSwapPublic(a,r,o,i),this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySinceLimit(d,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeString(t,"symbol"),i=this.safeMarket(s),n=i.symbol;let r=this.safeValue(this.trades,n);if(r===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);r=new RW(c),this.trades[n]=r}const a=this.safeValue(t,"data",{});let o;"deals"in a?o=this.safeValue(a,"deals",[]):o=[a];for(let c=0;c<o.length;c++){const u=this.parseWsTrade(o[c],i);r.append(u)}const d="trades:"+n;e.resolve(r,d)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n="trade",r;e!==void 0&&(r=this.market(e),e=r.symbol,n+=":"+r.symbol);let a;[a,i]=this.handleMarketTypeAndParams("watchMyTrades",r,i);let o;if(a==="spot")throw new Dg(this.id+" watchMyTrades does not support spot markets");return o=await this.watchSwapPrivate(n,i),this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleMyTrade(e,t,s=void 0){const i=this.safeValue(t,"data",{}),n=this.safeString(i,"symbol"),r=this.safeMarket(n),a=this.parseWsTrade(i,r);if(this.myTrades===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new kO(c)}const o=this.myTrades;o.append(a);let d="trade";e.resolve(o,d),d+=":"+r.symbol,e.resolve(o,d)}parseWsTrade(e,t=void 0){const s=this.safeInteger2(e,"timestamp","t"),i=this.safeString(e,"symbol");t=this.safeMarket(i,t,"_");const n=t.symbol,r=this.safeString2(e,"price","p");let a=this.safeString2(e,"vol","q");a===void 0&&(a=this.safeString(e,"v"));let o=this.safeString(e,"T"),d;o===void 0?(o=this.safeString(e,"side"),d=this.parseSwapSide(o)):d=o==="1"?"buy":"sell";let c=this.safeString(e,"id");c===void 0&&(c=s.toString()+"-"+t.id+"-"+a);const u=this.safeString(e,"fee");let h;if(u!==void 0){const g=this.safeString(e,"feeCurrency"),y=this.safeCurrencyCode(g);h={cost:u,currency:y}}const l=this.safeString(e,"orderId"),m=this.safeValue(e,"taker",!0)?"taker":"maker";return this.safeTrade({info:e,id:c,order:l,timestamp:s,datetime:this.iso8601(s),symbol:n,type:void 0,side:d,takerOrMaker:m,price:r,amount:a,cost:void 0,fee:h},t)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n="order",r;e!==void 0&&(r=this.market(e),e=r.symbol,n+=":"+r.symbol);let a;[a,i]=this.handleMarketTypeAndParams("watchOrders",r,i);let o;return a==="spot"?o=await this.watchSpotPrivate(n,i):o=await this.watchSwapPrivate(n,i),this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleOrder(e,t,s=void 0){const i=this.safeValue(t,"data",{});let n=this.safeString(t,"symbol");n===void 0&&(n=this.safeString(i,"symbol"));const r=this.safeMarket(n),a=this.parseWSOrder(i,r);if(this.orders===void 0){const c=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new kO(c)}const o=this.orders;o.append(a);let d="order";e.resolve(o,d),d+=":"+r.symbol,e.resolve(o,d)}parseWSOrder(e,t=void 0){const s=this.safeString2(e,"orderId","id"),i=this.safeString2(e,"state","status"),n=this.safeInteger(e,"createTime"),r=this.safeString(e,"price"),a=this.safeString2(e,"quantity","vol"),o=this.safeString(e,"remainQuantity"),d=this.safeString(e,"dealVol"),c=this.safeString(e,"amount"),u=this.safeString(e,"dealAvgPrice"),h=this.safeString2(e,"symbol","symbolDisplay"),l=this.safeSymbol(h,t,"_"),p=this.safeString(e,"side");let m=this.parseSwapSide(p);if(m===void 0){const T=this.safeStringLower(e,"tradeType");T==="ask"||T==="2"?m="sell":T==="bid"||T==="1"?m="buy":m=T}const g=this.parseWsOrderStatus(i,t);let y=this.safeString2(e,"client_order_id","orderId");y===""&&(y=void 0);const b=this.safeString(e,"orderType"),k=b==="3"||b==="5"?"market":"limit";return this.safeOrder({id:s,clientOrderId:y,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:this.safeInteger(e,"updateTime"),status:g,symbol:l,type:k,timeInForce:void 0,side:m,price:r,stopPrice:void 0,average:u,amount:a,cost:c,filled:d,remaining:o,fee:void 0,trades:void 0,info:e},t)}parseSwapSide(e){const t={1:"open long",2:"close short",3:"open short",4:"close long"};return this.safeString(t,e)}parseWsOrderStatus(e,t=void 0){let s={};return t.type==="spot"?s={1:"open",2:"closed",3:"open",4:"canceled",5:"open",NEW:"open",FILLED:"closed",PARTIALLY_FILLED:"open",CANCELED:"canceled",PARTIALLY_CANCELED:"canceled"}:s={2:"open",3:"closed",4:"canceled"},this.safeString(s,e,e)}async watchBalance(e={}){await this.loadMarkets();const t="balance";let s;if([s,e]=this.handleMarketTypeAndParams("watchBalance",void 0,e),s==="spot")throw new Dg(this.id+" watchBalance does not support spot markets");return this.watchSwapPrivate(t,e)}handleBalance(e,t){const s=this.safeValue(t,"data"),i=this.safeString(s,"currency"),n=this.safeCurrencyCode(i),r=this.account();r.free=this.safeString(s,"availableBalance"),r.used=this.safeString(s,"frozenBalance"),this.balance[n]=r,this.balance=this.safeBalance(this.balance);const a="balance";e.resolve(this.balance,a)}async watchSwapPublic(e,t,s,i={}){const n=this.urls.api.ws.swap,r={method:t,param:s},a=this.extend(r,i);return await this.watch(n,e,a,e)}async watchSpotPublic(e,t,s,i={}){const n=this.urls.api.ws.spot,r={op:t},a=this.extend(r,s),o=this.extend(a,i);return await this.watch(n,e,o,e)}async watchSpotPrivate(e,t={}){this.checkRequiredCredentials();const s="sub.personal",i=this.urls.api.ws.spot,n=this.milliseconds().toString(),r={op:s,api_key:this.apiKey,req_time:n},a=this.keysort(r);a.api_secret=this.secret;const o=this.urlencode(a),d=this.hash(this.encode(o),"md5");r.sign=d;const c=this.extend(r,t);return await this.watch(i,e,c,s)}async watchSwapPrivate(e,t={}){this.checkRequiredCredentials();const s="login",i=this.urls.api.ws.swap,n=this.milliseconds().toString(),r=this.apiKey+n,a=this.hmac(this.encode(r),this.encode(this.secret),"sha256"),o={method:s,param:{apiKey:this.apiKey,signature:a,reqTime:n}},d=this.extend(o,t),c=this.extend(d,t);return await this.watch(i,e,c,s)}handleErrorMessage(e,t){const s=this.safeString(t,"channel");try{const i=this.id+" "+this.json(t);if(s.indexOf("error")>=0){const n=this.safeValue(t,"data");typeof n=="string"&&(this.throwExactlyMatchedException(this.exceptions.ws.exact,n,i),this.throwBroadlyMatchedException(this.exceptions.ws.broad,n,i))}if(s==="sub.personal"){const n=this.safeString(t,"msg");this.throwExactlyMatchedException(this.exceptions.ws.exact,n,i)}}catch(i){if(i instanceof wO)return!1}return t}handleAuthenticate(e,t){return t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;if(t==="pong"){this.handlePong(e,t);return}const s=this.safeString(t,"channel"),i={pong:this.handlePong,"rs.login":this.handleAuthenticate,"push.deal":this.handleTrades,orderbook:this.handleOrderBook,"push.kline":this.handleOHLCV,"push.ticker":this.handleTicker,"push.depth":this.handleOrderBook,"push.limit.depth":this.handleOrderBook,"push.personal.order":this.handleOrder,"push.personal.trigger.order":this.handleOrder,"push.personal.plan.order":this.handleOrder,"push.personal.order.deal":this.handleMyTrade,"push.personal.asset":this.handleBalance},n=this.safeValue(i,s);n!==void 0&&n.call(this,e,t)}ping(e){return this.safeString(this.options,"defaultType","spot")==="spot"?"ping":{method:"ping"}}handlePong(e,t){return e.lastPong=this.milliseconds(),t}};const HW=jl,{ArrayCache:GW}=rt;var mC=class extends HW{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTrades:!0,watchTicker:!0,watchOHLCV:!0},urls:{test:{ws:"wss://ndaxmarginstaging.cdnhop.net:10456/WSAdminGatewa/"},api:{ws:"wss://api.ndax.io/WSGateway"}}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}async watchTicker(e,t={}){const s=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const i=this.market(e),n="SubscribeLevel1",r=n+":"+i.id,a=this.urls.api.ws,o=this.requestId(),d={OMSId:s,InstrumentId:parseInt(i.id)},c={m:0,i:o,n,o:this.json(d)},u=this.extend(c,t);return await this.watch(a,r,u,r)}handleTicker(e,t){const s=this.safeValue(t,"o",{}),i=this.parseTicker(s),n=i.symbol,r=this.market(n);this.tickers[n]=i;const o="SubscribeLevel1"+":"+r.id;e.resolve(i,o)}async watchTrades(e,t=void 0,s=void 0,i={}){const n=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const r=this.market(e);e=r.symbol;const a="SubscribeTrades",o=a+":"+r.id,d=this.urls.api.ws,c=this.requestId(),u={OMSId:n,InstrumentId:parseInt(r.id),IncludeLastCount:100},h={m:0,i:c,n:a,o:this.json(u)},l=this.extend(h,i),p=await this.watch(d,o,l,o);return this.newUpdates&&(s=p.getLimit(e,s)),this.filterBySinceLimit(p,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"o",[]),i="SubscribeTrades",n={};for(let a=0;a<s.length;a++){const o=this.parseTrade(s[a]),d=o.symbol;let c=this.safeValue(this.trades,d);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new GW(u)}c.append(o),this.trades[d]=c,n[d]=!0}const r=Object.keys(n);for(let a=0;a<r.length;a++){const o=r[a],d=this.market(o),c=i+":"+d.id,u=this.safeValue(this.trades,o);e.resolve(u,c)}}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){const r=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const a=this.market(e);e=a.symbol;const o="SubscribeTicker",d=o+":"+t+":"+a.id,c=this.urls.api.ws,u=this.requestId(),h={OMSId:r,InstrumentId:parseInt(a.id),Interval:parseInt(this.timeframes[t]),IncludeLastCount:100},l={m:0,i:u,n:o,o:this.json(h)},p=this.extend(l,n),m=await this.watch(c,d,p,d);return this.newUpdates&&(i=m.getLimit(e,i)),this.filterBySinceLimit(m,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"o",[]),i={};for(let a=0;a<s.length;a++){const o=s[a],d=this.safeString(o,8),u=this.safeMarket(d).symbol;i[d]={},this.ohlcvs[u]=this.safeValue(this.ohlcvs,u,{});const h=Object.keys(this.timeframes);for(let l=0;l<h.length;l++){const p=h[l],m=this.timeframes[p],g=parseInt(m)*1e3,y=this.safeInteger(o,0),b=[parseInt(y/g)*g,this.safeFloat(o,3),this.safeFloat(o,1),this.safeFloat(o,2),this.safeFloat(o,4),this.safeFloat(o,5)],w=this.safeValue(this.ohlcvs[u],p,[]),k=w.length;if(k&&b[0]===w[k-1][0]){const T=w[k-1];w[k-1]=[b[0],T[1],Math.max(b[1],T[1]),Math.min(b[2],T[2]),b[4],this.sum(b[5],T[5])],i[d][p]=!0}else{if(k&&b[0]<w[k-1][0])continue;{w.push(b);const T=this.safeInteger(this.options,"OHLCVLimit",1e3);k>=T&&w.shift(),i[d][p]=!0}}this.ohlcvs[u][p]=w}}const n="SubscribeTicker",r=Object.keys(i);for(let a=0;a<r.length;a++){const o=r[a],d=Object.keys(i[o]);for(let c=0;c<d.length;c++){const u=d[c],h=n+":"+u+":"+o,p=this.safeMarket(o).symbol,m=this.safeValue(this.ohlcvs[p],u,[]);e.resolve(m,h)}}}async watchOrderBook(e,t=void 0,s={}){const i=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="SubscribeLevel2",a=r+":"+n.id,o=this.urls.api.ws,d=this.requestId();t=t===void 0?100:t;const c={OMSId:i,InstrumentId:parseInt(n.id),Depth:t},u={m:0,i:d,n:r,o:this.json(c)},h={id:d,messageHash:a,name:r,symbol:e,marketId:n.id,method:this.handleOrderBookSubscription,limit:t,params:s},l=this.extend(u,s);return(await this.watch(o,a,l,a,h)).limit()}handleOrderBook(e,t){const s=this.safeValue(t,"o",[]),i=this.safeValue(s,0,[]),n=this.safeString(i,7);if(n===void 0)return t;const a=this.safeMarket(n).symbol,o=this.safeValue(this.orderbooks,a);if(o===void 0)return t;let d,c;for(let l=0;l<s.length;l++){const p=s[l];if(d===void 0)d=this.safeInteger(p,2);else{const k=this.safeInteger(p,2);d=Math.max(d,k)}if(c===void 0)c=this.safeInteger(p,0);else{const k=this.safeInteger(p,0);c=Math.max(c,k)}const m=this.safeInteger(p,3),g=this.safeFloat(p,6),y=this.safeFloat(p,8),w=this.safeInteger(p,9)===0?o.bids:o.asks;m===0||m===1?w.store(g,y):m===2&&w.store(g,0)}o.nonce=c,o.timestamp=d,o.datetime=this.iso8601(d);const h="SubscribeLevel2"+":"+n;this.orderbooks[a]=o,e.resolve(o,h)}handleOrderBookSubscription(e,t,s){const i=this.safeValue(t,"o",[]),n=this.safeString(s,"symbol"),r=this.parseOrderBook(i,n),a=this.safeInteger(s,"limit"),o=this.orderBook(r,a);this.orderbooks[n]=o;const d=this.safeString(s,"messageHash");e.resolve(o,d)}handleSubscriptionStatus(e,t){const s=this.indexBy(e.subscriptions,"id"),i=this.safeInteger(t,"i"),n=this.safeValue(s,i);if(n!==void 0){const r=this.safeValue(n,"method");return r===void 0?t:r.call(this,e,t,n)}}handleMessage(e,t){const s=this.safeString(t,"o");if(s===void 0)return t;t.o=JSON.parse(s);const i={SubscribeLevel2:this.handleSubscriptionStatus,SubscribeLevel1:this.handleTicker,Level2UpdateEvent:this.handleOrderBook,Level1UpdateEvent:this.handleTicker,SubscribeTrades:this.handleTrades,TradeDataUpdateEvent:this.handleTrades,SubscribeTicker:this.handleOHLCV,TickerDataUpdateEvent:this.handleOHLCV},n=this.safeString(t,"n"),r=this.safeValue(i,n);return r===void 0?t:r.call(this,e,t)}};const UW=sC,{ArgumentsRequired:tu,AuthenticationError:$W}=de,{ArrayCache:jW,ArrayCacheByTimestamp:WW,ArrayCacheBySymbolById:zW}=rt;var KW=class extends UW{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchTickers:!1,watchOrderBook:!0,watchOrders:!0,watchTrades:!0,watchBalance:!0,watchOHLCV:!0},urls:{api:{ws:"wss://real.okcoin.com:8443/ws/v3"},logo:"https://user-images.githubusercontent.com/1294454/27766791-89ffb502-5ee5-11e7-8a5b-c5950b68ac65.jpg",www:"https://www.okcoin.com",doc:"https://www.okcoin.com/docs/en/",fees:"https://www.okcoin.com/coin-fees",referral:"https://www.okcoin.com/account/register?flag=activity&channelId=600001513"},options:{fetchMarkets:["spot"],watchOrders:"order",watchOrderBook:{limit:400,type:"spot",depth:"depth_l2_tbt"},watchBalance:"spot",ws:{inflate:!0}},streaming:{ping:this.ping,keepAlive:2e4}})}async subscribe(e,t,s={}){await this.loadMarkets();const i=this.market(t),n=this.urls.api.ws,r=i.type+"/"+e+":"+i.id,a={op:"subscribe",args:[r]};return await this.watch(n,r,this.deepExtend(a,s),r)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.subscribe("trade",e,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate(),e!==void 0&&(e=this.symbol(e));const n=this.safeString(this.options,"watchOrders","order"),r=await this.subscribe(n,e,i);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySinceLimit(r,t,s,"timestamp",!0)}handleOrders(e,t,s=void 0){const i=this.safeString(t,"table"),n=this.safeValue(t,"data",[]);if(n.length>0){const a=this.safeInteger(this.options,"ordersLimit",1e3);this.orders===void 0&&(this.orders=new zW(a));const o=this.orders,d={},c=this.parseOrders(n);for(let h=0;h<c.length;h++){const l=c[h];o.append(l);const p=l.symbol,m=this.market(p);d[m.id]=!0}const u=Object.keys(d);for(let h=0;h<u.length;h++){const l=i+":"+u[h];e.resolve(this.orders,l)}}}async watchTicker(e,t={}){return await this.subscribe("ticker",e,t)}handleTrade(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]),n=this.safeInteger(this.options,"tradesLimit",1e3);for(let r=0;r<i.length;r++){const a=this.parseTrade(i[r]),o=a.symbol,d=this.safeString(a.info,"instrument_id"),c=s+":"+d;let u=this.safeValue(this.trades,o);u===void 0&&(u=new jW(n),this.trades[o]=u),u.append(a),e.resolve(u,c)}return t}handleTicker(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]);for(let n=0;n<i.length;n++){const r=this.parseTicker(i[n]),a=r.symbol,o=this.safeString(r.info,"instrument_id"),d=s+":"+o;this.tickers[a]=r,e.resolve(r,d)}return t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets(),e=this.symbol(e);const a="candle"+this.timeframes[t]+"s",o=await this.subscribe(a,e,n);return this.newUpdates&&(i=o.getLimit(e,i)),this.filterBySinceLimit(o,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]),n=s.split("/");let a=this.safeString(n,1).replace("candle","");a=a.replace("s","");const o=this.findTimeframe(a);for(let d=0;d<i.length;d++){const c=this.safeString(i[d],"instrument_id"),u=this.safeValue(i[d],"candle"),h=this.safeMarket(c),l=h.symbol,p=this.parseOHLCV(u,h);this.ohlcvs[l]=this.safeValue(this.ohlcvs,l,{});let m=this.safeValue(this.ohlcvs[l],o);if(m===void 0){const y=this.safeInteger(this.options,"OHLCVLimit",1e3);m=new WW(y),this.ohlcvs[l][o]=m}m.append(p);const g=s+":"+c;e.resolve(m,g)}}async watchOrderBook(e,t=void 0,s={}){const i=this.safeValue(this.options,"watchOrderBook",{}),n=this.safeString(i,"depth","depth_l2_tbt");return(await this.subscribe(n,e,s)).limit()}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s){const i=this.safeValue(t,"asks",[]),n=this.safeValue(t,"bids",[]);this.handleDeltas(s.asks,i),this.handleDeltas(s.bids,n);const r=this.parse8601(this.safeString(t,"timestamp"));return s.timestamp=r,s.datetime=this.iso8601(r),s}handleOrderBook(e,t){const s=this.safeString(t,"action"),i=this.safeValue(t,"data",[]),n=this.safeString(t,"table");if(s==="partial")for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"instrument_id"),c=this.safeMarket(o).symbol,u=this.safeValue(this.options,"watchOrderBook",{}),h=this.safeInteger(u,"limit",400),l=this.orderBook({},h);this.orderbooks[c]=l,this.handleOrderBookMessage(e,a,l);const p=n+":"+o;e.resolve(l,p)}else for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"instrument_id"),c=this.safeMarket(o).symbol;if(c in this.orderbooks){const u=this.orderbooks[c];this.handleOrderBookMessage(e,a,u);const h=n+":"+o;e.resolve(u,h)}}return t}async authenticate(e={}){this.checkRequiredCredentials();const t=this.urls.api.ws,s="login",i=this.client(t);let n=this.safeValue(i.subscriptions,s);if(n===void 0){n=i.future("authenticated");const r=this.seconds().toString(),a="GET",o="/users/self/verify",d=r+a+o,c=this.hmac(this.encode(d),this.encode(this.secret),"sha256","base64"),u={op:s,args:[this.apiKey,this.password,r,c]};this.spawn(this.watch,t,s,u,s,n)}return await n}async watchBalance(e={}){const t=this.safeString2(this.options,"watchBalance","defaultType");if(this.safeString(e,"type",t)===void 0)throw new tu(this.id+" watchBalance requires a type parameter (one of 'spot', 'margin', 'futures', 'swap')");const i=await this.authenticate();return await this.subscribeToUserAccount(i,e)}async subscribeToUserAccount(e,t={}){const s=this.safeString2(this.options,"watchBalance","defaultType"),i=this.safeString(t,"type",s);if(i===void 0)throw new tu(this.id+" watchBalance requires a type parameter (one of 'spot', 'margin', 'futures', 'swap')");await this.loadMarkets();const n=this.safeString(t,"currency"),r=this.safeString(t,"code",this.safeCurrencyCode(n));let a;r!==void 0&&(a=this.currency(r));const o=this.safeString(t,"instrument_id"),d=this.safeString(t,"symbol");let c;d!==void 0?c=this.market(d):o!==void 0&&o in this.markets_by_id&&(c=this.markets_by_id[o]);const u=c===void 0,h=a===void 0;if(i==="spot"){if(h)throw new tu(this.id+" watchBalance requires a 'currency' (id) or a unified 'code' parameter for "+i+" accounts")}else if(i==="margin"||i==="swap"||i==="option"){if(u)throw new tu(this.id+" watchBalance requires a 'instrument_id' (id) or a unified 'symbol' parameter for "+i+" accounts")}else if(i==="futures"&&h&&u)throw new tu(this.id+" watchBalance requires a 'currency' (id), or unified 'code', or 'instrument_id' (id), or unified 'symbol' parameter for "+i+" accounts");let l;h?u||(l=c.id):l=a.id;const p=i==="margin"?"spot":i,m=i==="margin"?"margin_account":"account",g=p+"/"+m,y=g+":"+l,b=this.urls.api.ws,w={op:"subscribe",args:[y]},k=this.omit(t,["currency","code","instrument_id","symbol","type"]);return await this.watch(b,g,this.deepExtend(w,k),y)}handleBalance(e,t){const s=this.safeString(t,"table"),i=s.split("/");let n=this.safeString(i,0);n==="spot"&&this.safeString(i,1)==="margin_account"&&(n="margin");const r=this.safeValue(t,"data",[]);for(let a=0;a<r.length;a++){const o=this.parseBalanceByType(n,r),d=this.safeValue(this.balance,n,{}),c=this.deepExtend(d,o);this.balance[n]=this.safeBalance(c),e.resolve(this.balance[n],s)}}handleSubscriptionStatus(e,t){return t}handleAuthenticate(e,t){return e.resolve(t,"authenticated"),t}ping(e){return"ping"}handlePong(e,t){return e.lastPong=this.milliseconds(),t}handleErrorMessage(e,t){const s=this.safeString(t,"errorCode");try{if(s!==void 0){const i=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,i);const n=this.safeValue(t,"message");n!==void 0&&this.throwBroadlyMatchedException(this.exceptions.broad,n,i)}}catch(i){if(i instanceof $W){e.reject(i,"authenticated");const n="login";return n in e.subscriptions&&delete e.subscriptions[n],!1}}return t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;if(t==="pong")return this.handlePong(e,t);const s=this.safeString(t,"table");if(s===void 0){const i=this.safeString(t,"event");if(i!==void 0){const n={login:this.handleAuthenticate,subscribe:this.handleSubscriptionStatus},r=this.safeValue(n,i);return r===void 0?t:r.call(this,e,t)}}else{const i=s.split("/"),n=this.safeString(i,1),r={depth:this.handleOrderBook,depth5:this.handleOrderBook,depth_l2_tbt:this.handleOrderBook,ticker:this.handleTicker,trade:this.handleTrade,account:this.handleBalance,margin_account:this.handleBalance,order:this.handleOrders};let a=this.safeValue(r,n);return n.indexOf("candle")>=0&&(a=this.handleOHLCV),a===void 0?t:a.call(this,e,t)}}};const XW=Eb,{AuthenticationError:YW,InvalidNonce:QW}=de,{ArrayCache:ZW,ArrayCacheByTimestamp:JW,ArrayCacheBySymbolById:ez}=rt;var gC=class extends XW{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchOrderBook:!0,watchTrades:!0,watchBalance:!0,watchOHLCV:!0,watchOrders:!0},urls:{api:{ws:{public:"wss://ws.okx.com:8443/ws/v5/public",private:"wss://ws.okx.com:8443/ws/v5/private"}},test:{ws:{public:"wss://wspap.okx.com:8443/ws/v5/public?brokerId=9999",private:"wss://wspap.okx.com:8443/ws/v5/private?brokerId=9999"}}},options:{watchOrderBook:{depth:"books"},watchBalance:"spot",ws:{},checksum:!0},streaming:{ping:this.ping,keepAlive:2e4}})}async subscribe(e,t,s,i={}){await this.loadMarkets();const n=this.urls.api.ws[e];let r=t;const a={channel:t};if(s!==void 0){const d=this.market(s);r+=":"+d.id,a.instId=d.id}const o={op:"subscribe",args:[this.deepExtend(a,i)]};return await this.watch(n,r,o,r)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.subscribe("public","trades",e,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"arg",{}),i=this.safeString(s,"channel"),n=this.safeValue(t,"data",[]),r=this.safeInteger(this.options,"tradesLimit",1e3);for(let a=0;a<n.length;a++){const o=this.parseTrade(n[a]),d=o.symbol,c=this.safeString(o.info,"instId"),u=i+":"+c;let h=this.safeValue(this.trades,d);h===void 0&&(h=new ZW(r),this.trades[d]=h),h.append(o),e.resolve(h,u)}return t}async watchTicker(e,t={}){return await this.subscribe("public","tickers",e,t)}handleTicker(e,t){const s=this.safeValue(t,"arg",{}),i=this.safeString(s,"channel"),n=this.safeValue(t,"data",[]);for(let r=0;r<n.length;r++){const a=this.parseTicker(n[r]),o=a.symbol,d=this.safeString(a.info,"instId"),c=i+":"+d;this.tickers[o]=a,e.resolve(a,c)}return t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets(),e=this.symbol(e);const a="candle"+this.timeframes[t],o=await this.subscribe("public",a,e,n);return this.newUpdates&&(i=o.getLimit(e,i)),this.filterBySinceLimit(o,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"arg",{}),i=this.safeString(s,"channel"),n=this.safeValue(t,"data",[]),r=this.safeString(s,"instId"),a=this.safeMarket(r),o=a.id,d=i.replace("candle",""),c=this.findTimeframe(d);for(let u=0;u<n.length;u++){const h=this.parseOHLCV(n[u],a);this.ohlcvs[o]=this.safeValue(this.ohlcvs,o,{});let l=this.safeValue(this.ohlcvs[o],c);if(l===void 0){const m=this.safeInteger(this.options,"OHLCVLimit",1e3);l=new JW(m),this.ohlcvs[o][c]=l}l.append(h);const p=i+":"+r;e.resolve(l,p)}}async watchOrderBook(e,t=void 0,s={}){const i=this.safeValue(this.options,"watchOrderBook",{}),n=this.safeString(i,"depth","books");return(await this.subscribe("public",n,e,s)).limit()}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s,i){const n=this.safeValue(t,"asks",[]),r=this.safeValue(t,"bids",[]),a=s.asks,o=s.bids;if(this.handleDeltas(a,n),this.handleDeltas(o,r),this.safeValue(this.options,"checksum",!0)){const u=a.length,h=o.length,l=[];for(let y=0;y<25;y++)y<h&&(l.push(this.numberToString(o[y][0])),l.push(this.numberToString(o[y][1]))),y<u&&(l.push(this.numberToString(a[y][0])),l.push(this.numberToString(a[y][1])));const p=l.join(":"),m=this.safeInteger(t,"checksum"),g=this.crc32(p,!0);if(m!==g){const y=new QW(this.id+" invalid checksum");e.reject(y,i)}}const c=this.safeInteger(t,"ts");return s.timestamp=c,s.datetime=this.iso8601(c),s}handleOrderBook(e,t){const s=this.safeValue(t,"arg",{}),i=this.safeString(s,"channel"),n=this.safeString(t,"action"),r=this.safeValue(t,"data",[]),a=this.safeString(s,"instId"),d=this.safeMarket(a).symbol,c={"bbo-tbt":1,books:400,books5:5,"books-l2-tbt":400,"books50-l2-tbt":50},u=this.safeInteger(c,i),h=i+":"+a;if(n==="snapshot")for(let l=0;l<r.length;l++){const p=r[l],m=this.orderBook({},u);this.orderbooks[d]=m,this.handleOrderBookMessage(e,p,m,h),e.resolve(m,h)}else if(n==="update"){if(d in this.orderbooks){const l=this.orderbooks[d];for(let p=0;p<r.length;p++){const m=r[p];this.handleOrderBookMessage(e,m,l,h),e.resolve(l,h)}}}else if(i==="books5"||i==="bbo-tbt"){let l=this.safeValue(this.orderbooks,d);l===void 0&&(l=this.orderBook({},u)),this.orderbooks[d]=l;for(let p=0;p<r.length;p++){const m=r[p],g=this.safeInteger(m,"ts"),y=this.parseOrderBook(m,d,g,"bids","asks",0,1);l.reset(y),e.resolve(l,h)}}return t}async authenticate(e={}){this.checkRequiredCredentials();const t=this.urls.api.ws.private,s="login",i=this.client(t);let n=this.safeValue(i.subscriptions,s);if(n===void 0){n=i.future("authenticated");const r=this.seconds().toString(),a="GET",o="/users/self/verify",d=r+a+o,c=this.hmac(this.encode(d),this.encode(this.secret),"sha256","base64"),u={op:s,args:[{apiKey:this.apiKey,passphrase:this.password,timestamp:r,sign:c}]};this.spawn(this.watch,t,s,u,s,n)}return await n}async watchBalance(e={}){return await this.loadMarkets(),await this.authenticate(),await this.subscribe("private","account",void 0,e)}handleBalance(e,t){const s=this.safeValue(t,"arg",{}),i=this.safeString(s,"channel"),n="spot",r=this.parseTradingBalance(t),a=this.safeValue(this.balance,n,{}),o=this.deepExtend(a,r);this.balance[n]=this.safeBalance(o),e.resolve(this.balance[n],i)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate();const n=this.safeValue(this.options,"watchOrders",{});let r=this.safeString(n,"type","ANY");r=this.safeString(i,"type",r);const a=this.safeValue(i,"stop",!1);i=this.omit(i,["type","stop"]);let o;e!==void 0&&(o=this.market(e),e=o.symbol,r=o.type),r==="future"&&(r="futures");const c={instType:r.toUpperCase()},u=a?"orders-algo":"orders",h=await this.subscribe("private",u,e,this.extend(c,i));return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySymbolSinceLimit(h,e,t,s,!0)}handleOrders(e,t,s=void 0){const i=this.safeValue(t,"arg",{}),n=this.safeString(i,"channel"),r=this.safeValue(t,"data",[]);if(r.length>0){const o=this.safeInteger(this.options,"ordersLimit",1e3);this.orders===void 0&&(this.orders=new ez(o));const d=this.orders,c=[],u=this.parseOrders(r);for(let h=0;h<u.length;h++){const l=u[h];d.append(l);const p=l.symbol,m=this.market(p);c.push(m.id)}e.resolve(this.orders,n);for(let h=0;h<c.length;h++){const l=n+":"+c[h];e.resolve(this.orders,l)}}}handleSubscriptionStatus(e,t){return t}handleAuthenticate(e,t){return e.resolve(t,"authenticated"),t}ping(e){return"ping"}handlePong(e,t){return e.lastPong=this.milliseconds(),t}handleErrorMessage(e,t){const s=this.safeString(t,"errorCode");try{if(s!==void 0){const i=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,i);const n=this.safeValue(t,"message");n!==void 0&&this.throwBroadlyMatchedException(this.exceptions.broad,n,i)}}catch(i){if(i instanceof YW){e.reject(i,"authenticated");const n="login";return n in e.subscriptions&&delete e.subscriptions[n],!1}}return t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;if(t==="pong")return this.handlePong(e,t);const s=this.safeString(t,"event");if(s!==void 0){const i={login:this.handleAuthenticate,subscribe:this.handleSubscriptionStatus},n=this.safeValue(i,s);return n===void 0?t:n.call(this,e,t)}else{const i=this.safeValue(t,"arg",{}),n=this.safeString(i,"channel"),r={"bbo-tbt":this.handleOrderBook,books:this.handleOrderBook,books5:this.handleOrderBook,"books50-l2-tbt":this.handleOrderBook,"books-l2-tbt":this.handleOrderBook,tickers:this.handleTicker,trades:this.handleTrades,account:this.handleBalance,orders:this.handleOrders,"orders-algo":this.handleOrders},a=this.safeValue(r,n);if(a===void 0)if(n.indexOf("candle")===0)this.handleOHLCV(e,t);else return t;else return a.call(this,e,t)}}};const tz=gC;var sz=class extends tz{describe(){return this.deepExtend(super.describe(),{alias:!0,id:"okex"})}};const iz=nC,fa=Se,{ArrayCache:nz,ArrayCacheByTimestamp:rz,ArrayCacheBySymbolById:SO}=rt;var az=class extends iz{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchMyTrades:!0,watchOrders:!0,watchOrderBook:!0,watchOHLCV:!0},urls:{test:{ws:"wss://testnet.phemex.com/ws"},api:{ws:"wss://phemex.com/ws"}},options:{tradesLimit:1e3,OHLCVLimit:1e3},streaming:{keepAlive:2e4}})}fromEn(e,t){if(e===void 0)return;const s=new fa(e);return s.decimals=this.sum(s.decimals,t),s.reduce(),s.toString()}fromEp(e,t=void 0){return e===void 0||t===void 0?e:this.fromEn(e,this.safeInteger(t,"priceScale"))}fromEv(e,t=void 0){return e===void 0||t===void 0?e:this.fromEn(e,this.safeInteger(t,"valueScale"))}fromEr(e,t=void 0){return e===void 0||t===void 0?e:this.fromEn(e,this.safeInteger(t,"ratioScale"))}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}parseSwapTicker(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=t.symbol,n=this.safeIntegerProduct(e,"timestamp",1e-6),r=this.fromEp(this.safeString(e,"close"),t),a=this.parseNumber(r),o=this.parseNumber(this.fromEv(this.safeString(e,"turnover"),t)),d=this.parseNumber(this.fromEv(this.safeString(e,"volume"),t));let c,u,h;const l=this.omitZero(this.fromEp(this.safeString(e,"open"),t)),p=this.parseNumber(l);return l!==void 0&&r!==void 0&&(c=this.parseNumber(fa.stringSub(r,l)),h=this.parseNumber(fa.stringDiv(fa.stringAdd(r,l),"2")),u=this.parseNumber(fa.stringMul(fa.stringSub(fa.stringDiv(r,l),"1"),"100"))),{symbol:i,timestamp:n,datetime:this.iso8601(n),high:this.parseNumber(this.fromEp(this.safeString(e,"high"),t)),low:this.parseNumber(this.fromEp(this.safeString(e,"low"),t)),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:p,close:a,last:a,previousClose:void 0,change:c,percentage:u,average:h,baseVolume:d,quoteVolume:o,info:e}}handleTicker(e,t){let s="market24h",i=this.safeValue(t,s),n;i===void 0?(s="spot_market24h",i=this.safeValue(t,s),n=this.parseTicker(i)):n=this.parseSwapTicker(i);const r=n.symbol,a=s+":"+r,o=this.safeIntegerProduct(t,"timestamp",1e-6);n.timestamp=o,n.datetime=this.iso8601(o),this.tickers[r]=n,e.resolve(n,a)}async watchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("watchBalance",void 0,e),i=t+":balance";return await this.subscribePrivate(t,i,s)}handleBalance(e,t,s){for(let n=0;n<s.length;n++){const r=s[n],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a),d=this.safeValue(this.currencies,o,{}),c=this.safeInteger(d,"valueScale",8),u=this.account();let h=this.safeString(r,"totalUsedBalanceEv");if(h===void 0){const p=this.safeString(r,"lockedTradingBalanceEv"),m=this.safeString(r,"lockedWithdrawEv");h=fa.stringAdd(p,m)}const l=this.safeString2(r,"accountBalanceEv","balanceEv");u.used=this.fromEn(h,c),u.total=this.fromEn(l,c),this.balance[o]=u,this.balance=this.safeBalance(this.balance)}const i=e+":balance";t.resolve(this.balance,i)}handleTrades(e,t){const s="trade",i=this.safeString(t,"symbol"),n=this.safeMarket(i),r=n.symbol,a=s+":"+r;let o=this.safeValue(this.trades,r);if(o===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);o=new nz(u),this.trades[r]=o}const d=this.safeValue(t,"trades",[]),c=this.parseTrades(d,n);for(let u=0;u<c.length;u++)o.append(c[u]);e.resolve(o,a)}handleOHLCV(e,t){const s="kline",i=this.safeString(t,"symbol"),n=this.safeMarket(i),r=n.symbol,a=this.safeValue(t,s,[]),o=this.safeValue(a,0,[]),d=this.safeString(o,1),c=this.findTimeframe(d);if(c!==void 0){const u=s+":"+c+":"+r,h=this.parseOHLCVs(a,n);this.ohlcvs[r]=this.safeValue(this.ohlcvs,r,{});let l=this.safeValue(this.ohlcvs[r],c);if(l===void 0){const p=this.safeInteger(this.options,"OHLCVLimit",1e3);l=new rz(p),this.ohlcvs[r][c]=l}for(let p=0;p<h.length;p++){const m=h[p];l.append(m)}e.resolve(l,u)}}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i=s.spot?"spot_market24h":"market24h",n=this.urls.api.ws,r=this.requestId(),a=i+".subscribe",o=i+":"+e,d={method:a,id:r,params:[]},c=this.deepExtend(d,t);return await this.watch(n,o,c,a)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r=this.urls.api.ws,a=this.requestId(),o="trade",d=o+":"+e,u={method:o+".subscribe",id:a,params:[n.id]},h=this.deepExtend(u,i),l=await this.watch(r,d,h,d);return this.newUpdates&&(s=l.getLimit(e,s)),this.filterBySinceLimit(l,t,s,"timestamp",!0)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n=this.urls.api.ws,r=this.requestId(),a="orderbook",o=a+":"+e,c={method:a+".subscribe",id:r,params:[i.id]},u=this.deepExtend(c,s);return(await this.watch(n,o,u,o)).limit()}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=this.urls.api.ws,o=this.requestId(),d="kline",c=d+":"+t+":"+e,h={method:d+".subscribe",id:o,params:[r.id,this.safeInteger(this.timeframes,t)]},l=this.deepExtend(h,n),p=await this.watch(a,c,l,c);return this.newUpdates&&(i=p.getLimit(e,i)),this.filterBySinceLimit(p,s,i,0,!0)}handleDelta(e,t,s=void 0){const i=this.parseBidAsk(t,0,1,s);e.storeArray(i)}handleDeltas(e,t,s=void 0){for(let i=0;i<t.length;i++)this.handleDelta(e,t[i],s)}handleOrderBook(e,t){const s=this.safeString(t,"symbol"),i=this.safeMarket(s),n=i.symbol,r=this.safeString(t,"type"),a=this.safeInteger(t,"depth"),d="orderbook"+":"+n,c=this.safeInteger(t,"sequence"),u=this.safeIntegerProduct(t,"timestamp",1e-6);if(r==="snapshot"){const h=this.safeValue(t,"book",{}),l=this.parseOrderBook(h,n,u,"bids","asks",0,1,i);l.nonce=c;const p=this.orderBook(l,a);this.orderbooks[n]=p,e.resolve(p,d)}else{const h=this.safeValue(this.orderbooks,n);if(h!==void 0){const l=this.safeValue(t,"book",{}),p=this.safeValue(l,"asks",[]),m=this.safeValue(l,"bids",[]);this.handleDeltas(h.asks,p,i),this.handleDeltas(h.bids,m,i),h.nonce=c,h.timestamp=u,h.datetime=this.iso8601(u),this.orderbooks[n]=h,e.resolve(h,d)}}}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n="trades",r,a;e!==void 0&&(r=this.market(e),e=r.symbol,n=n+":"+r.symbol),[a,i]=this.handleMarketTypeAndParams("watchMyTrades",r,i),e===void 0&&(n=n+":"+a);const o=await this.subscribePrivate(a,n,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleMyTrades(e,t){const s="trades";if(t.length===0)return;let n=this.myTrades;if(n===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);n=new SO(c)}const r={};let a;for(let c=0;c<t.length;c++){const u=t[c];if(this.safeString(u,"symbol")in this.markets_by_id){const l=this.parseTrade(u);n.append(l);const p=l.symbol,m=this.market(p);a===void 0&&(a=m.type),r[p]=!0}}const o=Object.keys(r);for(let c=0;c<o.length;c++){const u=o[c],h=s+":"+u;e.resolve(n,h)}const d=s+":"+a;e.resolve(n,d)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let n="orders",r,a;e!==void 0&&(r=this.market(e),e=r.symbol,n=n+":"+r.symbol),[a,i]=this.handleMarketTypeAndParams("watchOrders",r,i),e===void 0&&(n=n+":"+a);const o=await this.subscribePrivate(a,n,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleOrders(e,t){let s=[];const i=[];if("closed"in t||"fills"in t||"open"in t){const u=this.safeValue(t,"closed",[]),h=this.safeValue(t,"open",[]),l=this.arrayConcat(h,u);if(l.length===0)return;s=this.safeValue(t,"fills",[]);for(let g=0;g<l.length;g++){const y=l[g];if(this.safeString(y,"symbol")in this.markets_by_id){const w=this.parseOrder(y);i.push(w)}}}else for(let u=0;u<t.length;u++){const h=t[u];if(this.safeString(h,"symbol")in this.markets_by_id){const p=this.safeString(h,"action");p!==void 0&&p!=="Cancel"&&s.push(h);const m=this.parseWSSwapOrder(h);i.push(m)}}this.handleMyTrades(e,s);const n=this.safeInteger(this.options,"ordersLimit",1e3),r={};this.orders===void 0&&(this.orders=new SO(n));let a;const o=this.orders;for(let u=0;u<i.length;u++){const h=i[u];o.append(h);const l=h.symbol,p=this.market(l);a===void 0&&(a=p.type),r[l]=!0}const d=Object.keys(r);for(let u=0;u<d.length;u++){const h="orders:"+d[u];e.resolve(this.orders,h)}const c="orders:"+a;e.resolve(this.orders,c)}parseWSSwapOrder(e,t=void 0){const s=this.safeString(e,"orderID");let i=this.safeString(e,"clOrdID");i!==void 0&&i.length<1&&(i=void 0);const n=this.safeString(e,"symbol");t=this.safeMarket(n,t);const r=t.symbol,a=this.parseOrderStatus(this.safeString(e,"ordStatus")),o=this.safeStringLower(e,"side"),d=this.parseOrderType(this.safeString(e,"ordType")),c=this.parseNumber(this.fromEp(this.safeString(e,"priceEp"),t)),u=this.safeString(e,"orderQty"),h=this.safeString(e,"cumQty"),l=this.safeString(e,"leavesQty"),p=this.safeIntegerProduct(e,"actionTimeNs",1e-6),m=this.safeString(e,"cumValueEv"),g=this.fromEv(m,t);let y=this.safeIntegerProduct(e,"transactTimeNs",1e-6);y===0&&(y=void 0);const b=this.parseTimeInForce(this.safeString(e,"timeInForce")),w=this.safeString(e,"stopPx"),k=b==="PO";return this.safeOrder({info:e,id:s,clientOrderId:i,datetime:this.iso8601(p),timestamp:p,lastTradeTimestamp:y,symbol:r,type:d,timeInForce:b,postOnly:k,side:o,price:c,stopPrice:w,amount:u,filled:h,remaining:l,cost:g,average:void 0,status:a,fee:void 0,trades:void 0},t)}handleMessage(e,t){const s=this.safeInteger(t,"id");if(s!==void 0){const i=e.subscriptions,n=Object.values(i);for(let r=0;r<n.length;r++){const a=n[r];if(a!==!0){const o=this.safeInteger(a,"id");if(o!==void 0&&o===s){const d=this.safeValue(a,"method");if(d!==void 0){d.call(this,e,t);return}}}}}if("market24h"in t||"spot_market24h"in t)return this.handleTicker(e,t);if("trades"in t)return this.handleTrades(e,t);if("kline"in t)return this.handleOHLCV(e,t);if("book"in t)return this.handleOrderBook(e,t);if("orders"in t){const i=this.safeValue(t,"orders",{});this.handleOrders(e,i)}if("accounts"in t||"wallets"in t){const i="accounts"in t?"swap":"spot",n=this.safeValue2(t,"accounts","wallets",[]);this.handleBalance(i,e,n)}}handleAuthenticate(e,t){return e.futures.authenticated.resolve(1),t}async subscribePrivate(e,t,s={}){await this.loadMarkets(),await this.authenticate();const i=this.urls.api.ws,n=this.seconds(),r=e==="spot"?"wo.subscribe":"aop.subscribe";let a={id:n,method:r,params:[]};a=this.extend(a,s);const o={id:n,messageHash:t};return await this.watch(i,t,a,r,o)}async authenticate(e={}){this.checkRequiredCredentials();const t=this.urls.api.ws,s=this.client(t),i=this.seconds(),n="authenticated",r=s.future(n);if(this.safeValue(s.subscriptions,n)===void 0){const o=this.safeInteger(this.options,"expires",120),d=this.seconds()+o,c=this.apiKey+d.toString(),u=this.hmac(this.encode(c),this.encode(this.secret),"sha256"),h={method:"user.auth",params:["API",this.apiKey,u,d],id:i},l={id:i,method:this.handleAuthenticate};this.spawn(this.watch,t,n,h,n,l)}return await r}};const oz=rC,{ArrayCache:dz}=rt;var cz=class extends oz{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTrades:!0,watchTicker:!0},urls:{api:{ws:"wss://api.exchange.ripio.com/ws/v2/consumer/non-persistent/public/default/"}},options:{tradesLimit:1e3,uuid:this.uuid()}})}async watchTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=this.market(e);e=n.symbol;const r="trades",a=r+"_"+n.id.toLowerCase(),o=this.urls.api.ws+a+"/"+this.options.uuid,d={name:r,symbol:e,messageHash:a,method:this.handleTrade},c=await this.watch(o,a,void 0,a,d);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySinceLimit(c,t,s,"timestamp",!0)}handleTrade(e,t,s){const i=this.safeString(t,"payload");if(i===void 0)return t;const n=JSON.parse(this.base64ToString(i)),r=this.safeString(s,"symbol"),a=this.safeString(s,"messageHash"),o=this.market(r),d=this.parseTrade(n,o);let c=this.safeValue(this.trades,r);if(c===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);c=new dz(u),this.trades[r]=c}c.append(d),e.resolve(c,a)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i="rate",n=i+"_"+s.id.toLowerCase(),r=this.urls.api.ws+n+"/"+this.options.uuid,a={name:i,symbol:e,messageHash:n,method:this.handleTicker};return await this.watch(r,n,void 0,n,a)}handleTicker(e,t,s){const i=this.safeString(t,"payload");if(i===void 0)return t;const n=JSON.parse(this.base64ToString(i)),r=this.parseTicker(n),a=this.parse8601(this.safeString(t,"publishTime"));r.timestamp=a,r.datetime=this.iso8601(a);const o=r.symbol;this.tickers[o]=r;const d=this.safeString(s,"messageHash");return d!==void 0&&e.resolve(r,d),t}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n="orderbook",r=n+"_"+i.id.toLowerCase(),a=this.urls.api.ws+r+"/"+this.options.uuid,o=this.client(a),d={name:n,symbol:e,messageHash:r,method:this.handleOrderBook};if(!(r in o.subscriptions)){this.orderbooks[e]=this.orderBook({}),o.subscriptions[r]=d;const u=this.safeValue(this.options,"fetchOrderBookSnapshot",{}),h=this.safeInteger(u,"delay",this.rateLimit);this.delay(h,this.fetchOrderBookSnapshot,o,d)}return(await this.watch(a,r,void 0,r,d)).limit()}async fetchOrderBookSnapshot(e,t){const s=this.safeString(t,"symbol"),i=this.safeString(t,"messageHash");try{const n=await this.fetchOrderBook(s),r=this.orderbooks[s],a=r.cache;r.reset(n);for(let o=0;o<a.length;o++){const d=a[o];this.handleOrderBookMessage(e,d,r)}this.orderbooks[s]=r,e.resolve(r,i)}catch(n){e.reject(n,i)}}handleOrderBook(e,t,s){const i=this.safeString(s,"messageHash"),n=this.safeString(s,"symbol"),r=this.safeValue(this.orderbooks,n);return r===void 0||(r.nonce===void 0?r.cache.push(t):(this.handleOrderBookMessage(e,t,r),e.resolve(r,i))),t}handleOrderBookMessage(e,t,s){const i=this.safeString(t,"payload");if(i===void 0)return t;const n=JSON.parse(this.base64ToString(i)),r=this.safeInteger(n,"updated_id");if(r>s.nonce){const a=this.safeValue(n,"sell",[]),o=this.safeValue(n,"buy",[]);this.handleDeltas(s.asks,a,s.nonce),this.handleDeltas(s.bids,o,s.nonce),s.nonce=r;const d=this.parse8601(this.safeString(t,"publishTime"));s.timestamp=d,s.datetime=this.iso8601(d)}return s}handleDelta(e,t){const s=this.safeFloat(t,"price"),i=this.safeFloat(t,"amount");e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async ack(e,t){await e.send({messageId:t})}handleMessage(e,t){const s=this.safeString(t,"messageId");s!==void 0&&this.spawn(this.ack,e,s);const i=Object.keys(e.subscriptions),n=this.safeString(i,0),r=this.safeValue(e.subscriptions,n,{}),a=this.safeValue(r,"method");return a!==void 0?a.call(this,e,t,r):t}};const uz=aC,{ArrayCache:fz}=rt;var hz=class extends uz{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTicker:!0,watchTrades:!0},urls:{api:{ws:"wss://api.upbit.com/websocket/v1"}},options:{tradesLimit:1e3}})}async watchPublic(e,t,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n=i.id,r=this.urls.api.ws;this.options[t]=this.safeValue(this.options,t,{}),this.options[t][e]=!0;const a=Object.keys(this.options[t]),o=this.marketIds(a),d=[{ticket:this.uuid()},{type:t,codes:o}],c=t+":"+n;return await this.watch(r,c,d,c)}async watchTicker(e,t={}){return await this.watchPublic(e,"ticker")}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.watchPublic(e,"trade");return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}async watchOrderBook(e,t=void 0,s={}){return(await this.watchPublic(e,"orderbook")).limit()}handleTicker(e,t){const i="ticker:"+this.safeString(t,"code"),n=this.parseTicker(t),r=n.symbol;this.tickers[r]=n,e.resolve(n,i)}handleOrderBook(e,t){const s=this.safeString(t,"code"),i=this.safeSymbol(s,void 0,"-"),n=this.safeString(t,"stream_type"),r=this.safeValue(this.options,"watchOrderBook",{}),a=this.safeInteger(r,"limit",15);n==="SNAPSHOT"&&(this.orderbooks[i]=this.orderBook({},a));const o=this.orderbooks[i];o.reset({}),o.symbol=i;const d=o.bids,c=o.asks,u=this.safeValue(t,"orderbook_units",[]);for(let m=0;m<u.length;m++){const g=u[m],y=this.safeFloat(g,"ask_price"),b=this.safeFloat(g,"ask_size"),w=this.safeFloat(g,"bid_price"),k=this.safeFloat(g,"bid_size");c.store(y,b),d.store(w,k)}const h=this.safeInteger(t,"timestamp"),l=this.iso8601(h);o.timestamp=h,o.datetime=l;const p="orderbook:"+s;e.resolve(o,p)}handleTrades(e,t){const s=this.parseTrade(t),i=s.symbol;let n=this.safeValue(this.trades,i);if(n===void 0){const o=this.safeInteger(this.options,"tradesLimit",1e3);n=new fz(o),this.trades[i]=n}n.append(s);const a="trade:"+this.safeString(t,"code");e.resolve(n,a)}handleMessage(e,t){const s={ticker:this.handleTicker,orderbook:this.handleOrderBook,trade:this.handleTrades},i=this.safeString(t,"type"),n=this.safeValue(s,i);n&&n.call(this,e,t)}};const lz=oC,{NotSupported:pz,ExchangeError:mz}=de,{ArrayCacheBySymbolById:vO,ArrayCacheByTimestamp:gz}=rt;var yz=class extends lz{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!0,watchTrades:!1,watchMyTrades:!0,watchOrders:!0,watchOrderBook:!0,watchOHLCV:!0},urls:{api:{ws:"wss://stream.wazirx.com/stream"}},options:{},streaming:{},exceptions:{},api:{private:{post:{create_auth_token:1}}}})}async watchBalance(e={}){await this.loadMarkets();const t=await this.authenticate(e),s="balance",i=this.urls.api.ws,n={event:"subscribe",streams:["outboundAccountPosition"],auth_key:t},r=this.deepExtend(n,e);return await this.watch(i,s,r,s)}handleBalance(e,t){const s=this.safeValue(t,"data",{}),i=this.safeValue(s,"B",[]);for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(a,"a"),d=this.safeCurrencyCode(o),c=this.safeNumber(a,"b"),u=this.safeNumber(a,"l"),h=this.account();h.free=c,h.used=u,this.balance[d]=h}this.balance=this.safeBalance(this.balance);const n="balance";e.resolve(this.balance,n)}parseWSTrade(e,t=void 0){const s=this.safeInteger(e,"E"),i=this.safeString(e,"s");t=this.safeMarket(i,t);const n=this.safeString(e,"U");return this.safeTrade({id:this.safeString(e,"t"),info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:this.safeString(e,"o"),type:void 0,side:void 0,takerOrMaker:this.safeValue(e,"m"),price:this.safeString(e,"p"),amount:this.safeString(e,"q"),cost:void 0,fee:{cost:this.safeString(e,"f"),currency:this.safeCurrencyCode(n),rate:void 0}},t)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=this.urls.api.ws,n="ticker:"+s.symbol,r="tickers",o={event:"subscribe",streams:["!ticker@arr"]},d=this.deepExtend(o,t);return await this.watch(i,n,d,r)}async watchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.urls.api.ws,i="tickers",r={event:"subscribe",streams:["!ticker@arr"]},a=this.deepExtend(r,t),o=await this.watch(s,i,a,i);return this.filterByArray(o,"symbol",e,!1)}handleTicker(e,t){const s=this.safeValue(t,"data",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.parseWSTicker(n),a=r.symbol;this.tickers[a]=r;const o="ticker:"+a;e.resolve(r,o)}e.resolve(this.tickers,"tickers")}parseWSTicker(e,t=void 0){const s=this.safeString(e,"s"),i=this.safeInteger(e,"E");return this.safeTicker({symbol:this.safeSymbol(s,t),timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"h"),low:this.safeString(e,"l"),bid:this.safeNumber(e,"b"),bidVolume:void 0,ask:this.safeNumber(e,"a"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"o"),close:void 0,last:this.safeString(e,"l"),previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:this.safeString(e,"q"),info:e},t)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const n=await this.authenticate(i);e!==void 0&&(e=this.market(e).symbol);const r=this.urls.api.ws,a="myTrades",o={event:"subscribe",streams:["ownTrade"],auth_key:n},d=this.deepExtend(o,i),c=await this.watch(r,a,d,a);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=this.urls.api.ws,o="ohlcv:"+e+":"+t,c={event:"subscribe",streams:[r.id+"@kline_"+t]},u=this.deepExtend(c,n),h=await this.watch(a,o,u,o);return this.newUpdates&&(i=h.getLimit(e,i)),this.filterBySinceLimit(h,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(s,"s"),n=this.safeMarket(i),r=this.safeSymbol(i,n),a=this.safeString(s,"i");this.ohlcvs[r]=this.safeValue(this.ohlcvs,r,{});let o=this.safeValue(this.ohlcvs[r],a);if(o===void 0){const u=this.safeInteger(this.options,"OHLCVLimit",1e3);o=new gz(u),this.ohlcvs[r][a]=o}const d=this.parseWsOHLCV(s,n);o.append(d);const c="ohlcv:"+r+":"+a;e.resolve(o,c)}parseWsOHLCV(e,t=void 0){return[this.safeInteger(e,"t"),this.safeNumber(e,"o"),this.safeNumber(e,"c"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"v")]}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const n=this.urls.api.ws,r="orderbook:"+e,o={event:"subscribe",streams:[i.id+"@depth"]},d=this.deepExtend(o,s);return(await this.watch(n,r,d,r)).limit()}handleDelta(e,t){const s=this.parseBidAsk(t,0,1);e.storeArray(s)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBook(e,t){const s=this.safeValue(t,"data",{}),i=this.safeInteger(s,"E"),n=this.safeString(s,"s"),a=this.safeMarket(n).symbol,o="orderbook:"+a,d=this.safeValue(this.orderbooks,a);if(d===void 0){const c=this.parseOrderBook(s,a,i,"b","a"),u=this.orderBook(c);this.orderbooks[a]=u}else{const c=this.safeValue(s,"a",[]),u=this.safeValue(s,"b",[]);this.handleDeltas(d.asks,c),this.handleDeltas(d.bids,u),d.nonce=i,d.timestamp=i,d.datetime=this.iso8601(i),this.orderbooks[a]=d}e.resolve(this.orderbooks[a],o)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),e!==void 0&&(e=this.market(e).symbol);const n=await this.authenticate(i),r="orders",a={event:"subscribe",streams:["orderUpdate"],auth_key:n},o=this.urls.api.ws,d=this.deepExtend(a,i),c=await this.watch(o,r,d,r,d);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}handleOrder(e,t){const s=this.safeValue(t,"data",{}),i=this.parseWSOrder(s);if(this.orders===void 0){const r=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new vO(r)}this.orders.append(i);let n="orders";e.resolve(this.orders,n),n+=":"+i.symbol,e.resolve(this.orders,n)}parseWSOrder(e){const t=this.safeInteger(e,"O"),s=this.safeString(e,"s"),i=this.safeString(e,"X"),n=this.safeMarket(s);return this.safeOrder({info:e,id:this.safeString(e,"i"),clientOrderId:this.safeString(e,"c"),datetime:this.iso8601(t),timestamp:t,lastTradeTimestamp:void 0,symbol:n.symbol,type:this.safeValue(e,"m")?"limit":"market",timeInForce:void 0,postOnly:void 0,side:this.safeString(e,"o"),price:this.safeString(e,"p"),stopPrice:void 0,amount:this.safeString(e,"V"),filled:void 0,remaining:this.safeString(e,"q"),cost:void 0,average:this.safeString(e,"v"),status:this.parseOrderStatus(i),fee:void 0,trades:void 0},n)}handleMyTrades(e,t){const s=this.safeValue(t,"data",{}),i="myTrades";let n;if(this.myTrades===void 0){const a=this.safeInteger(this.options,"tradesLimit",1e3);n=new vO(a),this.myTrades=n}else n=this.myTrades;const r=this.parseWSTrade(s);n.append(r),e.resolve(n,i)}handleConnected(e,t){return t}handleSubscribed(e,t){return t}handleError(e,t){throw new mz(this.id+" "+this.json(t))}handleMessage(e,t){const s=this.safeString(t,"event"),i={error:this.handleError,connected:this.handleConnected,subscribed:this.handleSubscribed},n=this.safeValue(i,s);if(n!==void 0)return n.call(this,e,t);const r=this.safeString(t,"stream",""),a={"ticker@arr":this.handleTicker,"@depth":this.handleOrderBook,"@kline":this.handleOHLCV,outboundAccountPosition:this.handleBalance,orderUpdate:this.handleOrder,ownTrade:this.handleMyTrades},o=Object.keys(a);for(let d=0;d<o.length;d++)if(this.inArray(o[d],r))return a[o[d]].call(this,e,t);throw new pz(this.id+" this message type is not supported yet. Message: "+this.json(t))}async authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i="authenticated",n=this.milliseconds();let r=this.safeValue(s.subscriptions,i);const a=this.safeNumber(r,"expires");return(r===void 0||n>a)&&(r=await this.privatePostCreateAuthToken(),r.expires=n+this.safeNumber(r,"timeout_duration")*1e3,s.subscriptions[i]=r),this.safeString(r,"auth_key")}};const bz=dC,wz=Se,{AuthenticationError:TO,BadRequest:Hg,ArgumentsRequired:OO}=de,{ArrayCache:IO,ArrayCacheBySymbolById:kz,ArrayCacheByTimestamp:Sz}=rt;var vz=class extends bz{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTrades:!0},urls:{api:{ws:"wss://api.whitebit.com/ws"}},options:{timeframes:{"1m":"60","5m":"300","15m":"900","30m":"1800","1h":"3600","4h":"14400","8h":"28800","1d":"86400","1w":"604800"},watchOrderBook:{priceInterval:0}},streaming:{ping:this.ping},exceptions:{ws:{exact:{1:Hg,2:Hg,4:Hg,6:TO}}}})}async watchOHLCV(e,t="1m",s=void 0,i=void 0,n={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=this.safeValue(this.options,"timeframes",{}),o=this.safeInteger(a,t),d=r.id,c="candles:"+e,u=[d,o],h="candles_subscribe",l=await this.watchPublic(c,h,u,n);return this.newUpdates&&(i=l.getLimit(e,i)),this.filterBySinceLimit(l,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"params",[]);for(let i=0;i<s.length;i++){const n=s[i],r=this.safeString(n,7),a=this.safeMarket(r),o=a.symbol,d="candles:"+o,c=this.parseOHLCV(n,a);this.ohlcvs[o]=this.safeValue(this.ohlcvs,o);let u=this.ohlcvs[o];if(u===void 0){const h=this.safeInteger(this.options,"OHLCVLimit",1e3);u=new Sz(h),this.ohlcvs[o]=u}u.append(c),e.resolve(u,d)}return t}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);t===void 0&&(t=10);const n="orderbook:"+i.symbol,r="depth_subscribe",a=this.safeValue(this.options,"watchOrderBook",{}),o=this.safeString(a,"priceInterval","0"),d=this.safeString(s,"priceInterval",o);s=this.omit(s,"priceInterval");const c=[i.id,t,d,!0];return(await this.watchPublic(n,r,c,s)).limit()}handleOrderBook(e,t){const s=this.safeValue(t,"params",[]),i=this.safeValue(s,0),n=this.safeString(s,2),a=this.safeMarket(n).symbol,o=this.safeValue(s,1);let d;if(a in this.orderbooks?d=this.orderbooks[a]:(d=this.orderBook(),this.orderbooks[a]=d),i){const u=this.parseOrderBook(o,a);d.reset(u)}else{const u=this.safeValue(o,"asks",[]),h=this.safeValue(o,"bids",[]);this.handleDeltas(d.asks,u),this.handleDeltas(d.bids,h)}const c="orderbook:"+a;e.resolve(d,c)}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchTicker(e,t={}){await this.loadMarkets(),e=this.market(e).symbol;const i="market_subscribe",n="ticker:"+e;return await this.watchMultipleSubscription(n,i,e,!1,t)}handleTicker(e,t){const s=this.safeValue(t,"params",[]),i=this.safeString(s,0),n=this.safeMarket(i,void 0),r=n.symbol,a=this.safeValue(s,1,{}),o="ticker:"+r,d=this.parseTicker(a,n);this.tickers[r]=d,e.resolve(d,o);const c=Object.keys(e.futures);for(let u=0;u<c.length;u++){const h=c[u];h.indexOf("tickers")>=0&&h.indexOf(r)>=0&&e.resolve(d,h)}return t}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.market(e).symbol;const r="trades:"+e,a="trades_subscribe",o=await this.watchMultipleSubscription(r,a,e,!1,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"params",[]),i=this.safeString(s,0),n=this.safeMarket(i),r=n.symbol;let a=this.safeValue(this.trades,r);if(a===void 0){const u=this.safeInteger(this.options,"tradesLimit",1e3);a=new IO(u),this.trades[r]=a}const o=this.safeValue(s,1,[]),d=this.parseTrades(o,n);for(let u=0;u<d.length;u++)a.append(d[u]);const c="trades:"+n.symbol;e.resolve(a,c)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new OO(this.id+" watchMyTrades requires a symbol argument");await this.loadMarkets(),await this.authenticate(),e=this.market(e).symbol;const r="myTrades:"+e,a="deals_subscribe",o=await this.watchMultipleSubscription(r,a,e,!0,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleMyTrades(e,t,s=void 0){const i=this.safeValue(t,"params");if(this.myTrades===void 0){const d=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new IO(d)}const n=this.myTrades,r=this.parseWsTrade(i);n.append(r);const o="myTrades:"+r.symbol;e.resolve(n,o)}parseWsTrade(e,t=void 0){const s=this.safeString(e,3),i=this.safeTimestamp(e,1),n=this.safeString(e,0),r=this.safeString(e,4),a=this.safeString(e,5),o=this.safeString(e,2);t=this.safeMarket(o,t);let d;const c=this.safeString(e,6);return c!==void 0&&(d={cost:c,currency:t.quote}),this.safeTrade({id:n,info:e,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,order:s,type:void 0,side:void 0,takerOrMaker:void 0,price:r,amount:a,cost:void 0,fee:d},t)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(e===void 0)throw new OO(this.id+" watchOrders requires a symbol argument");await this.loadMarkets(),await this.authenticate(),e=this.market(e).symbol;const r="orders:"+e,a="ordersPending_subscribe",o=await this.watchMultipleSubscription(r,a,e,!1,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleOrder(e,t,s=void 0){const i=this.safeValue(t,"params",[]),n=this.safeValue(i,1);if(this.orders===void 0){const u=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new kz(u)}const r=this.orders,a=this.safeInteger(i,0),o=this.parseWsOrder(n,a);r.append(o);const c="orders:"+o.symbol;e.resolve(this.orders,c)}parseWsOrder(e,t,s=void 0){const i=this.safeString(e,"market");s=this.safeMarket(i,s);const n=this.safeString(e,"id"),r=this.omitZero(this.safeString(e,"client_order_id")),a=this.safeString(e,"price"),o=this.safeString(e,"deal_stock"),d=this.safeString(e,"deal_money"),c=this.safeString(e,"activation_price"),u=this.safeString(e,"type"),h=this.parseWsOrderType(u);let l,p;h==="market"?(l=this.safeString(e,"deal_stock"),p="0"):(p=this.safeString(e,"left"),l=this.safeString(e,"amount"));const m=this.safeTimestamp(e,"ctime"),g=this.safeTimestamp(e,"mtime"),y=s.symbol,w=this.safeInteger(e,"side")===1?"sell":"buy",k=this.safeString(e,"deal_fee");let T;return k!==void 0&&(T={cost:this.parseNumber(k),currency:s.quote}),t===1||t===2?t="open":wz.stringEquals(p,"0")?t="closed":t="canceled",this.safeOrder({info:e,symbol:y,id:n,clientOrderId:r,timestamp:m,datetime:this.iso8601(m),lastTradeTimestamp:g,type:h,timeInForce:void 0,postOnly:void 0,side:w,price:a,stopPrice:c,amount:l,cost:d,average:void 0,filled:o,remaining:p,status:t,fee:T,trades:void 0},s)}parseWsOrderType(e){const t={1:"limit",2:"market",202:"market",3:"limit",4:"market",5:"limit",6:"market",8:"limit",10:"market"};return this.safeString(t,e,e)}async watchBalance(e={}){await this.loadMarkets();let t;[t,e]=this.handleMarketTypeAndParams("watchBalance",void 0,e);let s="wallet:",i;t==="spot"?(i="balanceSpot_subscribe",s+="spot"):(i="balanceMargin_subscribe",s+="margin");const n=Object.keys(this.currencies);return await this.watchPrivate(s,i,n,e)}handleBalance(e,t){const s=this.safeString(t,"method"),i=this.safeValue(t,"params"),n=this.safeValue(i,0),r=Object.keys(n),a=this.safeValue(r,0),o=this.safeValue(n,a),d=this.safeCurrencyCode(a),c=this.account();c.free=this.safeString(o,"available"),c.used=this.safeString(o,"freeze"),this.balance[d]=c,this.balance=this.safeBalance(this.balance);let u="wallet:";s.indexOf("Spot")>=0?u+="spot":u+="margin",e.resolve(this.balance,u)}async watchPublic(e,t,s=[],i={}){const n=this.urls.api.ws,a={id:this.nonce(),method:t,params:s},o=this.extend(a,i);return await this.watch(n,e,o,e)}async watchMultipleSubscription(e,t,s,i=!1,n={}){await this.loadMarkets();const r=this.urls.api.ws,a=this.nonce(),o=this.safeValue(this.clients,r);let d;if(o===void 0){const c={},h=this.market(s).id;c[h]=!0;let l=[h];i&&(l=[l]),d={id:a,method:t,params:l};const p=this.extend(d,n);return await this.watch(r,e,p,t,c)}else{const c=this.safeValue(o.subscriptions,t,{});let u=!0;const l=this.market(s).id;if(this.safeValue(c,l,!1)||(c[l]=!0,u=!1),u)return await this.watch(r,e,d,t,c);{let m=Object.keys(c);i&&(m=[m]);const g={id:a,method:t,params:m};return t in o.subscriptions&&delete o.subscriptions[t],await this.watch(r,e,g,t,c)}}}async watchPrivate(e,t,s=[],i={}){this.checkRequiredCredentials(),await this.authenticate();const n=this.urls.api.ws,a={id:this.nonce(),method:t,params:s},o=this.extend(a,i);return await this.watch(n,e,o,e)}async authenticate(e={}){this.checkRequiredCredentials();const t=this.urls.api.ws,s="login",i=this.client(t),n=i.future("authenticated");if(this.safeValue(i.subscriptions,s)===void 0){const a=await this.v4PrivatePostProfileWebsocketToken(),o=this.safeString(a,"websocket_token"),d=this.nonce(),c={id:d,method:"authorize",params:[o,"public"]},u={id:d,method:this.handleAuthenticate};this.spawn(this.watch,t,s,c,s,u)}return await n}handleAuthenticate(e,t){return e.futures.authenticated.resolve(1),t}handleErrorMessage(e,t){const s=this.safeValue(t,"error");try{if(s!==void 0){const i=this.safeString(t,"code"),n=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.ws.exact,i,n)}}catch(i){if(i instanceof TO)return e.reject(i,"authenticated"),"login"in e.subscriptions&&delete e.subscriptions.login,!1}return t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;const s=this.safeValue(t,"result",{});if(s!==void 0&&s==="pong"){this.handlePong(e,t);return}const i=this.safeInteger(t,"id");if(i!==void 0){this.handleSubscriptionStatus(e,t,i);return}const n={market_update:this.handleTicker,trades_update:this.handleTrades,depth_update:this.handleOrderBook,candles_update:this.handleOHLCV,ordersPending_update:this.handleOrder,ordersExecuted_update:this.handleOrder,balanceSpot_update:this.handleBalance,balanceMargin_update:this.handleBalance,deals_update:this.handleMyTrades},r=this.safeValue(t,"method"),a=this.safeValue(n,r);a!==void 0&&a.call(this,e,t)}handleSubscriptionStatus(e,t,s){const i=e.subscriptions,n=Object.values(i);for(let r=0;r<n.length;r++){const a=n[r];if(a!==!0){const o=this.safeInteger(a,"id");if(o!==void 0&&o===s){const d=this.safeValue(a,"method");if(d!==void 0){d.call(this,e,t);return}}}}}handlePong(e,t){return e.lastPong=this.milliseconds(),t}ping(e){return{id:0,method:"ping",params:[]}}};const Tz=cC,{ExchangeError:Oz}=de,{ArrayCache:Iz}=rt;var xz=class extends Tz{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTicker:!0,watchTrades:!0},urls:{api:{ws:"wss://api.{hostname}/websocket"}},options:{tradesLimit:1e3,ordersLimit:1e3,OHLCVLimit:1e3}})}async watchPublic(e,t,s,i={}){await this.loadMarkets();const n=this.market(t);t=n.symbol;const r=n.baseId+n.quoteId+"_"+e,a=this.implodeHostname(this.urls.api.ws),o={event:"addChannel",channel:r},d=this.extend(o,i),c={name:e,symbol:t,marketId:n.id,messageHash:r,method:s};return await this.watch(a,r,d,r,c)}async watchTicker(e,t={}){return await this.watchPublic("ticker",e,this.handleTicker,t)}handleTicker(e,t,s){const i=this.safeString(s,"symbol"),n=this.safeString(t,"channel"),r=this.market(i),a=this.safeValue(t,"ticker");a.date=this.safeValue(t,"date");const o=this.parseTicker(a,r);return o.symbol=i,this.tickers[i]=o,e.resolve(o,n),t}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const n=await this.watchPublic("trades",e,this.handleTrades,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}handleTrades(e,t,s){const i=this.safeValue(t,"channel"),n=this.safeString(s,"symbol"),r=this.market(n),a=this.safeValue(t,"data"),o=this.parseTrades(a,r);let d=this.safeValue(this.trades,n);if(d===void 0){const c=this.safeInteger(this.options,"tradesLimit",1e3);d=new Iz(c)}for(let c=0;c<o.length;c++)d.append(o[c]);this.trades[n]=d,e.resolve(d,i)}async watchOrderBook(e,t=void 0,s={}){if(t!==void 0){if(t!==5&&t!==10&&t!==20)throw new Oz(this.id+" watchOrderBook limit argument must be undefined, 5, 10 or 20")}else t=5;await this.loadMarkets();const i=this.market(e);e=i.symbol;const n="quick_depth",r=i.baseId+i.quoteId+"_"+n,a=this.implodeHostname(this.urls.api.ws)+"/"+i.baseId,o={event:"addChannel",channel:r,length:t},d=this.extend(o,s),c={name:n,symbol:e,marketId:i.id,messageHash:r,method:this.handleOrderBook};return(await this.watch(a,r,d,r,c)).limit()}handleOrderBook(e,t,s){const i=this.safeString(t,"channel"),n=this.safeInteger(s,"limit"),r=this.safeString(s,"symbol");let a=this.safeValue(this.orderbooks,r);a===void 0&&(a=this.orderBook({},n),this.orderbooks[r]=a);const o=this.safeInteger(t,"lastTime"),d=this.parseOrderBook(t,r,o,"listDown","listUp");a.reset(d),a.symbol=r,e.resolve(a,i)}handleMessage(e,t){if(this.safeString(t,"dataType")!==void 0){const i=this.safeString(t,"channel"),n=this.safeValue(e.subscriptions,i);if(n!==void 0){const r=this.safeValue(n,"method");if(r!==void 0)return r.call(this,e,t,n)}return t}}};const _z=mC;var Cz=class extends _z{describe(){return this.deepExtend(super.describe(),{id:"zipmex",name:"Zipmex",countries:["AU","SG","TH","ID"],urls:{logo:"https://user-images.githubusercontent.com/1294454/146103275-c39a34d9-68a4-4cd2-b1f1-c684548d311b.jpg",test:void 0,api:{public:"https://apws.zipmex.com:8443/AP",private:"https://apws.zipmex.com:8443/AP",ws:"wss://apws.zipmex.com/WSGateway"},www:"https://zipmex.com/",referral:"https://trade.zipmex.com/global/accounts/sign-up?aff=KLm7HyCsvN",fees:"https://zipmex.com/fee-schedule"},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.002"),maker:this.parseNumber("0.002")}}})}};const yC=ge,xO=Vq,Mz=Se,Pz=Fu,Az=de,bC="2.2.30";yC.ccxtVersion=bC;const wy={aax:A_,alpaca:zq,ascendex:B_,bequant:r4,bibox:p4,bigone:b4,binance:Gu,binancecoinm:x4,binanceus:C4,binanceusdm:P4,bit2c:R4,bitbank:$4,bitbay:t5,bitbns:c5,bitcoincom:h5,bitfinex:V_,bitfinex2:q_,bitflyer:V5,bitforex:G5,bitget:z5,bithumb:s6,bitmart:L_,bitmex:R_,bitopro:F_,bitpanda:w6,bitrue:x6,bitso:V6,bitstamp:D_,bitstamp1:Y6,bittrex:H_,bitvavo:G_,bkex:gL,bl3p:wL,blockchaincom:_L,btcalpha:VL,btcbox:$L,btcex:KL,btcmarkets:t8,btctradeua:r8,btcturk:u8,buda:g8,bybit:U_,bytetrade:I8,cex:$_,coinbase:R8,coinbaseprime:z8,coinbasepro:Mb,coincheck:Z8,coinex:j_,coinfalcon:lR,coinmate:SR,coinone:CR,coinspot:ER,crex24:GR,cryptocom:W_,currencycom:z_,delta:fF,deribit:K_,digifinex:IF,exmo:X_,flowbtc:qF,fmfwio:N_,gate:Pb,gateio:UF,gemini:KF,hitbtc:$l,hitbtc3:iD,hollaex:Y_,huobi:Ab,huobijp:Q_,huobipro:TD,idex:Z_,independentreserve:FD,indodax:jD,itbit:YD,kraken:J_,kucoin:Bb,kucoinfutures:yH,kuna:vH,latoken:PH,lbank:qH,lbank2:$H,liquid:e9,luno:eC,lykke:c9,mercado:p9,mexc:tC,mexc3:_9,ndax:jl,novadax:D9,oceanex:W9,okcoin:sC,okex:iC,okex5:oG,okx:Eb,paymium:fG,phemex:nC,poloniex:IG,probit:NG,qtrade:GG,ripio:rC,stex:n7,therock:d7,tidex:m7,timex:S7,tokocrypto:A7,upbit:aC,wavesexchange:$7,wazirx:oC,whitebit:dC,woo:rU,yobit:hU,zaif:yU,zb:cC,zipmex:IU,zonda:E_},il={aax:NU,ascendex:DU,bequant:jU,binance:Wl,binancecoinm:QU,binanceus:JU,binanceusdm:t$,bitcoincom:i$,bitfinex:c$,bitfinex2:g$,bitmart:v$,bitmex:C$,bitopro:B$,bitstamp:R$,bittrex:$$,bitvavo:X$,bybit:ej,cex:nj,coinbaseprime:dj,coinbasepro:hC,coinex:yj,cryptocom:Tj,currencycom:Cj,deribit:Ej,exmo:Rj,gate:lC,gateio:zj,hitbtc:Nb,hollaex:Jj,huobi:pC,huobijp:cW,huobipro:fW,idex:gW,kraken:IW,kucoin:AW,luno:NW,mexc:DW,ndax:mC,okcoin:KW,okex:sz,okx:gC,phemex:az,ripio:cz,upbit:hz,wazirx:yz,whitebit:vz,zb:xz,zipmex:Cz};for(const f in il){const e=wy[f];Object.getPrototypeOf(e).name==="Exchange"&&(Object.setPrototypeOf(e,xO),Object.setPrototypeOf(e.prototype,xO.prototype))}il.exchanges=Object.keys(il);var _O=Object.assign({version:bC,Exchange:yC,Precise:Mz,exchanges:Object.keys(wy),pro:il},wy,Pz,Az);window.Buffer=pl.Buffer;const Bz=_O.exchanges.filter(f=>new _O[f]().hasFetchPositions);function CO(f,e,t){Ez(f,e),e.set(f,t)}function Ez(f,e){if(e.has(f))throw new TypeError("Cannot initialize the same private elements twice on an object")}function Nz(f,e,t){var s=wC(f,e,"set");return Vz(f,s,t),t}function Vz(f,e,t){if(e.set)e.set.call(f,t);else{if(!e.writable)throw new TypeError("attempted to set read only private field");e.value=t}}function io(f,e){var t=wC(f,e,"get");return qz(f,t)}function wC(f,e,t){if(!e.has(f))throw new TypeError("attempted to "+t+" private field on non-instance");return e.get(f)}function qz(f,e){return e.get?e.get.call(f):e.value}function kC(f,e,t){const s=e.length-1;if(s<0)return f===void 0?t:f;for(let i=0;i<s;i++){if(f==null)return t;f=f[e[i]]}return f==null||f[e[s]]===void 0?t:f[e[s]]}function zl(f,e){if(f===e)return!0;if(f instanceof Date&&e instanceof Date&&f.getTime()!==e.getTime()||f!==Object(f)||e!==Object(e))return!1;const t=Object.keys(f);return t.length!==Object.keys(e).length?!1:t.every(s=>zl(f[s],e[s]))}function ky(f,e,t){return f==null||!e||typeof e!="string"?t:f[e]!==void 0?f[e]:(e=e.replace(/\[(\w+)\]/g,".$1"),e=e.replace(/^\./,""),kC(f,e.split("."),t))}function er(f,e,t){if(e==null)return f===void 0?t:f;if(f!==Object(f)){if(typeof e!="function")return t;const i=e(f,t);return typeof i>"u"?t:i}if(typeof e=="string")return ky(f,e,t);if(Array.isArray(e))return kC(f,e,t);if(typeof e!="function")return t;const s=e(f,t);return typeof s>"u"?t:s}function Lz(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0;return Array.from({length:f},(t,s)=>e+s)}function ze(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"px";if(!(f==null||f===""))return isNaN(+f)?String(f):isFinite(+f)?`${Number(f)}${e}`:void 0}function Sy(f){return f!==null&&typeof f=="object"&&!Array.isArray(f)}function Rz(f){return f==null?void 0:f.$el}const MO=Object.freeze({enter:13,tab:9,delete:46,esc:27,space:32,up:38,down:40,left:37,right:39,end:35,home:36,del:46,backspace:8,insert:45,pageup:33,pagedown:34,shift:16});Object.freeze({enter:"Enter",tab:"Tab",delete:"Delete",esc:"Escape",space:"Space",up:"ArrowUp",down:"ArrowDown",left:"ArrowLeft",right:"ArrowRight",end:"End",home:"Home",del:"Delete",backspace:"Backspace",insert:"Insert",pageup:"PageUp",pagedown:"PageDown",shift:"Shift"});function or(f,e){const t=Object.create(null),s=Object.create(null);for(const i in f)e.some(n=>n instanceof RegExp?n.test(i):n===i)?t[i]=f[i]:s[i]=f[i];return[t,s]}function Kl(f,e){const t={...f};return e.forEach(s=>delete t[s]),t}function Vb(f){return or(f,["class","style","id",/^data-/])}function tr(f){return f==null?[]:Array.isArray(f)?f:[f]}function vy(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,t=arguments.length>2&&arguments[2]!==void 0?arguments[2]:1;return Math.max(e,Math.min(t,f))}function xr(){let f=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},t=arguments.length>2?arguments[2]:void 0;const s={};for(const i in f)s[i]=f[i];for(const i in e){const n=f[i],r=e[i];if(Sy(n)&&Sy(r)){s[i]=xr(n,r,t);continue}if(Array.isArray(n)&&Array.isArray(r)&&t){s[i]=t(n,r);continue}s[i]=r}return s}function SC(f){return f.map(e=>e.type===Ft?SC(e.children):e).flat()}function Xl(){return(arguments.length>0&&arguments[0]!==void 0?arguments[0]:"").replace(/[^a-z]/gi,"-").replace(/\B([A-Z])/g,"-$1").toLowerCase()}function gu(f,e){if(!e||typeof e!="object")return[];if(Array.isArray(e))return e.map(t=>gu(f,t)).flat(1);if(Array.isArray(e.children))return e.children.map(t=>gu(f,t)).flat(1);if(e.component){if(Object.getOwnPropertySymbols(e.component.provides).includes(f))return[e.component];if(e.component.subTree)return gu(f,e.component.subTree).flat(1)}return[]}var Bh=new WeakMap,ed=new WeakMap;class Fz{constructor(e){CO(this,Bh,{writable:!0,value:[]}),CO(this,ed,{writable:!0,value:0}),this.size=e}push(e){io(this,Bh)[io(this,ed)]=e,Nz(this,ed,(io(this,ed)+1)%this.size)}values(){return io(this,Bh).slice(io(this,ed)).concat(io(this,Bh).slice(0,io(this,ed)))}}function qb(f){const e=ti({}),t=ie(f);return Mr(()=>{for(const s in t.value)e[s]=t.value[s]},{flush:"sync"}),Jy(e)}function nl(f,e){return f.includes(e)}const Dz=/^on[^a-z]/,vC=f=>Dz.test(f),mo=[Function,Array];function PO(f,e){return e="on"+Cr(e),!!(f[e]||f[`${e}Once`]||f[`${e}Capture`]||f[`${e}OnceCapture`]||f[`${e}CaptureOnce`])}function Hz(f){for(var e=arguments.length,t=new Array(e>1?e-1:0),s=1;s<e;s++)t[s-1]=arguments[s];if(Array.isArray(f))for(const i of f)i(...t);else typeof f=="function"&&f(...t)}const TC=["top","bottom"],Gz=["start","end","left","right"];function Ty(f,e){let[t,s]=f.split(" ");return s||(s=nl(TC,t)?"start":nl(Gz,t)?"top":"center"),{side:Oy(t,e),align:Oy(s,e)}}function Oy(f,e){return f==="start"?e?"right":"left":f==="end"?e?"left":"right":f}function Gg(f){return{side:{center:"center",top:"bottom",bottom:"top",left:"right",right:"left"}[f.side],align:f.align}}function Ug(f){return{side:f.side,align:{center:"center",top:"bottom",bottom:"top",left:"right",right:"left"}[f.align]}}function AO(f){return{side:f.align,align:f.side}}function BO(f){return nl(TC,f.side)?"y":"x"}class gd{constructor(e){let{x:t,y:s,width:i,height:n}=e;this.x=t,this.y=s,this.width=i,this.height=n}get top(){return this.y}get bottom(){return this.y+this.height}get left(){return this.x}get right(){return this.x+this.width}}function EO(f,e){return{x:{before:Math.max(0,e.left-f.left),after:Math.max(0,f.right-e.right)},y:{before:Math.max(0,e.top-f.top),after:Math.max(0,f.bottom-e.bottom)}}}function Lb(f){const e=f.getBoundingClientRect(),t=getComputedStyle(f),s=t.transform;if(s){let i,n,r,a,o;if(s.startsWith("matrix3d("))i=s.slice(9,-1).split(/, /),n=+i[0],r=+i[5],a=+i[12],o=+i[13];else if(s.startsWith("matrix("))i=s.slice(7,-1).split(/, /),n=+i[0],r=+i[3],a=+i[4],o=+i[5];else return new gd(e);const d=t.transformOrigin,c=e.x-a-(1-n)*parseFloat(d),u=e.y-o-(1-r)*parseFloat(d.slice(d.indexOf(" ")+1)),h=n?e.width/n:f.offsetWidth+1,l=r?e.height/r:f.offsetHeight+1;return new gd({x:c,y:u,width:h,height:l})}else return new gd(e)}function ud(f,e,t){if(typeof f.animate>"u")return{finished:Promise.resolve()};const s=f.animate(e,t);return typeof s.finished>"u"&&(s.finished=new Promise(i=>{s.onfinish=()=>{i(s)}})),s}function OC(f,e,t){if(t&&(e={_isVue:!0,$parent:t,$options:e}),e){if(e.$_alreadyWarned=e.$_alreadyWarned||[],e.$_alreadyWarned.includes(f))return;e.$_alreadyWarned.push(f)}return`[Vuetify] ${f}`+(e?jz(e):"")}function yd(f,e,t){const s=OC(f,e,t);s!=null&&console.warn(s)}function Iy(f,e,t){const s=OC(f,e,t);s!=null&&console.error(s)}const Uz=/(?:^|[-_])(\w)/g,$z=f=>f.replace(Uz,e=>e.toUpperCase()).replace(/[-_]/g,"");function $g(f,e){if(f.$root===f)return"<Root>";const t=typeof f=="function"&&f.cid!=null?f.options:f._isVue?f.$options||f.constructor.options:f||{};let s=t.name||t._componentTag;const i=t.__file;if(!s&&i){const n=i.match(/([^/\\]+)\.vue$/);s=n==null?void 0:n[1]}return(s?`<${$z(s)}>`:"<Anonymous>")+(i&&e!==!1?` at ${i}`:"")}function jz(f){if(f._isVue&&f.$parent){const e=[];let t=0;for(;f;){if(e.length>0){const s=e[e.length-1];if(s.constructor===f.constructor){t++,f=f.$parent;continue}else t>0&&(e[e.length-1]=[s,t],t=0)}e.push(f),f=f.$parent}return`

found in

`+e.map((s,i)=>`${i===0?"---> ":" ".repeat(5+i*2)}${Array.isArray(s)?`${$g(s[0])}... (${s[1]} recursive calls)`:$g(s)}`).join(`
`)}else return`

(found in ${$g(f)})`}const Wz=[[3.2406,-1.5372,-.4986],[-.9689,1.8758,.0415],[.0557,-.204,1.057]],zz=f=>f<=.0031308?f*12.92:1.055*f**(1/2.4)-.055,Kz=[[.4124,.3576,.1805],[.2126,.7152,.0722],[.0193,.1192,.9505]],Xz=f=>f<=.04045?f/12.92:((f+.055)/1.055)**2.4;function IC(f){const e=Array(3),t=zz,s=Wz;for(let i=0;i<3;++i)e[i]=Math.round(vy(t(s[i][0]*f[0]+s[i][1]*f[1]+s[i][2]*f[2]))*255);return(e[0]<<16)+(e[1]<<8)+(e[2]<<0)}function Rb(f){const e=[0,0,0],t=Xz,s=Kz,i=t((f>>16&255)/255),n=t((f>>8&255)/255),r=t((f>>0&255)/255);for(let a=0;a<3;++a)e[a]=s[a][0]*i+s[a][1]*n+s[a][2]*r;return e}const rl=.20689655172413793,Yz=f=>f>rl**3?Math.cbrt(f):f/(3*rl**2)+4/29,Qz=f=>f>rl?f**3:3*rl**2*(f-4/29);function xC(f){const e=Yz,t=e(f[1]);return[116*t-16,500*(e(f[0]/.95047)-t),200*(t-e(f[2]/1.08883))]}function _C(f){const e=Qz,t=(f[0]+16)/116;return[e(t+f[1]/500)*.95047,e(t),e(t-f[2]/200)*1.08883]}function NO(f){return!!f&&/^(#|var\(--|(rgb|hsl)a?\()/.test(f)}function al(f){let e;if(typeof f=="number")e=f;else if(typeof f=="string"){let t=f.startsWith("#")?f.substring(1):f;t.length===3&&(t=t.split("").map(s=>s+s).join("")),t.length!==6&&t.length!==8&&yd(`'${f}' is not a valid rgb color`),e=parseInt(t,16)}else throw new TypeError(`Colors can only be numbers or strings, recieved ${f==null?f:f.constructor.name} instead`);return e<0?(yd(`Colors cannot be negative: '${f}'`),e=0):(e>4294967295||isNaN(e))&&(yd(`'${f}' is not a valid rgb color`),e=16777215),e}function Zz(f){let e=f.toString(16);return e.length<6&&(e="0".repeat(6-e.length)+e),"#"+e}function CC(f){const e=al(f);return{r:(e&16711680)>>16,g:(e&65280)>>8,b:e&255}}function Jz(f,e){const t=xC(Rb(f));return t[0]=t[0]+e*10,IC(_C(t))}function eK(f,e){const t=xC(Rb(f));return t[0]=t[0]-e*10,IC(_C(t))}function tK(f){const e=al(f);return Rb(e)[1]}function ii(f,e){const t=Cl();if(!t)throw new Error(`[Vuetify] ${f} ${e||"must be called from inside a setup function"}`);return t}function Br(){let f=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"composables";const e=ii(f).type;return Xl((e==null?void 0:e.aliasName)||(e==null?void 0:e.name))}let MC=0,Kh=new WeakMap;function $i(){const f=ii("getUid");if(Kh.has(f))return Kh.get(f);{const e=MC++;return Kh.set(f,e),e}}$i.reset=()=>{MC=0,Kh=new WeakMap};function sK(f){const{provides:e}=ii("injectSelf");if(e&&f in e)return e[f]}const Mu=Symbol.for("vuetify:defaults");function iK(f){return fe(f!=null?f:{})}function PC(){const f=Zt(Mu);if(!f)throw new Error("[Vuetify] Could not find defaults instance");return f}function Er(f,e){const t=PC(),s=fe(f),i=ie(()=>{const n=ei(e==null?void 0:e.scoped),r=ei(e==null?void 0:e.reset),a=ei(e==null?void 0:e.root);let o=xr(s.value,{prev:t.value});if(n)return o;if(r||a){const d=Number(r||1/0);for(let c=0;c<=d&&o.prev;c++)o=o.prev;return o}return xr(o.prev,o)});return Ni(Mu,i),i}function Td(f,e){let t;st(f,s=>{if(s&&!t)t=wl(),t.run(e);else if(!s){var i;(i=t)==null||i.stop(),t=void 0}},{immediate:!0}),rr(()=>{var s;(s=t)==null||s.stop()})}function Ye(f,e){return t=>Object.keys(f).reduce((s,i)=>{const r=typeof f[i]=="object"&&f[i]!=null&&!Array.isArray(f[i])?f[i]:{type:f[i]};return t&&i in t?s[i]={...r,default:t[i]}:s[i]=r,e&&!s[i].source&&(s[i].source=e),s},{})}function nK(f,e){var t,s;return((t=f.props)==null?void 0:t.hasOwnProperty(e))||((s=f.props)==null?void 0:s.hasOwnProperty(Xl(e)))}const Qe=function(e){var t,s;return e._setup=(t=e._setup)!=null?t:e.setup,e.name?(e._setup&&(e.props=(s=e.props)!=null?s:{},e.props=Ye(e.props,Xl(e.name))(),e.props._as=String,e.setup=function(n,r){const a=Cl(),o=PC(),d=KM(),c=MI({...mt(n)});Mr(()=>{var p,m,g;const h=o.value.global,l=o.value[(p=n._as)!=null?p:e.name];if(l){const y=Object.entries(l).filter(b=>{let[w]=b;return w.startsWith(w[0].toUpperCase())});y.length&&(d.value=Object.fromEntries(y))}for(const y of Object.keys(n)){let b=n[y];nK(a.vnode,y)||(b=(g=(m=l==null?void 0:l[y])!=null?m:h==null?void 0:h[y])!=null?g:n[y]),c[y]!==b&&(c[y]=b)}});const u=e._setup(c,r);return Td(d,()=>{var l;var h;Er(xr((l=(h=sK(Mu))==null?void 0:h.value)!=null?l:{},d.value))}),u}),e):(yd("The component is missing an explicit name, unable to generate default prop value"),e)};function zs(){let f=arguments.length>0&&arguments[0]!==void 0?arguments[0]:!0;return e=>(f?Qe:nb)(e)}function Fd(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"div",t=arguments.length>2?arguments[2]:void 0;return Qe({name:t!=null?t:Cr(pn(f.replace(/__/g,"-"))),props:{tag:{type:String,default:e}},setup(s,i){let{slots:n}=i;return()=>{var r;return Sa(s.tag,{class:f},(r=n.default)==null?void 0:r.call(n))}}})}function AC(f){if(typeof f.getRootNode!="function"){for(;f.parentNode;)f=f.parentNode;return f!==document?null:document}const e=f.getRootNode();return e!==document&&e.getRootNode({composed:!0})!==document?null:e}const ol="cubic-bezier(0.4, 0, 0.2, 1)",rK="cubic-bezier(0.0, 0, 0.2, 1)",aK="cubic-bezier(0.4, 0, 1, 1)";function oK(f){for(;f;){if(Fb(f))return f;f=f.parentElement}return document.scrollingElement}function dl(f,e){const t=[];if(e&&f&&!e.contains(f))return t;for(;f&&(Fb(f)&&t.push(f),f!==e);)f=f.parentElement;return t}function Fb(f){if(!f||f.nodeType!==Node.ELEMENT_NODE)return!1;const e=window.getComputedStyle(f);return e.overflowY==="scroll"||e.overflowY==="auto"&&f.scrollHeight>f.clientHeight}const ds=typeof window<"u",Db=ds&&"IntersectionObserver"in window,dK=ds&&("ontouchstart"in window||window.navigator.maxTouchPoints>0),xy=ds&&typeof CSS<"u"&&CSS.supports("selector(:focus-visible)");function cK(f){for(;f;){if(window.getComputedStyle(f).position==="fixed")return!0;f=f.offsetParent}return!1}function Xe(f){const e=ii("useRender");e.render=f}const uK=Fd("v-alert-title");const Nr=Ye({border:[Boolean,Number,String]},"border");function Vr(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Br();return{borderClasses:ie(()=>{const s=Qt(f)?f.value:f.border,i=[];if(s===!0||s==="")i.push(`${e}--border`);else if(typeof s=="string"||s===0)for(const n of String(s).split(" "))i.push(`border-${n}`);return i})}}const fK=[null,"default","comfortable","compact"],Vn=Ye({density:{type:String,default:"default",validator:f=>fK.includes(f)}},"density");function dr(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Br();return{densityClasses:ie(()=>`${e}--density-${f.density}`)}}const cr=Ye({elevation:{type:[Number,String],validator(f){const e=parseInt(f);return!isNaN(e)&&e>=0&&e<=24}}},"elevation");function ur(f){return{elevationClasses:ie(()=>{const t=Qt(f)?f.value:f.elevation,s=[];return t==null||s.push(`elevation-${t}`),s})}}const gn=Ye({rounded:{type:[Boolean,Number,String],default:void 0}},"rounded");function yn(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Br();return{roundedClasses:ie(()=>{const s=Qt(f)?f.value:f.rounded,i=[];if(s===!0||s==="")i.push(`${e}--rounded`);else if(typeof s=="string"||s===0)for(const n of String(s).split(" "))i.push(`rounded-${n}`);return i})}}const cs=Ye({tag:{type:String,default:"div"}},"tag"),td=2.4,VO=.2126729,qO=.7151522,LO=.072175,hK=.55,lK=.58,pK=.57,mK=.62,Eh=.03,RO=1.45,gK=5e-4,yK=1.25,bK=1.25,FO=.078,DO=12.82051282051282,Nh=.06,HO=.001;function GO(f,e){const t=((f>>16&255)/255)**td,s=((f>>8&255)/255)**td,i=((f>>0&255)/255)**td,n=((e>>16&255)/255)**td,r=((e>>8&255)/255)**td,a=((e>>0&255)/255)**td;let o=t*VO+s*qO+i*LO,d=n*VO+r*qO+a*LO;if(o<=Eh&&(o+=(Eh-o)**RO),d<=Eh&&(d+=(Eh-d)**RO),Math.abs(d-o)<gK)return 0;let c;if(d>o){const u=(d**hK-o**lK)*yK;c=u<HO?0:u<FO?u-u*DO*Nh:u-Nh}else{const u=(d**mK-o**pK)*bK;c=u>-HO?0:u>-FO?u-u*DO*Nh:u+Nh}return c*100}const cl=Symbol.for("vuetify:theme"),_s=Ye({theme:String},"theme"),su={defaultTheme:"light",variations:{colors:[],lighten:0,darken:0},themes:{light:{dark:!1,colors:{background:"#FFFFFF",surface:"#FFFFFF","surface-variant":"#424242","on-surface-variant":"#EEEEEE",primary:"#6200EE","primary-darken-1":"#3700B3",secondary:"#03DAC6","secondary-darken-1":"#018786",error:"#B00020",info:"#2196F3",success:"#4CAF50",warning:"#FB8C00"},variables:{"border-color":"#000000","border-opacity":.12,"high-emphasis-opacity":.87,"medium-emphasis-opacity":.6,"disabled-opacity":.38,"idle-opacity":.04,"hover-opacity":.04,"focus-opacity":.12,"selected-opacity":.08,"activated-opacity":.12,"pressed-opacity":.12,"dragged-opacity":.08,"theme-kbd":"#212529","theme-on-kbd":"#FFFFFF","theme-code":"#F5F5F5","theme-on-code":"#000000"}},dark:{dark:!0,colors:{background:"#121212",surface:"#212121","surface-variant":"#BDBDBD","on-surface-variant":"#424242",primary:"#BB86FC","primary-darken-1":"#3700B3",secondary:"#03DAC5","secondary-darken-1":"#03DAC5",error:"#CF6679",info:"#2196F3",success:"#4CAF50",warning:"#FB8C00"},variables:{"border-color":"#FFFFFF","border-opacity":.12,"high-emphasis-opacity":.87,"medium-emphasis-opacity":.6,"disabled-opacity":.38,"idle-opacity":.1,"hover-opacity":.04,"focus-opacity":.12,"selected-opacity":.08,"activated-opacity":.12,"pressed-opacity":.16,"dragged-opacity":.08,"theme-kbd":"#212529","theme-on-kbd":"#FFFFFF","theme-code":"#343434","theme-on-code":"#CCCCCC"}}}};function wK(){var i;let f=arguments.length>0&&arguments[0]!==void 0?arguments[0]:su;if(!f)return{...su,isDisabled:!0};const e={};for(const[n,r]of Object.entries((i=f.themes)!=null?i:{})){var t,s;const a=r.dark||n==="dark"?(t=su.themes)==null?void 0:t.dark:(s=su.themes)==null?void 0:s.light;e[n]=xr(a,r)}return xr(su,{...f,themes:e})}function kK(f){const e=ti(wK(f)),t=fe(e.defaultTheme),s=fe(e.themes),i=ie(()=>{const d={};for(const[c,u]of Object.entries(s.value)){const h=d[c]={...u,colors:{...u.colors}};if(e.variations)for(const l of e.variations.colors){const p=h.colors[l];if(!!p)for(const m of["lighten","darken"]){const g=m==="lighten"?Jz:eK;for(const y of Lz(e.variations[m],1))h.colors[`${l}-${m}-${y}`]=Zz(g(al(p),y))}}for(const l of Object.keys(h.colors)){if(/^on-[a-z]/.test(l)||h.colors[`on-${l}`])continue;const p=`on-${l}`,m=al(h.colors[l]),g=Math.abs(GO(0,m)),y=Math.abs(GO(16777215,m));h.colors[p]=y>Math.min(g,50)?"#fff":"#000"}}return d}),n=ie(()=>i.value[t.value]),r=ie(()=>{const d=[];n.value.dark&&sd(d,":root",["color-scheme: dark"]);for(const[l,p]of Object.entries(i.value)){const{variables:m,dark:g}=p;sd(d,`.v-theme--${l}`,[`color-scheme: ${g?"dark":"normal"}`,...SK(p),...Object.keys(m).map(y=>{const b=m[y],w=typeof b=="string"&&b.startsWith("#")?CC(b):void 0,k=w?`${w.r}, ${w.g}, ${w.b}`:void 0;return`--v-${y}: ${k!=null?k:b}`})])}const c=[],u=[],h=new Set(Object.values(i.value).flatMap(l=>Object.keys(l.colors)));for(const l of h)/^on-[a-z]/.test(l)?sd(u,`.${l}`,[`color: rgb(var(--v-theme-${l})) !important`]):(sd(c,`.bg-${l}`,[`--v-theme-overlay-multiplier: var(--v-theme-${l}-overlay-multiplier)`,`background: rgb(var(--v-theme-${l})) !important`,`color: rgb(var(--v-theme-on-${l})) !important`]),sd(u,`.text-${l}`,[`color: rgb(var(--v-theme-${l})) !important`]),sd(u,`.border-${l}`,[`--v-border-color: var(--v-theme-${l})`]));return d.push(...c,...u),d.map((l,p)=>p===0?l:`    ${l}`).join("")});function a(d){const c=d._context.provides.usehead;if(c)c.addHeadObjs(ie(()=>{const u={children:r.value,type:"text/css",id:"vuetify-theme-stylesheet"};return e.cspNonce&&(u.nonce=e.cspNonce),{style:[u]}})),ds&&Mr(()=>c.updateDOM());else{let h=function(){if(!e.isDisabled){if(typeof document<"u"&&!u){const l=document.createElement("style");l.type="text/css",l.id="vuetify-theme-stylesheet",e.cspNonce&&l.setAttribute("nonce",e.cspNonce),u=l,document.head.appendChild(u)}u&&(u.innerHTML=r.value)}},u=ds?document.getElementById("vuetify-theme-stylesheet"):null;st(r,h,{immediate:!0})}}const o=ie(()=>e.isDisabled?void 0:`v-theme--${t.value}`);return{install:a,isDisabled:e.isDisabled,name:t,themes:s,current:n,computedThemes:i,themeClasses:o,styles:r,global:{name:t,current:n}}}function Rs(f){ii("provideTheme");const e=Zt(cl,null);if(!e)throw new Error("Could not find Vuetify theme injection");const t=ie(()=>{var n;return(n=f.theme)!=null?n:e==null?void 0:e.name.value}),s=ie(()=>e.isDisabled?void 0:`v-theme--${t.value}`),i={...e,name:t,themeClasses:s};return Ni(cl,i),i}function sd(f,e,t){f.push(`${e} {
`,...t.map(s=>`  ${s};
`),`}
`)}function SK(f){const e=f.dark?2:1,t=f.dark?1:2,s=[];for(const[i,n]of Object.entries(f.colors)){const r=CC(n);s.push(`--v-theme-${i}: ${r.r},${r.g},${r.b}`),i.startsWith("on-")||s.push(`--v-theme-${i}-overlay-multiplier: ${tK(n)>.18?e:t}`)}return s}function Hb(f){return qb(()=>{const e=[],t={};return f.value.background&&(NO(f.value.background)?t.backgroundColor=f.value.background:e.push(`bg-${f.value.background}`)),f.value.text&&(NO(f.value.text)?(t.color=f.value.text,t.caretColor=f.value.text):e.push(`text-${f.value.text}`)),{colorClasses:e,colorStyles:t}})}function _r(f,e){const t=ie(()=>({text:Qt(f)?f.value:e?f[e]:null})),{colorClasses:s,colorStyles:i}=Hb(t);return{textColorClasses:s,textColorStyles:i}}function nr(f,e){const t=ie(()=>({background:Qt(f)?f.value:e?f[e]:null})),{colorClasses:s,colorStyles:i}=Hb(t);return{backgroundColorClasses:s,backgroundColorStyles:i}}const vK=["elevated","flat","tonal","outlined","text","plain"];function Dd(f,e){return $(Ft,null,[f&&$("span",{key:"overlay",class:`${e}__overlay`},null),$("span",{key:"underlay",class:`${e}__underlay`},null)])}const qr=Ye({color:String,variant:{type:String,default:"elevated",validator:f=>vK.includes(f)}},"variant");function Hd(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Br();const t=ie(()=>{const{variant:n}=ei(f);return`${e}--variant-${n}`}),{colorClasses:s,colorStyles:i}=Hb(ie(()=>{const{variant:n,color:r}=ei(f);return{[["elevated","flat"].includes(n)?"background":"text"]:r}}));return{colorClasses:s,colorStyles:i,variantClasses:t}}const TK=Qe({name:"VBtnGroup",props:{divided:Boolean,...Nr(),...Vn(),...cr(),...gn(),...cs(),..._s(),...qr()},setup(f,e){let{slots:t}=e;const{themeClasses:s}=Rs(f),{densityClasses:i}=dr(f),{borderClasses:n}=Vr(f),{elevationClasses:r}=ur(f),{roundedClasses:a}=yn(f);Er({VBtn:{height:"auto",color:je(f,"color"),density:je(f,"density"),flat:!0,variant:je(f,"variant")}}),Xe(()=>$(f.tag,{class:["v-btn-group",{"v-btn-group--divided":f.divided},s.value,n.value,i.value,r.value,a.value]},t))}});function Vt(f,e,t){let s=arguments.length>3&&arguments[3]!==void 0?arguments[3]:u=>u,i=arguments.length>4&&arguments[4]!==void 0?arguments[4]:u=>u;const n=ii("useProxiedModel"),r=fe(f[e]!==void 0?f[e]:t),a=Xl(e),d=ie(a!==e?()=>{var u,h,l,p;return f[e],!!(((u=n.vnode.props)!=null&&u.hasOwnProperty(e)||(h=n.vnode.props)!=null&&h.hasOwnProperty(a))&&((l=n.vnode.props)!=null&&l.hasOwnProperty(`onUpdate:${e}`)||(p=n.vnode.props)!=null&&p.hasOwnProperty(`onUpdate:${a}`)))}:()=>{var u,h;return f[e],!!((u=n.vnode.props)!=null&&u.hasOwnProperty(e)&&(h=n.vnode.props)!=null&&h.hasOwnProperty(`onUpdate:${e}`))});Td(()=>!d.value,()=>{st(()=>f[e],u=>{r.value=u})});const c=ie({get(){return s(d.value?f[e]:r.value)},set(u){const h=i(u);(d.value?f[e]:r.value)===h||s(d.value?f[e]:r.value)===u||(r.value=h,n==null||n.emit(`update:${e}`,h))}});return Object.defineProperty(c,"externalValue",{get:()=>d.value?f[e]:r.value}),c}const BC=Ye({modelValue:{type:null,default:void 0},multiple:Boolean,mandatory:[Boolean,String],max:Number,selectedClass:String,disabled:Boolean},"group"),EC=Ye({value:null,disabled:Boolean,selectedClass:String},"group-item");function NC(f,e){let t=arguments.length>2&&arguments[2]!==void 0?arguments[2]:!0;const s=ii("useGroupItem");if(!s)throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");const i=$i();Ni(Symbol.for(`${e.description}:id`),i);const n=Zt(e,null);if(!n){if(!t)return n;throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${e.description}`)}const r=je(f,"value"),a=ie(()=>n.disabled.value||f.disabled);n.register({id:i,value:r,disabled:a},s),mn(()=>{n.unregister(i)});const o=ie(()=>n.isSelected(i)),d=ie(()=>o.value&&[n.selectedClass.value,f.selectedClass]);return st(o,c=>{s.emit("group:selected",{value:c})}),{id:i,isSelected:o,toggle:()=>n.select(i,!o.value),select:c=>n.select(i,c),selectedClass:d,value:r,disabled:a,group:n}}function VC(f,e){let t=!1;const s=ti([]),i=Vt(f,"modelValue",[],h=>h==null?[]:qC(s,tr(h)),h=>{const l=IK(s,h);return f.multiple?l:l[0]}),n=ii("useGroup");function r(h,l){const p=h,m=Symbol.for(`${e.description}:id`),y=gu(m,n==null?void 0:n.vnode).indexOf(l);y>-1?s.splice(y,0,p):s.push(p)}function a(h){if(t)return;o();const l=s.findIndex(p=>p.id===h);s.splice(l,1)}function o(){const h=s.find(l=>!l.disabled);h&&f.mandatory==="force"&&!i.value.length&&(i.value=[h.id])}ar(()=>{o()}),mn(()=>{t=!0});function d(h,l){const p=s.find(m=>m.id===h);if(!(l&&p!=null&&p.disabled))if(f.multiple){const m=i.value.slice(),g=m.findIndex(b=>b===h),y=~g;if(l=l!=null?l:!y,y&&f.mandatory&&m.length<=1||!y&&f.max!=null&&m.length+1>f.max)return;g<0&&l?m.push(h):g>=0&&!l&&m.splice(g,1),i.value=m}else{const m=i.value.includes(h);if(f.mandatory&&m)return;i.value=(l!=null?l:!m)?[h]:[]}}function c(h){if(f.multiple&&yd('This method is not supported when using "multiple" prop'),i.value.length){const l=i.value[0],p=s.findIndex(y=>y.id===l);let m=(p+h)%s.length,g=s[m];for(;g.disabled&&m!==p;)m=(m+h)%s.length,g=s[m];if(g.disabled)return;i.value=[s[m].id]}else{const l=s.find(p=>!p.disabled);l&&(i.value=[l.id])}}const u={register:r,unregister:a,selected:i,select:d,disabled:je(f,"disabled"),prev:()=>c(s.length-1),next:()=>c(1),isSelected:h=>i.value.includes(h),selectedClass:ie(()=>f.selectedClass),items:ie(()=>s),getItemIndex:h=>OK(s,h)};return Ni(e,u),u}function OK(f,e){const t=qC(f,[e]);return t.length?f.findIndex(s=>s.id===t[0]):-1}function qC(f,e){const t=[];for(let s=0;s<f.length;s++){const i=f[s];i.value!=null?e.find(n=>zl(n,i.value))!=null&&t.push(i.id):e.includes(s)&&t.push(i.id)}return t}function IK(f,e){const t=[];for(let s=0;s<f.length;s++){const i=f[s];e.includes(i.id)&&t.push(i.value!=null?i.value:s)}return t}const LC=Symbol.for("vuetify:v-btn-toggle");zs()({name:"VBtnToggle",props:BC(),emits:{"update:modelValue":f=>!0},setup(f,e){let{slots:t}=e;const{isSelected:s,next:i,prev:n,select:r,selected:a}=VC(f,LC);return Xe(()=>{var o;return $(TK,{class:"v-btn-toggle"},{default:()=>[(o=t.default)==null?void 0:o.call(t,{isSelected:s,next:i,prev:n,select:r,selected:a})]})}),{next:i,prev:n,select:r}}});const xs=nb({name:"VDefaultsProvider",props:{defaults:Object,reset:[Number,String],root:Boolean,scoped:Boolean},setup(f,e){let{slots:t}=e;const{defaults:s,reset:i,root:n,scoped:r}=Jy(f);return Er(s,{reset:i,root:n,scoped:r}),()=>{var a;return(a=t.default)==null?void 0:a.call(t)}}});const xK={collapse:"mdi-chevron-up",complete:"mdi-check",cancel:"mdi-close-circle",close:"mdi-close",delete:"mdi-close-circle",clear:"mdi-close-circle",success:"mdi-check-circle",info:"mdi-information",warning:"mdi-alert-circle",error:"mdi-close-circle",prev:"mdi-chevron-left",next:"mdi-chevron-right",checkboxOn:"mdi-checkbox-marked",checkboxOff:"mdi-checkbox-blank-outline",checkboxIndeterminate:"mdi-minus-box",delimiter:"mdi-circle",sort:"mdi-arrow-up",expand:"mdi-chevron-down",menu:"mdi-menu",subgroup:"mdi-menu-down",dropdown:"mdi-menu-down",radioOn:"mdi-radiobox-marked",radioOff:"mdi-radiobox-blank",edit:"mdi-pencil",ratingEmpty:"mdi-star-outline",ratingFull:"mdi-star",ratingHalf:"mdi-star-half-full",loading:"mdi-cached",first:"mdi-page-first",last:"mdi-page-last",unfold:"mdi-unfold-more-horizontal",file:"mdi-paperclip",plus:"mdi-plus",minus:"mdi-minus"},_K={component:f=>Sa(RC,{...f,class:"mdi"})},It=[String,Function,Object],_y=Symbol.for("vuetify:icons"),Yl=Ye({icon:{type:It,required:!0},tag:{type:String,required:!0}},"icon"),CK=Qe({name:"VComponentIcon",props:Yl(),setup(f){return()=>$(f.tag,null,{default:()=>[$(f.icon,null,null)]})}}),MK=Qe({name:"VSvgIcon",inheritAttrs:!1,props:Yl(),setup(f,e){let{attrs:t}=e;return()=>$(f.tag,Je(t,{style:null}),{default:()=>[$("svg",{class:"v-icon__svg",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",role:"img","aria-hidden":"true"},[$("path",{d:f.icon},null)])]})}});Qe({name:"VLigatureIcon",props:Yl(),setup(f){return()=>$(f.tag,null,{default:()=>[f.icon]})}});const RC=Qe({name:"VClassIcon",props:Yl(),setup(f){return()=>$(f.tag,{class:f.icon},null)}}),PK={svg:{component:MK},class:{component:RC}};function AK(f){return xr({defaultSet:"mdi",sets:{...PK,mdi:_K},aliases:xK},f)}const BK=f=>{const e=Zt(_y);if(!e)throw new Error("Missing Vuetify Icons provide!");return{iconData:ie(()=>{const s=Qt(f)?f.value:f.icon;if(!s)throw new Error("Icon value is undefined or null");let i=s;if(typeof i=="string"&&(i=i.trim(),i.startsWith("$"))){var n;i=(n=e.aliases)==null?void 0:n[i.slice(1)]}if(!i)throw new Error(`Could not find aliased icon "${s}"`);if(typeof i!="string")return{component:CK,icon:i};const r=Object.keys(e.sets).find(d=>typeof i=="string"&&i.startsWith(`${d}:`)),a=r?i.slice(r.length+1):i;return{component:e.sets[r!=null?r:e.defaultSet].component,icon:a}})}},EK=["x-small","small","default","large","x-large"],Uu=Ye({size:{type:[String,Number],default:"default"}},"size");function $u(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Br();return qb(()=>{let t,s;return nl(EK,f.size)?t=`${e}--size-${f.size}`:f.size&&(s={width:ze(f.size),height:ze(f.size)}),{sizeClasses:t,sizeStyles:s}})}const NK=Ye({color:String,start:Boolean,end:Boolean,icon:It,...Uu(),...cs({tag:"i"}),..._s()},"v-icon"),gi=Qe({name:"VIcon",props:NK(),setup(f,e){let{attrs:t,slots:s}=e,i;s.default&&(i=ie(()=>{var c,u;const h=(c=s.default)==null?void 0:c.call(s);if(!!h)return(u=SC(h).filter(l=>l.children&&typeof l.children=="string")[0])==null?void 0:u.children}));const{themeClasses:n}=Rs(f),{iconData:r}=BK(i||f),{sizeClasses:a}=$u(f),{textColorClasses:o,textColorStyles:d}=_r(je(f,"color"));return Xe(()=>$(r.value.component,{tag:f.tag,icon:r.value.icon,class:["v-icon","notranslate",n.value,a.value,o.value,{"v-icon--clickable":!!t.onClick,"v-icon--start":f.start,"v-icon--end":f.end}],style:[a.value?void 0:{fontSize:ze(f.size),height:ze(f.size),width:ze(f.size)},d.value],role:t.onClick?"button":void 0,"aria-hidden":!t.onClick},null)),{}}});function FC(f){const e=fe(),t=fe(!1);if(Db){const s=new IntersectionObserver(i=>{f==null||f(i,s),t.value=!!i.find(n=>n.isIntersecting)});mn(()=>{s.disconnect()}),st(e,(i,n)=>{n&&(s.unobserve(n),t.value=!1),i&&s.observe(i)},{flush:"post"})}return{intersectionRef:e,isIntersecting:t}}function Gb(f){const e=fe(),t=fe();if(ds){const s=new ResizeObserver(i=>{f==null||f(i,s),i.length&&(t.value=i[0].contentRect)});mn(()=>{s.disconnect()}),st(e,(i,n)=>{n&&(s.unobserve(n),t.value=void 0),i&&s.observe(i)},{flush:"post"})}return{resizeRef:e,contentRect:Eu(t)}}const VK=Qe({name:"VProgressCircular",props:{bgColor:String,color:String,indeterminate:[Boolean,String],modelValue:{type:[Number,String],default:0},rotate:{type:[Number,String],default:0},width:{type:[Number,String],default:4},...Uu(),...cs({tag:"div"}),..._s()},setup(f,e){let{slots:t}=e;const s=20,i=2*Math.PI*s,n=fe(),{themeClasses:r}=Rs(f),{sizeClasses:a,sizeStyles:o}=$u(f),{textColorClasses:d,textColorStyles:c}=_r(je(f,"color")),{textColorClasses:u,textColorStyles:h}=_r(je(f,"bgColor")),{intersectionRef:l,isIntersecting:p}=FC(),{resizeRef:m,contentRect:g}=Gb(),y=ie(()=>Math.max(0,Math.min(100,parseFloat(f.modelValue)))),b=ie(()=>Number(f.width)),w=ie(()=>o.value?Number(f.size):g.value?g.value.width:Math.max(b.value,32)),k=ie(()=>s/(1-b.value/w.value)*2),T=ie(()=>b.value/w.value*k.value),O=ie(()=>ze((100-y.value)/100*i));return Mr(()=>{l.value=n.value,m.value=n.value}),Xe(()=>$(f.tag,{ref:n,class:["v-progress-circular",{"v-progress-circular--indeterminate":!!f.indeterminate,"v-progress-circular--visible":p.value,"v-progress-circular--disable-shrink":f.indeterminate==="disable-shrink"},r.value,a.value,d.value],style:[o.value,c.value],role:"progressbar","aria-valuemin":"0","aria-valuemax":"100","aria-valuenow":f.indeterminate?void 0:y.value},{default:()=>[$("svg",{style:{transform:`rotate(calc(-90deg + ${Number(f.rotate)}deg))`},xmlns:"http://www.w3.org/2000/svg",viewBox:`0 0 ${k.value} ${k.value}`},[$("circle",{class:["v-progress-circular__underlay",u.value],style:h.value,fill:"transparent",cx:"50%",cy:"50%",r:s,"stroke-width":T.value,"stroke-dasharray":i,"stroke-dashoffset":0},null),$("circle",{class:"v-progress-circular__overlay",fill:"transparent",cx:"50%",cy:"50%",r:s,"stroke-width":T.value,"stroke-dasharray":i,"stroke-dashoffset":O.value},null)]),t.default&&$("div",{class:"v-progress-circular__content"},[t.default({value:y.value})])]})),{}}});const Cy=Symbol("rippleStop"),qK=80;function UO(f,e){f.style.transform=e,f.style.webkitTransform=e}function jg(f,e){f.style.opacity=`calc(${e} * var(--v-theme-overlay-multiplier))`}function My(f){return f.constructor.name==="TouchEvent"}function DC(f){return f.constructor.name==="KeyboardEvent"}const LK=function(f,e){var t;let s=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},i=0,n=0;if(!DC(f)){const h=e.getBoundingClientRect(),l=My(f)?f.touches[f.touches.length-1]:f;i=l.clientX-h.left,n=l.clientY-h.top}let r=0,a=.3;(t=e._ripple)!=null&&t.circle?(a=.15,r=e.clientWidth/2,r=s.center?r:r+Math.sqrt((i-r)**2+(n-r)**2)/4):r=Math.sqrt(e.clientWidth**2+e.clientHeight**2)/2;const o=`${(e.clientWidth-r*2)/2}px`,d=`${(e.clientHeight-r*2)/2}px`,c=s.center?o:`${i-r}px`,u=s.center?d:`${n-r}px`;return{radius:r,scale:a,x:c,y:u,centerX:o,centerY:d}},ul={show(f,e){var t;let s=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};if(!(e!=null&&(t=e._ripple)!=null&&t.enabled))return;const i=document.createElement("span"),n=document.createElement("span");i.appendChild(n),i.className="v-ripple__container",s.class&&(i.className+=` ${s.class}`);const{radius:r,scale:a,x:o,y:d,centerX:c,centerY:u}=LK(f,e,s),h=`${r*2}px`;n.className="v-ripple__animation",n.style.width=h,n.style.height=h,e.appendChild(i);const l=window.getComputedStyle(e);l&&l.position==="static"&&(e.style.position="relative",e.dataset.previousPosition="static"),n.classList.add("v-ripple__animation--enter"),n.classList.add("v-ripple__animation--visible"),UO(n,`translate(${o}, ${d}) scale3d(${a},${a},${a})`),jg(n,0),n.dataset.activated=String(performance.now()),setTimeout(()=>{n.classList.remove("v-ripple__animation--enter"),n.classList.add("v-ripple__animation--in"),UO(n,`translate(${c}, ${u}) scale3d(1,1,1)`),jg(n,.08)},0)},hide(f){var e;if(!(f!=null&&(e=f._ripple)!=null&&e.enabled))return;const t=f.getElementsByClassName("v-ripple__animation");if(t.length===0)return;const s=t[t.length-1];if(s.dataset.isHiding)return;s.dataset.isHiding="true";const i=performance.now()-Number(s.dataset.activated),n=Math.max(250-i,0);setTimeout(()=>{s.classList.remove("v-ripple__animation--in"),s.classList.add("v-ripple__animation--out"),jg(s,0),setTimeout(()=>{f.getElementsByClassName("v-ripple__animation").length===1&&f.dataset.previousPosition&&(f.style.position=f.dataset.previousPosition,delete f.dataset.previousPosition),s.parentNode&&f.removeChild(s.parentNode)},300)},n)}};function HC(f){return typeof f>"u"||!!f}function Pu(f){const e={},t=f.currentTarget;if(!(!(t!=null&&t._ripple)||t._ripple.touched||f[Cy])){if(f[Cy]=!0,My(f))t._ripple.touched=!0,t._ripple.isTouch=!0;else if(t._ripple.isTouch)return;if(e.center=t._ripple.centered||DC(f),t._ripple.class&&(e.class=t._ripple.class),My(f)){if(t._ripple.showTimerCommit)return;t._ripple.showTimerCommit=()=>{ul.show(f,t,e)},t._ripple.showTimer=window.setTimeout(()=>{var s;t!=null&&(s=t._ripple)!=null&&s.showTimerCommit&&(t._ripple.showTimerCommit(),t._ripple.showTimerCommit=null)},qK)}else ul.show(f,t,e)}}function $O(f){f[Cy]=!0}function Fi(f){const e=f.currentTarget;if(!(!e||!e._ripple)){if(window.clearTimeout(e._ripple.showTimer),f.type==="touchend"&&e._ripple.showTimerCommit){e._ripple.showTimerCommit(),e._ripple.showTimerCommit=null,e._ripple.showTimer=window.setTimeout(()=>{Fi(f)});return}window.setTimeout(()=>{e._ripple&&(e._ripple.touched=!1)}),ul.hide(e)}}function GC(f){const e=f.currentTarget;!e||!e._ripple||(e._ripple.showTimerCommit&&(e._ripple.showTimerCommit=null),window.clearTimeout(e._ripple.showTimer))}let Au=!1;function UC(f){!Au&&(f.keyCode===MO.enter||f.keyCode===MO.space)&&(Au=!0,Pu(f))}function $C(f){Au=!1,Fi(f)}function jC(f){Au&&(Au=!1,Fi(f))}function WC(f,e,t){var r;const{value:s,modifiers:i}=e,n=HC(s);if(n||ul.hide(f),f._ripple=(r=f._ripple)!=null?r:{},f._ripple.enabled=n,f._ripple.centered=i.center,f._ripple.circle=i.circle,Sy(s)&&s.class&&(f._ripple.class=s.class),n&&!t){if(i.stop){f.addEventListener("touchstart",$O,{passive:!0}),f.addEventListener("mousedown",$O);return}f.addEventListener("touchstart",Pu,{passive:!0}),f.addEventListener("touchend",Fi,{passive:!0}),f.addEventListener("touchmove",GC,{passive:!0}),f.addEventListener("touchcancel",Fi),f.addEventListener("mousedown",Pu),f.addEventListener("mouseup",Fi),f.addEventListener("mouseleave",Fi),f.addEventListener("keydown",UC),f.addEventListener("keyup",$C),f.addEventListener("blur",jC),f.addEventListener("dragstart",Fi,{passive:!0})}else!n&&t&&zC(f)}function zC(f){f.removeEventListener("mousedown",Pu),f.removeEventListener("touchstart",Pu),f.removeEventListener("touchend",Fi),f.removeEventListener("touchmove",GC),f.removeEventListener("touchcancel",Fi),f.removeEventListener("mouseup",Fi),f.removeEventListener("mouseleave",Fi),f.removeEventListener("keydown",UC),f.removeEventListener("keyup",$C),f.removeEventListener("dragstart",Fi),f.removeEventListener("blur",jC)}function RK(f,e){WC(f,e,!1)}function FK(f){delete f._ripple,zC(f)}function DK(f,e){if(e.value===e.oldValue)return;const t=HC(e.oldValue);WC(f,e,t)}const ju={mounted:RK,unmounted:FK,updated:DK},ko=Ye({height:[Number,String],maxHeight:[Number,String],maxWidth:[Number,String],minHeight:[Number,String],minWidth:[Number,String],width:[Number,String]},"dimension");function So(f){return{dimensionStyles:ie(()=>({height:ze(f.height),maxHeight:ze(f.maxHeight),maxWidth:ze(f.maxWidth),minHeight:ze(f.minHeight),minWidth:ze(f.minWidth),width:ze(f.width)}))}}const HK={badge:"Badge",close:"Close",dataIterator:{noResultsText:"No matching records found",loadingText:"Loading items..."},dataTable:{itemsPerPageText:"Rows per page:",ariaLabel:{sortDescending:"Sorted descending.",sortAscending:"Sorted ascending.",sortNone:"Not sorted.",activateNone:"Activate to remove sorting.",activateDescending:"Activate to sort descending.",activateAscending:"Activate to sort ascending."},sortBy:"Sort by"},dataFooter:{itemsPerPageText:"Items per page:",itemsPerPageAll:"All",nextPage:"Next page",prevPage:"Previous page",firstPage:"First page",lastPage:"Last page",pageText:"{0}-{1} of {2}"},datePicker:{itemsSelected:"{0} selected",nextMonthAriaLabel:"Next month",nextYearAriaLabel:"Next year",prevMonthAriaLabel:"Previous month",prevYearAriaLabel:"Previous year"},noDataText:"No data available",carousel:{prev:"Previous visual",next:"Next visual",ariaLabel:{delimiter:"Carousel slide {0} of {1}"}},calendar:{moreEvents:"{0} more"},input:{clear:"Clear {0}",prependAction:"{0} prepended action",appendAction:"{0} appended action"},fileInput:{counter:"{0} files",counterSize:"{0} files ({1} in total)"},timePicker:{am:"AM",pm:"PM"},pagination:{ariaLabel:{root:"Pagination Navigation",next:"Next page",previous:"Previous page",page:"Goto Page {0}",currentPage:"Page {0}, Current Page",first:"First page",last:"Last page"}},rating:{ariaLabel:{item:"Rating {0} of {1}"}}},jO="$vuetify.",WO=(f,e)=>f.replace(/\{(\d+)\}/g,(t,s)=>String(e[+s])),KC=(f,e,t)=>function(s){for(var i=arguments.length,n=new Array(i>1?i-1:0),r=1;r<i;r++)n[r-1]=arguments[r];if(!s.startsWith(jO))return WO(s,n);const a=s.replace(jO,""),o=f.value&&t.value[f.value],d=e.value&&t.value[e.value];let c=ky(o,a,null);return c||(yd(`Translation key "${s}" not found in "${f.value}", trying fallback locale`),c=ky(d,a,null)),c||(Iy(`Translation key "${s}" not found in fallback`),c=s),typeof c!="string"&&(Iy(`Translation key "${s}" has a non-string value`),c=s),WO(c,n)};function XC(f,e){return(t,s)=>new Intl.NumberFormat([f.value,e.value],s).format(t)}function Wg(f,e,t){var i,n;const s=Vt(f,e,(i=f[e])!=null?i:t.value);return s.value=(n=f[e])!=null?n:t.value,st(t,r=>{f[e]==null&&(s.value=t.value)}),s}function YC(f){return e=>{const t=Wg(e,"locale",f.current),s=Wg(e,"fallback",f.fallback),i=Wg(e,"messages",f.messages);return{name:"vuetify",current:t,fallback:s,messages:i,t:KC(t,s,i),n:XC(t,s),provide:YC({current:t,fallback:s,messages:i})}}}function GK(f){var i,n;const e=fe((i=f==null?void 0:f.locale)!=null?i:"en"),t=fe((n=f==null?void 0:f.fallback)!=null?n:"en"),s=fe({en:HK,...f==null?void 0:f.messages});return{name:"vuetify",current:e,fallback:t,messages:s,t:KC(e,t,s),n:XC(e,t),provide:YC({current:e,fallback:t,messages:s})}}const UK={af:!1,ar:!0,bg:!1,ca:!1,ckb:!1,cs:!1,de:!1,el:!1,en:!1,es:!1,et:!1,fa:!1,fi:!1,fr:!1,hr:!1,hu:!1,he:!0,id:!1,it:!1,ja:!1,ko:!1,lv:!1,lt:!1,nl:!1,no:!1,pl:!1,pt:!1,ro:!1,ru:!1,sk:!1,sl:!1,srCyrl:!1,srLatn:!1,sv:!1,th:!1,tr:!1,az:!1,uk:!1,vi:!1,zhHans:!1,zhHant:!1},fl=Symbol.for("vuetify:locale");function $K(f){return f.name!=null}function jK(f){const e=f!=null&&f.adapter&&$K(f==null?void 0:f.adapter)?f==null?void 0:f.adapter:GK(f),t=WK(e,f);return{...e,...t}}function Ql(){const f=Zt(fl);if(!f)throw new Error("[Vuetify] Could not find injected locale instance");return f}function WK(f,e){var i;const t=fe((i=e==null?void 0:e.rtl)!=null?i:UK),s=ie(()=>{var n;return(n=t.value[f.current.value])!=null?n:!1});return{isRtl:s,rtl:t,rtlClasses:ie(()=>`v-locale--is-${s.value?"rtl":"ltr"}`)}}function Wu(){const f=Zt(fl);if(!f)throw new Error("[Vuetify] Could not find injected rtl instance");return{isRtl:f.isRtl,rtlClasses:f.rtlClasses}}const zK=Qe({name:"VProgressLinear",props:{active:{type:Boolean,default:!0},bgColor:String,bgOpacity:[Number,String],bufferValue:{type:[Number,String],default:0},clickable:Boolean,color:String,height:{type:[Number,String],default:4},indeterminate:Boolean,max:{type:[Number,String],default:100},modelValue:{type:[Number,String],default:0},reverse:Boolean,stream:Boolean,striped:Boolean,roundedBar:Boolean,...gn(),...cs(),..._s()},emits:{"update:modelValue":f=>!0},setup(f,e){let{slots:t}=e;const s=Vt(f,"modelValue"),{isRtl:i}=Wu(),{themeClasses:n}=Rs(f),{textColorClasses:r,textColorStyles:a}=_r(f,"color"),{backgroundColorClasses:o,backgroundColorStyles:d}=nr(ie(()=>f.bgColor||f.color)),{backgroundColorClasses:c,backgroundColorStyles:u}=nr(f,"color"),{roundedClasses:h}=yn(f),{intersectionRef:l,isIntersecting:p}=FC(),m=ie(()=>parseInt(f.max,10)),g=ie(()=>parseInt(f.height,10)),y=ie(()=>parseFloat(f.bufferValue)/m.value*100),b=ie(()=>parseFloat(s.value)/m.value*100),w=ie(()=>i.value!==f.reverse),k=ie(()=>f.indeterminate?"fade-transition":"slide-x-transition"),T=ie(()=>f.bgOpacity==null?f.bgOpacity:parseFloat(f.bgOpacity));function O(x){if(!l.value)return;const{left:C,right:E,width:P}=l.value.getBoundingClientRect(),_=w.value?P-x.clientX+(E-P):x.clientX-C;s.value=Math.round(_/P*m.value)}return Xe(()=>$(f.tag,{ref:l,class:["v-progress-linear",{"v-progress-linear--active":f.active&&p.value,"v-progress-linear--reverse":w.value,"v-progress-linear--rounded":f.rounded,"v-progress-linear--rounded-bar":f.roundedBar,"v-progress-linear--striped":f.striped},h.value,n.value],style:{height:f.active?ze(g.value):0,"--v-progress-linear-height":ze(g.value)},role:"progressbar","aria-hidden":f.active?"false":"true","aria-valuemin":"0","aria-valuemax":f.max,"aria-valuenow":f.indeterminate?void 0:b.value,onClick:f.clickable&&O},{default:()=>[f.stream&&$("div",{key:"stream",class:["v-progress-linear__stream",r.value],style:{...a.value,[w.value?"left":"right"]:ze(-g.value),borderTop:`${ze(g.value/2)} dotted`,opacity:T.value,top:`calc(50% - ${ze(g.value/4)})`,width:ze(100-y.value,"%"),"--v-progress-linear-stream-to":ze(g.value*(w.value?1:-1))}},null),$("div",{class:["v-progress-linear__background",o.value],style:[d.value,{opacity:T.value,width:ze(f.stream?y.value:100,"%")}]},null),$(sr,{name:k.value},{default:()=>[f.indeterminate?$("div",{class:"v-progress-linear__indeterminate"},[["long","short"].map(x=>$("div",{key:x,class:["v-progress-linear__indeterminate",x,c.value],style:u.value},null))]):$("div",{class:["v-progress-linear__determinate",c.value],style:[u.value,{width:ze(b.value,"%")}]},null)]}),t.default&&$("div",{class:"v-progress-linear__content"},[t.default({value:b.value,buffer:y.value})])]})),{}}}),Ub=Ye({loading:Boolean},"loader");function $b(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Br();return{loaderClasses:ie(()=>({[`${e}--loading`]:f.loading}))}}function QC(f,e){var t;let{slots:s}=e;return $("div",{class:`${f.name}__loader`},[((t=s.default)==null?void 0:t.call(s,{color:f.color,isActive:f.active}))||$(zK,{active:f.active,color:f.color,height:"2",indeterminate:!0},null)])}const zO={center:"center",top:"bottom",bottom:"top",left:"right",right:"left"},jb=Ye({location:String},"location");function Wb(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1,t=arguments.length>2?arguments[2]:void 0;const{isRtl:s}=Wu();return{locationStyles:ie(()=>{if(!f.location)return{};const{side:n,align:r}=Ty(f.location.split(" ").length>1?f.location:`${f.location} center`,s.value);function a(d){return t?t(d):0}const o={};return n!=="center"&&(e?o[zO[n]]=`calc(100% - ${a(n)}px)`:o[n]=0),r!=="center"?e?o[zO[r]]=`calc(100% - ${a(r)}px)`:o[r]=0:(n==="center"?o.top=o.left="50%":o[{top:"left",bottom:"left",left:"top",right:"top"}[n]]="50%",o.transform={top:"translateX(-50%)",bottom:"translateX(-50%)",left:"translateY(-50%)",right:"translateY(-50%)",center:"translate(-50%, -50%)"}[n]),o})}}const KK=["static","relative","fixed","absolute","sticky"],zb=Ye({position:{type:String,validator:f=>KK.includes(f)}},"position");function Kb(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Br();return{positionClasses:ie(()=>f.position?`${e}--${f.position}`:void 0)}}function ZC(){var f,e;return(f=ii("useRouter"))==null||(e=f.proxy)==null?void 0:e.$router}function Zl(f,e){const t=kP("RouterLink"),s=ie(()=>!!(f.href||f.to)),i=ie(()=>(s==null?void 0:s.value)||PO(e,"click")||PO(f,"click"));if(typeof t=="string")return{isLink:s,isClickable:i,href:je(f,"href")};const n=f.to?t.useLink(f):void 0;return{isLink:s,isClickable:i,route:n==null?void 0:n.route,navigate:n==null?void 0:n.navigate,isActive:n&&ie(()=>{var r,a;return f.exact?(r=n.isExactActive)==null?void 0:r.value:(a=n.isActive)==null?void 0:a.value}),href:ie(()=>f.to?n==null?void 0:n.route.value.href:f.href)}}const Jl=Ye({href:String,replace:Boolean,to:[String,Object],exact:Boolean},"router");let zg=!1;function XK(f,e){let t=!1,s,i;ds&&(Bi(()=>{window.addEventListener("popstate",n),s=f==null?void 0:f.beforeEach((r,a,o)=>{zg?t?e(o):o():setTimeout(()=>t?e(o):o()),zg=!0}),i=f==null?void 0:f.afterEach(()=>{zg=!1})}),rr(()=>{var r,a;window.removeEventListener("popstate",n),(r=s)==null||r(),(a=i)==null||a()}));function n(r){var a;(a=r.state)!=null&&a.replaced||(t=!0,setTimeout(()=>t=!1))}}function YK(f,e){st(()=>{var t;return(t=f.isActive)==null?void 0:t.value},t=>{f.isLink.value&&t&&e&&Bi(()=>{e(!0)})},{immediate:!0})}const ot=Qe({name:"VBtn",directives:{Ripple:ju},props:{active:{type:Boolean,default:void 0},symbol:{type:null,default:LC},flat:Boolean,icon:[Boolean,String,Function,Object],prependIcon:It,appendIcon:It,block:Boolean,stacked:Boolean,ripple:{type:Boolean,default:!0},...Nr(),...gn(),...Vn(),...ko(),...cr(),...EC(),...Ub(),...jb(),...zb(),...Jl(),...Uu(),...cs({tag:"button"}),..._s(),...qr({variant:"elevated"})},emits:{"group:selected":f=>!0},setup(f,e){let{attrs:t,slots:s}=e;const{themeClasses:i}=Rs(f),{borderClasses:n}=Vr(f),{colorClasses:r,colorStyles:a,variantClasses:o}=Hd(f),{densityClasses:d}=dr(f),{dimensionStyles:c}=So(f),{elevationClasses:u}=ur(f),{loaderClasses:h}=$b(f),{locationStyles:l}=Wb(f),{positionClasses:p}=Kb(f),{roundedClasses:m}=yn(f),{sizeClasses:g,sizeStyles:y}=$u(f),b=NC(f,f.symbol,!1),w=Zl(f,t),k=ie(()=>{var x;return f.active!==!1&&(f.active||((x=w.isActive)==null?void 0:x.value)||(b==null?void 0:b.isSelected.value))}),T=ie(()=>(b==null?void 0:b.disabled.value)||f.disabled),O=ie(()=>f.variant==="elevated"&&!(f.disabled||f.flat||f.border));return YK(w,b==null?void 0:b.select),Xe(()=>{var x,C,E,P;const _=w.isLink.value?"a":f.tag,S=!b||b.isSelected.value,I=!!(f.prependIcon||s.prepend),v=!!(f.appendIcon||s.append),N=!!(f.icon&&f.icon!==!0);return Gi($(_,{type:_==="a"?void 0:"button",class:["v-btn",b==null?void 0:b.selectedClass.value,{"v-btn--active":k.value,"v-btn--block":f.block,"v-btn--disabled":T.value,"v-btn--elevated":O.value,"v-btn--flat":f.flat,"v-btn--icon":!!f.icon,"v-btn--loading":f.loading,"v-btn--stacked":f.stacked},i.value,n.value,S?r.value:void 0,d.value,u.value,h.value,p.value,m.value,g.value,o.value],style:[S?a.value:void 0,c.value,l.value,y.value],disabled:T.value||void 0,href:w.href.value,onClick:q=>{var R;T.value||((R=w.navigate)==null||R.call(w,q),b==null||b.toggle())}},{default:()=>{var q;return[Dd(!0,"v-btn"),!f.icon&&I&&$(xs,{key:"prepend",defaults:{VIcon:{icon:f.prependIcon}}},{default:()=>{var R;return[$("span",{class:"v-btn__prepend"},[(R=(x=s.prepend)==null?void 0:x.call(s))!=null?R:$(gi,null,null)])]}}),$("span",{class:"v-btn__content","data-no-activator":""},[$(xs,{key:"content",defaults:{VIcon:{icon:N?f.icon:void 0}}},{default:()=>{var R;return[(R=(C=s.default)==null?void 0:C.call(s))!=null?R:N&&$(gi,{key:"icon"},null)]}})]),!f.icon&&v&&$(xs,{key:"append",defaults:{VIcon:{icon:f.appendIcon}}},{default:()=>{var R;return[$("span",{class:"v-btn__append"},[(R=(E=s.append)==null?void 0:E.call(s))!=null?R:$(gi,null,null)])]}}),!!f.loading&&$("span",{key:"loader",class:"v-btn__loader"},[(q=(P=s.loader)==null?void 0:P.call(s))!=null?q:$(VK,{color:typeof f.loading=="boolean"?void 0:f.loading,indeterminate:!0,size:"23",width:"2"},null)])]}}),[[ka("ripple"),!T.value&&f.ripple,null]])}),{}}}),QK=["success","info","warning","error"],ZK=Qe({name:"VAlert",props:{border:{type:[Boolean,String],validator:f=>typeof f=="boolean"||["top","end","bottom","start"].includes(f)},borderColor:String,closable:Boolean,closeIcon:{type:It,default:"$close"},closeLabel:{type:String,default:"$vuetify.close"},icon:{type:[Boolean,String,Function,Object],default:null},modelValue:{type:Boolean,default:!0},prominent:Boolean,title:String,text:String,type:{type:String,validator:f=>QK.includes(f)},...Vn(),...ko(),...cr(),...jb(),...zb(),...gn(),...cs(),..._s(),...qr({variant:"flat"})},emits:{"update:modelValue":f=>!0},setup(f,e){let{slots:t}=e;const s=Vt(f,"modelValue"),i=ie(()=>{var k;if(f.icon!==!1)return f.type?(k=f.icon)!=null?k:`$${f.type}`:f.icon}),n=ie(()=>{var k;return{color:(k=f.color)!=null?k:f.type,variant:f.variant}}),{themeClasses:r}=Rs(f),{colorClasses:a,colorStyles:o,variantClasses:d}=Hd(n),{densityClasses:c}=dr(f),{dimensionStyles:u}=So(f),{elevationClasses:h}=ur(f),{locationStyles:l}=Wb(f),{positionClasses:p}=Kb(f),{roundedClasses:m}=yn(f),{textColorClasses:g,textColorStyles:y}=_r(je(f,"borderColor")),{t:b}=Ql(),w=ie(()=>({"aria-label":b(f.closeLabel),onClick(k){s.value=!1}}));return()=>{var k,T;const O=!!(t.prepend||i.value),x=!!(t.title||f.title),C=!!(f.text||t.text),E=!!(t.close||f.closable);return s.value&&$(f.tag,{class:["v-alert",f.border&&{"v-alert--border":!!f.border,[`v-alert--border-${f.border===!0?"start":f.border}`]:!0},{"v-alert--prominent":f.prominent},r.value,a.value,c.value,h.value,p.value,m.value,d.value],style:[o.value,u.value,l.value],role:"alert"},{default:()=>[Dd(!1,"v-alert"),f.border&&$("div",{key:"border",class:["v-alert__border",g.value],style:y.value},null),O&&$(xs,{key:"prepend",defaults:{VIcon:{density:f.density,icon:i.value,size:f.prominent?44:28}}},{default:()=>[$("div",{class:"v-alert__prepend"},[t.prepend?t.prepend():i.value&&$(gi,null,null)])]}),$("div",{class:"v-alert__content"},[x&&$(uK,{key:"title"},{default:()=>[t.title?t.title():f.title]}),C&&(t.text?t.text():f.text),(k=t.default)==null?void 0:k.call(t)]),t.append&&$("div",{key:"append",class:"v-alert__append"},[t.append()]),E&&$(xs,{key:"close",defaults:{VBtn:{icon:f.closeIcon,size:"x-small",variant:"text"}}},{default:()=>{var P;return[$("div",{class:"v-alert__close"},[(P=(T=t.close)==null?void 0:T.call(t,{props:w.value}))!=null?P:$(ot,w.value,null)])]}})]})}}});const hl=Symbol.for("vuetify:layout"),JC=Symbol.for("vuetify:layout-item"),KO=1e3,JK=Ye({overlaps:{type:Array,default:()=>[]},fullHeight:Boolean},"layout"),Xb=Ye({name:{type:String},order:{type:[Number,String],default:0},absolute:Boolean},"layout-item");function eX(){const f=Zt(hl);if(!f)throw new Error("[Vuetify] Could not find injected layout");return{getLayoutItem:f.getLayoutItem,mainRect:f.mainRect,mainStyles:f.mainStyles}}function Yb(f){var a;const e=Zt(hl);if(!e)throw new Error("[Vuetify] Could not find injected layout");const t=(a=f.id)!=null?a:`layout-item-${$i()}`,s=ii("useLayoutItem");Ni(JC,{id:t});const i=fe(!1);XI(()=>i.value=!0),KI(()=>i.value=!1);const{layoutItemStyles:n,layoutItemScrimStyles:r}=e.register(s,{...f,active:ie(()=>i.value?!1:f.active.value),id:t});return mn(()=>e.unregister(t)),{layoutItemStyles:n,layoutRect:e.layoutRect,layoutItemScrimStyles:r}}const tX=(f,e,t,s)=>{let i={top:0,left:0,right:0,bottom:0};const n=[{id:"",layer:{...i}}];for(const r of f){const a=e.get(r),o=t.get(r),d=s.get(r);if(!a||!o||!d)continue;const c={...i,[a.value]:parseInt(i[a.value],10)+(d.value?parseInt(o.value,10):0)};n.push({id:r,layer:c}),i=c}return n};function sX(f){const e=Zt(hl,null),t=ie(()=>e?e.rootZIndex.value-100:KO),s=fe([]),i=ti(new Map),n=ti(new Map),r=ti(new Map),a=ti(new Map),o=ti(new Map),{resizeRef:d,contentRect:c}=Gb(),u=ie(()=>{var C;const O=new Map,x=(C=f.overlaps)!=null?C:[];for(const E of x.filter(P=>P.includes(":"))){const[P,_]=E.split(":");if(!s.value.includes(P)||!s.value.includes(_))continue;const S=i.get(P),I=i.get(_),v=n.get(P),N=n.get(_);!S||!I||!v||!N||(O.set(_,{position:S.value,amount:parseInt(v.value,10)}),O.set(P,{position:I.value,amount:-parseInt(N.value,10)}))}return O}),h=ie(()=>{const O=[...new Set([...r.values()].map(C=>C.value))].sort((C,E)=>C-E),x=[];for(const C of O){const E=s.value.filter(P=>{var _;return((_=r.get(P))==null?void 0:_.value)===C});x.push(...E)}return tX(x,i,n,a)}),l=ie(()=>!Array.from(o.values()).some(O=>O.value)),p=ie(()=>h.value[h.value.length-1].layer),m=ie(()=>({"--v-layout-left":ze(p.value.left),"--v-layout-right":ze(p.value.right),"--v-layout-top":ze(p.value.top),"--v-layout-bottom":ze(p.value.bottom),...l.value?void 0:{transition:"none"}})),g=ie(()=>h.value.slice(1).map((O,x)=>{let{id:C}=O;const{layer:E}=h.value[x],P=n.get(C),_=i.get(C);return{id:C,...E,size:Number(P.value),position:_.value}})),y=O=>g.value.find(x=>x.id===O),b=ii("createLayout"),w=fe(!1);ar(()=>{w.value=!0}),Ni(hl,{register:(O,x)=>{let{id:C,order:E,position:P,layoutSize:_,elementSize:S,active:I,disableTransitions:v,absolute:N}=x;r.set(C,E),i.set(C,P),n.set(C,_),a.set(C,I),v&&o.set(C,v);const R=gu(JC,b==null?void 0:b.vnode).indexOf(O);R>-1?s.value.splice(R,0,C):s.value.push(C);const G=ie(()=>g.value.findIndex(Q=>Q.id===C)),F=ie(()=>t.value+h.value.length*2-G.value*2),A=ie(()=>{const Q=P.value==="left"||P.value==="right",J=P.value==="right",se=P.value==="bottom",we={[P.value]:0,zIndex:F.value,transform:`translate${Q?"X":"Y"}(${(I.value?0:-110)*(J||se?-1:1)}%)`,position:N.value||t.value!==KO?"absolute":"fixed",...l.value?void 0:{transition:"none"}};if(!w.value)return we;const le=g.value[G.value];if(!le)throw new Error(`[Vuetify] Could not find layout item "${C}"`);const Oe=u.value.get(C);return Oe&&(le[Oe.position]+=Oe.amount),{...we,height:Q?`calc(100% - ${le.top}px - ${le.bottom}px)`:S.value?`${S.value}px`:void 0,left:J?void 0:`${le.left}px`,right:J?`${le.right}px`:void 0,top:P.value!=="bottom"?`${le.top}px`:void 0,bottom:P.value!=="top"?`${le.bottom}px`:void 0,width:Q?S.value?`${S.value}px`:void 0:`calc(100% - ${le.left}px - ${le.right}px)`}}),V=ie(()=>({zIndex:F.value-1}));return{layoutItemStyles:A,layoutItemScrimStyles:V,zIndex:F}},unregister:O=>{r.delete(O),i.delete(O),n.delete(O),a.delete(O),o.delete(O),s.value=s.value.filter(x=>x!==O)},mainRect:p,mainStyles:m,getLayoutItem:y,items:g,layoutRect:c,rootZIndex:t});const k=ie(()=>["v-layout",{"v-layout--full-height":f.fullHeight}]),T=ie(()=>({zIndex:t.value,position:e?"relative":void 0,overflow:e?"hidden":void 0}));return{layoutClasses:k,layoutStyles:T,getLayoutItem:y,items:g,layoutRect:c,layoutRef:d}}const iX=Qe({name:"VApp",props:{...JK({fullHeight:!0}),..._s()},setup(f,e){let{slots:t}=e;const s=Rs(f),{layoutClasses:i,layoutStyles:n,getLayoutItem:r,items:a,layoutRef:o}=sX(f),{rtlClasses:d}=Wu();return Xe(()=>{var c;return $("div",{ref:o,class:["v-application",s.themeClasses.value,i.value,d.value],style:n.value},[$("div",{class:"v-application__wrap"},[(c=t.default)==null?void 0:c.call(t)])])}),{getLayoutItem:r,items:a,theme:s}}});function ji(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"top center 0",t=arguments.length>2?arguments[2]:void 0;return Qe({name:f,props:{group:Boolean,hideOnLeave:Boolean,leaveAbsolute:Boolean,mode:{type:String,default:t},origin:{type:String,default:e}},setup(s,i){let{slots:n}=i;return()=>{const r=s.group?IA:sr;return Sa(r,{name:f,mode:s.mode,onBeforeEnter(a){a.style.transformOrigin=s.origin},onLeave(a){if(s.leaveAbsolute){const{offsetTop:o,offsetLeft:d,offsetWidth:c,offsetHeight:u}=a;a._transitionInitialStyles={position:a.style.position,top:a.style.top,left:a.style.left,width:a.style.width,height:a.style.height},a.style.position="absolute",a.style.top=`${o}px`,a.style.left=`${d}px`,a.style.width=`${c}px`,a.style.height=`${u}px`}s.hideOnLeave&&a.style.setProperty("display","none","important")},onAfterLeave(a){if(s.leaveAbsolute&&a!=null&&a._transitionInitialStyles){const{position:o,top:d,left:c,width:u,height:h}=a._transitionInitialStyles;delete a._transitionInitialStyles,a.style.position=o||"",a.style.top=d||"",a.style.left=c||"",a.style.width=u||"",a.style.height=h||""}}},n.default)}}})}function e2(f,e){let t=arguments.length>2&&arguments[2]!==void 0?arguments[2]:"in-out";return Qe({name:f,props:{mode:{type:String,default:t}},setup(s,i){let{slots:n}=i;return()=>Sa(sr,{name:f,...e},n.default)}})}function t2(){let f=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"";const t=(arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1)?"width":"height",s=pn(`offset-${t}`);return{onBeforeEnter(r){r._parent=r.parentNode,r._initialStyle={transition:r.style.transition,overflow:r.style.overflow,[t]:r.style[t]}},onEnter(r){const a=r._initialStyle;r.style.setProperty("transition","none","important"),r.style.overflow="hidden";const o=`${r[s]}px`;r.style[t]="0",r.offsetHeight,r.style.transition=a.transition,f&&r._parent&&r._parent.classList.add(f),requestAnimationFrame(()=>{r.style[t]=o})},onAfterEnter:n,onEnterCancelled:n,onLeave(r){r._initialStyle={transition:"",overflow:r.style.overflow,[t]:r.style[t]},r.style.overflow="hidden",r.style[t]=`${r[s]}px`,r.offsetHeight,requestAnimationFrame(()=>r.style[t]="0")},onAfterLeave:i,onLeaveCancelled:i};function i(r){f&&r._parent&&r._parent.classList.remove(f),n(r)}function n(r){const a=r._initialStyle[t];r.style.overflow=r._initialStyle.overflow,a!=null&&(r.style[t]=a),delete r._initialStyle}}const Qb=Qe({name:"VDialogTransition",props:{target:Object},setup(f,e){let{slots:t}=e;const s={onBeforeEnter(i){i.style.pointerEvents="none",i.style.visibility="hidden"},async onEnter(i,n){var r;await new Promise(l=>requestAnimationFrame(l)),await new Promise(l=>requestAnimationFrame(l)),i.style.visibility="";const{x:a,y:o,sx:d,sy:c,speed:u}=YO(f.target,i),h=ud(i,[{transform:`translate(${a}px, ${o}px) scale(${d}, ${c})`,opacity:0},{transform:""}],{duration:225*u,easing:rK});(r=XO(i))==null||r.forEach(l=>{ud(l,[{opacity:0},{opacity:0,offset:.33},{opacity:1}],{duration:225*2*u,easing:ol})}),h.finished.then(()=>n())},onAfterEnter(i){i.style.removeProperty("pointer-events")},onBeforeLeave(i){i.style.pointerEvents="none"},async onLeave(i,n){var r;await new Promise(l=>requestAnimationFrame(l));const{x:a,y:o,sx:d,sy:c,speed:u}=YO(f.target,i);ud(i,[{transform:""},{transform:`translate(${a}px, ${o}px) scale(${d}, ${c})`,opacity:0}],{duration:125*u,easing:aK}).finished.then(()=>n()),(r=XO(i))==null||r.forEach(l=>{ud(l,[{},{opacity:0,offset:.2},{opacity:0}],{duration:125*2*u,easing:ol})})},onAfterLeave(i){i.style.removeProperty("pointer-events")}};return()=>f.target?$(sr,Je({name:"dialog-transition"},s,{css:!1}),t):$(sr,{name:"dialog-transition"},t)}});function XO(f){var e;const t=(e=f.querySelector(":scope > .v-card, :scope > .v-sheet, :scope > .v-list"))==null?void 0:e.children;return t&&[...t]}function YO(f,e){const t=f.getBoundingClientRect(),s=Lb(e),[i,n]=getComputedStyle(e).transformOrigin.split(" ").map(y=>parseFloat(y)),[r,a]=getComputedStyle(e).getPropertyValue("--v-overlay-anchor-origin").split(" ");let o=t.left+t.width/2;r==="left"||a==="left"?o-=t.width/2:(r==="right"||a==="right")&&(o+=t.width/2);let d=t.top+t.height/2;r==="top"||a==="top"?d-=t.height/2:(r==="bottom"||a==="bottom")&&(d+=t.height/2);const c=t.width/s.width,u=t.height/s.height,h=Math.max(1,c,u),l=c/h,p=u/h,m=s.width*s.height/(window.innerWidth*window.innerHeight),g=m>.12?Math.min(1.5,(m-.12)*10+1):1;return{x:o-(i+s.left),y:d-(n+s.top),sx:l,sy:p,speed:g}}ji("fab-transition","center center","out-in");ji("dialog-bottom-transition");ji("dialog-top-transition");ji("fade-transition");ji("scale-transition");ji("scroll-x-transition");ji("scroll-x-reverse-transition");ji("scroll-y-transition");ji("scroll-y-reverse-transition");ji("slide-x-transition");ji("slide-x-reverse-transition");const s2=ji("slide-y-transition");ji("slide-y-reverse-transition");const i2=e2("expand-transition",t2()),n2=e2("expand-x-transition",t2("",!0));function nX(f){return{aspectStyles:ie(()=>{const e=Number(f.aspectRatio);return e?{paddingBottom:String(1/e*100)+"%"}:void 0})}}const r2=Qe({name:"VResponsive",props:{aspectRatio:[String,Number],contentClass:String,...ko()},setup(f,e){let{slots:t}=e;const{aspectStyles:s}=nX(f),{dimensionStyles:i}=So(f);return Xe(()=>{var n;return $("div",{class:"v-responsive",style:i.value},[$("div",{class:"v-responsive__sizer",style:s.value},null),(n=t.additional)==null?void 0:n.call(t),t.default&&$("div",{class:["v-responsive__content",f.contentClass]},[t.default()])])}),{}}});function rX(f,e){if(!Db)return;const t=e.modifiers||{},s=e.value,{handler:i,options:n}=typeof s=="object"?s:{handler:s,options:{}},r=new IntersectionObserver(function(){var a;let o=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[],d=arguments.length>1?arguments[1]:void 0;const c=(a=f._observe)==null?void 0:a[e.instance.$.uid];if(!c)return;const u=o.some(h=>h.isIntersecting);i&&(!t.quiet||c.init)&&(!t.once||u||c.init)&&i(u,o,d),u&&t.once?a2(f,e):c.init=!0},n);f._observe=Object(f._observe),f._observe[e.instance.$.uid]={init:!1,observer:r},r.observe(f)}function a2(f,e){var t;const s=(t=f._observe)==null?void 0:t[e.instance.$.uid];!s||(s.observer.unobserve(f),delete f._observe[e.instance.$.uid])}const aX={mounted:rX,unmounted:a2},o2=aX,Gd=Ye({transition:{type:[Boolean,String,Object],default:"fade-transition",validator:f=>f!==!0}},"transition"),fo=(f,e)=>{let{slots:t}=e;const{transition:s,...i}=f,{component:n=sr,...r}=typeof s=="object"?s:{};return Sa(n,Je(typeof s=="string"?{name:s}:r,i),t)},ma=Qe({name:"VImg",directives:{intersect:o2},props:{aspectRatio:[String,Number],alt:String,cover:Boolean,eager:Boolean,gradient:String,lazySrc:String,options:{type:Object,default:()=>({root:void 0,rootMargin:void 0,threshold:void 0})},sizes:String,src:{type:[String,Object],default:""},srcset:String,width:[String,Number],...Gd()},emits:{loadstart:f=>!0,load:f=>!0,error:f=>!0},setup(f,e){let{emit:t,slots:s}=e;const i=fe(""),n=fe(),r=fe(f.eager?"loading":"idle"),a=fe(),o=fe(),d=ie(()=>f.src&&typeof f.src=="object"?{src:f.src.src,srcset:f.srcset||f.src.srcset,lazySrc:f.lazySrc||f.src.lazySrc,aspect:Number(f.aspectRatio||f.src.aspect)}:{src:f.src,srcset:f.srcset,lazySrc:f.lazySrc,aspect:Number(f.aspectRatio||0)}),c=ie(()=>d.value.aspect||a.value/o.value||0);st(()=>f.src,()=>{u(r.value!=="idle")}),Il(()=>u());function u(x){if(!(f.eager&&x)&&!(Db&&!x&&!f.eager)){if(r.value="loading",d.value.lazySrc){const C=new Image;C.src=d.value.lazySrc,m(C,null)}!d.value.src||Bi(()=>{var C,E;if(t("loadstart",((C=n.value)==null?void 0:C.currentSrc)||d.value.src),(E=n.value)!=null&&E.complete){if(n.value.naturalWidth||l(),r.value==="error")return;c.value||m(n.value,null),h()}else c.value||m(n.value),p()})}}function h(){var x;p(),r.value="loaded",t("load",((x=n.value)==null?void 0:x.currentSrc)||d.value.src)}function l(){var x;r.value="error",t("error",((x=n.value)==null?void 0:x.currentSrc)||d.value.src)}function p(){const x=n.value;x&&(i.value=x.currentSrc||x.src)}function m(x){let C=arguments.length>1&&arguments[1]!==void 0?arguments[1]:100;const E=()=>{const{naturalHeight:P,naturalWidth:_}=x;P||_?(a.value=_,o.value=P):!x.complete&&r.value==="loading"&&C!=null?setTimeout(E,C):(x.currentSrc.endsWith(".svg")||x.currentSrc.startsWith("data:image/svg+xml"))&&(a.value=1,o.value=1)};E()}const g=ie(()=>({"v-img__img--cover":f.cover,"v-img__img--contain":!f.cover})),y=()=>{var x;if(!d.value.src||r.value==="idle")return null;const C=$("img",{class:["v-img__img",g.value],src:d.value.src,srcset:d.value.srcset,alt:"",sizes:f.sizes,ref:n,onLoad:h,onError:l},null),E=(x=s.sources)==null?void 0:x.call(s);return $(fo,{transition:f.transition,appear:!0},{default:()=>[Gi(E?$("picture",{class:"v-img__picture"},[E,C]):C,[[Cd,r.value==="loaded"]])]})},b=()=>$(fo,{transition:f.transition},{default:()=>[d.value.lazySrc&&r.value!=="loaded"&&$("img",{class:["v-img__img","v-img__img--preload",g.value],src:d.value.lazySrc,alt:""},null)]}),w=()=>s.placeholder?$(fo,{transition:f.transition,appear:!0},{default:()=>[(r.value==="loading"||r.value==="error"&&!s.error)&&$("div",{class:"v-img__placeholder"},[s.placeholder()])]}):null,k=()=>s.error?$(fo,{transition:f.transition,appear:!0},{default:()=>[r.value==="error"&&$("div",{class:"v-img__error"},[s.error()])]}):null,T=()=>f.gradient?$("div",{class:"v-img__gradient",style:{backgroundImage:`linear-gradient(${f.gradient})`}},null):null,O=fe(!1);{const x=st(c,C=>{C&&(requestAnimationFrame(()=>{requestAnimationFrame(()=>{O.value=!0})}),x())})}return Xe(()=>Gi($(r2,{class:["v-img",{"v-img--booting":!O.value}],style:{width:ze(f.width==="auto"?a.value:f.width)},aspectRatio:c.value,"aria-label":f.alt,role:f.alt?"img":void 0},{additional:()=>$(Ft,null,[$(y,null,null),$(b,null,null),$(T,null,null),$(w,null,null),$(k,null,null)]),default:s.default}),[[ka("intersect"),{handler:u,options:f.options},null,{once:!0}]])),{currentSrc:i,image:n,state:r,naturalWidth:a,naturalHeight:o}}}),oX=zs()({name:"VToolbarTitle",props:{text:String,...cs()},setup(f,e){let{slots:t}=e;return Xe(()=>{var s;const i=!!(t.default||t.text||f.text);return $(f.tag,{class:"v-toolbar-title"},{default:()=>[i&&$("div",{class:"v-toolbar-title__placeholder"},[t.text?t.text():f.text,(s=t.default)==null?void 0:s.call(t)])]})}),{}}}),dX=[null,"prominent","default","comfortable","compact"],d2=Ye({absolute:Boolean,collapse:Boolean,color:String,density:{type:String,default:"default",validator:f=>dX.includes(f)},extended:Boolean,extensionHeight:{type:[Number,String],default:48},flat:Boolean,floating:Boolean,height:{type:[Number,String],default:64},image:String,title:String,...Nr(),...cr(),...gn(),...cs({tag:"header"}),..._s()},"v-toolbar"),Py=zs()({name:"VToolbar",props:d2(),setup(f,e){var t;let{slots:s}=e;const{backgroundColorClasses:i,backgroundColorStyles:n}=nr(je(f,"color")),{borderClasses:r}=Vr(f),{elevationClasses:a}=ur(f),{roundedClasses:o}=yn(f),{themeClasses:d}=Rs(f),c=fe(!!(f.extended||(t=s.extension)!=null&&t.call(s))),u=ie(()=>parseInt(Number(f.height)+(f.density==="prominent"?Number(f.height):0)-(f.density==="comfortable"?8:0)-(f.density==="compact"?16:0),10)),h=ie(()=>c.value?parseInt(Number(f.extensionHeight)+(f.density==="prominent"?Number(f.extensionHeight):0)-(f.density==="comfortable"?4:0)-(f.density==="compact"?8:0),10):0);return Er({VBtn:{variant:"text"}}),Xe(()=>{var l,p,m,g,y;const b=!!(f.title||s.title),w=!!(s.image||f.image),k=(l=s.extension)==null?void 0:l.call(s);return c.value=!!(f.extended||k),$(f.tag,{class:["v-toolbar",{"v-toolbar--absolute":f.absolute,"v-toolbar--collapse":f.collapse,"v-toolbar--flat":f.flat,"v-toolbar--floating":f.floating,[`v-toolbar--density-${f.density}`]:!0},i.value,r.value,a.value,o.value,d.value],style:[n.value]},{default:()=>[w&&$("div",{key:"image",class:"v-toolbar__image"},[$(xs,{defaults:{VImg:{cover:!0,src:f.image}}},{default:()=>[s.image?(p=s.image)==null?void 0:p.call(s):$(ma,null,null)]})]),$("div",{class:"v-toolbar__content",style:{height:ze(u.value)}},[s.prepend&&$("div",{class:"v-toolbar__prepend"},[(m=s.prepend)==null?void 0:m.call(s)]),b&&$(oX,{key:"title",text:f.title},{text:s.title}),(g=s.default)==null?void 0:g.call(s),s.append&&$("div",{class:"v-toolbar__append"},[(y=s.append)==null?void 0:y.call(s)])]),$(i2,null,{default:()=>[c.value&&$("div",{class:"v-toolbar__extension",style:{height:ze(h.value)}},[k])]})]})}),{contentHeight:u,extensionHeight:h}}});function cX(f){var e;return or(f,Object.keys((e=Py==null?void 0:Py.props)!=null?e:{}))}const uX=Qe({name:"VAppBar",props:{modelValue:{type:Boolean,default:!0},location:{type:String,default:"top",validator:f=>["top","bottom"].includes(f)},...d2(),...Xb(),height:{type:[Number,String],default:64}},emits:{"update:modelValue":f=>!0},setup(f,e){let{slots:t}=e;const s=fe(),i=Vt(f,"modelValue"),n=ie(()=>{var u,h;var a,o;const d=(u=(a=s.value)==null?void 0:a.contentHeight)!=null?u:0,c=(h=(o=s.value)==null?void 0:o.extensionHeight)!=null?h:0;return d+c}),{layoutItemStyles:r}=Yb({id:f.name,order:ie(()=>parseInt(f.order,10)),position:je(f,"location"),layoutSize:n,elementSize:n,active:i,absolute:je(f,"absolute")});return Xe(()=>{const[a]=cX(f);return $(Py,Je({ref:s,class:["v-app-bar",{"v-app-bar--bottom":f.location==="bottom"}],style:{...r.value,height:void 0}},a),t)}),{}}});function c2(f){const{t:e}=Ql();function t(s){var o;let{name:i}=s;const n={prepend:"prependAction",prependInner:"prependAction",append:"appendAction",appendInner:"appendAction",clear:"clear"}[i],r=f[`onClick:${i}`],a=r&&n?e(`$vuetify.input.${n}`,(o=f.label)!=null?o:""):void 0;return $(gi,{icon:f[`${i}Icon`],"aria-label":a,onClick:r},null)}return{InputIcon:t}}const u2=Qe({name:"VLabel",props:{text:String,clickable:Boolean,..._s()},setup(f,e){let{slots:t}=e;return Xe(()=>{var s;return $("label",{class:["v-label",{"v-label--clickable":f.clickable}]},[f.text,(s=t.default)==null?void 0:s.call(t)])}),{}}}),Vh=Qe({name:"VFieldLabel",props:{floating:Boolean},setup(f,e){let{slots:t}=e;return Xe(()=>$(u2,{class:["v-field-label",{"v-field-label--floating":f.floating}],"aria-hidden":f.floating||void 0},t)),{}}}),f2=Ye({focused:Boolean},"focus");function Zb(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Br();const t=Vt(f,"focused"),s=ie(()=>({[`${e}--focused`]:t.value}));function i(){t.value=!0}function n(){t.value=!1}return{focusClasses:s,isFocused:t,focus:i,blur:n}}const fX=["underlined","outlined","filled","solo","plain"],h2=Ye({appendInnerIcon:It,bgColor:String,clearable:Boolean,clearIcon:{type:It,default:"$clear"},active:Boolean,color:String,dirty:Boolean,disabled:Boolean,error:Boolean,label:String,persistentClear:Boolean,prependInnerIcon:It,reverse:Boolean,singleLine:Boolean,variant:{type:String,default:"filled",validator:f=>fX.includes(f)},"onClick:clear":mo,"onClick:appendInner":mo,"onClick:prependInner":mo,..._s(),...Ub()},"v-field"),l2=zs()({name:"VField",inheritAttrs:!1,props:{id:String,...f2(),...h2()},emits:{"click:control":f=>!0,"update:focused":f=>!0,"update:modelValue":f=>!0},setup(f,e){let{attrs:t,emit:s,slots:i}=e;const{themeClasses:n}=Rs(f),{loaderClasses:r}=$b(f),{focusClasses:a,isFocused:o,focus:d,blur:c}=Zb(f),{InputIcon:u}=c2(f),h=ie(()=>f.dirty||f.active),l=ie(()=>!f.singleLine&&!!(f.label||i.label)),p=$i(),m=ie(()=>f.id||`input-${p}`),g=fe(),y=fe(),b=fe(),{backgroundColorClasses:w,backgroundColorStyles:k}=nr(je(f,"bgColor")),{textColorClasses:T,textColorStyles:O}=_r(ie(()=>h.value&&o.value&&!f.error&&!f.disabled?f.color:void 0));st(h,E=>{if(l.value){const P=g.value.$el,_=y.value.$el,S=Lb(P),I=_.getBoundingClientRect(),v=I.x-S.x,N=I.y-S.y-(S.height/2-I.height/2),q=I.width/.75,R=Math.abs(q-S.width)>1?{maxWidth:ze(q)}:void 0,G=getComputedStyle(P),F=getComputedStyle(_),A=parseFloat(G.transitionDuration)*1e3||150,V=parseFloat(F.getPropertyValue("--v-field-label-scale")),Q=F.getPropertyValue("color");P.style.visibility="visible",_.style.visibility="hidden",ud(P,{transform:`translate(${v}px, ${N}px) scale(${V})`,color:Q,...R},{duration:A,easing:ol,direction:E?"normal":"reverse"}).finished.then(()=>{P.style.removeProperty("visibility"),_.style.removeProperty("visibility")})}},{flush:"post"});const x=ie(()=>({isActive:h,isFocused:o,controlRef:b,blur:c,focus:d}));function C(E){E.target!==document.activeElement&&E.preventDefault(),s("click:control",E)}return Xe(()=>{var E,P,_;const S=f.variant==="outlined",I=i["prepend-inner"]||f.prependInnerIcon,v=!!(f.clearable||i.clear),N=!!(i["append-inner"]||f.appendInnerIcon||v),q=i.label?i.label({label:f.label,props:{for:m.value}}):f.label;return $("div",Je({class:["v-field",{"v-field--active":h.value,"v-field--appended":N,"v-field--disabled":f.disabled,"v-field--dirty":f.dirty,"v-field--error":f.error,"v-field--has-background":!!f.bgColor,"v-field--persistent-clear":f.persistentClear,"v-field--prepended":I,"v-field--reverse":f.reverse,"v-field--single-line":f.singleLine,"v-field--no-label":!q,[`v-field--variant-${f.variant}`]:!0},n.value,w.value,a.value,r.value],style:[k.value,O.value],onClick:C},t),[$("div",{class:"v-field__overlay"},null),$(QC,{name:"v-field",active:f.loading,color:f.error?"error":f.color},{default:i.loader}),I&&$("div",{key:"prepend",class:"v-field__prepend-inner"},[f.prependInnerIcon&&$(u,{key:"prepend-icon",name:"prependInner"},null),(E=i["prepend-inner"])==null?void 0:E.call(i,x.value)]),$("div",{class:"v-field__field","data-no-activator":""},[["solo","filled"].includes(f.variant)&&l.value&&$(Vh,{key:"floating-label",ref:y,class:[T.value],floating:!0,for:m.value},{default:()=>[q]}),$(Vh,{ref:g,for:m.value},{default:()=>[q]}),(P=i.default)==null?void 0:P.call(i,{...x.value,props:{id:m.value,class:"v-field__input"},focus:d,blur:c})]),v&&$(n2,{key:"clear"},{default:()=>[Gi($("div",{class:"v-field__clearable"},[i.clear?i.clear():$(u,{name:"clear"},null)]),[[Cd,f.dirty]])]}),N&&$("div",{key:"append",class:"v-field__append-inner"},[(_=i["append-inner"])==null?void 0:_.call(i,x.value),f.appendInnerIcon&&$(u,{key:"append-icon",name:"appendInner"},null)]),$("div",{class:["v-field__outline",T.value]},[S&&$(Ft,null,[$("div",{class:"v-field__outline__start"},null),l.value&&$("div",{class:"v-field__outline__notch"},[$(Vh,{ref:y,floating:!0,for:m.value},{default:()=>[q]})]),$("div",{class:"v-field__outline__end"},null)]),["plain","underlined"].includes(f.variant)&&l.value&&$(Vh,{ref:y,floating:!0,for:m.value},{default:()=>[q]})])])}),{controlRef:b}}});function hX(f){const e=Object.keys(l2.props).filter(t=>!vC(t));return or(f,e)}const lX=Qe({name:"VMessages",props:{active:Boolean,color:String,messages:{type:[Array,String],default:()=>[]},...Gd({transition:{component:s2,leaveAbsolute:!0,group:!0}})},setup(f,e){let{slots:t}=e;const s=ie(()=>tr(f.messages)),{textColorClasses:i,textColorStyles:n}=_r(ie(()=>f.color));return Xe(()=>$(fo,{transition:f.transition,tag:"div",class:["v-messages",i.value],style:n.value},{default:()=>[f.active&&s.value.map((r,a)=>$("div",{class:"v-messages__message",key:`${a}-${s.value}`},[t.message?t.message({message:r}):r]))]})),{}}}),pX=Symbol.for("vuetify:form");function mX(){return Zt(pX,null)}const gX=Ye({disabled:Boolean,error:Boolean,errorMessages:{type:[Array,String],default:()=>[]},maxErrors:{type:[Number,String],default:1},name:String,label:String,readonly:Boolean,rules:{type:Array,default:()=>[]},modelValue:null,validateOn:String,validationValue:null,...f2()},"validation");function yX(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Br(),t=arguments.length>2&&arguments[2]!==void 0?arguments[2]:$i();const s=Vt(f,"modelValue"),i=ie(()=>f.validationValue===void 0?s.value:f.validationValue),n=mX(),r=fe([]),a=fe(!0),o=ie(()=>!!(tr(s.value===""?null:s.value).length||tr(i.value===""?null:i.value).length)),d=ie(()=>!!(f.disabled||n!=null&&n.isDisabled.value)),c=ie(()=>!!(f.readonly||n!=null&&n.isReadonly.value)),u=ie(()=>f.errorMessages.length?tr(f.errorMessages):r.value),h=ie(()=>f.error||u.value.length?!1:f.rules.length&&a.value?null:!0),l=fe(!1),p=ie(()=>({[`${e}--error`]:h.value===!1,[`${e}--dirty`]:o.value,[`${e}--disabled`]:d.value,[`${e}--readonly`]:c.value})),m=ie(()=>{var k;return(k=f.name)!=null?k:ei(t)});Il(()=>{n==null||n.register({id:m.value,validate:w,reset:y,resetValidation:b})}),mn(()=>{n==null||n.unregister(m.value)});const g=ie(()=>f.validateOn||(n==null?void 0:n.validateOn.value)||"input");ar(()=>n==null?void 0:n.update(m.value,h.value,u.value)),Td(()=>g.value==="input",()=>{st(i,()=>{if(i.value!=null)w();else if(f.focused){const k=st(()=>f.focused,T=>{T||w(),k()})}})}),Td(()=>g.value==="blur",()=>{st(()=>f.focused,k=>{k||w()})}),st(h,()=>{n==null||n.update(m.value,h.value,u.value)});function y(){b(),s.value=null}function b(){a.value=!0,r.value=[]}async function w(){const k=[];l.value=!0;for(const T of f.rules){if(k.length>=(f.maxErrors||1))break;const x=await(typeof T=="function"?T:()=>T)(i.value);if(x!==!0){if(typeof x!="string"){console.warn(`${x} is not a valid value. Rule functions must return boolean true or a string.`);continue}k.push(x)}}return r.value=k,l.value=!1,a.value=!1,r.value}return{errorMessages:u,isDirty:o,isDisabled:d,isReadonly:c,isPristine:a,isValid:h,isValidating:l,reset:y,resetValidation:b,validate:w,validationClasses:p}}const Jb=Ye({id:String,appendIcon:It,prependIcon:It,hideDetails:[Boolean,String],messages:{type:[Array,String],default:()=>[]},direction:{type:String,default:"horizontal",validator:f=>["horizontal","vertical"].includes(f)},"onClick:prepend":mo,"onClick:append":mo,...Vn(),...gX()},"v-input"),ew=zs()({name:"VInput",props:{...Jb()},emits:{"update:modelValue":f=>!0},setup(f,e){let{attrs:t,slots:s,emit:i}=e;const{densityClasses:n}=dr(f),{InputIcon:r}=c2(f),a=$i(),o=ie(()=>f.id||`input-${a}`),{errorMessages:d,isDirty:c,isDisabled:u,isReadonly:h,isPristine:l,isValid:p,isValidating:m,reset:g,resetValidation:y,validate:b,validationClasses:w}=yX(f,"v-input",o),k=ie(()=>({id:o,isDirty:c,isDisabled:u,isReadonly:h,isPristine:l,isValid:p,isValidating:m,reset:g,resetValidation:y,validate:b}));return Xe(()=>{var T,O,x,C,E;const P=!!(s.prepend||f.prependIcon),_=!!(s.append||f.appendIcon),S=!!((T=f.messages)!=null&&T.length||d.value.length),I=!f.hideDetails||f.hideDetails==="auto"&&(S||!!s.details);return $("div",{class:["v-input",`v-input--${f.direction}`,n.value,w.value]},[P&&$("div",{key:"prepend",class:"v-input__prepend"},[(O=s.prepend)==null?void 0:O.call(s,k.value),f.prependIcon&&$(r,{key:"prepend-icon",name:"prepend"},null)]),s.default&&$("div",{class:"v-input__control"},[(x=s.default)==null?void 0:x.call(s,k.value)]),_&&$("div",{key:"append",class:"v-input__append"},[f.appendIcon&&$(r,{key:"append-icon",name:"append"},null),(C=s.append)==null?void 0:C.call(s,k.value)]),I&&$("div",{class:"v-input__details"},[$(lX,{active:S,messages:d.value.length>0?d.value:f.messages},{message:s.message}),(E=s.details)==null?void 0:E.call(s,k.value)])])}),{reset:g,resetValidation:y,validate:b}}});function p2(f){const e=Object.keys(ew.props).filter(t=>!vC(t));return or(f,e)}const bX=Qe({name:"VCounter",functional:!0,props:{active:Boolean,max:[Number,String],value:{type:[Number,String],default:0},...Gd({transition:{component:s2}})},setup(f,e){let{slots:t}=e;const s=ie(()=>f.max?`${f.value} / ${f.max}`:String(f.value));return Xe(()=>$(fo,{transition:f.transition},{default:()=>[Gi($("div",{class:"v-counter"},[t.default?t.default({counter:s.value,max:f.max,value:f.value}):s.value]),[[Cd,f.active]])]})),{}}}),Kg=Symbol("Forwarded refs");function Ud(f){for(var e=arguments.length,t=new Array(e>1?e-1:0),s=1;s<e;s++)t[s-1]=arguments[s];return f[Kg]=t,new Proxy(f,{get(i,n){if(Reflect.has(i,n))return Reflect.get(i,n);for(const r of t)if(r.value&&Reflect.has(r.value,n)){const a=Reflect.get(r.value,n);return typeof a=="function"?a.bind(r.value):a}},getOwnPropertyDescriptor(i,n){const r=Reflect.getOwnPropertyDescriptor(i,n);if(r)return r;if(!(typeof n=="symbol"||n.startsWith("__"))){for(const a of t){if(!a.value)continue;const o=Reflect.getOwnPropertyDescriptor(a.value,n);if(o)return o;if("_"in a.value&&"setupState"in a.value._){const d=Reflect.getOwnPropertyDescriptor(a.value._.setupState,n);if(d)return d}}for(const a of t){let o=a.value&&Object.getPrototypeOf(a.value);for(;o;){const d=Reflect.getOwnPropertyDescriptor(o,n);if(d)return d;o=Object.getPrototypeOf(o)}}for(const a of t){const o=a.value&&a.value[Kg];if(!o)continue;const d=o.slice();for(;d.length;){const c=d.shift(),u=Reflect.getOwnPropertyDescriptor(c.value,n);if(u)return u;const h=c.value&&c.value[Kg];h&&d.push(...h)}}}}})}const wX=["color","file","time","date","datetime-local","week","month"],tw=Ye({autofocus:Boolean,counter:[Boolean,Number,String],counterValue:Function,hint:String,persistentHint:Boolean,prefix:String,placeholder:String,persistentPlaceholder:Boolean,persistentCounter:Boolean,suffix:String,type:{type:String,default:"text"},...Jb(),...h2()},"v-text-field"),Yn=zs()({name:"VTextField",directives:{Intersect:o2},inheritAttrs:!1,props:tw(),emits:{"click:control":f=>!0,"click:input":f=>!0,"update:focused":f=>!0,"update:modelValue":f=>!0},setup(f,e){let{attrs:t,emit:s,slots:i}=e;const n=Vt(f,"modelValue"),{isFocused:r,focus:a,blur:o}=Zb(f),d=ie(()=>{var T;return typeof f.counterValue=="function"?f.counterValue(n.value):((T=n.value)!=null?T:"").toString().length}),c=ie(()=>{if(t.maxlength)return t.maxlength;if(!(!f.counter||typeof f.counter!="number"&&typeof f.counter!="string"))return f.counter});function u(T,O){var x,C;!f.autofocus||!T||(x=O[0].target)==null||(C=x.focus)==null||C.call(x)}const h=fe(),l=fe(),p=fe(),m=ie(()=>wX.includes(f.type)||f.persistentPlaceholder||r.value),g=ie(()=>f.messages.length?f.messages:r.value||f.persistentHint?f.hint:"");function y(){if(p.value!==document.activeElement){var T;(T=p.value)==null||T.focus()}r.value||a()}function b(T){y(),s("click:control",T)}function w(T){T.stopPropagation(),y(),Bi(()=>{n.value=null,Hz(f["onClick:clear"],T)})}function k(T){n.value=T.target.value}return Xe(()=>{const T=!!(i.counter||f.counter||f.counterValue),O=!!(T||i.details),[x,C]=Vb(t),[{modelValue:E,...P}]=p2(f),[_]=hX(f);return $(ew,Je({ref:h,modelValue:n.value,"onUpdate:modelValue":S=>n.value=S,class:["v-text-field",{"v-text-field--prefixed":f.prefix,"v-text-field--suffixed":f.suffix,"v-text-field--flush-details":["plain","underlined"].includes(f.variant)}],"onClick:prepend":f["onClick:prepend"],"onClick:append":f["onClick:append"]},x,P,{focused:r.value,messages:g.value}),{...i,default:S=>{let{id:I,isDisabled:v,isDirty:N,isReadonly:q,isValid:R}=S;return $(l2,Je({ref:l,onMousedown:G=>{G.target!==p.value&&G.preventDefault()},"onClick:control":b,"onClick:clear":w,"onClick:prependInner":f["onClick:prependInner"],"onClick:appendInner":f["onClick:appendInner"],role:"textbox"},_,{id:I.value,active:m.value||N.value,dirty:N.value||f.dirty,focused:r.value,error:R.value===!1}),{...i,default:G=>{let{props:{class:F,...A}}=G;const V=Gi($("input",Je({ref:p,value:n.value,onInput:k,autofocus:f.autofocus,readonly:q.value,disabled:v.value,name:f.name,placeholder:f.placeholder,size:1,type:f.type,onFocus:y,onBlur:o},A,C),null),[[ka("intersect"),{handler:u},null,{once:!0}]]);return $(Ft,null,[f.prefix&&$("span",{class:"v-text-field__prefix"},[f.prefix]),i.default?$("div",{class:F,onClick:Q=>s("click:input",Q),"data-no-activator":""},[i.default(),V]):Ir(V,{class:F}),f.suffix&&$("span",{class:"v-text-field__suffix"},[f.suffix])])}})},details:O?S=>{var I;return $(Ft,null,[(I=i.details)==null?void 0:I.call(i,S),T&&$(Ft,null,[$("span",null,null),$(bX,{active:f.persistentCounter||r.value,value:d.value,max:c.value},i.counter)])])}:void 0})}),Ud({},h,l,p)}});function m2(f){return or(f,Object.keys(Yn.props))}const g2=Symbol.for("vuetify:selection-control-group"),y2=Ye({color:String,disabled:Boolean,error:Boolean,id:String,inline:Boolean,falseIcon:It,trueIcon:It,ripple:{type:Boolean,default:!0},multiple:{type:Boolean,default:null},name:String,readonly:Boolean,modelValue:null,type:String,valueComparator:{type:Function,default:zl},..._s(),...Vn()},"v-selection-control-group");Qe({name:"VSelectionControlGroup",props:{defaultsTarget:{type:String,default:"VSelectionControl"},...y2()},emits:{"update:modelValue":f=>!0},setup(f,e){let{slots:t}=e;const s=Vt(f,"modelValue"),i=$i(),n=ie(()=>f.id||`v-selection-control-group-${i}`),r=ie(()=>f.name||n.value);return Ni(g2,{modelValue:s}),Er({[f.defaultsTarget]:{color:je(f,"color"),disabled:je(f,"disabled"),density:je(f,"density"),error:je(f,"error"),inline:je(f,"inline"),modelValue:s,multiple:ie(()=>!!f.multiple||f.multiple==null&&Array.isArray(s.value)),name:r,falseIcon:je(f,"falseIcon"),trueIcon:je(f,"trueIcon"),readonly:je(f,"readonly"),ripple:je(f,"ripple"),type:je(f,"type"),valueComparator:je(f,"valueComparator")}}),Xe(()=>{var a;return $("div",{class:["v-selection-control-group",{"v-selection-control-group--inline":f.inline}],"aria-labelled-by":f.type==="radio"?n.value:void 0,role:f.type==="radio"?"radiogroup":void 0},[(a=t.default)==null?void 0:a.call(t)])}),{}}});const b2=Ye({label:String,trueValue:null,falseValue:null,value:null,...y2()},"v-selection-control");function kX(f){const e=Zt(g2,void 0),{densityClasses:t}=dr(f),s=Vt(f,"modelValue"),i=ie(()=>f.trueValue!==void 0?f.trueValue:f.value!==void 0?f.value:!0),n=ie(()=>f.falseValue!==void 0?f.falseValue:!1),r=ie(()=>!!f.multiple||f.multiple==null&&Array.isArray(s.value)),a=ie({get(){const u=e?e.modelValue.value:s.value;return r.value?u.some(h=>f.valueComparator(h,i.value)):f.valueComparator(u,i.value)},set(u){if(f.readonly)return;const h=u?i.value:n.value;let l=h;r.value&&(l=u?[...tr(s.value),h]:tr(s.value).filter(p=>!f.valueComparator(p,i.value))),e?e.modelValue.value=l:s.value=l}}),{textColorClasses:o,textColorStyles:d}=_r(ie(()=>a.value&&!f.error&&!f.disabled?f.color:void 0)),c=ie(()=>a.value?f.trueIcon:f.falseIcon);return{group:e,densityClasses:t,trueValue:i,falseValue:n,model:a,textColorClasses:o,textColorStyles:d,icon:c}}const SX=zs()({name:"VSelectionControl",directives:{Ripple:ju},inheritAttrs:!1,props:b2(),emits:{"update:modelValue":f=>!0},setup(f,e){let{attrs:t,slots:s}=e;const{densityClasses:i,icon:n,model:r,textColorClasses:a,textColorStyles:o,trueValue:d}=kX(f),c=$i(),u=ie(()=>f.id||`input-${c}`),h=fe(!1),l=fe(!1),p=fe();function m(b){h.value=!0,(!xy||xy&&b.target.matches(":focus-visible"))&&(l.value=!0)}function g(){h.value=!1,l.value=!1}function y(b){r.value=b.target.checked}return Xe(()=>{var b,w;const k=s.label?s.label({label:f.label,props:{for:u.value}}):f.label,[T,O]=Vb(t);return $("div",Je({class:["v-selection-control",{"v-selection-control--dirty":r.value,"v-selection-control--disabled":f.disabled,"v-selection-control--error":f.error,"v-selection-control--focused":h.value,"v-selection-control--focus-visible":l.value,"v-selection-control--inline":f.inline},i.value]},T),[$("div",{class:["v-selection-control__wrapper",a.value],style:o.value},[(b=s.default)==null?void 0:b.call(s),Gi($("div",{class:["v-selection-control__input"]},[n.value&&$(gi,{key:"icon",icon:n.value},null),$("input",Je({ref:p,checked:r.value,disabled:f.disabled,id:u.value,onBlur:g,onFocus:m,onInput:y,"aria-readonly":f.readonly,type:f.type,value:d.value,name:f.name,"aria-checked":f.type==="checkbox"?r.value:void 0},O),null),(w=s.input)==null?void 0:w.call(s,{model:r,textColorClasses:a,textColorStyles:o,props:{onFocus:m,onBlur:g,id:u.value}})]),[[ka("ripple"),f.ripple&&[!f.disabled&&!f.readonly,null,["center","circle"]]]])]),k&&$(u2,{for:u.value,clickable:!0},{default:()=>[k]})])}),{isFocused:h,input:p}}}),w2=Ye({indeterminate:Boolean,indeterminateIcon:{type:It,default:"$checkboxIndeterminate"},...b2({falseIcon:"$checkboxOff",trueIcon:"$checkboxOn"})},"v-checkbox-btn"),ep=Qe({name:"VCheckboxBtn",props:w2(),emits:{"update:modelValue":f=>!0,"update:indeterminate":f=>!0},setup(f,e){let{slots:t}=e;const s=Vt(f,"indeterminate"),i=Vt(f,"modelValue");function n(o){s.value&&(s.value=!1)}const r=ie(()=>f.indeterminate?f.indeterminateIcon:f.falseIcon),a=ie(()=>f.indeterminate?f.indeterminateIcon:f.trueIcon);return Xe(()=>$(SX,Je(f,{modelValue:i.value,"onUpdate:modelValue":[o=>i.value=o,n],class:"v-checkbox-btn",type:"checkbox",inline:!0,falseIcon:r.value,trueIcon:a.value,"aria-checked":f.indeterminate?"mixed":void 0}),t)),{}}});function vX(f){return or(f,Object.keys(ep.props))}const qh=Qe({name:"VCheckbox",inheritAttrs:!1,props:{...Jb(),...w2()},emits:{"update:focused":f=>!0},setup(f,e){let{attrs:t,slots:s}=e;const{isFocused:i,focus:n,blur:r}=Zb(f),a=$i(),o=ie(()=>f.id||`checkbox-${a}`);return Xe(()=>{const[d,c]=Vb(t),[u,h]=p2(f),[l,p]=vX(f);return $(ew,Je({class:"v-checkbox"},d,u,{id:o.value,focused:i.value}),{...s,default:m=>{let{id:g,isDisabled:y,isReadonly:b}=m;return $(ep,Je(l,{id:g.value,disabled:y.value,readonly:b.value},c,{onFocus:n,onBlur:r}),s)}})}),{}}});const TX=Ye({start:Boolean,end:Boolean,icon:It,image:String,...Vn(),...gn(),...Uu(),...cs(),...qr({variant:"flat"})},"v-avatar"),go=Qe({name:"VAvatar",props:TX(),setup(f,e){let{slots:t}=e;const{colorClasses:s,colorStyles:i,variantClasses:n}=Hd(f),{densityClasses:r}=dr(f),{roundedClasses:a}=yn(f),{sizeClasses:o,sizeStyles:d}=$u(f);return Xe(()=>{var c;return $(f.tag,{class:["v-avatar",{"v-avatar--start":f.start,"v-avatar--end":f.end},s.value,r.value,a.value,o.value,n.value],style:[i.value,d.value]},{default:()=>[f.image?$(ma,{key:"image",src:f.image,alt:""},null):f.icon?$(gi,{key:"icon",icon:f.icon},null):(c=t.default)==null?void 0:c.call(t),Dd(!1,"v-avatar")]})}),{}}});const k2=Symbol.for("vuetify:v-chip-group");Qe({name:"VChipGroup",props:{column:Boolean,filter:Boolean,valueComparator:{type:Function,default:zl},...BC({selectedClass:"v-chip--selected"}),...cs(),..._s(),...qr({variant:"tonal"})},emits:{"update:modelValue":f=>!0},setup(f,e){let{slots:t}=e;const{themeClasses:s}=Rs(f),{isSelected:i,select:n,next:r,prev:a,selected:o}=VC(f,k2);return Er({VChip:{color:je(f,"color"),filter:je(f,"filter"),variant:je(f,"variant")}}),Xe(()=>{var d;return $(f.tag,{class:["v-chip-group",{"v-chip-group--column":f.column},s.value]},{default:()=>[(d=t.default)==null?void 0:d.call(t,{isSelected:i,select:n,next:r,prev:a,selected:o.value})]})}),{}}});const S2=Qe({name:"VChip",directives:{Ripple:ju},props:{activeClass:String,appendAvatar:String,appendIcon:It,closable:Boolean,closeIcon:{type:It,default:"$delete"},closeLabel:{type:String,default:"$vuetify.close"},draggable:Boolean,filter:Boolean,filterIcon:{type:String,default:"$complete"},label:Boolean,link:Boolean,pill:Boolean,prependAvatar:String,prependIcon:It,ripple:{type:Boolean,default:!0},text:String,modelValue:{type:Boolean,default:!0},...Nr(),...Vn(),...cr(),...EC(),...gn(),...Jl(),...Uu(),...cs({tag:"span"}),..._s(),...qr({variant:"tonal"})},emits:{"click:close":f=>!0,"update:modelValue":f=>!0,"group:selected":f=>!0},setup(f,e){let{attrs:t,emit:s,slots:i}=e;const{borderClasses:n}=Vr(f),{colorClasses:r,colorStyles:a,variantClasses:o}=Hd(f),{densityClasses:d}=dr(f),{elevationClasses:c}=ur(f),{roundedClasses:u}=yn(f),{sizeClasses:h}=$u(f),{themeClasses:l}=Rs(f),p=Vt(f,"modelValue"),m=NC(f,k2,!1),g=Zl(f,t);function y(b){p.value=!1,s("click:close",b)}return()=>{var b;const w=g.isLink.value?"a":f.tag,k=!!(i.append||f.appendIcon||f.appendAvatar),T=!!(i.close||f.closable),O=!!(i.filter||f.filter)&&m,x=!!(i.prepend||f.prependIcon||f.prependAvatar),C=!m||m.isSelected.value,E=!f.disabled&&(!!m||g.isClickable.value||f.link),P=f.link?f.link:m==null?void 0:m.toggle;return p.value&&Gi($(w,{class:["v-chip",{"v-chip--disabled":f.disabled,"v-chip--label":f.label,"v-chip--link":E,"v-chip--filter":O,"v-chip--pill":f.pill},l.value,n.value,C?r.value:void 0,d.value,c.value,u.value,h.value,o.value,m==null?void 0:m.selectedClass.value],style:[C?a.value:void 0],disabled:f.disabled||void 0,draggable:f.draggable,href:g.href.value,onClick:E&&P},{default:()=>{var _;return[Dd(E,"v-chip"),O&&$(xs,{key:"filter",defaults:{VIcon:{icon:f.filterIcon}}},{default:()=>[$(n2,null,{default:()=>[Gi($("div",{class:"v-chip__filter"},[i.filter?i.filter():$(gi,null,null)]),[[Cd,m.isSelected.value]])]})]}),x&&$(xs,{key:"prepend",defaults:{VAvatar:{image:f.prependAvatar},VIcon:{icon:f.prependIcon}}},{default:()=>[i.prepend?$("div",{class:"v-chip__prepend"},[i.prepend()]):f.prependAvatar?$(go,{start:!0},null):f.prependIcon?$(gi,{start:!0},null):void 0]}),(_=(b=i.default)==null?void 0:b.call(i,{isSelected:m==null?void 0:m.isSelected.value,selectedClass:m==null?void 0:m.selectedClass.value,select:m==null?void 0:m.select,toggle:m==null?void 0:m.toggle,value:m==null?void 0:m.value.value,disabled:f.disabled}))!=null?_:f.text,k&&$(xs,{key:"append",defaults:{VAvatar:{image:f.appendAvatar},VIcon:{icon:f.appendIcon}}},{default:()=>[i.append?$("div",{class:"v-chip__append"},[i.append()]):f.appendAvatar?$(go,{end:!0},null):f.appendIcon?$(gi,{end:!0},null):void 0]}),T&&$(xs,{key:"close",defaults:{VIcon:{icon:f.closeIcon,size:"x-small"}}},{default:()=>[$("div",{class:"v-chip__close",onClick:y},[i.close?i.close():$(gi,null,null)])]})]}}),[[ka("ripple"),E&&f.ripple,null]])}}});const dd=Qe({name:"VDivider",props:{color:String,inset:Boolean,length:[Number,String],thickness:[Number,String],vertical:Boolean,..._s()},setup(f,e){let{attrs:t}=e;const{themeClasses:s}=Rs(f),{backgroundColorClasses:i,backgroundColorStyles:n}=nr(je(f,"color")),r=ie(()=>{const a={};return f.length&&(a[f.vertical?"maxHeight":"maxWidth"]=ze(f.length)),f.thickness&&(a[f.vertical?"borderRightWidth":"borderTopWidth"]=ze(f.thickness)),a});return Xe(()=>$("hr",{class:[{"v-divider":!0,"v-divider--inset":f.inset,"v-divider--vertical":f.vertical},s.value,i.value],style:[r.value,n.value],"aria-orientation":!t.role||t.role==="separator"?f.vertical?"vertical":"horizontal":void 0,role:`${t.role||"separator"}`},null)),{}}}),Ay=Symbol.for("vuetify:list");function v2(){const f=Zt(Ay,{hasPrepend:fe(!1),updateHasPrepend:()=>null}),e={hasPrepend:fe(!1),updateHasPrepend:t=>{t&&(e.hasPrepend.value=t)}};return Ni(Ay,e),f}function T2(){return Zt(Ay,null)}const OX={open:f=>{let{id:e,value:t,opened:s,parents:i}=f;if(t){const n=new Set;n.add(e);let r=i.get(e);for(;r!=null;)n.add(r),r=i.get(r);return n}else return s.delete(e),s},select:()=>null},O2={open:f=>{let{id:e,value:t,opened:s,parents:i}=f;if(t){let n=i.get(e);for(s.add(e);n!=null&&n!==e;)s.add(n),n=i.get(n);return s}else s.delete(e);return s},select:()=>null},IX={open:O2.open,select:f=>{let{id:e,value:t,opened:s,parents:i}=f;if(!t)return s;const n=[];let r=i.get(e);for(;r!=null;)n.push(r),r=i.get(r);return new Set(n)}},sw=f=>{const e={select:t=>{let{id:s,value:i,selected:n}=t;if(f&&!i){const r=Array.from(n.entries()).reduce((a,o)=>{let[d,c]=o;return c==="on"?[...a,d]:a},[]);if(r.length===1&&r[0]===s)return n}return n.set(s,i?"on":"off"),n},in:(t,s,i)=>{let n=new Map;for(const r of t||[])n=e.select({id:r,value:!0,selected:new Map(n),children:s,parents:i});return n},out:t=>{const s=[];for(const[i,n]of t.entries())n==="on"&&s.push(i);return s}};return e},I2=f=>{const e=sw(f);return{select:s=>{let{selected:i,id:n,...r}=s;const a=i.has(n)?new Map([[n,i.get(n)]]):new Map;return e.select({...r,id:n,selected:a})},in:(s,i,n)=>{let r=new Map;return s!=null&&s.length&&(r=e.in(s.slice(0,1),i,n)),r},out:(s,i,n)=>e.out(s,i,n)}},xX=f=>{const e=sw(f);return{select:s=>{let{id:i,selected:n,children:r,...a}=s;return r.has(i)?n:e.select({id:i,selected:n,children:r,...a})},in:e.in,out:e.out}},_X=f=>{const e=I2(f);return{select:s=>{let{id:i,selected:n,children:r,...a}=s;return r.has(i)?n:e.select({id:i,selected:n,children:r,...a})},in:e.in,out:e.out}},CX=f=>{const e={select:t=>{let{id:s,value:i,selected:n,children:r,parents:a}=t;const o=new Map(n),d=[s];for(;d.length;){const u=d.shift();n.set(u,i?"on":"off"),r.has(u)&&d.push(...r.get(u))}let c=a.get(s);for(;c;){const u=r.get(c),h=u.every(p=>n.get(p)==="on"),l=u.every(p=>!n.has(p)||n.get(p)==="off");n.set(c,h?"on":l?"off":"indeterminate"),c=a.get(c)}return f&&!i&&Array.from(n.entries()).reduce((h,l)=>{let[p,m]=l;return m==="on"?[...h,p]:h},[]).length===0?o:n},in:(t,s,i)=>{let n=new Map;for(const r of t||[])n=e.select({id:r,value:!0,selected:new Map(n),children:s,parents:i});return n},out:(t,s)=>{const i=[];for(const[n,r]of t.entries())r==="on"&&!s.has(n)&&i.push(n);return i}};return e},Bu=Symbol.for("vuetify:nested"),x2={id:fe(),root:{register:()=>null,unregister:()=>null,parents:fe(new Map),children:fe(new Map),open:()=>null,openOnSelect:()=>null,select:()=>null,opened:fe(new Set),selected:fe(new Map),selectedValues:fe([])}},MX=Ye({selectStrategy:[String,Function],openStrategy:[String,Object],opened:Array,selected:Array,mandatory:Boolean},"nested"),PX=f=>{let e=!1;const t=fe(new Map),s=fe(new Map),i=Vt(f,"opened",f.opened,u=>new Set(u),u=>[...u.values()]),n=ie(()=>{if(typeof f.selectStrategy=="object")return f.selectStrategy;switch(f.selectStrategy){case"single-leaf":return _X(f.mandatory);case"leaf":return xX(f.mandatory);case"independent":return sw(f.mandatory);case"single-independent":return I2(f.mandatory);case"classic":default:return CX(f.mandatory)}}),r=ie(()=>{if(typeof f.openStrategy=="object")return f.openStrategy;switch(f.openStrategy){case"list":return IX;case"single":return OX;case"multiple":default:return O2}}),a=Vt(f,"selected",f.selected,u=>n.value.in(u,t.value,s.value),u=>n.value.out(u,t.value,s.value));mn(()=>{e=!0});function o(u){const h=[];let l=u;for(;l!=null;)h.unshift(l),l=s.value.get(l);return h}const d=ii("nested"),c={id:fe(),root:{opened:i,selected:a,selectedValues:ie(()=>{const u=[];for(const[h,l]of a.value.entries())l==="on"&&u.push(h);return u}),register:(u,h,l)=>{h&&u!==h&&s.value.set(u,h),l&&t.value.set(u,[]),h!=null&&t.value.set(h,[...t.value.get(h)||[],u])},unregister:u=>{var l;if(e)return;t.value.delete(u);const h=s.value.get(u);if(h){const p=(l=t.value.get(h))!=null?l:[];t.value.set(h,p.filter(m=>m!==u))}s.value.delete(u),i.value.delete(u)},open:(u,h,l)=>{d.emit("click:open",{id:u,value:h,path:o(u),event:l});const p=r.value.open({id:u,value:h,opened:new Set(i.value),children:t.value,parents:s.value,event:l});p&&(i.value=p)},openOnSelect:(u,h,l)=>{const p=r.value.select({id:u,value:h,selected:new Map(a.value),opened:new Set(i.value),children:t.value,parents:s.value,event:l});p&&(i.value=p)},select:(u,h,l)=>{d.emit("click:select",{id:u,value:h,path:o(u),event:l});const p=n.value.select({id:u,value:h,selected:new Map(a.value),children:t.value,parents:s.value,event:l});p&&(a.value=p),c.root.openOnSelect(u,h,l)},children:t,parents:s}};return Ni(Bu,c),c.root},_2=(f,e)=>{const t=Zt(Bu,x2),s=ie(()=>{var n;return(n=f.value)!=null?n:Symbol($i())}),i={...t,id:s,open:(n,r)=>t.root.open(s.value,n,r),openOnSelect:(n,r)=>t.root.openOnSelect(s.value,n,r),isOpen:ie(()=>t.root.opened.value.has(s.value)),parent:ie(()=>t.root.parents.value.get(s.value)),select:(n,r)=>t.root.select(s.value,n,r),isSelected:ie(()=>t.root.selected.value.get(s.value)==="on"),isIndeterminate:ie(()=>t.root.selected.value.get(s.value)==="indeterminate"),isLeaf:ie(()=>!t.root.children.value.get(s.value)),isGroupActivator:t.isGroupActivator};return!t.isGroupActivator&&t.root.register(s.value,t.id.value,e),mn(()=>{!t.isGroupActivator&&t.root.unregister(s.value)}),e&&Ni(Bu,i),i},AX=()=>{const f=Zt(Bu,x2);Ni(Bu,{...f,isGroupActivator:!0})},BX=Qe({name:"VListGroupActivator",setup(f,e){let{slots:t}=e;return AX(),()=>{var s;return(s=t.default)==null?void 0:s.call(t)}}}),EX=Ye({activeColor:String,color:String,collapseIcon:{type:It,default:"$collapse"},expandIcon:{type:It,default:"$expand"},prependIcon:It,appendIcon:It,fluid:Boolean,subgroup:Boolean,value:null,...cs()},"v-list-group"),C2=zs()({name:"VListGroup",props:{title:String,...EX()},setup(f,e){let{slots:t}=e;const{isOpen:s,open:i,id:n}=_2(je(f,"value"),!0),r=ie(()=>`v-list-group--id-${String(n.value)}`),a=T2();function o(u){i(!s.value,u)}const d=ie(()=>({onClick:o,class:"v-list-group__header",id:r.value})),c=ie(()=>s.value?f.collapseIcon:f.expandIcon);return Xe(()=>{var u;return $(f.tag,{class:["v-list-group",{"v-list-group--prepend":a==null?void 0:a.hasPrepend.value,"v-list-group--fluid":f.fluid,"v-list-group--subgroup":f.subgroup}]},{default:()=>[t.activator&&$(xs,{defaults:{VListItem:{active:s.value,activeColor:f.activeColor,color:f.color,prependIcon:f.prependIcon||f.subgroup&&c.value,appendIcon:f.appendIcon||!f.subgroup&&c.value,title:f.title,value:f.value}}},{default:()=>[$(BX,null,{default:()=>[t.activator({props:d.value,isOpen:s})]})]}),$(i2,null,{default:()=>[Gi($("div",{class:"v-list-group__items",role:"group","aria-labelledby":r.value},[(u=t.default)==null?void 0:u.call(t)]),[[Cd,s.value]])]})]})}),{}}});function NX(f){return or(f,Object.keys(C2.props))}const VX=Fd("v-list-item-subtitle"),qX=Fd("v-list-item-title"),Od=zs()({name:"VListItem",directives:{Ripple:ju},props:{active:{type:Boolean,default:void 0},activeClass:String,activeColor:String,appendAvatar:String,appendIcon:It,disabled:Boolean,lines:String,link:{type:Boolean,default:void 0},nav:Boolean,prependAvatar:String,prependIcon:It,subtitle:[String,Number,Boolean],title:[String,Number,Boolean],value:null,onClick:mo,onClickOnce:mo,...Nr(),...Vn(),...ko(),...cr(),...gn(),...Jl(),...cs(),..._s(),...qr({variant:"text"})},emits:{click:f=>!0},setup(f,e){let{attrs:t,slots:s,emit:i}=e;const n=Zl(f,t),r=ie(()=>{var R;return(R=f.value)!=null?R:n.href.value}),{select:a,isSelected:o,isIndeterminate:d,isGroupActivator:c,root:u,parent:h,openOnSelect:l}=_2(r,!1),p=T2(),m=ie(()=>{var R;return f.active!==!1&&(f.active||((R=n.isActive)==null?void 0:R.value)||o.value)}),g=ie(()=>f.link!==!1&&n.isLink.value),y=ie(()=>!f.disabled&&f.link!==!1&&(f.link||n.isClickable.value||f.value!=null&&!!p)),b=ie(()=>f.rounded||f.nav),w=ie(()=>{var R;return{color:m.value&&(R=f.activeColor)!=null?R:f.color,variant:f.variant}});st(()=>{var R;return(R=n.isActive)==null?void 0:R.value},R=>{R&&h.value!=null&&u.open(h.value,!0),R&&l(R)},{immediate:!0});const{themeClasses:k}=Rs(f),{borderClasses:T}=Vr(f),{colorClasses:O,colorStyles:x,variantClasses:C}=Hd(w),{densityClasses:E}=dr(f),{dimensionStyles:P}=So(f),{elevationClasses:_}=ur(f),{roundedClasses:S}=yn(b),I=ie(()=>f.lines?`v-list-item--${f.lines}-line`:void 0),v=ie(()=>({isActive:m.value,select:a,isSelected:o.value,isIndeterminate:d.value}));function N(R){var G;i("click",R),!(c||!y.value)&&((G=n.navigate)==null||G.call(n,R),f.value!=null&&a(!o.value,R))}function q(R){(R.key==="Enter"||R.key===" ")&&(R.preventDefault(),N(R))}return Xe(()=>{var R,G,F,A,V;const Q=g.value?"a":f.tag,J=!p||o.value||m.value,se=s.title||f.title,we=s.subtitle||f.subtitle,le=!!(s.append||f.appendAvatar||f.appendIcon),Oe=!!(s.prepend||f.prependAvatar||f.prependIcon);return p==null||p.updateHasPrepend(Oe),Gi($(Q,{class:["v-list-item",{"v-list-item--active":m.value,"v-list-item--disabled":f.disabled,"v-list-item--link":y.value,"v-list-item--nav":f.nav,"v-list-item--prepend":!Oe&&(p==null?void 0:p.hasPrepend.value),[`${f.activeClass}`]:f.activeClass&&m.value},k.value,T.value,J?O.value:void 0,E.value,_.value,I.value,S.value,C.value],style:[J?x.value:void 0,P.value],href:n.href.value,tabindex:y.value?0:void 0,onClick:N,onKeydown:y.value&&!g.value&&q},{default:()=>[Dd(y.value||m.value,"v-list-item"),Oe&&$(xs,{key:"prepend",defaults:{VAvatar:{density:f.density,image:f.prependAvatar},VIcon:{density:f.density,icon:f.prependIcon},VListItemAction:{start:!0}}},{default:()=>[$("div",{class:"v-list-item__prepend"},[f.prependAvatar&&$(go,{key:"prepend-avatar"},null),f.prependIcon&&$(gi,{key:"prepend-icon"},null),(R=s.prepend)==null?void 0:R.call(s,v.value)])]}),$("div",{class:"v-list-item__content"},[se&&$(qX,{key:"title"},{default:()=>{var Ce;return[(Ce=(G=s.title)==null?void 0:G.call(s,{title:f.title}))!=null?Ce:f.title]}}),we&&$(VX,{key:"subtitle"},{default:()=>{var Ce;return[(Ce=(F=s.subtitle)==null?void 0:F.call(s,{subtitle:f.subtitle}))!=null?Ce:f.subtitle]}}),(A=s.default)==null?void 0:A.call(s,v.value)]),le&&$(xs,{key:"append",defaults:{VAvatar:{density:f.density,image:f.appendAvatar},VIcon:{density:f.density,icon:f.appendIcon},VListItemAction:{end:!0}}},{default:()=>[$("div",{class:"v-list-item__append"},[(V=s.append)==null?void 0:V.call(s,v.value),f.appendIcon&&$(gi,{key:"append-icon"},null),f.appendAvatar&&$(go,{key:"append-avatar"},null)])]})]}),[[ka("ripple"),y.value]])}),{}}}),LX=Qe({name:"VListSubheader",props:{color:String,inset:Boolean,sticky:Boolean,title:String,...cs()},setup(f,e){let{slots:t}=e;const{textColorClasses:s,textColorStyles:i}=_r(je(f,"color"));return Xe(()=>{var n;const r=!!(t.default||f.title);return $(f.tag,{class:["v-list-subheader",{"v-list-subheader--inset":f.inset,"v-list-subheader--sticky":f.sticky},s.value],style:{textColorStyles:i}},{default:()=>{var a;return[r&&$("div",{class:"v-list-subheader__text"},[(a=(n=t.default)==null?void 0:n.call(t))!=null?a:f.title])]}})}),{}}}),M2=zs()({name:"VListChildren",props:{items:Array},setup(f,e){let{slots:t}=e;return v2(),()=>{var n;var s,i;return(n=(s=t.default)==null?void 0:s.call(t))!=null?n:(i=f.items)==null?void 0:i.map(r=>{var g,y;let{children:a,props:o,type:d,raw:c}=r;if(d==="divider"){var u;return(g=(u=t.divider)==null?void 0:u.call(t,{props:o}))!=null?g:$(dd,o,null)}if(d==="subheader"){var h;return(y=(h=t.subheader)==null?void 0:h.call(t,{props:o}))!=null?y:$(LX,o,{default:t.subheader})}const l={subtitle:t.subtitle?b=>{var w;return(w=t.subtitle)==null?void 0:w.call(t,{...b,item:c})}:void 0,prepend:t.prepend?b=>{var w;return(w=t.prepend)==null?void 0:w.call(t,{...b,item:c})}:void 0,append:t.append?b=>{var w;return(w=t.append)==null?void 0:w.call(t,{...b,item:c})}:void 0,default:t.default?b=>{var w;return(w=t.default)==null?void 0:w.call(t,{...b,item:c})}:void 0,title:t.title?b=>{var w;return(w=t.title)==null?void 0:w.call(t,{...b,item:c})}:void 0},[p,m]=NX(o);return a?$(C2,Je({value:o==null?void 0:o.value},p),{activator:b=>{let{props:w}=b;return t.header?t.header({...o,...w}):$(Od,Je(o,w),l)},default:()=>$(M2,{items:a},t)}):t.item?t.item(o):$(Od,o,l)})}}}),P2=Ye({items:{type:Array,default:()=>[]},itemTitle:{type:[String,Array,Function],default:"title"},itemValue:{type:[String,Array,Function],default:"value"},itemChildren:{type:[Boolean,String,Array,Function],default:"children"},itemProps:{type:[Boolean,String,Array,Function],default:"props"},returnObject:Boolean},"item");function A2(f,e){var a;const t=er(e,f.itemTitle,e),s=f.returnObject?e:er(e,f.itemValue,t),i=er(e,f.itemChildren),n=f.itemProps===!0?typeof e=="object"&&e!=null&&!Array.isArray(e)?"children"in e?or(e,["children"])[1]:e:void 0:er(e,f.itemProps),r={title:t,value:s,...n};return{title:String((a=r.title)!=null?a:""),value:r.value,props:r,children:Array.isArray(i)?B2(f,i):void 0,raw:e}}function B2(f,e){const t=[];for(const s of e)t.push(A2(f,s));return t}function E2(f){const e=ie(()=>B2(f,f.items));function t(i){return i.map(n=>A2(f,n))}function s(i){return i.map(n=>{let{props:r}=n;return r.value})}return{items:e,transformIn:t,transformOut:s}}function RX(f,e){const t=er(e,f.itemType,"item"),s=typeof e=="string"?e:er(e,f.itemTitle),i=er(e,f.itemValue,void 0),n=er(e,f.itemChildren),r=f.itemProps===!0?or(e,["children"])[1]:er(e,f.itemProps),a={title:s,value:i,...r};return{type:t,title:a.title,value:a.value,props:a,children:t==="item"&&n?N2(f,n):void 0,raw:e}}function N2(f,e){const t=[];for(const s of e)t.push(RX(f,s));return t}function FX(f){return{items:ie(()=>N2(f,f.items))}}const V2=zs()({name:"VList",props:{activeColor:String,activeClass:String,bgColor:String,disabled:Boolean,lines:{type:[Boolean,String],default:"one"},nav:Boolean,...MX({selectStrategy:"single-leaf",openStrategy:"list"}),...Nr(),...Vn(),...ko(),...cr(),itemType:{type:String,default:"type"},...P2(),...gn(),...cs(),..._s(),...qr({variant:"text"})},emits:{"update:selected":f=>!0,"update:opened":f=>!0,"click:open":f=>!0,"click:select":f=>!0},setup(f,e){let{slots:t}=e;const{items:s}=FX(f),{themeClasses:i}=Rs(f),{backgroundColorClasses:n,backgroundColorStyles:r}=nr(je(f,"bgColor")),{borderClasses:a}=Vr(f),{densityClasses:o}=dr(f),{dimensionStyles:d}=So(f),{elevationClasses:c}=ur(f),{roundedClasses:u}=yn(f),{open:h,select:l}=PX(f),p=ie(()=>f.lines?`v-list--${f.lines}-line`:void 0),m=je(f,"activeColor"),g=je(f,"color");v2(),Er({VListGroup:{activeColor:m,color:g},VListItem:{activeClass:je(f,"activeClass"),activeColor:m,color:g,density:je(f,"density"),disabled:je(f,"disabled"),lines:je(f,"lines"),nav:je(f,"nav"),variant:je(f,"variant")}});const y=fe(!1),b=fe();function w(C){y.value=!0}function k(C){y.value=!1}function T(C){var E;!y.value&&!(C.relatedTarget&&(E=b.value)!=null&&E.contains(C.relatedTarget))&&x()}function O(C){if(!!b.value){if(C.key==="ArrowDown")x("next");else if(C.key==="ArrowUp")x("prev");else if(C.key==="Home")x("first");else if(C.key==="End")x("last");else return;C.preventDefault()}}function x(C){if(!b.value)return;const E=[...b.value.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])')].filter(v=>!v.hasAttribute("disabled")),P=E.indexOf(document.activeElement);if(C)if(C==="first"){var S;(S=E[0])==null||S.focus()}else if(C==="last"){var I;(I=E.at(-1))==null||I.focus()}else{let v,N=P;const q=C==="next"?1:-1;do N+=q,v=E[N];while((!v||v.offsetParent==null)&&N<E.length&&N>=0);v?v.focus():x(C==="next"?"first":"last")}else{var _;(_=E[0])==null||_.focus()}}return Xe(()=>$(f.tag,{ref:b,class:["v-list",{"v-list--disabled":f.disabled,"v-list--nav":f.nav},i.value,n.value,a.value,o.value,c.value,p.value,u.value],style:[r.value,d.value],role:"listbox","aria-activedescendant":void 0,onFocusin:w,onFocusout:k,onFocus:T,onKeydown:O},{default:()=>[$(M2,{items:s.value},t)]})),{open:h,select:l,focus:x}}});const DX=Ye({closeDelay:[Number,String],openDelay:[Number,String]},"delay");function HX(f,e){const t={},s=i=>()=>{if(!ds)return Promise.resolve(!0);const n=i==="openDelay";return t.closeDelay&&window.clearTimeout(t.closeDelay),delete t.closeDelay,t.openDelay&&window.clearTimeout(t.openDelay),delete t.openDelay,new Promise(r=>{var o;const a=parseInt((o=f[i])!=null?o:0,10);t[i]=window.setTimeout(()=>{e==null||e(n),r(n)},a)})};return{runCloseDelay:s("closeDelay"),runOpenDelay:s("openDelay")}}const By=Symbol.for("vuetify:v-menu"),GX=Ye({activator:[String,Object],activatorProps:{type:Object,default:()=>({})},openOnClick:{type:Boolean,default:void 0},openOnHover:Boolean,openOnFocus:{type:Boolean,default:void 0},closeOnContentClick:Boolean,...DX()},"v-overlay-activator");function UX(f,e){let{isActive:t,isTop:s}=e;const i=fe();let n=!1,r=!1,a=!0;const o=ie(()=>f.openOnFocus||f.openOnFocus==null&&f.openOnHover),d=ie(()=>f.openOnClick||f.openOnClick==null&&!f.openOnHover&&!o.value),{runOpenDelay:c,runCloseDelay:u}=HX(f,w=>{w===(f.openOnHover&&n||o.value&&r)&&!(f.openOnHover&&t.value&&!s.value)&&(t.value!==w&&(a=!0),t.value=w)}),h={click:w=>{w.stopPropagation(),i.value=w.currentTarget||w.target,t.value=!t.value},mouseenter:w=>{n=!0,i.value=w.currentTarget||w.target,c()},mouseleave:w=>{n=!1,u()},focus:w=>{xy&&!w.target.matches(":focus-visible")||(r=!0,w.stopPropagation(),i.value=w.currentTarget||w.target,c())},blur:w=>{r=!1,w.stopPropagation(),u()}},l=ie(()=>{const w={};return d.value&&(w.click=h.click),f.openOnHover&&(w.mouseenter=h.mouseenter,w.mouseleave=h.mouseleave),o.value&&(w.focus=h.focus,w.blur=h.blur),w}),p=ie(()=>{const w={};if(f.openOnHover&&(w.mouseenter=()=>{n=!0,c()},w.mouseleave=()=>{n=!1,u()}),f.closeOnContentClick){const k=Zt(By,null);w.click=()=>{t.value=!1,k==null||k.closeParents()}}return w}),m=ie(()=>{const w={};return f.openOnHover&&(w.mouseenter=()=>{a&&(n=!0,a=!1,c())},w.mouseleave=()=>{n=!1,u()}),w});st(s,w=>{w&&(f.openOnHover&&!n&&(!o.value||!r)||o.value&&!r&&(!f.openOnHover||!n))&&(t.value=!1)});const g=fe();Mr(()=>{!g.value||Bi(()=>{const w=g.value;i.value=Rz(w)?w.$el:w})});const y=ii("useActivator");let b;return st(()=>!!f.activator,w=>{w&&ds?(b=wl(),b.run(()=>{$X(f,y,{activatorEl:i,activatorEvents:l})})):b&&b.stop()},{flush:"post",immediate:!0}),rr(()=>{var w;(w=b)==null||w.stop()}),{activatorEl:i,activatorRef:g,activatorEvents:l,contentEvents:p,scrimEvents:m}}function $X(f,e,t){let{activatorEl:s,activatorEvents:i}=t;st(()=>f.activator,(o,d)=>{if(d&&o!==d){const c=a(d);c&&r(c)}o&&Bi(()=>n())},{immediate:!0}),st(()=>f.activatorProps,()=>{n()}),rr(()=>{r()});function n(){let o=arguments.length>0&&arguments[0]!==void 0?arguments[0]:a(),d=arguments.length>1&&arguments[1]!==void 0?arguments[1]:f.activatorProps;!o||(Object.entries(i.value).forEach(c=>{let[u,h]=c;o.addEventListener(u,h)}),Object.keys(d).forEach(c=>{d[c]==null?o.removeAttribute(c):o.setAttribute(c,d[c])}))}function r(){let o=arguments.length>0&&arguments[0]!==void 0?arguments[0]:a(),d=arguments.length>1&&arguments[1]!==void 0?arguments[1]:f.activatorProps;!o||(Object.entries(i.value).forEach(c=>{let[u,h]=c;o.removeEventListener(u,h)}),Object.keys(d).forEach(c=>{o.removeAttribute(c)}))}function a(){var o;let d=arguments.length>0&&arguments[0]!==void 0?arguments[0]:f.activator,c;if(d)if(d==="parent"){var u,h;let l=e==null||(u=e.proxy)==null||(h=u.$el)==null?void 0:h.parentNode;for(;l.hasAttribute("data-no-activator");)l=l.parentNode;c=l}else typeof d=="string"?c=document.querySelector(d):"$el"in d?c=d.$el:c=d;return s.value=((o=c)==null?void 0:o.nodeType)===Node.ELEMENT_NODE?c:null,s.value}}const jX=Ye({eager:Boolean},"lazy");function WX(f,e){const t=fe(!1),s=ie(()=>t.value||f.eager||e.value);st(e,()=>t.value=!0);function i(){f.eager||(t.value=!1)}return{isBooted:t,hasContent:s,onAfterLeave:i}}function Xg(f,e){return{x:f.x+e.x,y:f.y+e.y}}function zX(f,e){return{x:f.x-e.x,y:f.y-e.y}}function QO(f,e){if(f.side==="top"||f.side==="bottom"){const{side:t,align:s}=f,i=s==="left"?0:s==="center"?e.width/2:s==="right"?e.width:s,n=t==="top"?0:t==="bottom"?e.height:t;return Xg({x:i,y:n},e)}else if(f.side==="left"||f.side==="right"){const{side:t,align:s}=f,i=t==="left"?0:t==="right"?e.width:t,n=s==="top"?0:s==="center"?e.height/2:s==="bottom"?e.height:s;return Xg({x:i,y:n},e)}return Xg({x:e.width/2,y:e.height/2},e)}const q2={static:YX,connected:ZX},KX=Ye({locationStrategy:{type:[String,Function],default:"static",validator:f=>typeof f=="function"||f in q2},location:{type:String,default:"bottom"},origin:{type:String,default:"auto"},offset:[Number,String,Array]},"v-overlay-location-strategies");function XX(f,e){const t=fe({}),s=fe();let i;Mr(async()=>{var r;(r=i)==null||r.stop(),s.value=void 0,ds&&e.isActive.value&&f.locationStrategy&&(i=wl(),await Bi(),i.run(()=>{if(typeof f.locationStrategy=="function"){var a;s.value=(a=f.locationStrategy(e,f,t))==null?void 0:a.updateLocation}else{var o;s.value=(o=q2[f.locationStrategy](e,f,t))==null?void 0:o.updateLocation}}))}),ds&&window.addEventListener("resize",n,{passive:!0}),rr(()=>{var r;ds&&window.removeEventListener("resize",n),s.value=void 0,(r=i)==null||r.stop()});function n(r){var a;(a=s.value)==null||a.call(s,r)}return{contentStyles:t,updateLocation:s}}function YX(){}function QX(f){const e=Lb(f);return e.x-=parseFloat(f.style.left||0),e.y-=parseFloat(f.style.top||0),e}function ZX(f,e,t){const s=cK(f.activatorEl.value);s&&Object.assign(t.value,{position:"fixed"});const{preferredAnchor:i,preferredOrigin:n}=qb(()=>{const p=Ty(e.location,f.isRtl.value),m=e.origin==="overlap"?p:e.origin==="auto"?Gg(p):Ty(e.origin,f.isRtl.value);return p.side===m.side&&p.align===Ug(m).align?{preferredAnchor:AO(p),preferredOrigin:AO(m)}:{preferredAnchor:p,preferredOrigin:m}}),[r,a,o,d]=["minWidth","minHeight","maxWidth","maxHeight"].map(p=>ie(()=>{const m=parseFloat(e[p]);return isNaN(m)?1/0:m})),c=ie(()=>{if(Array.isArray(e.offset))return e.offset;if(typeof e.offset=="string"){const p=e.offset.split(" ").map(parseFloat);return p.length<2&&p.push(0),p}return typeof e.offset=="number"?[e.offset,0]:[0,0]});let u=!1;const h=new ResizeObserver(()=>{u&&l()});st([f.activatorEl,f.contentEl],(p,m)=>{let[g,y]=p,[b,w]=m;b&&h.unobserve(b),g&&h.observe(g),w&&h.unobserve(w),y&&h.observe(y)},{immediate:!0}),rr(()=>{h.disconnect()});function l(){if(u=!1,requestAnimationFrame(()=>{requestAnimationFrame(()=>u=!0)}),!f.activatorEl.value||!f.contentEl.value)return;const p=f.activatorEl.value.getBoundingClientRect(),m=QX(f.contentEl.value),g=dl(f.contentEl.value),y=12;g.length||(g.push(document.documentElement),f.contentEl.value.style.top&&f.contentEl.value.style.left||(m.x+=parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-x")||0),m.y+=parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-y")||0)));const b=g.reduce((_,S)=>{const I=S.getBoundingClientRect(),v=new gd({x:S===document.documentElement?0:I.x,y:S===document.documentElement?0:I.y,width:S.clientWidth,height:S.clientHeight});return _?new gd({x:Math.max(_.left,v.left),y:Math.max(_.top,v.top),width:Math.min(_.right,v.right)-Math.max(_.left,v.left),height:Math.min(_.bottom,v.bottom)-Math.max(_.top,v.top)}):v},void 0);b.x+=y,b.y+=y,b.width-=y*2,b.height-=y*2;let w={anchor:i.value,origin:n.value};function k(_){const S=new gd(m),I=QO(_.anchor,p),v=QO(_.origin,S);let{x:N,y:q}=zX(I,v);switch(_.anchor.side){case"top":q-=c.value[0];break;case"bottom":q+=c.value[0];break;case"left":N-=c.value[0];break;case"right":N+=c.value[0];break}switch(_.anchor.align){case"top":q-=c.value[1];break;case"bottom":q+=c.value[1];break;case"left":N-=c.value[1];break;case"right":N+=c.value[1];break}return S.x+=N,S.y+=q,S.width=Math.min(S.width,o.value),S.height=Math.min(S.height,d.value),{overflows:EO(S,b),x:N,y:q}}let T=0,O=0;const x={x:0,y:0},C={x:!1,y:!1};let E=-1;for(;;){if(E++>10){Iy("Infinite loop detected in connectedLocationStrategy");break}const{x:_,y:S,overflows:I}=k(w);T+=_,O+=S,m.x+=_,m.y+=S;{const v=BO(w.anchor),N=I.x.before||I.x.after,q=I.y.before||I.y.after;let R=!1;if(["x","y"].forEach(G=>{if(G==="x"&&N&&!C.x||G==="y"&&q&&!C.y){const F={anchor:{...w.anchor},origin:{...w.origin}},A=G==="x"?v==="y"?Ug:Gg:v==="y"?Gg:Ug;F.anchor=A(F.anchor),F.origin=A(F.origin);const{overflows:V}=k(F);(V[G].before<=I[G].before&&V[G].after<=I[G].after||V[G].before+V[G].after<(I[G].before+I[G].after)/2)&&(w=F,R=C[G]=!0)}}),R)continue}I.x.before&&(T+=I.x.before,m.x+=I.x.before),I.x.after&&(T-=I.x.after,m.x-=I.x.after),I.y.before&&(O+=I.y.before,m.y+=I.y.before),I.y.after&&(O-=I.y.after,m.y-=I.y.after);{const v=EO(m,b);x.x=b.width-v.x.before-v.x.after,x.y=b.height-v.y.before-v.y.after,T+=v.x.before,m.x+=v.x.before,O+=v.y.before,m.y+=v.y.before}break}const P=BO(w.anchor);Object.assign(t.value,{"--v-overlay-anchor-origin":`${w.anchor.side} ${w.anchor.align}`,transformOrigin:`${w.origin.side} ${w.origin.align}`,top:ze(ZO(O)),left:ze(ZO(T)),minWidth:ze(P==="y"?Math.min(r.value,p.width):r.value),maxWidth:ze(JO(vy(x.x,r.value===1/0?0:r.value,o.value))),maxHeight:ze(JO(vy(x.y,a.value===1/0?0:a.value,d.value)))})}return st(()=>[i.value,n.value,e.offset,e.minWidth,e.minHeight,e.maxWidth,e.maxHeight],()=>l(),{immediate:!s}),s&&Bi(()=>l()),requestAnimationFrame(()=>{t.value.maxHeight&&l()}),{updateLocation:l}}function ZO(f){return Math.round(f*devicePixelRatio)/devicePixelRatio}function JO(f){return Math.ceil(f*devicePixelRatio)/devicePixelRatio}let Ey=!0;const ll=[];function JX(f){!Ey||ll.length?(ll.push(f),Ny()):(Ey=!1,f(),Ny())}let eI=-1;function Ny(){cancelAnimationFrame(eI),eI=requestAnimationFrame(()=>{const f=ll.shift();f&&f(),ll.length?Ny():Ey=!0})}const Vy={none:null,close:sY,block:iY,reposition:nY},eY=Ye({scrollStrategy:{type:[String,Function],default:"block",validator:f=>typeof f=="function"||f in Vy}},"v-overlay-scroll-strategies");function tY(f,e){if(!ds)return;let t;Mr(async()=>{var s;(s=t)==null||s.stop(),e.isActive.value&&f.scrollStrategy&&(t=wl(),await Bi(),t.run(()=>{if(typeof f.scrollStrategy=="function")f.scrollStrategy(e,f);else{var i;(i=Vy[f.scrollStrategy])==null||i.call(Vy,e,f)}}))}),rr(()=>{var s;(s=t)==null||s.stop()})}function sY(f){var t;function e(s){f.isActive.value=!1}L2((t=f.activatorEl.value)!=null?t:f.contentEl.value,e)}function iY(f,e){var t;const s=(t=f.root.value)==null?void 0:t.offsetParent,i=[...new Set([...dl(f.activatorEl.value,e.contained?s:void 0),...dl(f.contentEl.value,e.contained?s:void 0)])].filter(a=>!a.classList.contains("v-overlay-scroll-blocked")),n=window.innerWidth-document.documentElement.offsetWidth,r=(a=>Fb(a)&&a)(s||document.documentElement);r&&f.root.value.classList.add("v-overlay--scroll-blocked"),i.forEach((a,o)=>{a.style.setProperty("--v-body-scroll-x",ze(-a.scrollLeft)),a.style.setProperty("--v-body-scroll-y",ze(-a.scrollTop)),a.style.setProperty("--v-scrollbar-offset",ze(n)),a.classList.add("v-overlay-scroll-blocked")}),rr(()=>{i.forEach((a,o)=>{const d=parseFloat(a.style.getPropertyValue("--v-body-scroll-x")),c=parseFloat(a.style.getPropertyValue("--v-body-scroll-y"));a.style.removeProperty("--v-body-scroll-x"),a.style.removeProperty("--v-body-scroll-y"),a.style.removeProperty("--v-scrollbar-offset"),a.classList.remove("v-overlay-scroll-blocked"),a.scrollLeft=-d,a.scrollTop=-c}),r&&f.root.value.classList.remove("v-overlay--scroll-blocked")})}function nY(f){var i;let e=!1,t=-1;function s(n){JX(()=>{var r,a;const o=performance.now();(r=(a=f.updateLocation).value)==null||r.call(a,n),e=(performance.now()-o)/(1e3/60)>2})}L2((i=f.activatorEl.value)!=null?i:f.contentEl.value,n=>{e?(cancelAnimationFrame(t),t=requestAnimationFrame(()=>{t=requestAnimationFrame(()=>{s(n)})})):s(n)})}function L2(f,e){const t=[document,...dl(f)];t.forEach(s=>{s.addEventListener("scroll",e,{passive:!0})}),rr(()=>{t.forEach(s=>{s.removeEventListener("scroll",e)})})}function rY(){var f,e,t;if(!ds)return fe(!1);const s=ii("useHydration"),i=s==null||(f=s.root)==null||(e=f.appContext)==null||(t=e.app)==null?void 0:t._container,n=fe(!!(i!=null&&i.__vue_app__));return n.value||ar(()=>n.value=!0),n}const tI=Symbol.for("vuetify:stack"),iu=ti([]);function aY(f,e){const t=ii("useStack"),s=Zt(tI,void 0),i=ti({activeChildren:new Set});Ni(tI,i);const n=fe(+e.value);Td(f,()=>{var o;const d=(o=iu.at(-1))==null?void 0:o[1];n.value=d?d+10:+e.value,iu.push([t.uid,n.value]),s==null||s.activeChildren.add(t.uid),rr(()=>{const c=iu.findIndex(u=>u[0]===t.uid);iu.splice(c,1),s==null||s.activeChildren.delete(t.uid)})});const r=fe(!0);Mr(()=>{var o;const d=((o=iu.at(-1))==null?void 0:o[0])===t.uid;setTimeout(()=>r.value=d)});const a=ie(()=>!i.activeChildren.size);return{globalTop:Eu(r),localTop:a,stackStyles:ie(()=>({zIndex:n.value}))}}function yu(f){return{teleportTarget:ie(()=>{const t=f.value;if(t===!0||!ds)return;const s=t===!1?document.body:typeof t=="string"?document.querySelector(t):t;if(s!=null){if(!yu.cache.has(s)){const i=document.createElement("div");i.className="v-overlay-container",s.appendChild(i),yu.cache.set(s,i)}return yu.cache.get(s)}})}}yu.cache=new WeakMap;function oY(){return!0}function R2(f,e,t){if(!f||F2(f,t)===!1)return!1;const s=AC(e);if(typeof ShadowRoot<"u"&&s instanceof ShadowRoot&&s.host===f.target)return!1;const i=(typeof t.value=="object"&&t.value.include||(()=>[]))();return i.push(e),!i.some(n=>n==null?void 0:n.contains(f.target))}function F2(f,e){return(typeof e.value=="object"&&e.value.closeConditional||oY)(f)}function dY(f,e,t){const s=typeof t.value=="function"?t.value:t.value.handler;e._clickOutside.lastMousedownWasOutside&&R2(f,e,t)&&setTimeout(()=>{F2(f,t)&&s&&s(f)},0)}function sI(f,e){const t=AC(f);e(document),typeof ShadowRoot<"u"&&t instanceof ShadowRoot&&e(t)}const cY={mounted(f,e){const t=i=>dY(i,f,e),s=i=>{f._clickOutside.lastMousedownWasOutside=R2(i,f,e)};sI(f,i=>{i.addEventListener("click",t,!0),i.addEventListener("mousedown",s,!0)}),f._clickOutside||(f._clickOutside={lastMousedownWasOutside:!0}),f._clickOutside[e.instance.$.uid]={onClick:t,onMousedown:s}},unmounted(f,e){!f._clickOutside||(sI(f,t=>{var s;if(!t||!((s=f._clickOutside)!=null&&s[e.instance.$.uid]))return;const{onClick:i,onMousedown:n}=f._clickOutside[e.instance.$.uid];t.removeEventListener("click",i,!0),t.removeEventListener("mousedown",n,!0)}),delete f._clickOutside[e.instance.$.uid])}};function uY(f){const{modelValue:e,color:t,...s}=f;return $(sr,{name:"fade-transition",appear:!0},{default:()=>[f.modelValue&&$("div",Je({class:["v-overlay__scrim",f.color.backgroundColorClasses.value],style:f.color.backgroundColorStyles.value},s),null)]})}const tp=Ye({absolute:Boolean,attach:[Boolean,String,Object],closeOnBack:{type:Boolean,default:!0},contained:Boolean,contentClass:null,contentProps:null,disabled:Boolean,noClickAnimation:Boolean,modelValue:Boolean,persistent:Boolean,scrim:{type:[String,Boolean],default:!0},zIndex:{type:[Number,String],default:2e3},...GX(),...ko(),...jX(),...KX(),...eY(),..._s(),...Gd()},"v-overlay"),sp=zs()({name:"VOverlay",directives:{ClickOutside:cY},inheritAttrs:!1,props:tp(),emits:{"click:outside":f=>!0,"update:modelValue":f=>!0,afterLeave:()=>!0},setup(f,e){let{slots:t,attrs:s,emit:i}=e;const n=Vt(f,"modelValue"),r=ie({get:()=>n.value,set:G=>{G&&f.disabled||(n.value=G)}}),{teleportTarget:a}=yu(ie(()=>f.attach||f.contained)),{themeClasses:o}=Rs(f),{rtlClasses:d,isRtl:c}=Wu(),{hasContent:u,onAfterLeave:h}=WX(f,r),l=nr(ie(()=>typeof f.scrim=="string"?f.scrim:null)),{globalTop:p,localTop:m,stackStyles:g}=aY(r,je(f,"zIndex")),{activatorEl:y,activatorRef:b,activatorEvents:w,contentEvents:k,scrimEvents:T}=UX(f,{isActive:r,isTop:m}),{dimensionStyles:O}=So(f),x=rY();st(()=>f.disabled,G=>{G&&(r.value=!1)});const C=fe(),E=fe(),{contentStyles:P,updateLocation:_}=XX(f,{isRtl:c,contentEl:E,activatorEl:y,isActive:r});tY(f,{root:C,contentEl:E,activatorEl:y,isActive:r,updateLocation:_});function S(G){i("click:outside",G),f.persistent?R():r.value=!1}function I(){return r.value&&p.value}ds&&st(r,G=>{G?window.addEventListener("keydown",v):window.removeEventListener("keydown",v)},{immediate:!0});function v(G){G.key==="Escape"&&p.value&&(f.persistent?R():r.value=!1)}const N=ZC();Td(()=>f.closeOnBack,()=>{XK(N,G=>{p.value&&r.value?(G(!1),f.persistent?R():r.value=!1):G()})});const q=fe();st(()=>r.value&&(f.absolute||f.contained)&&a.value==null,G=>{if(G){const F=oK(C.value);F&&F!==document.scrollingElement&&(q.value=F.scrollTop)}});function R(){f.noClickAnimation||E.value&&ud(E.value,[{transformOrigin:"center"},{transform:"scale(1.03)"},{transformOrigin:"center"}],{duration:150,easing:ol})}return Xe(()=>{var G,F;return $(Ft,null,[(G=t.activator)==null?void 0:G.call(t,{isActive:r.value,props:Je({ref:b},xp(w.value),f.activatorProps)}),x.value&&$(GP,{disabled:!a.value,to:a.value},{default:()=>[u.value&&$("div",Je({class:["v-overlay",{"v-overlay--absolute":f.absolute||f.contained,"v-overlay--active":r.value,"v-overlay--contained":f.contained},o.value,d.value],style:[g.value,{top:ze(q.value)}],ref:C},s),[$(uY,Je({color:l,modelValue:r.value&&!!f.scrim},xp(T.value)),null),$(fo,{appear:!0,persisted:!0,transition:f.transition,target:y.value,onAfterLeave:()=>{h(),i("afterLeave")}},{default:()=>[Gi($("div",Je({ref:E,class:["v-overlay__content",f.contentClass],style:[O.value,P.value]},xp(k.value),f.contentProps),[(F=t.default)==null?void 0:F.call(t,{isActive:r})]),[[Cd,r.value],[ka("click-outside"),{handler:S,closeConditional:I,include:()=>[y.value]}]])]})])]})])}),{activatorEl:y,animateClick:R,contentEl:E,globalTop:p,localTop:m,updateLocation:_}}});function iw(f){return or(f,Object.keys(sp.props))}function nw(){const e=ii("useScopeId").vnode.scopeId;return{scopeId:e?{[e]:""}:void 0}}const D2=zs()({name:"VMenu",props:{id:String,...Kl(tp({closeDelay:250,closeOnContentClick:!0,locationStrategy:"connected",openDelay:300,scrim:!1,scrollStrategy:"reposition",transition:{component:Qb}}),["absolute"])},emits:{"update:modelValue":f=>!0},setup(f,e){let{slots:t}=e;const s=Vt(f,"modelValue"),{scopeId:i}=nw(),n=$i(),r=ie(()=>f.id||`v-menu-${n}`),a=fe(),o=Zt(By,null);let d=0;Ni(By,{register(){++d},unregister(){--d},closeParents(){setTimeout(()=>{d||(s.value=!1,o==null||o.closeParents())},40)}}),st(s,u=>{u?o==null||o.register():o==null||o.unregister()});function c(){o==null||o.closeParents()}return Xe(()=>{const[u]=iw(f);return $(sp,Je({ref:a,class:["v-menu"]},u,{modelValue:s.value,"onUpdate:modelValue":h=>s.value=h,absolute:!0,activatorProps:Je({"aria-haspopup":"menu","aria-expanded":String(s.value),"aria-owns":r.value},f.activatorProps),"onClick:outside":c},i),{activator:t.activator,default:function(){for(var h,l=arguments.length,p=new Array(l),m=0;m<l;m++)p[m]=arguments[m];return $(xs,{root:!0},{default:()=>[(h=t.default)==null?void 0:h.call(t,...p)]})}})}),Ud({id:r},a)}}),H2=Ye({chips:Boolean,closableChips:Boolean,eager:Boolean,hideNoData:Boolean,hideSelected:Boolean,menu:Boolean,menuIcon:{type:It,default:"$dropdown"},menuProps:{type:Object},multiple:Boolean,noDataText:{type:String,default:"$vuetify.noDataText"},openOnClear:Boolean,...P2({itemChildren:!1})},"v-select");zs()({name:"VSelect",props:{...H2(),...Kl(tw({modelValue:null}),["validationValue","dirty","appendInnerIcon"]),...Gd({transition:{component:Qb}})},emits:{"update:modelValue":f=>!0,"update:menu":f=>!0},setup(f,e){let{slots:t}=e;const{t:s}=Ql(),i=fe(),n=Vt(f,"menu"),{items:r,transformIn:a,transformOut:o}=E2(f),d=Vt(f,"modelValue",[],w=>a(tr(w)),w=>{var T;const k=o(w);return f.multiple?k:(T=k[0])!=null?T:null}),c=ie(()=>d.value.map(w=>r.value.find(k=>k.value===w.value)||w)),u=ie(()=>c.value.map(w=>w.props.value)),h=fe();function l(w){d.value=[],f.openOnClear&&(n.value=!0)}function p(){f.hideNoData&&!r.value.length||f.readonly||(n.value=!n.value)}function m(w){if(!f.readonly){if(["Enter","ArrowDown"," "].includes(w.key)&&(w.preventDefault(),n.value=!0),["Escape","Tab"].includes(w.key)&&(n.value=!1),w.key==="ArrowDown"){var k;(k=h.value)==null||k.focus("next")}else if(w.key==="ArrowUp"){var T;w.preventDefault(),(T=h.value)==null||T.focus("prev")}else if(w.key==="Home"){var O;w.preventDefault(),(O=h.value)==null||O.focus("first")}else if(w.key==="End"){var x;w.preventDefault(),(x=h.value)==null||x.focus("last")}}}function g(w){if(f.multiple){const k=u.value.findIndex(T=>T===w.value);if(k===-1)d.value=[...d.value,w];else{const T=[...d.value];T.splice(k,1),d.value=T}}else d.value=[w],n.value=!1}function y(w){var k;(k=h.value)!=null&&k.$el.contains(w.relatedTarget)||(n.value=!1)}function b(w){if(w.relatedTarget==null){var k;(k=i.value)==null||k.focus()}}return Xe(()=>{const w=!!(f.chips||t.chip),[k]=m2(f);return $(Yn,Je({ref:i},k,{modelValue:d.value.map(T=>T.props.value).join(", "),"onUpdate:modelValue":T=>{T==null&&(d.value=[])},validationValue:d.externalValue,dirty:d.value.length>0,class:["v-select",{"v-select--active-menu":n.value,"v-select--chips":!!f.chips,[`v-select--${f.multiple?"multiple":"single"}`]:!0,"v-select--selected":d.value.length}],appendInnerIcon:f.menuIcon,readonly:!0,"onClick:clear":l,"onClick:control":p,onBlur:y,onKeydown:m}),{...t,default:()=>{var T,O,x;return $(Ft,null,[$(D2,Je({modelValue:n.value,"onUpdate:modelValue":C=>n.value=C,activator:"parent",contentClass:"v-select__content",eager:f.eager,openOnClick:!1,closeOnContentClick:!1,transition:f.transition},f.menuProps),{default:()=>[$(V2,{ref:h,selected:u.value,selectStrategy:f.multiple?"independent":"single-independent",onMousedown:C=>C.preventDefault(),onFocusout:b},{default:()=>{var C;return[!r.value.length&&!f.hideNoData&&((C=(T=t["no-data"])==null?void 0:T.call(t))!=null?C:$(Od,{title:s(f.noDataText)},null)),(O=t["prepend-item"])==null?void 0:O.call(t),r.value.map((E,P)=>{var S;var _;return(S=(_=t.item)==null?void 0:_.call(t,{item:E,index:P,props:Je(E.props,{onClick:()=>g(E)})}))!=null?S:$(Od,Je({key:P},E.props,{onClick:()=>g(E)}),{prepend:I=>{let{isSelected:v}=I;return f.multiple&&!f.hideSelected?$(ep,{modelValue:v,ripple:!1},null):void 0}})}),(x=t["append-item"])==null?void 0:x.call(t)]}})]}),c.value.map((C,E)=>{function P(S){S.stopPropagation(),S.preventDefault(),g(C)}const _={"onClick:close":P,modelValue:!0,"onUpdate:modelValue":void 0};return $("div",{key:C.value,class:"v-select__selection"},[w?$(xs,{defaults:{VChip:{closable:f.closableChips,size:"small",text:C.title}}},{default:()=>[t.chip?t.chip({item:C,index:E,props:_}):$(S2,_,null)]}):t.selection?t.selection({item:C,index:E}):$("span",{class:"v-select__selection-text"},[C.title,f.multiple&&E<c.value.length-1&&$("span",{class:"v-select__selection-comma"},[et(",")])])])})])}})}),Ud({menu:n,select:g},i)}});const fY=(f,e,t)=>f==null||e==null?-1:f.toString().toLocaleLowerCase().indexOf(e.toString().toLocaleLowerCase()),hY=Ye({customFilter:Function,customKeyFilter:Object,filterKeys:[Array,String],filterMode:{type:String,default:"intersection"},noFilter:Boolean},"filter");function lY(f,e,t){var o,d;const s=[],i=(o=t==null?void 0:t.default)!=null?o:fY,n=t!=null&&t.filterKeys?tr(t.filterKeys):!1,r=Object.keys((d=t==null?void 0:t.customKeyFilter)!=null?d:{}).length;if(!(f!=null&&f.length))return s;e:for(let c=0;c<f.length;c++){const u=f[c],h={},l={};let p=-1;if(e&&!(t!=null&&t.noFilter)){if(typeof u=="object"){const y=n||Object.keys(u);for(const b of y){var a;const w=er(u,b,u),k=t==null||(a=t.customKeyFilter)==null?void 0:a[b];if(p=k?k(w,e,u):i(w,e,u),p!==-1&&p!==!1)k?h[b]=p:l[b]=p;else if((t==null?void 0:t.filterMode)==="every")continue e}}else p=i(u,e,u),p!==-1&&p!==!1&&(l.title=p);const m=Object.keys(l).length,g=Object.keys(h).length;if(!m&&!g||(t==null?void 0:t.filterMode)==="union"&&g!==r&&!m||(t==null?void 0:t.filterMode)==="intersection"&&(g!==r||!m))continue}s.push({index:c,matches:{...l,...h}})}return s}function pY(f,e,t){const s=ie(()=>typeof(t==null?void 0:t.value)!="string"&&typeof(t==null?void 0:t.value)!="number"?"":String(t.value));return{filteredItems:ie(()=>{const n=ei(e);return lY(n,s.value,{customKeyFilter:f.customKeyFilter,default:f.customFilter,filterKeys:f.filterKeys,filterMode:f.filterMode,noFilter:f.noFilter}).map(a=>{let{index:o,matches:d}=a;return{item:n[o],matches:d}})})}}function mY(f,e,t){if(Array.isArray(e))throw new Error("Multiple matches is not implemented");return typeof e=="number"&&~e?$(Ft,null,[$("span",{class:"v-autocomplete__unmask"},[f.substr(0,e)]),$("span",{class:"v-autocomplete__mask"},[f.substr(e,t)]),$("span",{class:"v-autocomplete__unmask"},[f.substr(e+t)])]):f}const gY=zs()({name:"VAutocomplete",props:{search:String,...hY({filterKeys:["title"]}),...H2(),...Kl(tw({modelValue:null}),["validationValue","dirty","appendInnerIcon"]),...Gd({transition:!1})},emits:{"update:search":f=>!0,"update:modelValue":f=>!0,"update:menu":f=>!0},setup(f,e){let{slots:t}=e;const{t:s}=Ql(),i=fe(),n=fe(!1),r=fe(!0),a=Vt(f,"menu"),{items:o,transformIn:d,transformOut:c}=E2(f),u=Vt(f,"search",""),h=Vt(f,"modelValue",[],P=>d(tr(P)),P=>{var S;const _=c(P);return f.multiple?_:(S=_[0])!=null?S:null}),{filteredItems:l}=pY(f,o,ie(()=>r.value?void 0:u.value)),p=ie(()=>h.value.map(P=>o.value.find(_=>_.value===P.value)||P)),m=ie(()=>p.value.map(P=>P.props.value)),g=fe();function y(P){h.value=[],f.openOnClear&&(a.value=!0),u.value=""}function b(){f.hideNoData&&!o.value.length||f.readonly||(a.value=!0)}function w(P){if(!f.readonly){if(["Enter","ArrowDown"].includes(P.key)&&(a.value=!0),["Escape"].includes(P.key)&&(a.value=!1),["Enter","Escape","Tab"].includes(P.key)&&(r.value=!0),P.key==="ArrowDown"){var _;P.preventDefault(),(_=g.value)==null||_.focus("next")}else if(P.key==="ArrowUp"){var S;P.preventDefault(),(S=g.value)==null||S.focus("prev")}}}function k(P){u.value=P.target.value}function T(){n.value&&(r.value=!0)}function O(P){n.value=!0}function x(P){if(P.relatedTarget==null){var _;(_=i.value)==null||_.focus()}}const C=fe(!1);function E(P){if(f.multiple){const _=m.value.findIndex(S=>S===P.value);if(_===-1)h.value=[...h.value,P],u.value="";else{const S=[...h.value];S.splice(_,1),h.value=S}}else h.value=[P],C.value=!0,t.selection||(u.value=P.title),a.value=!1,r.value=!0,Bi(()=>C.value=!1)}return st(n,P=>{var S;if(P){var _;C.value=!0,u.value=f.multiple||!!t.selection?"":String((S=(_=p.value.at(-1))==null?void 0:_.props.title)!=null?S:""),r.value=!0,Bi(()=>C.value=!1)}else a.value=!1,u.value=""}),st(u,P=>{!n.value||C.value||(P&&(a.value=!0),r.value=!P)}),Xe(()=>{const P=!!(f.chips||t.chip),[_]=m2(f);return $(Yn,Je({ref:i},_,{modelValue:u.value,"onUpdate:modelValue":S=>{S==null&&(h.value=[])},validationValue:h.externalValue,dirty:h.value.length>0,onInput:k,class:["v-autocomplete",{"v-autocomplete--active-menu":a.value,"v-autocomplete--chips":!!f.chips,[`v-autocomplete--${f.multiple?"multiple":"single"}`]:!0,"v-autocomplete--selection-slot":!!t.selection}],appendInnerIcon:f.menuIcon,readonly:f.readonly,"onClick:clear":y,"onClick:control":b,"onClick:input":b,onFocus:()=>n.value=!0,onBlur:()=>n.value=!1,onKeydown:w}),{...t,default:()=>{var S,I,v;return $(Ft,null,[$(D2,Je({modelValue:a.value,"onUpdate:modelValue":N=>a.value=N,activator:"parent",contentClass:"v-autocomplete__content",eager:f.eager,openOnClick:!1,closeOnContentClick:!1,transition:f.transition,onAfterLeave:T},f.menuProps),{default:()=>[$(V2,{ref:g,selected:m.value,selectStrategy:f.multiple?"independent":"single-independent",onMousedown:N=>N.preventDefault(),onFocusin:O,onFocusout:x},{default:()=>{var N;return[!l.value.length&&!f.hideNoData&&((N=(S=t["no-data"])==null?void 0:S.call(t))!=null?N:$(Od,{title:s(f.noDataText)},null)),(I=t["prepend-item"])==null?void 0:I.call(t),l.value.map((q,R)=>{var V;var G;let{item:F,matches:A}=q;return(V=(G=t.item)==null?void 0:G.call(t,{item:F,index:R,props:Je(F.props,{onClick:()=>E(F)})}))!=null?V:$(Od,Je({key:R},F.props,{onClick:()=>E(F)}),{prepend:Q=>{let{isSelected:J}=Q;return f.multiple&&!f.hideSelected?$(ep,{modelValue:J,ripple:!1},null):void 0},title:()=>{var J;var Q;return r.value?F.title:mY(F.title,A.title,(J=(Q=u.value)==null?void 0:Q.length)!=null?J:0)}})}),(v=t["append-item"])==null?void 0:v.call(t)]}})]}),p.value.map((N,q)=>{function R(F){F.stopPropagation(),F.preventDefault(),E(N)}const G={"onClick:close":R,modelValue:!0,"onUpdate:modelValue":void 0};return $("div",{key:N.value,class:"v-autocomplete__selection"},[P?$(xs,{defaults:{VChip:{closable:f.closableChips,size:"small",text:N.title}}},{default:()=>[t.chip?t.chip({item:N,index:q,props:G}):$(S2,G,null)]}):t.selection?t.selection({item:N,index:q}):$("span",{class:"v-autocomplete__selection-text"},[N.title,f.multiple&&q<p.value.length-1&&$("span",{class:"v-autocomplete__selection-comma"},[et(",")])])])})])}})}),Ud({isFocused:n,isPristine:r,menu:a,search:u,filteredItems:l,select:E},i)}});const cu=Qe({name:"VCardActions",setup(f,e){let{slots:t}=e;return Er({VBtn:{variant:"text"}}),Xe(()=>{var s;return $("div",{class:"v-card-actions"},[(s=t.default)==null?void 0:s.call(t)])}),{}}}),uu=Fd("v-card-subtitle"),fu=Fd("v-card-title"),yY=Qe({name:"VCardItem",props:{appendAvatar:String,appendIcon:It,prependAvatar:String,prependIcon:It,subtitle:String,title:String,...Vn()},setup(f,e){let{slots:t}=e;return Xe(()=>{var s,i,n,r,a;const o=!!(f.prependAvatar||f.prependIcon||t.prepend),d=!!(f.appendAvatar||f.appendIcon||t.append),c=!!(f.title||t.title),u=!!(f.subtitle||t.subtitle);return $("div",{class:"v-card-item"},[o&&$(xs,{key:"prepend",defaults:{VAvatar:{density:f.density,icon:f.prependIcon,image:f.prependAvatar},VIcon:{density:f.density,icon:f.prependIcon}}},{default:()=>{var h;return[$("div",{class:"v-card-item__prepend"},[(h=(s=t.prepend)==null?void 0:s.call(t))!=null?h:$(go,null,null)])]}}),$("div",{class:"v-card-item__content"},[c&&$(fu,{key:"title"},{default:()=>{var h;return[(h=(i=t.title)==null?void 0:i.call(t))!=null?h:f.title]}}),u&&$(uu,{key:"subtitle"},{default:()=>{var h;return[(h=(n=t.subtitle)==null?void 0:n.call(t))!=null?h:f.subtitle]}}),(r=t.default)==null?void 0:r.call(t)]),d&&$(xs,{key:"append",defaults:{VAvatar:{density:f.density,icon:f.appendIcon,image:f.appendAvatar},VIcon:{density:f.density,icon:f.appendIcon}}},{default:()=>{var h;return[$("div",{class:"v-card-item__append"},[(h=(a=t.append)==null?void 0:a.call(t))!=null?h:$(go,null,null)])]}})])}),{}}}),bY=Fd("v-card-text"),Lh=Qe({name:"VCard",directives:{Ripple:ju},props:{appendAvatar:String,appendIcon:It,disabled:Boolean,flat:Boolean,hover:Boolean,image:String,link:{type:Boolean,default:void 0},prependAvatar:String,prependIcon:It,ripple:Boolean,subtitle:String,text:String,title:String,..._s(),...Nr(),...Vn(),...ko(),...cr(),...Ub(),...jb(),...zb(),...gn(),...Jl(),...cs(),...qr({variant:"elevated"})},setup(f,e){let{attrs:t,slots:s}=e;const{themeClasses:i}=Rs(f),{borderClasses:n}=Vr(f),{colorClasses:r,colorStyles:a,variantClasses:o}=Hd(f),{densityClasses:d}=dr(f),{dimensionStyles:c}=So(f),{elevationClasses:u}=ur(f),{loaderClasses:h}=$b(f),{locationStyles:l}=Wb(f),{positionClasses:p}=Kb(f),{roundedClasses:m}=yn(f),g=Zl(f,t),y=ie(()=>f.link!==!1&&g.isLink.value),b=ie(()=>!f.disabled&&f.link!==!1&&(f.link||g.isClickable.value));return Xe(()=>{var w,k,T;const O=y.value?"a":f.tag,x=!!(s.title||f.title),C=!!(s.subtitle||f.subtitle),E=x||C,P=!!(s.append||f.appendAvatar||f.appendIcon),_=!!(s.prepend||f.prependAvatar||f.prependIcon),S=!!(s.image||f.image),I=E||_||P,v=!!(s.text||f.text);return Gi($(O,{class:["v-card",{"v-card--disabled":f.disabled,"v-card--flat":f.flat,"v-card--hover":f.hover&&!(f.disabled||f.flat),"v-card--link":b.value},i.value,n.value,r.value,d.value,u.value,h.value,p.value,m.value,o.value],style:[a.value,c.value,l.value],href:g.href.value,onClick:b.value&&g.navigate,tabindex:f.disabled?-1:void 0},{default:()=>[S&&$(xs,{key:"image",defaults:{VImg:{cover:!0,src:f.image}}},{default:()=>{var N;return[$("div",{class:"v-card__image"},[(N=(w=s.image)==null?void 0:w.call(s))!=null?N:$(ma,null,null)])]}}),$(QC,{name:"v-card",active:!!f.loading,color:typeof f.loading=="boolean"?void 0:f.loading},{default:s.loader}),I&&$(yY,{key:"item",prependAvatar:f.prependAvatar,prependIcon:f.prependIcon,title:f.title,subtitle:f.subtitle,appendAvatar:f.appendAvatar,appendIcon:f.appendIcon},{default:s.item,prepend:s.prepend,title:s.title,subtitle:s.subtitle,append:s.append}),v&&$(bY,{key:"text"},{default:()=>{var N;return[(N=(k=s.text)==null?void 0:k.call(s))!=null?N:f.text]}}),(T=s.default)==null?void 0:T.call(s),s.actions&&$(cu,null,{default:s.actions}),Dd(b.value,"v-card")]}),[[ka("ripple"),b.value]])}),{}}});const Rh=zs()({name:"VDialog",props:{fullscreen:Boolean,retainFocus:{type:Boolean,default:!0},scrollable:Boolean,...tp({origin:"center center",scrollStrategy:"block",transition:{component:Qb},zIndex:2400})},emits:{"update:modelValue":f=>!0},setup(f,e){let{slots:t}=e;const s=Vt(f,"modelValue"),{scopeId:i}=nw(),n=fe();function r(a){var o,d;const c=a.relatedTarget,u=a.target;if(c!==u&&(o=n.value)!=null&&o.contentEl&&(d=n.value)!=null&&d.globalTop&&![document,n.value.contentEl].includes(u)&&!n.value.contentEl.contains(u)){const h=[...n.value.contentEl.querySelectorAll('button, [href], input:not([type="hidden"]), select, textarea, [tabindex]:not([tabindex="-1"])')].filter(m=>!m.hasAttribute("disabled")&&!m.matches('[tabindex="-1"]'));if(!h.length)return;const l=h[0],p=h[h.length-1];c===l?p.focus():l.focus()}}return ds&&st(()=>s.value&&f.retainFocus,a=>{a?document.addEventListener("focusin",r):document.removeEventListener("focusin",r)},{immediate:!0}),st(s,async a=>{if(await Bi(),a){var o;(o=n.value.contentEl)==null||o.focus({preventScroll:!0})}else{var d;(d=n.value.activatorEl)==null||d.focus({preventScroll:!0})}}),Xe(()=>{const[a]=iw(f);return $(sp,Je({ref:n,class:["v-dialog",{"v-dialog--fullscreen":f.fullscreen,"v-dialog--scrollable":f.scrollable}]},a,{modelValue:s.value,"onUpdate:modelValue":o=>s.value=o,"aria-role":"dialog","aria-modal":"true",activatorProps:Je({"aria-haspopup":"dialog","aria-expanded":String(s.value)},f.activatorProps)},i),{activator:t.activator,default:function(){for(var o,d=arguments.length,c=new Array(d),u=0;u<d;u++)c[u]=arguments[u];return $(xs,{root:!0},{default:()=>[(o=t.default)==null?void 0:o.call(t,...c)]})}})}),Ud({},n)}});const wY=Qe({name:"VFooter",props:{app:Boolean,color:String,height:{type:[Number,String],default:"auto"},...Nr(),...cr(),...Xb(),...gn(),...cs({tag:"footer"}),..._s()},setup(f,e){let{slots:t}=e;const{themeClasses:s}=Rs(f),{backgroundColorClasses:i,backgroundColorStyles:n}=nr(je(f,"color")),{borderClasses:r}=Vr(f),{elevationClasses:a}=ur(f),{roundedClasses:o}=yn(f),d=fe(32),{resizeRef:c}=Gb(l=>{!l.length||(d.value=l[0].target.clientHeight)}),u=ie(()=>f.height==="auto"?d.value:parseInt(f.height,10)),{layoutItemStyles:h}=Yb({id:f.name,order:ie(()=>parseInt(f.order,10)),position:ie(()=>"bottom"),layoutSize:u,elementSize:ie(()=>f.height==="auto"?void 0:u.value),active:ie(()=>f.app),absolute:je(f,"absolute")});return Xe(()=>$(f.tag,{ref:c,class:["v-footer",s.value,i.value,r.value,a.value,o.value],style:[n,f.app?h.value:void 0]},t)),{}}});const kY=Qe({name:"VContainer",props:{fluid:{type:Boolean,default:!1},...cs()},setup(f,e){let{slots:t}=e;return Xe(()=>$(f.tag,{class:["v-container",{"v-container--fluid":f.fluid}]},t)),{}}}),rw=["sm","md","lg","xl","xxl"],G2=(()=>rw.reduce((f,e)=>(f[e]={type:[Boolean,String,Number],default:!1},f),{}))(),U2=(()=>rw.reduce((f,e)=>(f["offset"+Cr(e)]={type:[String,Number],default:null},f),{}))(),$2=(()=>rw.reduce((f,e)=>(f["order"+Cr(e)]={type:[String,Number],default:null},f),{}))(),iI={col:Object.keys(G2),offset:Object.keys(U2),order:Object.keys($2)};function SY(f,e,t){let s=f;if(!(t==null||t===!1)){if(e){const i=e.replace(f,"");s+=`-${i}`}return f==="col"&&(s="v-"+s),f==="col"&&(t===""||t===!0)||(s+=`-${t}`),s.toLowerCase()}}const vY=["auto","start","end","center","baseline","stretch"],id=Qe({name:"VCol",props:{cols:{type:[Boolean,String,Number],default:!1},...G2,offset:{type:[String,Number],default:null},...U2,order:{type:[String,Number],default:null},...$2,alignSelf:{type:String,default:null,validator:f=>vY.includes(f)},...cs()},setup(f,e){let{slots:t}=e;const s=ie(()=>{const i=[];let n;for(n in iI)iI[n].forEach(a=>{const o=f[a],d=SY(n,a,o);d&&i.push(d)});const r=i.some(a=>a.startsWith("v-col-"));return i.push({"v-col":!r||!f.cols,[`v-col-${f.cols}`]:f.cols,[`offset-${f.offset}`]:f.offset,[`order-${f.order}`]:f.order,[`align-self-${f.alignSelf}`]:f.alignSelf}),i});return()=>{var i;return Sa(f.tag,{class:s.value},(i=t.default)==null?void 0:i.call(t))}}}),TY=["sm","md","lg","xl","xxl"],aw=["start","end","center"],j2=["space-between","space-around","space-evenly"];function ow(f,e){return TY.reduce((t,s)=>(t[f+Cr(s)]=e(),t),{})}const OY=[...aw,"baseline","stretch"],W2=f=>OY.includes(f),z2=ow("align",()=>({type:String,default:null,validator:W2})),IY=[...aw,...j2],K2=f=>IY.includes(f),X2=ow("justify",()=>({type:String,default:null,validator:K2})),xY=[...aw,...j2,"stretch"],Y2=f=>xY.includes(f),Q2=ow("alignContent",()=>({type:String,default:null,validator:Y2})),nI={align:Object.keys(z2),justify:Object.keys(X2),alignContent:Object.keys(Q2)},_Y={align:"align",justify:"justify",alignContent:"align-content"};function CY(f,e,t){let s=_Y[f];if(t!=null){if(e){const i=e.replace(f,"");s+=`-${i}`}return s+=`-${t}`,s.toLowerCase()}}const Fh=Qe({name:"VRow",props:{dense:Boolean,noGutters:Boolean,align:{type:String,default:null,validator:W2},...z2,justify:{type:String,default:null,validator:K2},...X2,alignContent:{type:String,default:null,validator:Y2},...Q2,...cs()},setup(f,e){let{slots:t}=e;const s=ie(()=>{const i=[];let n;for(n in nI)nI[n].forEach(r=>{const a=f[r],o=CY(n,r,a);o&&i.push(o)});return i.push({"v-row--no-gutters":f.noGutters,"v-row--dense":f.dense,[`align-${f.align}`]:f.align,[`justify-${f.justify}`]:f.justify,[`align-content-${f.alignContent}`]:f.alignContent}),i});return()=>{var i;return Sa(f.tag,{class:["v-row",s.value]},(i=t.default)==null?void 0:i.call(t))}}});function Z2(){const f=fe(!1);return ar(()=>{window.requestAnimationFrame(()=>{f.value=!0})}),{ssrBootStyles:ie(()=>f.value?void 0:{transition:"none !important"}),isBooted:Eu(f)}}const MY=Qe({name:"VMain",props:{scrollable:Boolean,...cs({tag:"main"})},setup(f,e){let{slots:t}=e;const{mainStyles:s}=eX(),{ssrBootStyles:i}=Z2();return Xe(()=>{var n,r;return $(f.tag,{class:["v-main",{"v-main--scrollable":f.scrollable}],style:[s.value,i.value]},{default:()=>[f.scrollable?$("div",{class:"v-main__scroller"},[(n=t.default)==null?void 0:n.call(t)]):(r=t.default)==null?void 0:r.call(t)]})}),{}}});const qy=Symbol.for("vuetify:display"),rI={mobileBreakpoint:"lg",thresholds:{xs:0,sm:600,md:960,lg:1280,xl:1920,xxl:2560}},PY=function(){let f=arguments.length>0&&arguments[0]!==void 0?arguments[0]:rI;return xr(rI,f)};function aI(f){return ds&&!f?window.innerWidth:0}function oI(f){return ds&&!f?window.innerHeight:0}function AY(){const f=ds?window.navigator.userAgent:"ssr";function e(p){return Boolean(f.match(p))}const t=e(/android/i),s=e(/iphone|ipad|ipod/i),i=e(/cordova/i),n=e(/electron/i),r=e(/chrome/i),a=e(/edge/i),o=e(/firefox/i),d=e(/opera/i),c=e(/win/i),u=e(/mac/i),h=e(/linux/i),l=e(/ssr/i);return{android:t,ios:s,cordova:i,electron:n,chrome:r,edge:a,firefox:o,opera:d,win:c,mac:u,linux:h,touch:dK,ssr:l}}function BY(f,e){const{thresholds:t,mobileBreakpoint:s}=PY(f),i=fe(oI(e)),n=AY(),r=ti({}),a=fe(aI(e));function o(){i.value=oI(),a.value=aI()}return Mr(()=>{const d=a.value<t.sm,c=a.value<t.md&&!d,u=a.value<t.lg&&!(c||d),h=a.value<t.xl&&!(u||c||d),l=a.value<t.xxl&&!(h||u||c||d),p=a.value>=t.xxl,m=d?"xs":c?"sm":u?"md":h?"lg":l?"xl":"xxl",g=typeof s=="number"?s:t[s],y=n.ssr?n.android||n.ios||n.opera:a.value<g;r.xs=d,r.sm=c,r.md=u,r.lg=h,r.xl=l,r.xxl=p,r.smAndUp=!d,r.mdAndUp=!(d||c),r.lgAndUp=!(d||c||u),r.xlAndUp=!(d||c||u||h),r.smAndDown=!(u||h||l||p),r.mdAndDown=!(h||l||p),r.lgAndDown=!(l||p),r.xlAndDown=!p,r.name=m,r.height=i.value,r.width=a.value,r.mobile=y,r.mobileBreakpoint=s,r.platform=n,r.thresholds=t}),ds&&window.addEventListener("resize",o,{passive:!0}),{...Jy(r),update:o}}function EY(){const f=Zt(qy);if(!f)throw new Error("Could not find Vuetify display injection");return f}function NY(f){let{rootEl:e,isSticky:t,layoutItemStyles:s}=f;const i=fe(!1),n=fe(0),r=ie(()=>{const d=typeof i.value=="boolean"?"top":i.value;return[t.value?{top:"auto",bottom:"auto",height:void 0}:void 0,i.value?{[d]:ze(n.value)}:{top:s.value.top}]});ar(()=>{st(t,d=>{d?window.addEventListener("scroll",o,{passive:!0}):window.removeEventListener("scroll",o)},{immediate:!0})}),mn(()=>{document.removeEventListener("scroll",o)});let a=0;function o(){var p;const d=a>window.scrollY?"up":"down",c=e.value.getBoundingClientRect(),u=parseFloat((p=s.value.top)!=null?p:0),h=window.scrollY-Math.max(0,n.value-u),l=c.height+Math.max(n.value,u)-window.scrollY-window.innerHeight;c.height<window.innerHeight-u?(i.value="top",n.value=u):d==="up"&&i.value==="bottom"||d==="down"&&i.value==="top"?(n.value=window.scrollY+c.top,i.value=!0):d==="down"&&l<=0?(n.value=0,i.value="bottom"):d==="up"&&h<=0&&(n.value=c.top+h,i.value="top"),a=window.scrollY}return{isStuck:i,stickyStyles:r}}const VY=100,qY=20;function dI(f){const e=1.41421356237;return(f<0?-1:1)*Math.sqrt(Math.abs(f))*e}function cI(f){if(f.length<2)return 0;if(f.length===2)return f[1].t===f[0].t?0:(f[1].d-f[0].d)/(f[1].t-f[0].t);let e=0;for(let t=f.length-1;t>0;t--){if(f[t].t===f[t-1].t)continue;const s=dI(e),i=(f[t].d-f[t-1].d)/(f[t].t-f[t-1].t);e+=(i-s)*Math.abs(i),t===f.length-1&&(e*=.5)}return dI(e)*1e3}function LY(){const f={};function e(i){Array.from(i.changedTouches).forEach(n=>{var a;((a=f[n.identifier])!=null?a:f[n.identifier]=new Fz(qY)).push([i.timeStamp,n])})}function t(i){Array.from(i.changedTouches).forEach(n=>{delete f[n.identifier]})}function s(i){var n;const r=(n=f[i])==null?void 0:n.values().reverse();if(!r)throw new Error(`No samples for touch id ${i}`);const a=r[0],o=[],d=[];for(const c of r){if(a[0]-c[0]>VY)break;o.push({t:c[0],d:c[1].clientX}),d.push({t:c[0],d:c[1].clientY})}return{x:cI(o),y:cI(d),get direction(){const{x:c,y:u}=this,[h,l]=[Math.abs(c),Math.abs(u)];return h>l&&c>=0?"right":h>l&&c<=0?"left":l>h&&u>=0?"down":l>h&&u<=0?"up":RY()}}}return{addMovement:e,endTouch:t,getVelocity:s}}function RY(){throw new Error}function FY(f){let{isActive:e,isTemporary:t,width:s,touchless:i,position:n}=f;ar(()=>{window.addEventListener("touchstart",y,{passive:!0}),window.addEventListener("touchmove",b,{passive:!1}),window.addEventListener("touchend",w,{passive:!0})}),mn(()=>{window.removeEventListener("touchstart",y),window.removeEventListener("touchmove",b),window.removeEventListener("touchend",w)});const r=ie(()=>n.value!=="bottom"),{addMovement:a,endTouch:o,getVelocity:d}=LY();let c=!1;const u=fe(!1),h=fe(0),l=fe(0);let p;function m(T,O){return(n.value==="left"?T:n.value==="right"?document.documentElement.clientWidth-T:n.value==="bottom"?document.documentElement.clientHeight-T:nd())-(O?s.value:0)}function g(T){let O=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0;const x=n.value==="left"?(T-l.value)/s.value:n.value==="right"?(document.documentElement.clientWidth-T-l.value)/s.value:n.value==="bottom"?(document.documentElement.clientHeight-T-l.value)/s.value:nd();return O?Math.max(0,Math.min(1,x)):x}function y(T){if(i.value)return;const O=T.changedTouches[0].clientX,x=T.changedTouches[0].clientY,C=25,E=n.value==="left"?O<C:n.value==="right"?O>document.documentElement.clientWidth-C:n.value==="bottom"?x>document.documentElement.clientHeight-C:nd(),P=e.value&&(n.value==="left"?O<s.value:n.value==="right"?O>document.documentElement.clientWidth-s.value:n.value==="bottom"?x>document.documentElement.clientHeight-s.value:nd());(E||P||e.value&&t.value)&&(c=!0,p=[O,x],l.value=m(r.value?O:x,e.value),h.value=g(r.value?O:x),o(T),a(T))}function b(T){const O=T.changedTouches[0].clientX,x=T.changedTouches[0].clientY;if(c){if(!T.cancelable){c=!1;return}const E=Math.abs(O-p[0]),P=Math.abs(x-p[1]);(r.value?E>P&&E>3:P>E&&P>3)?(u.value=!0,c=!1):(r.value?P:E)>3&&(c=!1)}if(!u.value)return;T.preventDefault(),a(T);const C=g(r.value?O:x,!1);h.value=Math.max(0,Math.min(1,C)),C>1?l.value=m(r.value?O:x,!0):C<0&&(l.value=m(r.value?O:x,!1))}function w(T){if(c=!1,!u.value)return;a(T),u.value=!1;const O=d(T.changedTouches[0].identifier),x=Math.abs(O.x),C=Math.abs(O.y);(r.value?x>C&&x>400:C>x&&C>3)?e.value=O.direction===({left:"right",right:"left",bottom:"up"}[n.value]||nd()):e.value=h.value>.5}const k=ie(()=>u.value?{transform:n.value==="left"?`translateX(calc(-100% + ${h.value*s.value}px))`:n.value==="right"?`translateX(calc(100% - ${h.value*s.value}px))`:n.value==="bottom"?`translateY(calc(100% - ${h.value*s.value}px))`:nd(),transition:"none"}:void 0);return{isDragging:u,dragProgress:h,dragStyles:k}}function nd(){throw new Error}const DY=["start","end","left","right","bottom"],HY=Qe({name:"VNavigationDrawer",props:{color:String,disableResizeWatcher:Boolean,disableRouteWatcher:Boolean,expandOnHover:Boolean,floating:Boolean,modelValue:{type:Boolean,default:null},permanent:Boolean,rail:Boolean,railWidth:{type:[Number,String],default:56},scrim:{type:[String,Boolean],default:!0},image:String,temporary:Boolean,touchless:Boolean,width:{type:[Number,String],default:256},location:{type:String,default:"start",validator:f=>DY.includes(f)},sticky:Boolean,...Nr(),...cr(),...Xb(),...gn(),...cs({tag:"nav"}),..._s()},emits:{"update:modelValue":f=>!0},setup(f,e){let{attrs:t,slots:s}=e;const{isRtl:i}=Wu(),{themeClasses:n}=Rs(f),{borderClasses:r}=Vr(f),{backgroundColorClasses:a,backgroundColorStyles:o}=nr(je(f,"color")),{elevationClasses:d}=ur(f),{mobile:c}=EY(),{roundedClasses:u}=yn(f),h=ZC(),l=Vt(f,"modelValue",null,q=>!!q),{ssrBootStyles:p}=Z2(),m=fe(),g=fe(!1),y=ie(()=>f.rail&&f.expandOnHover&&g.value?Number(f.width):Number(f.rail?f.railWidth:f.width)),b=ie(()=>Oy(f.location,i.value)),w=ie(()=>!f.permanent&&(c.value||f.temporary)),k=ie(()=>f.sticky&&!w.value&&b.value!=="bottom");f.disableResizeWatcher||st(w,q=>!f.permanent&&(l.value=!q)),!f.disableRouteWatcher&&h&&st(h.currentRoute,()=>w.value&&(l.value=!1)),st(()=>f.permanent,q=>{q&&(l.value=!0)}),Il(()=>{f.modelValue!=null||w.value||(l.value=f.permanent||!c.value)});const{isDragging:T,dragProgress:O,dragStyles:x}=FY({isActive:l,isTemporary:w,width:y,touchless:je(f,"touchless"),position:b}),C=ie(()=>{const q=w.value?0:f.rail&&f.expandOnHover?Number(f.railWidth):y.value;return T.value?q*O.value:q}),{layoutItemStyles:E,layoutRect:P,layoutItemScrimStyles:_}=Yb({id:f.name,order:ie(()=>parseInt(f.order,10)),position:b,layoutSize:C,elementSize:y,active:ie(()=>l.value||T.value),disableTransitions:ie(()=>T.value),absolute:ie(()=>f.absolute||k.value&&typeof S.value!="string")}),{isStuck:S,stickyStyles:I}=NY({rootEl:m,isSticky:k,layoutItemStyles:E}),v=nr(ie(()=>typeof f.scrim=="string"?f.scrim:null)),N=ie(()=>({...T.value?{opacity:O.value*.2,transition:"none"}:void 0,...P.value?{left:ze(P.value.left),right:ze(P.value.right),top:ze(P.value.top),bottom:ze(P.value.bottom)}:void 0,..._.value}));return Er({VList:{bgColor:"transparent"}}),Xe(()=>{var q,R,G,F;const A=s.image||f.image;return $(Ft,null,[$(f.tag,Je({ref:m,onMouseenter:()=>g.value=!0,onMouseleave:()=>g.value=!1,class:["v-navigation-drawer",`v-navigation-drawer--${b.value}`,{"v-navigation-drawer--expand-on-hover":f.expandOnHover,"v-navigation-drawer--floating":f.floating,"v-navigation-drawer--is-hovering":g.value,"v-navigation-drawer--rail":f.rail,"v-navigation-drawer--temporary":w.value,"v-navigation-drawer--active":l.value,"v-navigation-drawer--sticky":k.value},n.value,a.value,r.value,d.value,u.value],style:[o.value,E.value,x.value,p.value,I.value]},t),{default:()=>[A&&$("div",{key:"image",class:"v-navigation-drawer__img"},[s.image?(q=s.image)==null?void 0:q.call(s,{image:f.image}):$("img",{src:f.image,alt:""},null)]),s.prepend&&$("div",{class:"v-navigation-drawer__prepend"},[(R=s.prepend)==null?void 0:R.call(s)]),$("div",{class:"v-navigation-drawer__content"},[(G=s.default)==null?void 0:G.call(s)]),s.append&&$("div",{class:"v-navigation-drawer__append"},[(F=s.append)==null?void 0:F.call(s)])]}),$(sr,{name:"fade-transition"},{default:()=>[w.value&&(T.value||l.value)&&!!f.scrim&&$("div",{class:["v-navigation-drawer__scrim",v.backgroundColorClasses.value],style:[N.value,v.backgroundColorStyles.value],onClick:()=>l.value=!1},null)]})])}),{isStuck:S}}});const nu=zs()({name:"VTooltip",props:{id:String,text:String,...Kl(tp({closeOnBack:!1,location:"end",locationStrategy:"connected",minWidth:0,offset:10,openOnClick:!1,openOnHover:!0,origin:"auto",scrim:!1,scrollStrategy:"reposition",transition:!1}),["absolute","persistent","eager"])},emits:{"update:modelValue":f=>!0},setup(f,e){let{slots:t}=e;const s=Vt(f,"modelValue"),{scopeId:i}=nw(),n=$i(),r=ie(()=>f.id||`v-tooltip-${n}`),a=fe(),o=ie(()=>f.location.split(" ").length>1?f.location:f.location+" center"),d=ie(()=>f.origin==="auto"||f.origin==="overlap"||f.origin.split(" ").length>1||f.location.split(" ").length>1?f.origin:f.origin+" center"),c=ie(()=>f.transition?f.transition:s.value?"scale-transition":"fade-transition");return Xe(()=>{const[u]=iw(f);return $(sp,Je({ref:a,class:["v-tooltip"],id:r.value},u,{modelValue:s.value,"onUpdate:modelValue":h=>s.value=h,transition:c.value,absolute:!0,location:o.value,origin:d.value,persistent:!0,role:"tooltip",eager:!0,activatorProps:Je({"aria-describedby":r.value},f.activatorProps)},i),{activator:t.activator,default:function(){var g;for(var h,l=arguments.length,p=new Array(l),m=0;m<l;m++)p[m]=arguments[m];return(g=(h=t.default)==null?void 0:h.call(t,...p))!=null?g:f.text}})}),Ud({},a)}}),GY={class:"d-flex align-top justify-center"},UY={class:"d-flex align-top justify-center"},$Y={class:"d-flex align-top justify-center"},jY={class:"d-flex align-top justify-center"},WY={key:0,class:"text-h3 font-weight-bold"},zY={key:1,class:"text-h4 font-weight-bold",style:{color:"rgb(169, 94, 171)"}},KY={key:2,class:"text-h5 font-weight-bold",style:{color:"rgb(148 143 149)"}},XY={key:4,class:"py-5"},YY={key:0},QY={key:0},ZY=mi("h3",null,"Exchange Keys",-1),JY={style:{"margin-bottom":"1em"}},eQ={key:0},tQ={class:"d-flex align-top justify-center",style:{"margin-top":".5em"}},sQ={key:1},iQ={style:{"margin-top":"1em"}},nQ=mi("h3",null,"Discord Settings",-1),rQ={style:{"margin-bottom":"2em"}},aQ=mi("h3",null,"Twitch Settings",-1),oQ={key:0},dQ=nb({__name:"App",setup(f){const e=new URL(""+new URL("TwitchGlitchBlackOps.a3857686.png",import.meta.url).href,self.location).href,t=new URL(""+new URL("discord-mark-white.3e862997.png",import.meta.url).href,self.location).href,s=fe({show:!1,message:"",type:"success",timeout:null}),i=fe(!1),n=fe(""),r=fe(""),a=fe([]),o=fe(""),d=fe([]),c=LI(()=>Buffer.from(JSON.stringify(d.value),"utf-8").toString("base64")),u=fe({}),h=fe(null),l=fe(!0),p=fe(!0),m=fe(!1),g=fe(!1),y=fe(!1),b=fe(!1),w=fe(!0),k=fe(""),T=fe(""),O=fe(!1),x=fe(!1),C=fe(!1),E=fe(!1),P=fe(5),_=fe(!1),S=fe(new Array),I=fe(null),v=ti({twitchExtensionEnabled:i,alert:s,copiedRefLink:r,refLink:n,referrals:a,exchangeKeys:d,exchangeKeyOpen:S,twitchAccessToken:u,twitchUserInfo:h,editExchangeKeys:l,editDiscordInfo:p,editTwitchInfo:w,discordChannelId:k,discordMessageId:T,enabled:O,discordEnabled:x,twitchEnabled:C,twitchTimeoutEnabled:E,twitchTimeoutLength:P,userInfo:I,deleteDialog:m,logoutDialog:g,startDialog:y,stopDialog:b,connectedToTwitchChannel:_});window.Twitch.ext.onAuthorized(Y=>{v.twitchAccessToken={access_token:Y.helixToken,client_id:Y.clientId,channel_id:Y.channelId,token:Y.token,user_id:Y.userId.substring(1)},v.twitchExtensionEnabled=!0}),st(()=>[v.twitchExtensionEnabled,v.twitchAccessToken],(Y,z)=>{Y[0]&&Y[1]!==null&&Y[1]!==void 0&&(v.editDiscordInfo=!1,v.editExchangeKeys=!1,v.editTwitchInfo=!1,R().then(()=>{G().then(()=>{A(),U()}).catch(X=>{console.error(X)})}).catch(X=>{console.error(X)}))});const N=()=>{v.twitchExtensionEnabled?(v.editDiscordInfo=!1,v.editExchangeKeys=!1,v.editTwitchInfo=!1,R().then(()=>{G().then(()=>{A(),U()}).catch(Y=>{console.error(Y)})}).catch(Y=>{console.error(Y)})):window.location.host!=="localhost:3000"&&window.location.host!=="127.0.0.1:3000"?window.location.href=`https://bot.cryptopositionsbot.com/login?redirect_uri=https://www.cryptopositionsbot.com/&state=${v.refLink}`:window.location.href=`https://bot.cryptopositionsbot.com/login?redirect_uri=https://localhost:3000/&state=${v.refLink}`},q=()=>{navigator.clipboard.writeText(`https://www.cryptopositionsbot.com/?ref=${v.userInfo.TWITCH_CHANNEL.toLowerCase().substring(1)}`),H("Copied ref link to clipboard","success")};ar(()=>{if(document.location.hash&&!v.twitchExtensionEnabled){var Y={};decodeURIComponent(window.location.hash.substring(1)).split("&").forEach(X=>{let[ne,te]=X.split("=");Y[ne]=te}),v.twitchAccessToken=Y,document.location.hash="",R().then(()=>{G().then(()=>{A(),U()}).catch(X=>{console.error(X)})}).catch(X=>{console.error(X)})}let z=new URL(window.location.href).searchParams;z.has("ref")&&(v.refLink=z.get("ref"))});const R=()=>new Promise((Y,z)=>{Ct.get(`https://bot.cryptopositionsbot.com/twitchUserInfo?access_token=${v.twitchAccessToken.access_token}&is_helix=${v.twitchExtensionEnabled}&client_id=${v.twitchAccessToken.client_id}&user_id=${v.twitchAccessToken.user_id}`).then(X=>{v.twitchUserInfo=X.data,Y()}).catch(X=>{console.error(X),z(X)})}),G=()=>new Promise((Y,z)=>{Ct.get(`https://bot.cryptopositionsbot.com/userInfo?access_token=${v.twitchAccessToken.access_token}&is_helix=${v.twitchExtensionEnabled}&client_id=${v.twitchAccessToken.client_id}&user_id=${v.twitchAccessToken.user_id}`).then(X=>{o.value=Buffer.from(JSON.stringify(X.data.EXCHANGE_KEYS),"utf-8").toString("base64"),v.userInfo=X.data,v.userInfo.EXCHANGE_KEYS.length>0&&v.exchangeKeys.push(...X.data.EXCHANGE_KEYS),v.discordChannelId=X.data.DISCORD_CHANNEL,v.discordMessageId=X.data.DISCORD_MESSAGE,v.discordEnabled=X.data.DISCORD_ENABLED,v.twitchEnabled=X.data.TWITCH_ENABLED,v.twitchTimeoutEnabled=X.data.TWITCH_TIMEOUT,v.twitchTimeoutLength=X.data.TWITCH_TIMEOUT_EXPIRE,v.enabled=X.data.ENABLED,v.refLink=X.data.REF_LINK||"",(v.refLink===null||v.refLink===void 0||v.refLink==="")&&v.twitchAccessToken.state!==""&&v.twitchAccessToken.state!==void 0&&v.twitchAccessToken.state!==null?v.twitchAccessToken.state.toLowerCase()!==v.userInfo.TWITCH_CHANNEL.toLowerCase().substring(1)?F(v.twitchAccessToken.state).then(()=>{Y()}).catch(ne=>{console.error(ne),z(ne)}):H("Cannot refer yourself "+v.userInfo.TWITCH_CHANNEL,"error"):Y()}).catch(X=>{console.error(X),z(X)})}),F=Y=>new Promise((z,X)=>{W("Are you sure you want to set your referral to: "+Y)?Ct.post("https://bot.cryptopositionsbot.com/trySetupRefLink",{access_token:v.twitchAccessToken.access_token,refLink:Y}).then(ne=>{ne.data===!0?(v.refLink=Y,v.userInfo.REF_LINK=v.refLink,H("Ref Link connected to "+v.refLink,"success"),z()):(H(ne.data,"error"),v.refLink="",z())}).catch(ne=>{console.error(ne),X(ne)}):z()}),A=()=>new Promise((Y,z)=>{Ct.get(`https://bot.cryptopositionsbot.com/referrals?access_token=${v.twitchAccessToken.access_token}&is_helix=${v.twitchExtensionEnabled}&client_id=${v.twitchAccessToken.client_id}&user_id=${v.twitchAccessToken.user_id}`).then(X=>{v.referrals=X.data,Y()}).catch(X=>{H("Failed to retrieve referrals","error"),console.error(X),z(X)})}),V=()=>{v.userInfo.EXCHANGE_KEYS.length>0&&(v.exchangeKeys=[...v.userInfo.EXCHANGE_KEYS])},Q=()=>{v.discordChannelId=v.userInfo.DISCORD_CHANNEL,v.discordMessageId=v.userInfo.DISCORD_MESSAGE,v.discordEnabled=v.userInfo.DISCORD_ENABLED},J=()=>{v.twitchEnabled=v.userInfo.TWITCH_ENABLED,v.twitchTimeoutEnabled=v.userInfo.TWITCH_TIMEOUT,v.twitchTimeoutLength=v.userInfo.TWITCH_TIMEOUT_EXPIRE},se=()=>new Promise((Y,z)=>{let X={access_token:v.twitchAccessToken.access_token,is_helix:v.twitchExtensionEnabled,client_id:v.twitchAccessToken.client_id,user_id:v.twitchAccessToken.user_id,exchangeKeys:v.exchangeKeys};Ct.post("https://bot.cryptopositionsbot.com/userExchangeKeys",X).then(ne=>{o.value=Buffer.from(JSON.stringify(v.exchangeKeys),"utf-8").toString("base64"),v.userInfo.EXCHANGE_KEYS=v.exchangeKeys.map(te=>({EXCHANGE_ID:te.EXCHANGE_ID,DESCRIPTION:te.DESCRIPTION,API_KEY:new Array(te.API_KEY.length+1).join("*"),API_SECRET:new Array(te.API_SECRET.length+1).join("*"),KEY_ID:te.KEY_ID})),H("Updated exchange keys","success"),Y()}).catch(ne=>{H("Failed to update exchange keys","error"),console.error(ne),z(ne)})}),we=()=>new Promise((Y,z)=>{let X={access_token:v.twitchAccessToken.access_token,is_helix:v.twitchExtensionEnabled,client_id:v.twitchAccessToken.client_id,user_id:v.twitchAccessToken.user_id,discordInfo:{DISCORD_CHANNEL:v.discordChannelId,DISCORD_MESSAGE:v.discordMessageId,DISCORD_ENABLED:v.discordEnabled}};Ct.post("https://bot.cryptopositionsbot.com/userDiscordInfo",X).then(ne=>{ne.data===!0?(v.userInfo.DISCORD_CHANNEL=v.discordChannelId,v.userInfo.DISCORD_MESSAGE=v.discordMessageId,v.userInfo.DISCORD_ENABLED=v.discordEnabled,H("Updated user discord info","success")):H("Failed to update user discord info","error"),Y()}).catch(ne=>{H("Failed to update user discord info","error"),console.error(ne),z(ne)})}),le=()=>new Promise((Y,z)=>{let X={access_token:v.twitchAccessToken.access_token,is_helix:v.twitchExtensionEnabled,client_id:v.twitchAccessToken.client_id,user_id:v.twitchAccessToken.user_id,twitchInfo:{TWITCH_ENABLED:v.twitchEnabled,TWITCH_TIMEOUT:v.twitchTimeoutEnabled,TWITCH_TIMEOUT_EXPIRE:v.twitchTimeoutLength}};Ct.post("https://bot.cryptopositionsbot.com/userTwitchInfo",X).then(ne=>{ne.data===!0?(H("Updated user twitch info","success"),v.userInfo.TWITCH_ENABLED=v.twitchEnabled,v.userInfo.TWITCH_TIMEOUT=v.twitchTimeoutEnabled,v.userInfo.TWITCH_TIMEOUT_EXPIRE=v.twitchTimeoutLength,U().then(()=>{Y()}).catch(te=>{console.error(te),z(te)})):H("Failed to update user twitch info","error")}).catch(ne=>{H("Failed to update user twitch info","error"),console.error(ne),z(ne)})}),Oe=()=>new Promise((Y,z)=>{let X={access_token:v.twitchAccessToken.access_token,is_helix:v.twitchExtensionEnabled,client_id:v.twitchAccessToken.client_id,user_id:v.twitchAccessToken.user_id,enabled:v.enabled};Ct.post("https://bot.cryptopositionsbot.com/userEnabled",X).then(ne=>{ne.data===!0?(v.userInfo.ENABLED=v.enabled,H("Updated user enabled state","success")):H("Failed to update user enabled state","error"),Y()}).catch(ne=>{H("Failed to update user enabled state","error"),console.error(ne),z(ne)})}),Ce=()=>{v.userInfo=null,v.twitchUserInfo=null,H("Logged out","success")},Le=()=>new Promise((Y,z)=>{let X={access_token:v.twitchAccessToken.access_token,is_helix:v.twitchExtensionEnabled,client_id:v.twitchAccessToken.client_id,user_id:v.twitchAccessToken.user_id};Ct.post("https://bot.cryptopositionsbot.com/removeUser",X).then(ne=>{v.deleteDialog=!1,Ce(),Y()}).catch(ne=>{console.error(ne),z(ne)})}),Fe=()=>new Promise((Y,z)=>{let X={access_token:v.twitchAccessToken.access_token,is_helix:v.twitchExtensionEnabled,client_id:v.twitchAccessToken.client_id,user_id:v.twitchAccessToken.user_id};Ct.post("https://bot.cryptopositionsbot.com/start",X).then(ne=>{ne.data===!0?(v.userInfo.IS_RUNNING=!0,v.startDialog=!1,H("Started the bot!","success")):H("Failed to start!","error"),Y()}).catch(ne=>{H("Failed to start!","error"),console.error(ne),z(ne)})}),At=()=>new Promise((Y,z)=>{let X={access_token:v.twitchAccessToken.access_token,is_helix:v.twitchExtensionEnabled,client_id:v.twitchAccessToken.client_id,user_id:v.twitchAccessToken.user_id};Ct.post("https://bot.cryptopositionsbot.com/stop",X).then(ne=>{ne.data===!0?(v.userInfo.IS_RUNNING=!1,v.stopDialog=!1,H("Stopped the bot!","success")):H("Failed to stop!","error"),Y()}).catch(ne=>{H("Failed to stop!","error"),console.error(ne),z(ne)})}),D=()=>new Promise((Y,z)=>{U().then(X=>{if(X){H("Already connected to Twitch Channel","error");return}let ne={access_token:v.twitchAccessToken.access_token,is_helix:v.twitchExtensionEnabled,client_id:v.twitchAccessToken.client_id,user_id:v.twitchAccessToken.user_id};Ct.post("https://bot.cryptopositionsbot.com/connectToTwitchChannel",ne).then(te=>{te.data===!0?(v.connectedToTwitchChannel=!0,H("Bot connected to twich channel chat","success")):H(te.data,"error"),Y(te.data)}).catch(te=>{console.error(te),z(te)})})}),j=()=>new Promise((Y,z)=>{U().then(X=>{if(X){let ne={access_token:v.twitchAccessToken.access_token,is_helix:v.twitchExtensionEnabled,client_id:v.twitchAccessToken.client_id,user_id:v.twitchAccessToken.user_id};Ct.post("https://bot.cryptopositionsbot.com/disconnectFromTwitchChannel",ne).then(te=>{te.data===!0?(v.connectedToTwitchChannel=!1,H("Bot disconnected from twich channel chat","success")):H(te.data,"error")}).catch(te=>{console.error(te),z(te)})}else H("Not connected to Twitch Channel","error")})}),U=()=>new Promise((Y,z)=>{Ct.get(`https://bot.cryptopositionsbot.com/isConnectedToTwitchChannel?access_token=${v.twitchAccessToken.access_token}&is_helix=${v.twitchExtensionEnabled}&client_id=${v.twitchAccessToken.client_id}&user_id=${v.twitchAccessToken.user_id}`).then(X=>{v.connectedToTwitchChannel=X.data,Y(X.data)}).catch(X=>{console.error(X),z(X)})}),H=(Y,z)=>{v.alert.message=Y,v.alert.type=z,v.alert.show=!0,v.alert.timeout&&clearTimeout(v.alert.timeout),v.alert.timeout=setTimeout(()=>{v.alert.show=!1},2500)},W=Y=>window.confirm(Y);return(Y,z)=>(Ge(),lt(iX,{id:"inspire"},{default:Be(()=>[$(ZK,{closable:"",variant:"tonal",modelValue:v.alert.show,"onUpdate:modelValue":z[0]||(z[0]=X=>v.alert.show=X),type:v.alert.type,style:Pi(`${v.twitchExtensionEnabled?"bottom: 0px; left: -1em; right: 0px; width: 100%;":"left: 5%; top: 0px; width: 90%;"} z-index: 5000; position: absolute; margin: 1em; `),text:v.alert.message},null,8,["modelValue","type","style","text"]),$(Rh,{modelValue:g.value,"onUpdate:modelValue":z[3]||(z[3]=X=>g.value=X)},{default:Be(()=>[mi("div",GY,[$(Lh,{style:{width:"400px"}},{default:Be(()=>[$(fu,null,{default:Be(()=>[et("Logout")]),_:1}),$(uu,null,{default:Be(()=>[et("Are you sure you want to logout?")]),_:1}),$(cu,null,{default:Be(()=>[$(ot,{variant:"outlined",onClick:z[1]||(z[1]=X=>Ce()),color:"error"},{default:Be(()=>[et("Logout")]),_:1}),$(ot,{variant:"outlined",onClick:z[2]||(z[2]=X=>{g.value=!1})},{default:Be(()=>[et("Cancel")]),_:1})]),_:1})]),_:1})])]),_:1},8,["modelValue"]),$(Rh,{modelValue:m.value,"onUpdate:modelValue":z[6]||(z[6]=X=>m.value=X)},{default:Be(()=>[mi("div",UY,[$(Lh,{style:{width:"400px"}},{default:Be(()=>[$(fu,null,{default:Be(()=>[et("Deletion")]),_:1}),$(uu,null,{default:Be(()=>[et("Are you sure you want to delete your user?")]),_:1}),$(cu,null,{default:Be(()=>[$(ot,{variant:"outlined",onClick:z[4]||(z[4]=X=>Le()),color:"error"},{default:Be(()=>[et("Delete")]),_:1}),$(ot,{variant:"outlined",onClick:z[5]||(z[5]=X=>{m.value=!1})},{default:Be(()=>[et("Cancel")]),_:1})]),_:1})]),_:1})])]),_:1},8,["modelValue"]),$(Rh,{modelValue:y.value,"onUpdate:modelValue":z[9]||(z[9]=X=>y.value=X)},{default:Be(()=>[mi("div",$Y,[$(Lh,{style:{width:"400px"}},{default:Be(()=>[$(fu,null,{default:Be(()=>[et("Start Running?")]),_:1}),$(uu,null,{default:Be(()=>[et("Allow the bot to pull data from Exchanges?")]),_:1}),$(cu,null,{default:Be(()=>[$(ot,{variant:"outlined",onClick:z[7]||(z[7]=X=>Fe()),color:"success"},{default:Be(()=>[et("Start")]),_:1}),$(ot,{variant:"outlined",onClick:z[8]||(z[8]=X=>{y.value=!1})},{default:Be(()=>[et("Cancel")]),_:1})]),_:1})]),_:1})])]),_:1},8,["modelValue"]),$(Rh,{modelValue:b.value,"onUpdate:modelValue":z[12]||(z[12]=X=>b.value=X)},{default:Be(()=>[mi("div",jY,[$(Lh,{style:{width:"400px"}},{default:Be(()=>[$(fu,null,{default:Be(()=>[et("Stop Running?")]),_:1}),$(uu,null,{default:Be(()=>[et("Are you sure you want to stop the bot?")]),_:1}),$(cu,null,{default:Be(()=>[$(ot,{variant:"outlined",onClick:z[10]||(z[10]=X=>At()),color:"error"},{default:Be(()=>[et("Stop")]),_:1}),$(ot,{variant:"outlined",onClick:z[11]||(z[11]=X=>{b.value=!1})},{default:Be(()=>[et("Cancel")]),_:1})]),_:1})]),_:1})])]),_:1},8,["modelValue"]),v.twitchExtensionEnabled&&v.twitchUserInfo!==null&&v.userInfo.ENABLED!==void 0&&v.userInfo.ENABLED?(Ge(),lt(uX,{key:0,color:"teal-darken-4",style:Pi(`${v.twitchExtensionEnabled&&v.twitchAccessToken.channel_id!==void 0&&v.twitchAccessToken.channel_id===v.twitchUserInfo.id?"width: 150px;":"width: 50px;"} border-radius: 0 0 30px 0;`),elevation:0},{image:Be(()=>[$(ma,{gradient:"to top right, rgba(25,25,25,.8), rgba(50,50,50,.8)"})]),default:Be(()=>[$(nu,{text:"Twitch Info",location:"bottom"},{activator:Be(({props:X})=>[v.twitchUserInfo!==null?(Ge(),lt(ot,Je({key:0,style:{"margin-right":"1em"}},X,{key:"chat",icon:"",active:v.editTwitchInfo,flat:"",size:"32px",color:v.editTwitchInfo?"success":"warning",onClick:z[13]||(z[13]=ne=>{v.editTwitchInfo=!v.editTwitchInfo,v.editDiscordInfo=!1,v.editExchangeKeys=!1})}),{default:Be(()=>[$(ma,{style:{width:"32px",height:"32px"},src:ei(e)},null,8,["src"])]),_:2},1040,["active","color"])):tt("",!0)]),_:1}),$(nu,{text:"Discord Info",location:"bottom"},{activator:Be(({props:X})=>[v.twitchUserInfo!==null?(Ge(),lt(ot,Je({key:0,style:{"margin-right":"1em"}},X,{key:"forum",icon:"",active:v.editDiscordInfo,flat:"",size:"32px",color:v.editDiscordInfo?"success":"warning",onClick:z[14]||(z[14]=ne=>{v.editDiscordInfo=!v.editDiscordInfo,v.editExchangeKeys=!1,v.editTwitchInfo=!1})}),{default:Be(()=>[$(ma,{style:{width:"32px",height:"32px"},src:ei(t)},null,8,["src"])]),_:2},1040,["active","color"])):tt("",!0)]),_:1}),$(nu,{text:"Exchange Keys",location:"bottom"},{activator:Be(({props:X})=>[v.twitchUserInfo!==null?(Ge(),lt(ot,Je({key:0},X,{key:"key",icon:"",active:v.editExchangeKeys,flat:"",size:"32px",color:v.editExchangeKeys?"success":"warning",onClick:z[15]||(z[15]=ne=>{v.editExchangeKeys=!v.editExchangeKeys,v.editDiscordInfo=!1,v.editTwitchInfo=!1})}),{default:Be(()=>[$(gi,null,{default:Be(()=>[et("mdi-key")]),_:1})]),_:2},1040,["active","color"])):tt("",!0)]),_:1}),$(nu,{text:"Exchange Keys",location:"bottom"},{activator:Be(({props:X})=>[$(ot,Je(X,{size:"x-small",variant:"plain",icon:"mdi-share",color:"success",onClick:z[16]||(z[16]=ne=>q())}),null,16)]),_:1})]),_:1},8,["style"])):tt("",!0),v.twitchUserInfo!==null&&!v.twitchExtensionEnabled?(Ge(),lt(HY,{key:1,app:"","model-value":"",class:"pt-4",rail:"",permanent:""},{default:Be(()=>[$(go,{style:{"margin-top":"1em",cursor:"pointer"},color:"grey-darken-1",image:v.twitchUserInfo!==null?v.twitchUserInfo.profile_image_url:"",size:36,onClick:z[17]||(z[17]=()=>{v.twitchUserInfo!==null&&(v.logoutDialog=!0)}),class:"d-block text-center mx-auto mb-9"},null,8,["image"]),v.twitchUserInfo!==null?(Ge(),lt(dd,{key:0})):tt("",!0),v.twitchUserInfo!==null?(Ge(),lt(dd,{key:1})):tt("",!0),v.twitchUserInfo!==null?(Ge(),lt(ot,{key:2,variant:"plain",style:{"margin-top":"2em"},active:v.editTwitchInfo,flat:"",class:"d-block text-center mx-auto mb-9",size:"32px",icon:"mdi-chat",onClick:z[18]||(z[18]=X=>{v.editTwitchInfo=!v.editTwitchInfo,v.editDiscordInfo=!1,v.editExchangeKeys=!1})},{default:Be(()=>[$(ma,{style:{width:"32px",height:"32px"},src:ei(e)},null,8,["src"])]),_:1},8,["active"])):tt("",!0),v.twitchUserInfo!==null?(Ge(),lt(dd,{key:3})):tt("",!0),v.twitchUserInfo!==null?(Ge(),lt(ot,{key:4,variant:"plain",style:{"margin-top":"2em"},active:v.editDiscordInfo,flat:"",class:"d-block text-center mx-auto mb-9",size:"32px",icon:"",onClick:z[19]||(z[19]=X=>{v.editDiscordInfo=!v.editDiscordInfo,v.editTwitchInfo=!1,v.editExchangeKeys=!1})},{default:Be(()=>[$(ma,{style:"width: 32px; height: 32px;",src:ei(t)},null,8,["src"])]),_:1},8,["active"])):tt("",!0),v.twitchUserInfo!==null?(Ge(),lt(dd,{key:5})):tt("",!0),v.twitchUserInfo!==null?(Ge(),lt(ot,{key:6,variant:"plain",style:{"margin-top":"2em"},active:v.editExchangeKeys,flat:"",class:"d-block text-center mx-auto mb-9",size:"32px",icon:"mdi-key",onClick:z[20]||(z[20]=X=>{v.editExchangeKeys=!v.editExchangeKeys,v.editTwitchInfo=!1,v.editDiscordInfo=!1})},null,8,["active"])):tt("",!0)]),_:1})):tt("",!0),$(MY,null,{default:Be(()=>[$(kY,{class:"fill-height"},{default:Be(()=>[$(r2,{class:"d-flex align-center text-center justify-center fill-height"},{default:Be(()=>[v.twitchUserInfo===null?(Ge(),bi("h1",WY,"CryptoPositionsBot")):tt("",!0),v.twitchUserInfo!==null&&!v.twitchExtensionEnabled?(Ge(),bi("h2",zY,[et(" Logged In As: "+To(v.twitchUserInfo.display_name)+" ",1),$(ot,{size:"x-small",variant:"plain",icon:"mdi-share",color:"success",onClick:z[21]||(z[21]=X=>q())})])):tt("",!0),v.userInfo!==null&&v.userInfo.REF_LINK!==null&&v.userInfo.REF_LINK!==void 0&&v.userInfo.REF_LINK!==""&&(!v.twitchExtensionEnabled||v.twitchExtensionEnabled&&!v.editDiscordInfo&&!v.editTwitchInfo&&!v.editExchangeKeys)?(Ge(),bi("h3",KY,"Referred By: "+To(v.userInfo.REF_LINK),1)):tt("",!0),v.userInfo===null&&v.twitchUserInfo===null||v.userInfo!==null&&!(v.userInfo.REF_LINK!==null&&v.userInfo.REF_LINK!==void 0&&v.userInfo.REF_LINK!=="")?(Ge(),lt(Yn,{key:3,style:{margin:"2em auto 0 auto",width:"300px"},variant:"underlined","persistent-hint":"",hint:v.userInfo!==null?v.refLink.toLowerCase()===v.userInfo.TWITCH_CHANNEL.substring(1).toLowerCase()?"Can not refer yourself.":"Can not be changed once set.":"",label:"Referred By (Twitch Username)",modelValue:v.refLink,"onUpdate:modelValue":z[23]||(z[23]=X=>v.refLink=X)},vP({_:2},[v.userInfo!==null&&!(v.userInfo.REF_LINK!==null&&v.userInfo.REF_LINK!==void 0&&v.userInfo.REF_LINK!=="")?{name:"append-inner",fn:Be(()=>[$(ot,{disabled:v.refLink===""||v.refLink===null||v.refLink===void 0||v.refLink.toLowerCase()===v.userInfo.TWITCH_CHANNEL.substring(1).toLowerCase(),onClick:z[22]||(z[22]=X=>F(v.refLink)),variant:"text",icon:"mdi-content-save",color:"success"},null,8,["disabled"])]),key:"0"}:void 0]),1032,["hint","modelValue"])):tt("",!0),!v.twitchExtensionEnabled||v.twitchExtensionEnabled&&!v.editDiscordInfo&&!v.editTwitchInfo&&!v.editExchangeKeys?(Ge(),bi("div",XY)):tt("",!0),v.twitchUserInfo===null?(Ge(),lt(Fh,{key:5,class:"d-flex align-top justify-center"},{default:Be(()=>[$(id,{cols:"auto"},{default:Be(()=>[$(ot,{variant:"outlined",onClick:N,color:"rgb(169, 94, 171)"},{default:Be(()=>[et("Connect Twitch")]),_:1})]),_:1})]),_:1})):tt("",!0),v.twitchUserInfo!==null&&v.userInfo!==null&&(!v.twitchExtensionEnabled||v.twitchExtensionEnabled&&!v.editDiscordInfo&&!v.editTwitchInfo&&!v.editExchangeKeys)?(Ge(),lt(Fh,{key:6,class:"d-flex align-top justify-center"},{default:Be(()=>[$(id,{cols:"auto"},{default:Be(()=>[!v.twitchExtensionEnabled||v.twitchExtensionEnabled&&v.twitchAccessToken.channel_id!==void 0&&v.twitchAccessToken.channel_id===v.twitchUserInfo.id&&!v.editDiscordInfo&&!v.editTwitchInfo&&!v.editExchangeKeys?(Ge(),bi("div",YY,[$(qh,{label:(()=>v.userInfo.ENABLED?v.enabled===v.userInfo.ENABLED?"Account is Enabled":"Press Save to Disable":v.enabled===v.userInfo.ENABLED?"Account is Disabled":"Press Save to Enable")(),modelValue:v.enabled,"onUpdate:modelValue":z[24]||(z[24]=X=>v.enabled=X)},null,8,["label","modelValue"]),v.enabled!==v.userInfo.ENABLED?(Ge(),lt(ot,{key:0,variant:"outlined",color:"success",onClick:z[25]||(z[25]=X=>Oe())},{default:Be(()=>[et("Save ")]),_:1})):tt("",!0)])):tt("",!0)]),_:1})]),_:1})):tt("",!0),v.twitchUserInfo!==null&&v.userInfo!==null&&(!v.twitchExtensionEnabled||v.twitchExtensionEnabled&&!v.editDiscordInfo&&!v.editTwitchInfo&&!v.editExchangeKeys)?(Ge(),lt(Fh,{key:7,class:"d-flex align-top justify-center"},{default:Be(()=>[$(id,{cols:"auto"},{default:Be(()=>[v.userInfo.ENABLED&&(!v.twitchExtensionEnabled||v.twitchExtensionEnabled&&v.twitchAccessToken.channel_id!==void 0&&v.twitchAccessToken.channel_id===v.twitchUserInfo.id&&!v.editDiscordInfo&&!v.editTwitchInfo&&!v.editExchangeKeys)?(Ge(),bi("div",QY,[$(nu,{text:`${v.userInfo.IS_RUNNING?"Stop Bot from pulling data":"Start Bot from pulling data"}`,location:"bottom"},{activator:Be(({props:X})=>[v.twitchUserInfo!==null?(Ge(),lt(ot,Je({key:0},X,{variant:"outlined",icon:v.userInfo.IS_RUNNING?"mdi-stop":"mdi-play",disabled:!v.enabled,color:v.userInfo.IS_RUNNING?"error":"success",onClick:z[26]||(z[26]=()=>{v.userInfo.IS_RUNNING?b.value=!0:y.value=!0})}),null,16,["icon","disabled","color"])):tt("",!0)]),_:1},8,["text"])])):tt("",!0)]),_:1})]),_:1})):tt("",!0),v.twitchUserInfo!==null&&v.userInfo!==null?(Ge(),lt(Fh,{key:8,class:"d-flex align-top justify-center"},{default:Be(()=>[v.editExchangeKeys?(Ge(),lt(id,{key:0,cols:"auto",style:Pi(v.twitchExtensionEnabled?"width: 100%":"")},{default:Be(()=>[v.editExchangeKeys?(Ge(),bi("div",{key:0,style:Pi(`${v.twitchExtensionEnabled?"":"margin-top: 1em;"} padding: 1em; ${v.twitchExtensionEnabled?"background-color: rgba(255, 255, 255, 0.01)":""}`),class:"overflow-y-auto"},[ZY,(Ge(!0),bi(Ft,null,SP(v.exchangeKeys,(X,ne)=>(Ge(),bi("p",{style:{"margin-top":"1em"},key:"exchangeKey-"+ne},[mi("p",JY,[et("#"+To(ne+1)+" - "+To(X.EXCHANGE_ID)+" ",1),$(gi,{style:Pi(v.enabled?"cursor: pointer;":"cursor: default;"),onClick:te=>v.enabled?v.exchangeKeyOpen[ne]=!v.exchangeKeyOpen[ne]:""},{default:Be(()=>[et(To(v.exchangeKeyOpen[ne]===!0?"mdi-chevron-down":"mdi-chevron-up"),1)]),_:2},1032,["style","onClick"])]),v.exchangeKeyOpen[ne]?(Ge(),bi("div",eQ,[$(gY,{disabled:!O.value,variant:"underlined",style:{height:"auto"},density:"compact",label:"EXCHANGE",items:ei(Bz),modelValue:X.EXCHANGE_ID,"onUpdate:modelValue":te=>X.EXCHANGE_ID=te},null,8,["disabled","items","modelValue","onUpdate:modelValue"]),$(Yn,{disabled:!O.value,variant:"underlined",density:"compact",label:"DESCRIPTION",modelValue:X.DESCRIPTION,"onUpdate:modelValue":te=>X.DESCRIPTION=te},null,8,["disabled","modelValue","onUpdate:modelValue"]),$(Yn,{disabled:!O.value,variant:"underlined",density:"compact",label:"API KEY",modelValue:X.API_KEY,"onUpdate:modelValue":te=>X.API_KEY=te,type:"password"},null,8,["disabled","modelValue","onUpdate:modelValue"]),$(Yn,{disabled:!O.value,variant:"underlined",density:"compact",label:"API SECRET",modelValue:X.API_SECRET,"onUpdate:modelValue":te=>X.API_SECRET=te,type:"password"},null,8,["disabled","modelValue","onUpdate:modelValue"]),$(ot,{variant:"outlined",disabled:!O.value,style:Pi(`margin-bottom: 2em; ${v.twitchExtensionEnabled?"font-size: .75em":""}`),color:"error",onClick:()=>{v.exchangeKeys.splice(ne,1)}},{default:Be(()=>[et("Remove Exchange API Key #"+To(ne+1),1)]),_:2},1032,["disabled","style","onClick"])])):tt("",!0),$(dd)]))),128)),mi("p",tQ,[$(ot,{variant:"outlined",disabled:!O.value,color:"primary",onClick:z[27]||(z[27]=()=>{v.exchangeKeyOpen[v.exchangeKeys.push({KEY_ID:ei(HB)(),EXCHANGE_ID:"",API_KEY:"",API_SECRET:"",DESCRIPTION:""})-1]=!0})},{default:Be(()=>[et(" Add Exchange API Key")]),_:1},8,["disabled"])])],4)):tt("",!0),l.value?(Ge(),bi("div",sQ,[mi("p",iQ,[$(ot,{variant:"outlined",disabled:!v.enabled||o.value===ei(c),style:{margin:".25em"},color:"success",onClick:z[28]||(z[28]=X=>se())},{default:Be(()=>[et("Save Exchange Keys")]),_:1},8,["disabled"]),v.exchangeKeys.length!==v.userInfo.EXCHANGE_KEYS.length||o.value!==ei(c)?(Ge(),lt(ot,{key:0,variant:"outlined",disabled:!v.enabled,style:{margin:".25em"},color:"error",onClick:z[29]||(z[29]=X=>V())},{default:Be(()=>[et("Cancel")]),_:1},8,["disabled"])):(Ge(),lt(ot,{key:1,variant:"outlined",disabled:!v.enabled,style:{margin:".25em"},color:"error",onClick:z[30]||(z[30]=X=>v.editExchangeKeys=!v.editExchangeKeys)},{default:Be(()=>[et("Close")]),_:1},8,["disabled"]))])])):tt("",!0)]),_:1},8,["style"])):tt("",!0),v.editDiscordInfo?(Ge(),lt(id,{key:1,cols:"auto",style:Pi(v.twitchExtensionEnabled?"width: 100%":"")},{default:Be(()=>[v.editDiscordInfo?(Ge(),bi("div",{key:0,style:Pi(`margin-top: 1em; max-height: 400px; min-width: ${v.twitchExtensionEnabled?"0":"400px"}; padding: 1em;`),class:"overflow-y-auto"},[nQ,$(qh,{disabled:!v.enabled,label:"Discord Enabled",modelValue:v.discordEnabled,"onUpdate:modelValue":z[31]||(z[31]=X=>v.discordEnabled=X)},null,8,["disabled","modelValue"]),mi("div",rQ,[$(ot,{disabled:!v.enabled,color:"primary",target:"_blank",variant:"outlined",href:"https://discord.com/api/oauth2/authorize?client_id=1044389854236127262&permissions=83968&scope=bot"},{default:Be(()=>[et("Invite Discord Bot")]),_:1},8,["disabled"])]),$(Yn,{disabled:!v.enabled,variant:"underlined",density:"compact",label:"Discord Channel ID",modelValue:v.discordChannelId,"onUpdate:modelValue":z[32]||(z[32]=X=>v.discordChannelId=X)},null,8,["disabled","modelValue"]),$(Yn,{disabled:!v.enabled,variant:"underlined",density:"compact",label:"Discord Message ID",modelValue:v.discordMessageId,"onUpdate:modelValue":z[33]||(z[33]=X=>v.discordMessageId=X)},null,8,["disabled","modelValue"]),mi("p",null,[$(ot,{variant:"outlined",style:{margin:".25em"},color:"success",onClick:z[34]||(z[34]=X=>we()),disabled:!v.enabled||!(v.discordEnabled!==v.userInfo.DISCORD_ENABLED||v.discordChannelId!==v.userInfo.DISCORD_CHANNEL||v.discordMessageId!==v.userInfo.DISCORD_MESSAGE)},{default:Be(()=>[et(" Save")]),_:1},8,["disabled"]),v.discordEnabled!==v.userInfo.DISCORD_ENABLED||v.discordChannelId!==v.userInfo.DISCORD_CHANNEL||v.discordMessageId!==v.userInfo.DISCORD_MESSAGE?(Ge(),lt(ot,{key:0,variant:"outlined",disabled:!v.enabled,style:{margin:".25em"},color:"error",onClick:z[35]||(z[35]=X=>Q())},{default:Be(()=>[et(" Cancel")]),_:1},8,["disabled"])):tt("",!0),v.discordEnabled===v.userInfo.DISCORD_ENABLED&&v.discordChannelId===v.userInfo.DISCORD_CHANNEL&&v.discordMessageId===v.userInfo.DISCORD_MESSAGE?(Ge(),lt(ot,{key:1,variant:"outlined",disabled:!v.enabled,style:{margin:".25em"},color:"error",onClick:z[36]||(z[36]=X=>v.editDiscordInfo=!v.editDiscordInfo)},{default:Be(()=>[et(" Close")]),_:1},8,["disabled"])):tt("",!0)])],4)):tt("",!0)]),_:1},8,["style"])):tt("",!0),v.editTwitchInfo?(Ge(),lt(id,{key:2,cols:"auto",style:Pi(v.twitchExtensionEnabled?"width: 100%":"")},{default:Be(()=>[v.editTwitchInfo?(Ge(),bi("div",{key:0,style:Pi(`margin-top: 1em; max-height: 400px; min-width: ${v.twitchExtensionEnabled?"0":"400px"}; padding: 1em;`),class:"overflow-y-auto"},[aQ,$(qh,{disabled:!v.enabled,label:"Twitch Enabled",modelValue:C.value,"onUpdate:modelValue":z[37]||(z[37]=X=>C.value=X)},null,8,["disabled","modelValue"]),$(qh,{disabled:!v.enabled,label:"Timeout Enabled",modelValue:E.value,"onUpdate:modelValue":z[38]||(z[38]=X=>E.value=X)},null,8,["disabled","modelValue"]),!v.twitchExtensionEnabled||v.twitchExtensionEnabled&&v.twitchAccessToken.channel_id!==void 0&&v.twitchAccessToken.channel_id===v.twitchUserInfo.id?(Ge(),bi("div",oQ,[v.connectedToTwitchChannel?(Ge(),lt(ot,{key:1,disabled:!v.enabled,color:"error",style:Pi(`margin-bottom: 2em; ${v.twitchExtensionEnabled?"font-size: .75em":""}`),variant:"outlined",onClick:z[40]||(z[40]=X=>j())},{default:Be(()=>[et("Disconnect Twitch Channel ")]),_:1},8,["disabled","style"])):(Ge(),lt(ot,{key:0,color:"primary",style:{"margin-bottom":"2em"},variant:"outlined",onClick:z[39]||(z[39]=X=>D())},{default:Be(()=>[et("Connect To Twitch Channel ")]),_:1}))])):tt("",!0),$(Yn,{disabled:!v.enabled,variant:"underlined",density:"compact",type:"number",label:"Command Timeout Length (minutes)",modelValue:v.twitchTimeoutLength,"onUpdate:modelValue":z[41]||(z[41]=X=>v.twitchTimeoutLength=X)},null,8,["disabled","modelValue"]),mi("p",null,[$(ot,{variant:"outlined",style:{margin:".25em"},color:"success",onClick:z[42]||(z[42]=X=>le()),disabled:!O.value||!(v.twitchEnabled!==I.value.TWITCH_ENABLED||E.value!==I.value.TWITCH_TIMEOUT||Number.parseFloat(P.value.toString())!==Number.parseFloat(I.value.TWITCH_TIMEOUT_EXPIRE.toString()))},{default:Be(()=>[et(" Save")]),_:1},8,["disabled"]),v.twitchEnabled!==I.value.TWITCH_ENABLED||E.value!==I.value.TWITCH_TIMEOUT||Number.parseFloat(P.value.toString())!==Number.parseFloat(I.value.TWITCH_TIMEOUT_EXPIRE.toString())?(Ge(),lt(ot,{key:0,variant:"outlined",disabled:!v.enabled,style:{margin:".25em"},color:"error",onClick:z[43]||(z[43]=X=>J())},{default:Be(()=>[et(" Cancel")]),_:1},8,["disabled"])):tt("",!0),C.value!==I.value.TWITCH_ENABLED||E.value!==I.value.TWITCH_TIMEOUT||Number.parseFloat(P.value.toString())!==Number.parseFloat(I.value.TWITCH_TIMEOUT_EXPIRE.toString())?tt("",!0):(Ge(),lt(ot,{key:1,variant:"outlined",disabled:!v.enabled,style:{margin:".25em"},color:"error",onClick:z[44]||(z[44]=X=>v.editTwitchInfo=!v.editTwitchInfo)},{default:Be(()=>[et(" Close")]),_:1},8,["disabled"]))])],4)):tt("",!0)]),_:1},8,["style"])):tt("",!0)]),_:1})):tt("",!0)]),_:1})]),_:1})]),_:1}),v.twitchExtensionEnabled?tt("",!0):(Ge(),lt(wY,{key:2,app:"",style:{"max-height":"1.5em"}},{default:Be(()=>[et(" CryptoPositionsBot 2022 ")]),_:1}))]),_:1}))}});const cQ="modulepreload",uQ=function(f,e){return new URL(f,e).href},uI={},fQ=function(e,t,s){if(!t||t.length===0)return e();const i=document.getElementsByTagName("link");return Promise.all(t.map(n=>{if(n=uQ(n,s),n in uI)return;uI[n]=!0;const r=n.endsWith(".css"),a=r?'[rel="stylesheet"]':"";if(!!s)for(let c=i.length-1;c>=0;c--){const u=i[c];if(u.href===n&&(!r||u.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${n}"]${a}`))return;const d=document.createElement("link");if(d.rel=r?"stylesheet":cQ,r||(d.as="script",d.crossOrigin=""),d.href=n,document.head.appendChild(d),r)return new Promise((c,u)=>{d.addEventListener("load",c),d.addEventListener("error",()=>u(new Error(`Unable to preload CSS for ${n}`)))})})).then(()=>e())};async function hQ(){(await fQ(()=>import("./webfontloader.b777d690.js").then(e=>e.w),[],import.meta.url)).load({google:{families:["Roboto:100,300,400,500,700,900&display=swap"]}})}function J2(){let f=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};const{blueprint:e,...t}=f,s=xr(e,t),{aliases:i={},components:n={},directives:r={}}=s,a=iK(s.defaults),o=BY(s.display,s.ssr),d=kK(s.theme),c=AK(s.icons),u=jK(s.locale);return{install:l=>{for(const p in r)l.directive(p,r[p]);for(const p in n)l.component(p,n[p]);for(const p in i)l.component(p,Qe({...i[p],name:p,aliasName:i[p].name}));if(d.install(l),l.provide(Mu,a),l.provide(qy,o),l.provide(cl,d),l.provide(_y,c),l.provide(fl,u),ds&&s.ssr)if(l.$nuxt)l.$nuxt.hook("app:suspense:resolve",()=>{o.update()});else{const{mount:p}=l;l.mount=function(){const m=p(...arguments);return Bi(()=>o.update()),l.mount=p,m}}$i.reset(),l.mixin({computed:{$vuetify(){return ti({defaults:ru.call(this,Mu),display:ru.call(this,qy),theme:ru.call(this,cl),icons:ru.call(this,_y),locale:ru.call(this,fl)})}}})},defaults:a,display:o,theme:d,icons:c,locale:u}}const lQ="3.0.2";J2.version=lQ;function ru(f){var n;var e,t;const s=this.$,i=(n=(e=s.parent)==null?void 0:e.provides)!=null?n:(t=s.vnode.appContext)==null?void 0:t.provides;if(i&&f in i)return i[f]}const pQ=J2({theme:{defaultTheme:"dark"}});function mQ(f){hQ(),f.use(pQ)}const eM=BA(dQ);mQ(eM);eM.mount("#app");
